(self.webpackChunkregal_ui_docs=self.webpackChunkregal_ui_docs||[]).push([[481],{17833:(module,exports,__webpack_require__)=>{eval("/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = __webpack_require__(40736)(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4MzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixZQUFZO0FBQ1osWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBNEM7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxLQUFVOztBQUVuQyxPQUFPLFlBQVk7O0FBRW5CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcz9hNTNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRsZXQgbTtcblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pKSAmJiBwYXJzZUludChtWzFdLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17833\n")},40736:(module,__unused_webpack_exports,__webpack_require__)=>{eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = __webpack_require__(6585);\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA3MzYuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsSUFBSTtBQUNwQzs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcz9kNTAwIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40736\n")},97627:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nmodule.exports = __webpack_require__(14652);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc2MjcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiwyQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2dsb2JhbHMvaW5kZXguanM/ODU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZ2xvYmFscy5qc29uJyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97627\n")},65879:(__unused_webpack_module,exports)=>{eval('// Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell\n// License: MIT. (See LICENSE.)\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}))\n\n// This regex comes from regex.coffee, and is inserted here by generate-index.js\n// (run `npm run build`).\nexports["default"] = /(([\'"])(?:(?!\\2|\\\\).|\\\\(?:\\r\\n|[\\s\\S]))*(\\2)?|`(?:[^`\\\\$]|\\\\[\\s\\S]|\\$(?!\\{)|\\$\\{(?:[^{}]|\\{[^}]*\\}?)*\\}?)*(`)?)|(\\/\\/.*)|(\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?)|(\\/(?!\\*)(?:\\[(?:(?![\\]\\\\]).|\\\\.)*\\]|(?![\\/\\]\\\\]).|\\\\.)+\\/(?:(?!\\s*(?:\\b|[\\u0080-\\uFFFF$\\\\\'"~({]|[+\\-!](?!=)|\\.?\\d))|[gmiyus]{1,6}\\b(?![\\u0080-\\uFFFF$\\\\]|\\s*(?:[+\\-*%&|^<>!=?({]|\\/(?![\\/*])))))|(0[xX][\\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][+-]?\\d+)?)|((?!\\d)(?:(?!\\s)[$\\w\\u0080-\\uFFFF]|\\\\u[\\da-fA-F]{4}|\\\\u\\{[\\da-fA-F]+\\})+)|(--|\\+\\+|&&|\\|\\||=>|\\.{3}|(?:[+\\-\\/%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\\](){}])|(\\s+)|(^$|[\\s\\S])/g\n\nexports.matchToToken = function(match) {\n  var token = {type: "invalid", value: match[0], closed: undefined}\n       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4])\n  else if (match[ 5]) token.type = "comment"\n  else if (match[ 6]) token.type = "comment", token.closed = !!match[7]\n  else if (match[ 8]) token.type = "regex"\n  else if (match[ 9]) token.type = "number"\n  else if (match[10]) token.type = "name"\n  else if (match[11]) token.type = "punctuator"\n  else if (match[12]) token.type = "whitespace"\n  return token\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4NzkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQSw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBLGtCQUFlLDhFQUE4RSxNQUFNLE9BQU8sSUFBSSxHQUFHLElBQUksS0FBSyxpSkFBaUosK0JBQStCLElBQUksOENBQThDLGtKQUFrSixFQUFFLE1BQU0sYUFBYSwyQkFBMkIsRUFBRSxtQkFBbUIsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLE9BQU8sSUFBSSxXQUFXLE9BQU87O0FBRWxtQixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9qcy10b2tlbnMvaW5kZXguanM/NjhhYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAxNCwgMjAxNSwgMjAxNiwgMjAxNywgMjAxOCBTaW1vbiBMeWRlbGxcbi8vIExpY2Vuc2U6IE1JVC4gKFNlZSBMSUNFTlNFLilcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KVxuXG4vLyBUaGlzIHJlZ2V4IGNvbWVzIGZyb20gcmVnZXguY29mZmVlLCBhbmQgaXMgaW5zZXJ0ZWQgaGVyZSBieSBnZW5lcmF0ZS1pbmRleC5qc1xuLy8gKHJ1biBgbnBtIHJ1biBidWlsZGApLlxuZXhwb3J0cy5kZWZhdWx0ID0gLygoWydcIl0pKD86KD8hXFwyfFxcXFwpLnxcXFxcKD86XFxyXFxufFtcXHNcXFNdKSkqKFxcMik/fGAoPzpbXmBcXFxcJF18XFxcXFtcXHNcXFNdfFxcJCg/IVxceyl8XFwkXFx7KD86W157fV18XFx7W159XSpcXH0/KSpcXH0/KSooYCk/KXwoXFwvXFwvLiopfChcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKihcXCpcXC8pPyl8KFxcLyg/IVxcKikoPzpcXFsoPzooPyFbXFxdXFxcXF0pLnxcXFxcLikqXFxdfCg/IVtcXC9cXF1cXFxcXSkufFxcXFwuKStcXC8oPzooPyFcXHMqKD86XFxifFtcXHUwMDgwLVxcdUZGRkYkXFxcXCdcIn4oe118WytcXC0hXSg/IT0pfFxcLj9cXGQpKXxbZ21peXVzXXsxLDZ9XFxiKD8hW1xcdTAwODAtXFx1RkZGRiRcXFxcXXxcXHMqKD86WytcXC0qJSZ8Xjw+IT0/KHtdfFxcLyg/IVtcXC8qXSkpKSkpfCgwW3hYXVtcXGRhLWZBLUZdK3wwW29PXVswLTddK3wwW2JCXVswMV0rfCg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPyl8KCg/IVxcZCkoPzooPyFcXHMpWyRcXHdcXHUwMDgwLVxcdUZGRkZdfFxcXFx1W1xcZGEtZkEtRl17NH18XFxcXHVcXHtbXFxkYS1mQS1GXStcXH0pKyl8KC0tfFxcK1xcK3wmJnxcXHxcXHx8PT58XFwuezN9fCg/OlsrXFwtXFwvJSZ8Xl18XFwqezEsMn18PHsxLDJ9fD57MSwzfXwhPT98PXsxLDJ9KT0/fFs/fi4sOjtbXFxdKCl7fV0pfChcXHMrKXwoXiR8W1xcc1xcU10pL2dcblxuZXhwb3J0cy5tYXRjaFRvVG9rZW4gPSBmdW5jdGlvbihtYXRjaCkge1xuICB2YXIgdG9rZW4gPSB7dHlwZTogXCJpbnZhbGlkXCIsIHZhbHVlOiBtYXRjaFswXSwgY2xvc2VkOiB1bmRlZmluZWR9XG4gICAgICAgaWYgKG1hdGNoWyAxXSkgdG9rZW4udHlwZSA9IFwic3RyaW5nXCIgLCB0b2tlbi5jbG9zZWQgPSAhIShtYXRjaFszXSB8fCBtYXRjaFs0XSlcbiAgZWxzZSBpZiAobWF0Y2hbIDVdKSB0b2tlbi50eXBlID0gXCJjb21tZW50XCJcbiAgZWxzZSBpZiAobWF0Y2hbIDZdKSB0b2tlbi50eXBlID0gXCJjb21tZW50XCIsIHRva2VuLmNsb3NlZCA9ICEhbWF0Y2hbN11cbiAgZWxzZSBpZiAobWF0Y2hbIDhdKSB0b2tlbi50eXBlID0gXCJyZWdleFwiXG4gIGVsc2UgaWYgKG1hdGNoWyA5XSkgdG9rZW4udHlwZSA9IFwibnVtYmVyXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTBdKSB0b2tlbi50eXBlID0gXCJuYW1lXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTFdKSB0b2tlbi50eXBlID0gXCJwdW5jdHVhdG9yXCJcbiAgZWxzZSBpZiAobWF0Y2hbMTJdKSB0b2tlbi50eXBlID0gXCJ3aGl0ZXNwYWNlXCJcbiAgcmV0dXJuIHRva2VuXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///65879\n')},17159:module=>{"use strict";eval("\n\nconst object = {};\nconst hasOwnProperty = object.hasOwnProperty;\nconst forOwn = (object, callback) => {\n\tfor (const key in object) {\n\t\tif (hasOwnProperty.call(object, key)) {\n\t\t\tcallback(key, object[key]);\n\t\t}\n\t}\n};\n\nconst extend = (destination, source) => {\n\tif (!source) {\n\t\treturn destination;\n\t}\n\tforOwn(source, (key, value) => {\n\t\tdestination[key] = value;\n\t});\n\treturn destination;\n};\n\nconst forEach = (array, callback) => {\n\tconst length = array.length;\n\tlet index = -1;\n\twhile (++index < length) {\n\t\tcallback(array[index]);\n\t}\n};\n\nconst fourHexEscape = (hex) => {\n\treturn '\\\\u' + ('0000' + hex).slice(-4);\n}\n\nconst hexadecimal = (code, lowercase) => {\n\tlet hexadecimal = code.toString(16);\n\tif (lowercase) return hexadecimal;\n\treturn hexadecimal.toUpperCase();\n};\n\nconst toString = object.toString;\nconst isArray = Array.isArray;\nconst isBuffer = (value) => {\n\treturn typeof Buffer === 'function' && Buffer.isBuffer(value);\n};\nconst isObject = (value) => {\n\t// This is a very simple check, but it\u2019s good enough for what we need.\n\treturn toString.call(value) == '[object Object]';\n};\nconst isString = (value) => {\n\treturn typeof value == 'string' ||\n\t\ttoString.call(value) == '[object String]';\n};\nconst isNumber = (value) => {\n\treturn typeof value == 'number' ||\n\t\ttoString.call(value) == '[object Number]';\n};\nconst isFunction = (value) => {\n\treturn typeof value == 'function';\n};\nconst isMap = (value) => {\n\treturn toString.call(value) == '[object Map]';\n};\nconst isSet = (value) => {\n\treturn toString.call(value) == '[object Set]';\n};\n\n/*--------------------------------------------------------------------------*/\n\n// https://mathiasbynens.be/notes/javascript-escapes#single\nconst singleEscapes = {\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t'\n\t// `\\v` is omitted intentionally, because in IE < 9, '\\v' == 'v'.\n\t// '\\v': '\\\\x0B'\n};\nconst regexSingleEscape = /[\\\\\\b\\f\\n\\r\\t]/;\n\nconst regexDigit = /[0-9]/;\nconst regexWhitespace = /[\\xA0\\u1680\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000]/;\n\nconst escapeEverythingRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^]/g;\nconst escapeNonAsciiRegex = /([\\uD800-\\uDBFF][\\uDC00-\\uDFFF])|([\\uD800-\\uDFFF])|(['\"`])|[^ !#-&\\(-\\[\\]-_a-~]/g;\n\nconst jsesc = (argument, options) => {\n\tconst increaseIndentation = () => {\n\t\toldIndent = indent;\n\t\t++options.indentLevel;\n\t\tindent = options.indent.repeat(options.indentLevel)\n\t};\n\t// Handle options\n\tconst defaults = {\n\t\t'escapeEverything': false,\n\t\t'minimal': false,\n\t\t'isScriptContext': false,\n\t\t'quotes': 'single',\n\t\t'wrap': false,\n\t\t'es6': false,\n\t\t'json': false,\n\t\t'compact': true,\n\t\t'lowercaseHex': false,\n\t\t'numbers': 'decimal',\n\t\t'indent': '\\t',\n\t\t'indentLevel': 0,\n\t\t'__inline1__': false,\n\t\t'__inline2__': false\n\t};\n\tconst json = options && options.json;\n\tif (json) {\n\t\tdefaults.quotes = 'double';\n\t\tdefaults.wrap = true;\n\t}\n\toptions = extend(defaults, options);\n\tif (\n\t\toptions.quotes != 'single' &&\n\t\toptions.quotes != 'double' &&\n\t\toptions.quotes != 'backtick'\n\t) {\n\t\toptions.quotes = 'single';\n\t}\n\tconst quote = options.quotes == 'double' ?\n\t\t'\"' :\n\t\t(options.quotes == 'backtick' ?\n\t\t\t'`' :\n\t\t\t'\\''\n\t\t);\n\tconst compact = options.compact;\n\tconst lowercaseHex = options.lowercaseHex;\n\tlet indent = options.indent.repeat(options.indentLevel);\n\tlet oldIndent = '';\n\tconst inline1 = options.__inline1__;\n\tconst inline2 = options.__inline2__;\n\tconst newLine = compact ? '' : '\\n';\n\tlet result;\n\tlet isEmpty = true;\n\tconst useBinNumbers = options.numbers == 'binary';\n\tconst useOctNumbers = options.numbers == 'octal';\n\tconst useDecNumbers = options.numbers == 'decimal';\n\tconst useHexNumbers = options.numbers == 'hexadecimal';\n\n\tif (json && argument && isFunction(argument.toJSON)) {\n\t\targument = argument.toJSON();\n\t}\n\n\tif (!isString(argument)) {\n\t\tif (isMap(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Map()';\n\t\t\t}\n\t\t\tif (!compact) {\n\t\t\t\toptions.__inline1__ = true;\n\t\t\t\toptions.__inline2__ = false;\n\t\t\t}\n\t\t\treturn 'new Map(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isSet(argument)) {\n\t\t\tif (argument.size == 0) {\n\t\t\t\treturn 'new Set()';\n\t\t\t}\n\t\t\treturn 'new Set(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isBuffer(argument)) {\n\t\t\tif (argument.length == 0) {\n\t\t\t\treturn 'Buffer.from([])';\n\t\t\t}\n\t\t\treturn 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';\n\t\t}\n\t\tif (isArray(argument)) {\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tif (inline1) {\n\t\t\t\toptions.__inline1__ = false;\n\t\t\t\toptions.__inline2__ = true;\n\t\t\t}\n\t\t\tif (!inline2) {\n\t\t\t\tincreaseIndentation();\n\t\t\t}\n\t\t\tforEach(argument, (value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tif (inline2) {\n\t\t\t\t\toptions.__inline2__ = false;\n\t\t\t\t}\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact || inline2 ? '' : indent) +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '[]';\n\t\t\t}\n\t\t\tif (inline2) {\n\t\t\t\treturn '[' + result.join(', ') + ']';\n\t\t\t}\n\t\t\treturn '[' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + ']';\n\t\t} else if (isNumber(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// Some number values (e.g. `Infinity`) cannot be represented in JSON.\n\t\t\t\treturn JSON.stringify(argument);\n\t\t\t}\n\t\t\tif (useDecNumbers) {\n\t\t\t\treturn String(argument);\n\t\t\t}\n\t\t\tif (useHexNumbers) {\n\t\t\t\tlet hexadecimal = argument.toString(16);\n\t\t\t\tif (!lowercaseHex) {\n\t\t\t\t\thexadecimal = hexadecimal.toUpperCase();\n\t\t\t\t}\n\t\t\t\treturn '0x' + hexadecimal;\n\t\t\t}\n\t\t\tif (useBinNumbers) {\n\t\t\t\treturn '0b' + argument.toString(2);\n\t\t\t}\n\t\t\tif (useOctNumbers) {\n\t\t\t\treturn '0o' + argument.toString(8);\n\t\t\t}\n\t\t} else if (!isObject(argument)) {\n\t\t\tif (json) {\n\t\t\t\t// For some values (e.g. `undefined`, `function` objects),\n\t\t\t\t// `JSON.stringify(value)` returns `undefined` (which isn\u2019t valid\n\t\t\t\t// JSON) instead of `'null'`.\n\t\t\t\treturn JSON.stringify(argument) || 'null';\n\t\t\t}\n\t\t\treturn String(argument);\n\t\t} else { // it\u2019s an object\n\t\t\tresult = [];\n\t\t\toptions.wrap = true;\n\t\t\tincreaseIndentation();\n\t\t\tforOwn(argument, (key, value) => {\n\t\t\t\tisEmpty = false;\n\t\t\t\tresult.push(\n\t\t\t\t\t(compact ? '' : indent) +\n\t\t\t\t\tjsesc(key, options) + ':' +\n\t\t\t\t\t(compact ? '' : ' ') +\n\t\t\t\t\tjsesc(value, options)\n\t\t\t\t);\n\t\t\t});\n\t\t\tif (isEmpty) {\n\t\t\t\treturn '{}';\n\t\t\t}\n\t\t\treturn '{' + newLine + result.join(',' + newLine) + newLine +\n\t\t\t\t(compact ? '' : oldIndent) + '}';\n\t\t}\n\t}\n\n\tconst regex = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;\n\tresult = argument.replace(regex, (char, pair, lone, quoteChar, index, string) => {\n\t\tif (pair) {\n\t\t\tif (options.minimal) return pair;\n\t\t\tconst first = pair.charCodeAt(0);\n\t\t\tconst second = pair.charCodeAt(1);\n\t\t\tif (options.es6) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tconst codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t\t\t\tconst hex = hexadecimal(codePoint, lowercaseHex);\n\t\t\t\treturn '\\\\u{' + hex + '}';\n\t\t\t}\n\t\t\treturn fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));\n\t\t}\n\n\t\tif (lone) {\n\t\t\treturn fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));\n\t\t}\n\n\t\tif (\n\t\t\tchar == '\\0' &&\n\t\t\t!json &&\n\t\t\t!regexDigit.test(string.charAt(index + 1))\n\t\t) {\n\t\t\treturn '\\\\0';\n\t\t}\n\n\t\tif (quoteChar) {\n\t\t\tif (quoteChar == quote || options.escapeEverything) {\n\t\t\t\treturn '\\\\' + quoteChar;\n\t\t\t}\n\t\t\treturn quoteChar;\n\t\t}\n\n\t\tif (regexSingleEscape.test(char)) {\n\t\t\t// no need for a `hasOwnProperty` check here\n\t\t\treturn singleEscapes[char];\n\t\t}\n\n\t\tif (options.minimal && !regexWhitespace.test(char)) {\n\t\t\treturn char;\n\t\t}\n\n\t\tconst hex = hexadecimal(char.charCodeAt(0), lowercaseHex);\n\t\tif (json || hex.length > 2) {\n\t\t\treturn fourHexEscape(hex);\n\t\t}\n\n\t\treturn '\\\\x' + ('00' + hex).slice(-2);\n\t});\n\n\tif (quote == '`') {\n\t\tresult = result.replace(/\\$\\{/g, '\\\\${');\n\t}\n\tif (options.isScriptContext) {\n\t\t// https://mathiasbynens.be/notes/etago\n\t\tresult = result\n\t\t\t.replace(/<\\/(script|style)/gi, '<\\\\/$1')\n\t\t\t.replace(/\x3c!--/g, json ? '\\\\u003C!--' : '\\\\x3C!--');\n\t}\n\tif (options.wrap) {\n\t\tresult = quote + result + quote;\n\t}\n\treturn result;\n};\n\njsesc.version = '3.0.2';\n\nmodule.exports = jsesc;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxNTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksT0FBTztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxZQUFZO0FBQ1osbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0EsK0JBQStCLFNBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9qc2VzYy9qc2VzYy5qcz9mMmU3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qgb2JqZWN0ID0ge307XG5jb25zdCBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcbmNvbnN0IGZvck93biA9IChvYmplY3QsIGNhbGxiYWNrKSA9PiB7XG5cdGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuXHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuXHRcdFx0Y2FsbGJhY2soa2V5LCBvYmplY3Rba2V5XSk7XG5cdFx0fVxuXHR9XG59O1xuXG5jb25zdCBleHRlbmQgPSAoZGVzdGluYXRpb24sIHNvdXJjZSkgPT4ge1xuXHRpZiAoIXNvdXJjZSkge1xuXHRcdHJldHVybiBkZXN0aW5hdGlvbjtcblx0fVxuXHRmb3JPd24oc291cmNlLCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdGRlc3RpbmF0aW9uW2tleV0gPSB2YWx1ZTtcblx0fSk7XG5cdHJldHVybiBkZXN0aW5hdGlvbjtcbn07XG5cbmNvbnN0IGZvckVhY2ggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG5cdGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0bGV0IGluZGV4ID0gLTE7XG5cdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0Y2FsbGJhY2soYXJyYXlbaW5kZXhdKTtcblx0fVxufTtcblxuY29uc3QgZm91ckhleEVzY2FwZSA9IChoZXgpID0+IHtcblx0cmV0dXJuICdcXFxcdScgKyAoJzAwMDAnICsgaGV4KS5zbGljZSgtNCk7XG59XG5cbmNvbnN0IGhleGFkZWNpbWFsID0gKGNvZGUsIGxvd2VyY2FzZSkgPT4ge1xuXHRsZXQgaGV4YWRlY2ltYWwgPSBjb2RlLnRvU3RyaW5nKDE2KTtcblx0aWYgKGxvd2VyY2FzZSkgcmV0dXJuIGhleGFkZWNpbWFsO1xuXHRyZXR1cm4gaGV4YWRlY2ltYWwudG9VcHBlckNhc2UoKTtcbn07XG5cbmNvbnN0IHRvU3RyaW5nID0gb2JqZWN0LnRvU3RyaW5nO1xuY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5jb25zdCBpc0J1ZmZlciA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIuaXNCdWZmZXIodmFsdWUpO1xufTtcbmNvbnN0IGlzT2JqZWN0ID0gKHZhbHVlKSA9PiB7XG5cdC8vIFRoaXMgaXMgYSB2ZXJ5IHNpbXBsZSBjaGVjaywgYnV0IGl04oCZcyBnb29kIGVub3VnaCBmb3Igd2hhdCB3ZSBuZWVkLlxuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59O1xuY29uc3QgaXNTdHJpbmcgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuXHRcdHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcbmNvbnN0IGlzTnVtYmVyID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcblx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJztcbn07XG5jb25zdCBpc01hcCA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTWFwXSc7XG59O1xuY29uc3QgaXNTZXQgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IFNldF0nO1xufTtcblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVzY2FwZXMjc2luZ2xlXG5jb25zdCBzaW5nbGVFc2NhcGVzID0ge1xuXHQnXFxcXCc6ICdcXFxcXFxcXCcsXG5cdCdcXGInOiAnXFxcXGInLFxuXHQnXFxmJzogJ1xcXFxmJyxcblx0J1xcbic6ICdcXFxcbicsXG5cdCdcXHInOiAnXFxcXHInLFxuXHQnXFx0JzogJ1xcXFx0J1xuXHQvLyBgXFx2YCBpcyBvbWl0dGVkIGludGVudGlvbmFsbHksIGJlY2F1c2UgaW4gSUUgPCA5LCAnXFx2JyA9PSAndicuXG5cdC8vICdcXHYnOiAnXFxcXHgwQidcbn07XG5jb25zdCByZWdleFNpbmdsZUVzY2FwZSA9IC9bXFxcXFxcYlxcZlxcblxcclxcdF0vO1xuXG5jb25zdCByZWdleERpZ2l0ID0gL1swLTldLztcbmNvbnN0IHJlZ2V4V2hpdGVzcGFjZSA9IC9bXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyOFxcdTIwMjlcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLztcblxuY29uc3QgZXNjYXBlRXZlcnl0aGluZ1JlZ2V4ID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKXwoW1xcdUQ4MDAtXFx1REZGRl0pfChbJ1wiYF0pfFteXS9nO1xuY29uc3QgZXNjYXBlTm9uQXNjaWlSZWdleCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl8KFtcXHVEODAwLVxcdURGRkZdKXwoWydcImBdKXxbXiAhIy0mXFwoLVxcW1xcXS1fYS1+XS9nO1xuXG5jb25zdCBqc2VzYyA9IChhcmd1bWVudCwgb3B0aW9ucykgPT4ge1xuXHRjb25zdCBpbmNyZWFzZUluZGVudGF0aW9uID0gKCkgPT4ge1xuXHRcdG9sZEluZGVudCA9IGluZGVudDtcblx0XHQrK29wdGlvbnMuaW5kZW50TGV2ZWw7XG5cdFx0aW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpXG5cdH07XG5cdC8vIEhhbmRsZSBvcHRpb25zXG5cdGNvbnN0IGRlZmF1bHRzID0ge1xuXHRcdCdlc2NhcGVFdmVyeXRoaW5nJzogZmFsc2UsXG5cdFx0J21pbmltYWwnOiBmYWxzZSxcblx0XHQnaXNTY3JpcHRDb250ZXh0JzogZmFsc2UsXG5cdFx0J3F1b3Rlcyc6ICdzaW5nbGUnLFxuXHRcdCd3cmFwJzogZmFsc2UsXG5cdFx0J2VzNic6IGZhbHNlLFxuXHRcdCdqc29uJzogZmFsc2UsXG5cdFx0J2NvbXBhY3QnOiB0cnVlLFxuXHRcdCdsb3dlcmNhc2VIZXgnOiBmYWxzZSxcblx0XHQnbnVtYmVycyc6ICdkZWNpbWFsJyxcblx0XHQnaW5kZW50JzogJ1xcdCcsXG5cdFx0J2luZGVudExldmVsJzogMCxcblx0XHQnX19pbmxpbmUxX18nOiBmYWxzZSxcblx0XHQnX19pbmxpbmUyX18nOiBmYWxzZVxuXHR9O1xuXHRjb25zdCBqc29uID0gb3B0aW9ucyAmJiBvcHRpb25zLmpzb247XG5cdGlmIChqc29uKSB7XG5cdFx0ZGVmYXVsdHMucXVvdGVzID0gJ2RvdWJsZSc7XG5cdFx0ZGVmYXVsdHMud3JhcCA9IHRydWU7XG5cdH1cblx0b3B0aW9ucyA9IGV4dGVuZChkZWZhdWx0cywgb3B0aW9ucyk7XG5cdGlmIChcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnc2luZ2xlJyAmJlxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnICYmXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ2JhY2t0aWNrJ1xuXHQpIHtcblx0XHRvcHRpb25zLnF1b3RlcyA9ICdzaW5nbGUnO1xuXHR9XG5cdGNvbnN0IHF1b3RlID0gb3B0aW9ucy5xdW90ZXMgPT0gJ2RvdWJsZScgP1xuXHRcdCdcIicgOlxuXHRcdChvcHRpb25zLnF1b3RlcyA9PSAnYmFja3RpY2snID9cblx0XHRcdCdgJyA6XG5cdFx0XHQnXFwnJ1xuXHRcdCk7XG5cdGNvbnN0IGNvbXBhY3QgPSBvcHRpb25zLmNvbXBhY3Q7XG5cdGNvbnN0IGxvd2VyY2FzZUhleCA9IG9wdGlvbnMubG93ZXJjYXNlSGV4O1xuXHRsZXQgaW5kZW50ID0gb3B0aW9ucy5pbmRlbnQucmVwZWF0KG9wdGlvbnMuaW5kZW50TGV2ZWwpO1xuXHRsZXQgb2xkSW5kZW50ID0gJyc7XG5cdGNvbnN0IGlubGluZTEgPSBvcHRpb25zLl9faW5saW5lMV9fO1xuXHRjb25zdCBpbmxpbmUyID0gb3B0aW9ucy5fX2lubGluZTJfXztcblx0Y29uc3QgbmV3TGluZSA9IGNvbXBhY3QgPyAnJyA6ICdcXG4nO1xuXHRsZXQgcmVzdWx0O1xuXHRsZXQgaXNFbXB0eSA9IHRydWU7XG5cdGNvbnN0IHVzZUJpbk51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2JpbmFyeSc7XG5cdGNvbnN0IHVzZU9jdE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ29jdGFsJztcblx0Y29uc3QgdXNlRGVjTnVtYmVycyA9IG9wdGlvbnMubnVtYmVycyA9PSAnZGVjaW1hbCc7XG5cdGNvbnN0IHVzZUhleE51bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2hleGFkZWNpbWFsJztcblxuXHRpZiAoanNvbiAmJiBhcmd1bWVudCAmJiBpc0Z1bmN0aW9uKGFyZ3VtZW50LnRvSlNPTikpIHtcblx0XHRhcmd1bWVudCA9IGFyZ3VtZW50LnRvSlNPTigpO1xuXHR9XG5cblx0aWYgKCFpc1N0cmluZyhhcmd1bWVudCkpIHtcblx0XHRpZiAoaXNNYXAoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnbmV3IE1hcCgpJztcblx0XHRcdH1cblx0XHRcdGlmICghY29tcGFjdCkge1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMV9fID0gdHJ1ZTtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgTWFwKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc1NldChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5zaXplID09IDApIHtcblx0XHRcdFx0cmV0dXJuICduZXcgU2V0KCknO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICduZXcgU2V0KCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0J1ZmZlcihhcmd1bWVudCkpIHtcblx0XHRcdGlmIChhcmd1bWVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKFtdKSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ0J1ZmZlci5mcm9tKCcgKyBqc2VzYyhBcnJheS5mcm9tKGFyZ3VtZW50KSwgb3B0aW9ucykgKyAnKSc7XG5cdFx0fVxuXHRcdGlmIChpc0FycmF5KGFyZ3VtZW50KSkge1xuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aWYgKGlubGluZTEpIHtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTFfXyA9IGZhbHNlO1xuXHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICghaW5saW5lMikge1xuXHRcdFx0XHRpbmNyZWFzZUluZGVudGF0aW9uKCk7XG5cdFx0XHR9XG5cdFx0XHRmb3JFYWNoKGFyZ3VtZW50LCAodmFsdWUpID0+IHtcblx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHQoY29tcGFjdCB8fCBpbmxpbmUyID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyh2YWx1ZSwgb3B0aW9ucylcblx0XHRcdFx0KTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKGlzRW1wdHkpIHtcblx0XHRcdFx0cmV0dXJuICdbXSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaW5saW5lMikge1xuXHRcdFx0XHRyZXR1cm4gJ1snICsgcmVzdWx0LmpvaW4oJywgJykgKyAnXSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gJ1snICsgbmV3TGluZSArIHJlc3VsdC5qb2luKCcsJyArIG5ld0xpbmUpICsgbmV3TGluZSArXG5cdFx0XHRcdChjb21wYWN0ID8gJycgOiBvbGRJbmRlbnQpICsgJ10nO1xuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoanNvbikge1xuXHRcdFx0XHQvLyBTb21lIG51bWJlciB2YWx1ZXMgKGUuZy4gYEluZmluaXR5YCkgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04uXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlRGVjTnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VIZXhOdW1iZXJzKSB7XG5cdFx0XHRcdGxldCBoZXhhZGVjaW1hbCA9IGFyZ3VtZW50LnRvU3RyaW5nKDE2KTtcblx0XHRcdFx0aWYgKCFsb3dlcmNhc2VIZXgpIHtcblx0XHRcdFx0XHRoZXhhZGVjaW1hbCA9IGhleGFkZWNpbWFsLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuICcweCcgKyBoZXhhZGVjaW1hbDtcblx0XHRcdH1cblx0XHRcdGlmICh1c2VCaW5OdW1iZXJzKSB7XG5cdFx0XHRcdHJldHVybiAnMGInICsgYXJndW1lbnQudG9TdHJpbmcoMik7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlT2N0TnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gJzBvJyArIGFyZ3VtZW50LnRvU3RyaW5nKDgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWlzT2JqZWN0KGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0Ly8gRm9yIHNvbWUgdmFsdWVzIChlLmcuIGB1bmRlZmluZWRgLCBgZnVuY3Rpb25gIG9iamVjdHMpLFxuXHRcdFx0XHQvLyBgSlNPTi5zdHJpbmdpZnkodmFsdWUpYCByZXR1cm5zIGB1bmRlZmluZWRgICh3aGljaCBpc27igJl0IHZhbGlkXG5cdFx0XHRcdC8vIEpTT04pIGluc3RlYWQgb2YgYCdudWxsJ2AuXG5cdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShhcmd1bWVudCkgfHwgJ251bGwnO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0fSBlbHNlIHsgLy8gaXTigJlzIGFuIG9iamVjdFxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0XHRvcHRpb25zLndyYXAgPSB0cnVlO1xuXHRcdFx0aW5jcmVhc2VJbmRlbnRhdGlvbigpO1xuXHRcdFx0Zm9yT3duKGFyZ3VtZW50LCAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdFx0XHRpc0VtcHR5ID0gZmFsc2U7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKFxuXHRcdFx0XHRcdChjb21wYWN0ID8gJycgOiBpbmRlbnQpICtcblx0XHRcdFx0XHRqc2VzYyhrZXksIG9wdGlvbnMpICsgJzonICtcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogJyAnKSArXG5cdFx0XHRcdFx0anNlc2ModmFsdWUsIG9wdGlvbnMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdHJldHVybiAne30nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICd7JyArIG5ld0xpbmUgKyByZXN1bHQuam9pbignLCcgKyBuZXdMaW5lKSArIG5ld0xpbmUgK1xuXHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICd9Jztcblx0XHR9XG5cdH1cblxuXHRjb25zdCByZWdleCA9IG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZyA/IGVzY2FwZUV2ZXJ5dGhpbmdSZWdleCA6IGVzY2FwZU5vbkFzY2lpUmVnZXg7XG5cdHJlc3VsdCA9IGFyZ3VtZW50LnJlcGxhY2UocmVnZXgsIChjaGFyLCBwYWlyLCBsb25lLCBxdW90ZUNoYXIsIGluZGV4LCBzdHJpbmcpID0+IHtcblx0XHRpZiAocGFpcikge1xuXHRcdFx0aWYgKG9wdGlvbnMubWluaW1hbCkgcmV0dXJuIHBhaXI7XG5cdFx0XHRjb25zdCBmaXJzdCA9IHBhaXIuY2hhckNvZGVBdCgwKTtcblx0XHRcdGNvbnN0IHNlY29uZCA9IHBhaXIuY2hhckNvZGVBdCgxKTtcblx0XHRcdGlmIChvcHRpb25zLmVzNikge1xuXHRcdFx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcblx0XHRcdFx0Y29uc3QgY29kZVBvaW50ID0gKGZpcnN0IC0gMHhEODAwKSAqIDB4NDAwICsgc2Vjb25kIC0gMHhEQzAwICsgMHgxMDAwMDtcblx0XHRcdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY29kZVBvaW50LCBsb3dlcmNhc2VIZXgpO1xuXHRcdFx0XHRyZXR1cm4gJ1xcXFx1eycgKyBoZXggKyAnfSc7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChmaXJzdCwgbG93ZXJjYXNlSGV4KSkgKyBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKHNlY29uZCwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKGxvbmUpIHtcblx0XHRcdHJldHVybiBmb3VySGV4RXNjYXBlKGhleGFkZWNpbWFsKGxvbmUuY2hhckNvZGVBdCgwKSwgbG93ZXJjYXNlSGV4KSk7XG5cdFx0fVxuXG5cdFx0aWYgKFxuXHRcdFx0Y2hhciA9PSAnXFwwJyAmJlxuXHRcdFx0IWpzb24gJiZcblx0XHRcdCFyZWdleERpZ2l0LnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCArIDEpKVxuXHRcdCkge1xuXHRcdFx0cmV0dXJuICdcXFxcMCc7XG5cdFx0fVxuXG5cdFx0aWYgKHF1b3RlQ2hhcikge1xuXHRcdFx0aWYgKHF1b3RlQ2hhciA9PSBxdW90ZSB8fCBvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcpIHtcblx0XHRcdFx0cmV0dXJuICdcXFxcJyArIHF1b3RlQ2hhcjtcblx0XHRcdH1cblx0XHRcdHJldHVybiBxdW90ZUNoYXI7XG5cdFx0fVxuXG5cdFx0aWYgKHJlZ2V4U2luZ2xlRXNjYXBlLnRlc3QoY2hhcikpIHtcblx0XHRcdC8vIG5vIG5lZWQgZm9yIGEgYGhhc093blByb3BlcnR5YCBjaGVjayBoZXJlXG5cdFx0XHRyZXR1cm4gc2luZ2xlRXNjYXBlc1tjaGFyXTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5taW5pbWFsICYmICFyZWdleFdoaXRlc3BhY2UudGVzdChjaGFyKSkge1xuXHRcdFx0cmV0dXJuIGNoYXI7XG5cdFx0fVxuXG5cdFx0Y29uc3QgaGV4ID0gaGV4YWRlY2ltYWwoY2hhci5jaGFyQ29kZUF0KDApLCBsb3dlcmNhc2VIZXgpO1xuXHRcdGlmIChqc29uIHx8IGhleC5sZW5ndGggPiAyKSB7XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXgpO1xuXHRcdH1cblxuXHRcdHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBoZXgpLnNsaWNlKC0yKTtcblx0fSk7XG5cblx0aWYgKHF1b3RlID09ICdgJykge1xuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXCRcXHsvZywgJ1xcXFwkeycpO1xuXHR9XG5cdGlmIChvcHRpb25zLmlzU2NyaXB0Q29udGV4dCkge1xuXHRcdC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9ldGFnb1xuXHRcdHJlc3VsdCA9IHJlc3VsdFxuXHRcdFx0LnJlcGxhY2UoLzxcXC8oc2NyaXB0fHN0eWxlKS9naSwgJzxcXFxcLyQxJylcblx0XHRcdC5yZXBsYWNlKC88IS0tL2csIGpzb24gPyAnXFxcXHUwMDNDIS0tJyA6ICdcXFxceDNDIS0tJyk7XG5cdH1cblx0aWYgKG9wdGlvbnMud3JhcCkge1xuXHRcdHJlc3VsdCA9IHF1b3RlICsgcmVzdWx0ICsgcXVvdGU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbmpzZXNjLnZlcnNpb24gPSAnMy4wLjInO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGpzZXNjO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17159\n")},6585:module=>{eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU4NS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanM/M2E3OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6585\n")},48633:module=>{eval("var x=String;\nvar create=function() {return {isColorSupported:false,reset:x,bold:x,dim:x,italic:x,underline:x,inverse:x,hidden:x,strikethrough:x,black:x,red:x,green:x,yellow:x,blue:x,magenta:x,cyan:x,white:x,gray:x,bgBlack:x,bgRed:x,bgGreen:x,bgYellow:x,bgBlue:x,bgMagenta:x,bgCyan:x,bgWhite:x,blackBright:x,redBright:x,greenBright:x,yellowBright:x,blueBright:x,magentaBright:x,cyanBright:x,whiteBright:x,bgBlackBright:x,bgRedBright:x,bgGreenBright:x,bgYellowBright:x,bgBlueBright:x,bgMagentaBright:x,bgCyanBright:x,bgWhiteBright:x}};\nmodule.exports=create();\nmodule.exports.createColors = create;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg2MzMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvcGljb2NvbG9ycy9waWNvY29sb3JzLmJyb3dzZXIuanM/ZmFhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgeD1TdHJpbmc7XG52YXIgY3JlYXRlPWZ1bmN0aW9uKCkge3JldHVybiB7aXNDb2xvclN1cHBvcnRlZDpmYWxzZSxyZXNldDp4LGJvbGQ6eCxkaW06eCxpdGFsaWM6eCx1bmRlcmxpbmU6eCxpbnZlcnNlOngsaGlkZGVuOngsc3RyaWtldGhyb3VnaDp4LGJsYWNrOngscmVkOngsZ3JlZW46eCx5ZWxsb3c6eCxibHVlOngsbWFnZW50YTp4LGN5YW46eCx3aGl0ZTp4LGdyYXk6eCxiZ0JsYWNrOngsYmdSZWQ6eCxiZ0dyZWVuOngsYmdZZWxsb3c6eCxiZ0JsdWU6eCxiZ01hZ2VudGE6eCxiZ0N5YW46eCxiZ1doaXRlOngsYmxhY2tCcmlnaHQ6eCxyZWRCcmlnaHQ6eCxncmVlbkJyaWdodDp4LHllbGxvd0JyaWdodDp4LGJsdWVCcmlnaHQ6eCxtYWdlbnRhQnJpZ2h0OngsY3lhbkJyaWdodDp4LHdoaXRlQnJpZ2h0OngsYmdCbGFja0JyaWdodDp4LGJnUmVkQnJpZ2h0OngsYmdHcmVlbkJyaWdodDp4LGJnWWVsbG93QnJpZ2h0OngsYmdCbHVlQnJpZ2h0OngsYmdNYWdlbnRhQnJpZ2h0OngsYmdDeWFuQnJpZ2h0OngsYmdXaGl0ZUJyaWdodDp4fX07XG5tb2R1bGUuZXhwb3J0cz1jcmVhdGUoKTtcbm1vZHVsZS5leHBvcnRzLmNyZWF0ZUNvbG9ycyA9IGNyZWF0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48633\n")},85130:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ react_split_es)\n});\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n// EXTERNAL MODULE: ./node_modules/prop-types/index.js\nvar prop_types = __webpack_require__(5556);\nvar prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);\n;// ./node_modules/split.js/dist/split.es.js\n// The programming goals of Split.js are to deliver readable, understandable and\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\n// browser compatibility without additional requirements\n// and very few assumptions about the user's page layout.\nvar global = typeof window !== 'undefined' ? window : null;\nvar ssr = global === null;\nvar split_es_document = !ssr ? global.document : undefined;\n\n// Save a couple long function names that are used frequently.\n// This optimization saves around 400 bytes.\nvar addEventListener = 'addEventListener';\nvar removeEventListener = 'removeEventListener';\nvar getBoundingClientRect = 'getBoundingClientRect';\nvar gutterStartDragging = '_a';\nvar aGutterSize = '_b';\nvar bGutterSize = '_c';\nvar HORIZONTAL = 'horizontal';\nvar NOOP = function () { return false; };\n\n// Helper function determines which prefixes of CSS calc we need.\n// We only need to do this once on startup, when this anonymous function is called.\n//\n// Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\n// http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\nvar calc = ssr\n    ? 'calc'\n    : ((['', '-webkit-', '-moz-', '-o-']\n          .filter(function (prefix) {\n              var el = split_es_document.createElement('div');\n              el.style.cssText = \"width:\" + prefix + \"calc(9px)\";\n\n              return !!el.style.length\n          })\n          .shift()) + \"calc\");\n\n// Helper function checks if its argument is a string-like type\nvar isString = function (v) { return typeof v === 'string' || v instanceof String; };\n\n// Helper function allows elements and string selectors to be used\n// interchangeably. In either case an element is returned. This allows us to\n// do `Split([elem1, elem2])` as well as `Split(['#id1', '#id2'])`.\nvar elementOrSelector = function (el) {\n    if (isString(el)) {\n        var ele = split_es_document.querySelector(el);\n        if (!ele) {\n            throw new Error((\"Selector \" + el + \" did not match a DOM element\"))\n        }\n        return ele\n    }\n\n    return el\n};\n\n// Helper function gets a property from the properties object, with a default fallback\nvar getOption = function (options, propName, def) {\n    var value = options[propName];\n    if (value !== undefined) {\n        return value\n    }\n    return def\n};\n\nvar getGutterSize = function (gutterSize, isFirst, isLast, gutterAlign) {\n    if (isFirst) {\n        if (gutterAlign === 'end') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    } else if (isLast) {\n        if (gutterAlign === 'start') {\n            return 0\n        }\n        if (gutterAlign === 'center') {\n            return gutterSize / 2\n        }\n    }\n\n    return gutterSize\n};\n\n// Default options\nvar defaultGutterFn = function (i, gutterDirection) {\n    var gut = split_es_document.createElement('div');\n    gut.className = \"gutter gutter-\" + gutterDirection;\n    return gut\n};\n\nvar defaultElementStyleFn = function (dim, size, gutSize) {\n    var style = {};\n\n    if (!isString(size)) {\n        style[dim] = calc + \"(\" + size + \"% - \" + gutSize + \"px)\";\n    } else {\n        style[dim] = size;\n    }\n\n    return style\n};\n\nvar defaultGutterStyleFn = function (dim, gutSize) {\n    var obj;\n\n    return (( obj = {}, obj[dim] = (gutSize + \"px\"), obj ));\n};\n\n// The main function to initialize a split. Split.js thinks about each pair\n// of elements as an independant pair. Dragging the gutter between two elements\n// only changes the dimensions of elements in that pair. This is key to understanding\n// how the following functions operate, since each function is bound to a pair.\n//\n// A pair object is shaped like this:\n//\n// {\n//     a: DOM element,\n//     b: DOM element,\n//     aMin: Number,\n//     bMin: Number,\n//     dragging: Boolean,\n//     parent: DOM element,\n//     direction: 'horizontal' | 'vertical'\n// }\n//\n// The basic sequence:\n//\n// 1. Set defaults to something sane. `options` doesn't have to be passed at all.\n// 2. Initialize a bunch of strings based on the direction we're splitting.\n//    A lot of the behavior in the rest of the library is paramatized down to\n//    rely on CSS strings and classes.\n// 3. Define the dragging helper functions, and a few helpers to go with them.\n// 4. Loop through the elements while pairing them off. Every pair gets an\n//    `pair` object and a gutter.\n// 5. Actually size the pair elements, insert gutters and attach event listeners.\nvar Split = function (idsOption, options) {\n    if ( options === void 0 ) options = {};\n\n    if (ssr) { return {} }\n\n    var ids = idsOption;\n    var dimension;\n    var clientAxis;\n    var position;\n    var positionEnd;\n    var clientSize;\n    var elements;\n\n    // Allow HTMLCollection to be used as an argument when supported\n    if (Array.from) {\n        ids = Array.from(ids);\n    }\n\n    // All DOM elements in the split should have a common parent. We can grab\n    // the first elements parent and hope users read the docs because the\n    // behavior will be whacky otherwise.\n    var firstElement = elementOrSelector(ids[0]);\n    var parent = firstElement.parentNode;\n    var parentStyle = getComputedStyle ? getComputedStyle(parent) : null;\n    var parentFlexDirection = parentStyle ? parentStyle.flexDirection : null;\n\n    // Set default options.sizes to equal percentages of the parent element.\n    var sizes = getOption(options, 'sizes') || ids.map(function () { return 100 / ids.length; });\n\n    // Standardize minSize and maxSize to an array if it isn't already.\n    // This allows minSize and maxSize to be passed as a number.\n    var minSize = getOption(options, 'minSize', 100);\n    var minSizes = Array.isArray(minSize) ? minSize : ids.map(function () { return minSize; });\n    var maxSize = getOption(options, 'maxSize', Infinity);\n    var maxSizes = Array.isArray(maxSize) ? maxSize : ids.map(function () { return maxSize; });\n\n    // Get other options\n    var expandToMin = getOption(options, 'expandToMin', false);\n    var gutterSize = getOption(options, 'gutterSize', 10);\n    var gutterAlign = getOption(options, 'gutterAlign', 'center');\n    var snapOffset = getOption(options, 'snapOffset', 30);\n    var snapOffsets = Array.isArray(snapOffset) ? snapOffset : ids.map(function () { return snapOffset; });\n    var dragInterval = getOption(options, 'dragInterval', 1);\n    var direction = getOption(options, 'direction', HORIZONTAL);\n    var cursor = getOption(\n        options,\n        'cursor',\n        direction === HORIZONTAL ? 'col-resize' : 'row-resize'\n    );\n    var gutter = getOption(options, 'gutter', defaultGutterFn);\n    var elementStyle = getOption(\n        options,\n        'elementStyle',\n        defaultElementStyleFn\n    );\n    var gutterStyle = getOption(options, 'gutterStyle', defaultGutterStyleFn);\n\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\n    // A lot of the behavior in the rest of the library is paramatized down to\n    // rely on CSS strings and classes.\n    if (direction === HORIZONTAL) {\n        dimension = 'width';\n        clientAxis = 'clientX';\n        position = 'left';\n        positionEnd = 'right';\n        clientSize = 'clientWidth';\n    } else if (direction === 'vertical') {\n        dimension = 'height';\n        clientAxis = 'clientY';\n        position = 'top';\n        positionEnd = 'bottom';\n        clientSize = 'clientHeight';\n    }\n\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\n    // Each helper is bound to a pair object that contains its metadata. This\n    // also makes it easy to store references to listeners that that will be\n    // added and removed.\n    //\n    // Even though there are no other functions contained in them, aliasing\n    // this to self saves 50 bytes or so since it's used so frequently.\n    //\n    // The pair object saves metadata like dragging state, position and\n    // event listener references.\n\n    function setElementSize(el, size, gutSize, i) {\n        // Split.js allows setting sizes via numbers (ideally), or if you must,\n        // by string, like '300px'. This is less than ideal, because it breaks\n        // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\n        // make sure you calculate the gutter size by hand.\n        var style = elementStyle(dimension, size, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            el.style[prop] = style[prop];\n        });\n    }\n\n    function setGutterSize(gutterElement, gutSize, i) {\n        var style = gutterStyle(dimension, gutSize, i);\n\n        Object.keys(style).forEach(function (prop) {\n            // eslint-disable-next-line no-param-reassign\n            gutterElement.style[prop] = style[prop];\n        });\n    }\n\n    function getSizes() {\n        return elements.map(function (element) { return element.size; })\n    }\n\n    // Supports touch events, but not multitouch, so only the first\n    // finger `touches[0]` is counted.\n    function getMousePosition(e) {\n        if ('touches' in e) { return e.touches[0][clientAxis] }\n        return e[clientAxis]\n    }\n\n    // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\n    // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\n    // which allows the viewport to be resized without additional logic.\n    // Element a's size is the same as offset. b's size is total size - a size.\n    // Both sizes are calculated from the initial parent percentage,\n    // then the gutter size is subtracted.\n    function adjust(offset) {\n        var a = elements[this.a];\n        var b = elements[this.b];\n        var percentage = a.size + b.size;\n\n        a.size = (offset / this.size) * percentage;\n        b.size = percentage - (offset / this.size) * percentage;\n\n        setElementSize(a.element, a.size, this[aGutterSize], a.i);\n        setElementSize(b.element, b.size, this[bGutterSize], b.i);\n    }\n\n    // drag, where all the magic happens. The logic is really quite simple:\n    //\n    // 1. Ignore if the pair is not dragging.\n    // 2. Get the offset of the event.\n    // 3. Snap offset to min if within snappable range (within min + snapOffset).\n    // 4. Actually adjust each element in the pair to offset.\n    //\n    // ---------------------------------------------------------------------\n    // |    | <- a.minSize               ||              b.minSize -> |    |\n    // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\n    // |    |  |                         ||                        |  |    |\n    // |    |  |                         ||                        |  |    |\n    // ---------------------------------------------------------------------\n    // | <- this.start                                        this.size -> |\n    function drag(e) {\n        var offset;\n        var a = elements[this.a];\n        var b = elements[this.b];\n\n        if (!this.dragging) { return }\n\n        // Get the offset of the event from the first side of the\n        // pair `this.start`. Then offset by the initial position of the\n        // mouse compared to the gutter size.\n        offset =\n            getMousePosition(e) -\n            this.start +\n            (this[aGutterSize] - this.dragOffset);\n\n        if (dragInterval > 1) {\n            offset = Math.round(offset / dragInterval) * dragInterval;\n        }\n\n        // If within snapOffset of min or max, set offset to min or max.\n        // snapOffset buffers a.minSize and b.minSize, so logic is opposite for both.\n        // Include the appropriate gutter sizes to prevent overflows.\n        if (offset <= a.minSize + a.snapOffset + this[aGutterSize]) {\n            offset = a.minSize + this[aGutterSize];\n        } else if (\n            offset >=\n            this.size - (b.minSize + b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.minSize + this[bGutterSize]);\n        }\n\n        if (offset >= a.maxSize - a.snapOffset + this[aGutterSize]) {\n            offset = a.maxSize + this[aGutterSize];\n        } else if (\n            offset <=\n            this.size - (b.maxSize - b.snapOffset + this[bGutterSize])\n        ) {\n            offset = this.size - (b.maxSize + this[bGutterSize]);\n        }\n\n        // Actually adjust the size.\n        adjust.call(this, offset);\n\n        // Call the drag callback continously. Don't do anything too intensive\n        // in this callback.\n        getOption(options, 'onDrag', NOOP)(getSizes());\n    }\n\n    // Cache some important sizes when drag starts, so we don't have to do that\n    // continously:\n    //\n    // `size`: The total size of the pair. First + second + first gutter + second gutter.\n    // `start`: The leading side of the first element.\n    //\n    // ------------------------------------------------\n    // |      aGutterSize -> |||                      |\n    // |                     |||                      |\n    // |                     |||                      |\n    // |                     ||| <- bGutterSize       |\n    // ------------------------------------------------\n    // | <- start                             size -> |\n    function calculateSizes() {\n        // Figure out the parent size minus padding.\n        var a = elements[this.a].element;\n        var b = elements[this.b].element;\n\n        var aBounds = a[getBoundingClientRect]();\n        var bBounds = b[getBoundingClientRect]();\n\n        this.size =\n            aBounds[dimension] +\n            bBounds[dimension] +\n            this[aGutterSize] +\n            this[bGutterSize];\n        this.start = aBounds[position];\n        this.end = aBounds[positionEnd];\n    }\n\n    function innerSize(element) {\n        // Return nothing if getComputedStyle is not supported (< IE9)\n        // Or if parent element has no layout yet\n        if (!getComputedStyle) { return null }\n\n        var computedStyle = getComputedStyle(element);\n\n        if (!computedStyle) { return null }\n\n        var size = element[clientSize];\n\n        if (size === 0) { return null }\n\n        if (direction === HORIZONTAL) {\n            size -=\n                parseFloat(computedStyle.paddingLeft) +\n                parseFloat(computedStyle.paddingRight);\n        } else {\n            size -=\n                parseFloat(computedStyle.paddingTop) +\n                parseFloat(computedStyle.paddingBottom);\n        }\n\n        return size\n    }\n\n    // When specifying percentage sizes that are less than the computed\n    // size of the element minus the gutter, the lesser percentages must be increased\n    // (and decreased from the other elements) to make space for the pixels\n    // subtracted by the gutters.\n    function trimToMin(sizesToTrim) {\n        // Try to get inner size of parent element.\n        // If it's no supported, return original sizes.\n        var parentSize = innerSize(parent);\n        if (parentSize === null) {\n            return sizesToTrim\n        }\n\n        if (minSizes.reduce(function (a, b) { return a + b; }, 0) > parentSize) {\n            return sizesToTrim\n        }\n\n        // Keep track of the excess pixels, the amount of pixels over the desired percentage\n        // Also keep track of the elements with pixels to spare, to decrease after if needed\n        var excessPixels = 0;\n        var toSpare = [];\n\n        var pixelSizes = sizesToTrim.map(function (size, i) {\n            // Convert requested percentages to pixel sizes\n            var pixelSize = (parentSize * size) / 100;\n            var elementGutterSize = getGutterSize(\n                gutterSize,\n                i === 0,\n                i === sizesToTrim.length - 1,\n                gutterAlign\n            );\n            var elementMinSize = minSizes[i] + elementGutterSize;\n\n            // If element is too smal, increase excess pixels by the difference\n            // and mark that it has no pixels to spare\n            if (pixelSize < elementMinSize) {\n                excessPixels += elementMinSize - pixelSize;\n                toSpare.push(0);\n                return elementMinSize\n            }\n\n            // Otherwise, mark the pixels it has to spare and return it's original size\n            toSpare.push(pixelSize - elementMinSize);\n            return pixelSize\n        });\n\n        // If nothing was adjusted, return the original sizes\n        if (excessPixels === 0) {\n            return sizesToTrim\n        }\n\n        return pixelSizes.map(function (pixelSize, i) {\n            var newPixelSize = pixelSize;\n\n            // While there's still pixels to take, and there's enough pixels to spare,\n            // take as many as possible up to the total excess pixels\n            if (excessPixels > 0 && toSpare[i] - excessPixels > 0) {\n                var takenPixels = Math.min(\n                    excessPixels,\n                    toSpare[i] - excessPixels\n                );\n\n                // Subtract the amount taken for the next iteration\n                excessPixels -= takenPixels;\n                newPixelSize = pixelSize - takenPixels;\n            }\n\n            // Return the pixel size adjusted as a percentage\n            return (newPixelSize / parentSize) * 100\n        })\n    }\n\n    // stopDragging is very similar to startDragging in reverse.\n    function stopDragging() {\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        if (self.dragging) {\n            getOption(options, 'onDragEnd', NOOP)(getSizes());\n        }\n\n        self.dragging = false;\n\n        // Remove the stored event listeners. This is why we store them.\n        global[removeEventListener]('mouseup', self.stop);\n        global[removeEventListener]('touchend', self.stop);\n        global[removeEventListener]('touchcancel', self.stop);\n        global[removeEventListener]('mousemove', self.move);\n        global[removeEventListener]('touchmove', self.move);\n\n        // Clear bound function references\n        self.stop = null;\n        self.move = null;\n\n        a[removeEventListener]('selectstart', NOOP);\n        a[removeEventListener]('dragstart', NOOP);\n        b[removeEventListener]('selectstart', NOOP);\n        b[removeEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = '';\n        a.style.webkitUserSelect = '';\n        a.style.MozUserSelect = '';\n        a.style.pointerEvents = '';\n\n        b.style.userSelect = '';\n        b.style.webkitUserSelect = '';\n        b.style.MozUserSelect = '';\n        b.style.pointerEvents = '';\n\n        self.gutter.style.cursor = '';\n        self.parent.style.cursor = '';\n        split_es_document.body.style.cursor = '';\n    }\n\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\n    // It also adds event listeners for mouse/touch events,\n    // and prevents selection while dragging so avoid the selecting text.\n    function startDragging(e) {\n        // Right-clicking can't start dragging.\n        if ('button' in e && e.button !== 0) {\n            return\n        }\n\n        // Alias frequently used variables to save space. 200 bytes.\n        var self = this;\n        var a = elements[self.a].element;\n        var b = elements[self.b].element;\n\n        // Call the onDragStart callback.\n        if (!self.dragging) {\n            getOption(options, 'onDragStart', NOOP)(getSizes());\n        }\n\n        // Don't actually drag the element. We emulate that in the drag function.\n        e.preventDefault();\n\n        // Set the dragging property of the pair object.\n        self.dragging = true;\n\n        // Create two event listeners bound to the same pair object and store\n        // them in the pair object.\n        self.move = drag.bind(self);\n        self.stop = stopDragging.bind(self);\n\n        // All the binding. `window` gets the stop events in case we drag out of the elements.\n        global[addEventListener]('mouseup', self.stop);\n        global[addEventListener]('touchend', self.stop);\n        global[addEventListener]('touchcancel', self.stop);\n        global[addEventListener]('mousemove', self.move);\n        global[addEventListener]('touchmove', self.move);\n\n        // Disable selection. Disable!\n        a[addEventListener]('selectstart', NOOP);\n        a[addEventListener]('dragstart', NOOP);\n        b[addEventListener]('selectstart', NOOP);\n        b[addEventListener]('dragstart', NOOP);\n\n        a.style.userSelect = 'none';\n        a.style.webkitUserSelect = 'none';\n        a.style.MozUserSelect = 'none';\n        a.style.pointerEvents = 'none';\n\n        b.style.userSelect = 'none';\n        b.style.webkitUserSelect = 'none';\n        b.style.MozUserSelect = 'none';\n        b.style.pointerEvents = 'none';\n\n        // Set the cursor at multiple levels\n        self.gutter.style.cursor = cursor;\n        self.parent.style.cursor = cursor;\n        split_es_document.body.style.cursor = cursor;\n\n        // Cache the initial sizes of the pair.\n        calculateSizes.call(self);\n\n        // Determine the position of the mouse compared to the gutter\n        self.dragOffset = getMousePosition(e) - self.end;\n    }\n\n    // adjust sizes to ensure percentage is within min size and gutter.\n    sizes = trimToMin(sizes);\n\n    // 5. Create pair and element objects. Each pair has an index reference to\n    // elements `a` and `b` of the pair (first and second elements).\n    // Loop through the elements while pairing them off. Every pair gets a\n    // `pair` object and a gutter.\n    //\n    // Basic logic:\n    //\n    // - Starting with the second element `i > 0`, create `pair` objects with\n    //   `a = i - 1` and `b = i`\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\n    // - Create gutter elements and add event listeners.\n    // - Set the size of the elements, minus the gutter sizes.\n    //\n    // -----------------------------------------------------------------------\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\n    // |             |                     |                  |              |\n    // |           pair 0                pair 1             pair 2           |\n    // |             |                     |                  |              |\n    // -----------------------------------------------------------------------\n    var pairs = [];\n    elements = ids.map(function (id, i) {\n        // Create the element object.\n        var element = {\n            element: elementOrSelector(id),\n            size: sizes[i],\n            minSize: minSizes[i],\n            maxSize: maxSizes[i],\n            snapOffset: snapOffsets[i],\n            i: i,\n        };\n\n        var pair;\n\n        if (i > 0) {\n            // Create the pair object with its metadata.\n            pair = {\n                a: i - 1,\n                b: i,\n                dragging: false,\n                direction: direction,\n                parent: parent,\n            };\n\n            pair[aGutterSize] = getGutterSize(\n                gutterSize,\n                i - 1 === 0,\n                false,\n                gutterAlign\n            );\n            pair[bGutterSize] = getGutterSize(\n                gutterSize,\n                false,\n                i === ids.length - 1,\n                gutterAlign\n            );\n\n            // if the parent has a reverse flex-direction, switch the pair elements.\n            if (\n                parentFlexDirection === 'row-reverse' ||\n                parentFlexDirection === 'column-reverse'\n            ) {\n                var temp = pair.a;\n                pair.a = pair.b;\n                pair.b = temp;\n            }\n        }\n\n        // Determine the size of the current element. IE8 is supported by\n        // staticly assigning sizes without draggable gutters. Assigns a string\n        // to `size`.\n        //\n        // Create gutter elements for each pair.\n        if (i > 0) {\n            var gutterElement = gutter(i, direction, element.element);\n            setGutterSize(gutterElement, gutterSize, i);\n\n            // Save bound event listener for removal later\n            pair[gutterStartDragging] = startDragging.bind(pair);\n\n            // Attach bound event listener\n            gutterElement[addEventListener](\n                'mousedown',\n                pair[gutterStartDragging]\n            );\n            gutterElement[addEventListener](\n                'touchstart',\n                pair[gutterStartDragging]\n            );\n\n            parent.insertBefore(gutterElement, element.element);\n\n            pair.gutter = gutterElement;\n        }\n\n        setElementSize(\n            element.element,\n            element.size,\n            getGutterSize(\n                gutterSize,\n                i === 0,\n                i === ids.length - 1,\n                gutterAlign\n            ),\n            i\n        );\n\n        // After the first iteration, and we have a pair object, append it to the\n        // list of pairs.\n        if (i > 0) {\n            pairs.push(pair);\n        }\n\n        return element\n    });\n\n    function adjustToMin(element) {\n        var isLast = element.i === pairs.length;\n        var pair = isLast ? pairs[element.i - 1] : pairs[element.i];\n\n        calculateSizes.call(pair);\n\n        var size = isLast\n            ? pair.size - element.minSize - pair[bGutterSize]\n            : element.minSize + pair[aGutterSize];\n\n        adjust.call(pair, size);\n    }\n\n    elements.forEach(function (element) {\n        var computedSize = element.element[getBoundingClientRect]()[dimension];\n\n        if (computedSize < element.minSize) {\n            if (expandToMin) {\n                adjustToMin(element);\n            } else {\n                // eslint-disable-next-line no-param-reassign\n                element.minSize = computedSize;\n            }\n        }\n    });\n\n    function setSizes(newSizes) {\n        var trimmed = trimToMin(newSizes);\n        trimmed.forEach(function (newSize, i) {\n            if (i > 0) {\n                var pair = pairs[i - 1];\n\n                var a = elements[pair.a];\n                var b = elements[pair.b];\n\n                a.size = trimmed[i - 1];\n                b.size = newSize;\n\n                setElementSize(a.element, a.size, pair[aGutterSize], a.i);\n                setElementSize(b.element, b.size, pair[bGutterSize], b.i);\n            }\n        });\n    }\n\n    function destroy(preserveStyles, preserveGutter) {\n        pairs.forEach(function (pair) {\n            if (preserveGutter !== true) {\n                pair.parent.removeChild(pair.gutter);\n            } else {\n                pair.gutter[removeEventListener](\n                    'mousedown',\n                    pair[gutterStartDragging]\n                );\n                pair.gutter[removeEventListener](\n                    'touchstart',\n                    pair[gutterStartDragging]\n                );\n            }\n\n            if (preserveStyles !== true) {\n                var style = elementStyle(\n                    dimension,\n                    pair.a.size,\n                    pair[aGutterSize]\n                );\n\n                Object.keys(style).forEach(function (prop) {\n                    elements[pair.a].element.style[prop] = '';\n                    elements[pair.b].element.style[prop] = '';\n                });\n            }\n        });\n    }\n\n    return {\n        setSizes: setSizes,\n        getSizes: getSizes,\n        collapse: function collapse(i) {\n            adjustToMin(elements[i]);\n        },\n        destroy: destroy,\n        parent: parent,\n        pairs: pairs,\n    }\n};\n\n/* harmony default export */ const split_es = (Split);\n\n;// ./node_modules/react-split/dist/react-split.es.js\n\n\n\n\nfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n\nvar SplitWrapper = /*@__PURE__*/(function (superclass) {\n    function SplitWrapper () {\n        superclass.apply(this, arguments);\n    }\n\n    if ( superclass ) SplitWrapper.__proto__ = superclass;\n    SplitWrapper.prototype = Object.create( superclass && superclass.prototype );\n    SplitWrapper.prototype.constructor = SplitWrapper;\n\n    SplitWrapper.prototype.componentDidMount = function componentDidMount () {\n        var ref = this.props;\n        ref.children;\n        var gutter = ref.gutter;\n        var rest = objectWithoutProperties( ref, [\"children\", \"gutter\"] );\n        var options = rest;\n\n        options.gutter = function (index, direction) {\n            var gutterElement;\n\n            if (gutter) {\n                gutterElement = gutter(index, direction);\n            } else {\n                gutterElement = document.createElement('div');\n                gutterElement.className = \"gutter gutter-\" + direction;\n            }\n\n            // eslint-disable-next-line no-underscore-dangle\n            gutterElement.__isSplitGutter = true;\n            return gutterElement\n        };\n\n        this.split = split_es(this.parent.children, options);\n    };\n\n    SplitWrapper.prototype.componentDidUpdate = function componentDidUpdate (prevProps) {\n        var this$1 = this;\n\n        var ref = this.props;\n        ref.children;\n        var minSize = ref.minSize;\n        var sizes = ref.sizes;\n        var collapsed = ref.collapsed;\n        var rest = objectWithoutProperties( ref, [\"children\", \"minSize\", \"sizes\", \"collapsed\"] );\n        var options = rest;\n        var prevMinSize = prevProps.minSize;\n        var prevSizes = prevProps.sizes;\n        var prevCollapsed = prevProps.collapsed;\n\n        var otherProps = [\n            'maxSize',\n            'expandToMin',\n            'gutterSize',\n            'gutterAlign',\n            'snapOffset',\n            'dragInterval',\n            'direction',\n            'cursor' ];\n\n        var needsRecreate = otherProps\n            // eslint-disable-next-line react/destructuring-assignment\n            .map(function (prop) { return this$1.props[prop] !== prevProps[prop]; })\n            .reduce(function (accum, same) { return accum || same; }, false);\n\n        // Compare minSize when both are arrays, when one is an array and when neither is an array\n        if (Array.isArray(minSize) && Array.isArray(prevMinSize)) {\n            var minSizeChanged = false;\n\n            minSize.forEach(function (minSizeI, i) {\n                minSizeChanged = minSizeChanged || minSizeI !== prevMinSize[i];\n            });\n\n            needsRecreate = needsRecreate || minSizeChanged;\n        } else if (Array.isArray(minSize) || Array.isArray(prevMinSize)) {\n            needsRecreate = true;\n        } else {\n            needsRecreate = needsRecreate || minSize !== prevMinSize;\n        }\n\n        // Destroy and re-create split if options changed\n        if (needsRecreate) {\n            options.minSize = minSize;\n            options.sizes = sizes || this.split.getSizes();\n            this.split.destroy(true, true);\n            options.gutter = function (index, direction, pairB) { return pairB.previousSibling; };\n            this.split = split_es(\n                Array.from(this.parent.children).filter(\n                    // eslint-disable-next-line no-underscore-dangle\n                    function (element) { return !element.__isSplitGutter; }\n                ),\n                options\n            );\n        } else if (sizes) {\n            // If only the size has changed, set the size. No need to do this if re-created.\n            var sizeChanged = false;\n\n            sizes.forEach(function (sizeI, i) {\n                sizeChanged = sizeChanged || sizeI !== prevSizes[i];\n            });\n\n            if (sizeChanged) {\n                // eslint-disable-next-line react/destructuring-assignment\n                this.split.setSizes(this.props.sizes);\n            }\n        }\n\n        // Collapse after re-created or when collapsed changed.\n        if (\n            Number.isInteger(collapsed) &&\n            (collapsed !== prevCollapsed || needsRecreate)\n        ) {\n            this.split.collapse(collapsed);\n        }\n    };\n\n    SplitWrapper.prototype.componentWillUnmount = function componentWillUnmount () {\n        this.split.destroy();\n        delete this.split;\n    };\n\n    SplitWrapper.prototype.render = function render () {\n        var this$1 = this;\n\n        var ref = this.props;\n        ref.sizes;\n        ref.minSize;\n        ref.maxSize;\n        ref.expandToMin;\n        ref.gutterSize;\n        ref.gutterAlign;\n        ref.snapOffset;\n        ref.dragInterval;\n        ref.direction;\n        ref.cursor;\n        ref.gutter;\n        ref.elementStyle;\n        ref.gutterStyle;\n        ref.onDrag;\n        ref.onDragStart;\n        ref.onDragEnd;\n        ref.collapsed;\n        var children = ref.children;\n        var rest$1 = objectWithoutProperties( ref, [\"sizes\", \"minSize\", \"maxSize\", \"expandToMin\", \"gutterSize\", \"gutterAlign\", \"snapOffset\", \"dragInterval\", \"direction\", \"cursor\", \"gutter\", \"elementStyle\", \"gutterStyle\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"collapsed\", \"children\"] );\n        var rest = rest$1;\n\n        return (\n            react.createElement( 'div', Object.assign({},\n                { ref: function (parent) {\n                    this$1.parent = parent;\n                } }, rest),\n                children\n            )\n        )\n    };\n\n    return SplitWrapper;\n}(react.Component));\n\nSplitWrapper.propTypes = {\n    sizes: prop_types_default().arrayOf((prop_types_default()).number),\n    minSize: prop_types_default().oneOfType([\n        (prop_types_default()).number,\n        prop_types_default().arrayOf((prop_types_default()).number) ]),\n    maxSize: prop_types_default().oneOfType([\n        (prop_types_default()).number,\n        prop_types_default().arrayOf((prop_types_default()).number) ]),\n    expandToMin: (prop_types_default()).bool,\n    gutterSize: (prop_types_default()).number,\n    gutterAlign: (prop_types_default()).string,\n    snapOffset: prop_types_default().oneOfType([\n        (prop_types_default()).number,\n        prop_types_default().arrayOf((prop_types_default()).number) ]),\n    dragInterval: (prop_types_default()).number,\n    direction: (prop_types_default()).string,\n    cursor: (prop_types_default()).string,\n    gutter: (prop_types_default()).func,\n    elementStyle: (prop_types_default()).func,\n    gutterStyle: (prop_types_default()).func,\n    onDrag: (prop_types_default()).func,\n    onDragStart: (prop_types_default()).func,\n    onDragEnd: (prop_types_default()).func,\n    collapsed: (prop_types_default()).number,\n    children: prop_types_default().arrayOf((prop_types_default()).element),\n};\n\nSplitWrapper.defaultProps = {\n    sizes: undefined,\n    minSize: undefined,\n    maxSize: undefined,\n    expandToMin: undefined,\n    gutterSize: undefined,\n    gutterAlign: undefined,\n    snapOffset: undefined,\n    dragInterval: undefined,\n    direction: undefined,\n    cursor: undefined,\n    gutter: undefined,\n    elementStyle: undefined,\n    gutterStyle: undefined,\n    onDrag: undefined,\n    onDragStart: undefined,\n    onDragEnd: undefined,\n    collapsed: undefined,\n    children: undefined,\n};\n\n/* harmony default export */ const react_split_es = (SplitWrapper);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUxMzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpQkFBUTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixpQkFBUTtBQUMvQjs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsaUJBQVE7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLDBCQUEwQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBLDRFQUE0RSxpQkFBaUI7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsb0JBQW9CO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsaURBQWlELHNCQUFzQjtBQUN2RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUEsOEJBQThCOztBQUU5Qjs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsZUFBZTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsaUJBQVE7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBUTs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBZSxLQUFLLEVBQUM7OztBQ3B3Qks7QUFDUztBQUNOOztBQUU3QixrREFBa0QsaUJBQWlCLHNIQUFzSDs7QUFFekw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixRQUFLO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQWdEO0FBQ25GLDZDQUE2Qyx1QkFBdUI7O0FBRXBFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUseUJBQXlCLFFBQUs7QUFDOUI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFtQix5QkFBeUI7QUFDeEQsa0JBQWtCO0FBQ2xCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLGVBQWU7O0FBRWpCO0FBQ0EsV0FBVyw0QkFBaUIsQ0FBQyw2QkFBZ0I7QUFDN0MsYUFBYSw4QkFBbUI7QUFDaEMsUUFBUSw2QkFBZ0I7QUFDeEIsUUFBUSw0QkFBaUIsQ0FBQyw2QkFBZ0I7QUFDMUMsYUFBYSw4QkFBbUI7QUFDaEMsUUFBUSw2QkFBZ0I7QUFDeEIsUUFBUSw0QkFBaUIsQ0FBQyw2QkFBZ0I7QUFDMUMsaUJBQWlCLDJCQUFjO0FBQy9CLGdCQUFnQiw2QkFBZ0I7QUFDaEMsaUJBQWlCLDZCQUFnQjtBQUNqQyxnQkFBZ0IsOEJBQW1CO0FBQ25DLFFBQVEsNkJBQWdCO0FBQ3hCLFFBQVEsNEJBQWlCLENBQUMsNkJBQWdCO0FBQzFDLGtCQUFrQiw2QkFBZ0I7QUFDbEMsZUFBZSw2QkFBZ0I7QUFDL0IsWUFBWSw2QkFBZ0I7QUFDNUIsWUFBWSwyQkFBYztBQUMxQixrQkFBa0IsMkJBQWM7QUFDaEMsaUJBQWlCLDJCQUFjO0FBQy9CLFlBQVksMkJBQWM7QUFDMUIsaUJBQWlCLDJCQUFjO0FBQy9CLGVBQWUsMkJBQWM7QUFDN0IsZUFBZSw2QkFBZ0I7QUFDL0IsY0FBYyw0QkFBaUIsQ0FBQyw4QkFBaUI7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxREFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL3NwbGl0LmpzL2Rpc3Qvc3BsaXQuZXMuanM/MWQwMiIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXNwbGl0L2Rpc3QvcmVhY3Qtc3BsaXQuZXMuanM/MzgzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcHJvZ3JhbW1pbmcgZ29hbHMgb2YgU3BsaXQuanMgYXJlIHRvIGRlbGl2ZXIgcmVhZGFibGUsIHVuZGVyc3RhbmRhYmxlIGFuZFxuLy8gbWFpbnRhaW5hYmxlIGNvZGUsIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgbWFudWFsbHkgb3B0aW1pemluZyBmb3IgdGlueSBtaW5pZmllZCBmaWxlIHNpemUsXG4vLyBicm93c2VyIGNvbXBhdGliaWxpdHkgd2l0aG91dCBhZGRpdGlvbmFsIHJlcXVpcmVtZW50c1xuLy8gYW5kIHZlcnkgZmV3IGFzc3VtcHRpb25zIGFib3V0IHRoZSB1c2VyJ3MgcGFnZSBsYXlvdXQuXG52YXIgZ2xvYmFsID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBudWxsO1xudmFyIHNzciA9IGdsb2JhbCA9PT0gbnVsbDtcbnZhciBkb2N1bWVudCA9ICFzc3IgPyBnbG9iYWwuZG9jdW1lbnQgOiB1bmRlZmluZWQ7XG5cbi8vIFNhdmUgYSBjb3VwbGUgbG9uZyBmdW5jdGlvbiBuYW1lcyB0aGF0IGFyZSB1c2VkIGZyZXF1ZW50bHkuXG4vLyBUaGlzIG9wdGltaXphdGlvbiBzYXZlcyBhcm91bmQgNDAwIGJ5dGVzLlxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSAnYWRkRXZlbnRMaXN0ZW5lcic7XG52YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbnZhciBnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSAnZ2V0Qm91bmRpbmdDbGllbnRSZWN0JztcbnZhciBndXR0ZXJTdGFydERyYWdnaW5nID0gJ19hJztcbnZhciBhR3V0dGVyU2l6ZSA9ICdfYic7XG52YXIgYkd1dHRlclNpemUgPSAnX2MnO1xudmFyIEhPUklaT05UQUwgPSAnaG9yaXpvbnRhbCc7XG52YXIgTk9PUCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGljaCBwcmVmaXhlcyBvZiBDU1MgY2FsYyB3ZSBuZWVkLlxuLy8gV2Ugb25seSBuZWVkIHRvIGRvIHRoaXMgb25jZSBvbiBzdGFydHVwLCB3aGVuIHRoaXMgYW5vbnltb3VzIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbi8vXG4vLyBUZXN0cyAtd2Via2l0LCAtbW96IGFuZCAtbyBwcmVmaXhlcy4gTW9kaWZpZWQgZnJvbSBTdGFja092ZXJmbG93OlxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjYyNTE0MC9qcy1mZWF0dXJlLWRldGVjdGlvbi10by1kZXRlY3QtdGhlLXVzYWdlLW9mLXdlYmtpdC1jYWxjLW92ZXItY2FsYy8xNjYyNTE2NyMxNjYyNTE2N1xudmFyIGNhbGMgPSBzc3JcbiAgICA/ICdjYWxjJ1xuICAgIDogKChbJycsICctd2Via2l0LScsICctbW96LScsICctby0nXVxuICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuY3NzVGV4dCA9IFwid2lkdGg6XCIgKyBwcmVmaXggKyBcImNhbGMoOXB4KVwiO1xuXG4gICAgICAgICAgICAgIHJldHVybiAhIWVsLnN0eWxlLmxlbmd0aFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNoaWZ0KCkpICsgXCJjYWxjXCIpO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gY2hlY2tzIGlmIGl0cyBhcmd1bWVudCBpcyBhIHN0cmluZy1saWtlIHR5cGVcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0eXBlb2YgdiA9PT0gJ3N0cmluZycgfHwgdiBpbnN0YW5jZW9mIFN0cmluZzsgfTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIGFsbG93cyBlbGVtZW50cyBhbmQgc3RyaW5nIHNlbGVjdG9ycyB0byBiZSB1c2VkXG4vLyBpbnRlcmNoYW5nZWFibHkuIEluIGVpdGhlciBjYXNlIGFuIGVsZW1lbnQgaXMgcmV0dXJuZWQuIFRoaXMgYWxsb3dzIHVzIHRvXG4vLyBkbyBgU3BsaXQoW2VsZW0xLCBlbGVtMl0pYCBhcyB3ZWxsIGFzIGBTcGxpdChbJyNpZDEnLCAnI2lkMiddKWAuXG52YXIgZWxlbWVudE9yU2VsZWN0b3IgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoaXNTdHJpbmcoZWwpKSB7XG4gICAgICAgIHZhciBlbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICAgICAgaWYgKCFlbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJTZWxlY3RvciBcIiArIGVsICsgXCIgZGlkIG5vdCBtYXRjaCBhIERPTSBlbGVtZW50XCIpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVcbiAgICB9XG5cbiAgICByZXR1cm4gZWxcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBnZXRzIGEgcHJvcGVydHkgZnJvbSB0aGUgcHJvcGVydGllcyBvYmplY3QsIHdpdGggYSBkZWZhdWx0IGZhbGxiYWNrXG52YXIgZ2V0T3B0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMsIHByb3BOYW1lLCBkZWYpIHtcbiAgICB2YXIgdmFsdWUgPSBvcHRpb25zW3Byb3BOYW1lXTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gICAgcmV0dXJuIGRlZlxufTtcblxudmFyIGdldEd1dHRlclNpemUgPSBmdW5jdGlvbiAoZ3V0dGVyU2l6ZSwgaXNGaXJzdCwgaXNMYXN0LCBndXR0ZXJBbGlnbikge1xuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGlmIChndXR0ZXJBbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGd1dHRlclNpemUgLyAyXG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTGFzdCkge1xuICAgICAgICBpZiAoZ3V0dGVyQWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGd1dHRlckFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGd1dHRlclNpemUgLyAyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ3V0dGVyU2l6ZVxufTtcblxuLy8gRGVmYXVsdCBvcHRpb25zXG52YXIgZGVmYXVsdEd1dHRlckZuID0gZnVuY3Rpb24gKGksIGd1dHRlckRpcmVjdGlvbikge1xuICAgIHZhciBndXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBndXQuY2xhc3NOYW1lID0gXCJndXR0ZXIgZ3V0dGVyLVwiICsgZ3V0dGVyRGlyZWN0aW9uO1xuICAgIHJldHVybiBndXRcbn07XG5cbnZhciBkZWZhdWx0RWxlbWVudFN0eWxlRm4gPSBmdW5jdGlvbiAoZGltLCBzaXplLCBndXRTaXplKSB7XG4gICAgdmFyIHN0eWxlID0ge307XG5cbiAgICBpZiAoIWlzU3RyaW5nKHNpemUpKSB7XG4gICAgICAgIHN0eWxlW2RpbV0gPSBjYWxjICsgXCIoXCIgKyBzaXplICsgXCIlIC0gXCIgKyBndXRTaXplICsgXCJweClcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZVtkaW1dID0gc2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVcbn07XG5cbnZhciBkZWZhdWx0R3V0dGVyU3R5bGVGbiA9IGZ1bmN0aW9uIChkaW0sIGd1dFNpemUpIHtcbiAgICB2YXIgb2JqO1xuXG4gICAgcmV0dXJuICgoIG9iaiA9IHt9LCBvYmpbZGltXSA9IChndXRTaXplICsgXCJweFwiKSwgb2JqICkpO1xufTtcblxuLy8gVGhlIG1haW4gZnVuY3Rpb24gdG8gaW5pdGlhbGl6ZSBhIHNwbGl0LiBTcGxpdC5qcyB0aGlua3MgYWJvdXQgZWFjaCBwYWlyXG4vLyBvZiBlbGVtZW50cyBhcyBhbiBpbmRlcGVuZGFudCBwYWlyLiBEcmFnZ2luZyB0aGUgZ3V0dGVyIGJldHdlZW4gdHdvIGVsZW1lbnRzXG4vLyBvbmx5IGNoYW5nZXMgdGhlIGRpbWVuc2lvbnMgb2YgZWxlbWVudHMgaW4gdGhhdCBwYWlyLiBUaGlzIGlzIGtleSB0byB1bmRlcnN0YW5kaW5nXG4vLyBob3cgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgb3BlcmF0ZSwgc2luY2UgZWFjaCBmdW5jdGlvbiBpcyBib3VuZCB0byBhIHBhaXIuXG4vL1xuLy8gQSBwYWlyIG9iamVjdCBpcyBzaGFwZWQgbGlrZSB0aGlzOlxuLy9cbi8vIHtcbi8vICAgICBhOiBET00gZWxlbWVudCxcbi8vICAgICBiOiBET00gZWxlbWVudCxcbi8vICAgICBhTWluOiBOdW1iZXIsXG4vLyAgICAgYk1pbjogTnVtYmVyLFxuLy8gICAgIGRyYWdnaW5nOiBCb29sZWFuLFxuLy8gICAgIHBhcmVudDogRE9NIGVsZW1lbnQsXG4vLyAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnXG4vLyB9XG4vL1xuLy8gVGhlIGJhc2ljIHNlcXVlbmNlOlxuLy9cbi8vIDEuIFNldCBkZWZhdWx0cyB0byBzb21ldGhpbmcgc2FuZS4gYG9wdGlvbnNgIGRvZXNuJ3QgaGF2ZSB0byBiZSBwYXNzZWQgYXQgYWxsLlxuLy8gMi4gSW5pdGlhbGl6ZSBhIGJ1bmNoIG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiB3ZSdyZSBzcGxpdHRpbmcuXG4vLyAgICBBIGxvdCBvZiB0aGUgYmVoYXZpb3IgaW4gdGhlIHJlc3Qgb2YgdGhlIGxpYnJhcnkgaXMgcGFyYW1hdGl6ZWQgZG93biB0b1xuLy8gICAgcmVseSBvbiBDU1Mgc3RyaW5ncyBhbmQgY2xhc3Nlcy5cbi8vIDMuIERlZmluZSB0aGUgZHJhZ2dpbmcgaGVscGVyIGZ1bmN0aW9ucywgYW5kIGEgZmV3IGhlbHBlcnMgdG8gZ28gd2l0aCB0aGVtLlxuLy8gNC4gTG9vcCB0aHJvdWdoIHRoZSBlbGVtZW50cyB3aGlsZSBwYWlyaW5nIHRoZW0gb2ZmLiBFdmVyeSBwYWlyIGdldHMgYW5cbi8vICAgIGBwYWlyYCBvYmplY3QgYW5kIGEgZ3V0dGVyLlxuLy8gNS4gQWN0dWFsbHkgc2l6ZSB0aGUgcGFpciBlbGVtZW50cywgaW5zZXJ0IGd1dHRlcnMgYW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG52YXIgU3BsaXQgPSBmdW5jdGlvbiAoaWRzT3B0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgICBpZiAoc3NyKSB7IHJldHVybiB7fSB9XG5cbiAgICB2YXIgaWRzID0gaWRzT3B0aW9uO1xuICAgIHZhciBkaW1lbnNpb247XG4gICAgdmFyIGNsaWVudEF4aXM7XG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIHZhciBwb3NpdGlvbkVuZDtcbiAgICB2YXIgY2xpZW50U2l6ZTtcbiAgICB2YXIgZWxlbWVudHM7XG5cbiAgICAvLyBBbGxvdyBIVE1MQ29sbGVjdGlvbiB0byBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHdoZW4gc3VwcG9ydGVkXG4gICAgaWYgKEFycmF5LmZyb20pIHtcbiAgICAgICAgaWRzID0gQXJyYXkuZnJvbShpZHMpO1xuICAgIH1cblxuICAgIC8vIEFsbCBET00gZWxlbWVudHMgaW4gdGhlIHNwbGl0IHNob3VsZCBoYXZlIGEgY29tbW9uIHBhcmVudC4gV2UgY2FuIGdyYWJcbiAgICAvLyB0aGUgZmlyc3QgZWxlbWVudHMgcGFyZW50IGFuZCBob3BlIHVzZXJzIHJlYWQgdGhlIGRvY3MgYmVjYXVzZSB0aGVcbiAgICAvLyBiZWhhdmlvciB3aWxsIGJlIHdoYWNreSBvdGhlcndpc2UuXG4gICAgdmFyIGZpcnN0RWxlbWVudCA9IGVsZW1lbnRPclNlbGVjdG9yKGlkc1swXSk7XG4gICAgdmFyIHBhcmVudCA9IGZpcnN0RWxlbWVudC5wYXJlbnROb2RlO1xuICAgIHZhciBwYXJlbnRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUgPyBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkgOiBudWxsO1xuICAgIHZhciBwYXJlbnRGbGV4RGlyZWN0aW9uID0gcGFyZW50U3R5bGUgPyBwYXJlbnRTdHlsZS5mbGV4RGlyZWN0aW9uIDogbnVsbDtcblxuICAgIC8vIFNldCBkZWZhdWx0IG9wdGlvbnMuc2l6ZXMgdG8gZXF1YWwgcGVyY2VudGFnZXMgb2YgdGhlIHBhcmVudCBlbGVtZW50LlxuICAgIHZhciBzaXplcyA9IGdldE9wdGlvbihvcHRpb25zLCAnc2l6ZXMnKSB8fCBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEwMCAvIGlkcy5sZW5ndGg7IH0pO1xuXG4gICAgLy8gU3RhbmRhcmRpemUgbWluU2l6ZSBhbmQgbWF4U2l6ZSB0byBhbiBhcnJheSBpZiBpdCBpc24ndCBhbHJlYWR5LlxuICAgIC8vIFRoaXMgYWxsb3dzIG1pblNpemUgYW5kIG1heFNpemUgdG8gYmUgcGFzc2VkIGFzIGEgbnVtYmVyLlxuICAgIHZhciBtaW5TaXplID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdtaW5TaXplJywgMTAwKTtcbiAgICB2YXIgbWluU2l6ZXMgPSBBcnJheS5pc0FycmF5KG1pblNpemUpID8gbWluU2l6ZSA6IGlkcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluU2l6ZTsgfSk7XG4gICAgdmFyIG1heFNpemUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ21heFNpemUnLCBJbmZpbml0eSk7XG4gICAgdmFyIG1heFNpemVzID0gQXJyYXkuaXNBcnJheShtYXhTaXplKSA/IG1heFNpemUgOiBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFNpemU7IH0pO1xuXG4gICAgLy8gR2V0IG90aGVyIG9wdGlvbnNcbiAgICB2YXIgZXhwYW5kVG9NaW4gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2V4cGFuZFRvTWluJywgZmFsc2UpO1xuICAgIHZhciBndXR0ZXJTaXplID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJTaXplJywgMTApO1xuICAgIHZhciBndXR0ZXJBbGlnbiA9IGdldE9wdGlvbihvcHRpb25zLCAnZ3V0dGVyQWxpZ24nLCAnY2VudGVyJyk7XG4gICAgdmFyIHNuYXBPZmZzZXQgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3NuYXBPZmZzZXQnLCAzMCk7XG4gICAgdmFyIHNuYXBPZmZzZXRzID0gQXJyYXkuaXNBcnJheShzbmFwT2Zmc2V0KSA/IHNuYXBPZmZzZXQgOiBpZHMubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNuYXBPZmZzZXQ7IH0pO1xuICAgIHZhciBkcmFnSW50ZXJ2YWwgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RyYWdJbnRlcnZhbCcsIDEpO1xuICAgIHZhciBkaXJlY3Rpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgJ2RpcmVjdGlvbicsIEhPUklaT05UQUwpO1xuICAgIHZhciBjdXJzb3IgPSBnZXRPcHRpb24oXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgICdjdXJzb3InLFxuICAgICAgICBkaXJlY3Rpb24gPT09IEhPUklaT05UQUwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSdcbiAgICApO1xuICAgIHZhciBndXR0ZXIgPSBnZXRPcHRpb24ob3B0aW9ucywgJ2d1dHRlcicsIGRlZmF1bHRHdXR0ZXJGbik7XG4gICAgdmFyIGVsZW1lbnRTdHlsZSA9IGdldE9wdGlvbihcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgJ2VsZW1lbnRTdHlsZScsXG4gICAgICAgIGRlZmF1bHRFbGVtZW50U3R5bGVGblxuICAgICk7XG4gICAgdmFyIGd1dHRlclN0eWxlID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdndXR0ZXJTdHlsZScsIGRlZmF1bHRHdXR0ZXJTdHlsZUZuKTtcblxuICAgIC8vIDIuIEluaXRpYWxpemUgYSBidW5jaCBvZiBzdHJpbmdzIGJhc2VkIG9uIHRoZSBkaXJlY3Rpb24gd2UncmUgc3BsaXR0aW5nLlxuICAgIC8vIEEgbG90IG9mIHRoZSBiZWhhdmlvciBpbiB0aGUgcmVzdCBvZiB0aGUgbGlicmFyeSBpcyBwYXJhbWF0aXplZCBkb3duIHRvXG4gICAgLy8gcmVseSBvbiBDU1Mgc3RyaW5ncyBhbmQgY2xhc3Nlcy5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBIT1JJWk9OVEFMKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICd3aWR0aCc7XG4gICAgICAgIGNsaWVudEF4aXMgPSAnY2xpZW50WCc7XG4gICAgICAgIHBvc2l0aW9uID0gJ2xlZnQnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdyaWdodCc7XG4gICAgICAgIGNsaWVudFNpemUgPSAnY2xpZW50V2lkdGgnO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgIGRpbWVuc2lvbiA9ICdoZWlnaHQnO1xuICAgICAgICBjbGllbnRBeGlzID0gJ2NsaWVudFknO1xuICAgICAgICBwb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgICBwb3NpdGlvbkVuZCA9ICdib3R0b20nO1xuICAgICAgICBjbGllbnRTaXplID0gJ2NsaWVudEhlaWdodCc7XG4gICAgfVxuXG4gICAgLy8gMy4gRGVmaW5lIHRoZSBkcmFnZ2luZyBoZWxwZXIgZnVuY3Rpb25zLCBhbmQgYSBmZXcgaGVscGVycyB0byBnbyB3aXRoIHRoZW0uXG4gICAgLy8gRWFjaCBoZWxwZXIgaXMgYm91bmQgdG8gYSBwYWlyIG9iamVjdCB0aGF0IGNvbnRhaW5zIGl0cyBtZXRhZGF0YS4gVGhpc1xuICAgIC8vIGFsc28gbWFrZXMgaXQgZWFzeSB0byBzdG9yZSByZWZlcmVuY2VzIHRvIGxpc3RlbmVycyB0aGF0IHRoYXQgd2lsbCBiZVxuICAgIC8vIGFkZGVkIGFuZCByZW1vdmVkLlxuICAgIC8vXG4gICAgLy8gRXZlbiB0aG91Z2ggdGhlcmUgYXJlIG5vIG90aGVyIGZ1bmN0aW9ucyBjb250YWluZWQgaW4gdGhlbSwgYWxpYXNpbmdcbiAgICAvLyB0aGlzIHRvIHNlbGYgc2F2ZXMgNTAgYnl0ZXMgb3Igc28gc2luY2UgaXQncyB1c2VkIHNvIGZyZXF1ZW50bHkuXG4gICAgLy9cbiAgICAvLyBUaGUgcGFpciBvYmplY3Qgc2F2ZXMgbWV0YWRhdGEgbGlrZSBkcmFnZ2luZyBzdGF0ZSwgcG9zaXRpb24gYW5kXG4gICAgLy8gZXZlbnQgbGlzdGVuZXIgcmVmZXJlbmNlcy5cblxuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTaXplKGVsLCBzaXplLCBndXRTaXplLCBpKSB7XG4gICAgICAgIC8vIFNwbGl0LmpzIGFsbG93cyBzZXR0aW5nIHNpemVzIHZpYSBudW1iZXJzIChpZGVhbGx5KSwgb3IgaWYgeW91IG11c3QsXG4gICAgICAgIC8vIGJ5IHN0cmluZywgbGlrZSAnMzAwcHgnLiBUaGlzIGlzIGxlc3MgdGhhbiBpZGVhbCwgYmVjYXVzZSBpdCBicmVha3NcbiAgICAgICAgLy8gdGhlIGZsdWlkIGxheW91dCB0aGF0IGBjYWxjKCUgLSBweClgIHByb3ZpZGVzLiBZb3UncmUgb24geW91ciBvd24gaWYgeW91IGRvIHRoYXQsXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB5b3UgY2FsY3VsYXRlIHRoZSBndXR0ZXIgc2l6ZSBieSBoYW5kLlxuICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50U3R5bGUoZGltZW5zaW9uLCBzaXplLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBlbC5zdHlsZVtwcm9wXSA9IHN0eWxlW3Byb3BdO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRHdXR0ZXJTaXplKGd1dHRlckVsZW1lbnQsIGd1dFNpemUsIGkpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZ3V0dGVyU3R5bGUoZGltZW5zaW9uLCBndXRTaXplLCBpKTtcblxuICAgICAgICBPYmplY3Qua2V5cyhzdHlsZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVbcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNpemVzKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnNpemU7IH0pXG4gICAgfVxuXG4gICAgLy8gU3VwcG9ydHMgdG91Y2ggZXZlbnRzLCBidXQgbm90IG11bHRpdG91Y2gsIHNvIG9ubHkgdGhlIGZpcnN0XG4gICAgLy8gZmluZ2VyIGB0b3VjaGVzWzBdYCBpcyBjb3VudGVkLlxuICAgIGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgICAgICBpZiAoJ3RvdWNoZXMnIGluIGUpIHsgcmV0dXJuIGUudG91Y2hlc1swXVtjbGllbnRBeGlzXSB9XG4gICAgICAgIHJldHVybiBlW2NsaWVudEF4aXNdXG4gICAgfVxuXG4gICAgLy8gQWN0dWFsbHkgYWRqdXN0IHRoZSBzaXplIG9mIGVsZW1lbnRzIGBhYCBhbmQgYGJgIHRvIGBvZmZzZXRgIHdoaWxlIGRyYWdnaW5nLlxuICAgIC8vIGNhbGMgaXMgdXNlZCB0byBhbGxvdyBjYWxjKHBlcmNlbnRhZ2UgKyBndXR0ZXJweCkgb24gdGhlIHdob2xlIHNwbGl0IGluc3RhbmNlLFxuICAgIC8vIHdoaWNoIGFsbG93cyB0aGUgdmlld3BvcnQgdG8gYmUgcmVzaXplZCB3aXRob3V0IGFkZGl0aW9uYWwgbG9naWMuXG4gICAgLy8gRWxlbWVudCBhJ3Mgc2l6ZSBpcyB0aGUgc2FtZSBhcyBvZmZzZXQuIGIncyBzaXplIGlzIHRvdGFsIHNpemUgLSBhIHNpemUuXG4gICAgLy8gQm90aCBzaXplcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBpbml0aWFsIHBhcmVudCBwZXJjZW50YWdlLFxuICAgIC8vIHRoZW4gdGhlIGd1dHRlciBzaXplIGlzIHN1YnRyYWN0ZWQuXG4gICAgZnVuY3Rpb24gYWRqdXN0KG9mZnNldCkge1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3RoaXMuYV07XG4gICAgICAgIHZhciBiID0gZWxlbWVudHNbdGhpcy5iXTtcbiAgICAgICAgdmFyIHBlcmNlbnRhZ2UgPSBhLnNpemUgKyBiLnNpemU7XG5cbiAgICAgICAgYS5zaXplID0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuICAgICAgICBiLnNpemUgPSBwZXJjZW50YWdlIC0gKG9mZnNldCAvIHRoaXMuc2l6ZSkgKiBwZXJjZW50YWdlO1xuXG4gICAgICAgIHNldEVsZW1lbnRTaXplKGEuZWxlbWVudCwgYS5zaXplLCB0aGlzW2FHdXR0ZXJTaXplXSwgYS5pKTtcbiAgICAgICAgc2V0RWxlbWVudFNpemUoYi5lbGVtZW50LCBiLnNpemUsIHRoaXNbYkd1dHRlclNpemVdLCBiLmkpO1xuICAgIH1cblxuICAgIC8vIGRyYWcsIHdoZXJlIGFsbCB0aGUgbWFnaWMgaGFwcGVucy4gVGhlIGxvZ2ljIGlzIHJlYWxseSBxdWl0ZSBzaW1wbGU6XG4gICAgLy9cbiAgICAvLyAxLiBJZ25vcmUgaWYgdGhlIHBhaXIgaXMgbm90IGRyYWdnaW5nLlxuICAgIC8vIDIuIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudC5cbiAgICAvLyAzLiBTbmFwIG9mZnNldCB0byBtaW4gaWYgd2l0aGluIHNuYXBwYWJsZSByYW5nZSAod2l0aGluIG1pbiArIHNuYXBPZmZzZXQpLlxuICAgIC8vIDQuIEFjdHVhbGx5IGFkanVzdCBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhaXIgdG8gb2Zmc2V0LlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICB8IDwtIGEubWluU2l6ZSAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICBiLm1pblNpemUgLT4gfCAgICB8XG4gICAgLy8gfCAgICB8ICB8IDwtIHRoaXMuc25hcE9mZnNldCAgICAgIHx8ICAgICB0aGlzLnNuYXBPZmZzZXQgLT4gfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gfCAgICB8ICB8ICAgICAgICAgICAgICAgICAgICAgICAgIHx8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgfCAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCA8LSB0aGlzLnN0YXJ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSAtPiB8XG4gICAgZnVuY3Rpb24gZHJhZyhlKSB7XG4gICAgICAgIHZhciBvZmZzZXQ7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXTtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1t0aGlzLmJdO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnZ2luZykgeyByZXR1cm4gfVxuXG4gICAgICAgIC8vIEdldCB0aGUgb2Zmc2V0IG9mIHRoZSBldmVudCBmcm9tIHRoZSBmaXJzdCBzaWRlIG9mIHRoZVxuICAgICAgICAvLyBwYWlyIGB0aGlzLnN0YXJ0YC4gVGhlbiBvZmZzZXQgYnkgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlXG4gICAgICAgIC8vIG1vdXNlIGNvbXBhcmVkIHRvIHRoZSBndXR0ZXIgc2l6ZS5cbiAgICAgICAgb2Zmc2V0ID1cbiAgICAgICAgICAgIGdldE1vdXNlUG9zaXRpb24oZSkgLVxuICAgICAgICAgICAgdGhpcy5zdGFydCArXG4gICAgICAgICAgICAodGhpc1thR3V0dGVyU2l6ZV0gLSB0aGlzLmRyYWdPZmZzZXQpO1xuXG4gICAgICAgIGlmIChkcmFnSW50ZXJ2YWwgPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKG9mZnNldCAvIGRyYWdJbnRlcnZhbCkgKiBkcmFnSW50ZXJ2YWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3aXRoaW4gc25hcE9mZnNldCBvZiBtaW4gb3IgbWF4LCBzZXQgb2Zmc2V0IHRvIG1pbiBvciBtYXguXG4gICAgICAgIC8vIHNuYXBPZmZzZXQgYnVmZmVycyBhLm1pblNpemUgYW5kIGIubWluU2l6ZSwgc28gbG9naWMgaXMgb3Bwb3NpdGUgZm9yIGJvdGguXG4gICAgICAgIC8vIEluY2x1ZGUgdGhlIGFwcHJvcHJpYXRlIGd1dHRlciBzaXplcyB0byBwcmV2ZW50IG92ZXJmbG93cy5cbiAgICAgICAgaWYgKG9mZnNldCA8PSBhLm1pblNpemUgKyBhLnNuYXBPZmZzZXQgKyB0aGlzW2FHdXR0ZXJTaXplXSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYS5taW5TaXplICsgdGhpc1thR3V0dGVyU2l6ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBvZmZzZXQgPj1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtIChiLm1pblNpemUgKyBiLnNuYXBPZmZzZXQgKyB0aGlzW2JHdXR0ZXJTaXplXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNpemUgLSAoYi5taW5TaXplICsgdGhpc1tiR3V0dGVyU2l6ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldCA+PSBhLm1heFNpemUgLSBhLnNuYXBPZmZzZXQgKyB0aGlzW2FHdXR0ZXJTaXplXSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gYS5tYXhTaXplICsgdGhpc1thR3V0dGVyU2l6ZV07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBvZmZzZXQgPD1cbiAgICAgICAgICAgIHRoaXMuc2l6ZSAtIChiLm1heFNpemUgLSBiLnNuYXBPZmZzZXQgKyB0aGlzW2JHdXR0ZXJTaXplXSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNpemUgLSAoYi5tYXhTaXplICsgdGhpc1tiR3V0dGVyU2l6ZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWN0dWFsbHkgYWRqdXN0IHRoZSBzaXplLlxuICAgICAgICBhZGp1c3QuY2FsbCh0aGlzLCBvZmZzZXQpO1xuXG4gICAgICAgIC8vIENhbGwgdGhlIGRyYWcgY2FsbGJhY2sgY29udGlub3VzbHkuIERvbid0IGRvIGFueXRoaW5nIHRvbyBpbnRlbnNpdmVcbiAgICAgICAgLy8gaW4gdGhpcyBjYWxsYmFjay5cbiAgICAgICAgZ2V0T3B0aW9uKG9wdGlvbnMsICdvbkRyYWcnLCBOT09QKShnZXRTaXplcygpKTtcbiAgICB9XG5cbiAgICAvLyBDYWNoZSBzb21lIGltcG9ydGFudCBzaXplcyB3aGVuIGRyYWcgc3RhcnRzLCBzbyB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoYXRcbiAgICAvLyBjb250aW5vdXNseTpcbiAgICAvL1xuICAgIC8vIGBzaXplYDogVGhlIHRvdGFsIHNpemUgb2YgdGhlIHBhaXIuIEZpcnN0ICsgc2Vjb25kICsgZmlyc3QgZ3V0dGVyICsgc2Vjb25kIGd1dHRlci5cbiAgICAvLyBgc3RhcnRgOiBUaGUgbGVhZGluZyBzaWRlIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCAgICAgIGFHdXR0ZXJTaXplIC0+IHx8fCAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgICAgIHx8fCAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgICAgIHx8fCAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgICAgICAgICAgIHx8fCA8LSBiR3V0dGVyU2l6ZSAgICAgICB8XG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gfCA8LSBzdGFydCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSAtPiB8XG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZXMoKSB7XG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIHBhcmVudCBzaXplIG1pbnVzIHBhZGRpbmcuXG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbdGhpcy5hXS5lbGVtZW50O1xuICAgICAgICB2YXIgYiA9IGVsZW1lbnRzW3RoaXMuYl0uZWxlbWVudDtcblxuICAgICAgICB2YXIgYUJvdW5kcyA9IGFbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpO1xuICAgICAgICB2YXIgYkJvdW5kcyA9IGJbZ2V0Qm91bmRpbmdDbGllbnRSZWN0XSgpO1xuXG4gICAgICAgIHRoaXMuc2l6ZSA9XG4gICAgICAgICAgICBhQm91bmRzW2RpbWVuc2lvbl0gK1xuICAgICAgICAgICAgYkJvdW5kc1tkaW1lbnNpb25dICtcbiAgICAgICAgICAgIHRoaXNbYUd1dHRlclNpemVdICtcbiAgICAgICAgICAgIHRoaXNbYkd1dHRlclNpemVdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gYUJvdW5kc1twb3NpdGlvbl07XG4gICAgICAgIHRoaXMuZW5kID0gYUJvdW5kc1twb3NpdGlvbkVuZF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5uZXJTaXplKGVsZW1lbnQpIHtcbiAgICAgICAgLy8gUmV0dXJuIG5vdGhpbmcgaWYgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBub3Qgc3VwcG9ydGVkICg8IElFOSlcbiAgICAgICAgLy8gT3IgaWYgcGFyZW50IGVsZW1lbnQgaGFzIG5vIGxheW91dCB5ZXRcbiAgICAgICAgaWYgKCFnZXRDb21wdXRlZFN0eWxlKSB7IHJldHVybiBudWxsIH1cblxuICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFjb21wdXRlZFN0eWxlKSB7IHJldHVybiBudWxsIH1cblxuICAgICAgICB2YXIgc2l6ZSA9IGVsZW1lbnRbY2xpZW50U2l6ZV07XG5cbiAgICAgICAgaWYgKHNpemUgPT09IDApIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IEhPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHNpemUgLT1cbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICtcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgLT1cbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ1RvcCkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaXplXG4gICAgfVxuXG4gICAgLy8gV2hlbiBzcGVjaWZ5aW5nIHBlcmNlbnRhZ2Ugc2l6ZXMgdGhhdCBhcmUgbGVzcyB0aGFuIHRoZSBjb21wdXRlZFxuICAgIC8vIHNpemUgb2YgdGhlIGVsZW1lbnQgbWludXMgdGhlIGd1dHRlciwgdGhlIGxlc3NlciBwZXJjZW50YWdlcyBtdXN0IGJlIGluY3JlYXNlZFxuICAgIC8vIChhbmQgZGVjcmVhc2VkIGZyb20gdGhlIG90aGVyIGVsZW1lbnRzKSB0byBtYWtlIHNwYWNlIGZvciB0aGUgcGl4ZWxzXG4gICAgLy8gc3VidHJhY3RlZCBieSB0aGUgZ3V0dGVycy5cbiAgICBmdW5jdGlvbiB0cmltVG9NaW4oc2l6ZXNUb1RyaW0pIHtcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBpbm5lciBzaXplIG9mIHBhcmVudCBlbGVtZW50LlxuICAgICAgICAvLyBJZiBpdCdzIG5vIHN1cHBvcnRlZCwgcmV0dXJuIG9yaWdpbmFsIHNpemVzLlxuICAgICAgICB2YXIgcGFyZW50U2l6ZSA9IGlubmVyU2l6ZShwYXJlbnQpO1xuICAgICAgICBpZiAocGFyZW50U2l6ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemVzVG9UcmltXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluU2l6ZXMucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYjsgfSwgMCkgPiBwYXJlbnRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZXNUb1RyaW1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIGV4Y2VzcyBwaXhlbHMsIHRoZSBhbW91bnQgb2YgcGl4ZWxzIG92ZXIgdGhlIGRlc2lyZWQgcGVyY2VudGFnZVxuICAgICAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2YgdGhlIGVsZW1lbnRzIHdpdGggcGl4ZWxzIHRvIHNwYXJlLCB0byBkZWNyZWFzZSBhZnRlciBpZiBuZWVkZWRcbiAgICAgICAgdmFyIGV4Y2Vzc1BpeGVscyA9IDA7XG4gICAgICAgIHZhciB0b1NwYXJlID0gW107XG5cbiAgICAgICAgdmFyIHBpeGVsU2l6ZXMgPSBzaXplc1RvVHJpbS5tYXAoZnVuY3Rpb24gKHNpemUsIGkpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmVxdWVzdGVkIHBlcmNlbnRhZ2VzIHRvIHBpeGVsIHNpemVzXG4gICAgICAgICAgICB2YXIgcGl4ZWxTaXplID0gKHBhcmVudFNpemUgKiBzaXplKSAvIDEwMDtcbiAgICAgICAgICAgIHZhciBlbGVtZW50R3V0dGVyU2l6ZSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBpID09PSAwLFxuICAgICAgICAgICAgICAgIGkgPT09IHNpemVzVG9UcmltLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgZ3V0dGVyQWxpZ25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB2YXIgZWxlbWVudE1pblNpemUgPSBtaW5TaXplc1tpXSArIGVsZW1lbnRHdXR0ZXJTaXplO1xuXG4gICAgICAgICAgICAvLyBJZiBlbGVtZW50IGlzIHRvbyBzbWFsLCBpbmNyZWFzZSBleGNlc3MgcGl4ZWxzIGJ5IHRoZSBkaWZmZXJlbmNlXG4gICAgICAgICAgICAvLyBhbmQgbWFyayB0aGF0IGl0IGhhcyBubyBwaXhlbHMgdG8gc3BhcmVcbiAgICAgICAgICAgIGlmIChwaXhlbFNpemUgPCBlbGVtZW50TWluU2l6ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2Vzc1BpeGVscyArPSBlbGVtZW50TWluU2l6ZSAtIHBpeGVsU2l6ZTtcbiAgICAgICAgICAgICAgICB0b1NwYXJlLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRNaW5TaXplXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgbWFyayB0aGUgcGl4ZWxzIGl0IGhhcyB0byBzcGFyZSBhbmQgcmV0dXJuIGl0J3Mgb3JpZ2luYWwgc2l6ZVxuICAgICAgICAgICAgdG9TcGFyZS5wdXNoKHBpeGVsU2l6ZSAtIGVsZW1lbnRNaW5TaXplKTtcbiAgICAgICAgICAgIHJldHVybiBwaXhlbFNpemVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgbm90aGluZyB3YXMgYWRqdXN0ZWQsIHJldHVybiB0aGUgb3JpZ2luYWwgc2l6ZXNcbiAgICAgICAgaWYgKGV4Y2Vzc1BpeGVscyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHNpemVzVG9UcmltXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGl4ZWxTaXplcy5tYXAoZnVuY3Rpb24gKHBpeGVsU2l6ZSwgaSkge1xuICAgICAgICAgICAgdmFyIG5ld1BpeGVsU2l6ZSA9IHBpeGVsU2l6ZTtcblxuICAgICAgICAgICAgLy8gV2hpbGUgdGhlcmUncyBzdGlsbCBwaXhlbHMgdG8gdGFrZSwgYW5kIHRoZXJlJ3MgZW5vdWdoIHBpeGVscyB0byBzcGFyZSxcbiAgICAgICAgICAgIC8vIHRha2UgYXMgbWFueSBhcyBwb3NzaWJsZSB1cCB0byB0aGUgdG90YWwgZXhjZXNzIHBpeGVsc1xuICAgICAgICAgICAgaWYgKGV4Y2Vzc1BpeGVscyA+IDAgJiYgdG9TcGFyZVtpXSAtIGV4Y2Vzc1BpeGVscyA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFrZW5QaXhlbHMgPSBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgZXhjZXNzUGl4ZWxzLFxuICAgICAgICAgICAgICAgICAgICB0b1NwYXJlW2ldIC0gZXhjZXNzUGl4ZWxzXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHRoZSBhbW91bnQgdGFrZW4gZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIGV4Y2Vzc1BpeGVscyAtPSB0YWtlblBpeGVscztcbiAgICAgICAgICAgICAgICBuZXdQaXhlbFNpemUgPSBwaXhlbFNpemUgLSB0YWtlblBpeGVscztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBwaXhlbCBzaXplIGFkanVzdGVkIGFzIGEgcGVyY2VudGFnZVxuICAgICAgICAgICAgcmV0dXJuIChuZXdQaXhlbFNpemUgLyBwYXJlbnRTaXplKSAqIDEwMFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIC8vIHN0b3BEcmFnZ2luZyBpcyB2ZXJ5IHNpbWlsYXIgdG8gc3RhcnREcmFnZ2luZyBpbiByZXZlcnNlLlxuICAgIGZ1bmN0aW9uIHN0b3BEcmFnZ2luZygpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYSA9IGVsZW1lbnRzW3NlbGYuYV0uZWxlbWVudDtcbiAgICAgICAgdmFyIGIgPSBlbGVtZW50c1tzZWxmLmJdLmVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHNlbGYuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGdldE9wdGlvbihvcHRpb25zLCAnb25EcmFnRW5kJywgTk9PUCkoZ2V0U2l6ZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdG9yZWQgZXZlbnQgbGlzdGVuZXJzLiBUaGlzIGlzIHdoeSB3ZSBzdG9yZSB0aGVtLlxuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ21vdXNldXAnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbcmVtb3ZlRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoZW5kJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCd0b3VjaGNhbmNlbCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFtyZW1vdmVFdmVudExpc3RlbmVyXSgnbW91c2Vtb3ZlJywgc2VsZi5tb3ZlKTtcbiAgICAgICAgZ2xvYmFsW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCd0b3VjaG1vdmUnLCBzZWxmLm1vdmUpO1xuXG4gICAgICAgIC8vIENsZWFyIGJvdW5kIGZ1bmN0aW9uIHJlZmVyZW5jZXNcbiAgICAgICAgc2VsZi5zdG9wID0gbnVsbDtcbiAgICAgICAgc2VsZi5tb3ZlID0gbnVsbDtcblxuICAgICAgICBhW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBhW3JlbW92ZUV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcbiAgICAgICAgYltyZW1vdmVFdmVudExpc3RlbmVyXSgnc2VsZWN0c3RhcnQnLCBOT09QKTtcbiAgICAgICAgYltyZW1vdmVFdmVudExpc3RlbmVyXSgnZHJhZ3N0YXJ0JywgTk9PUCk7XG5cbiAgICAgICAgYS5zdHlsZS51c2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGEuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBhLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG5cbiAgICAgICAgYi5zdHlsZS51c2VyU2VsZWN0ID0gJyc7XG4gICAgICAgIGIuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICcnO1xuICAgICAgICBiLnN0eWxlLk1velVzZXJTZWxlY3QgPSAnJztcbiAgICAgICAgYi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG5cbiAgICAgICAgc2VsZi5ndXR0ZXIuc3R5bGUuY3Vyc29yID0gJyc7XG4gICAgICAgIHNlbGYucGFyZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0RHJhZ2dpbmcgY2FsbHMgYGNhbGN1bGF0ZVNpemVzYCB0byBzdG9yZSB0aGUgaW5pdGFsIHNpemUgaW4gdGhlIHBhaXIgb2JqZWN0LlxuICAgIC8vIEl0IGFsc28gYWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIG1vdXNlL3RvdWNoIGV2ZW50cyxcbiAgICAvLyBhbmQgcHJldmVudHMgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nIHNvIGF2b2lkIHRoZSBzZWxlY3RpbmcgdGV4dC5cbiAgICBmdW5jdGlvbiBzdGFydERyYWdnaW5nKGUpIHtcbiAgICAgICAgLy8gUmlnaHQtY2xpY2tpbmcgY2FuJ3Qgc3RhcnQgZHJhZ2dpbmcuXG4gICAgICAgIGlmICgnYnV0dG9uJyBpbiBlICYmIGUuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsaWFzIGZyZXF1ZW50bHkgdXNlZCB2YXJpYWJsZXMgdG8gc2F2ZSBzcGFjZS4gMjAwIGJ5dGVzLlxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBhID0gZWxlbWVudHNbc2VsZi5hXS5lbGVtZW50O1xuICAgICAgICB2YXIgYiA9IGVsZW1lbnRzW3NlbGYuYl0uZWxlbWVudDtcblxuICAgICAgICAvLyBDYWxsIHRoZSBvbkRyYWdTdGFydCBjYWxsYmFjay5cbiAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBnZXRPcHRpb24ob3B0aW9ucywgJ29uRHJhZ1N0YXJ0JywgTk9PUCkoZ2V0U2l6ZXMoKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEb24ndCBhY3R1YWxseSBkcmFnIHRoZSBlbGVtZW50LiBXZSBlbXVsYXRlIHRoYXQgaW4gdGhlIGRyYWcgZnVuY3Rpb24uXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBTZXQgdGhlIGRyYWdnaW5nIHByb3BlcnR5IG9mIHRoZSBwYWlyIG9iamVjdC5cbiAgICAgICAgc2VsZi5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHR3byBldmVudCBsaXN0ZW5lcnMgYm91bmQgdG8gdGhlIHNhbWUgcGFpciBvYmplY3QgYW5kIHN0b3JlXG4gICAgICAgIC8vIHRoZW0gaW4gdGhlIHBhaXIgb2JqZWN0LlxuICAgICAgICBzZWxmLm1vdmUgPSBkcmFnLmJpbmQoc2VsZik7XG4gICAgICAgIHNlbGYuc3RvcCA9IHN0b3BEcmFnZ2luZy5iaW5kKHNlbGYpO1xuXG4gICAgICAgIC8vIEFsbCB0aGUgYmluZGluZy4gYHdpbmRvd2AgZ2V0cyB0aGUgc3RvcCBldmVudHMgaW4gY2FzZSB3ZSBkcmFnIG91dCBvZiB0aGUgZWxlbWVudHMuXG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgnbW91c2V1cCcsIHNlbGYuc3RvcCk7XG4gICAgICAgIGdsb2JhbFthZGRFdmVudExpc3RlbmVyXSgndG91Y2hlbmQnLCBzZWxmLnN0b3ApO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ3RvdWNoY2FuY2VsJywgc2VsZi5zdG9wKTtcbiAgICAgICAgZ2xvYmFsW2FkZEV2ZW50TGlzdGVuZXJdKCdtb3VzZW1vdmUnLCBzZWxmLm1vdmUpO1xuICAgICAgICBnbG9iYWxbYWRkRXZlbnRMaXN0ZW5lcl0oJ3RvdWNobW92ZScsIHNlbGYubW92ZSk7XG5cbiAgICAgICAgLy8gRGlzYWJsZSBzZWxlY3Rpb24uIERpc2FibGUhXG4gICAgICAgIGFbYWRkRXZlbnRMaXN0ZW5lcl0oJ3NlbGVjdHN0YXJ0JywgTk9PUCk7XG4gICAgICAgIGFbYWRkRXZlbnRMaXN0ZW5lcl0oJ2RyYWdzdGFydCcsIE5PT1ApO1xuICAgICAgICBiW2FkZEV2ZW50TGlzdGVuZXJdKCdzZWxlY3RzdGFydCcsIE5PT1ApO1xuICAgICAgICBiW2FkZEV2ZW50TGlzdGVuZXJdKCdkcmFnc3RhcnQnLCBOT09QKTtcblxuICAgICAgICBhLnN0eWxlLnVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGEuc3R5bGUud2Via2l0VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYS5zdHlsZS5Nb3pVc2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBhLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG5cbiAgICAgICAgYi5zdHlsZS51c2VyU2VsZWN0ID0gJ25vbmUnO1xuICAgICAgICBiLnN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSAnbm9uZSc7XG4gICAgICAgIGIuc3R5bGUuTW96VXNlclNlbGVjdCA9ICdub25lJztcbiAgICAgICAgYi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgICAgIC8vIFNldCB0aGUgY3Vyc29yIGF0IG11bHRpcGxlIGxldmVsc1xuICAgICAgICBzZWxmLmd1dHRlci5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gICAgICAgIHNlbGYucGFyZW50LnN0eWxlLmN1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG5cbiAgICAgICAgLy8gQ2FjaGUgdGhlIGluaXRpYWwgc2l6ZXMgb2YgdGhlIHBhaXIuXG4gICAgICAgIGNhbGN1bGF0ZVNpemVzLmNhbGwoc2VsZik7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgbW91c2UgY29tcGFyZWQgdG8gdGhlIGd1dHRlclxuICAgICAgICBzZWxmLmRyYWdPZmZzZXQgPSBnZXRNb3VzZVBvc2l0aW9uKGUpIC0gc2VsZi5lbmQ7XG4gICAgfVxuXG4gICAgLy8gYWRqdXN0IHNpemVzIHRvIGVuc3VyZSBwZXJjZW50YWdlIGlzIHdpdGhpbiBtaW4gc2l6ZSBhbmQgZ3V0dGVyLlxuICAgIHNpemVzID0gdHJpbVRvTWluKHNpemVzKTtcblxuICAgIC8vIDUuIENyZWF0ZSBwYWlyIGFuZCBlbGVtZW50IG9iamVjdHMuIEVhY2ggcGFpciBoYXMgYW4gaW5kZXggcmVmZXJlbmNlIHRvXG4gICAgLy8gZWxlbWVudHMgYGFgIGFuZCBgYmAgb2YgdGhlIHBhaXIgKGZpcnN0IGFuZCBzZWNvbmQgZWxlbWVudHMpLlxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgZWxlbWVudHMgd2hpbGUgcGFpcmluZyB0aGVtIG9mZi4gRXZlcnkgcGFpciBnZXRzIGFcbiAgICAvLyBgcGFpcmAgb2JqZWN0IGFuZCBhIGd1dHRlci5cbiAgICAvL1xuICAgIC8vIEJhc2ljIGxvZ2ljOlxuICAgIC8vXG4gICAgLy8gLSBTdGFydGluZyB3aXRoIHRoZSBzZWNvbmQgZWxlbWVudCBgaSA+IDBgLCBjcmVhdGUgYHBhaXJgIG9iamVjdHMgd2l0aFxuICAgIC8vICAgYGEgPSBpIC0gMWAgYW5kIGBiID0gaWBcbiAgICAvLyAtIFNldCBndXR0ZXIgc2l6ZXMgYmFzZWQgb24gdGhlIF9wYWlyXyBiZWluZyBmaXJzdC9sYXN0LiBUaGUgZmlyc3QgYW5kIGxhc3RcbiAgICAvLyAgIHBhaXIgaGF2ZSBndXR0ZXJTaXplIC8gMiwgc2luY2UgdGhleSBvbmx5IGhhdmUgb25lIGhhbGYgZ3V0dGVyLCBhbmQgbm90IHR3by5cbiAgICAvLyAtIENyZWF0ZSBndXR0ZXIgZWxlbWVudHMgYW5kIGFkZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgLy8gLSBTZXQgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnRzLCBtaW51cyB0aGUgZ3V0dGVyIHNpemVzLlxuICAgIC8vXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB8ICAgICBpPTAgICAgIHwgICAgICAgICBpPTEgICAgICAgICB8ICAgICAgICBpPTIgICAgICAgfCAgICAgIGk9MyAgICAgfFxuICAgIC8vIHwgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgcGFpciAwICAgICAgICAgICAgICAgIHBhaXIgMSAgICAgICAgICAgICBwYWlyIDIgICAgICAgICAgIHxcbiAgICAvLyB8ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgdmFyIHBhaXJzID0gW107XG4gICAgZWxlbWVudHMgPSBpZHMubWFwKGZ1bmN0aW9uIChpZCwgaSkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGVsZW1lbnQgb2JqZWN0LlxuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRPclNlbGVjdG9yKGlkKSxcbiAgICAgICAgICAgIHNpemU6IHNpemVzW2ldLFxuICAgICAgICAgICAgbWluU2l6ZTogbWluU2l6ZXNbaV0sXG4gICAgICAgICAgICBtYXhTaXplOiBtYXhTaXplc1tpXSxcbiAgICAgICAgICAgIHNuYXBPZmZzZXQ6IHNuYXBPZmZzZXRzW2ldLFxuICAgICAgICAgICAgaTogaSxcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcGFpcjtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgcGFpciBvYmplY3Qgd2l0aCBpdHMgbWV0YWRhdGEuXG4gICAgICAgICAgICBwYWlyID0ge1xuICAgICAgICAgICAgICAgIGE6IGkgLSAxLFxuICAgICAgICAgICAgICAgIGI6IGksXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcGFpclthR3V0dGVyU2l6ZV0gPSBnZXRHdXR0ZXJTaXplKFxuICAgICAgICAgICAgICAgIGd1dHRlclNpemUsXG4gICAgICAgICAgICAgICAgaSAtIDEgPT09IDAsXG4gICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgZ3V0dGVyQWxpZ25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwYWlyW2JHdXR0ZXJTaXplXSA9IGdldEd1dHRlclNpemUoXG4gICAgICAgICAgICAgICAgZ3V0dGVyU2l6ZSxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgICBpID09PSBpZHMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICBndXR0ZXJBbGlnblxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBoYXMgYSByZXZlcnNlIGZsZXgtZGlyZWN0aW9uLCBzd2l0Y2ggdGhlIHBhaXIgZWxlbWVudHMuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGFyZW50RmxleERpcmVjdGlvbiA9PT0gJ3Jvdy1yZXZlcnNlJyB8fFxuICAgICAgICAgICAgICAgIHBhcmVudEZsZXhEaXJlY3Rpb24gPT09ICdjb2x1bW4tcmV2ZXJzZSdcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gcGFpci5hO1xuICAgICAgICAgICAgICAgIHBhaXIuYSA9IHBhaXIuYjtcbiAgICAgICAgICAgICAgICBwYWlyLmIgPSB0ZW1wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQuIElFOCBpcyBzdXBwb3J0ZWQgYnlcbiAgICAgICAgLy8gc3RhdGljbHkgYXNzaWduaW5nIHNpemVzIHdpdGhvdXQgZHJhZ2dhYmxlIGd1dHRlcnMuIEFzc2lnbnMgYSBzdHJpbmdcbiAgICAgICAgLy8gdG8gYHNpemVgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBDcmVhdGUgZ3V0dGVyIGVsZW1lbnRzIGZvciBlYWNoIHBhaXIuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgdmFyIGd1dHRlckVsZW1lbnQgPSBndXR0ZXIoaSwgZGlyZWN0aW9uLCBlbGVtZW50LmVsZW1lbnQpO1xuICAgICAgICAgICAgc2V0R3V0dGVyU2l6ZShndXR0ZXJFbGVtZW50LCBndXR0ZXJTaXplLCBpKTtcblxuICAgICAgICAgICAgLy8gU2F2ZSBib3VuZCBldmVudCBsaXN0ZW5lciBmb3IgcmVtb3ZhbCBsYXRlclxuICAgICAgICAgICAgcGFpcltndXR0ZXJTdGFydERyYWdnaW5nXSA9IHN0YXJ0RHJhZ2dpbmcuYmluZChwYWlyKTtcblxuICAgICAgICAgICAgLy8gQXR0YWNoIGJvdW5kIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50W2FkZEV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBndXR0ZXJFbGVtZW50W2FkZEV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgICAgICAgICBwYWlyW2d1dHRlclN0YXJ0RHJhZ2dpbmddXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGd1dHRlckVsZW1lbnQsIGVsZW1lbnQuZWxlbWVudCk7XG5cbiAgICAgICAgICAgIHBhaXIuZ3V0dGVyID0gZ3V0dGVyRWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEVsZW1lbnRTaXplKFxuICAgICAgICAgICAgZWxlbWVudC5lbGVtZW50LFxuICAgICAgICAgICAgZWxlbWVudC5zaXplLFxuICAgICAgICAgICAgZ2V0R3V0dGVyU2l6ZShcbiAgICAgICAgICAgICAgICBndXR0ZXJTaXplLFxuICAgICAgICAgICAgICAgIGkgPT09IDAsXG4gICAgICAgICAgICAgICAgaSA9PT0gaWRzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgZ3V0dGVyQWxpZ25cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBpXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYW5kIHdlIGhhdmUgYSBwYWlyIG9iamVjdCwgYXBwZW5kIGl0IHRvIHRoZVxuICAgICAgICAvLyBsaXN0IG9mIHBhaXJzLlxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2gocGFpcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZWxlbWVudFxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRqdXN0VG9NaW4oZWxlbWVudCkge1xuICAgICAgICB2YXIgaXNMYXN0ID0gZWxlbWVudC5pID09PSBwYWlycy5sZW5ndGg7XG4gICAgICAgIHZhciBwYWlyID0gaXNMYXN0ID8gcGFpcnNbZWxlbWVudC5pIC0gMV0gOiBwYWlyc1tlbGVtZW50LmldO1xuXG4gICAgICAgIGNhbGN1bGF0ZVNpemVzLmNhbGwocGFpcik7XG5cbiAgICAgICAgdmFyIHNpemUgPSBpc0xhc3RcbiAgICAgICAgICAgID8gcGFpci5zaXplIC0gZWxlbWVudC5taW5TaXplIC0gcGFpcltiR3V0dGVyU2l6ZV1cbiAgICAgICAgICAgIDogZWxlbWVudC5taW5TaXplICsgcGFpclthR3V0dGVyU2l6ZV07XG5cbiAgICAgICAgYWRqdXN0LmNhbGwocGFpciwgc2l6ZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB2YXIgY29tcHV0ZWRTaXplID0gZWxlbWVudC5lbGVtZW50W2dldEJvdW5kaW5nQ2xpZW50UmVjdF0oKVtkaW1lbnNpb25dO1xuXG4gICAgICAgIGlmIChjb21wdXRlZFNpemUgPCBlbGVtZW50Lm1pblNpemUpIHtcbiAgICAgICAgICAgIGlmIChleHBhbmRUb01pbikge1xuICAgICAgICAgICAgICAgIGFkanVzdFRvTWluKGVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1pblNpemUgPSBjb21wdXRlZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHNldFNpemVzKG5ld1NpemVzKSB7XG4gICAgICAgIHZhciB0cmltbWVkID0gdHJpbVRvTWluKG5ld1NpemVzKTtcbiAgICAgICAgdHJpbW1lZC5mb3JFYWNoKGZ1bmN0aW9uIChuZXdTaXplLCBpKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2kgLSAxXTtcblxuICAgICAgICAgICAgICAgIHZhciBhID0gZWxlbWVudHNbcGFpci5hXTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGVsZW1lbnRzW3BhaXIuYl07XG5cbiAgICAgICAgICAgICAgICBhLnNpemUgPSB0cmltbWVkW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBiLnNpemUgPSBuZXdTaXplO1xuXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNpemUoYS5lbGVtZW50LCBhLnNpemUsIHBhaXJbYUd1dHRlclNpemVdLCBhLmkpO1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTaXplKGIuZWxlbWVudCwgYi5zaXplLCBwYWlyW2JHdXR0ZXJTaXplXSwgYi5pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVzdHJveShwcmVzZXJ2ZVN0eWxlcywgcHJlc2VydmVHdXR0ZXIpIHtcbiAgICAgICAgcGFpcnMuZm9yRWFjaChmdW5jdGlvbiAocGFpcikge1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlR3V0dGVyICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcGFpci5wYXJlbnQucmVtb3ZlQ2hpbGQocGFpci5ndXR0ZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWlyLmd1dHRlcltyZW1vdmVFdmVudExpc3RlbmVyXShcbiAgICAgICAgICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHBhaXIuZ3V0dGVyW3JlbW92ZUV2ZW50TGlzdGVuZXJdKFxuICAgICAgICAgICAgICAgICAgICAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIHBhaXJbZ3V0dGVyU3RhcnREcmFnZ2luZ11cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocHJlc2VydmVTdHlsZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBlbGVtZW50U3R5bGUoXG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgcGFpci5hLnNpemUsXG4gICAgICAgICAgICAgICAgICAgIHBhaXJbYUd1dHRlclNpemVdXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzW3BhaXIuYV0uZWxlbWVudC5zdHlsZVtwcm9wXSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1twYWlyLmJdLmVsZW1lbnQuc3R5bGVbcHJvcF0gPSAnJztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2V0U2l6ZXM6IHNldFNpemVzLFxuICAgICAgICBnZXRTaXplczogZ2V0U2l6ZXMsXG4gICAgICAgIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZShpKSB7XG4gICAgICAgICAgICBhZGp1c3RUb01pbihlbGVtZW50c1tpXSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICBwYWlyczogcGFpcnMsXG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3BsaXQ7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBTcGxpdCBmcm9tICdzcGxpdC5qcyc7XG5cbmZ1bmN0aW9uIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIChvYmosIGV4Y2x1ZGUpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspICYmIGV4Y2x1ZGUuaW5kZXhPZihrKSA9PT0gLTEpIHRhcmdldFtrXSA9IG9ialtrXTsgcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU3BsaXRXcmFwcGVyID0gLypAX19QVVJFX18qLyhmdW5jdGlvbiAoc3VwZXJjbGFzcykge1xuICAgIGZ1bmN0aW9uIFNwbGl0V3JhcHBlciAoKSB7XG4gICAgICAgIHN1cGVyY2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIHN1cGVyY2xhc3MgKSBTcGxpdFdyYXBwZXIuX19wcm90b19fID0gc3VwZXJjbGFzcztcbiAgICBTcGxpdFdyYXBwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggc3VwZXJjbGFzcyAmJiBzdXBlcmNsYXNzLnByb3RvdHlwZSApO1xuICAgIFNwbGl0V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGxpdFdyYXBwZXI7XG5cbiAgICBTcGxpdFdyYXBwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQgKCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmVmLmNoaWxkcmVuO1xuICAgICAgICB2YXIgZ3V0dGVyID0gcmVmLmd1dHRlcjtcbiAgICAgICAgdmFyIHJlc3QgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyggcmVmLCBbXCJjaGlsZHJlblwiLCBcImd1dHRlclwiXSApO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHJlc3Q7XG5cbiAgICAgICAgb3B0aW9ucy5ndXR0ZXIgPSBmdW5jdGlvbiAoaW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGd1dHRlckVsZW1lbnQ7XG5cbiAgICAgICAgICAgIGlmIChndXR0ZXIpIHtcbiAgICAgICAgICAgICAgICBndXR0ZXJFbGVtZW50ID0gZ3V0dGVyKGluZGV4LCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBndXR0ZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZ3V0dGVyRWxlbWVudC5jbGFzc05hbWUgPSBcImd1dHRlciBndXR0ZXItXCIgKyBkaXJlY3Rpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgZ3V0dGVyRWxlbWVudC5fX2lzU3BsaXRHdXR0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGd1dHRlckVsZW1lbnRcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNwbGl0ID0gU3BsaXQodGhpcy5wYXJlbnQuY2hpbGRyZW4sIG9wdGlvbnMpO1xuICAgIH07XG5cbiAgICBTcGxpdFdyYXBwZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgICAgICByZWYuY2hpbGRyZW47XG4gICAgICAgIHZhciBtaW5TaXplID0gcmVmLm1pblNpemU7XG4gICAgICAgIHZhciBzaXplcyA9IHJlZi5zaXplcztcbiAgICAgICAgdmFyIGNvbGxhcHNlZCA9IHJlZi5jb2xsYXBzZWQ7XG4gICAgICAgIHZhciByZXN0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoIHJlZiwgW1wiY2hpbGRyZW5cIiwgXCJtaW5TaXplXCIsIFwic2l6ZXNcIiwgXCJjb2xsYXBzZWRcIl0gKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSByZXN0O1xuICAgICAgICB2YXIgcHJldk1pblNpemUgPSBwcmV2UHJvcHMubWluU2l6ZTtcbiAgICAgICAgdmFyIHByZXZTaXplcyA9IHByZXZQcm9wcy5zaXplcztcbiAgICAgICAgdmFyIHByZXZDb2xsYXBzZWQgPSBwcmV2UHJvcHMuY29sbGFwc2VkO1xuXG4gICAgICAgIHZhciBvdGhlclByb3BzID0gW1xuICAgICAgICAgICAgJ21heFNpemUnLFxuICAgICAgICAgICAgJ2V4cGFuZFRvTWluJyxcbiAgICAgICAgICAgICdndXR0ZXJTaXplJyxcbiAgICAgICAgICAgICdndXR0ZXJBbGlnbicsXG4gICAgICAgICAgICAnc25hcE9mZnNldCcsXG4gICAgICAgICAgICAnZHJhZ0ludGVydmFsJyxcbiAgICAgICAgICAgICdkaXJlY3Rpb24nLFxuICAgICAgICAgICAgJ2N1cnNvcicgXTtcblxuICAgICAgICB2YXIgbmVlZHNSZWNyZWF0ZSA9IG90aGVyUHJvcHNcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kZXN0cnVjdHVyaW5nLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHRoaXMkMS5wcm9wc1twcm9wXSAhPT0gcHJldlByb3BzW3Byb3BdOyB9KVxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHNhbWUpIHsgcmV0dXJuIGFjY3VtIHx8IHNhbWU7IH0sIGZhbHNlKTtcblxuICAgICAgICAvLyBDb21wYXJlIG1pblNpemUgd2hlbiBib3RoIGFyZSBhcnJheXMsIHdoZW4gb25lIGlzIGFuIGFycmF5IGFuZCB3aGVuIG5laXRoZXIgaXMgYW4gYXJyYXlcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWluU2l6ZSkgJiYgQXJyYXkuaXNBcnJheShwcmV2TWluU2l6ZSkpIHtcbiAgICAgICAgICAgIHZhciBtaW5TaXplQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBtaW5TaXplLmZvckVhY2goZnVuY3Rpb24gKG1pblNpemVJLCBpKSB7XG4gICAgICAgICAgICAgICAgbWluU2l6ZUNoYW5nZWQgPSBtaW5TaXplQ2hhbmdlZCB8fCBtaW5TaXplSSAhPT0gcHJldk1pblNpemVbaV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbmVlZHNSZWNyZWF0ZSA9IG5lZWRzUmVjcmVhdGUgfHwgbWluU2l6ZUNoYW5nZWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtaW5TaXplKSB8fCBBcnJheS5pc0FycmF5KHByZXZNaW5TaXplKSkge1xuICAgICAgICAgICAgbmVlZHNSZWNyZWF0ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlY3JlYXRlID0gbmVlZHNSZWNyZWF0ZSB8fCBtaW5TaXplICE9PSBwcmV2TWluU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc3Ryb3kgYW5kIHJlLWNyZWF0ZSBzcGxpdCBpZiBvcHRpb25zIGNoYW5nZWRcbiAgICAgICAgaWYgKG5lZWRzUmVjcmVhdGUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubWluU2l6ZSA9IG1pblNpemU7XG4gICAgICAgICAgICBvcHRpb25zLnNpemVzID0gc2l6ZXMgfHwgdGhpcy5zcGxpdC5nZXRTaXplcygpO1xuICAgICAgICAgICAgdGhpcy5zcGxpdC5kZXN0cm95KHRydWUsIHRydWUpO1xuICAgICAgICAgICAgb3B0aW9ucy5ndXR0ZXIgPSBmdW5jdGlvbiAoaW5kZXgsIGRpcmVjdGlvbiwgcGFpckIpIHsgcmV0dXJuIHBhaXJCLnByZXZpb3VzU2libGluZzsgfTtcbiAgICAgICAgICAgIHRoaXMuc3BsaXQgPSBTcGxpdChcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMucGFyZW50LmNoaWxkcmVuKS5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZWxlbWVudCkgeyByZXR1cm4gIWVsZW1lbnQuX19pc1NwbGl0R3V0dGVyOyB9XG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHNpemVzKSB7XG4gICAgICAgICAgICAvLyBJZiBvbmx5IHRoZSBzaXplIGhhcyBjaGFuZ2VkLCBzZXQgdGhlIHNpemUuIE5vIG5lZWQgdG8gZG8gdGhpcyBpZiByZS1jcmVhdGVkLlxuICAgICAgICAgICAgdmFyIHNpemVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHNpemVzLmZvckVhY2goZnVuY3Rpb24gKHNpemVJLCBpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZUNoYW5nZWQgPSBzaXplQ2hhbmdlZCB8fCBzaXplSSAhPT0gcHJldlNpemVzW2ldO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChzaXplQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kZXN0cnVjdHVyaW5nLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0LnNldFNpemVzKHRoaXMucHJvcHMuc2l6ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29sbGFwc2UgYWZ0ZXIgcmUtY3JlYXRlZCBvciB3aGVuIGNvbGxhcHNlZCBjaGFuZ2VkLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGNvbGxhcHNlZCkgJiZcbiAgICAgICAgICAgIChjb2xsYXBzZWQgIT09IHByZXZDb2xsYXBzZWQgfHwgbmVlZHNSZWNyZWF0ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGl0LmNvbGxhcHNlKGNvbGxhcHNlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgU3BsaXRXcmFwcGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICAgICAgdGhpcy5zcGxpdC5kZXN0cm95KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNwbGl0O1xuICAgIH07XG5cbiAgICBTcGxpdFdyYXBwZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICAgIHZhciByZWYgPSB0aGlzLnByb3BzO1xuICAgICAgICByZWYuc2l6ZXM7XG4gICAgICAgIHJlZi5taW5TaXplO1xuICAgICAgICByZWYubWF4U2l6ZTtcbiAgICAgICAgcmVmLmV4cGFuZFRvTWluO1xuICAgICAgICByZWYuZ3V0dGVyU2l6ZTtcbiAgICAgICAgcmVmLmd1dHRlckFsaWduO1xuICAgICAgICByZWYuc25hcE9mZnNldDtcbiAgICAgICAgcmVmLmRyYWdJbnRlcnZhbDtcbiAgICAgICAgcmVmLmRpcmVjdGlvbjtcbiAgICAgICAgcmVmLmN1cnNvcjtcbiAgICAgICAgcmVmLmd1dHRlcjtcbiAgICAgICAgcmVmLmVsZW1lbnRTdHlsZTtcbiAgICAgICAgcmVmLmd1dHRlclN0eWxlO1xuICAgICAgICByZWYub25EcmFnO1xuICAgICAgICByZWYub25EcmFnU3RhcnQ7XG4gICAgICAgIHJlZi5vbkRyYWdFbmQ7XG4gICAgICAgIHJlZi5jb2xsYXBzZWQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHJlZi5jaGlsZHJlbjtcbiAgICAgICAgdmFyIHJlc3QkMSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKCByZWYsIFtcInNpemVzXCIsIFwibWluU2l6ZVwiLCBcIm1heFNpemVcIiwgXCJleHBhbmRUb01pblwiLCBcImd1dHRlclNpemVcIiwgXCJndXR0ZXJBbGlnblwiLCBcInNuYXBPZmZzZXRcIiwgXCJkcmFnSW50ZXJ2YWxcIiwgXCJkaXJlY3Rpb25cIiwgXCJjdXJzb3JcIiwgXCJndXR0ZXJcIiwgXCJlbGVtZW50U3R5bGVcIiwgXCJndXR0ZXJTdHlsZVwiLCBcIm9uRHJhZ1wiLCBcIm9uRHJhZ1N0YXJ0XCIsIFwib25EcmFnRW5kXCIsIFwiY29sbGFwc2VkXCIsIFwiY2hpbGRyZW5cIl0gKTtcbiAgICAgICAgdmFyIHJlc3QgPSByZXN0JDE7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoICdkaXYnLCBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAgICAgICAgIHsgcmVmOiBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgfSB9LCByZXN0KSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICAgKVxuICAgICAgICApXG4gICAgfTtcblxuICAgIHJldHVybiBTcGxpdFdyYXBwZXI7XG59KFJlYWN0LkNvbXBvbmVudCkpO1xuXG5TcGxpdFdyYXBwZXIucHJvcFR5cGVzID0ge1xuICAgIHNpemVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcbiAgICBtaW5TaXplOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlcikgXSksXG4gICAgbWF4U2l6ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXIsXG4gICAgICAgIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpIF0pLFxuICAgIGV4cGFuZFRvTWluOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBndXR0ZXJTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGd1dHRlckFsaWduOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHNuYXBPZmZzZXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSBdKSxcbiAgICBkcmFnSW50ZXJ2YWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgZGlyZWN0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGN1cnNvcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBndXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIGVsZW1lbnRTdHlsZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ3V0dGVyU3R5bGU6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRHJhZzogUHJvcFR5cGVzLmZ1bmMsXG4gICAgb25EcmFnU3RhcnQ6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uRHJhZ0VuZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgY29sbGFwc2VkOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMuZWxlbWVudCksXG59O1xuXG5TcGxpdFdyYXBwZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIHNpemVzOiB1bmRlZmluZWQsXG4gICAgbWluU2l6ZTogdW5kZWZpbmVkLFxuICAgIG1heFNpemU6IHVuZGVmaW5lZCxcbiAgICBleHBhbmRUb01pbjogdW5kZWZpbmVkLFxuICAgIGd1dHRlclNpemU6IHVuZGVmaW5lZCxcbiAgICBndXR0ZXJBbGlnbjogdW5kZWZpbmVkLFxuICAgIHNuYXBPZmZzZXQ6IHVuZGVmaW5lZCxcbiAgICBkcmFnSW50ZXJ2YWw6IHVuZGVmaW5lZCxcbiAgICBkaXJlY3Rpb246IHVuZGVmaW5lZCxcbiAgICBjdXJzb3I6IHVuZGVmaW5lZCxcbiAgICBndXR0ZXI6IHVuZGVmaW5lZCxcbiAgICBlbGVtZW50U3R5bGU6IHVuZGVmaW5lZCxcbiAgICBndXR0ZXJTdHlsZTogdW5kZWZpbmVkLFxuICAgIG9uRHJhZzogdW5kZWZpbmVkLFxuICAgIG9uRHJhZ1N0YXJ0OiB1bmRlZmluZWQsXG4gICAgb25EcmFnRW5kOiB1bmRlZmluZWQsXG4gICAgY29sbGFwc2VkOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNwbGl0V3JhcHBlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85130\n")},62882:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\nvar picocolors = __webpack_require__(48633);\nvar jsTokens = __webpack_require__(65879);\nvar helperValidatorIdentifier = __webpack_require__(61000);\n\nfunction isColorSupported() {\n  return (typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors.isColorSupported\n  );\n}\nconst compose = (f, g) => v => f(g(v));\nfunction buildDefs(colors) {\n  return {\n    keyword: colors.cyan,\n    capitalized: colors.yellow,\n    jsxIdentifier: colors.yellow,\n    punctuator: colors.yellow,\n    number: colors.magenta,\n    string: colors.green,\n    regex: colors.magenta,\n    comment: colors.gray,\n    invalid: compose(compose(colors.white, colors.bgRed), colors.bold),\n    gutter: colors.gray,\n    marker: compose(colors.red, colors.bold),\n    message: compose(colors.red, colors.bold),\n    reset: colors.reset\n  };\n}\nconst defsOn = buildDefs(picocolors.createColors(true));\nconst defsOff = buildDefs(picocolors.createColors(false));\nfunction getDefs(enabled) {\n  return enabled ? defsOn : defsOff;\n}\n\nconst sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);\nconst NEWLINE$1 = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nconst BRACKET = /^[()[\\]{}]$/;\nlet tokenize;\n{\n  const JSX_TAG = /^[a-z][\\w-]*$/i;\n  const getTokenType = function (token, offset, text) {\n    if (token.type === "name") {\n      if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {\n        return "keyword";\n      }\n      if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.slice(offset - 2, offset) === "</")) {\n        return "jsxIdentifier";\n      }\n      if (token.value[0] !== token.value[0].toLowerCase()) {\n        return "capitalized";\n      }\n    }\n    if (token.type === "punctuator" && BRACKET.test(token.value)) {\n      return "bracket";\n    }\n    if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {\n      return "punctuator";\n    }\n    return token.type;\n  };\n  tokenize = function* (text) {\n    let match;\n    while (match = jsTokens.default.exec(text)) {\n      const token = jsTokens.matchToToken(match);\n      yield {\n        type: getTokenType(token, match.index, text),\n        value: token.value\n      };\n    }\n  };\n}\nfunction highlight(text) {\n  if (text === "") return "";\n  const defs = getDefs(true);\n  let highlighted = "";\n  for (const {\n    type,\n    value\n  } of tokenize(text)) {\n    if (type in defs) {\n      highlighted += value.split(NEWLINE$1).map(str => defs[type](str)).join("\\n");\n    } else {\n      highlighted += value;\n    }\n  }\n  return highlighted;\n}\n\nlet deprecationWarningShown = false;\nconst NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\nfunction getMarkerLines(loc, source, opts) {\n  const startLoc = Object.assign({\n    column: 0,\n    line: -1\n  }, loc.start);\n  const endLoc = Object.assign({}, startLoc, loc.end);\n  const {\n    linesAbove = 2,\n    linesBelow = 3\n  } = opts || {};\n  const startLine = startLoc.line;\n  const startColumn = startLoc.column;\n  const endLine = endLoc.line;\n  const endColumn = endLoc.column;\n  let start = Math.max(startLine - (linesAbove + 1), 0);\n  let end = Math.min(source.length, endLine + linesBelow);\n  if (startLine === -1) {\n    start = 0;\n  }\n  if (endLine === -1) {\n    end = source.length;\n  }\n  const lineDiff = endLine - startLine;\n  const markerLines = {};\n  if (lineDiff) {\n    for (let i = 0; i <= lineDiff; i++) {\n      const lineNumber = i + startLine;\n      if (!startColumn) {\n        markerLines[lineNumber] = true;\n      } else if (i === 0) {\n        const sourceLength = source[lineNumber - 1].length;\n        markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];\n      } else if (i === lineDiff) {\n        markerLines[lineNumber] = [0, endColumn];\n      } else {\n        const sourceLength = source[lineNumber - i].length;\n        markerLines[lineNumber] = [0, sourceLength];\n      }\n    }\n  } else {\n    if (startColumn === endColumn) {\n      if (startColumn) {\n        markerLines[startLine] = [startColumn, 0];\n      } else {\n        markerLines[startLine] = true;\n      }\n    } else {\n      markerLines[startLine] = [startColumn, endColumn - startColumn];\n    }\n  }\n  return {\n    start,\n    end,\n    markerLines\n  };\n}\nfunction codeFrameColumns(rawLines, loc, opts = {}) {\n  const shouldHighlight = opts.forceColor || isColorSupported() && opts.highlightCode;\n  const defs = getDefs(shouldHighlight);\n  const lines = rawLines.split(NEWLINE);\n  const {\n    start,\n    end,\n    markerLines\n  } = getMarkerLines(loc, lines, opts);\n  const hasColumns = loc.start && typeof loc.start.column === "number";\n  const numberMaxWidth = String(end).length;\n  const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;\n  let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index) => {\n    const number = start + 1 + index;\n    const paddedNumber = ` ${number}`.slice(-numberMaxWidth);\n    const gutter = ` ${paddedNumber} |`;\n    const hasMarker = markerLines[number];\n    const lastMarkerLine = !markerLines[number + 1];\n    if (hasMarker) {\n      let markerLine = "";\n      if (Array.isArray(hasMarker)) {\n        const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\\t]/g, " ");\n        const numberOfMarkers = hasMarker[1] || 1;\n        markerLine = ["\\n ", defs.gutter(gutter.replace(/\\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");\n        if (lastMarkerLine && opts.message) {\n          markerLine += " " + defs.message(opts.message);\n        }\n      }\n      return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");\n    } else {\n      return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;\n    }\n  }).join("\\n");\n  if (opts.message && !hasColumns) {\n    frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}\\n${frame}`;\n  }\n  if (shouldHighlight) {\n    return defs.reset(frame);\n  } else {\n    return frame;\n  }\n}\nfunction index (rawLines, lineNumber, colNumber, opts = {}) {\n  if (!deprecationWarningShown) {\n    deprecationWarningShown = true;\n    const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";\n    if (process.emitWarning) {\n      process.emitWarning(message, "DeprecationWarning");\n    } else {\n      const deprecationError = new Error(message);\n      deprecationError.name = "DeprecationWarning";\n      console.warn(new Error(message));\n    }\n  }\n  colNumber = Math.max(colNumber, 0);\n  const location = {\n    start: {\n      column: colNumber,\n      line: lineNumber\n    }\n  };\n  return codeFrameColumns(rawLines, location, opts);\n}\n\nexports.codeFrameColumns = codeFrameColumns;\nexports["default"] = index;\nexports.highlight = highlight;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI4ODIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDOztBQUU3RCxpQkFBaUIsbUJBQU8sQ0FBQyxLQUFZO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxLQUFXO0FBQ2xDLGdDQUFnQyxtQkFBTyxDQUFDLEtBQW9DOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxLQUFLO0FBQ2hGLE1BQU07QUFDTixpQkFBaUIsb0JBQW9CLEVBQUUsc0JBQXNCLEtBQUssT0FBTztBQUN6RTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsK0JBQStCLEVBQUUsYUFBYSxJQUFJLE1BQU07QUFDdkU7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCLGtCQUFlO0FBQ2YsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvY29kZS1mcmFtZS9saWIvaW5kZXguanM/ZWQ2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBwaWNvY29sb3JzID0gcmVxdWlyZSgncGljb2NvbG9ycycpO1xudmFyIGpzVG9rZW5zID0gcmVxdWlyZSgnanMtdG9rZW5zJyk7XG52YXIgaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllciA9IHJlcXVpcmUoJ0BiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXInKTtcblxuZnVuY3Rpb24gaXNDb2xvclN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiAocHJvY2Vzcy5lbnYuRk9SQ0VfQ09MT1IgPT09IFwiMFwiIHx8IHByb2Nlc3MuZW52LkZPUkNFX0NPTE9SID09PSBcImZhbHNlXCIpID8gZmFsc2UgOiBwaWNvY29sb3JzLmlzQ29sb3JTdXBwb3J0ZWRcbiAgKTtcbn1cbmNvbnN0IGNvbXBvc2UgPSAoZiwgZykgPT4gdiA9PiBmKGcodikpO1xuZnVuY3Rpb24gYnVpbGREZWZzKGNvbG9ycykge1xuICByZXR1cm4ge1xuICAgIGtleXdvcmQ6IGNvbG9ycy5jeWFuLFxuICAgIGNhcGl0YWxpemVkOiBjb2xvcnMueWVsbG93LFxuICAgIGpzeElkZW50aWZpZXI6IGNvbG9ycy55ZWxsb3csXG4gICAgcHVuY3R1YXRvcjogY29sb3JzLnllbGxvdyxcbiAgICBudW1iZXI6IGNvbG9ycy5tYWdlbnRhLFxuICAgIHN0cmluZzogY29sb3JzLmdyZWVuLFxuICAgIHJlZ2V4OiBjb2xvcnMubWFnZW50YSxcbiAgICBjb21tZW50OiBjb2xvcnMuZ3JheSxcbiAgICBpbnZhbGlkOiBjb21wb3NlKGNvbXBvc2UoY29sb3JzLndoaXRlLCBjb2xvcnMuYmdSZWQpLCBjb2xvcnMuYm9sZCksXG4gICAgZ3V0dGVyOiBjb2xvcnMuZ3JheSxcbiAgICBtYXJrZXI6IGNvbXBvc2UoY29sb3JzLnJlZCwgY29sb3JzLmJvbGQpLFxuICAgIG1lc3NhZ2U6IGNvbXBvc2UoY29sb3JzLnJlZCwgY29sb3JzLmJvbGQpLFxuICAgIHJlc2V0OiBjb2xvcnMucmVzZXRcbiAgfTtcbn1cbmNvbnN0IGRlZnNPbiA9IGJ1aWxkRGVmcyhwaWNvY29sb3JzLmNyZWF0ZUNvbG9ycyh0cnVlKSk7XG5jb25zdCBkZWZzT2ZmID0gYnVpbGREZWZzKHBpY29jb2xvcnMuY3JlYXRlQ29sb3JzKGZhbHNlKSk7XG5mdW5jdGlvbiBnZXREZWZzKGVuYWJsZWQpIHtcbiAgcmV0dXJuIGVuYWJsZWQgPyBkZWZzT24gOiBkZWZzT2ZmO1xufVxuXG5jb25zdCBzb21ldGltZXNLZXl3b3JkcyA9IG5ldyBTZXQoW1wiYXNcIiwgXCJhc3luY1wiLCBcImZyb21cIiwgXCJnZXRcIiwgXCJvZlwiLCBcInNldFwiXSk7XG5jb25zdCBORVdMSU5FJDEgPSAvXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgQlJBQ0tFVCA9IC9eWygpW1xcXXt9XSQvO1xubGV0IHRva2VuaXplO1xue1xuICBjb25zdCBKU1hfVEFHID0gL15bYS16XVtcXHctXSokL2k7XG4gIGNvbnN0IGdldFRva2VuVHlwZSA9IGZ1bmN0aW9uICh0b2tlbiwgb2Zmc2V0LCB0ZXh0KSB7XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwibmFtZVwiKSB7XG4gICAgICBpZiAoaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0tleXdvcmQodG9rZW4udmFsdWUpIHx8IGhlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNTdHJpY3RSZXNlcnZlZFdvcmQodG9rZW4udmFsdWUsIHRydWUpIHx8IHNvbWV0aW1lc0tleXdvcmRzLmhhcyh0b2tlbi52YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICAgICAgfVxuICAgICAgaWYgKEpTWF9UQUcudGVzdCh0b2tlbi52YWx1ZSkgJiYgKHRleHRbb2Zmc2V0IC0gMV0gPT09IFwiPFwiIHx8IHRleHQuc2xpY2Uob2Zmc2V0IC0gMiwgb2Zmc2V0KSA9PT0gXCI8L1wiKSkge1xuICAgICAgICByZXR1cm4gXCJqc3hJZGVudGlmaWVyXCI7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW4udmFsdWVbMF0gIT09IHRva2VuLnZhbHVlWzBdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIFwiY2FwaXRhbGl6ZWRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwicHVuY3R1YXRvclwiICYmIEJSQUNLRVQudGVzdCh0b2tlbi52YWx1ZSkpIHtcbiAgICAgIHJldHVybiBcImJyYWNrZXRcIjtcbiAgICB9XG4gICAgaWYgKHRva2VuLnR5cGUgPT09IFwiaW52YWxpZFwiICYmICh0b2tlbi52YWx1ZSA9PT0gXCJAXCIgfHwgdG9rZW4udmFsdWUgPT09IFwiI1wiKSkge1xuICAgICAgcmV0dXJuIFwicHVuY3R1YXRvclwiO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW4udHlwZTtcbiAgfTtcbiAgdG9rZW5pemUgPSBmdW5jdGlvbiogKHRleHQpIHtcbiAgICBsZXQgbWF0Y2g7XG4gICAgd2hpbGUgKG1hdGNoID0ganNUb2tlbnMuZGVmYXVsdC5leGVjKHRleHQpKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGpzVG9rZW5zLm1hdGNoVG9Ub2tlbihtYXRjaCk7XG4gICAgICB5aWVsZCB7XG4gICAgICAgIHR5cGU6IGdldFRva2VuVHlwZSh0b2tlbiwgbWF0Y2guaW5kZXgsIHRleHQpLFxuICAgICAgICB2YWx1ZTogdG9rZW4udmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaGlnaGxpZ2h0KHRleHQpIHtcbiAgaWYgKHRleHQgPT09IFwiXCIpIHJldHVybiBcIlwiO1xuICBjb25zdCBkZWZzID0gZ2V0RGVmcyh0cnVlKTtcbiAgbGV0IGhpZ2hsaWdodGVkID0gXCJcIjtcbiAgZm9yIChjb25zdCB7XG4gICAgdHlwZSxcbiAgICB2YWx1ZVxuICB9IG9mIHRva2VuaXplKHRleHQpKSB7XG4gICAgaWYgKHR5cGUgaW4gZGVmcykge1xuICAgICAgaGlnaGxpZ2h0ZWQgKz0gdmFsdWUuc3BsaXQoTkVXTElORSQxKS5tYXAoc3RyID0+IGRlZnNbdHlwZV0oc3RyKSkuam9pbihcIlxcblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGlnaGxpZ2h0ZWQgKz0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBoaWdobGlnaHRlZDtcbn1cblxubGV0IGRlcHJlY2F0aW9uV2FybmluZ1Nob3duID0gZmFsc2U7XG5jb25zdCBORVdMSU5FID0gL1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldLztcbmZ1bmN0aW9uIGdldE1hcmtlckxpbmVzKGxvYywgc291cmNlLCBvcHRzKSB7XG4gIGNvbnN0IHN0YXJ0TG9jID0gT2JqZWN0LmFzc2lnbih7XG4gICAgY29sdW1uOiAwLFxuICAgIGxpbmU6IC0xXG4gIH0sIGxvYy5zdGFydCk7XG4gIGNvbnN0IGVuZExvYyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXJ0TG9jLCBsb2MuZW5kKTtcbiAgY29uc3Qge1xuICAgIGxpbmVzQWJvdmUgPSAyLFxuICAgIGxpbmVzQmVsb3cgPSAzXG4gIH0gPSBvcHRzIHx8IHt9O1xuICBjb25zdCBzdGFydExpbmUgPSBzdGFydExvYy5saW5lO1xuICBjb25zdCBzdGFydENvbHVtbiA9IHN0YXJ0TG9jLmNvbHVtbjtcbiAgY29uc3QgZW5kTGluZSA9IGVuZExvYy5saW5lO1xuICBjb25zdCBlbmRDb2x1bW4gPSBlbmRMb2MuY29sdW1uO1xuICBsZXQgc3RhcnQgPSBNYXRoLm1heChzdGFydExpbmUgLSAobGluZXNBYm92ZSArIDEpLCAwKTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNvdXJjZS5sZW5ndGgsIGVuZExpbmUgKyBsaW5lc0JlbG93KTtcbiAgaWYgKHN0YXJ0TGluZSA9PT0gLTEpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZExpbmUgPT09IC0xKSB7XG4gICAgZW5kID0gc291cmNlLmxlbmd0aDtcbiAgfVxuICBjb25zdCBsaW5lRGlmZiA9IGVuZExpbmUgLSBzdGFydExpbmU7XG4gIGNvbnN0IG1hcmtlckxpbmVzID0ge307XG4gIGlmIChsaW5lRGlmZikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxpbmVEaWZmOyBpKyspIHtcbiAgICAgIGNvbnN0IGxpbmVOdW1iZXIgPSBpICsgc3RhcnRMaW5lO1xuICAgICAgaWYgKCFzdGFydENvbHVtbikge1xuICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSAxXS5sZW5ndGg7XG4gICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gW3N0YXJ0Q29sdW1uLCBzb3VyY2VMZW5ndGggLSBzdGFydENvbHVtbiArIDFdO1xuICAgICAgfSBlbHNlIGlmIChpID09PSBsaW5lRGlmZikge1xuICAgICAgICBtYXJrZXJMaW5lc1tsaW5lTnVtYmVyXSA9IFswLCBlbmRDb2x1bW5dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc291cmNlTGVuZ3RoID0gc291cmNlW2xpbmVOdW1iZXIgLSBpXS5sZW5ndGg7XG4gICAgICAgIG1hcmtlckxpbmVzW2xpbmVOdW1iZXJdID0gWzAsIHNvdXJjZUxlbmd0aF07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdGFydENvbHVtbiA9PT0gZW5kQ29sdW1uKSB7XG4gICAgICBpZiAoc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IFtzdGFydENvbHVtbiwgMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXJrZXJMaW5lc1tzdGFydExpbmVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyTGluZXNbc3RhcnRMaW5lXSA9IFtzdGFydENvbHVtbiwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW5dO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICBtYXJrZXJMaW5lc1xuICB9O1xufVxuZnVuY3Rpb24gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jLCBvcHRzID0ge30pIHtcbiAgY29uc3Qgc2hvdWxkSGlnaGxpZ2h0ID0gb3B0cy5mb3JjZUNvbG9yIHx8IGlzQ29sb3JTdXBwb3J0ZWQoKSAmJiBvcHRzLmhpZ2hsaWdodENvZGU7XG4gIGNvbnN0IGRlZnMgPSBnZXREZWZzKHNob3VsZEhpZ2hsaWdodCk7XG4gIGNvbnN0IGxpbmVzID0gcmF3TGluZXMuc3BsaXQoTkVXTElORSk7XG4gIGNvbnN0IHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgbWFya2VyTGluZXNcbiAgfSA9IGdldE1hcmtlckxpbmVzKGxvYywgbGluZXMsIG9wdHMpO1xuICBjb25zdCBoYXNDb2x1bW5zID0gbG9jLnN0YXJ0ICYmIHR5cGVvZiBsb2Muc3RhcnQuY29sdW1uID09PSBcIm51bWJlclwiO1xuICBjb25zdCBudW1iZXJNYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgY29uc3QgaGlnaGxpZ2h0ZWRMaW5lcyA9IHNob3VsZEhpZ2hsaWdodCA/IGhpZ2hsaWdodChyYXdMaW5lcykgOiByYXdMaW5lcztcbiAgbGV0IGZyYW1lID0gaGlnaGxpZ2h0ZWRMaW5lcy5zcGxpdChORVdMSU5FLCBlbmQpLnNsaWNlKHN0YXJ0LCBlbmQpLm1hcCgobGluZSwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBudW1iZXIgPSBzdGFydCArIDEgKyBpbmRleDtcbiAgICBjb25zdCBwYWRkZWROdW1iZXIgPSBgICR7bnVtYmVyfWAuc2xpY2UoLW51bWJlck1heFdpZHRoKTtcbiAgICBjb25zdCBndXR0ZXIgPSBgICR7cGFkZGVkTnVtYmVyfSB8YDtcbiAgICBjb25zdCBoYXNNYXJrZXIgPSBtYXJrZXJMaW5lc1tudW1iZXJdO1xuICAgIGNvbnN0IGxhc3RNYXJrZXJMaW5lID0gIW1hcmtlckxpbmVzW251bWJlciArIDFdO1xuICAgIGlmIChoYXNNYXJrZXIpIHtcbiAgICAgIGxldCBtYXJrZXJMaW5lID0gXCJcIjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhc01hcmtlcikpIHtcbiAgICAgICAgY29uc3QgbWFya2VyU3BhY2luZyA9IGxpbmUuc2xpY2UoMCwgTWF0aC5tYXgoaGFzTWFya2VyWzBdIC0gMSwgMCkpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgIGNvbnN0IG51bWJlck9mTWFya2VycyA9IGhhc01hcmtlclsxXSB8fCAxO1xuICAgICAgICBtYXJrZXJMaW5lID0gW1wiXFxuIFwiLCBkZWZzLmd1dHRlcihndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSksIFwiIFwiLCBtYXJrZXJTcGFjaW5nLCBkZWZzLm1hcmtlcihcIl5cIikucmVwZWF0KG51bWJlck9mTWFya2VycyldLmpvaW4oXCJcIik7XG4gICAgICAgIGlmIChsYXN0TWFya2VyTGluZSAmJiBvcHRzLm1lc3NhZ2UpIHtcbiAgICAgICAgICBtYXJrZXJMaW5lICs9IFwiIFwiICsgZGVmcy5tZXNzYWdlKG9wdHMubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbZGVmcy5tYXJrZXIoXCI+XCIpLCBkZWZzLmd1dHRlcihndXR0ZXIpLCBsaW5lLmxlbmd0aCA+IDAgPyBgICR7bGluZX1gIDogXCJcIiwgbWFya2VyTGluZV0uam9pbihcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGAgJHtkZWZzLmd1dHRlcihndXR0ZXIpfSR7bGluZS5sZW5ndGggPiAwID8gYCAke2xpbmV9YCA6IFwiXCJ9YDtcbiAgICB9XG4gIH0pLmpvaW4oXCJcXG5cIik7XG4gIGlmIChvcHRzLm1lc3NhZ2UgJiYgIWhhc0NvbHVtbnMpIHtcbiAgICBmcmFtZSA9IGAke1wiIFwiLnJlcGVhdChudW1iZXJNYXhXaWR0aCArIDEpfSR7b3B0cy5tZXNzYWdlfVxcbiR7ZnJhbWV9YDtcbiAgfVxuICBpZiAoc2hvdWxkSGlnaGxpZ2h0KSB7XG4gICAgcmV0dXJuIGRlZnMucmVzZXQoZnJhbWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmcmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXggKHJhd0xpbmVzLCBsaW5lTnVtYmVyLCBjb2xOdW1iZXIsIG9wdHMgPSB7fSkge1xuICBpZiAoIWRlcHJlY2F0aW9uV2FybmluZ1Nob3duKSB7XG4gICAgZGVwcmVjYXRpb25XYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBcIlBhc3NpbmcgbGluZU51bWJlciBhbmQgY29sTnVtYmVyIGlzIGRlcHJlY2F0ZWQgdG8gQGJhYmVsL2NvZGUtZnJhbWUuIFBsZWFzZSB1c2UgYGNvZGVGcmFtZUNvbHVtbnNgLlwiO1xuICAgIGlmIChwcm9jZXNzLmVtaXRXYXJuaW5nKSB7XG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG1lc3NhZ2UsIFwiRGVwcmVjYXRpb25XYXJuaW5nXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZXByZWNhdGlvbkVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgZGVwcmVjYXRpb25FcnJvci5uYW1lID0gXCJEZXByZWNhdGlvbldhcm5pbmdcIjtcbiAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgIH1cbiAgfVxuICBjb2xOdW1iZXIgPSBNYXRoLm1heChjb2xOdW1iZXIsIDApO1xuICBjb25zdCBsb2NhdGlvbiA9IHtcbiAgICBzdGFydDoge1xuICAgICAgY29sdW1uOiBjb2xOdW1iZXIsXG4gICAgICBsaW5lOiBsaW5lTnVtYmVyXG4gICAgfVxuICB9O1xuICByZXR1cm4gY29kZUZyYW1lQ29sdW1ucyhyYXdMaW5lcywgbG9jYXRpb24sIG9wdHMpO1xufVxuXG5leHBvcnRzLmNvZGVGcmFtZUNvbHVtbnMgPSBjb2RlRnJhbWVDb2x1bW5zO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5kZXg7XG5leHBvcnRzLmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62882\n')},74960:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nclass Buffer {\n  constructor(map, indentChar) {\n    this._map = null;\n    this._buf = "";\n    this._str = "";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._canMarkIdName = true;\n    this._indentChar = "";\n    this._fastIndentations = [];\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: undefined,\n      identifierNamePos: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined\n    };\n    this._map = map;\n    this._indentChar = indentChar;\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n    this._allocQueue();\n  }\n  _allocQueue() {\n    const queue = this._queue;\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: ""\n      });\n    }\n  }\n  _pushQueue(char, repeat, line, column, filename) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error("Cannot pop from empty queue");\n    }\n    return this._queue[--this._queueCursor];\n  }\n  get() {\n    this._flush();\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n      get __mergedMap() {\n        return this.map;\n      },\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, "map", {\n          value,\n          writable: true\n        });\n      },\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, "rawMappings", {\n          value,\n          writable: true\n        });\n      }\n    };\n    return result;\n  }\n  append(str, maybeNewline) {\n    this._flush();\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n  appendChar(char) {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n        this._queueCursor--;\n      }\n    }\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);\n  }\n  queueIndentation(repeat) {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n    }\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    const position = this._position;\n    this._last = str.charCodeAt(len - 1);\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n    const {\n      column,\n      identifierName,\n      identifierNamePos,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    let i = str.indexOf("\\n");\n    let last = 0;\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, null, null, filename);\n      }\n      i = str.indexOf("\\n", last);\n    }\n    position.column += len - last;\n  }\n  _mark(line, column, identifierName, identifierNamePos, filename) {\n    var _this$_map;\n    (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);\n  }\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n  getNewlineCount() {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === 10 ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== 10) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === 10 ? count + 1 : count;\n  }\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n  exactSource(loc, cb) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n    this.source("start", loc);\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source("end", loc);\n  }\n  source(prop, loc) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, 0);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!this._map) return;\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n  _normalizePosition(prop, loc, columnOffset) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n    if (pos) {\n      target.line = pos.line;\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n  getCurrentColumn() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === 10) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n    return this._position.line + count;\n  }\n}\nexports["default"] = Buffer;\n\n//# sourceMappingURL=buffer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ5NjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7QUFFZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvYnVmZmVyLmpzP2Y5ZjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5jbGFzcyBCdWZmZXIge1xuICBjb25zdHJ1Y3RvcihtYXAsIGluZGVudENoYXIpIHtcbiAgICB0aGlzLl9tYXAgPSBudWxsO1xuICAgIHRoaXMuX2J1ZiA9IFwiXCI7XG4gICAgdGhpcy5fc3RyID0gXCJcIjtcbiAgICB0aGlzLl9hcHBlbmRDb3VudCA9IDA7XG4gICAgdGhpcy5fbGFzdCA9IDA7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZUN1cnNvciA9IDA7XG4gICAgdGhpcy5fY2FuTWFya0lkTmFtZSA9IHRydWU7XG4gICAgdGhpcy5faW5kZW50Q2hhciA9IFwiXCI7XG4gICAgdGhpcy5fZmFzdEluZGVudGF0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3Bvc2l0aW9uID0ge1xuICAgICAgbGluZTogMSxcbiAgICAgIGNvbHVtbjogMFxuICAgIH07XG4gICAgdGhpcy5fc291cmNlUG9zaXRpb24gPSB7XG4gICAgICBpZGVudGlmaWVyTmFtZTogdW5kZWZpbmVkLFxuICAgICAgaWRlbnRpZmllck5hbWVQb3M6IHVuZGVmaW5lZCxcbiAgICAgIGxpbmU6IHVuZGVmaW5lZCxcbiAgICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgICAgZmlsZW5hbWU6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5fbWFwID0gbWFwO1xuICAgIHRoaXMuX2luZGVudENoYXIgPSBpbmRlbnRDaGFyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgdGhpcy5fZmFzdEluZGVudGF0aW9ucy5wdXNoKGluZGVudENoYXIucmVwZWF0KGkpKTtcbiAgICB9XG4gICAgdGhpcy5fYWxsb2NRdWV1ZSgpO1xuICB9XG4gIF9hbGxvY1F1ZXVlKCkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgY2hhcjogMCxcbiAgICAgICAgcmVwZWF0OiAxLFxuICAgICAgICBsaW5lOiB1bmRlZmluZWQsXG4gICAgICAgIGNvbHVtbjogdW5kZWZpbmVkLFxuICAgICAgICBpZGVudGlmaWVyTmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBpZGVudGlmaWVyTmFtZVBvczogdW5kZWZpbmVkLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIF9wdXNoUXVldWUoY2hhciwgcmVwZWF0LCBsaW5lLCBjb2x1bW4sIGZpbGVuYW1lKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgaWYgKGN1cnNvciA9PT0gdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9hbGxvY1F1ZXVlKCk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9xdWV1ZVtjdXJzb3JdO1xuICAgIGl0ZW0uY2hhciA9IGNoYXI7XG4gICAgaXRlbS5yZXBlYXQgPSByZXBlYXQ7XG4gICAgaXRlbS5saW5lID0gbGluZTtcbiAgICBpdGVtLmNvbHVtbiA9IGNvbHVtbjtcbiAgICBpdGVtLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgdGhpcy5fcXVldWVDdXJzb3IrKztcbiAgfVxuICBfcG9wUXVldWUoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlQ3Vyc29yID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcG9wIGZyb20gZW1wdHkgcXVldWVcIik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9xdWV1ZVstLXRoaXMuX3F1ZXVlQ3Vyc29yXTtcbiAgfVxuICBnZXQoKSB7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY29kZTogKHRoaXMuX2J1ZiArIHRoaXMuX3N0cikudHJpbVJpZ2h0KCksXG4gICAgICBkZWNvZGVkTWFwOiBtYXAgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcC5nZXREZWNvZGVkKCksXG4gICAgICBnZXQgX19tZXJnZWRNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcDtcbiAgICAgIH0sXG4gICAgICBnZXQgbWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHRNYXAgPSBtYXAgPyBtYXAuZ2V0KCkgOiBudWxsO1xuICAgICAgICByZXN1bHQubWFwID0gcmVzdWx0TWFwO1xuICAgICAgICByZXR1cm4gcmVzdWx0TWFwO1xuICAgICAgfSxcbiAgICAgIHNldCBtYXAodmFsdWUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgXCJtYXBcIiwge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldCByYXdNYXBwaW5ncygpIHtcbiAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBtYXAgPT0gbnVsbCA/IHZvaWQgMCA6IG1hcC5nZXRSYXdNYXBwaW5ncygpO1xuICAgICAgICByZXN1bHQucmF3TWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgICAgfSxcbiAgICAgIHNldCByYXdNYXBwaW5ncyh2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBcInJhd01hcHBpbmdzXCIsIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgYXBwZW5kKHN0ciwgbWF5YmVOZXdsaW5lKSB7XG4gICAgdGhpcy5fZmx1c2goKTtcbiAgICB0aGlzLl9hcHBlbmQoc3RyLCB0aGlzLl9zb3VyY2VQb3NpdGlvbiwgbWF5YmVOZXdsaW5lKTtcbiAgfVxuICBhcHBlbmRDaGFyKGNoYXIpIHtcbiAgICB0aGlzLl9mbHVzaCgpO1xuICAgIHRoaXMuX2FwcGVuZENoYXIoY2hhciwgMSwgdGhpcy5fc291cmNlUG9zaXRpb24pO1xuICB9XG4gIHF1ZXVlKGNoYXIpIHtcbiAgICBpZiAoY2hhciA9PT0gMTApIHtcbiAgICAgIHdoaWxlICh0aGlzLl9xdWV1ZUN1cnNvciAhPT0gMCkge1xuICAgICAgICBjb25zdCBjaGFyID0gdGhpcy5fcXVldWVbdGhpcy5fcXVldWVDdXJzb3IgLSAxXS5jaGFyO1xuICAgICAgICBpZiAoY2hhciAhPT0gMzIgJiYgY2hhciAhPT0gOSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3F1ZXVlQ3Vyc29yLS07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gdGhpcy5fc291cmNlUG9zaXRpb247XG4gICAgdGhpcy5fcHVzaFF1ZXVlKGNoYXIsIDEsIHNvdXJjZVBvc2l0aW9uLmxpbmUsIHNvdXJjZVBvc2l0aW9uLmNvbHVtbiwgc291cmNlUG9zaXRpb24uZmlsZW5hbWUpO1xuICB9XG4gIHF1ZXVlSW5kZW50YXRpb24ocmVwZWF0KSB7XG4gICAgaWYgKHJlcGVhdCA9PT0gMCkgcmV0dXJuO1xuICAgIHRoaXMuX3B1c2hRdWV1ZSgtMSwgcmVwZWF0LCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgfVxuICBfZmx1c2goKSB7XG4gICAgY29uc3QgcXVldWVDdXJzb3IgPSB0aGlzLl9xdWV1ZUN1cnNvcjtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWVDdXJzb3I7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgdGhpcy5fYXBwZW5kQ2hhcihpdGVtLmNoYXIsIGl0ZW0ucmVwZWF0LCBpdGVtKTtcbiAgICB9XG4gICAgdGhpcy5fcXVldWVDdXJzb3IgPSAwO1xuICB9XG4gIF9hcHBlbmRDaGFyKGNoYXIsIHJlcGVhdCwgc291cmNlUG9zKSB7XG4gICAgdGhpcy5fbGFzdCA9IGNoYXI7XG4gICAgaWYgKGNoYXIgPT09IC0xKSB7XG4gICAgICBjb25zdCBmYXN0SW5kZW50YXRpb24gPSB0aGlzLl9mYXN0SW5kZW50YXRpb25zW3JlcGVhdF07XG4gICAgICBpZiAoZmFzdEluZGVudGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3RyICs9IGZhc3RJbmRlbnRhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0ciArPSByZXBlYXQgPiAxID8gdGhpcy5faW5kZW50Q2hhci5yZXBlYXQocmVwZWF0KSA6IHRoaXMuX2luZGVudENoYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0ciArPSByZXBlYXQgPiAxID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKS5yZXBlYXQocmVwZWF0KSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcik7XG4gICAgfVxuICAgIGlmIChjaGFyICE9PSAxMCkge1xuICAgICAgdGhpcy5fbWFyayhzb3VyY2VQb3MubGluZSwgc291cmNlUG9zLmNvbHVtbiwgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lLCBzb3VyY2VQb3MuaWRlbnRpZmllck5hbWVQb3MsIHNvdXJjZVBvcy5maWxlbmFtZSk7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gKz0gcmVwZWF0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5saW5lKys7XG4gICAgICB0aGlzLl9wb3NpdGlvbi5jb2x1bW4gPSAwO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FuTWFya0lkTmFtZSkge1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lUG9zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICBfYXBwZW5kKHN0ciwgc291cmNlUG9zLCBtYXliZU5ld2xpbmUpIHtcbiAgICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgdGhpcy5fbGFzdCA9IHN0ci5jaGFyQ29kZUF0KGxlbiAtIDEpO1xuICAgIGlmICgrK3RoaXMuX2FwcGVuZENvdW50ID4gNDA5Nikge1xuICAgICAgK3RoaXMuX3N0cjtcbiAgICAgIHRoaXMuX2J1ZiArPSB0aGlzLl9zdHI7XG4gICAgICB0aGlzLl9zdHIgPSBzdHI7XG4gICAgICB0aGlzLl9hcHBlbmRDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3N0ciArPSBzdHI7XG4gICAgfVxuICAgIGlmICghbWF5YmVOZXdsaW5lICYmICF0aGlzLl9tYXApIHtcbiAgICAgIHBvc2l0aW9uLmNvbHVtbiArPSBsZW47XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNvbHVtbixcbiAgICAgIGlkZW50aWZpZXJOYW1lLFxuICAgICAgaWRlbnRpZmllck5hbWVQb3MsXG4gICAgICBmaWxlbmFtZVxuICAgIH0gPSBzb3VyY2VQb3M7XG4gICAgbGV0IGxpbmUgPSBzb3VyY2VQb3MubGluZTtcbiAgICBpZiAoKGlkZW50aWZpZXJOYW1lICE9IG51bGwgfHwgaWRlbnRpZmllck5hbWVQb3MgIT0gbnVsbCkgJiYgdGhpcy5fY2FuTWFya0lkTmFtZSkge1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lID0gdW5kZWZpbmVkO1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lUG9zID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgaSA9IHN0ci5pbmRleE9mKFwiXFxuXCIpO1xuICAgIGxldCBsYXN0ID0gMDtcbiAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgdGhpcy5fbWFyayhsaW5lLCBjb2x1bW4sIGlkZW50aWZpZXJOYW1lLCBpZGVudGlmaWVyTmFtZVBvcywgZmlsZW5hbWUpO1xuICAgIH1cbiAgICB3aGlsZSAoaSAhPT0gLTEpIHtcbiAgICAgIHBvc2l0aW9uLmxpbmUrKztcbiAgICAgIHBvc2l0aW9uLmNvbHVtbiA9IDA7XG4gICAgICBsYXN0ID0gaSArIDE7XG4gICAgICBpZiAobGFzdCA8IGxlbiAmJiBsaW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fbWFyaygrK2xpbmUsIDAsIG51bGwsIG51bGwsIGZpbGVuYW1lKTtcbiAgICAgIH1cbiAgICAgIGkgPSBzdHIuaW5kZXhPZihcIlxcblwiLCBsYXN0KTtcbiAgICB9XG4gICAgcG9zaXRpb24uY29sdW1uICs9IGxlbiAtIGxhc3Q7XG4gIH1cbiAgX21hcmsobGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck5hbWVQb3MsIGZpbGVuYW1lKSB7XG4gICAgdmFyIF90aGlzJF9tYXA7XG4gICAgKF90aGlzJF9tYXAgPSB0aGlzLl9tYXApID09IG51bGwgfHwgX3RoaXMkX21hcC5tYXJrKHRoaXMuX3Bvc2l0aW9uLCBsaW5lLCBjb2x1bW4sIGlkZW50aWZpZXJOYW1lLCBpZGVudGlmaWVyTmFtZVBvcywgZmlsZW5hbWUpO1xuICB9XG4gIHJlbW92ZVRyYWlsaW5nTmV3bGluZSgpIHtcbiAgICBjb25zdCBxdWV1ZUN1cnNvciA9IHRoaXMuX3F1ZXVlQ3Vyc29yO1xuICAgIGlmIChxdWV1ZUN1cnNvciAhPT0gMCAmJiB0aGlzLl9xdWV1ZVtxdWV1ZUN1cnNvciAtIDFdLmNoYXIgPT09IDEwKSB7XG4gICAgICB0aGlzLl9xdWV1ZUN1cnNvci0tO1xuICAgIH1cbiAgfVxuICByZW1vdmVMYXN0U2VtaWNvbG9uKCkge1xuICAgIGNvbnN0IHF1ZXVlQ3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgaWYgKHF1ZXVlQ3Vyc29yICE9PSAwICYmIHRoaXMuX3F1ZXVlW3F1ZXVlQ3Vyc29yIC0gMV0uY2hhciA9PT0gNTkpIHtcbiAgICAgIHRoaXMuX3F1ZXVlQ3Vyc29yLS07XG4gICAgfVxuICB9XG4gIGdldExhc3RDaGFyKCkge1xuICAgIGNvbnN0IHF1ZXVlQ3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgcmV0dXJuIHF1ZXVlQ3Vyc29yICE9PSAwID8gdGhpcy5fcXVldWVbcXVldWVDdXJzb3IgLSAxXS5jaGFyIDogdGhpcy5fbGFzdDtcbiAgfVxuICBnZXROZXdsaW5lQ291bnQoKSB7XG4gICAgY29uc3QgcXVldWVDdXJzb3IgPSB0aGlzLl9xdWV1ZUN1cnNvcjtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGlmIChxdWV1ZUN1cnNvciA9PT0gMCkgcmV0dXJuIHRoaXMuX2xhc3QgPT09IDEwID8gMSA6IDA7XG4gICAgZm9yIChsZXQgaSA9IHF1ZXVlQ3Vyc29yIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmICh0aGlzLl9xdWV1ZVtpXS5jaGFyICE9PSAxMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiBjb3VudCA9PT0gcXVldWVDdXJzb3IgJiYgdGhpcy5fbGFzdCA9PT0gMTAgPyBjb3VudCArIDEgOiBjb3VudDtcbiAgfVxuICBlbmRzV2l0aENoYXJBbmROZXdsaW5lKCkge1xuICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5fcXVldWU7XG4gICAgY29uc3QgcXVldWVDdXJzb3IgPSB0aGlzLl9xdWV1ZUN1cnNvcjtcbiAgICBpZiAocXVldWVDdXJzb3IgIT09IDApIHtcbiAgICAgIGNvbnN0IGxhc3RDcCA9IHF1ZXVlW3F1ZXVlQ3Vyc29yIC0gMV0uY2hhcjtcbiAgICAgIGlmIChsYXN0Q3AgIT09IDEwKSByZXR1cm47XG4gICAgICBpZiAocXVldWVDdXJzb3IgPiAxKSB7XG4gICAgICAgIHJldHVybiBxdWV1ZVtxdWV1ZUN1cnNvciAtIDJdLmNoYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFzQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVldWVDdXJzb3IgIT09IDAgfHwgISF0aGlzLl9sYXN0O1xuICB9XG4gIGV4YWN0U291cmNlKGxvYywgY2IpIHtcbiAgICBpZiAoIXRoaXMuX21hcCkge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UoXCJzdGFydFwiLCBsb2MpO1xuICAgIGNvbnN0IGlkZW50aWZpZXJOYW1lID0gbG9jLmlkZW50aWZpZXJOYW1lO1xuICAgIGNvbnN0IHNvdXJjZVBvcyA9IHRoaXMuX3NvdXJjZVBvc2l0aW9uO1xuICAgIGlmIChpZGVudGlmaWVyTmFtZSkge1xuICAgICAgdGhpcy5fY2FuTWFya0lkTmFtZSA9IGZhbHNlO1xuICAgICAgc291cmNlUG9zLmlkZW50aWZpZXJOYW1lID0gaWRlbnRpZmllck5hbWU7XG4gICAgfVxuICAgIGNiKCk7XG4gICAgaWYgKGlkZW50aWZpZXJOYW1lKSB7XG4gICAgICB0aGlzLl9jYW5NYXJrSWROYW1lID0gdHJ1ZTtcbiAgICAgIHNvdXJjZVBvcy5pZGVudGlmaWVyTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIHNvdXJjZVBvcy5pZGVudGlmaWVyTmFtZVBvcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5zb3VyY2UoXCJlbmRcIiwgbG9jKTtcbiAgfVxuICBzb3VyY2UocHJvcCwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLl9tYXApIHJldHVybjtcbiAgICB0aGlzLl9ub3JtYWxpemVQb3NpdGlvbihwcm9wLCBsb2MsIDApO1xuICB9XG4gIHNvdXJjZVdpdGhPZmZzZXQocHJvcCwgbG9jLCBjb2x1bW5PZmZzZXQpIHtcbiAgICBpZiAoIXRoaXMuX21hcCkgcmV0dXJuO1xuICAgIHRoaXMuX25vcm1hbGl6ZVBvc2l0aW9uKHByb3AsIGxvYywgY29sdW1uT2Zmc2V0KTtcbiAgfVxuICBfbm9ybWFsaXplUG9zaXRpb24ocHJvcCwgbG9jLCBjb2x1bW5PZmZzZXQpIHtcbiAgICBjb25zdCBwb3MgPSBsb2NbcHJvcF07XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc291cmNlUG9zaXRpb247XG4gICAgaWYgKHBvcykge1xuICAgICAgdGFyZ2V0LmxpbmUgPSBwb3MubGluZTtcbiAgICAgIHRhcmdldC5jb2x1bW4gPSBNYXRoLm1heChwb3MuY29sdW1uICsgY29sdW1uT2Zmc2V0LCAwKTtcbiAgICAgIHRhcmdldC5maWxlbmFtZSA9IGxvYy5maWxlbmFtZTtcbiAgICB9XG4gIH1cbiAgZ2V0Q3VycmVudENvbHVtbigpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGNvbnN0IHF1ZXVlQ3Vyc29yID0gdGhpcy5fcXVldWVDdXJzb3I7XG4gICAgbGV0IGxhc3RJbmRleCA9IC0xO1xuICAgIGxldCBsZW4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWVDdXJzb3I7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IHF1ZXVlW2ldO1xuICAgICAgaWYgKGl0ZW0uY2hhciA9PT0gMTApIHtcbiAgICAgICAgbGFzdEluZGV4ID0gbGVuO1xuICAgICAgfVxuICAgICAgbGVuICs9IGl0ZW0ucmVwZWF0O1xuICAgIH1cbiAgICByZXR1cm4gbGFzdEluZGV4ID09PSAtMSA/IHRoaXMuX3Bvc2l0aW9uLmNvbHVtbiArIGxlbiA6IGxlbiAtIDEgLSBsYXN0SW5kZXg7XG4gIH1cbiAgZ2V0Q3VycmVudExpbmUoKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcXVldWVDdXJzb3I7IGkrKykge1xuICAgICAgaWYgKHF1ZXVlW2ldLmNoYXIgPT09IDEwKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb3NpdGlvbi5saW5lICsgY291bnQ7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEJ1ZmZlcjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVmZmVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74960\n')},90546:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.BlockStatement = BlockStatement;\nexports.Directive = Directive;\nexports.DirectiveLiteral = DirectiveLiteral;\nexports.File = File;\nexports.InterpreterDirective = InterpreterDirective;\nexports.Placeholder = Placeholder;\nexports.Program = Program;\nfunction File(node) {\n  if (node.program) {\n    this.print(node.program.interpreter);\n  }\n  this.print(node.program);\n}\nfunction Program(node) {\n  var _node$directives;\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n  const directivesLen = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;\n  if (directivesLen) {\n    var _node$directives$trai;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, {\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body);\n}\nfunction BlockStatement(node) {\n  var _node$directives2;\n  this.tokenChar(123);\n  const exit = this.enterDelimited();\n  const directivesLen = (_node$directives2 = node.directives) == null ? void 0 : _node$directives2.length;\n  if (directivesLen) {\n    var _node$directives$trai2;\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, {\n      indent: true,\n      trailingCommentsLineOffset: newline\n    });\n    if (!((_node$directives$trai2 = node.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {\n      this.newline(newline);\n    }\n  }\n  this.printSequence(node.body, {\n    indent: true\n  });\n  exit();\n  this.rightBrace(node);\n}\nfunction Directive(node) {\n  this.print(node.value);\n  this.semicolon();\n}\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*"/;\nfunction DirectiveLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const {\n    value\n  } = node;\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`"${value}"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`\'${value}\'`);\n  } else {\n    throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");\n  }\n}\nfunction InterpreterDirective(node) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\nfunction Placeholder(node) {\n  this.token("%%");\n  this.print(node.name);\n  this.token("%%");\n  if (node.expectedNode === "Statement") {\n    this.semicolon();\n  }\n}\n\n//# sourceMappingURL=base.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA1NDYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0JBQXNCO0FBQ3RCLGlCQUFpQjtBQUNqQix3QkFBd0I7QUFDeEIsWUFBWTtBQUNaLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QixJQUFJO0FBQ0osbUJBQW1CLE1BQU07QUFDekIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvYmFzZS5qcz8zZjA2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CbG9ja1N0YXRlbWVudCA9IEJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5EaXJlY3RpdmUgPSBEaXJlY3RpdmU7XG5leHBvcnRzLkRpcmVjdGl2ZUxpdGVyYWwgPSBEaXJlY3RpdmVMaXRlcmFsO1xuZXhwb3J0cy5GaWxlID0gRmlsZTtcbmV4cG9ydHMuSW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBJbnRlcnByZXRlckRpcmVjdGl2ZTtcbmV4cG9ydHMuUGxhY2Vob2xkZXIgPSBQbGFjZWhvbGRlcjtcbmV4cG9ydHMuUHJvZ3JhbSA9IFByb2dyYW07XG5mdW5jdGlvbiBGaWxlKG5vZGUpIHtcbiAgaWYgKG5vZGUucHJvZ3JhbSkge1xuICAgIHRoaXMucHJpbnQobm9kZS5wcm9ncmFtLmludGVycHJldGVyKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUucHJvZ3JhbSk7XG59XG5mdW5jdGlvbiBQcm9ncmFtKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGRpcmVjdGl2ZXM7XG4gIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICB0aGlzLnByaW50SW5uZXJDb21tZW50cygpO1xuICBjb25zdCBkaXJlY3RpdmVzTGVuID0gKF9ub2RlJGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRkaXJlY3RpdmVzLmxlbmd0aDtcbiAgaWYgKGRpcmVjdGl2ZXNMZW4pIHtcbiAgICB2YXIgX25vZGUkZGlyZWN0aXZlcyR0cmFpO1xuICAgIGNvbnN0IG5ld2xpbmUgPSBub2RlLmJvZHkubGVuZ3RoID8gMiA6IDE7XG4gICAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuZGlyZWN0aXZlcywge1xuICAgICAgdHJhaWxpbmdDb21tZW50c0xpbmVPZmZzZXQ6IG5ld2xpbmVcbiAgICB9KTtcbiAgICBpZiAoISgoX25vZGUkZGlyZWN0aXZlcyR0cmFpID0gbm9kZS5kaXJlY3RpdmVzW2RpcmVjdGl2ZXNMZW4gLSAxXS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJGRpcmVjdGl2ZXMkdHJhaS5sZW5ndGgpKSB7XG4gICAgICB0aGlzLm5ld2xpbmUobmV3bGluZSk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRTZXF1ZW5jZShub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gQmxvY2tTdGF0ZW1lbnQobm9kZSkge1xuICB2YXIgX25vZGUkZGlyZWN0aXZlczI7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIGNvbnN0IGV4aXQgPSB0aGlzLmVudGVyRGVsaW1pdGVkKCk7XG4gIGNvbnN0IGRpcmVjdGl2ZXNMZW4gPSAoX25vZGUkZGlyZWN0aXZlczIgPSBub2RlLmRpcmVjdGl2ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRkaXJlY3RpdmVzMi5sZW5ndGg7XG4gIGlmIChkaXJlY3RpdmVzTGVuKSB7XG4gICAgdmFyIF9ub2RlJGRpcmVjdGl2ZXMkdHJhaTI7XG4gICAgY29uc3QgbmV3bGluZSA9IG5vZGUuYm9keS5sZW5ndGggPyAyIDogMTtcbiAgICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5kaXJlY3RpdmVzLCB7XG4gICAgICBpbmRlbnQ6IHRydWUsXG4gICAgICB0cmFpbGluZ0NvbW1lbnRzTGluZU9mZnNldDogbmV3bGluZVxuICAgIH0pO1xuICAgIGlmICghKChfbm9kZSRkaXJlY3RpdmVzJHRyYWkyID0gbm9kZS5kaXJlY3RpdmVzW2RpcmVjdGl2ZXNMZW4gLSAxXS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJGRpcmVjdGl2ZXMkdHJhaTIubGVuZ3RoKSkge1xuICAgICAgdGhpcy5uZXdsaW5lKG5ld2xpbmUpO1xuICAgIH1cbiAgfVxuICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5ib2R5LCB7XG4gICAgaW5kZW50OiB0cnVlXG4gIH0pO1xuICBleGl0KCk7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIERpcmVjdGl2ZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5jb25zdCB1bmVzY2FwZWRTaW5nbGVRdW90ZVJFID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqJy87XG5jb25zdCB1bmVzY2FwZWREb3VibGVRdW90ZVJFID0gLyg/Ol58W15cXFxcXSkoPzpcXFxcXFxcXCkqXCIvO1xuZnVuY3Rpb24gRGlyZWN0aXZlTGl0ZXJhbChub2RlKSB7XG4gIGNvbnN0IHJhdyA9IHRoaXMuZ2V0UG9zc2libGVSYXcobm9kZSk7XG4gIGlmICghdGhpcy5mb3JtYXQubWluaWZpZWQgJiYgcmF3ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRva2VuKHJhdyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtcbiAgICB2YWx1ZVxuICB9ID0gbm9kZTtcbiAgaWYgKCF1bmVzY2FwZWREb3VibGVRdW90ZVJFLnRlc3QodmFsdWUpKSB7XG4gICAgdGhpcy50b2tlbihgXCIke3ZhbHVlfVwiYCk7XG4gIH0gZWxzZSBpZiAoIXVuZXNjYXBlZFNpbmdsZVF1b3RlUkUudGVzdCh2YWx1ZSkpIHtcbiAgICB0aGlzLnRva2VuKGAnJHt2YWx1ZX0nYCk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIEFTVDogaXQgaXMgbm90IHBvc3NpYmxlIHRvIHByaW50IGEgZGlyZWN0aXZlIGNvbnRhaW5pbmdcIiArIFwiIGJvdGggdW5lc2NhcGVkIHNpbmdsZSBhbmQgZG91YmxlIHF1b3Rlcy5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIEludGVycHJldGVyRGlyZWN0aXZlKG5vZGUpIHtcbiAgdGhpcy50b2tlbihgIyEke25vZGUudmFsdWV9YCk7XG4gIHRoaXMubmV3bGluZSgxLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcIiUlXCIpO1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG4gIHRoaXMudG9rZW4oXCIlJVwiKTtcbiAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIlN0YXRlbWVudFwiKSB7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///90546\n')},76271:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ClassAccessorProperty = ClassAccessorProperty;\nexports.ClassBody = ClassBody;\nexports.ClassExpression = exports.ClassDeclaration = ClassDeclaration;\nexports.ClassMethod = ClassMethod;\nexports.ClassPrivateMethod = ClassPrivateMethod;\nexports.ClassPrivateProperty = ClassPrivateProperty;\nexports.ClassProperty = ClassProperty;\nexports.StaticBlock = StaticBlock;\nexports._classMethodHead = _classMethodHead;\nvar _t = __webpack_require__(2352);\nconst {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration\n} = _t;\nfunction ClassDeclaration(node, parent) {\n  const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n  if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {\n    this.printJoin(node.decorators);\n  }\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n  if (node.abstract) {\n    this.word("abstract");\n    this.space();\n  }\n  this.word("class");\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n  this.print(node.typeParameters);\n  if (node.superClass) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.print(node.superClass);\n    this.print(node.superTypeParameters);\n  }\n  if (node.implements) {\n    this.space();\n    this.word("implements");\n    this.space();\n    this.printList(node.implements);\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction ClassBody(node) {\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator == null || separator(-1);\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, {\n      statement: true,\n      indent: true,\n      separator,\n      printTrailingSeparator: true\n    });\n    exit();\n    if (!this.endsWith(10)) this.newline();\n    this.rightBrace(node);\n  }\n}\nfunction classBodyEmptySemicolonsPrinter(printer, node) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n  let k = 1;\n  let occurrenceCount = 0;\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (nextLocIndex < node.body.length && node.body[nextLocIndex].start == null) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n  return i => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n    const end = nextLocIndex === node.body.length ? node.end : node.body[nextLocIndex].start;\n    let tok;\n    while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {\n      printer.token(";", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\nfunction ClassProperty(node) {\n  this.printJoin(node.decorators);\n  if (!node.static && !this.format.preserveFormat) {\n    var _node$key$loc;\n    const endLine = (_node$key$loc = node.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;\n    if (endLine) this.catchUp(endLine);\n  }\n  this.tsPrintClassMemberModifiers(node);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassAccessorProperty(node) {\n  var _node$key$loc2;\n  this.printJoin(node.decorators);\n  const endLine = (_node$key$loc2 = node.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;\n  if (endLine) this.catchUp(endLine);\n  this.tsPrintClassMemberModifiers(node);\n  this.word("accessor", true);\n  this.space();\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  if (node.definite) {\n    this.tokenChar(33);\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassPrivateProperty(node) {\n  this.printJoin(node.decorators);\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  this.print(node.key);\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\nfunction ClassMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction ClassPrivateMethod(node) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction _classMethodHead(node) {\n  this.printJoin(node.decorators);\n  if (!this.format.preserveFormat) {\n    var _node$key$loc3;\n    const endLine = (_node$key$loc3 = node.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;\n    if (endLine) this.catchUp(endLine);\n  }\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\nfunction StaticBlock(node) {\n  this.word("static");\n  this.space();\n  this.tokenChar(123);\n  if (node.body.length === 0) {\n    this.tokenChar(125);\n  } else {\n    this.newline();\n    this.printSequence(node.body, {\n      indent: true\n    });\n    this.rightBrace(node);\n  }\n}\n\n//# sourceMappingURL=classes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYyNzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkJBQTZCO0FBQzdCLGlCQUFpQjtBQUNqQix1QkFBdUIsR0FBRyx3QkFBd0I7QUFDbEQsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvY2xhc3Nlcy5qcz80ODQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5DbGFzc0FjY2Vzc29yUHJvcGVydHkgPSBDbGFzc0FjY2Vzc29yUHJvcGVydHk7XG5leHBvcnRzLkNsYXNzQm9keSA9IENsYXNzQm9keTtcbmV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gQ2xhc3NEZWNsYXJhdGlvbjtcbmV4cG9ydHMuQ2xhc3NNZXRob2QgPSBDbGFzc01ldGhvZDtcbmV4cG9ydHMuQ2xhc3NQcml2YXRlTWV0aG9kID0gQ2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5DbGFzc1ByaXZhdGVQcm9wZXJ0eSA9IENsYXNzUHJpdmF0ZVByb3BlcnR5O1xuZXhwb3J0cy5DbGFzc1Byb3BlcnR5ID0gQ2xhc3NQcm9wZXJ0eTtcbmV4cG9ydHMuU3RhdGljQmxvY2sgPSBTdGF0aWNCbG9jaztcbmV4cG9ydHMuX2NsYXNzTWV0aG9kSGVhZCA9IF9jbGFzc01ldGhvZEhlYWQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBpc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbixcbiAgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uXG59ID0gX3Q7XG5mdW5jdGlvbiBDbGFzc0RlY2xhcmF0aW9uKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBpbkV4cG9ydCA9IGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKHBhcmVudCkgfHwgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKHBhcmVudCk7XG4gIGlmICghaW5FeHBvcnQgfHwgIXRoaXMuX3Nob3VsZFByaW50RGVjb3JhdG9yc0JlZm9yZUV4cG9ydChwYXJlbnQpKSB7XG4gICAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzKTtcbiAgfVxuICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKG5vZGUuYWJzdHJhY3QpIHtcbiAgICB0aGlzLndvcmQoXCJhYnN0cmFjdFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwiY2xhc3NcIik7XG4gIGlmIChub2RlLmlkKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5pZCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgaWYgKG5vZGUuc3VwZXJDbGFzcykge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJleHRlbmRzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuc3VwZXJDbGFzcyk7XG4gICAgdGhpcy5wcmludChub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMpO1xuICB9XG4gIGlmIChub2RlLmltcGxlbWVudHMpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiaW1wbGVtZW50c1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludExpc3Qobm9kZS5pbXBsZW1lbnRzKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIENsYXNzQm9keShub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIGlmIChub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICBjb25zdCBzZXBhcmF0b3IgPSBjbGFzc0JvZHlFbXB0eVNlbWljb2xvbnNQcmludGVyKHRoaXMsIG5vZGUpO1xuICAgIHNlcGFyYXRvciA9PSBudWxsIHx8IHNlcGFyYXRvcigtMSk7XG4gICAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgICB0aGlzLnByaW50Sm9pbihub2RlLmJvZHksIHtcbiAgICAgIHN0YXRlbWVudDogdHJ1ZSxcbiAgICAgIGluZGVudDogdHJ1ZSxcbiAgICAgIHNlcGFyYXRvcixcbiAgICAgIHByaW50VHJhaWxpbmdTZXBhcmF0b3I6IHRydWVcbiAgICB9KTtcbiAgICBleGl0KCk7XG4gICAgaWYgKCF0aGlzLmVuZHNXaXRoKDEwKSkgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy5yaWdodEJyYWNlKG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBjbGFzc0JvZHlFbXB0eVNlbWljb2xvbnNQcmludGVyKHByaW50ZXIsIG5vZGUpIHtcbiAgaWYgKCFwcmludGVyLnRva2VuTWFwIHx8IG5vZGUuc3RhcnQgPT0gbnVsbCB8fCBub2RlLmVuZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgaW5kZXhlcyA9IHByaW50ZXIudG9rZW5NYXAuZ2V0SW5kZXhlcyhub2RlKTtcbiAgaWYgKCFpbmRleGVzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGsgPSAxO1xuICBsZXQgb2NjdXJyZW5jZUNvdW50ID0gMDtcbiAgbGV0IG5leHRMb2NJbmRleCA9IDA7XG4gIGNvbnN0IGFkdmFuY2VOZXh0TG9jSW5kZXggPSAoKSA9PiB7XG4gICAgd2hpbGUgKG5leHRMb2NJbmRleCA8IG5vZGUuYm9keS5sZW5ndGggJiYgbm9kZS5ib2R5W25leHRMb2NJbmRleF0uc3RhcnQgPT0gbnVsbCkge1xuICAgICAgbmV4dExvY0luZGV4Kys7XG4gICAgfVxuICB9O1xuICBhZHZhbmNlTmV4dExvY0luZGV4KCk7XG4gIHJldHVybiBpID0+IHtcbiAgICBpZiAobmV4dExvY0luZGV4IDw9IGkpIHtcbiAgICAgIG5leHRMb2NJbmRleCA9IGkgKyAxO1xuICAgICAgYWR2YW5jZU5leHRMb2NJbmRleCgpO1xuICAgIH1cbiAgICBjb25zdCBlbmQgPSBuZXh0TG9jSW5kZXggPT09IG5vZGUuYm9keS5sZW5ndGggPyBub2RlLmVuZCA6IG5vZGUuYm9keVtuZXh0TG9jSW5kZXhdLnN0YXJ0O1xuICAgIGxldCB0b2s7XG4gICAgd2hpbGUgKGsgPCBpbmRleGVzLmxlbmd0aCAmJiBwcmludGVyLnRva2VuTWFwLm1hdGNoZXNPcmlnaW5hbCh0b2sgPSBwcmludGVyLl90b2tlbnNbaW5kZXhlc1trXV0sIFwiO1wiKSAmJiB0b2suc3RhcnQgPCBlbmQpIHtcbiAgICAgIHByaW50ZXIudG9rZW4oXCI7XCIsIHVuZGVmaW5lZCwgb2NjdXJyZW5jZUNvdW50KyspO1xuICAgICAgaysrO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIENsYXNzUHJvcGVydHkobm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLmRlY29yYXRvcnMpO1xuICBpZiAoIW5vZGUuc3RhdGljICYmICF0aGlzLmZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCkge1xuICAgIHZhciBfbm9kZSRrZXkkbG9jO1xuICAgIGNvbnN0IGVuZExpbmUgPSAoX25vZGUka2V5JGxvYyA9IG5vZGUua2V5LmxvYykgPT0gbnVsbCB8fCAoX25vZGUka2V5JGxvYyA9IF9ub2RlJGtleSRsb2MuZW5kKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUka2V5JGxvYy5saW5lO1xuICAgIGlmIChlbmRMaW5lKSB0aGlzLmNhdGNoVXAoZW5kTGluZSk7XG4gIH1cbiAgdGhpcy50c1ByaW50Q2xhc3NNZW1iZXJNb2RpZmllcnMobm9kZSk7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICAgIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICAgIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl92YXJpYW5jZShub2RlKTtcbiAgICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgfVxuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICBpZiAobm9kZS5kZWZpbml0ZSkge1xuICAgIHRoaXMudG9rZW5DaGFyKDMzKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICBpZiAobm9kZS52YWx1ZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIENsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKSB7XG4gIHZhciBfbm9kZSRrZXkkbG9jMjtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzKTtcbiAgY29uc3QgZW5kTGluZSA9IChfbm9kZSRrZXkkbG9jMiA9IG5vZGUua2V5LmxvYykgPT0gbnVsbCB8fCAoX25vZGUka2V5JGxvYzIgPSBfbm9kZSRrZXkkbG9jMi5lbmQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRrZXkkbG9jMi5saW5lO1xuICBpZiAoZW5kTGluZSkgdGhpcy5jYXRjaFVwKGVuZExpbmUpO1xuICB0aGlzLnRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycyhub2RlKTtcbiAgdGhpcy53b3JkKFwiYWNjZXNzb3JcIiwgdHJ1ZSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gICAgdGhpcy5wcmludChub2RlLmtleSk7XG4gICAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICAgIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICB9XG4gIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB9XG4gIGlmIChub2RlLmRlZmluaXRlKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoMzMpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIGlmIChub2RlLnZhbHVlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnZhbHVlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLmRlY29yYXRvcnMpO1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICBpZiAobm9kZS52YWx1ZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIENsYXNzTWV0aG9kKG5vZGUpIHtcbiAgdGhpcy5fY2xhc3NNZXRob2RIZWFkKG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIENsYXNzUHJpdmF0ZU1ldGhvZChub2RlKSB7XG4gIHRoaXMuX2NsYXNzTWV0aG9kSGVhZChub2RlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBfY2xhc3NNZXRob2RIZWFkKG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzKTtcbiAgaWYgKCF0aGlzLmZvcm1hdC5wcmVzZXJ2ZUZvcm1hdCkge1xuICAgIHZhciBfbm9kZSRrZXkkbG9jMztcbiAgICBjb25zdCBlbmRMaW5lID0gKF9ub2RlJGtleSRsb2MzID0gbm9kZS5rZXkubG9jKSA9PSBudWxsIHx8IChfbm9kZSRrZXkkbG9jMyA9IF9ub2RlJGtleSRsb2MzLmVuZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGtleSRsb2MzLmxpbmU7XG4gICAgaWYgKGVuZExpbmUpIHRoaXMuY2F0Y2hVcChlbmRMaW5lKTtcbiAgfVxuICB0aGlzLnRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycyhub2RlKTtcbiAgdGhpcy5fbWV0aG9kSGVhZChub2RlKTtcbn1cbmZ1bmN0aW9uIFN0YXRpY0Jsb2NrKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIGlmIChub2RlLmJvZHkubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5ib2R5LCB7XG4gICAgICBpbmRlbnQ6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3Nlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76271\n')},34436:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AwaitExpression = AwaitExpression;\nexports.BindExpression = BindExpression;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.Decorator = Decorator;\nexports.DoExpression = DoExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.Import = Import;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.ModuleExpression = ModuleExpression;\nexports.NewExpression = NewExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.PrivateName = PrivateName;\nexports.SequenceExpression = SequenceExpression;\nexports.Super = Super;\nexports.ThisExpression = ThisExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.YieldExpression = YieldExpression;\nexports._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;\nvar _t = __webpack_require__(2352);\nvar _index = __webpack_require__(31373);\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern\n} = _t;\nfunction UnaryExpression(node) {\n  const {\n    operator\n  } = node;\n  if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n  this.print(node.argument);\n}\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word("async", true);\n    this.space();\n  }\n  this.word("do");\n  this.space();\n  this.print(node.body);\n}\nfunction ParenthesizedExpression(node) {\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\nfunction ConditionalExpression(node) {\n  this.print(node.test);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.alternate);\n}\nfunction NewExpression(node, parent) {\n  this.word("new");\n  this.space();\n  this.print(node.callee);\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n  this.print(node.typeArguments);\n  this.print(node.typeParameters);\n  if (node.optional) {\n    this.token("?.");\n  }\n  if (node.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node, ")")) {\n    return;\n  }\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, {\n    printTrailingSeparator: this.shouldPrintTrailingComma(")")\n  });\n  exit();\n  this.rightParens(node);\n}\nfunction SequenceExpression(node) {\n  this.printList(node.expressions);\n}\nfunction ThisExpression() {\n  this.word("this");\n}\nfunction Super() {\n  this.word("super");\n}\nfunction _shouldPrintDecoratorsBeforeExport(node) {\n  if (typeof this.format.decoratorsBeforeExport === "boolean") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return typeof node.start === "number" && node.start === node.declaration.start;\n}\nfunction Decorator(node) {\n  this.tokenChar(64);\n  this.print(node.expression);\n  this.newline();\n}\nfunction OptionalMemberExpression(node) {\n  let {\n    computed\n  } = node;\n  const {\n    optional,\n    property\n  } = node;\n  this.print(node.object);\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError("Got a MemberExpression for MemberExpression property");\n  }\n  if (isLiteral(property) && typeof property.value === "number") {\n    computed = true;\n  }\n  if (optional) {\n    this.token("?.");\n  }\n  if (computed) {\n    this.tokenChar(91);\n    this.print(property);\n    this.tokenChar(93);\n  } else {\n    if (!optional) {\n      this.tokenChar(46);\n    }\n    this.print(property);\n  }\n}\nfunction OptionalCallExpression(node) {\n  this.print(node.callee);\n  this.print(node.typeParameters);\n  if (node.optional) {\n    this.token("?.");\n  }\n  this.print(node.typeArguments);\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\nfunction CallExpression(node) {\n  this.print(node.callee);\n  this.print(node.typeArguments);\n  this.print(node.typeParameters);\n  this.tokenChar(40);\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, {\n    printTrailingSeparator: this.shouldPrintTrailingComma(")")\n  });\n  exit();\n  this.rightParens(node);\n}\nfunction Import() {\n  this.word("import");\n}\nfunction AwaitExpression(node) {\n  this.word("await");\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument);\n  }\n}\nfunction YieldExpression(node) {\n  this.word("yield", true);\n  if (node.delegate) {\n    this.tokenChar(42);\n    if (node.argument) {\n      this.space();\n      this.print(node.argument);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument);\n    }\n  }\n}\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\nfunction ExpressionStatement(node) {\n  this.tokenContext |= _index.TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\nfunction AssignmentPattern(node) {\n  this.print(node.left);\n  if (node.left.type === "Identifier" || isPattern(node.left)) {\n    if (node.left.optional) this.tokenChar(63);\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right);\n}\nfunction AssignmentExpression(node) {\n  this.print(node.left);\n  this.space();\n  if (node.operator === "in" || node.operator === "instanceof") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === "/";\n  }\n  this.space();\n  this.print(node.right);\n}\nfunction BindExpression(node) {\n  this.print(node.object);\n  this.token("::");\n  this.print(node.callee);\n}\nfunction MemberExpression(node) {\n  this.print(node.object);\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError("Got a MemberExpression for MemberExpression property");\n  }\n  let computed = node.computed;\n  if (isLiteral(node.property) && typeof node.property.value === "number") {\n    computed = true;\n  }\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.tokenChar(91);\n    this.print(node.property);\n    this.tokenChar(93);\n    exit();\n  } else {\n    this.tokenChar(46);\n    this.print(node.property);\n  }\n}\nfunction MetaProperty(node) {\n  this.print(node.meta);\n  this.tokenChar(46);\n  this.print(node.property);\n}\nfunction PrivateName(node) {\n  this.tokenChar(35);\n  this.print(node.id);\n}\nfunction V8IntrinsicIdentifier(node) {\n  this.tokenChar(37);\n  this.word(node.name);\n}\nfunction ModuleExpression(node) {\n  this.word("module", true);\n  this.space();\n  this.tokenChar(123);\n  this.indent();\n  const {\n    body\n  } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n\n//# sourceMappingURL=expressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0MzYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCO0FBQ25GLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0IsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQixhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLHVCQUF1QjtBQUN2QiwwQ0FBMEM7QUFDMUMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLEtBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2V4cHJlc3Npb25zLmpzPzk3Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkxvZ2ljYWxFeHByZXNzaW9uID0gZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5Bc3NpZ25tZW50UGF0dGVybiA9IEFzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5Bd2FpdEV4cHJlc3Npb24gPSBBd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLkJpbmRFeHByZXNzaW9uID0gQmluZEV4cHJlc3Npb247XG5leHBvcnRzLkNhbGxFeHByZXNzaW9uID0gQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLkNvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IENvbmRpdGlvbmFsRXhwcmVzc2lvbjtcbmV4cG9ydHMuRGVjb3JhdG9yID0gRGVjb3JhdG9yO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBEb0V4cHJlc3Npb247XG5leHBvcnRzLkVtcHR5U3RhdGVtZW50ID0gRW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLkV4cHJlc3Npb25TdGF0ZW1lbnQgPSBFeHByZXNzaW9uU3RhdGVtZW50O1xuZXhwb3J0cy5JbXBvcnQgPSBJbXBvcnQ7XG5leHBvcnRzLk1lbWJlckV4cHJlc3Npb24gPSBNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5NZXRhUHJvcGVydHkgPSBNZXRhUHJvcGVydHk7XG5leHBvcnRzLk1vZHVsZUV4cHJlc3Npb24gPSBNb2R1bGVFeHByZXNzaW9uO1xuZXhwb3J0cy5OZXdFeHByZXNzaW9uID0gTmV3RXhwcmVzc2lvbjtcbmV4cG9ydHMuT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IE9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuUHJpdmF0ZU5hbWUgPSBQcml2YXRlTmFtZTtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5TdXBlciA9IFN1cGVyO1xuZXhwb3J0cy5UaGlzRXhwcmVzc2lvbiA9IFRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5VbmFyeUV4cHJlc3Npb24gPSBVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLlVwZGF0ZUV4cHJlc3Npb24gPSBVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5WOEludHJpbnNpY0lkZW50aWZpZXIgPSBWOEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLllpZWxkRXhwcmVzc2lvbiA9IFlpZWxkRXhwcmVzc2lvbjtcbmV4cG9ydHMuX3Nob3VsZFByaW50RGVjb3JhdG9yc0JlZm9yZUV4cG9ydCA9IF9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9ub2RlL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0NhbGxFeHByZXNzaW9uLFxuICBpc0xpdGVyYWwsXG4gIGlzTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNOZXdFeHByZXNzaW9uLFxuICBpc1BhdHRlcm5cbn0gPSBfdDtcbmZ1bmN0aW9uIFVuYXJ5RXhwcmVzc2lvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVyYXRvclxuICB9ID0gbm9kZTtcbiAgaWYgKG9wZXJhdG9yID09PSBcInZvaWRcIiB8fCBvcGVyYXRvciA9PT0gXCJkZWxldGVcIiB8fCBvcGVyYXRvciA9PT0gXCJ0eXBlb2ZcIiB8fCBvcGVyYXRvciA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgdGhpcy53b3JkKG9wZXJhdG9yKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbihvcGVyYXRvcik7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIERvRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLmFzeW5jKSB7XG4gICAgdGhpcy53b3JkKFwiYXN5bmNcIiwgdHJ1ZSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImRvXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIGV4aXQoKTtcbiAgdGhpcy5yaWdodFBhcmVucyhub2RlKTtcbn1cbmZ1bmN0aW9uIFVwZGF0ZUV4cHJlc3Npb24obm9kZSkge1xuICBpZiAobm9kZS5wcmVmaXgpIHtcbiAgICB0aGlzLnRva2VuKG5vZGUub3BlcmF0b3IpO1xuICAgIHRoaXMucHJpbnQobm9kZS5hcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50LCB0cnVlKTtcbiAgICB0aGlzLnRva2VuKG5vZGUub3BlcmF0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5jb25zZXF1ZW50KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFsdGVybmF0ZSk7XG59XG5mdW5jdGlvbiBOZXdFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLndvcmQoXCJuZXdcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmNhbGxlZSk7XG4gIGlmICh0aGlzLmZvcm1hdC5taW5pZmllZCAmJiBub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDAgJiYgIW5vZGUub3B0aW9uYWwgJiYgIWlzQ2FsbEV4cHJlc3Npb24ocGFyZW50LCB7XG4gICAgY2FsbGVlOiBub2RlXG4gIH0pICYmICFpc01lbWJlckV4cHJlc3Npb24ocGFyZW50KSAmJiAhaXNOZXdFeHByZXNzaW9uKHBhcmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBcmd1bWVudHMpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW4oXCI/LlwiKTtcbiAgfVxuICBpZiAobm9kZS5hcmd1bWVudHMubGVuZ3RoID09PSAwICYmIHRoaXMudG9rZW5NYXAgJiYgIXRoaXMudG9rZW5NYXAuZW5kTWF0Y2hlcyhub2RlLCBcIilcIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICB0aGlzLnByaW50TGlzdChub2RlLmFyZ3VtZW50cywge1xuICAgIHByaW50VHJhaWxpbmdTZXBhcmF0b3I6IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwiKVwiKVxuICB9KTtcbiAgZXhpdCgpO1xuICB0aGlzLnJpZ2h0UGFyZW5zKG5vZGUpO1xufVxuZnVuY3Rpb24gU2VxdWVuY2VFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5leHByZXNzaW9ucyk7XG59XG5mdW5jdGlvbiBUaGlzRXhwcmVzc2lvbigpIHtcbiAgdGhpcy53b3JkKFwidGhpc1wiKTtcbn1cbmZ1bmN0aW9uIFN1cGVyKCkge1xuICB0aGlzLndvcmQoXCJzdXBlclwiKTtcbn1cbmZ1bmN0aW9uIF9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQobm9kZSkge1xuICBpZiAodHlwZW9mIHRoaXMuZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBub2RlLnN0YXJ0ID09PSBcIm51bWJlclwiICYmIG5vZGUuc3RhcnQgPT09IG5vZGUuZGVjbGFyYXRpb24uc3RhcnQ7XG59XG5mdW5jdGlvbiBEZWNvcmF0b3Iobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig2NCk7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5uZXdsaW5lKCk7XG59XG5mdW5jdGlvbiBPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICBsZXQge1xuICAgIGNvbXB1dGVkXG4gIH0gPSBub2RlO1xuICBjb25zdCB7XG4gICAgb3B0aW9uYWwsXG4gICAgcHJvcGVydHlcbiAgfSA9IG5vZGU7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICBpZiAoIWNvbXB1dGVkICYmIGlzTWVtYmVyRXhwcmVzc2lvbihwcm9wZXJ0eSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR290IGEgTWVtYmVyRXhwcmVzc2lvbiBmb3IgTWVtYmVyRXhwcmVzc2lvbiBwcm9wZXJ0eVwiKTtcbiAgfVxuICBpZiAoaXNMaXRlcmFsKHByb3BlcnR5KSAmJiB0eXBlb2YgcHJvcGVydHkudmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBjb21wdXRlZCA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbmFsKSB7XG4gICAgdGhpcy50b2tlbihcIj8uXCIpO1xuICB9XG4gIGlmIChjb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgICB0aGlzLnByaW50KHByb3BlcnR5KTtcbiAgICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFvcHRpb25hbCkge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KHByb3BlcnR5KTtcbiAgfVxufVxuZnVuY3Rpb24gT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW4oXCI/LlwiKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudHlwZUFyZ3VtZW50cyk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICBleGl0KCk7XG4gIHRoaXMucmlnaHRQYXJlbnMobm9kZSk7XG59XG5mdW5jdGlvbiBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFyZ3VtZW50cyk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgdGhpcy5wcmludExpc3Qobm9kZS5hcmd1bWVudHMsIHtcbiAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yOiB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIilcIilcbiAgfSk7XG4gIGV4aXQoKTtcbiAgdGhpcy5yaWdodFBhcmVucyhub2RlKTtcbn1cbmZ1bmN0aW9uIEltcG9ydCgpIHtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xufVxuZnVuY3Rpb24gQXdhaXRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiYXdhaXRcIik7XG4gIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRUZXJtaW5hdG9ybGVzcyhub2RlLmFyZ3VtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwieWllbGRcIiwgdHJ1ZSk7XG4gIGlmIChub2RlLmRlbGVnYXRlKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICAgIGlmIChub2RlLmFyZ3VtZW50KSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobm9kZS5hcmd1bWVudCkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy5wcmludFRlcm1pbmF0b3JsZXNzKG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gRW1wdHlTdGF0ZW1lbnQoKSB7XG4gIHRoaXMuc2VtaWNvbG9uKHRydWUpO1xufVxuZnVuY3Rpb24gRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMudG9rZW5Db250ZXh0IHw9IF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudDtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gQXNzaWdubWVudFBhdHRlcm4obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGVmdCk7XG4gIGlmIChub2RlLmxlZnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgaXNQYXR0ZXJuKG5vZGUubGVmdCkpIHtcbiAgICBpZiAobm9kZS5sZWZ0Lm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gICAgdGhpcy5wcmludChub2RlLmxlZnQudHlwZUFubm90YXRpb24pO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCk7XG59XG5mdW5jdGlvbiBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5sZWZ0KTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAobm9kZS5vcGVyYXRvciA9PT0gXCJpblwiIHx8IG5vZGUub3BlcmF0b3IgPT09IFwiaW5zdGFuY2VvZlwiKSB7XG4gICAgdGhpcy53b3JkKG5vZGUub3BlcmF0b3IpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW4obm9kZS5vcGVyYXRvcik7XG4gICAgdGhpcy5fZW5kc1dpdGhEaXYgPSBub2RlLm9wZXJhdG9yID09PSBcIi9cIjtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCk7XG59XG5mdW5jdGlvbiBCaW5kRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICB0aGlzLnRva2VuKFwiOjpcIik7XG4gIHRoaXMucHJpbnQobm9kZS5jYWxsZWUpO1xufVxuZnVuY3Rpb24gTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICBpZiAoIW5vZGUuY29tcHV0ZWQgJiYgaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUucHJvcGVydHkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdvdCBhIE1lbWJlckV4cHJlc3Npb24gZm9yIE1lbWJlckV4cHJlc3Npb24gcHJvcGVydHlcIik7XG4gIH1cbiAgbGV0IGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZDtcbiAgaWYgKGlzTGl0ZXJhbChub2RlLnByb3BlcnR5KSAmJiB0eXBlb2Ygbm9kZS5wcm9wZXJ0eS52YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgIGNvbXB1dGVkID0gdHJ1ZTtcbiAgfVxuICBpZiAoY29tcHV0ZWQpIHtcbiAgICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJvcGVydHkpO1xuICAgIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgICBleGl0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICAgIHRoaXMucHJpbnQobm9kZS5wcm9wZXJ0eSk7XG4gIH1cbn1cbmZ1bmN0aW9uIE1ldGFQcm9wZXJ0eShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5tZXRhKTtcbiAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICB0aGlzLnByaW50KG5vZGUucHJvcGVydHkpO1xufVxuZnVuY3Rpb24gUHJpdmF0ZU5hbWUobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigzNSk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCk7XG59XG5mdW5jdGlvbiBWOEludHJpbnNpY0lkZW50aWZpZXIobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigzNyk7XG4gIHRoaXMud29yZChub2RlLm5hbWUpO1xufVxuZnVuY3Rpb24gTW9kdWxlRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMud29yZChcIm1vZHVsZVwiLCB0cnVlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICB0aGlzLmluZGVudCgpO1xuICBjb25zdCB7XG4gICAgYm9keVxuICB9ID0gbm9kZTtcbiAgaWYgKGJvZHkuYm9keS5sZW5ndGggfHwgYm9keS5kaXJlY3RpdmVzLmxlbmd0aCkge1xuICAgIHRoaXMubmV3bGluZSgpO1xuICB9XG4gIHRoaXMucHJpbnQoYm9keSk7XG4gIHRoaXMuZGVkZW50KCk7XG4gIHRoaXMucmlnaHRCcmFjZShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwcmVzc2lvbnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34436\n')},72259:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, "NumberLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n}));\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, "StringLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n}));\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = __webpack_require__(2352);\nvar _modules = __webpack_require__(89638);\nvar _index = __webpack_require__(31373);\nvar _types2 = __webpack_require__(7942);\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\nfunction AnyTypeAnnotation() {\n  this.word("any");\n}\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n  this.word("boolean");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? "true" : "false");\n}\nfunction NullLiteralTypeAnnotation() {\n  this.word("null");\n}\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n  this.word("class");\n  this.space();\n  this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n  this.word("function");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation.typeAnnotation);\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n  this.semicolon();\n}\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word("checks");\n}\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word("checks");\n  this.tokenChar(40);\n  this.print(node.value);\n  this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n  this.word("declare");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n  this.word("declare");\n  this.space();\n  this.word("module");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\nfunction DeclareModuleExports(node) {\n  this.word("declare");\n  this.space();\n  this.word("module");\n  this.tokenChar(46);\n  this.word("exports");\n  this.print(node.typeAnnotation);\n}\nfunction DeclareTypeAlias(node) {\n  this.word("declare");\n  this.space();\n  this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word("declare");\n    this.space();\n  }\n  this.word("var");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n  this.word("declare");\n  this.space();\n  this.word("export");\n  this.space();\n  if (node.default) {\n    this.word("default");\n    this.space();\n  }\n  FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n  this.word("declare");\n  this.space();\n  _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word("enum");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word("of");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token("{");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token("...");\n    context.newline();\n  }\n  context.dedent();\n  context.token("}");\n}\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "boolean", explicitType);\n  enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "number", explicitType);\n  enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, "string", explicitType);\n  enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, "symbol", true);\n  enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id);\n  this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n  context.print(node.id);\n  context.space();\n  context.token("=");\n  context.space();\n  context.print(node.init);\n  context.token(",");\n}\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.tokenChar(125);\n    if (node.source) {\n      this.space();\n      this.word("from");\n      this.space();\n      this.print(node.source);\n    }\n    this.semicolon();\n  }\n}\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters);\n  this.tokenChar(40);\n  if (node.this) {\n    this.word("this");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n  this.printList(node.params);\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n    this.token("...");\n    this.print(node.rest);\n  }\n  this.tokenChar(41);\n  const type = parent == null ? void 0 : parent.type;\n  if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token("=>");\n  }\n  this.space();\n  this.print(node.returnType);\n}\nfunction FunctionTypeParam(node) {\n  this.print(node.name);\n  if (node.optional) this.tokenChar(63);\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\nfunction InterfaceExtends(node) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\nfunction _interfaceish(node) {\n  var _node$extends;\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === "DeclareClass") {\n    var _node$mixins, _node$implements;\n    if ((_node$mixins = node.mixins) != null && _node$mixins.length) {\n      this.space();\n      this.word("mixins");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if ((_node$implements = node.implements) != null && _node$implements.length) {\n      this.space();\n      this.word("implements");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction _variance(node) {\n  var _node$variance;\n  const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;\n  if (kind != null) {\n    if (kind === "plus") {\n      this.tokenChar(43);\n    } else if (kind === "minus") {\n      this.tokenChar(45);\n    }\n  }\n}\nfunction InterfaceDeclaration(node) {\n  this.word("interface");\n  this.space();\n  this._interfaceish(node);\n}\nfunction andSeparator(occurrenceCount) {\n  this.space();\n  this.token("&", false, occurrenceCount);\n  this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n  var _node$extends2;\n  this.word("interface");\n  if ((_node$extends2 = node.extends) != null && _node$extends2.length) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, {\n    separator: andSeparator\n  });\n}\nfunction MixedTypeAnnotation() {\n  this.word("mixed");\n}\nfunction EmptyTypeAnnotation() {\n  this.word("empty");\n}\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation);\n}\nfunction NumberTypeAnnotation() {\n  this.word("number");\n}\nfunction StringTypeAnnotation() {\n  this.word("string");\n}\nfunction ThisTypeAnnotation() {\n  this.word("this");\n}\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types);\n  this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n  this.word("typeof");\n  this.space();\n  this.print(node.argument);\n}\nfunction TypeAlias(node) {\n  this.word("type");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\nfunction TypeAnnotation(node, parent) {\n  this.tokenChar(58);\n  this.space();\n  if (parent.type === "ArrowFunctionExpression") {\n    this.tokenContext |= _index.TokenContext.arrowFlowReturnType;\n  } else if (node.optional) {\n    this.tokenChar(63);\n  }\n  this.print(node.typeAnnotation);\n}\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params, {});\n  this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n  this._variance(node);\n  this.word(node.name);\n  if (node.bound) {\n    this.print(node.bound);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default);\n  }\n}\nfunction OpaqueType(node) {\n  this.word("opaque");\n  this.space();\n  this.word("type");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype);\n  }\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token("{|");\n  } else {\n    this.tokenChar(123);\n  }\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n  if (props.length) {\n    this.newline();\n    this.space();\n    this.printJoin(props, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.tokenChar(44);\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n  if (node.inexact) {\n    this.indent();\n    this.token("...");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n  if (node.exact) {\n    this.token("|}");\n  } else {\n    this.tokenChar(125);\n  }\n}\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  this._variance(node);\n  this.tokenChar(91);\n  if (node.id) {\n    this.print(node.id);\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.key);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word("proto");\n    this.space();\n  }\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  if (node.kind === "get" || node.kind === "set") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value);\n}\nfunction ObjectTypeSpreadProperty(node) {\n  this.token("...");\n  this.print(node.argument);\n}\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification);\n  this.tokenChar(46);\n  this.print(node.id);\n}\nfunction SymbolTypeAnnotation() {\n  this.word("symbol");\n}\nfunction orSeparator(occurrenceCount) {\n  this.space();\n  this.token("|", false, occurrenceCount);\n  this.space();\n}\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, {\n    separator: orSeparator\n  });\n}\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.tokenChar(41);\n}\nfunction Variance(node) {\n  if (node.kind === "plus") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\nfunction VoidTypeAnnotation() {\n  this.word("void");\n}\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, true);\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token("?.");\n  }\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\n\n//# sourceMappingURL=flow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyNTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixvQ0FBb0M7QUFDcEMsNkJBQTZCO0FBQzdCLG9CQUFvQjtBQUNwQixtQ0FBbUM7QUFDbkMsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLDZCQUE2QixHQUFHLHVCQUF1QixHQUFHLHdCQUF3QjtBQUNsRiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLCtEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsOEJBQThCO0FBQzlCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQyxrQkFBa0I7QUFDbEIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiwrREFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGdDQUFnQyxHQUFHLGtDQUFrQztBQUNyRSw0QkFBNEI7QUFDNUIsMkJBQTJCO0FBQzNCLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQyxhQUFhLG1CQUFPLENBQUMsS0FBa0I7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLElBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvZmxvdy5qcz83ZDYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BbnlUeXBlQW5ub3RhdGlvbiA9IEFueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5BcnJheVR5cGVBbm5vdGF0aW9uID0gQXJyYXlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLkJvb2xlYW5UeXBlQW5ub3RhdGlvbiA9IEJvb2xlYW5UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRGVjbGFyZUNsYXNzID0gRGVjbGFyZUNsYXNzO1xuZXhwb3J0cy5EZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbiA9IERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuRGVjbGFyZUZ1bmN0aW9uID0gRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5EZWNsYXJlSW50ZXJmYWNlID0gRGVjbGFyZUludGVyZmFjZTtcbmV4cG9ydHMuRGVjbGFyZU1vZHVsZSA9IERlY2xhcmVNb2R1bGU7XG5leHBvcnRzLkRlY2xhcmVNb2R1bGVFeHBvcnRzID0gRGVjbGFyZU1vZHVsZUV4cG9ydHM7XG5leHBvcnRzLkRlY2xhcmVPcGFxdWVUeXBlID0gRGVjbGFyZU9wYXF1ZVR5cGU7XG5leHBvcnRzLkRlY2xhcmVUeXBlQWxpYXMgPSBEZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5EZWNsYXJlVmFyaWFibGUgPSBEZWNsYXJlVmFyaWFibGU7XG5leHBvcnRzLkRlY2xhcmVkUHJlZGljYXRlID0gRGVjbGFyZWRQcmVkaWNhdGU7XG5leHBvcnRzLkVtcHR5VHlwZUFubm90YXRpb24gPSBFbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5FbnVtQm9vbGVhbkJvZHkgPSBFbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLkVudW1Cb29sZWFuTWVtYmVyID0gRW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLkVudW1EZWNsYXJhdGlvbiA9IEVudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuRW51bURlZmF1bHRlZE1lbWJlciA9IEVudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLkVudW1OdW1iZXJCb2R5ID0gRW51bU51bWJlckJvZHk7XG5leHBvcnRzLkVudW1OdW1iZXJNZW1iZXIgPSBFbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5FbnVtU3RyaW5nQm9keSA9IEVudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5FbnVtU3RyaW5nTWVtYmVyID0gRW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuRW51bVN5bWJvbEJvZHkgPSBFbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuRXhpc3RzVHlwZUFubm90YXRpb24gPSBFeGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuRnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IEZ1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLkZ1bmN0aW9uVHlwZVBhcmFtID0gRnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLkluZGV4ZWRBY2Nlc3NUeXBlID0gSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLkluZmVycmVkUHJlZGljYXRlID0gSW5mZXJyZWRQcmVkaWNhdGU7XG5leHBvcnRzLkludGVyZmFjZURlY2xhcmF0aW9uID0gSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLkdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGV4cG9ydHMuQ2xhc3NJbXBsZW1lbnRzID0gZXhwb3J0cy5JbnRlcmZhY2VFeHRlbmRzID0gSW50ZXJmYWNlRXh0ZW5kcztcbmV4cG9ydHMuSW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuTWl4ZWRUeXBlQW5ub3RhdGlvbiA9IE1peGVkVHlwZUFubm90YXRpb247XG5leHBvcnRzLk51bGxMaXRlcmFsVHlwZUFubm90YXRpb24gPSBOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gTnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdHlwZXMyLk51bWVyaWNMaXRlcmFsO1xuICB9XG59KTtcbmV4cG9ydHMuTnVtYmVyVHlwZUFubm90YXRpb24gPSBOdW1iZXJUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0VHlwZUFubm90YXRpb24gPSBPYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IE9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLk9iamVjdFR5cGVJbmRleGVyID0gT2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLk9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5PYmplY3RUeXBlUHJvcGVydHkgPSBPYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMuT3BhcXVlVHlwZSA9IE9wYXF1ZVR5cGU7XG5leHBvcnRzLk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUgPSBPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5RdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IFF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90eXBlczIuU3RyaW5nTGl0ZXJhbDtcbiAgfVxufSk7XG5leHBvcnRzLlN0cmluZ1R5cGVBbm5vdGF0aW9uID0gU3RyaW5nVHlwZUFubm90YXRpb247XG5leHBvcnRzLlN5bWJvbFR5cGVBbm5vdGF0aW9uID0gU3ltYm9sVHlwZUFubm90YXRpb247XG5leHBvcnRzLlRoaXNUeXBlQW5ub3RhdGlvbiA9IFRoaXNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHVwbGVUeXBlQW5ub3RhdGlvbiA9IFR1cGxlVHlwZUFubm90YXRpb247XG5leHBvcnRzLlR5cGVBbGlhcyA9IFR5cGVBbGlhcztcbmV4cG9ydHMuVHlwZUFubm90YXRpb24gPSBUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVHlwZUNhc3RFeHByZXNzaW9uID0gVHlwZUNhc3RFeHByZXNzaW9uO1xuZXhwb3J0cy5UeXBlUGFyYW1ldGVyID0gVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gZXhwb3J0cy5UeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5UeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IFR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5VbmlvblR5cGVBbm5vdGF0aW9uID0gVW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuVmFyaWFuY2UgPSBWYXJpYW5jZTtcbmV4cG9ydHMuVm9pZFR5cGVBbm5vdGF0aW9uID0gVm9pZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5faW50ZXJmYWNlaXNoID0gX2ludGVyZmFjZWlzaDtcbmV4cG9ydHMuX3ZhcmlhbmNlID0gX3ZhcmlhbmNlO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfbW9kdWxlcyA9IHJlcXVpcmUoXCIuL21vZHVsZXMuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL25vZGUvaW5kZXguanNcIik7XG52YXIgX3R5cGVzMiA9IHJlcXVpcmUoXCIuL3R5cGVzLmpzXCIpO1xuY29uc3Qge1xuICBpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbixcbiAgaXNTdGF0ZW1lbnRcbn0gPSBfdDtcbmZ1bmN0aW9uIEFueVR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJhbnlcIik7XG59XG5mdW5jdGlvbiBBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmVsZW1lbnRUeXBlLCB0cnVlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG59XG5mdW5jdGlvbiBCb29sZWFuVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcImJvb2xlYW5cIik7XG59XG5mdW5jdGlvbiBCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKG5vZGUudmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIik7XG59XG5mdW5jdGlvbiBOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJudWxsXCIpO1xufVxuZnVuY3Rpb24gRGVjbGFyZUNsYXNzKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIWlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudCkpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJjbGFzc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLl9pbnRlcmZhY2Vpc2gobm9kZSk7XG59XG5mdW5jdGlvbiBEZWNsYXJlRnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XG4gIGlmICghaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24ocGFyZW50KSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImZ1bmN0aW9uXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZC50eXBlQW5ub3RhdGlvbi50eXBlQW5ub3RhdGlvbik7XG4gIGlmIChub2RlLnByZWRpY2F0ZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJlZGljYXRlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gSW5mZXJyZWRQcmVkaWNhdGUoKSB7XG4gIHRoaXMudG9rZW5DaGFyKDM3KTtcbiAgdGhpcy53b3JkKFwiY2hlY2tzXCIpO1xufVxuZnVuY3Rpb24gRGVjbGFyZWRQcmVkaWNhdGUobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigzNyk7XG4gIHRoaXMud29yZChcImNoZWNrc1wiKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG59XG5mdW5jdGlvbiBEZWNsYXJlSW50ZXJmYWNlKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLkludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUpO1xufVxuZnVuY3Rpb24gRGVjbGFyZU1vZHVsZShub2RlKSB7XG4gIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwibW9kdWxlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5pZCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSkge1xuICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcIm1vZHVsZVwiKTtcbiAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICB0aGlzLndvcmQoXCJleHBvcnRzXCIpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gRGVjbGFyZVR5cGVBbGlhcyhub2RlKSB7XG4gIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5UeXBlQWxpYXMobm9kZSk7XG59XG5mdW5jdGlvbiBEZWNsYXJlT3BhcXVlVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCFpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihwYXJlbnQpKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5PcGFxdWVUeXBlKG5vZGUpO1xufVxuZnVuY3Rpb24gRGVjbGFyZVZhcmlhYmxlKG5vZGUsIHBhcmVudCkge1xuICBpZiAoIWlzRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudCkpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJ2YXJcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLmlkLnR5cGVBbm5vdGF0aW9uKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwiZXhwb3J0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLmRlZmF1bHQpIHtcbiAgICB0aGlzLndvcmQoXCJkZWZhdWx0XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBGbG93RXhwb3J0RGVjbGFyYXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgX21vZHVsZXMuRXhwb3J0QWxsRGVjbGFyYXRpb24uY2FsbCh0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEVudW1EZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICBib2R5XG4gIH0gPSBub2RlO1xuICB0aGlzLndvcmQoXCJlbnVtXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoaWQpO1xuICB0aGlzLnByaW50KGJvZHkpO1xufVxuZnVuY3Rpb24gZW51bUV4cGxpY2l0VHlwZShjb250ZXh0LCBuYW1lLCBoYXNFeHBsaWNpdFR5cGUpIHtcbiAgaWYgKGhhc0V4cGxpY2l0VHlwZSkge1xuICAgIGNvbnRleHQuc3BhY2UoKTtcbiAgICBjb250ZXh0LndvcmQoXCJvZlwiKTtcbiAgICBjb250ZXh0LnNwYWNlKCk7XG4gICAgY29udGV4dC53b3JkKG5hbWUpO1xuICB9XG4gIGNvbnRleHQuc3BhY2UoKTtcbn1cbmZ1bmN0aW9uIGVudW1Cb2R5KGNvbnRleHQsIG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIG1lbWJlcnNcbiAgfSA9IG5vZGU7XG4gIGNvbnRleHQudG9rZW4oXCJ7XCIpO1xuICBjb250ZXh0LmluZGVudCgpO1xuICBjb250ZXh0Lm5ld2xpbmUoKTtcbiAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycykge1xuICAgIGNvbnRleHQucHJpbnQobWVtYmVyKTtcbiAgICBjb250ZXh0Lm5ld2xpbmUoKTtcbiAgfVxuICBpZiAobm9kZS5oYXNVbmtub3duTWVtYmVycykge1xuICAgIGNvbnRleHQudG9rZW4oXCIuLi5cIik7XG4gICAgY29udGV4dC5uZXdsaW5lKCk7XG4gIH1cbiAgY29udGV4dC5kZWRlbnQoKTtcbiAgY29udGV4dC50b2tlbihcIn1cIik7XG59XG5mdW5jdGlvbiBFbnVtQm9vbGVhbkJvZHkobm9kZSkge1xuICBjb25zdCB7XG4gICAgZXhwbGljaXRUeXBlXG4gIH0gPSBub2RlO1xuICBlbnVtRXhwbGljaXRUeXBlKHRoaXMsIFwiYm9vbGVhblwiLCBleHBsaWNpdFR5cGUpO1xuICBlbnVtQm9keSh0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEVudW1OdW1iZXJCb2R5KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGV4cGxpY2l0VHlwZVxuICB9ID0gbm9kZTtcbiAgZW51bUV4cGxpY2l0VHlwZSh0aGlzLCBcIm51bWJlclwiLCBleHBsaWNpdFR5cGUpO1xuICBlbnVtQm9keSh0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEVudW1TdHJpbmdCb2R5KG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGV4cGxpY2l0VHlwZVxuICB9ID0gbm9kZTtcbiAgZW51bUV4cGxpY2l0VHlwZSh0aGlzLCBcInN0cmluZ1wiLCBleHBsaWNpdFR5cGUpO1xuICBlbnVtQm9keSh0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEVudW1TeW1ib2xCb2R5KG5vZGUpIHtcbiAgZW51bUV4cGxpY2l0VHlwZSh0aGlzLCBcInN5bWJvbFwiLCB0cnVlKTtcbiAgZW51bUJvZHkodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtRGVmYXVsdGVkTWVtYmVyKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGlkXG4gIH0gPSBub2RlO1xuICB0aGlzLnByaW50KGlkKTtcbiAgdGhpcy50b2tlbkNoYXIoNDQpO1xufVxuZnVuY3Rpb24gZW51bUluaXRpYWxpemVkTWVtYmVyKGNvbnRleHQsIG5vZGUpIHtcbiAgY29udGV4dC5wcmludChub2RlLmlkKTtcbiAgY29udGV4dC5zcGFjZSgpO1xuICBjb250ZXh0LnRva2VuKFwiPVwiKTtcbiAgY29udGV4dC5zcGFjZSgpO1xuICBjb250ZXh0LnByaW50KG5vZGUuaW5pdCk7XG4gIGNvbnRleHQudG9rZW4oXCIsXCIpO1xufVxuZnVuY3Rpb24gRW51bUJvb2xlYW5NZW1iZXIobm9kZSkge1xuICBlbnVtSW5pdGlhbGl6ZWRNZW1iZXIodGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBFbnVtTnVtYmVyTWVtYmVyKG5vZGUpIHtcbiAgZW51bUluaXRpYWxpemVkTWVtYmVyKHRoaXMsIG5vZGUpO1xufVxuZnVuY3Rpb24gRW51bVN0cmluZ01lbWJlcihub2RlKSB7XG4gIGVudW1Jbml0aWFsaXplZE1lbWJlcih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIEZsb3dFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgY29uc3QgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICB0aGlzLnByaW50KGRlY2xhcik7XG4gICAgaWYgKCFpc1N0YXRlbWVudChkZWNsYXIpKSB0aGlzLnNlbWljb2xvbigpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgaWYgKG5vZGUuc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuc3BlY2lmaWVycyk7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgfVxuICAgIHRoaXMudG9rZW5DaGFyKDEyNSk7XG4gICAgaWYgKG5vZGUuc291cmNlKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLndvcmQoXCJmcm9tXCIpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy5wcmludChub2RlLnNvdXJjZSk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEV4aXN0c1R5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLnRva2VuQ2hhcig0Mik7XG59XG5mdW5jdGlvbiBGdW5jdGlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIGlmIChub2RlLnRoaXMpIHtcbiAgICB0aGlzLndvcmQoXCJ0aGlzXCIpO1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnRoaXMudHlwZUFubm90YXRpb24pO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggfHwgbm9kZS5yZXN0KSB7XG4gICAgICB0aGlzLnRva2VuQ2hhcig0NCk7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgfVxuICB9XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUucGFyYW1zKTtcbiAgaWYgKG5vZGUucmVzdCkge1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudG9rZW5DaGFyKDQ0KTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgdGhpcy50b2tlbihcIi4uLlwiKTtcbiAgICB0aGlzLnByaW50KG5vZGUucmVzdCk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICBjb25zdCB0eXBlID0gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQudHlwZTtcbiAgaWYgKHR5cGUgIT0gbnVsbCAmJiAodHlwZSA9PT0gXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIgfHwgdHlwZSA9PT0gXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIgfHwgdHlwZSA9PT0gXCJEZWNsYXJlRnVuY3Rpb25cIiB8fCB0eXBlID09PSBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiICYmIHBhcmVudC5tZXRob2QpKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuKFwiPT5cIik7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUucmV0dXJuVHlwZSk7XG59XG5mdW5jdGlvbiBGdW5jdGlvblR5cGVQYXJhbShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgaWYgKG5vZGUubmFtZSkge1xuICAgIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbn1cbmZ1bmN0aW9uIEludGVyZmFjZUV4dGVuZHMobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMsIHRydWUpO1xufVxuZnVuY3Rpb24gX2ludGVyZmFjZWlzaChub2RlKSB7XG4gIHZhciBfbm9kZSRleHRlbmRzO1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBpZiAoKF9ub2RlJGV4dGVuZHMgPSBub2RlLmV4dGVuZHMpICE9IG51bGwgJiYgX25vZGUkZXh0ZW5kcy5sZW5ndGgpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZXh0ZW5kc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludExpc3Qobm9kZS5leHRlbmRzKTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkRlY2xhcmVDbGFzc1wiKSB7XG4gICAgdmFyIF9ub2RlJG1peGlucywgX25vZGUkaW1wbGVtZW50cztcbiAgICBpZiAoKF9ub2RlJG1peGlucyA9IG5vZGUubWl4aW5zKSAhPSBudWxsICYmIF9ub2RlJG1peGlucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMud29yZChcIm1peGluc1wiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnRMaXN0KG5vZGUubWl4aW5zKTtcbiAgICB9XG4gICAgaWYgKChfbm9kZSRpbXBsZW1lbnRzID0gbm9kZS5pbXBsZW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJGltcGxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLndvcmQoXCJpbXBsZW1lbnRzXCIpO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy5wcmludExpc3Qobm9kZS5pbXBsZW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBfdmFyaWFuY2Uobm9kZSkge1xuICB2YXIgX25vZGUkdmFyaWFuY2U7XG4gIGNvbnN0IGtpbmQgPSAoX25vZGUkdmFyaWFuY2UgPSBub2RlLnZhcmlhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkdmFyaWFuY2Uua2luZDtcbiAgaWYgKGtpbmQgIT0gbnVsbCkge1xuICAgIGlmIChraW5kID09PSBcInBsdXNcIikge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDMpO1xuICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gXCJtaW51c1wiKSB7XG4gICAgICB0aGlzLnRva2VuQ2hhcig0NSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChcImludGVyZmFjZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLl9pbnRlcmZhY2Vpc2gobm9kZSk7XG59XG5mdW5jdGlvbiBhbmRTZXBhcmF0b3Iob2NjdXJyZW5jZUNvdW50KSB7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbihcIiZcIiwgZmFsc2UsIG9jY3VycmVuY2VDb3VudCk7XG4gIHRoaXMuc3BhY2UoKTtcbn1cbmZ1bmN0aW9uIEludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGV4dGVuZHMyO1xuICB0aGlzLndvcmQoXCJpbnRlcmZhY2VcIik7XG4gIGlmICgoX25vZGUkZXh0ZW5kczIgPSBub2RlLmV4dGVuZHMpICE9IG51bGwgJiYgX25vZGUkZXh0ZW5kczIubGVuZ3RoKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRMaXN0KG5vZGUuZXh0ZW5kcyk7XG4gIH1cbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYm9keSk7XG59XG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUudHlwZXMsIHtcbiAgICBzZXBhcmF0b3I6IGFuZFNlcGFyYXRvclxuICB9KTtcbn1cbmZ1bmN0aW9uIE1peGVkVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcIm1peGVkXCIpO1xufVxuZnVuY3Rpb24gRW1wdHlUeXBlQW5ub3RhdGlvbigpIHtcbiAgdGhpcy53b3JkKFwiZW1wdHlcIik7XG59XG5mdW5jdGlvbiBOdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNjMpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gTnVtYmVyVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcIm51bWJlclwiKTtcbn1cbmZ1bmN0aW9uIFN0cmluZ1R5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJzdHJpbmdcIik7XG59XG5mdW5jdGlvbiBUaGlzVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInRoaXNcIik7XG59XG5mdW5jdGlvbiBUdXBsZVR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50TGlzdChub2RlLnR5cGVzKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gVHlwZW9mVHlwZUFubm90YXRpb24obm9kZSkge1xuICB0aGlzLndvcmQoXCJ0eXBlb2ZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmFyZ3VtZW50KTtcbn1cbmZ1bmN0aW9uIFR5cGVBbGlhcyhub2RlKSB7XG4gIHRoaXMud29yZChcInR5cGVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnJpZ2h0KTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIFR5cGVBbm5vdGF0aW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Rmxvd1JldHVyblR5cGU7XG4gIH0gZWxzZSBpZiAobm9kZS5vcHRpb25hbCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUucGFyYW1zLCB7fSk7XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cbmZ1bmN0aW9uIFR5cGVQYXJhbWV0ZXIobm9kZSkge1xuICB0aGlzLl92YXJpYW5jZShub2RlKTtcbiAgdGhpcy53b3JkKG5vZGUubmFtZSk7XG4gIGlmIChub2RlLmJvdW5kKSB7XG4gICAgdGhpcy5wcmludChub2RlLmJvdW5kKTtcbiAgfVxuICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmRlZmF1bHQpO1xuICB9XG59XG5mdW5jdGlvbiBPcGFxdWVUeXBlKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwib3BhcXVlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcInR5cGVcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgaWYgKG5vZGUuc3VwZXJ0eXBlKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUuc3VwZXJ0eXBlKTtcbiAgfVxuICBpZiAobm9kZS5pbXBsdHlwZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5pbXBsdHlwZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIE9iamVjdFR5cGVBbm5vdGF0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUuZXhhY3QpIHtcbiAgICB0aGlzLnRva2VuKFwie3xcIik7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgfVxuICBjb25zdCBwcm9wcyA9IFsuLi5ub2RlLnByb3BlcnRpZXMsIC4uLihub2RlLmNhbGxQcm9wZXJ0aWVzIHx8IFtdKSwgLi4uKG5vZGUuaW5kZXhlcnMgfHwgW10pLCAuLi4obm9kZS5pbnRlcm5hbFNsb3RzIHx8IFtdKV07XG4gIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludEpvaW4ocHJvcHMsIHtcbiAgICAgIGFkZE5ld2xpbmVzKGxlYWRpbmcpIHtcbiAgICAgICAgaWYgKGxlYWRpbmcgJiYgIXByb3BzWzBdKSByZXR1cm4gMTtcbiAgICAgIH0sXG4gICAgICBpbmRlbnQ6IHRydWUsXG4gICAgICBzdGF0ZW1lbnQ6IHRydWUsXG4gICAgICBpdGVyYXRvcjogKCkgPT4ge1xuICAgICAgICBpZiAocHJvcHMubGVuZ3RoICE9PSAxIHx8IG5vZGUuaW5leGFjdCkge1xuICAgICAgICAgIHRoaXMudG9rZW5DaGFyKDQ0KTtcbiAgICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKG5vZGUuaW5leGFjdCkge1xuICAgIHRoaXMuaW5kZW50KCk7XG4gICAgdGhpcy50b2tlbihcIi4uLlwiKTtcbiAgICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB9XG4gICAgdGhpcy5kZWRlbnQoKTtcbiAgfVxuICBpZiAobm9kZS5leGFjdCkge1xuICAgIHRoaXMudG9rZW4oXCJ8fVwiKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjUpO1xuICB9XG59XG5mdW5jdGlvbiBPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUpIHtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIGlmICghbm9kZS5tZXRob2QpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG59XG5mdW5jdGlvbiBPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUpIHtcbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xufVxuZnVuY3Rpb24gT2JqZWN0VHlwZUluZGV4ZXIobm9kZSkge1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICB0aGlzLndvcmQoXCJzdGF0aWNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX3ZhcmlhbmNlKG5vZGUpO1xuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIGlmIChub2RlLmlkKSB7XG4gICAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xufVxuZnVuY3Rpb24gT2JqZWN0VHlwZVByb3BlcnR5KG5vZGUpIHtcbiAgaWYgKG5vZGUucHJvdG8pIHtcbiAgICB0aGlzLndvcmQoXCJwcm90b1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKG5vZGUuc3RhdGljKSB7XG4gICAgdGhpcy53b3JkKFwic3RhdGljXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIikge1xuICAgIHRoaXMud29yZChub2RlLmtpbmQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLl92YXJpYW5jZShub2RlKTtcbiAgdGhpcy5wcmludChub2RlLmtleSk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIGlmICghbm9kZS5tZXRob2QpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG59XG5mdW5jdGlvbiBPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkobm9kZSkge1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQpO1xufVxuZnVuY3Rpb24gUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUucXVhbGlmaWNhdGlvbik7XG4gIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbn1cbmZ1bmN0aW9uIFN5bWJvbFR5cGVBbm5vdGF0aW9uKCkge1xuICB0aGlzLndvcmQoXCJzeW1ib2xcIik7XG59XG5mdW5jdGlvbiBvclNlcGFyYXRvcihvY2N1cnJlbmNlQ291bnQpIHtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwifFwiLCBmYWxzZSwgb2NjdXJyZW5jZUNvdW50KTtcbiAgdGhpcy5zcGFjZSgpO1xufVxuZnVuY3Rpb24gVW5pb25UeXBlQW5ub3RhdGlvbihub2RlKSB7XG4gIHRoaXMucHJpbnRKb2luKG5vZGUudHlwZXMsIHtcbiAgICBzZXBhcmF0b3I6IG9yU2VwYXJhdG9yXG4gIH0pO1xufVxuZnVuY3Rpb24gVHlwZUNhc3RFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbn1cbmZ1bmN0aW9uIFZhcmlhbmNlKG5vZGUpIHtcbiAgaWYgKG5vZGUua2luZCA9PT0gXCJwbHVzXCIpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig0Myk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDUpO1xuICB9XG59XG5mdW5jdGlvbiBWb2lkVHlwZUFubm90YXRpb24oKSB7XG4gIHRoaXMud29yZChcInZvaWRcIik7XG59XG5mdW5jdGlvbiBJbmRleGVkQWNjZXNzVHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3RUeXBlLCB0cnVlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50KG5vZGUuaW5kZXhUeXBlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3RUeXBlKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuKFwiPy5cIik7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50KG5vZGUuaW5kZXhUeXBlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1mbG93LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72259\n')},66735:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar _templateLiterals = __webpack_require__(12226);\nObject.keys(_templateLiterals).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _templateLiterals[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _templateLiterals[key];\n    }\n  });\n});\nvar _expressions = __webpack_require__(34436);\nObject.keys(_expressions).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _expressions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _expressions[key];\n    }\n  });\n});\nvar _statements = __webpack_require__(70521);\nObject.keys(_statements).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _statements[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _statements[key];\n    }\n  });\n});\nvar _classes = __webpack_require__(76271);\nObject.keys(_classes).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _classes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _classes[key];\n    }\n  });\n});\nvar _methods = __webpack_require__(2861);\nObject.keys(_methods).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _methods[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _methods[key];\n    }\n  });\n});\nvar _modules = __webpack_require__(89638);\nObject.keys(_modules).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _modules[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _modules[key];\n    }\n  });\n});\nvar _types = __webpack_require__(7942);\nObject.keys(_types).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\nvar _flow = __webpack_require__(72259);\nObject.keys(_flow).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _flow[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _flow[key];\n    }\n  });\n});\nvar _base = __webpack_require__(90546);\nObject.keys(_base).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _base[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _base[key];\n    }\n  });\n});\nvar _jsx = __webpack_require__(73962);\nObject.keys(_jsx).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _jsx[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _jsx[key];\n    }\n  });\n});\nvar _typescript = __webpack_require__(9276);\nObject.keys(_typescript).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (key in exports && exports[key] === _typescript[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _typescript[key];\n    }\n  });\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY3MzUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCLG1CQUFPLENBQUMsS0FBd0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsS0FBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsa0JBQWtCLG1CQUFPLENBQUMsS0FBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsZUFBZSxtQkFBTyxDQUFDLElBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsYUFBYSxtQkFBTyxDQUFDLElBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWSxtQkFBTyxDQUFDLEtBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWSxtQkFBTyxDQUFDLEtBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsV0FBVyxtQkFBTyxDQUFDLEtBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Qsa0JBQWtCLG1CQUFPLENBQUMsSUFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL2luZGV4LmpzPzU1ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgX3RlbXBsYXRlTGl0ZXJhbHMgPSByZXF1aXJlKFwiLi90ZW1wbGF0ZS1saXRlcmFscy5qc1wiKTtcbk9iamVjdC5rZXlzKF90ZW1wbGF0ZUxpdGVyYWxzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdGVtcGxhdGVMaXRlcmFsc1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90ZW1wbGF0ZUxpdGVyYWxzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9leHByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zLmpzXCIpO1xuT2JqZWN0LmtleXMoX2V4cHJlc3Npb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZXhwcmVzc2lvbnNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZXhwcmVzc2lvbnNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3N0YXRlbWVudHMgPSByZXF1aXJlKFwiLi9zdGF0ZW1lbnRzLmpzXCIpO1xuT2JqZWN0LmtleXMoX3N0YXRlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9zdGF0ZW1lbnRzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N0YXRlbWVudHNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2NsYXNzZXMgPSByZXF1aXJlKFwiLi9jbGFzc2VzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2NsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9jbGFzc2VzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2NsYXNzZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX21ldGhvZHMgPSByZXF1aXJlKFwiLi9tZXRob2RzLmpzXCIpO1xuT2JqZWN0LmtleXMoX21ldGhvZHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9tZXRob2RzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX21ldGhvZHNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX21vZHVsZXMgPSByZXF1aXJlKFwiLi9tb2R1bGVzLmpzXCIpO1xuT2JqZWN0LmtleXMoX21vZHVsZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9tb2R1bGVzW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX21vZHVsZXNba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXMuanNcIik7XG5PYmplY3Qua2V5cyhfdHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc1trZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90eXBlc1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZmxvdyA9IHJlcXVpcmUoXCIuL2Zsb3cuanNcIik7XG5PYmplY3Qua2V5cyhfZmxvdykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Zsb3dba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfZmxvd1trZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfYmFzZSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG5PYmplY3Qua2V5cyhfYmFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Jhc2Vba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfYmFzZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfanN4ID0gcmVxdWlyZShcIi4vanN4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2pzeCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2pzeFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9qc3hba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3R5cGVzY3JpcHQgPSByZXF1aXJlKFwiLi90eXBlc2NyaXB0LmpzXCIpO1xuT2JqZWN0LmtleXMoX3R5cGVzY3JpcHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90eXBlc2NyaXB0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3R5cGVzY3JpcHRba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///66735\n')},73962:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.JSXAttribute = JSXAttribute;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXClosingFragment = JSXClosingFragment;\nexports.JSXElement = JSXElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXFragment = JSXFragment;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXOpeningFragment = JSXOpeningFragment;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXSpreadChild = JSXSpreadChild;\nexports.JSXText = JSXText;\nfunction JSXAttribute(node) {\n  this.print(node.name);\n  if (node.value) {\n    this.tokenChar(61);\n    this.print(node.value);\n  }\n}\nfunction JSXIdentifier(node) {\n  this.word(node.name);\n}\nfunction JSXNamespacedName(node) {\n  this.print(node.namespace);\n  this.tokenChar(58);\n  this.print(node.name);\n}\nfunction JSXMemberExpression(node) {\n  this.print(node.object);\n  this.tokenChar(46);\n  this.print(node.property);\n}\nfunction JSXSpreadAttribute(node) {\n  this.tokenChar(123);\n  this.token("...");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\nfunction JSXExpressionContainer(node) {\n  this.tokenChar(123);\n  this.print(node.expression);\n  this.rightBrace(node);\n}\nfunction JSXSpreadChild(node) {\n  this.tokenChar(123);\n  this.token("...");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\nfunction JSXText(node) {\n  const raw = this.getPossibleRaw(node);\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\nfunction JSXElement(node) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n  this.print(node.closingElement);\n}\nfunction spaceSeparator() {\n  this.space();\n}\nfunction JSXOpeningElement(node) {\n  this.tokenChar(60);\n  this.print(node.name);\n  this.print(node.typeParameters);\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, {\n      separator: spaceSeparator\n    });\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.tokenChar(47);\n  }\n  this.tokenChar(62);\n}\nfunction JSXClosingElement(node) {\n  this.tokenChar(60);\n  this.tokenChar(47);\n  this.print(node.name);\n  this.tokenChar(62);\n}\nfunction JSXEmptyExpression() {\n  this.printInnerComments();\n}\nfunction JSXFragment(node) {\n  this.print(node.openingFragment);\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n  this.print(node.closingFragment);\n}\nfunction JSXOpeningFragment() {\n  this.tokenChar(60);\n  this.tokenChar(62);\n}\nfunction JSXClosingFragment() {\n  this.token("</");\n  this.tokenChar(62);\n}\n\n//# sourceMappingURL=jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM5NjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsa0JBQWtCO0FBQ2xCLDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvanN4LmpzP2UyNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkpTWEF0dHJpYnV0ZSA9IEpTWEF0dHJpYnV0ZTtcbmV4cG9ydHMuSlNYQ2xvc2luZ0VsZW1lbnQgPSBKU1hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMuSlNYQ2xvc2luZ0ZyYWdtZW50ID0gSlNYQ2xvc2luZ0ZyYWdtZW50O1xuZXhwb3J0cy5KU1hFbGVtZW50ID0gSlNYRWxlbWVudDtcbmV4cG9ydHMuSlNYRW1wdHlFeHByZXNzaW9uID0gSlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5KU1hFeHByZXNzaW9uQ29udGFpbmVyID0gSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbmV4cG9ydHMuSlNYRnJhZ21lbnQgPSBKU1hGcmFnbWVudDtcbmV4cG9ydHMuSlNYSWRlbnRpZmllciA9IEpTWElkZW50aWZpZXI7XG5leHBvcnRzLkpTWE1lbWJlckV4cHJlc3Npb24gPSBKU1hNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5KU1hOYW1lc3BhY2VkTmFtZSA9IEpTWE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5KU1hPcGVuaW5nRWxlbWVudCA9IEpTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5KU1hPcGVuaW5nRnJhZ21lbnQgPSBKU1hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLkpTWFNwcmVhZEF0dHJpYnV0ZSA9IEpTWFNwcmVhZEF0dHJpYnV0ZTtcbmV4cG9ydHMuSlNYU3ByZWFkQ2hpbGQgPSBKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuSlNYVGV4dCA9IEpTWFRleHQ7XG5mdW5jdGlvbiBKU1hBdHRyaWJ1dGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG4gIGlmIChub2RlLnZhbHVlKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNjEpO1xuICAgIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIEpTWElkZW50aWZpZXIobm9kZSkge1xuICB0aGlzLndvcmQobm9kZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIEpTWE5hbWVzcGFjZWROYW1lKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm5hbWVzcGFjZSk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5wcmludChub2RlLm5hbWUpO1xufVxuZnVuY3Rpb24gSlNYTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICB0aGlzLnRva2VuQ2hhcig0Nik7XG4gIHRoaXMucHJpbnQobm9kZS5wcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBKU1hTcHJlYWRBdHRyaWJ1dGUobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQpO1xuICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG59XG5mdW5jdGlvbiBKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG59XG5mdW5jdGlvbiBKU1hTcHJlYWRDaGlsZChub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gIHRoaXMudG9rZW4oXCIuLi5cIik7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5yaWdodEJyYWNlKG5vZGUpO1xufVxuZnVuY3Rpb24gSlNYVGV4dChub2RlKSB7XG4gIGNvbnN0IHJhdyA9IHRoaXMuZ2V0UG9zc2libGVSYXcobm9kZSk7XG4gIGlmIChyYXcgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMudG9rZW4ocmF3LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRva2VuKG5vZGUudmFsdWUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBKU1hFbGVtZW50KG5vZGUpIHtcbiAgY29uc3Qgb3BlbiA9IG5vZGUub3BlbmluZ0VsZW1lbnQ7XG4gIHRoaXMucHJpbnQob3Blbik7XG4gIGlmIChvcGVuLnNlbGZDbG9zaW5nKSByZXR1cm47XG4gIHRoaXMuaW5kZW50KCk7XG4gIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgIHRoaXMucHJpbnQoY2hpbGQpO1xuICB9XG4gIHRoaXMuZGVkZW50KCk7XG4gIHRoaXMucHJpbnQobm9kZS5jbG9zaW5nRWxlbWVudCk7XG59XG5mdW5jdGlvbiBzcGFjZVNlcGFyYXRvcigpIHtcbiAgdGhpcy5zcGFjZSgpO1xufVxuZnVuY3Rpb24gSlNYT3BlbmluZ0VsZW1lbnQobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIHRoaXMucHJpbnQobm9kZS5uYW1lKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbiAgaWYgKG5vZGUuYXR0cmlidXRlcy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnRKb2luKG5vZGUuYXR0cmlidXRlcywge1xuICAgICAgc2VwYXJhdG9yOiBzcGFjZVNlcGFyYXRvclxuICAgIH0pO1xuICB9XG4gIGlmIChub2RlLnNlbGZDbG9zaW5nKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDQ3KTtcbiAgfVxuICB0aGlzLnRva2VuQ2hhcig2Mik7XG59XG5mdW5jdGlvbiBKU1hDbG9zaW5nRWxlbWVudChub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDYwKTtcbiAgdGhpcy50b2tlbkNoYXIoNDcpO1xuICB0aGlzLnByaW50KG5vZGUubmFtZSk7XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cbmZ1bmN0aW9uIEpTWEVtcHR5RXhwcmVzc2lvbigpIHtcbiAgdGhpcy5wcmludElubmVyQ29tbWVudHMoKTtcbn1cbmZ1bmN0aW9uIEpTWEZyYWdtZW50KG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLm9wZW5pbmdGcmFnbWVudCk7XG4gIHRoaXMuaW5kZW50KCk7XG4gIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5jaGlsZHJlbikge1xuICAgIHRoaXMucHJpbnQoY2hpbGQpO1xuICB9XG4gIHRoaXMuZGVkZW50KCk7XG4gIHRoaXMucHJpbnQobm9kZS5jbG9zaW5nRnJhZ21lbnQpO1xufVxuZnVuY3Rpb24gSlNYT3BlbmluZ0ZyYWdtZW50KCkge1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIHRoaXMudG9rZW5DaGFyKDYyKTtcbn1cbmZ1bmN0aW9uIEpTWENsb3NpbmdGcmFnbWVudCgpIHtcbiAgdGhpcy50b2tlbihcIjwvXCIpO1xuICB0aGlzLnRva2VuQ2hhcig2Mik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzeC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73962\n')},2861:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.FunctionDeclaration = exports.FunctionExpression = FunctionExpression;\nexports._functionHead = _functionHead;\nexports._methodHead = _methodHead;\nexports._param = _param;\nexports._parameters = _parameters;\nexports._params = _params;\nexports._predicate = _predicate;\nexports._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;\nvar _t = __webpack_require__(2352);\nvar _index = __webpack_require__(31373);\nconst {\n  isIdentifier\n} = _t;\nfunction _params(node, idNode, parentNode) {\n  this.print(node.typeParameters);\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n  this.tokenChar(40);\n  this._parameters(node.params, ")");\n  const noLineTerminator = node.type === "ArrowFunctionExpression";\n  this.print(node.returnType, noLineTerminator);\n  this._noLineTerminator = noLineTerminator;\n}\nfunction _parameters(parameters, endToken) {\n  const exit = this.enterDelimited();\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n    if (trailingComma || i < paramLength - 1) {\n      this.token(",", null, i);\n      this.space();\n    }\n  }\n  this.token(endToken);\n  exit();\n}\nfunction _param(parameter) {\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (parameter.optional) {\n    this.tokenChar(63);\n  }\n  this.print(parameter.typeAnnotation);\n}\nfunction _methodHead(node) {\n  const kind = node.kind;\n  const key = node.key;\n  if (kind === "get" || kind === "set") {\n    this.word(kind);\n    this.space();\n  }\n  if (node.async) {\n    this.word("async", true);\n    this.space();\n  }\n  if (kind === "method" || kind === "init") {\n    if (node.generator) {\n      this.tokenChar(42);\n    }\n  }\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(key);\n    this.tokenChar(93);\n  } else {\n    this.print(key);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n  this._params(node, node.computed && node.key.type !== "StringLiteral" ? undefined : node.key, undefined);\n}\nfunction _predicate(node, noLineTerminatorAfter) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.tokenChar(58);\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\nfunction _functionHead(node, parent) {\n  if (node.async) {\n    this.word("async");\n    if (!this.format.preserveFormat) {\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word("function");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      this._endsWithInnerRaw = false;\n    }\n    this.tokenChar(42);\n  }\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n  this._params(node, node.id, parent);\n  if (node.type !== "TSDeclareFunction") {\n    this._predicate(node);\n  }\n}\nfunction FunctionExpression(node, parent) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\nfunction ArrowFunctionExpression(node, parent) {\n  if (node.async) {\n    this.word("async", true);\n    this.space();\n  }\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n  this._predicate(node, true);\n  this.space();\n  this.printInnerComments();\n  this.token("=>");\n  this.space();\n  this.tokenContext |= _index.TokenContext.arrowBody;\n  this.print(node.body);\n}\nfunction _shouldPrintArrowParamsParens(node) {\n  var _firstParam$leadingCo, _firstParam$trailingC;\n  if (node.params.length !== 1) return true;\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n  const firstParam = node.params[0];\n  if (!isIdentifier(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {\n    return true;\n  }\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, "(") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, "=>");\n    if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n  if (this.format.retainLines) return true;\n  return false;\n}\nfunction _getFuncIdName(idNode, parent) {\n  let id = idNode;\n  if (!id && parent) {\n    const parentType = parent.type;\n    if (parentType === "VariableDeclarator") {\n      id = parent.id;\n    } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {\n      id = parent.left;\n    } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {\n      if (!parent.computed || parent.key.type === "StringLiteral") {\n        id = parent.key;\n      }\n    } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {\n      id = parent.key;\n    }\n  }\n  if (!id) return;\n  let nameInfo;\n  if (id.type === "Identifier") {\n    var _id$loc, _id$loc2;\n    nameInfo = {\n      pos: (_id$loc = id.loc) == null ? void 0 : _id$loc.start,\n      name: ((_id$loc2 = id.loc) == null ? void 0 : _id$loc2.identifierName) || id.name\n    };\n  } else if (id.type === "PrivateName") {\n    var _id$loc3;\n    nameInfo = {\n      pos: (_id$loc3 = id.loc) == null ? void 0 : _id$loc3.start,\n      name: "#" + id.id.name\n    };\n  } else if (id.type === "StringLiteral") {\n    var _id$loc4;\n    nameInfo = {\n      pos: (_id$loc4 = id.loc) == null ? void 0 : _id$loc4.start,\n      name: id.value\n    };\n  }\n  return nameInfo;\n}\n\n//# sourceMappingURL=methods.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg2MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQkFBK0I7QUFDL0IsMkJBQTJCLEdBQUcsMEJBQTBCO0FBQ3hELHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLHFDQUFxQztBQUNyQyxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixhQUFhLG1CQUFPLENBQUMsS0FBa0I7QUFDdkM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tZXRob2RzLmpzP2E5NDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuX2Z1bmN0aW9uSGVhZCA9IF9mdW5jdGlvbkhlYWQ7XG5leHBvcnRzLl9tZXRob2RIZWFkID0gX21ldGhvZEhlYWQ7XG5leHBvcnRzLl9wYXJhbSA9IF9wYXJhbTtcbmV4cG9ydHMuX3BhcmFtZXRlcnMgPSBfcGFyYW1ldGVycztcbmV4cG9ydHMuX3BhcmFtcyA9IF9wYXJhbXM7XG5leHBvcnRzLl9wcmVkaWNhdGUgPSBfcHJlZGljYXRlO1xuZXhwb3J0cy5fc2hvdWxkUHJpbnRBcnJvd1BhcmFtc1BhcmVucyA9IF9zaG91bGRQcmludEFycm93UGFyYW1zUGFyZW5zO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vbm9kZS9pbmRleC5qc1wiKTtcbmNvbnN0IHtcbiAgaXNJZGVudGlmaWVyXG59ID0gX3Q7XG5mdW5jdGlvbiBfcGFyYW1zKG5vZGUsIGlkTm9kZSwgcGFyZW50Tm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICBjb25zdCBuYW1lSW5mbyA9IF9nZXRGdW5jSWROYW1lLmNhbGwodGhpcywgaWROb2RlLCBwYXJlbnROb2RlKTtcbiAgaWYgKG5hbWVJbmZvKSB7XG4gICAgdGhpcy5zb3VyY2VJZGVudGlmaWVyTmFtZShuYW1lSW5mby5uYW1lLCBuYW1lSW5mby5wb3MpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5fcGFyYW1ldGVycyhub2RlLnBhcmFtcywgXCIpXCIpO1xuICBjb25zdCBub0xpbmVUZXJtaW5hdG9yID0gbm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gIHRoaXMucHJpbnQobm9kZS5yZXR1cm5UeXBlLCBub0xpbmVUZXJtaW5hdG9yKTtcbiAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IG5vTGluZVRlcm1pbmF0b3I7XG59XG5mdW5jdGlvbiBfcGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBlbmRUb2tlbikge1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICBjb25zdCB0cmFpbGluZ0NvbW1hID0gdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoZW5kVG9rZW4pO1xuICBjb25zdCBwYXJhbUxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtTGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLl9wYXJhbShwYXJhbWV0ZXJzW2ldKTtcbiAgICBpZiAodHJhaWxpbmdDb21tYSB8fCBpIDwgcGFyYW1MZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLnRva2VuKFwiLFwiLCBudWxsLCBpKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b2tlbihlbmRUb2tlbik7XG4gIGV4aXQoKTtcbn1cbmZ1bmN0aW9uIF9wYXJhbShwYXJhbWV0ZXIpIHtcbiAgdGhpcy5wcmludEpvaW4ocGFyYW1ldGVyLmRlY29yYXRvcnMpO1xuICB0aGlzLnByaW50KHBhcmFtZXRlcik7XG4gIGlmIChwYXJhbWV0ZXIub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbiAgdGhpcy5wcmludChwYXJhbWV0ZXIudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gX21ldGhvZEhlYWQobm9kZSkge1xuICBjb25zdCBraW5kID0gbm9kZS5raW5kO1xuICBjb25zdCBrZXkgPSBub2RlLmtleTtcbiAgaWYgKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIikge1xuICAgIHRoaXMud29yZChraW5kKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKG5vZGUuYXN5bmMpIHtcbiAgICB0aGlzLndvcmQoXCJhc3luY1wiLCB0cnVlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKGtpbmQgPT09IFwibWV0aG9kXCIgfHwga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICAgIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gICAgdGhpcy5wcmludChrZXkpO1xuICAgIHRoaXMudG9rZW5DaGFyKDkzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KGtleSk7XG4gIH1cbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbiAgdGhpcy5fcGFyYW1zKG5vZGUsIG5vZGUuY29tcHV0ZWQgJiYgbm9kZS5rZXkudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgPyB1bmRlZmluZWQgOiBub2RlLmtleSwgdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIF9wcmVkaWNhdGUobm9kZSwgbm9MaW5lVGVybWluYXRvckFmdGVyKSB7XG4gIGlmIChub2RlLnByZWRpY2F0ZSkge1xuICAgIGlmICghbm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gICAgfVxuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUucHJlZGljYXRlLCBub0xpbmVUZXJtaW5hdG9yQWZ0ZXIpO1xuICB9XG59XG5mdW5jdGlvbiBfZnVuY3Rpb25IZWFkKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIpO1xuICAgIGlmICghdGhpcy5mb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICAgIHRoaXMuX2VuZHNXaXRoSW5uZXJSYXcgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImZ1bmN0aW9uXCIpO1xuICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICBpZiAoIXRoaXMuZm9ybWF0LnByZXNlcnZlRm9ybWF0KSB7XG4gICAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLmlkKSB7XG4gICAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgfVxuICB0aGlzLl9wYXJhbXMobm9kZSwgbm9kZS5pZCwgcGFyZW50KTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiKSB7XG4gICAgdGhpcy5fcHJlZGljYXRlKG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIHRoaXMuX2Z1bmN0aW9uSGVhZChub2RlLCBwYXJlbnQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAobm9kZS5hc3luYykge1xuICAgIHRoaXMud29yZChcImFzeW5jXCIsIHRydWUpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAodGhpcy5fc2hvdWxkUHJpbnRBcnJvd1BhcmFtc1BhcmVucyhub2RlKSkge1xuICAgIHRoaXMuX3BhcmFtcyhub2RlLCB1bmRlZmluZWQsIHBhcmVudCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludChub2RlLnBhcmFtc1swXSwgdHJ1ZSk7XG4gIH1cbiAgdGhpcy5fcHJlZGljYXRlKG5vZGUsIHRydWUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnRJbm5lckNvbW1lbnRzKCk7XG4gIHRoaXMudG9rZW4oXCI9PlwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Qm9keTtcbiAgdGhpcy5wcmludChub2RlLmJvZHkpO1xufVxuZnVuY3Rpb24gX3Nob3VsZFByaW50QXJyb3dQYXJhbXNQYXJlbnMobm9kZSkge1xuICB2YXIgX2ZpcnN0UGFyYW0kbGVhZGluZ0NvLCBfZmlyc3RQYXJhbSR0cmFpbGluZ0M7XG4gIGlmIChub2RlLnBhcmFtcy5sZW5ndGggIT09IDEpIHJldHVybiB0cnVlO1xuICBpZiAobm9kZS50eXBlUGFyYW1ldGVycyB8fCBub2RlLnJldHVyblR5cGUgfHwgbm9kZS5wcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBmaXJzdFBhcmFtID0gbm9kZS5wYXJhbXNbMF07XG4gIGlmICghaXNJZGVudGlmaWVyKGZpcnN0UGFyYW0pIHx8IGZpcnN0UGFyYW0udHlwZUFubm90YXRpb24gfHwgZmlyc3RQYXJhbS5vcHRpb25hbCB8fCAoX2ZpcnN0UGFyYW0kbGVhZGluZ0NvID0gZmlyc3RQYXJhbS5sZWFkaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX2ZpcnN0UGFyYW0kbGVhZGluZ0NvLmxlbmd0aCB8fCAoX2ZpcnN0UGFyYW0kdHJhaWxpbmdDID0gZmlyc3RQYXJhbS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9maXJzdFBhcmFtJHRyYWlsaW5nQy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgIGlmIChub2RlLmxvYyA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy50b2tlbk1hcC5maW5kTWF0Y2hpbmcobm9kZSwgXCIoXCIpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBhcnJvd1Rva2VuID0gdGhpcy50b2tlbk1hcC5maW5kTWF0Y2hpbmcobm9kZSwgXCI9PlwiKTtcbiAgICBpZiAoKGFycm93VG9rZW4gPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93VG9rZW4ubG9jKSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gYXJyb3dUb2tlbi5sb2Muc3RhcnQubGluZSAhPT0gbm9kZS5sb2Muc3RhcnQubGluZTtcbiAgfVxuICBpZiAodGhpcy5mb3JtYXQucmV0YWluTGluZXMpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfZ2V0RnVuY0lkTmFtZShpZE5vZGUsIHBhcmVudCkge1xuICBsZXQgaWQgPSBpZE5vZGU7XG4gIGlmICghaWQgJiYgcGFyZW50KSB7XG4gICAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICAgIGlmIChwYXJlbnRUeXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSB7XG4gICAgICBpZCA9IHBhcmVudC5pZDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudFR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIGlkID0gcGFyZW50LmxlZnQ7XG4gICAgfSBlbHNlIGlmIChwYXJlbnRUeXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgfHwgcGFyZW50VHlwZSA9PT0gXCJDbGFzc1Byb3BlcnR5XCIpIHtcbiAgICAgIGlmICghcGFyZW50LmNvbXB1dGVkIHx8IHBhcmVudC5rZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIpIHtcbiAgICAgICAgaWQgPSBwYXJlbnQua2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW50VHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiIHx8IHBhcmVudFR5cGUgPT09IFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIpIHtcbiAgICAgIGlkID0gcGFyZW50LmtleTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpZCkgcmV0dXJuO1xuICBsZXQgbmFtZUluZm87XG4gIGlmIChpZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHZhciBfaWQkbG9jLCBfaWQkbG9jMjtcbiAgICBuYW1lSW5mbyA9IHtcbiAgICAgIHBvczogKF9pZCRsb2MgPSBpZC5sb2MpID09IG51bGwgPyB2b2lkIDAgOiBfaWQkbG9jLnN0YXJ0LFxuICAgICAgbmFtZTogKChfaWQkbG9jMiA9IGlkLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pZCRsb2MyLmlkZW50aWZpZXJOYW1lKSB8fCBpZC5uYW1lXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpZC50eXBlID09PSBcIlByaXZhdGVOYW1lXCIpIHtcbiAgICB2YXIgX2lkJGxvYzM7XG4gICAgbmFtZUluZm8gPSB7XG4gICAgICBwb3M6IChfaWQkbG9jMyA9IGlkLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9pZCRsb2MzLnN0YXJ0LFxuICAgICAgbmFtZTogXCIjXCIgKyBpZC5pZC5uYW1lXG4gICAgfTtcbiAgfSBlbHNlIGlmIChpZC50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIikge1xuICAgIHZhciBfaWQkbG9jNDtcbiAgICBuYW1lSW5mbyA9IHtcbiAgICAgIHBvczogKF9pZCRsb2M0ID0gaWQubG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2lkJGxvYzQuc3RhcnQsXG4gICAgICBuYW1lOiBpZC52YWx1ZVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG5hbWVJbmZvO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRob2RzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2861\n')},89638:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportExpression = ImportExpression;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAttributes = _printAttributes;\nvar _t = __webpack_require__(2352);\nvar _index = __webpack_require__(31373);\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\nfunction ImportSpecifier(node) {\n  if (node.importKind === "type" || node.importKind === "typeof") {\n    this.word(node.importKind);\n    this.space();\n  }\n  this.print(node.imported);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(node.local);\n  }\n}\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local);\n}\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported);\n}\nfunction ExportSpecifier(node) {\n  if (node.exportKind === "type") {\n    this.word("type");\n    this.space();\n  }\n  this.print(node.local);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(node.exported);\n  }\n}\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word("as");\n  this.space();\n  this.print(node.exported);\n}\nlet warningShown = false;\nfunction _printAttributes(node, hasPreviousBrace) {\n  const {\n    importAttributesKeyword\n  } = this.format;\n  const {\n    attributes,\n    assertions\n  } = node;\n  if (attributes && !importAttributesKeyword && !warningShown) {\n    warningShown = true;\n    console.warn(`\\\nYou are using import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose value can be one of:\n - "with"        : \\`import { a } from "b" with { type: "json" };\\`\n - "assert"      : \\`import { a } from "b" assert { type: "json" };\\`\n - "with-legacy" : \\`import { a } from "b" with type: "json";\\`\n`);\n  }\n  const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;\n  this.word(useAssertKeyword ? "assert" : "with");\n  this.space();\n  if (!useAssertKeyword && importAttributesKeyword !== "with") {\n    this.printList(attributes || assertions);\n    return;\n  }\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n  this.token("{", null, occurrenceCount);\n  this.space();\n  this.printList(attributes || assertions, {\n    printTrailingSeparator: this.shouldPrintTrailingComma("}")\n  });\n  this.space();\n  this.token("}", null, occurrenceCount);\n}\nfunction ExportAllDeclaration(node) {\n  var _node$attributes, _node$assertions;\n  this.word("export");\n  this.space();\n  if (node.exportKind === "type") {\n    this.word("type");\n    this.space();\n  }\n  this.tokenChar(42);\n  this.space();\n  this.word("from");\n  this.space();\n  if ((_node$attributes = node.attributes) != null && _node$attributes.length || (_node$assertions = node.assertions) != null && _node$assertions.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n  this.semicolon();\n}\nfunction maybePrintDecoratorsBeforeExport(printer, node) {\n  if (isClassDeclaration(node.declaration) && printer._shouldPrintDecoratorsBeforeExport(node)) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\nfunction ExportNamedDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word("export");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === "type") {\n      this.word("type");\n      this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n    let hasBrace = false;\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      hasBrace = true;\n      this.tokenChar(123);\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, {\n          printTrailingSeparator: this.shouldPrintTrailingComma("}")\n        });\n        this.space();\n      }\n      this.tokenChar(125);\n    }\n    if (node.source) {\n      var _node$attributes2, _node$assertions2;\n      this.space();\n      this.word("from");\n      this.space();\n      if ((_node$attributes2 = node.attributes) != null && _node$attributes2.length || (_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n    this.semicolon();\n  }\n}\nfunction ExportDefaultDeclaration(node) {\n  maybePrintDecoratorsBeforeExport(this, node);\n  this.word("export");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word("default");\n  this.space();\n  this.tokenContext |= _index.TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n  var _node$attributes3, _node$assertions3;\n  this.word("import");\n  this.space();\n  const isTypeKind = node.importKind === "type" || node.importKind === "typeof";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word("module");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, {\n      printTrailingSeparator: this.shouldPrintTrailingComma("}")\n    });\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word("from");\n    this.space();\n  }\n  if ((_node$attributes3 = node.attributes) != null && _node$attributes3.length || (_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n  this.semicolon();\n}\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word("as");\n  this.space();\n  this.print(node.local);\n}\nfunction ImportExpression(node) {\n  this.word("import");\n  if (node.phase) {\n    this.tokenChar(46);\n    this.word(node.phase);\n  }\n  this.tokenChar(40);\n  this.print(node.source);\n  if (node.options != null) {\n    this.tokenChar(44);\n    this.space();\n    this.print(node.options);\n  }\n  this.tokenChar(41);\n}\n\n//# sourceMappingURL=modules.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk2MzguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQyxLQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixJQUFJLGdCQUFnQixlQUFlO0FBQ2pFLDhCQUE4QixJQUFJLGtCQUFrQixlQUFlO0FBQ25FLDhCQUE4QixJQUFJLDJCQUEyQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsNERBQTREO0FBQzVELEdBQUc7QUFDSDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvZ2VuZXJhdG9ycy9tb2R1bGVzLmpzP2E4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkV4cG9ydEFsbERlY2xhcmF0aW9uID0gRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLkV4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IEV4cG9ydERlZmF1bHREZWNsYXJhdGlvbjtcbmV4cG9ydHMuRXhwb3J0RGVmYXVsdFNwZWNpZmllciA9IEV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydE5hbWVkRGVjbGFyYXRpb24gPSBFeHBvcnROYW1lZERlY2xhcmF0aW9uO1xuZXhwb3J0cy5FeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLkV4cG9ydFNwZWNpZmllciA9IEV4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0QXR0cmlidXRlID0gSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5JbXBvcnREZWNsYXJhdGlvbiA9IEltcG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5JbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gSW1wb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0RXhwcmVzc2lvbiA9IEltcG9ydEV4cHJlc3Npb247XG5leHBvcnRzLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IEltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuSW1wb3J0U3BlY2lmaWVyID0gSW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5fcHJpbnRBdHRyaWJ1dGVzID0gX3ByaW50QXR0cmlidXRlcztcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL25vZGUvaW5kZXguanNcIik7XG5jb25zdCB7XG4gIGlzQ2xhc3NEZWNsYXJhdGlvbixcbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyLFxuICBpc0ltcG9ydE5hbWVzcGFjZVNwZWNpZmllcixcbiAgaXNTdGF0ZW1lbnRcbn0gPSBfdDtcbmZ1bmN0aW9uIEltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gIGlmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIikge1xuICAgIHRoaXMud29yZChub2RlLmltcG9ydEtpbmQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUuaW1wb3J0ZWQpO1xuICBpZiAobm9kZS5sb2NhbCAmJiBub2RlLmxvY2FsLm5hbWUgIT09IG5vZGUuaW1wb3J0ZWQubmFtZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmxvY2FsKTtcbiAgfVxufVxuZnVuY3Rpb24gSW1wb3J0RGVmYXVsdFNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5sb2NhbCk7XG59XG5mdW5jdGlvbiBFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmV4cG9ydGVkKTtcbn1cbmZ1bmN0aW9uIEV4cG9ydFNwZWNpZmllcihub2RlKSB7XG4gIGlmIChub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLmxvY2FsKTtcbiAgaWYgKG5vZGUuZXhwb3J0ZWQgJiYgbm9kZS5sb2NhbC5uYW1lICE9PSBub2RlLmV4cG9ydGVkLm5hbWUpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiYXNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5leHBvcnRlZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gIHRoaXMudG9rZW5DaGFyKDQyKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwb3J0ZWQpO1xufVxubGV0IHdhcm5pbmdTaG93biA9IGZhbHNlO1xuZnVuY3Rpb24gX3ByaW50QXR0cmlidXRlcyhub2RlLCBoYXNQcmV2aW91c0JyYWNlKSB7XG4gIGNvbnN0IHtcbiAgICBpbXBvcnRBdHRyaWJ1dGVzS2V5d29yZFxuICB9ID0gdGhpcy5mb3JtYXQ7XG4gIGNvbnN0IHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGFzc2VydGlvbnNcbiAgfSA9IG5vZGU7XG4gIGlmIChhdHRyaWJ1dGVzICYmICFpbXBvcnRBdHRyaWJ1dGVzS2V5d29yZCAmJiAhd2FybmluZ1Nob3duKSB7XG4gICAgd2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oYFxcXG5Zb3UgYXJlIHVzaW5nIGltcG9ydCBhdHRyaWJ1dGVzLCB3aXRob3V0IHNwZWNpZnlpbmcgdGhlIGRlc2lyZWQgb3V0cHV0IHN5bnRheC5cblBsZWFzZSBzcGVjaWZ5IHRoZSBcImltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkXCIgZ2VuZXJhdG9yIG9wdGlvbiwgd2hvc2UgdmFsdWUgY2FuIGJlIG9uZSBvZjpcbiAtIFwid2l0aFwiICAgICAgICA6IFxcYGltcG9ydCB7IGEgfSBmcm9tIFwiYlwiIHdpdGggeyB0eXBlOiBcImpzb25cIiB9O1xcYFxuIC0gXCJhc3NlcnRcIiAgICAgIDogXFxgaW1wb3J0IHsgYSB9IGZyb20gXCJiXCIgYXNzZXJ0IHsgdHlwZTogXCJqc29uXCIgfTtcXGBcbiAtIFwid2l0aC1sZWdhY3lcIiA6IFxcYGltcG9ydCB7IGEgfSBmcm9tIFwiYlwiIHdpdGggdHlwZTogXCJqc29uXCI7XFxgXG5gKTtcbiAgfVxuICBjb25zdCB1c2VBc3NlcnRLZXl3b3JkID0gaW1wb3J0QXR0cmlidXRlc0tleXdvcmQgPT09IFwiYXNzZXJ0XCIgfHwgIWltcG9ydEF0dHJpYnV0ZXNLZXl3b3JkICYmIGFzc2VydGlvbnM7XG4gIHRoaXMud29yZCh1c2VBc3NlcnRLZXl3b3JkID8gXCJhc3NlcnRcIiA6IFwid2l0aFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAoIXVzZUFzc2VydEtleXdvcmQgJiYgaW1wb3J0QXR0cmlidXRlc0tleXdvcmQgIT09IFwid2l0aFwiKSB7XG4gICAgdGhpcy5wcmludExpc3QoYXR0cmlidXRlcyB8fCBhc3NlcnRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2NjdXJyZW5jZUNvdW50ID0gaGFzUHJldmlvdXNCcmFjZSA/IDEgOiAwO1xuICB0aGlzLnRva2VuKFwie1wiLCBudWxsLCBvY2N1cnJlbmNlQ291bnQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnRMaXN0KGF0dHJpYnV0ZXMgfHwgYXNzZXJ0aW9ucywge1xuICAgIHByaW50VHJhaWxpbmdTZXBhcmF0b3I6IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwifVwiKVxuICB9KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuKFwifVwiLCBudWxsLCBvY2N1cnJlbmNlQ291bnQpO1xufVxuZnVuY3Rpb24gRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSkge1xuICB2YXIgX25vZGUkYXR0cmlidXRlcywgX25vZGUkYXNzZXJ0aW9ucztcbiAgdGhpcy53b3JkKFwiZXhwb3J0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiKSB7XG4gICAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImZyb21cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgaWYgKChfbm9kZSRhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzKSAhPSBudWxsICYmIF9ub2RlJGF0dHJpYnV0ZXMubGVuZ3RoIHx8IChfbm9kZSRhc3NlcnRpb25zID0gbm9kZS5hc3NlcnRpb25zKSAhPSBudWxsICYmIF9ub2RlJGFzc2VydGlvbnMubGVuZ3RoKSB7XG4gICAgdGhpcy5wcmludChub2RlLnNvdXJjZSwgdHJ1ZSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMuX3ByaW50QXR0cmlidXRlcyhub2RlLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmludChub2RlLnNvdXJjZSk7XG4gIH1cbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIG1heWJlUHJpbnREZWNvcmF0b3JzQmVmb3JlRXhwb3J0KHByaW50ZXIsIG5vZGUpIHtcbiAgaWYgKGlzQ2xhc3NEZWNsYXJhdGlvbihub2RlLmRlY2xhcmF0aW9uKSAmJiBwcmludGVyLl9zaG91bGRQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQobm9kZSkpIHtcbiAgICBwcmludGVyLnByaW50Sm9pbihub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMpO1xuICB9XG59XG5mdW5jdGlvbiBFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgbWF5YmVQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQodGhpcywgbm9kZSk7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgIGNvbnN0IGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb247XG4gICAgdGhpcy5wcmludChkZWNsYXIpO1xuICAgIGlmICghaXNTdGF0ZW1lbnQoZGVjbGFyKSkgdGhpcy5zZW1pY29sb24oKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgdGhpcy53b3JkKFwidHlwZVwiKTtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycy5zbGljZSgwKTtcbiAgICBsZXQgaGFzU3BlY2lhbCA9IGZhbHNlO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IGZpcnN0ID0gc3BlY2lmaWVyc1swXTtcbiAgICAgIGlmIChpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoZmlyc3QpIHx8IGlzRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGZpcnN0KSkge1xuICAgICAgICBoYXNTcGVjaWFsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmludChzcGVjaWZpZXJzLnNoaWZ0KCkpO1xuICAgICAgICBpZiAoc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnRva2VuQ2hhcig0NCk7XG4gICAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGhhc0JyYWNlID0gZmFsc2U7XG4gICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoIHx8ICFzcGVjaWZpZXJzLmxlbmd0aCAmJiAhaGFzU3BlY2lhbCkge1xuICAgICAgaGFzQnJhY2UgPSB0cnVlO1xuICAgICAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgICAgIGlmIChzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIHRoaXMucHJpbnRMaXN0KHNwZWNpZmllcnMsIHtcbiAgICAgICAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yOiB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIilcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9rZW5DaGFyKDEyNSk7XG4gICAgfVxuICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgdmFyIF9ub2RlJGF0dHJpYnV0ZXMyLCBfbm9kZSRhc3NlcnRpb25zMjtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMud29yZChcImZyb21cIik7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICBpZiAoKF9ub2RlJGF0dHJpYnV0ZXMyID0gbm9kZS5hdHRyaWJ1dGVzKSAhPSBudWxsICYmIF9ub2RlJGF0dHJpYnV0ZXMyLmxlbmd0aCB8fCAoX25vZGUkYXNzZXJ0aW9uczIgPSBub2RlLmFzc2VydGlvbnMpICE9IG51bGwgJiYgX25vZGUkYXNzZXJ0aW9uczIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJpbnQobm9kZS5zb3VyY2UsIHRydWUpO1xuICAgICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICAgIHRoaXMuX3ByaW50QXR0cmlidXRlcyhub2RlLCBoYXNCcmFjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByaW50KG5vZGUuc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxufVxuZnVuY3Rpb24gRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgbWF5YmVQcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQodGhpcywgbm9kZSk7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5ub0luZGVudElubmVyQ29tbWVudHNIZXJlKCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwiZGVmYXVsdFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmV4cG9ydERlZmF1bHQ7XG4gIGNvbnN0IGRlY2xhciA9IG5vZGUuZGVjbGFyYXRpb247XG4gIHRoaXMucHJpbnQoZGVjbGFyKTtcbiAgaWYgKCFpc1N0YXRlbWVudChkZWNsYXIpKSB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gSW1wb3J0RGVjbGFyYXRpb24obm9kZSkge1xuICB2YXIgX25vZGUkYXR0cmlidXRlczMsIF9ub2RlJGFzc2VydGlvbnMzO1xuICB0aGlzLndvcmQoXCJpbXBvcnRcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgY29uc3QgaXNUeXBlS2luZCA9IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiO1xuICBpZiAoaXNUeXBlS2luZCkge1xuICAgIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICAgIHRoaXMud29yZChub2RlLmltcG9ydEtpbmQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfSBlbHNlIGlmIChub2RlLm1vZHVsZSkge1xuICAgIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICAgIHRoaXMud29yZChcIm1vZHVsZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5waGFzZSkge1xuICAgIHRoaXMubm9JbmRlbnRJbm5lckNvbW1lbnRzSGVyZSgpO1xuICAgIHRoaXMud29yZChub2RlLnBoYXNlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgY29uc3Qgc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycy5zbGljZSgwKTtcbiAgY29uc3QgaGFzU3BlY2lmaWVycyA9ICEhc3BlY2lmaWVycy5sZW5ndGg7XG4gIHdoaWxlIChoYXNTcGVjaWZpZXJzKSB7XG4gICAgY29uc3QgZmlyc3QgPSBzcGVjaWZpZXJzWzBdO1xuICAgIGlmIChpc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoZmlyc3QpIHx8IGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKGZpcnN0KSkge1xuICAgICAgdGhpcy5wcmludChzcGVjaWZpZXJzLnNoaWZ0KCkpO1xuICAgICAgaWYgKHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMudG9rZW5DaGFyKDQ0KTtcbiAgICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV0IGhhc0JyYWNlID0gZmFsc2U7XG4gIGlmIChzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgIGhhc0JyYWNlID0gdHJ1ZTtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChzcGVjaWZpZXJzLCB7XG4gICAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yOiB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIilcbiAgICB9KTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfSBlbHNlIGlmIChpc1R5cGVLaW5kICYmICFoYXNTcGVjaWZpZXJzKSB7XG4gICAgaGFzQnJhY2UgPSB0cnVlO1xuICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfVxuICBpZiAoaGFzU3BlY2lmaWVycyB8fCBpc1R5cGVLaW5kKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImZyb21cIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmICgoX25vZGUkYXR0cmlidXRlczMgPSBub2RlLmF0dHJpYnV0ZXMpICE9IG51bGwgJiYgX25vZGUkYXR0cmlidXRlczMubGVuZ3RoIHx8IChfbm9kZSRhc3NlcnRpb25zMyA9IG5vZGUuYXNzZXJ0aW9ucykgIT0gbnVsbCAmJiBfbm9kZSRhc3NlcnRpb25zMy5sZW5ndGgpIHtcbiAgICB0aGlzLnByaW50KG5vZGUuc291cmNlLCB0cnVlKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5fcHJpbnRBdHRyaWJ1dGVzKG5vZGUsIGhhc0JyYWNlKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KG5vZGUuc291cmNlKTtcbiAgfVxuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gSW1wb3J0QXR0cmlidXRlKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmtleSk7XG4gIHRoaXMudG9rZW5DaGFyKDU4KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudmFsdWUpO1xufVxuZnVuY3Rpb24gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImFzXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5sb2NhbCk7XG59XG5mdW5jdGlvbiBJbXBvcnRFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xuICBpZiAobm9kZS5waGFzZSkge1xuICAgIHRoaXMudG9rZW5DaGFyKDQ2KTtcbiAgICB0aGlzLndvcmQobm9kZS5waGFzZSk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUuc291cmNlKTtcbiAgaWYgKG5vZGUub3B0aW9ucyAhPSBudWxsKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDQpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KG5vZGUub3B0aW9ucyk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89638\n')},70521:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.BreakStatement = BreakStatement;\nexports.CatchClause = CatchClause;\nexports.ContinueStatement = ContinueStatement;\nexports.DebuggerStatement = DebuggerStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.ForOfStatement = exports.ForInStatement = void 0;\nexports.ForStatement = ForStatement;\nexports.IfStatement = IfStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.ReturnStatement = ReturnStatement;\nexports.SwitchCase = SwitchCase;\nexports.SwitchStatement = SwitchStatement;\nexports.ThrowStatement = ThrowStatement;\nexports.TryStatement = TryStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\nexports.WhileStatement = WhileStatement;\nexports.WithStatement = WithStatement;\nvar _t = __webpack_require__(2352);\nvar _index = __webpack_require__(31373);\nconst {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement\n} = _t;\nfunction WithStatement(node) {\n  this.word("with");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.object);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction IfStatement(node) {\n  this.word("if");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.space();\n  const needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.tokenChar(123);\n    this.newline();\n    this.indent();\n  }\n  this.printAndIndentOnComments(node.consequent);\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.tokenChar(125);\n  }\n  if (node.alternate) {\n    if (this.endsWith(125)) this.space();\n    this.word("else");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\nfunction getLastStatement(statement) {\n  const {\n    body\n  } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n  return getLastStatement(body);\n}\nfunction ForStatement(node) {\n  this.word("for");\n  this.space();\n  this.tokenChar(40);\n  {\n    const exit = this.enterForStatementInit();\n    this.tokenContext |= _index.TokenContext.forHead;\n    this.print(node.init);\n    exit();\n  }\n  this.tokenChar(59);\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(";", false, 1);\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction WhileStatement(node) {\n  this.word("while");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nfunction ForXStatement(node) {\n  this.word("for");\n  this.space();\n  const isForOf = node.type === "ForOfStatement";\n  if (isForOf && node.await) {\n    this.word("await");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.tokenChar(40);\n  {\n    const exit = isForOf ? null : this.enterForStatementInit();\n    this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;\n    this.print(node.left);\n    exit == null || exit();\n  }\n  this.space();\n  this.word(isForOf ? "of" : "in");\n  this.space();\n  this.print(node.right);\n  this.tokenChar(41);\n  this.printBlock(node);\n}\nconst ForInStatement = exports.ForInStatement = ForXStatement;\nconst ForOfStatement = exports.ForOfStatement = ForXStatement;\nfunction DoWhileStatement(node) {\n  this.word("do");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word("while");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.test);\n  this.tokenChar(41);\n  this.semicolon();\n}\nfunction printStatementAfterKeyword(printer, node) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n  printer.semicolon();\n}\nfunction BreakStatement(node) {\n  this.word("break");\n  printStatementAfterKeyword(this, node.label);\n}\nfunction ContinueStatement(node) {\n  this.word("continue");\n  printStatementAfterKeyword(this, node.label);\n}\nfunction ReturnStatement(node) {\n  this.word("return");\n  printStatementAfterKeyword(this, node.argument);\n}\nfunction ThrowStatement(node) {\n  this.word("throw");\n  printStatementAfterKeyword(this, node.argument);\n}\nfunction LabeledStatement(node) {\n  this.print(node.label);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.body);\n}\nfunction TryStatement(node) {\n  this.word("try");\n  this.space();\n  this.print(node.block);\n  this.space();\n  if (node.handlers) {\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n  if (node.finalizer) {\n    this.space();\n    this.word("finally");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\nfunction CatchClause(node) {\n  this.word("catch");\n  this.space();\n  if (node.param) {\n    this.tokenChar(40);\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.tokenChar(41);\n    this.space();\n  }\n  this.print(node.body);\n}\nfunction SwitchStatement(node) {\n  this.word("switch");\n  this.space();\n  this.tokenChar(40);\n  this.print(node.discriminant);\n  this.tokenChar(41);\n  this.space();\n  this.tokenChar(123);\n  this.printSequence(node.cases, {\n    indent: true,\n    addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n  });\n  this.rightBrace(node);\n}\nfunction SwitchCase(node) {\n  if (node.test) {\n    this.word("case");\n    this.space();\n    this.print(node.test);\n    this.tokenChar(58);\n  } else {\n    this.word("default");\n    this.tokenChar(58);\n  }\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, {\n      indent: true\n    });\n  }\n}\nfunction DebuggerStatement() {\n  this.word("debugger");\n  this.semicolon();\n}\nfunction VariableDeclaration(node, parent) {\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n  const {\n    kind\n  } = node;\n  if (kind === "await using") {\n    this.word("await");\n    this.space();\n    this.word("using", true);\n  } else {\n    this.word(kind, kind === "using");\n  }\n  this.space();\n  let hasInits = false;\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        hasInits = true;\n      }\n    }\n  }\n  this.printList(node.declarations, {\n    separator: hasInits ? function (occurrenceCount) {\n      this.token(",", false, occurrenceCount);\n      this.newline();\n    } : undefined,\n    indent: node.declarations.length > 1 ? true : false\n  });\n  if (isFor(parent)) {\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n  this.semicolon();\n}\nfunction VariableDeclarator(node) {\n  this.print(node.id);\n  if (node.definite) this.tokenChar(33);\n  this.print(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.init);\n  }\n}\n\n//# sourceMappingURL=statements.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA1MjEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0Msb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQix3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLEtBQWtCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qyx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvc3RhdGVtZW50cy5qcz8xMGNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5CcmVha1N0YXRlbWVudCA9IEJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5DYXRjaENsYXVzZSA9IENhdGNoQ2xhdXNlO1xuZXhwb3J0cy5Db250aW51ZVN0YXRlbWVudCA9IENvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5EZWJ1Z2dlclN0YXRlbWVudCA9IERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5Eb1doaWxlU3RhdGVtZW50ID0gRG9XaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBleHBvcnRzLkZvckluU3RhdGVtZW50ID0gdm9pZCAwO1xuZXhwb3J0cy5Gb3JTdGF0ZW1lbnQgPSBGb3JTdGF0ZW1lbnQ7XG5leHBvcnRzLklmU3RhdGVtZW50ID0gSWZTdGF0ZW1lbnQ7XG5leHBvcnRzLkxhYmVsZWRTdGF0ZW1lbnQgPSBMYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5SZXR1cm5TdGF0ZW1lbnQgPSBSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLlN3aXRjaENhc2UgPSBTd2l0Y2hDYXNlO1xuZXhwb3J0cy5Td2l0Y2hTdGF0ZW1lbnQgPSBTd2l0Y2hTdGF0ZW1lbnQ7XG5leHBvcnRzLlRocm93U3RhdGVtZW50ID0gVGhyb3dTdGF0ZW1lbnQ7XG5leHBvcnRzLlRyeVN0YXRlbWVudCA9IFRyeVN0YXRlbWVudDtcbmV4cG9ydHMuVmFyaWFibGVEZWNsYXJhdGlvbiA9IFZhcmlhYmxlRGVjbGFyYXRpb247XG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcbmV4cG9ydHMuV2hpbGVTdGF0ZW1lbnQgPSBXaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuV2l0aFN0YXRlbWVudCA9IFdpdGhTdGF0ZW1lbnQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9ub2RlL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0ZvcixcbiAgaXNGb3JTdGF0ZW1lbnQsXG4gIGlzSWZTdGF0ZW1lbnQsXG4gIGlzU3RhdGVtZW50XG59ID0gX3Q7XG5mdW5jdGlvbiBXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwid2l0aFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3QpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMucHJpbnRCbG9jayhub2RlKTtcbn1cbmZ1bmN0aW9uIElmU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiaWZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUudGVzdCk7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICBjb25zdCBuZWVkc0Jsb2NrID0gbm9kZS5hbHRlcm5hdGUgJiYgaXNJZlN0YXRlbWVudChnZXRMYXN0U3RhdGVtZW50KG5vZGUuY29uc2VxdWVudCkpO1xuICBpZiAobmVlZHNCbG9jaykge1xuICAgIHRoaXMudG9rZW5DaGFyKDEyMyk7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy5pbmRlbnQoKTtcbiAgfVxuICB0aGlzLnByaW50QW5kSW5kZW50T25Db21tZW50cyhub2RlLmNvbnNlcXVlbnQpO1xuICBpZiAobmVlZHNCbG9jaykge1xuICAgIHRoaXMuZGVkZW50KCk7XG4gICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbiAgfVxuICBpZiAobm9kZS5hbHRlcm5hdGUpIHtcbiAgICBpZiAodGhpcy5lbmRzV2l0aCgxMjUpKSB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy53b3JkKFwiZWxzZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludEFuZEluZGVudE9uQ29tbWVudHMobm9kZS5hbHRlcm5hdGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRMYXN0U3RhdGVtZW50KHN0YXRlbWVudCkge1xuICBjb25zdCB7XG4gICAgYm9keVxuICB9ID0gc3RhdGVtZW50O1xuICBpZiAoaXNTdGF0ZW1lbnQoYm9keSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHN0YXRlbWVudDtcbiAgfVxuICByZXR1cm4gZ2V0TGFzdFN0YXRlbWVudChib2R5KTtcbn1cbmZ1bmN0aW9uIEZvclN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImZvclwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHtcbiAgICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckZvclN0YXRlbWVudEluaXQoKTtcbiAgICB0aGlzLnRva2VuQ29udGV4dCB8PSBfaW5kZXguVG9rZW5Db250ZXh0LmZvckhlYWQ7XG4gICAgdGhpcy5wcmludChub2RlLmluaXQpO1xuICAgIGV4aXQoKTtcbiAgfVxuICB0aGlzLnRva2VuQ2hhcig1OSk7XG4gIGlmIChub2RlLnRlc3QpIHtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnRlc3QpO1xuICB9XG4gIHRoaXMudG9rZW4oXCI7XCIsIGZhbHNlLCAxKTtcbiAgaWYgKG5vZGUudXBkYXRlKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS51cGRhdGUpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbiAgdGhpcy5wcmludEJsb2NrKG5vZGUpO1xufVxuZnVuY3Rpb24gV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS50ZXN0KTtcbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICB0aGlzLnByaW50QmxvY2sobm9kZSk7XG59XG5mdW5jdGlvbiBGb3JYU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiZm9yXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGNvbnN0IGlzRm9yT2YgPSBub2RlLnR5cGUgPT09IFwiRm9yT2ZTdGF0ZW1lbnRcIjtcbiAgaWYgKGlzRm9yT2YgJiYgbm9kZS5hd2FpdCkge1xuICAgIHRoaXMud29yZChcImF3YWl0XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLm5vSW5kZW50SW5uZXJDb21tZW50c0hlcmUoKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB7XG4gICAgY29uc3QgZXhpdCA9IGlzRm9yT2YgPyBudWxsIDogdGhpcy5lbnRlckZvclN0YXRlbWVudEluaXQoKTtcbiAgICB0aGlzLnRva2VuQ29udGV4dCB8PSBpc0Zvck9mID8gX2luZGV4LlRva2VuQ29udGV4dC5mb3JPZkhlYWQgOiBfaW5kZXguVG9rZW5Db250ZXh0LmZvckluSGVhZDtcbiAgICB0aGlzLnByaW50KG5vZGUubGVmdCk7XG4gICAgZXhpdCA9PSBudWxsIHx8IGV4aXQoKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChpc0Zvck9mID8gXCJvZlwiIDogXCJpblwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUucmlnaHQpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMucHJpbnRCbG9jayhub2RlKTtcbn1cbmNvbnN0IEZvckluU3RhdGVtZW50ID0gZXhwb3J0cy5Gb3JJblN0YXRlbWVudCA9IEZvclhTdGF0ZW1lbnQ7XG5jb25zdCBGb3JPZlN0YXRlbWVudCA9IGV4cG9ydHMuRm9yT2ZTdGF0ZW1lbnQgPSBGb3JYU3RhdGVtZW50O1xuZnVuY3Rpb24gRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImRvXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJ3aGlsZVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS50ZXN0KTtcbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gcHJpbnRTdGF0ZW1lbnRBZnRlcktleXdvcmQocHJpbnRlciwgbm9kZSkge1xuICBpZiAobm9kZSkge1xuICAgIHByaW50ZXIuc3BhY2UoKTtcbiAgICBwcmludGVyLnByaW50VGVybWluYXRvcmxlc3Mobm9kZSk7XG4gIH1cbiAgcHJpbnRlci5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIEJyZWFrU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy53b3JkKFwiYnJlYWtcIik7XG4gIHByaW50U3RhdGVtZW50QWZ0ZXJLZXl3b3JkKHRoaXMsIG5vZGUubGFiZWwpO1xufVxuZnVuY3Rpb24gQ29udGludWVTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJjb250aW51ZVwiKTtcbiAgcHJpbnRTdGF0ZW1lbnRBZnRlcktleXdvcmQodGhpcywgbm9kZS5sYWJlbCk7XG59XG5mdW5jdGlvbiBSZXR1cm5TdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJyZXR1cm5cIik7XG4gIHByaW50U3RhdGVtZW50QWZ0ZXJLZXl3b3JkKHRoaXMsIG5vZGUuYXJndW1lbnQpO1xufVxuZnVuY3Rpb24gVGhyb3dTdGF0ZW1lbnQobm9kZSkge1xuICB0aGlzLndvcmQoXCJ0aHJvd1wiKTtcbiAgcHJpbnRTdGF0ZW1lbnRBZnRlcktleXdvcmQodGhpcywgbm9kZS5hcmd1bWVudCk7XG59XG5mdW5jdGlvbiBMYWJlbGVkU3RhdGVtZW50KG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxhYmVsKTtcbiAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIFRyeVN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcInRyeVwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUuYmxvY2spO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLmhhbmRsZXJzKSB7XG4gICAgdGhpcy5wcmludChub2RlLmhhbmRsZXJzWzBdKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnByaW50KG5vZGUuaGFuZGxlcik7XG4gIH1cbiAgaWYgKG5vZGUuZmluYWxpemVyKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImZpbmFsbHlcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5maW5hbGl6ZXIpO1xuICB9XG59XG5mdW5jdGlvbiBDYXRjaENsYXVzZShub2RlKSB7XG4gIHRoaXMud29yZChcImNhdGNoXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLnBhcmFtKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDApO1xuICAgIHRoaXMucHJpbnQobm9kZS5wYXJhbSk7XG4gICAgdGhpcy5wcmludChub2RlLnBhcmFtLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIFN3aXRjaFN0YXRlbWVudChub2RlKSB7XG4gIHRoaXMud29yZChcInN3aXRjaFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMucHJpbnQobm9kZS5kaXNjcmltaW5hbnQpO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy50b2tlbkNoYXIoMTIzKTtcbiAgdGhpcy5wcmludFNlcXVlbmNlKG5vZGUuY2FzZXMsIHtcbiAgICBpbmRlbnQ6IHRydWUsXG4gICAgYWRkTmV3bGluZXMobGVhZGluZywgY2FzKSB7XG4gICAgICBpZiAoIWxlYWRpbmcgJiYgbm9kZS5jYXNlc1tub2RlLmNhc2VzLmxlbmd0aCAtIDFdID09PSBjYXMpIHJldHVybiAtMTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLnJpZ2h0QnJhY2Uobm9kZSk7XG59XG5mdW5jdGlvbiBTd2l0Y2hDYXNlKG5vZGUpIHtcbiAgaWYgKG5vZGUudGVzdCkge1xuICAgIHRoaXMud29yZChcImNhc2VcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS50ZXN0KTtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53b3JkKFwiZGVmYXVsdFwiKTtcbiAgICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIH1cbiAgaWYgKG5vZGUuY29uc2VxdWVudC5sZW5ndGgpIHtcbiAgICB0aGlzLm5ld2xpbmUoKTtcbiAgICB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5jb25zZXF1ZW50LCB7XG4gICAgICBpbmRlbnQ6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gRGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gIHRoaXMud29yZChcImRlYnVnZ2VyXCIpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gVmFyaWFibGVEZWNsYXJhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUuZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGNvbnN0IHtcbiAgICBraW5kXG4gIH0gPSBub2RlO1xuICBpZiAoa2luZCA9PT0gXCJhd2FpdCB1c2luZ1wiKSB7XG4gICAgdGhpcy53b3JkKFwiYXdhaXRcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcInVzaW5nXCIsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud29yZChraW5kLCBraW5kID09PSBcInVzaW5nXCIpO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgbGV0IGhhc0luaXRzID0gZmFsc2U7XG4gIGlmICghaXNGb3IocGFyZW50KSkge1xuICAgIGZvciAoY29uc3QgZGVjbGFyIG9mIG5vZGUuZGVjbGFyYXRpb25zKSB7XG4gICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgaGFzSW5pdHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnByaW50TGlzdChub2RlLmRlY2xhcmF0aW9ucywge1xuICAgIHNlcGFyYXRvcjogaGFzSW5pdHMgPyBmdW5jdGlvbiAob2NjdXJyZW5jZUNvdW50KSB7XG4gICAgICB0aGlzLnRva2VuKFwiLFwiLCBmYWxzZSwgb2NjdXJyZW5jZUNvdW50KTtcbiAgICAgIHRoaXMubmV3bGluZSgpO1xuICAgIH0gOiB1bmRlZmluZWQsXG4gICAgaW5kZW50OiBub2RlLmRlY2xhcmF0aW9ucy5sZW5ndGggPiAxID8gdHJ1ZSA6IGZhbHNlXG4gIH0pO1xuICBpZiAoaXNGb3IocGFyZW50KSkge1xuICAgIGlmIChpc0ZvclN0YXRlbWVudChwYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50LmluaXQgPT09IG5vZGUpIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBhcmVudC5sZWZ0ID09PSBub2RlKSByZXR1cm47XG4gICAgfVxuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3Iobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuaWQpO1xuICBpZiAobm9kZS5kZWZpbml0ZSkgdGhpcy50b2tlbkNoYXIoMzMpO1xuICB0aGlzLnByaW50KG5vZGUuaWQudHlwZUFubm90YXRpb24pO1xuICBpZiAobm9kZS5pbml0KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmluaXQpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70521\n')},12226:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\nfunction TaggedTemplateExpression(node) {\n  this.print(node.tag);\n  this.print(node.typeParameters);\n  this.print(node.quasi);\n}\nfunction TemplateElement() {\n  throw new Error("TemplateElement printing is handled in TemplateLiteral");\n}\nfunction TemplateLiteral(node) {\n  const quasis = node.quasis;\n  let partRaw = "`";\n  for (let i = 0; i < quasis.length; i++) {\n    partRaw += quasis[i].value.raw;\n    if (i + 1 < quasis.length) {\n      this.token(partRaw + "${", true);\n      this.print(node.expressions[i]);\n      partRaw = "}";\n      if (this.tokenMap) {\n        const token = this.tokenMap.findMatching(node, "}", i);\n        if (token) this._catchUpTo(token.loc.start);\n      }\n    }\n  }\n  this.token(partRaw + "`", true);\n}\n\n//# sourceMappingURL=template-literals.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyMjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL2dlbmVyYXRvcnMvdGVtcGxhdGUtbGl0ZXJhbHMuanM/YjgxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5UZW1wbGF0ZUVsZW1lbnQgPSBUZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLlRlbXBsYXRlTGl0ZXJhbCA9IFRlbXBsYXRlTGl0ZXJhbDtcbmZ1bmN0aW9uIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS50YWcpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICB0aGlzLnByaW50KG5vZGUucXVhc2kpO1xufVxuZnVuY3Rpb24gVGVtcGxhdGVFbGVtZW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZUVsZW1lbnQgcHJpbnRpbmcgaXMgaGFuZGxlZCBpbiBUZW1wbGF0ZUxpdGVyYWxcIik7XG59XG5mdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwobm9kZSkge1xuICBjb25zdCBxdWFzaXMgPSBub2RlLnF1YXNpcztcbiAgbGV0IHBhcnRSYXcgPSBcImBcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWFzaXMubGVuZ3RoOyBpKyspIHtcbiAgICBwYXJ0UmF3ICs9IHF1YXNpc1tpXS52YWx1ZS5yYXc7XG4gICAgaWYgKGkgKyAxIDwgcXVhc2lzLmxlbmd0aCkge1xuICAgICAgdGhpcy50b2tlbihwYXJ0UmF3ICsgXCIke1wiLCB0cnVlKTtcbiAgICAgIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uc1tpXSk7XG4gICAgICBwYXJ0UmF3ID0gXCJ9XCI7XG4gICAgICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMudG9rZW5NYXAuZmluZE1hdGNoaW5nKG5vZGUsIFwifVwiLCBpKTtcbiAgICAgICAgaWYgKHRva2VuKSB0aGlzLl9jYXRjaFVwVG8odG9rZW4ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy50b2tlbihwYXJ0UmF3ICsgXCJgXCIsIHRydWUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1saXRlcmFscy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12226\n')},7942:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ArgumentPlaceholder = ArgumentPlaceholder;\nexports.ArrayPattern = exports.ArrayExpression = ArrayExpression;\nexports.BigIntLiteral = BigIntLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.DecimalLiteral = DecimalLiteral;\nexports.Identifier = Identifier;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectPattern = exports.ObjectExpression = ObjectExpression;\nexports.ObjectMethod = ObjectMethod;\nexports.ObjectProperty = ObjectProperty;\nexports.PipelineBareFunction = PipelineBareFunction;\nexports.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;\nexports.PipelineTopicExpression = PipelineTopicExpression;\nexports.RecordExpression = RecordExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.SpreadElement = exports.RestElement = RestElement;\nexports.StringLiteral = StringLiteral;\nexports.TopicReference = TopicReference;\nexports.TupleExpression = TupleExpression;\nexports._getRawIdentifier = _getRawIdentifier;\nvar _t = __webpack_require__(2352);\nvar _jsesc = __webpack_require__(17159);\nconst {\n  isAssignmentPattern,\n  isIdentifier\n} = _t;\nlet lastRawIdentNode = null;\nlet lastRawIdentResult = "";\nfunction _getRawIdentifier(node) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n  const {\n    name\n  } = node;\n  const token = this.tokenMap.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return lastRawIdentResult = node.name;\n}\nfunction Identifier(node) {\n  var _node$loc;\n  this.sourceIdentifierName(((_node$loc = node.loc) == null ? void 0 : _node$loc.identifierName) || node.name);\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\nfunction ArgumentPlaceholder() {\n  this.tokenChar(63);\n}\nfunction RestElement(node) {\n  this.token("...");\n  this.print(node.argument);\n}\nfunction ObjectExpression(node) {\n  const props = node.properties;\n  this.tokenChar(123);\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, {\n      indent: true,\n      statement: true,\n      printTrailingSeparator: this.shouldPrintTrailingComma("}")\n    });\n    this.space();\n    exit();\n  }\n  this.sourceWithOffset("end", node.loc, -1);\n  this.tokenChar(125);\n}\nfunction ObjectMethod(node) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\nfunction ObjectProperty(node) {\n  this.printJoin(node.decorators);\n  if (node.computed) {\n    this.tokenChar(91);\n    this.print(node.key);\n    this.tokenChar(93);\n  } else {\n    if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {\n      this.print(node.value);\n      return;\n    }\n    this.print(node.key);\n    if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {\n      return;\n    }\n  }\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ArrayExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  this.tokenChar(91);\n  const exit = this.enterDelimited();\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma("]")) {\n        this.token(",", false, i);\n      }\n    } else {\n      this.token(",", false, i);\n    }\n  }\n  exit();\n  this.tokenChar(93);\n}\nfunction RecordExpression(node) {\n  const props = node.properties;\n  let startToken;\n  let endToken;\n  {\n    if (this.format.recordAndTupleSyntaxType === "bar") {\n      startToken = "{|";\n      endToken = "|}";\n    } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {\n      throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);\n    } else {\n      startToken = "#{";\n      endToken = "}";\n    }\n  }\n  this.token(startToken);\n  if (props.length) {\n    this.space();\n    this.printList(props, {\n      indent: true,\n      statement: true,\n      printTrailingSeparator: this.shouldPrintTrailingComma(endToken)\n    });\n    this.space();\n  }\n  this.token(endToken);\n}\nfunction TupleExpression(node) {\n  const elems = node.elements;\n  const len = elems.length;\n  let startToken;\n  let endToken;\n  {\n    if (this.format.recordAndTupleSyntaxType === "bar") {\n      startToken = "[|";\n      endToken = "|]";\n    } else if (this.format.recordAndTupleSyntaxType === "hash") {\n      startToken = "#[";\n      endToken = "]";\n    } else {\n      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);\n    }\n  }\n  this.token(startToken);\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {\n        this.token(",", false, i);\n      }\n    }\n  }\n  this.token(endToken);\n}\nfunction RegExpLiteral(node) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\nfunction BooleanLiteral(node) {\n  this.word(node.value ? "true" : "false");\n}\nfunction NullLiteral() {\n  this.word("null");\n}\nfunction NumericLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + "";\n  if (opts.numbers) {\n    this.number(_jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value);\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\nfunction StringLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n  const val = _jsesc(node.value, this.format.jsescOption);\n  this.token(val);\n}\nfunction BigIntLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + "n");\n}\nfunction DecimalLiteral(node) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + "m");\n}\nconst validTopicTokenSet = new Set(["^^", "@@", "^", "%", "#"]);\nfunction TopicReference() {\n  const {\n    topicToken\n  } = this.format;\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(`The "topicToken" generator option must be one of ` + `${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);\n  }\n}\nfunction PipelineTopicExpression(node) {\n  this.print(node.expression);\n}\nfunction PipelineBareFunction(node) {\n  this.print(node.callee);\n}\nfunction PipelinePrimaryTopicReference() {\n  this.tokenChar(35);\n}\n\n//# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk0Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQkFBMkI7QUFDM0Isb0JBQW9CLEdBQUcsdUJBQXVCO0FBQzlDLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHFCQUFxQixHQUFHLHdCQUF3QjtBQUNoRCxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1QixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIscUJBQXFCLEdBQUcsbUJBQW1CO0FBQzNDLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6QixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixhQUFhLG1CQUFPLENBQUMsS0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsTUFBTTtBQUNOLGtHQUFrRyxzREFBc0Q7QUFDeEosTUFBTTtBQUNOLHNCQUFzQjtBQUN0QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLHNDQUFzQztBQUMvRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhLEdBQUcsV0FBVztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsNkVBQTZFLHdCQUF3QixHQUFHLHFCQUFxQjtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL3R5cGVzLmpzPzk1ZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFyZ3VtZW50UGxhY2Vob2xkZXIgPSBBcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5BcnJheVBhdHRlcm4gPSBleHBvcnRzLkFycmF5RXhwcmVzc2lvbiA9IEFycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuQmlnSW50TGl0ZXJhbCA9IEJpZ0ludExpdGVyYWw7XG5leHBvcnRzLkJvb2xlYW5MaXRlcmFsID0gQm9vbGVhbkxpdGVyYWw7XG5leHBvcnRzLkRlY2ltYWxMaXRlcmFsID0gRGVjaW1hbExpdGVyYWw7XG5leHBvcnRzLklkZW50aWZpZXIgPSBJZGVudGlmaWVyO1xuZXhwb3J0cy5OdWxsTGl0ZXJhbCA9IE51bGxMaXRlcmFsO1xuZXhwb3J0cy5OdW1lcmljTGl0ZXJhbCA9IE51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5PYmplY3RQYXR0ZXJuID0gZXhwb3J0cy5PYmplY3RFeHByZXNzaW9uID0gT2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuT2JqZWN0TWV0aG9kID0gT2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5PYmplY3RQcm9wZXJ0eSA9IE9iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5QaXBlbGluZUJhcmVGdW5jdGlvbiA9IFBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5QaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5QaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IFBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5SZWNvcmRFeHByZXNzaW9uID0gUmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuUmVnRXhwTGl0ZXJhbCA9IFJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLlNwcmVhZEVsZW1lbnQgPSBleHBvcnRzLlJlc3RFbGVtZW50ID0gUmVzdEVsZW1lbnQ7XG5leHBvcnRzLlN0cmluZ0xpdGVyYWwgPSBTdHJpbmdMaXRlcmFsO1xuZXhwb3J0cy5Ub3BpY1JlZmVyZW5jZSA9IFRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5UdXBsZUV4cHJlc3Npb24gPSBUdXBsZUV4cHJlc3Npb247XG5leHBvcnRzLl9nZXRSYXdJZGVudGlmaWVyID0gX2dldFJhd0lkZW50aWZpZXI7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9qc2VzYyA9IHJlcXVpcmUoXCJqc2VzY1wiKTtcbmNvbnN0IHtcbiAgaXNBc3NpZ25tZW50UGF0dGVybixcbiAgaXNJZGVudGlmaWVyXG59ID0gX3Q7XG5sZXQgbGFzdFJhd0lkZW50Tm9kZSA9IG51bGw7XG5sZXQgbGFzdFJhd0lkZW50UmVzdWx0ID0gXCJcIjtcbmZ1bmN0aW9uIF9nZXRSYXdJZGVudGlmaWVyKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGxhc3RSYXdJZGVudE5vZGUpIHJldHVybiBsYXN0UmF3SWRlbnRSZXN1bHQ7XG4gIGxhc3RSYXdJZGVudE5vZGUgPSBub2RlO1xuICBjb25zdCB7XG4gICAgbmFtZVxuICB9ID0gbm9kZTtcbiAgY29uc3QgdG9rZW4gPSB0aGlzLnRva2VuTWFwLmZpbmQobm9kZSwgdG9rID0+IHRvay52YWx1ZSA9PT0gbmFtZSk7XG4gIGlmICh0b2tlbikge1xuICAgIGxhc3RSYXdJZGVudFJlc3VsdCA9IHRoaXMuX29yaWdpbmFsQ29kZS5zbGljZSh0b2tlbi5zdGFydCwgdG9rZW4uZW5kKTtcbiAgICByZXR1cm4gbGFzdFJhd0lkZW50UmVzdWx0O1xuICB9XG4gIHJldHVybiBsYXN0UmF3SWRlbnRSZXN1bHQgPSBub2RlLm5hbWU7XG59XG5mdW5jdGlvbiBJZGVudGlmaWVyKG5vZGUpIHtcbiAgdmFyIF9ub2RlJGxvYztcbiAgdGhpcy5zb3VyY2VJZGVudGlmaWVyTmFtZSgoKF9ub2RlJGxvYyA9IG5vZGUubG9jKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkbG9jLmlkZW50aWZpZXJOYW1lKSB8fCBub2RlLm5hbWUpO1xuICB0aGlzLndvcmQodGhpcy50b2tlbk1hcCA/IHRoaXMuX2dldFJhd0lkZW50aWZpZXIobm9kZSkgOiBub2RlLm5hbWUpO1xufVxuZnVuY3Rpb24gQXJndW1lbnRQbGFjZWhvbGRlcigpIHtcbiAgdGhpcy50b2tlbkNoYXIoNjMpO1xufVxuZnVuY3Rpb24gUmVzdEVsZW1lbnQobm9kZSkge1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUuYXJndW1lbnQpO1xufVxuZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihub2RlKSB7XG4gIGNvbnN0IHByb3BzID0gbm9kZS5wcm9wZXJ0aWVzO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgY29uc3QgZXhpdCA9IHRoaXMuZW50ZXJEZWxpbWl0ZWQoKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludExpc3QocHJvcHMsIHtcbiAgICAgIGluZGVudDogdHJ1ZSxcbiAgICAgIHN0YXRlbWVudDogdHJ1ZSxcbiAgICAgIHByaW50VHJhaWxpbmdTZXBhcmF0b3I6IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwifVwiKVxuICAgIH0pO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICBleGl0KCk7XG4gIH1cbiAgdGhpcy5zb3VyY2VXaXRoT2Zmc2V0KFwiZW5kXCIsIG5vZGUubG9jLCAtMSk7XG4gIHRoaXMudG9rZW5DaGFyKDEyNSk7XG59XG5mdW5jdGlvbiBPYmplY3RNZXRob2Qobm9kZSkge1xuICB0aGlzLnByaW50Sm9pbihub2RlLmRlY29yYXRvcnMpO1xuICB0aGlzLl9tZXRob2RIZWFkKG5vZGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5ib2R5KTtcbn1cbmZ1bmN0aW9uIE9iamVjdFByb3BlcnR5KG5vZGUpIHtcbiAgdGhpcy5wcmludEpvaW4obm9kZS5kZWNvcmF0b3JzKTtcbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gICAgdGhpcy5wcmludChub2RlLmtleSk7XG4gICAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpc0Fzc2lnbm1lbnRQYXR0ZXJuKG5vZGUudmFsdWUpICYmIGlzSWRlbnRpZmllcihub2RlLmtleSkgJiYgbm9kZS5rZXkubmFtZSA9PT0gbm9kZS52YWx1ZS5sZWZ0Lm5hbWUpIHtcbiAgICAgIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucHJpbnQobm9kZS5rZXkpO1xuICAgIGlmIChub2RlLnNob3J0aGFuZCAmJiBpc0lkZW50aWZpZXIobm9kZS5rZXkpICYmIGlzSWRlbnRpZmllcihub2RlLnZhbHVlKSAmJiBub2RlLmtleS5uYW1lID09PSBub2RlLnZhbHVlLm5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS52YWx1ZSk7XG59XG5mdW5jdGlvbiBBcnJheUV4cHJlc3Npb24obm9kZSkge1xuICBjb25zdCBlbGVtcyA9IG5vZGUuZWxlbWVudHM7XG4gIGNvbnN0IGxlbiA9IGVsZW1zLmxlbmd0aDtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZWxlbSA9IGVsZW1zW2ldO1xuICAgIGlmIChlbGVtKSB7XG4gICAgICBpZiAoaSA+IDApIHRoaXMuc3BhY2UoKTtcbiAgICAgIHRoaXMucHJpbnQoZWxlbSk7XG4gICAgICBpZiAoaSA8IGxlbiAtIDEgfHwgdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCJdXCIpKSB7XG4gICAgICAgIHRoaXMudG9rZW4oXCIsXCIsIGZhbHNlLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2tlbihcIixcIiwgZmFsc2UsIGkpO1xuICAgIH1cbiAgfVxuICBleGl0KCk7XG4gIHRoaXMudG9rZW5DaGFyKDkzKTtcbn1cbmZ1bmN0aW9uIFJlY29yZEV4cHJlc3Npb24obm9kZSkge1xuICBjb25zdCBwcm9wcyA9IG5vZGUucHJvcGVydGllcztcbiAgbGV0IHN0YXJ0VG9rZW47XG4gIGxldCBlbmRUb2tlbjtcbiAge1xuICAgIGlmICh0aGlzLmZvcm1hdC5yZWNvcmRBbmRUdXBsZVN5bnRheFR5cGUgPT09IFwiYmFyXCIpIHtcbiAgICAgIHN0YXJ0VG9rZW4gPSBcInt8XCI7XG4gICAgICBlbmRUb2tlbiA9IFwifH1cIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZm9ybWF0LnJlY29yZEFuZFR1cGxlU3ludGF4VHlwZSAhPT0gXCJoYXNoXCIgJiYgdGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwicmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlXCIgZ2VuZXJhdG9yIG9wdGlvbiBtdXN0IGJlIFwiYmFyXCIgb3IgXCJoYXNoXCIgKCR7SlNPTi5zdHJpbmdpZnkodGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlKX0gcmVjZWl2ZWQpLmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRva2VuID0gXCIje1wiO1xuICAgICAgZW5kVG9rZW4gPSBcIn1cIjtcbiAgICB9XG4gIH1cbiAgdGhpcy50b2tlbihzdGFydFRva2VuKTtcbiAgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChwcm9wcywge1xuICAgICAgaW5kZW50OiB0cnVlLFxuICAgICAgc3RhdGVtZW50OiB0cnVlLFxuICAgICAgcHJpbnRUcmFpbGluZ1NlcGFyYXRvcjogdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoZW5kVG9rZW4pXG4gICAgfSk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudG9rZW4oZW5kVG9rZW4pO1xufVxuZnVuY3Rpb24gVHVwbGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3QgZWxlbXMgPSBub2RlLmVsZW1lbnRzO1xuICBjb25zdCBsZW4gPSBlbGVtcy5sZW5ndGg7XG4gIGxldCBzdGFydFRva2VuO1xuICBsZXQgZW5kVG9rZW47XG4gIHtcbiAgICBpZiAodGhpcy5mb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlID09PSBcImJhclwiKSB7XG4gICAgICBzdGFydFRva2VuID0gXCJbfFwiO1xuICAgICAgZW5kVG9rZW4gPSBcInxdXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZvcm1hdC5yZWNvcmRBbmRUdXBsZVN5bnRheFR5cGUgPT09IFwiaGFzaFwiKSB7XG4gICAgICBzdGFydFRva2VuID0gXCIjW1wiO1xuICAgICAgZW5kVG9rZW4gPSBcIl1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuZm9ybWF0LnJlY29yZEFuZFR1cGxlU3ludGF4VHlwZX0gaXMgbm90IGEgdmFsaWQgcmVjb3JkQW5kVHVwbGUgc3ludGF4IHR5cGVgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy50b2tlbihzdGFydFRva2VuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsZW0gPSBlbGVtc1tpXTtcbiAgICBpZiAoZWxlbSkge1xuICAgICAgaWYgKGkgPiAwKSB0aGlzLnNwYWNlKCk7XG4gICAgICB0aGlzLnByaW50KGVsZW0pO1xuICAgICAgaWYgKGkgPCBsZW4gLSAxIHx8IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKGVuZFRva2VuKSkge1xuICAgICAgICB0aGlzLnRva2VuKFwiLFwiLCBmYWxzZSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMudG9rZW4oZW5kVG9rZW4pO1xufVxuZnVuY3Rpb24gUmVnRXhwTGl0ZXJhbChub2RlKSB7XG4gIHRoaXMud29yZChgLyR7bm9kZS5wYXR0ZXJufS8ke25vZGUuZmxhZ3N9YCk7XG59XG5mdW5jdGlvbiBCb29sZWFuTGl0ZXJhbChub2RlKSB7XG4gIHRoaXMud29yZChub2RlLnZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpO1xufVxuZnVuY3Rpb24gTnVsbExpdGVyYWwoKSB7XG4gIHRoaXMud29yZChcIm51bGxcIik7XG59XG5mdW5jdGlvbiBOdW1lcmljTGl0ZXJhbChub2RlKSB7XG4gIGNvbnN0IHJhdyA9IHRoaXMuZ2V0UG9zc2libGVSYXcobm9kZSk7XG4gIGNvbnN0IG9wdHMgPSB0aGlzLmZvcm1hdC5qc2VzY09wdGlvbjtcbiAgY29uc3QgdmFsdWUgPSBub2RlLnZhbHVlO1xuICBjb25zdCBzdHIgPSB2YWx1ZSArIFwiXCI7XG4gIGlmIChvcHRzLm51bWJlcnMpIHtcbiAgICB0aGlzLm51bWJlcihfanNlc2ModmFsdWUsIG9wdHMpLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocmF3ID09IG51bGwpIHtcbiAgICB0aGlzLm51bWJlcihzdHIsIHZhbHVlKTtcbiAgfSBlbHNlIGlmICh0aGlzLmZvcm1hdC5taW5pZmllZCkge1xuICAgIHRoaXMubnVtYmVyKHJhdy5sZW5ndGggPCBzdHIubGVuZ3RoID8gcmF3IDogc3RyLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5udW1iZXIocmF3LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFN0cmluZ0xpdGVyYWwobm9kZSkge1xuICBjb25zdCByYXcgPSB0aGlzLmdldFBvc3NpYmxlUmF3KG5vZGUpO1xuICBpZiAoIXRoaXMuZm9ybWF0Lm1pbmlmaWVkICYmIHJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50b2tlbihyYXcpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB2YWwgPSBfanNlc2Mobm9kZS52YWx1ZSwgdGhpcy5mb3JtYXQuanNlc2NPcHRpb24pO1xuICB0aGlzLnRva2VuKHZhbCk7XG59XG5mdW5jdGlvbiBCaWdJbnRMaXRlcmFsKG5vZGUpIHtcbiAgY29uc3QgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgaWYgKCF0aGlzLmZvcm1hdC5taW5pZmllZCAmJiByYXcgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMud29yZChyYXcpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLndvcmQobm9kZS52YWx1ZSArIFwiblwiKTtcbn1cbmZ1bmN0aW9uIERlY2ltYWxMaXRlcmFsKG5vZGUpIHtcbiAgY29uc3QgcmF3ID0gdGhpcy5nZXRQb3NzaWJsZVJhdyhub2RlKTtcbiAgaWYgKCF0aGlzLmZvcm1hdC5taW5pZmllZCAmJiByYXcgIT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMud29yZChyYXcpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLndvcmQobm9kZS52YWx1ZSArIFwibVwiKTtcbn1cbmNvbnN0IHZhbGlkVG9waWNUb2tlblNldCA9IG5ldyBTZXQoW1wiXl5cIiwgXCJAQFwiLCBcIl5cIiwgXCIlXCIsIFwiI1wiXSk7XG5mdW5jdGlvbiBUb3BpY1JlZmVyZW5jZSgpIHtcbiAgY29uc3Qge1xuICAgIHRvcGljVG9rZW5cbiAgfSA9IHRoaXMuZm9ybWF0O1xuICBpZiAodmFsaWRUb3BpY1Rva2VuU2V0Lmhhcyh0b3BpY1Rva2VuKSkge1xuICAgIHRoaXMudG9rZW4odG9waWNUb2tlbik7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZ2l2ZW5Ub3BpY1Rva2VuSlNPTiA9IEpTT04uc3RyaW5naWZ5KHRvcGljVG9rZW4pO1xuICAgIGNvbnN0IHZhbGlkVG9waWNzID0gQXJyYXkuZnJvbSh2YWxpZFRvcGljVG9rZW5TZXQsIHYgPT4gSlNPTi5zdHJpbmdpZnkodikpO1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwidG9waWNUb2tlblwiIGdlbmVyYXRvciBvcHRpb24gbXVzdCBiZSBvbmUgb2YgYCArIGAke3ZhbGlkVG9waWNzLmpvaW4oXCIsIFwiKX0gKCR7Z2l2ZW5Ub3BpY1Rva2VuSlNPTn0gcmVjZWl2ZWQgaW5zdGVhZCkuYCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFBpcGVsaW5lVG9waWNFeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xufVxuZnVuY3Rpb24gUGlwZWxpbmVCYXJlRnVuY3Rpb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuY2FsbGVlKTtcbn1cbmZ1bmN0aW9uIFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKCkge1xuICB0aGlzLnRva2VuQ2hhcigzNSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7942\n')},9276:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSInterfaceHeritage = exports.TSExpressionWithTypeArguments = exports.TSClassImplements = TSClassImplements;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nfunction TSTypeAnnotation(node, parent) {\n  this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node ? "=>" : ":");\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, t => this.tokenMap.matchesOriginal(t, ",")));\n    printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));\n  }\n  this.printList(node.params, {\n    printTrailingSeparator\n  });\n  this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word("in");\n    this.space();\n  }\n  if (node.out) {\n    this.word("out");\n    this.space();\n  }\n  this.word(node.name);\n  if (node.constraint) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.print(node.constraint);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default);\n  }\n}\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.readonly) {\n    this.word("readonly");\n    this.space();\n  }\n  this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n  if (node.declare) {\n    this.word("declare");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\nfunction TSQualifiedName(node) {\n  this.print(node.left);\n  this.tokenChar(46);\n  this.print(node.right);\n}\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction maybePrintTrailingCommaOrSemicolon(printer, node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n  if (printer.tokenMap.endMatches(node, ",")) {\n    printer.token(",");\n  } else if (printer.tokenMap.endMatches(node, ";")) {\n    printer.semicolon();\n  }\n}\nfunction TSConstructSignatureDeclaration(node) {\n  this.word("new");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSPropertySignature(node) {\n  const {\n    readonly\n  } = node;\n  if (readonly) {\n    this.word("readonly");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n  if (kind === "set" || kind === "get") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n  if (isStatic) {\n    this.word("static");\n    this.space();\n  }\n  if (readonly) {\n    this.word("readonly");\n    this.space();\n  }\n  this.tokenChar(91);\n  this._parameters(node.parameters, "]");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSAnyKeyword() {\n  this.word("any");\n}\nfunction TSBigIntKeyword() {\n  this.word("bigint");\n}\nfunction TSUnknownKeyword() {\n  this.word("unknown");\n}\nfunction TSNumberKeyword() {\n  this.word("number");\n}\nfunction TSObjectKeyword() {\n  this.word("object");\n}\nfunction TSBooleanKeyword() {\n  this.word("boolean");\n}\nfunction TSStringKeyword() {\n  this.word("string");\n}\nfunction TSSymbolKeyword() {\n  this.word("symbol");\n}\nfunction TSVoidKeyword() {\n  this.word("void");\n}\nfunction TSUndefinedKeyword() {\n  this.word("undefined");\n}\nfunction TSNullKeyword() {\n  this.word("null");\n}\nfunction TSNeverKeyword() {\n  this.word("never");\n}\nfunction TSIntrinsicKeyword() {\n  this.word("intrinsic");\n}\nfunction TSThisType() {\n  this.word("this");\n}\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word("abstract");\n    this.space();\n  }\n  this.word("new");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, ")");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction TSTypeReference(node) {\n  this.print(node.typeName, !!node.typeParameters);\n  this.print(node.typeParameters);\n}\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word("asserts");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word("is");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\nfunction TSTypeQuery(node) {\n  this.word("typeof");\n  this.space();\n  this.print(node.exprName);\n  if (node.typeParameters) {\n    this.print(node.typeParameters);\n  }\n}\nfunction TSTypeLiteral(node) {\n  printBraced(this, node, () => this.printJoin(node.members, {\n    indent: true,\n    statement: true\n  }));\n}\nfunction TSArrayType(node) {\n  this.print(node.elementType, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, {\n    printTrailingSeparator: this.shouldPrintTrailingComma("]")\n  });\n  this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation);\n  this.tokenChar(63);\n}\nfunction TSRestType(node) {\n  this.token("...");\n  this.print(node.typeAnnotation);\n}\nfunction TSNamedTupleMember(node) {\n  this.print(node.label);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType);\n}\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, "|");\n}\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, "&");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  var _printer$tokenMap;\n  let hasLeadingToken = 0;\n  if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n  printer.printJoin(node.types, {\n    separator(i) {\n      this.space();\n      this.token(sep, null, i + hasLeadingToken);\n      this.space();\n    }\n  });\n}\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word("extends");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\nfunction TSInferType(node) {\n  this.word("infer");\n  this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation);\n  this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, true);\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeAnnotation\n  } = node;\n  this.tokenChar(123);\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word("readonly");\n    this.space();\n  }\n  this.tokenChar(91);\n  {\n    this.word(node.typeParameter.name);\n  }\n  this.space();\n  this.word("in");\n  this.space();\n  {\n    this.print(node.typeParameter.constraint);\n  }\n  if (nameType) {\n    this.space();\n    this.word("as");\n    this.space();\n    this.print(nameType);\n  }\n  this.tokenChar(93);\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n  if (typeAnnotation) {\n    this.tokenChar(58);\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\nfunction TSLiteralType(node) {\n  this.print(node.literal);\n}\nfunction TSClassImplements(node) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n  this.word("interface");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word("extends");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\nfunction TSInterfaceBody(node) {\n  printBraced(this, node, () => this.printJoin(node.body, {\n    indent: true,\n    statement: true\n  }));\n}\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n  this.word("type");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\nfunction TSTypeExpression(node) {\n  const {\n    type,\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === "TSAsExpression" ? "as" : "satisfies");\n  this.space();\n  this.print(typeAnnotation);\n}\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression);\n}\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n  if (isConst) {\n    this.word("const");\n    this.space();\n  }\n  this.word("enum");\n  this.space();\n  this.print(id);\n  this.space();\n  printBraced(this, node, () => {\n    var _this$shouldPrintTrai;\n    return this.printList(members, {\n      indent: true,\n      statement: true,\n      printTrailingSeparator: (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true\n    });\n  });\n}\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer);\n  }\n}\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id,\n    kind\n  } = node;\n  if (declare) {\n    this.word("declare");\n    this.space();\n  }\n  if (!node.global) {\n    this.word(kind != null ? kind : id.type === "Identifier" ? "namespace" : "module");\n    this.space();\n  }\n  this.print(id);\n  if (!node.body) {\n    this.semicolon();\n    return;\n  }\n  let body = node.body;\n  while (body.type === "TSModuleDeclaration") {\n    this.tokenChar(46);\n    this.print(body.id);\n    body = body.body;\n  }\n  this.space();\n  this.print(body);\n}\nfunction TSModuleBlock(node) {\n  printBraced(this, node, () => this.printSequence(node.body, {\n    indent: true\n  }));\n}\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word("import");\n  this.tokenChar(40);\n  this.print(argument);\n  this.tokenChar(41);\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier);\n  }\n  if (typeParameters) {\n    this.print(typeParameters);\n  }\n}\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n  if (isExport) {\n    this.word("export");\n    this.space();\n  }\n  this.word("import");\n  this.space();\n  this.print(id);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\nfunction TSExternalModuleReference(node) {\n  this.token("require(");\n  this.print(node.expression);\n  this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n  this.print(node.expression);\n  this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n  this.word("export");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\nfunction TSNamespaceExportDeclaration(node) {\n  this.word("export");\n  this.space();\n  this.word("as");\n  this.space();\n  this.word("namespace");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, ")");\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === "ClassAccessorProperty" || node.type === "ClassProperty";\n  printModifiersList(this, node, [isField && node.declare && "declare", node.accessibility]);\n  if (node.static) {\n    this.word("static");\n    this.space();\n  }\n  printModifiersList(this, node, [node.override && "override", node.abstract && "abstract", isField && node.readonly && "readonly"]);\n}\nfunction printBraced(printer, node, cb) {\n  printer.token("{");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\nfunction printModifiersList(printer, node, modifiers) {\n  var _printer$tokenMap2;\n  const modifiersSet = new Set();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n  (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n\n//# sourceMappingURL=typescript.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI3Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLDZCQUE2QixHQUFHLHNCQUFzQjtBQUN0RCx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQywyQkFBMkIsR0FBRyxxQ0FBcUMsR0FBRyx5QkFBeUI7QUFDL0YseUJBQXlCO0FBQ3pCLHVDQUF1QztBQUN2Qyx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsc0JBQXNCO0FBQ3RCLGlDQUFpQztBQUNqQyxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsaUNBQWlDO0FBQ2pDLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQixvQ0FBb0M7QUFDcEMsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsOEJBQThCO0FBQzlCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0Qix1QkFBdUI7QUFDdkIsa0NBQWtDLEdBQUcsb0NBQW9DO0FBQ3pFLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkMsd0NBQXdDO0FBQ3hDLG1DQUFtQztBQUNuQyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9nZW5lcmF0b3JzL3R5cGVzY3JpcHQuanM/YTZjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVFNBbnlLZXl3b3JkID0gVFNBbnlLZXl3b3JkO1xuZXhwb3J0cy5UU0FycmF5VHlwZSA9IFRTQXJyYXlUeXBlO1xuZXhwb3J0cy5UU1NhdGlzZmllc0V4cHJlc3Npb24gPSBleHBvcnRzLlRTQXNFeHByZXNzaW9uID0gVFNUeXBlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNCaWdJbnRLZXl3b3JkID0gVFNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy5UU0Jvb2xlYW5LZXl3b3JkID0gVFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNJbnRlcmZhY2VIZXJpdGFnZSA9IGV4cG9ydHMuVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLlRTQ2xhc3NJbXBsZW1lbnRzID0gVFNDbGFzc0ltcGxlbWVudHM7XG5leHBvcnRzLlRTQ29uZGl0aW9uYWxUeXBlID0gVFNDb25kaXRpb25hbFR5cGU7XG5leHBvcnRzLlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5UU0NvbnN0cnVjdG9yVHlwZSA9IFRTQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy5UU0RlY2xhcmVGdW5jdGlvbiA9IFRTRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5UU0RlY2xhcmVNZXRob2QgPSBUU0RlY2xhcmVNZXRob2Q7XG5leHBvcnRzLlRTRW51bURlY2xhcmF0aW9uID0gVFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLlRTRW51bU1lbWJlciA9IFRTRW51bU1lbWJlcjtcbmV4cG9ydHMuVFNFeHBvcnRBc3NpZ25tZW50ID0gVFNFeHBvcnRBc3NpZ25tZW50O1xuZXhwb3J0cy5UU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuVFNGdW5jdGlvblR5cGUgPSBUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLlRTSW1wb3J0VHlwZSA9IFRTSW1wb3J0VHlwZTtcbmV4cG9ydHMuVFNJbmRleFNpZ25hdHVyZSA9IFRTSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLlRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5UU0luZmVyVHlwZSA9IFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNJbnRlcmZhY2VCb2R5ID0gVFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5UU0ludGVyZmFjZURlY2xhcmF0aW9uID0gVFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNJbnRlcnNlY3Rpb25UeXBlID0gVFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5UU0ludHJpbnNpY0tleXdvcmQgPSBUU0ludHJpbnNpY0tleXdvcmQ7XG5leHBvcnRzLlRTTGl0ZXJhbFR5cGUgPSBUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5UU01hcHBlZFR5cGUgPSBUU01hcHBlZFR5cGU7XG5leHBvcnRzLlRTTWV0aG9kU2lnbmF0dXJlID0gVFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLlRTTW9kdWxlQmxvY2sgPSBUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5UU01vZHVsZURlY2xhcmF0aW9uID0gVFNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNOYW1lZFR1cGxlTWVtYmVyID0gVFNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy5UU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNOZXZlcktleXdvcmQgPSBUU05ldmVyS2V5d29yZDtcbmV4cG9ydHMuVFNOb25OdWxsRXhwcmVzc2lvbiA9IFRTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLlRTTnVsbEtleXdvcmQgPSBUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5UU051bWJlcktleXdvcmQgPSBUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLlRTT2JqZWN0S2V5d29yZCA9IFRTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuVFNPcHRpb25hbFR5cGUgPSBUU09wdGlvbmFsVHlwZTtcbmV4cG9ydHMuVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IFRTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLlRTUGFyZW50aGVzaXplZFR5cGUgPSBUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5UU1Byb3BlcnR5U2lnbmF0dXJlID0gVFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuVFNRdWFsaWZpZWROYW1lID0gVFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5UU1Jlc3RUeXBlID0gVFNSZXN0VHlwZTtcbmV4cG9ydHMuVFNTdHJpbmdLZXl3b3JkID0gVFNTdHJpbmdLZXl3b3JkO1xuZXhwb3J0cy5UU1N5bWJvbEtleXdvcmQgPSBUU1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLlRTVGhpc1R5cGUgPSBUU1RoaXNUeXBlO1xuZXhwb3J0cy5UU1R1cGxlVHlwZSA9IFRTVHVwbGVUeXBlO1xuZXhwb3J0cy5UU1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gVFNUeXBlQWxpYXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuVFNUeXBlQW5ub3RhdGlvbiA9IFRTVHlwZUFubm90YXRpb247XG5leHBvcnRzLlRTVHlwZUFzc2VydGlvbiA9IFRTVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMuVFNUeXBlTGl0ZXJhbCA9IFRTVHlwZUxpdGVyYWw7XG5leHBvcnRzLlRTVHlwZU9wZXJhdG9yID0gVFNUeXBlT3BlcmF0b3I7XG5leHBvcnRzLlRTVHlwZVBhcmFtZXRlciA9IFRTVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy5UU1R5cGVQcmVkaWNhdGUgPSBUU1R5cGVQcmVkaWNhdGU7XG5leHBvcnRzLlRTVHlwZVF1ZXJ5ID0gVFNUeXBlUXVlcnk7XG5leHBvcnRzLlRTVHlwZVJlZmVyZW5jZSA9IFRTVHlwZVJlZmVyZW5jZTtcbmV4cG9ydHMuVFNVbmRlZmluZWRLZXl3b3JkID0gVFNVbmRlZmluZWRLZXl3b3JkO1xuZXhwb3J0cy5UU1VuaW9uVHlwZSA9IFRTVW5pb25UeXBlO1xuZXhwb3J0cy5UU1Vua25vd25LZXl3b3JkID0gVFNVbmtub3duS2V5d29yZDtcbmV4cG9ydHMuVFNWb2lkS2V5d29yZCA9IFRTVm9pZEtleXdvcmQ7XG5leHBvcnRzLnRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycyA9IHRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycztcbmV4cG9ydHMudHNQcmludEZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUgPSB0c1ByaW50RnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMudHNQcmludFByb3BlcnR5T3JNZXRob2ROYW1lID0gdHNQcmludFByb3BlcnR5T3JNZXRob2ROYW1lO1xuZXhwb3J0cy50c1ByaW50U2lnbmF0dXJlRGVjbGFyYXRpb25CYXNlID0gdHNQcmludFNpZ25hdHVyZURlY2xhcmF0aW9uQmFzZTtcbmZ1bmN0aW9uIFRTVHlwZUFubm90YXRpb24obm9kZSwgcGFyZW50KSB7XG4gIHRoaXMudG9rZW4oKHBhcmVudC50eXBlID09PSBcIlRTRnVuY3Rpb25UeXBlXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikgJiYgcGFyZW50LnR5cGVBbm5vdGF0aW9uID09PSBub2RlID8gXCI9PlwiIDogXCI6XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChub2RlLm9wdGlvbmFsKSB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG59XG5mdW5jdGlvbiBUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIHBhcmVudCkge1xuICB0aGlzLnRva2VuQ2hhcig2MCk7XG4gIGxldCBwcmludFRyYWlsaW5nU2VwYXJhdG9yID0gcGFyZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLnBhcmFtcy5sZW5ndGggPT09IDE7XG4gIGlmICh0aGlzLnRva2VuTWFwICYmIG5vZGUuc3RhcnQgIT0gbnVsbCAmJiBub2RlLmVuZCAhPSBudWxsKSB7XG4gICAgcHJpbnRUcmFpbGluZ1NlcGFyYXRvciAmJiAocHJpbnRUcmFpbGluZ1NlcGFyYXRvciA9ICEhdGhpcy50b2tlbk1hcC5maW5kKG5vZGUsIHQgPT4gdGhpcy50b2tlbk1hcC5tYXRjaGVzT3JpZ2luYWwodCwgXCIsXCIpKSk7XG4gICAgcHJpbnRUcmFpbGluZ1NlcGFyYXRvciB8fCAocHJpbnRUcmFpbGluZ1NlcGFyYXRvciA9IHRoaXMuc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKFwiPlwiKSk7XG4gIH1cbiAgdGhpcy5wcmludExpc3Qobm9kZS5wYXJhbXMsIHtcbiAgICBwcmludFRyYWlsaW5nU2VwYXJhdG9yXG4gIH0pO1xuICB0aGlzLnRva2VuQ2hhcig2Mik7XG59XG5mdW5jdGlvbiBUU1R5cGVQYXJhbWV0ZXIobm9kZSkge1xuICBpZiAobm9kZS5pbikge1xuICAgIHRoaXMud29yZChcImluXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5vdXQpIHtcbiAgICB0aGlzLndvcmQoXCJvdXRcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChub2RlLm5hbWUpO1xuICBpZiAobm9kZS5jb25zdHJhaW50KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMucHJpbnQobm9kZS5jb25zdHJhaW50KTtcbiAgfVxuICBpZiAobm9kZS5kZWZhdWx0KSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLmRlZmF1bHQpO1xuICB9XG59XG5mdW5jdGlvbiBUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUpIHtcbiAgaWYgKG5vZGUuYWNjZXNzaWJpbGl0eSkge1xuICAgIHRoaXMud29yZChub2RlLmFjY2Vzc2liaWxpdHkpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICBpZiAobm9kZS5yZWFkb25seSkge1xuICAgIHRoaXMud29yZChcInJlYWRvbmx5XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLl9wYXJhbShub2RlLnBhcmFtZXRlcik7XG59XG5mdW5jdGlvbiBUU0RlY2xhcmVGdW5jdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgaWYgKG5vZGUuZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMuX2Z1bmN0aW9uSGVhZChub2RlLCBwYXJlbnQpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gVFNEZWNsYXJlTWV0aG9kKG5vZGUpIHtcbiAgdGhpcy5fY2xhc3NNZXRob2RIZWFkKG5vZGUpO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gVFNRdWFsaWZpZWROYW1lKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxlZnQpO1xuICB0aGlzLnRva2VuQ2hhcig0Nik7XG4gIHRoaXMucHJpbnQobm9kZS5yaWdodCk7XG59XG5mdW5jdGlvbiBUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMudHNQcmludFNpZ25hdHVyZURlY2xhcmF0aW9uQmFzZShub2RlKTtcbiAgbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIG1heWJlUHJpbnRUcmFpbGluZ0NvbW1hT3JTZW1pY29sb24ocHJpbnRlciwgbm9kZSkge1xuICBpZiAoIXByaW50ZXIudG9rZW5NYXAgfHwgIW5vZGUuc3RhcnQgfHwgIW5vZGUuZW5kKSB7XG4gICAgcHJpbnRlci5zZW1pY29sb24oKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByaW50ZXIudG9rZW5NYXAuZW5kTWF0Y2hlcyhub2RlLCBcIixcIikpIHtcbiAgICBwcmludGVyLnRva2VuKFwiLFwiKTtcbiAgfSBlbHNlIGlmIChwcmludGVyLnRva2VuTWFwLmVuZE1hdGNoZXMobm9kZSwgXCI7XCIpKSB7XG4gICAgcHJpbnRlci5zZW1pY29sb24oKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChcIm5ld1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRzUHJpbnRTaWduYXR1cmVEZWNsYXJhdGlvbkJhc2Uobm9kZSk7XG4gIG1heWJlUHJpbnRUcmFpbGluZ0NvbW1hT3JTZW1pY29sb24odGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHJlYWRvbmx5XG4gIH0gPSBub2RlO1xuICBpZiAocmVhZG9ubHkpIHtcbiAgICB0aGlzLndvcmQoXCJyZWFkb25seVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy50c1ByaW50UHJvcGVydHlPck1ldGhvZE5hbWUobm9kZSk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIG1heWJlUHJpbnRUcmFpbGluZ0NvbW1hT3JTZW1pY29sb24odGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiB0c1ByaW50UHJvcGVydHlPck1ldGhvZE5hbWUobm9kZSkge1xuICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgfVxuICB0aGlzLnByaW50KG5vZGUua2V5KTtcbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig5Myk7XG4gIH1cbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRTTWV0aG9kU2lnbmF0dXJlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGtpbmRcbiAgfSA9IG5vZGU7XG4gIGlmIChraW5kID09PSBcInNldFwiIHx8IGtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICB0aGlzLndvcmQoa2luZCk7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudHNQcmludFByb3BlcnR5T3JNZXRob2ROYW1lKG5vZGUpO1xuICB0aGlzLnRzUHJpbnRTaWduYXR1cmVEZWNsYXJhdGlvbkJhc2Uobm9kZSk7XG4gIG1heWJlUHJpbnRUcmFpbGluZ0NvbW1hT3JTZW1pY29sb24odGhpcywgbm9kZSk7XG59XG5mdW5jdGlvbiBUU0luZGV4U2lnbmF0dXJlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHJlYWRvbmx5LFxuICAgIHN0YXRpYzogaXNTdGF0aWNcbiAgfSA9IG5vZGU7XG4gIGlmIChpc1N0YXRpYykge1xuICAgIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgaWYgKHJlYWRvbmx5KSB7XG4gICAgdGhpcy53b3JkKFwicmVhZG9ubHlcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy5fcGFyYW1ldGVycyhub2RlLnBhcmFtZXRlcnMsIFwiXVwiKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgbWF5YmVQcmludFRyYWlsaW5nQ29tbWFPclNlbWljb2xvbih0aGlzLCBub2RlKTtcbn1cbmZ1bmN0aW9uIFRTQW55S2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwiYW55XCIpO1xufVxuZnVuY3Rpb24gVFNCaWdJbnRLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJiaWdpbnRcIik7XG59XG5mdW5jdGlvbiBUU1Vua25vd25LZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJ1bmtub3duXCIpO1xufVxuZnVuY3Rpb24gVFNOdW1iZXJLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJudW1iZXJcIik7XG59XG5mdW5jdGlvbiBUU09iamVjdEtleXdvcmQoKSB7XG4gIHRoaXMud29yZChcIm9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIFRTQm9vbGVhbktleXdvcmQoKSB7XG4gIHRoaXMud29yZChcImJvb2xlYW5cIik7XG59XG5mdW5jdGlvbiBUU1N0cmluZ0tleXdvcmQoKSB7XG4gIHRoaXMud29yZChcInN0cmluZ1wiKTtcbn1cbmZ1bmN0aW9uIFRTU3ltYm9sS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwic3ltYm9sXCIpO1xufVxuZnVuY3Rpb24gVFNWb2lkS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwidm9pZFwiKTtcbn1cbmZ1bmN0aW9uIFRTVW5kZWZpbmVkS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwidW5kZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24gVFNOdWxsS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwibnVsbFwiKTtcbn1cbmZ1bmN0aW9uIFRTTmV2ZXJLZXl3b3JkKCkge1xuICB0aGlzLndvcmQoXCJuZXZlclwiKTtcbn1cbmZ1bmN0aW9uIFRTSW50cmluc2ljS2V5d29yZCgpIHtcbiAgdGhpcy53b3JkKFwiaW50cmluc2ljXCIpO1xufVxuZnVuY3Rpb24gVFNUaGlzVHlwZSgpIHtcbiAgdGhpcy53b3JkKFwidGhpc1wiKTtcbn1cbmZ1bmN0aW9uIFRTRnVuY3Rpb25UeXBlKG5vZGUpIHtcbiAgdGhpcy50c1ByaW50RnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShub2RlKTtcbn1cbmZ1bmN0aW9uIFRTQ29uc3RydWN0b3JUeXBlKG5vZGUpIHtcbiAgaWYgKG5vZGUuYWJzdHJhY3QpIHtcbiAgICB0aGlzLndvcmQoXCJhYnN0cmFjdFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwibmV3XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudHNQcmludEZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUobm9kZSk7XG59XG5mdW5jdGlvbiB0c1ByaW50RnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShub2RlKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9ID0gbm9kZTtcbiAgY29uc3QgcGFyYW1ldGVycyA9IG5vZGUucGFyYW1ldGVycztcbiAgdGhpcy5wcmludCh0eXBlUGFyYW1ldGVycyk7XG4gIHRoaXMudG9rZW5DaGFyKDQwKTtcbiAgdGhpcy5fcGFyYW1ldGVycyhwYXJhbWV0ZXJzLCBcIilcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgY29uc3QgcmV0dXJuVHlwZSA9IG5vZGUudHlwZUFubm90YXRpb247XG4gIHRoaXMucHJpbnQocmV0dXJuVHlwZSk7XG59XG5mdW5jdGlvbiBUU1R5cGVSZWZlcmVuY2Uobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUudHlwZU5hbWUsICEhbm9kZS50eXBlUGFyYW1ldGVycyk7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVycyk7XG59XG5mdW5jdGlvbiBUU1R5cGVQcmVkaWNhdGUobm9kZSkge1xuICBpZiAobm9kZS5hc3NlcnRzKSB7XG4gICAgdGhpcy53b3JkKFwiYXNzZXJ0c1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy5wcmludChub2RlLnBhcmFtZXRlck5hbWUpO1xuICBpZiAobm9kZS50eXBlQW5ub3RhdGlvbikge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJpc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChub2RlLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNUeXBlUXVlcnkobm9kZSkge1xuICB0aGlzLndvcmQoXCJ0eXBlb2ZcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJOYW1lKTtcbiAgaWYgKG5vZGUudHlwZVBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xuICB9XG59XG5mdW5jdGlvbiBUU1R5cGVMaXRlcmFsKG5vZGUpIHtcbiAgcHJpbnRCcmFjZWQodGhpcywgbm9kZSwgKCkgPT4gdGhpcy5wcmludEpvaW4obm9kZS5tZW1iZXJzLCB7XG4gICAgaW5kZW50OiB0cnVlLFxuICAgIHN0YXRlbWVudDogdHJ1ZVxuICB9KSk7XG59XG5mdW5jdGlvbiBUU0FycmF5VHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5lbGVtZW50VHlwZSwgdHJ1ZSk7XG4gIHRoaXMudG9rZW5DaGFyKDkxKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gVFNUdXBsZVR5cGUobm9kZSkge1xuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIHRoaXMucHJpbnRMaXN0KG5vZGUuZWxlbWVudFR5cGVzLCB7XG4gICAgcHJpbnRUcmFpbGluZ1NlcGFyYXRvcjogdGhpcy5zaG91bGRQcmludFRyYWlsaW5nQ29tbWEoXCJdXCIpXG4gIH0pO1xuICB0aGlzLnRva2VuQ2hhcig5Myk7XG59XG5mdW5jdGlvbiBUU09wdGlvbmFsVHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS50eXBlQW5ub3RhdGlvbik7XG4gIHRoaXMudG9rZW5DaGFyKDYzKTtcbn1cbmZ1bmN0aW9uIFRTUmVzdFR5cGUobm9kZSkge1xuICB0aGlzLnRva2VuKFwiLi4uXCIpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gVFNOYW1lZFR1cGxlTWVtYmVyKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmxhYmVsKTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHRoaXMudG9rZW5DaGFyKDYzKTtcbiAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQobm9kZS5lbGVtZW50VHlwZSk7XG59XG5mdW5jdGlvbiBUU1VuaW9uVHlwZShub2RlKSB7XG4gIHRzUHJpbnRVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZSh0aGlzLCBub2RlLCBcInxcIik7XG59XG5mdW5jdGlvbiBUU0ludGVyc2VjdGlvblR5cGUobm9kZSkge1xuICB0c1ByaW50VW5pb25PckludGVyc2VjdGlvblR5cGUodGhpcywgbm9kZSwgXCImXCIpO1xufVxuZnVuY3Rpb24gdHNQcmludFVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKHByaW50ZXIsIG5vZGUsIHNlcCkge1xuICB2YXIgX3ByaW50ZXIkdG9rZW5NYXA7XG4gIGxldCBoYXNMZWFkaW5nVG9rZW4gPSAwO1xuICBpZiAoKF9wcmludGVyJHRva2VuTWFwID0gcHJpbnRlci50b2tlbk1hcCkgIT0gbnVsbCAmJiBfcHJpbnRlciR0b2tlbk1hcC5zdGFydE1hdGNoZXMobm9kZSwgc2VwKSkge1xuICAgIGhhc0xlYWRpbmdUb2tlbiA9IDE7XG4gICAgcHJpbnRlci50b2tlbihzZXApO1xuICB9XG4gIHByaW50ZXIucHJpbnRKb2luKG5vZGUudHlwZXMsIHtcbiAgICBzZXBhcmF0b3IoaSkge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgICAgdGhpcy50b2tlbihzZXAsIG51bGwsIGkgKyBoYXNMZWFkaW5nVG9rZW4pO1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBUU0NvbmRpdGlvbmFsVHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5jaGVja1R5cGUpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMud29yZChcImV4dGVuZHNcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmV4dGVuZHNUeXBlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLnRydWVUeXBlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig1OCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmZhbHNlVHlwZSk7XG59XG5mdW5jdGlvbiBUU0luZmVyVHlwZShub2RlKSB7XG4gIHRoaXMud29yZChcImluZmVyXCIpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcik7XG59XG5mdW5jdGlvbiBUU1BhcmVudGhlc2l6ZWRUeXBlKG5vZGUpIHtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xuICB0aGlzLnRva2VuQ2hhcig0MSk7XG59XG5mdW5jdGlvbiBUU1R5cGVPcGVyYXRvcihub2RlKSB7XG4gIHRoaXMud29yZChub2RlLm9wZXJhdG9yKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG5vZGUudHlwZUFubm90YXRpb24pO1xufVxuZnVuY3Rpb24gVFNJbmRleGVkQWNjZXNzVHlwZShub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5vYmplY3RUeXBlLCB0cnVlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTEpO1xuICB0aGlzLnByaW50KG5vZGUuaW5kZXhUeXBlKTtcbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xufVxuZnVuY3Rpb24gVFNNYXBwZWRUeXBlKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIG5hbWVUeXBlLFxuICAgIG9wdGlvbmFsLFxuICAgIHJlYWRvbmx5LFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH0gPSBub2RlO1xuICB0aGlzLnRva2VuQ2hhcigxMjMpO1xuICBjb25zdCBleGl0ID0gdGhpcy5lbnRlckRlbGltaXRlZCgpO1xuICB0aGlzLnNwYWNlKCk7XG4gIGlmIChyZWFkb25seSkge1xuICAgIHRva2VuSWZQbHVzTWludXModGhpcywgcmVhZG9ubHkpO1xuICAgIHRoaXMud29yZChcInJlYWRvbmx5XCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnRva2VuQ2hhcig5MSk7XG4gIHtcbiAgICB0aGlzLndvcmQobm9kZS50eXBlUGFyYW1ldGVyLm5hbWUpO1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy53b3JkKFwiaW5cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAge1xuICAgIHRoaXMucHJpbnQobm9kZS50eXBlUGFyYW1ldGVyLmNvbnN0cmFpbnQpO1xuICB9XG4gIGlmIChuYW1lVHlwZSkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChuYW1lVHlwZSk7XG4gIH1cbiAgdGhpcy50b2tlbkNoYXIoOTMpO1xuICBpZiAob3B0aW9uYWwpIHtcbiAgICB0b2tlbklmUGx1c01pbnVzKHRoaXMsIG9wdGlvbmFsKTtcbiAgICB0aGlzLnRva2VuQ2hhcig2Myk7XG4gIH1cbiAgaWYgKHR5cGVBbm5vdGF0aW9uKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNTgpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50KHR5cGVBbm5vdGF0aW9uKTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIGV4aXQoKTtcbiAgdGhpcy50b2tlbkNoYXIoMTI1KTtcbn1cbmZ1bmN0aW9uIHRva2VuSWZQbHVzTWludXMoc2VsZiwgdG9rKSB7XG4gIGlmICh0b2sgIT09IHRydWUpIHtcbiAgICBzZWxmLnRva2VuKHRvayk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRTTGl0ZXJhbFR5cGUobm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUubGl0ZXJhbCk7XG59XG5mdW5jdGlvbiBUU0NsYXNzSW1wbGVtZW50cyhub2RlKSB7XG4gIHRoaXMucHJpbnQobm9kZS5leHByZXNzaW9uKTtcbiAgdGhpcy5wcmludChub2RlLnR5cGVQYXJhbWV0ZXJzKTtcbn1cbmZ1bmN0aW9uIFRTSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgZGVjbGFyZSxcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBleHRlbmRzOiBleHRlbmR6LFxuICAgIGJvZHlcbiAgfSA9IG5vZGU7XG4gIGlmIChkZWNsYXJlKSB7XG4gICAgdGhpcy53b3JkKFwiZGVjbGFyZVwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwiaW50ZXJmYWNlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoaWQpO1xuICB0aGlzLnByaW50KHR5cGVQYXJhbWV0ZXJzKTtcbiAgaWYgKGV4dGVuZHogIT0gbnVsbCAmJiBleHRlbmR6Lmxlbmd0aCkge1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLndvcmQoXCJleHRlbmRzXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgICB0aGlzLnByaW50TGlzdChleHRlbmR6KTtcbiAgfVxuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoYm9keSk7XG59XG5mdW5jdGlvbiBUU0ludGVyZmFjZUJvZHkobm9kZSkge1xuICBwcmludEJyYWNlZCh0aGlzLCBub2RlLCAoKSA9PiB0aGlzLnByaW50Sm9pbihub2RlLmJvZHksIHtcbiAgICBpbmRlbnQ6IHRydWUsXG4gICAgc3RhdGVtZW50OiB0cnVlXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIFRTVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgZGVjbGFyZSxcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9ID0gbm9kZTtcbiAgaWYgKGRlY2xhcmUpIHtcbiAgICB0aGlzLndvcmQoXCJkZWNsYXJlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLndvcmQoXCJ0eXBlXCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoaWQpO1xuICB0aGlzLnByaW50KHR5cGVQYXJhbWV0ZXJzKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludCh0eXBlQW5ub3RhdGlvbik7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBUU1R5cGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9ID0gbm9kZTtcbiAgdGhpcy5wcmludChleHByZXNzaW9uLCB0cnVlKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQodHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiID8gXCJhc1wiIDogXCJzYXRpc2ZpZXNcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludCh0eXBlQW5ub3RhdGlvbik7XG59XG5mdW5jdGlvbiBUU1R5cGVBc3NlcnRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgZXhwcmVzc2lvblxuICB9ID0gbm9kZTtcbiAgdGhpcy50b2tlbkNoYXIoNjApO1xuICB0aGlzLnByaW50KHR5cGVBbm5vdGF0aW9uKTtcbiAgdGhpcy50b2tlbkNoYXIoNjIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoZXhwcmVzc2lvbik7XG59XG5mdW5jdGlvbiBUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnByaW50KG5vZGUudHlwZVBhcmFtZXRlcnMpO1xufVxuZnVuY3Rpb24gVFNFbnVtRGVjbGFyYXRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgZGVjbGFyZSxcbiAgICBjb25zdDogaXNDb25zdCxcbiAgICBpZCxcbiAgICBtZW1iZXJzXG4gIH0gPSBub2RlO1xuICBpZiAoZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmIChpc0NvbnN0KSB7XG4gICAgdGhpcy53b3JkKFwiY29uc3RcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIHRoaXMud29yZChcImVudW1cIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChpZCk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgcHJpbnRCcmFjZWQodGhpcywgbm9kZSwgKCkgPT4ge1xuICAgIHZhciBfdGhpcyRzaG91bGRQcmludFRyYWk7XG4gICAgcmV0dXJuIHRoaXMucHJpbnRMaXN0KG1lbWJlcnMsIHtcbiAgICAgIGluZGVudDogdHJ1ZSxcbiAgICAgIHN0YXRlbWVudDogdHJ1ZSxcbiAgICAgIHByaW50VHJhaWxpbmdTZXBhcmF0b3I6IChfdGhpcyRzaG91bGRQcmludFRyYWkgPSB0aGlzLnNob3VsZFByaW50VHJhaWxpbmdDb21tYShcIn1cIikpICE9IG51bGwgPyBfdGhpcyRzaG91bGRQcmludFRyYWkgOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gVFNFbnVtTWVtYmVyKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIGluaXRpYWxpemVyXG4gIH0gPSBub2RlO1xuICB0aGlzLnByaW50KGlkKTtcbiAgaWYgKGluaXRpYWxpemVyKSB7XG4gICAgdGhpcy5zcGFjZSgpO1xuICAgIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gICAgdGhpcy5wcmludChpbml0aWFsaXplcik7XG4gIH1cbn1cbmZ1bmN0aW9uIFRTTW9kdWxlRGVjbGFyYXRpb24obm9kZSkge1xuICBjb25zdCB7XG4gICAgZGVjbGFyZSxcbiAgICBpZCxcbiAgICBraW5kXG4gIH0gPSBub2RlO1xuICBpZiAoZGVjbGFyZSkge1xuICAgIHRoaXMud29yZChcImRlY2xhcmVcIik7XG4gICAgdGhpcy5zcGFjZSgpO1xuICB9XG4gIGlmICghbm9kZS5nbG9iYWwpIHtcbiAgICB0aGlzLndvcmQoa2luZCAhPSBudWxsID8ga2luZCA6IGlkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gXCJuYW1lc3BhY2VcIiA6IFwibW9kdWxlXCIpO1xuICAgIHRoaXMuc3BhY2UoKTtcbiAgfVxuICB0aGlzLnByaW50KGlkKTtcbiAgaWYgKCFub2RlLmJvZHkpIHtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYm9keSA9IG5vZGUuYm9keTtcbiAgd2hpbGUgKGJvZHkudHlwZSA9PT0gXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpIHtcbiAgICB0aGlzLnRva2VuQ2hhcig0Nik7XG4gICAgdGhpcy5wcmludChib2R5LmlkKTtcbiAgICBib2R5ID0gYm9keS5ib2R5O1xuICB9XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChib2R5KTtcbn1cbmZ1bmN0aW9uIFRTTW9kdWxlQmxvY2sobm9kZSkge1xuICBwcmludEJyYWNlZCh0aGlzLCBub2RlLCAoKSA9PiB0aGlzLnByaW50U2VxdWVuY2Uobm9kZS5ib2R5LCB7XG4gICAgaW5kZW50OiB0cnVlXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIFRTSW1wb3J0VHlwZShub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBhcmd1bWVudCxcbiAgICBxdWFsaWZpZXIsXG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfSA9IG5vZGU7XG4gIHRoaXMud29yZChcImltcG9ydFwiKTtcbiAgdGhpcy50b2tlbkNoYXIoNDApO1xuICB0aGlzLnByaW50KGFyZ3VtZW50KTtcbiAgdGhpcy50b2tlbkNoYXIoNDEpO1xuICBpZiAocXVhbGlmaWVyKSB7XG4gICAgdGhpcy50b2tlbkNoYXIoNDYpO1xuICAgIHRoaXMucHJpbnQocXVhbGlmaWVyKTtcbiAgfVxuICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICB0aGlzLnByaW50KHR5cGVQYXJhbWV0ZXJzKTtcbiAgfVxufVxuZnVuY3Rpb24gVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlKSB7XG4gIGNvbnN0IHtcbiAgICBpc0V4cG9ydCxcbiAgICBpZCxcbiAgICBtb2R1bGVSZWZlcmVuY2VcbiAgfSA9IG5vZGU7XG4gIGlmIChpc0V4cG9ydCkge1xuICAgIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgdGhpcy53b3JkKFwiaW1wb3J0XCIpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMucHJpbnQoaWQpO1xuICB0aGlzLnNwYWNlKCk7XG4gIHRoaXMudG9rZW5DaGFyKDYxKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnByaW50KG1vZHVsZVJlZmVyZW5jZSk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG59XG5mdW5jdGlvbiBUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUpIHtcbiAgdGhpcy50b2tlbihcInJlcXVpcmUoXCIpO1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIHRoaXMudG9rZW5DaGFyKDQxKTtcbn1cbmZ1bmN0aW9uIFRTTm9uTnVsbEV4cHJlc3Npb24obm9kZSkge1xuICB0aGlzLnByaW50KG5vZGUuZXhwcmVzc2lvbik7XG4gIHRoaXMudG9rZW5DaGFyKDMzKTtcbn1cbmZ1bmN0aW9uIFRTRXhwb3J0QXNzaWdubWVudChub2RlKSB7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLnRva2VuQ2hhcig2MSk7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmV4cHJlc3Npb24pO1xuICB0aGlzLnNlbWljb2xvbigpO1xufVxuZnVuY3Rpb24gVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gIHRoaXMud29yZChcImV4cG9ydFwiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJhc1wiKTtcbiAgdGhpcy5zcGFjZSgpO1xuICB0aGlzLndvcmQoXCJuYW1lc3BhY2VcIik7XG4gIHRoaXMuc3BhY2UoKTtcbiAgdGhpcy5wcmludChub2RlLmlkKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbn1cbmZ1bmN0aW9uIHRzUHJpbnRTaWduYXR1cmVEZWNsYXJhdGlvbkJhc2Uobm9kZSkge1xuICBjb25zdCB7XG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfSA9IG5vZGU7XG4gIGNvbnN0IHBhcmFtZXRlcnMgPSBub2RlLnBhcmFtZXRlcnM7XG4gIHRoaXMucHJpbnQodHlwZVBhcmFtZXRlcnMpO1xuICB0aGlzLnRva2VuQ2hhcig0MCk7XG4gIHRoaXMuX3BhcmFtZXRlcnMocGFyYW1ldGVycywgXCIpXCIpO1xuICBjb25zdCByZXR1cm5UeXBlID0gbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgdGhpcy5wcmludChyZXR1cm5UeXBlKTtcbn1cbmZ1bmN0aW9uIHRzUHJpbnRDbGFzc01lbWJlck1vZGlmaWVycyhub2RlKSB7XG4gIGNvbnN0IGlzRmllbGQgPSBub2RlLnR5cGUgPT09IFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIgfHwgbm9kZS50eXBlID09PSBcIkNsYXNzUHJvcGVydHlcIjtcbiAgcHJpbnRNb2RpZmllcnNMaXN0KHRoaXMsIG5vZGUsIFtpc0ZpZWxkICYmIG5vZGUuZGVjbGFyZSAmJiBcImRlY2xhcmVcIiwgbm9kZS5hY2Nlc3NpYmlsaXR5XSk7XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHRoaXMud29yZChcInN0YXRpY1wiKTtcbiAgICB0aGlzLnNwYWNlKCk7XG4gIH1cbiAgcHJpbnRNb2RpZmllcnNMaXN0KHRoaXMsIG5vZGUsIFtub2RlLm92ZXJyaWRlICYmIFwib3ZlcnJpZGVcIiwgbm9kZS5hYnN0cmFjdCAmJiBcImFic3RyYWN0XCIsIGlzRmllbGQgJiYgbm9kZS5yZWFkb25seSAmJiBcInJlYWRvbmx5XCJdKTtcbn1cbmZ1bmN0aW9uIHByaW50QnJhY2VkKHByaW50ZXIsIG5vZGUsIGNiKSB7XG4gIHByaW50ZXIudG9rZW4oXCJ7XCIpO1xuICBjb25zdCBleGl0ID0gcHJpbnRlci5lbnRlckRlbGltaXRlZCgpO1xuICBjYigpO1xuICBleGl0KCk7XG4gIHByaW50ZXIucmlnaHRCcmFjZShub2RlKTtcbn1cbmZ1bmN0aW9uIHByaW50TW9kaWZpZXJzTGlzdChwcmludGVyLCBub2RlLCBtb2RpZmllcnMpIHtcbiAgdmFyIF9wcmludGVyJHRva2VuTWFwMjtcbiAgY29uc3QgbW9kaWZpZXJzU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IG1vZGlmaWVyIG9mIG1vZGlmaWVycykge1xuICAgIGlmIChtb2RpZmllcikgbW9kaWZpZXJzU2V0LmFkZChtb2RpZmllcik7XG4gIH1cbiAgKF9wcmludGVyJHRva2VuTWFwMiA9IHByaW50ZXIudG9rZW5NYXApID09IG51bGwgfHwgX3ByaW50ZXIkdG9rZW5NYXAyLmZpbmQobm9kZSwgdG9rID0+IHtcbiAgICBpZiAobW9kaWZpZXJzU2V0Lmhhcyh0b2sudmFsdWUpKSB7XG4gICAgICBwcmludGVyLnRva2VuKHRvay52YWx1ZSk7XG4gICAgICBwcmludGVyLnNwYWNlKCk7XG4gICAgICBtb2RpZmllcnNTZXQuZGVsZXRlKHRvay52YWx1ZSk7XG4gICAgICByZXR1cm4gbW9kaWZpZXJzU2V0LnNpemUgPT09IDA7XG4gICAgfVxuICB9KTtcbiAgZm9yIChjb25zdCBtb2RpZmllciBvZiBtb2RpZmllcnNTZXQpIHtcbiAgICBwcmludGVyLndvcmQobW9kaWZpZXIpO1xuICAgIHByaW50ZXIuc3BhY2UoKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlc2NyaXB0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9276\n')},78992:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = generate;\nvar _sourceMap = __webpack_require__(44068);\nvar _printer = __webpack_require__(66636);\nfunction normalizeOptions(code, opts, ast) {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== "string") {\n      throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");\n    }\n    if (!opts.retainLines) {\n      throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");\n    }\n    if (opts.compact && opts.compact !== "auto") {\n      throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");\n    }\n    if (opts.minified) {\n      throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");\n    }\n    if (opts.jsescOption) {\n      throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");\n    }\n    if (!Array.isArray(ast.tokens)) {\n      throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");\n    }\n  }\n  const format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: "  "\n    },\n    jsescOption: Object.assign({\n      quotes: "double",\n      wrap: true,\n      minimal: false\n    }, opts.jsescOption),\n    topicToken: opts.topicToken,\n    importAttributesKeyword: opts.importAttributesKeyword\n  };\n  {\n    var _opts$recordAndTupleS;\n    format.decoratorsBeforeExport = opts.decoratorsBeforeExport;\n    format.jsescOption.json = opts.jsonCompatibleStrings;\n    format.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";\n  }\n  if (format.minified) {\n    format.compact = true;\n    format.shouldPrintComment = format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment = format.shouldPrintComment || (value => format.comments || value.includes("@license") || value.includes("@preserve"));\n  }\n  if (format.compact === "auto") {\n    format.compact = typeof code === "string" && code.length > 500000;\n    if (format.compact) {\n      console.error("[BABEL] Note: The code generator has deoptimised the styling of " + `${opts.filename} as it exceeds the max of ${"500KB"}.`);\n    }\n  }\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n  const {\n    auxiliaryCommentBefore,\n    auxiliaryCommentAfter,\n    shouldPrintComment\n  } = format;\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n  return format;\n}\n{\n  exports.CodeGenerator = class CodeGenerator {\n    constructor(ast, opts = {}, code) {\n      this._ast = void 0;\n      this._format = void 0;\n      this._map = void 0;\n      this._ast = ast;\n      this._format = normalizeOptions(code, opts, ast);\n      this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n    }\n    generate() {\n      const printer = new _printer.default(this._format, this._map);\n      return printer.generate(this._ast);\n    }\n  };\n}\nfunction generate(ast, opts = {}, code) {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;\n  const printer = new _printer.default(format, map, ast.tokens, typeof code === "string" ? code : null);\n  return printer.generate(ast);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg5OTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxLQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLGVBQWUsMkJBQTJCLFFBQVE7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUJBQXFCO0FBQ3ZCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9pbmRleC5qcz9hM2YzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2VuZXJhdGU7XG52YXIgX3NvdXJjZU1hcCA9IHJlcXVpcmUoXCIuL3NvdXJjZS1tYXAuanNcIik7XG52YXIgX3ByaW50ZXIgPSByZXF1aXJlKFwiLi9wcmludGVyLmpzXCIpO1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhjb2RlLCBvcHRzLCBhc3QpIHtcbiAgaWYgKG9wdHMuZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0KSB7XG4gICAgaWYgKHR5cGVvZiBjb2RlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0YCByZXF1aXJlcyB0aGUgb3JpZ2luYWwgYGNvZGVgIHRvIGJlIHBhc3NlZCB0byBAYmFiZWwvZ2VuZXJhdG9yIGFzIGEgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAoIW9wdHMucmV0YWluTGluZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHBlcmltZW50YWxfcHJlc2VydmVGb3JtYXRgIHJlcXVpcmVzIGByZXRhaW5MaW5lc2AgdG8gYmUgc2V0IHRvIGB0cnVlYFwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29tcGFjdCAmJiBvcHRzLmNvbXBhY3QgIT09IFwiYXV0b1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0YCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBgY29tcGFjdGAgb3B0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAob3B0cy5taW5pZmllZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdGAgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYG1pbmlmaWVkYCBvcHRpb25cIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmpzZXNjT3B0aW9uKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0YCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBganNlc2NPcHRpb25gIG9wdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFzdC50b2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXhwZXJpbWVudGFsX3ByZXNlcnZlRm9ybWF0YCByZXF1aXJlcyB0aGUgQVNUIHRvIGhhdmUgYXR0YXRjaGVkIHRoZSB0b2tlbiBvZiB0aGUgaW5wdXQgY29kZS4gTWFrZSBzdXJlIHRvIGVuYWJsZSB0aGUgYHRva2VuczogdHJ1ZWAgcGFyc2VyIG9wdGlvbi5cIik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvcm1hdCA9IHtcbiAgICBhdXhpbGlhcnlDb21tZW50QmVmb3JlOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRCZWZvcmUsXG4gICAgYXV4aWxpYXJ5Q29tbWVudEFmdGVyOiBvcHRzLmF1eGlsaWFyeUNvbW1lbnRBZnRlcixcbiAgICBzaG91bGRQcmludENvbW1lbnQ6IG9wdHMuc2hvdWxkUHJpbnRDb21tZW50LFxuICAgIHByZXNlcnZlRm9ybWF0OiBvcHRzLmV4cGVyaW1lbnRhbF9wcmVzZXJ2ZUZvcm1hdCxcbiAgICByZXRhaW5MaW5lczogb3B0cy5yZXRhaW5MaW5lcyxcbiAgICByZXRhaW5GdW5jdGlvblBhcmVuczogb3B0cy5yZXRhaW5GdW5jdGlvblBhcmVucyxcbiAgICBjb21tZW50czogb3B0cy5jb21tZW50cyA9PSBudWxsIHx8IG9wdHMuY29tbWVudHMsXG4gICAgY29tcGFjdDogb3B0cy5jb21wYWN0LFxuICAgIG1pbmlmaWVkOiBvcHRzLm1pbmlmaWVkLFxuICAgIGNvbmNpc2U6IG9wdHMuY29uY2lzZSxcbiAgICBpbmRlbnQ6IHtcbiAgICAgIGFkanVzdE11bHRpbGluZUNvbW1lbnQ6IHRydWUsXG4gICAgICBzdHlsZTogXCIgIFwiXG4gICAgfSxcbiAgICBqc2VzY09wdGlvbjogT2JqZWN0LmFzc2lnbih7XG4gICAgICBxdW90ZXM6IFwiZG91YmxlXCIsXG4gICAgICB3cmFwOiB0cnVlLFxuICAgICAgbWluaW1hbDogZmFsc2VcbiAgICB9LCBvcHRzLmpzZXNjT3B0aW9uKSxcbiAgICB0b3BpY1Rva2VuOiBvcHRzLnRvcGljVG9rZW4sXG4gICAgaW1wb3J0QXR0cmlidXRlc0tleXdvcmQ6IG9wdHMuaW1wb3J0QXR0cmlidXRlc0tleXdvcmRcbiAgfTtcbiAge1xuICAgIHZhciBfb3B0cyRyZWNvcmRBbmRUdXBsZVM7XG4gICAgZm9ybWF0LmRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBvcHRzLmRlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG4gICAgZm9ybWF0LmpzZXNjT3B0aW9uLmpzb24gPSBvcHRzLmpzb25Db21wYXRpYmxlU3RyaW5ncztcbiAgICBmb3JtYXQucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlID0gKF9vcHRzJHJlY29yZEFuZFR1cGxlUyA9IG9wdHMucmVjb3JkQW5kVHVwbGVTeW50YXhUeXBlKSAhPSBudWxsID8gX29wdHMkcmVjb3JkQW5kVHVwbGVTIDogXCJoYXNoXCI7XG4gIH1cbiAgaWYgKGZvcm1hdC5taW5pZmllZCkge1xuICAgIGZvcm1hdC5jb21wYWN0ID0gdHJ1ZTtcbiAgICBmb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50ID0gZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCB8fCAoKCkgPT4gZm9ybWF0LmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JtYXQuc2hvdWxkUHJpbnRDb21tZW50ID0gZm9ybWF0LnNob3VsZFByaW50Q29tbWVudCB8fCAodmFsdWUgPT4gZm9ybWF0LmNvbW1lbnRzIHx8IHZhbHVlLmluY2x1ZGVzKFwiQGxpY2Vuc2VcIikgfHwgdmFsdWUuaW5jbHVkZXMoXCJAcHJlc2VydmVcIikpO1xuICB9XG4gIGlmIChmb3JtYXQuY29tcGFjdCA9PT0gXCJhdXRvXCIpIHtcbiAgICBmb3JtYXQuY29tcGFjdCA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiICYmIGNvZGUubGVuZ3RoID4gNTAwMDAwO1xuICAgIGlmIChmb3JtYXQuY29tcGFjdCkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltCQUJFTF0gTm90ZTogVGhlIGNvZGUgZ2VuZXJhdG9yIGhhcyBkZW9wdGltaXNlZCB0aGUgc3R5bGluZyBvZiBcIiArIGAke29wdHMuZmlsZW5hbWV9IGFzIGl0IGV4Y2VlZHMgdGhlIG1heCBvZiAke1wiNTAwS0JcIn0uYCk7XG4gICAgfVxuICB9XG4gIGlmIChmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQucHJlc2VydmVGb3JtYXQpIHtcbiAgICBmb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCB7XG4gICAgYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSxcbiAgICBhdXhpbGlhcnlDb21tZW50QWZ0ZXIsXG4gICAgc2hvdWxkUHJpbnRDb21tZW50XG4gIH0gPSBmb3JtYXQ7XG4gIGlmIChhdXhpbGlhcnlDb21tZW50QmVmb3JlICYmICFzaG91bGRQcmludENvbW1lbnQoYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSkpIHtcbiAgICBmb3JtYXQuYXV4aWxpYXJ5Q29tbWVudEJlZm9yZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoYXV4aWxpYXJ5Q29tbWVudEFmdGVyICYmICFzaG91bGRQcmludENvbW1lbnQoYXV4aWxpYXJ5Q29tbWVudEFmdGVyKSkge1xuICAgIGZvcm1hdC5hdXhpbGlhcnlDb21tZW50QWZ0ZXIgPSB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdDtcbn1cbntcbiAgZXhwb3J0cy5Db2RlR2VuZXJhdG9yID0gY2xhc3MgQ29kZUdlbmVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYXN0LCBvcHRzID0ge30sIGNvZGUpIHtcbiAgICAgIHRoaXMuX2FzdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2Zvcm1hdCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX21hcCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuX2FzdCA9IGFzdDtcbiAgICAgIHRoaXMuX2Zvcm1hdCA9IG5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cywgYXN0KTtcbiAgICAgIHRoaXMuX21hcCA9IG9wdHMuc291cmNlTWFwcyA/IG5ldyBfc291cmNlTWFwLmRlZmF1bHQob3B0cywgY29kZSkgOiBudWxsO1xuICAgIH1cbiAgICBnZW5lcmF0ZSgpIHtcbiAgICAgIGNvbnN0IHByaW50ZXIgPSBuZXcgX3ByaW50ZXIuZGVmYXVsdCh0aGlzLl9mb3JtYXQsIHRoaXMuX21hcCk7XG4gICAgICByZXR1cm4gcHJpbnRlci5nZW5lcmF0ZSh0aGlzLl9hc3QpO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlKGFzdCwgb3B0cyA9IHt9LCBjb2RlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG5vcm1hbGl6ZU9wdGlvbnMoY29kZSwgb3B0cywgYXN0KTtcbiAgY29uc3QgbWFwID0gb3B0cy5zb3VyY2VNYXBzID8gbmV3IF9zb3VyY2VNYXAuZGVmYXVsdChvcHRzLCBjb2RlKSA6IG51bGw7XG4gIGNvbnN0IHByaW50ZXIgPSBuZXcgX3ByaW50ZXIuZGVmYXVsdChmb3JtYXQsIG1hcCwgYXN0LnRva2VucywgdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBjb2RlIDogbnVsbCk7XG4gIHJldHVybiBwcmludGVyLmdlbmVyYXRlKGFzdCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78992\n')},31373:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TokenContext = void 0;\nexports.isLastChild = isLastChild;\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\nvar whitespace = __webpack_require__(42716);\nvar parens = __webpack_require__(11773);\nvar _t = __webpack_require__(2352);\nconst {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression\n} = _t;\nconst TokenContext = exports.TokenContext = {\n  expressionStatement: 1,\n  arrowBody: 2,\n  exportDefault: 4,\n  forHead: 8,\n  forInHead: 16,\n  forOfHead: 32,\n  arrowFlowReturnType: 64\n};\nfunction expandAliases(obj) {\n  const map = new Map();\n  function add(type, func) {\n    const fn = map.get(type);\n    map.set(type, fn ? function (node, parent, stack, inForInit, getRawIdentifier) {\n      var _fn;\n      return (_fn = fn(node, parent, stack, inForInit, getRawIdentifier)) != null ? _fn : func(node, parent, stack, inForInit, getRawIdentifier);\n    } : func);\n  }\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n  return map;\n}\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\nfunction needsWhitespace(node, parent, type) {\n  var _expandedWhitespaceNo;\n  if (!node) return false;\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n  const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node.type)) == null ? void 0 : _expandedWhitespaceNo(node, parent);\n  if (typeof flag === "number") {\n    return (flag & type) !== 0;\n  }\n  return false;\n}\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\nfunction needsParens(node, parent, tokenContext, inForInit, getRawIdentifier) {\n  var _expandedParens$get;\n  if (!parent) return false;\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n  if (isDecorator(parent)) {\n    return !isDecoratorMemberExpression(node) && !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) && !isParenthesizedExpression(node);\n  }\n  return (_expandedParens$get = expandedParens.get(node.type)) == null ? void 0 : _expandedParens$get(node, parent, tokenContext, inForInit, getRawIdentifier);\n}\nfunction isDecoratorMemberExpression(node) {\n  switch (node.type) {\n    case "Identifier":\n      return true;\n    case "MemberExpression":\n      return !node.computed && node.property.type === "Identifier" && isDecoratorMemberExpression(node.object);\n    default:\n      return false;\n  }\n}\nfunction isLastChild(parent, child) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = parent[visitorKeys[i]];\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEzNzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsS0FBaUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLEtBQWtCO0FBQ3ZDLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL25vZGUvaW5kZXguanM/YjkyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuVG9rZW5Db250ZXh0ID0gdm9pZCAwO1xuZXhwb3J0cy5pc0xhc3RDaGlsZCA9IGlzTGFzdENoaWxkO1xuZXhwb3J0cy5uZWVkc1BhcmVucyA9IG5lZWRzUGFyZW5zO1xuZXhwb3J0cy5uZWVkc1doaXRlc3BhY2UgPSBuZWVkc1doaXRlc3BhY2U7XG5leHBvcnRzLm5lZWRzV2hpdGVzcGFjZUFmdGVyID0gbmVlZHNXaGl0ZXNwYWNlQWZ0ZXI7XG5leHBvcnRzLm5lZWRzV2hpdGVzcGFjZUJlZm9yZSA9IG5lZWRzV2hpdGVzcGFjZUJlZm9yZTtcbnZhciB3aGl0ZXNwYWNlID0gcmVxdWlyZShcIi4vd2hpdGVzcGFjZS5qc1wiKTtcbnZhciBwYXJlbnMgPSByZXF1aXJlKFwiLi9wYXJlbnRoZXNlcy5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIEZMSVBQRURfQUxJQVNfS0VZUyxcbiAgVklTSVRPUl9LRVlTLFxuICBpc0NhbGxFeHByZXNzaW9uLFxuICBpc0RlY29yYXRvcixcbiAgaXNFeHByZXNzaW9uU3RhdGVtZW50LFxuICBpc01lbWJlckV4cHJlc3Npb24sXG4gIGlzTmV3RXhwcmVzc2lvbixcbiAgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvblxufSA9IF90O1xuY29uc3QgVG9rZW5Db250ZXh0ID0gZXhwb3J0cy5Ub2tlbkNvbnRleHQgPSB7XG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQ6IDEsXG4gIGFycm93Qm9keTogMixcbiAgZXhwb3J0RGVmYXVsdDogNCxcbiAgZm9ySGVhZDogOCxcbiAgZm9ySW5IZWFkOiAxNixcbiAgZm9yT2ZIZWFkOiAzMixcbiAgYXJyb3dGbG93UmV0dXJuVHlwZTogNjRcbn07XG5mdW5jdGlvbiBleHBhbmRBbGlhc2VzKG9iaikge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGFkZCh0eXBlLCBmdW5jKSB7XG4gICAgY29uc3QgZm4gPSBtYXAuZ2V0KHR5cGUpO1xuICAgIG1hcC5zZXQodHlwZSwgZm4gPyBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBzdGFjaywgaW5Gb3JJbml0LCBnZXRSYXdJZGVudGlmaWVyKSB7XG4gICAgICB2YXIgX2ZuO1xuICAgICAgcmV0dXJuIChfZm4gPSBmbihub2RlLCBwYXJlbnQsIHN0YWNrLCBpbkZvckluaXQsIGdldFJhd0lkZW50aWZpZXIpKSAhPSBudWxsID8gX2ZuIDogZnVuYyhub2RlLCBwYXJlbnQsIHN0YWNrLCBpbkZvckluaXQsIGdldFJhd0lkZW50aWZpZXIpO1xuICAgIH0gOiBmdW5jKTtcbiAgfVxuICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMob2JqKSkge1xuICAgIGNvbnN0IGFsaWFzZXMgPSBGTElQUEVEX0FMSUFTX0tFWVNbdHlwZV07XG4gICAgaWYgKGFsaWFzZXMpIHtcbiAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgICBhZGQoYWxpYXMsIG9ialt0eXBlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZCh0eXBlLCBvYmpbdHlwZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWFwO1xufVxuY29uc3QgZXhwYW5kZWRQYXJlbnMgPSBleHBhbmRBbGlhc2VzKHBhcmVucyk7XG5jb25zdCBleHBhbmRlZFdoaXRlc3BhY2VOb2RlcyA9IGV4cGFuZEFsaWFzZXMod2hpdGVzcGFjZS5ub2Rlcyk7XG5mdW5jdGlvbiBpc09ySGFzQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICBpZiAoaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBpc01lbWJlckV4cHJlc3Npb24obm9kZSkgJiYgaXNPckhhc0NhbGxFeHByZXNzaW9uKG5vZGUub2JqZWN0KTtcbn1cbmZ1bmN0aW9uIG5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIHR5cGUpIHtcbiAgdmFyIF9leHBhbmRlZFdoaXRlc3BhY2VObztcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChpc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIGNvbnN0IGZsYWcgPSAoX2V4cGFuZGVkV2hpdGVzcGFjZU5vID0gZXhwYW5kZWRXaGl0ZXNwYWNlTm9kZXMuZ2V0KG5vZGUudHlwZSkpID09IG51bGwgPyB2b2lkIDAgOiBfZXhwYW5kZWRXaGl0ZXNwYWNlTm8obm9kZSwgcGFyZW50KTtcbiAgaWYgKHR5cGVvZiBmbGFnID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIChmbGFnICYgdHlwZSkgIT09IDA7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbmVlZHNXaGl0ZXNwYWNlQmVmb3JlKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gbmVlZHNXaGl0ZXNwYWNlKG5vZGUsIHBhcmVudCwgMSk7XG59XG5mdW5jdGlvbiBuZWVkc1doaXRlc3BhY2VBZnRlcihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIG5lZWRzV2hpdGVzcGFjZShub2RlLCBwYXJlbnQsIDIpO1xufVxuZnVuY3Rpb24gbmVlZHNQYXJlbnMobm9kZSwgcGFyZW50LCB0b2tlbkNvbnRleHQsIGluRm9ySW5pdCwgZ2V0UmF3SWRlbnRpZmllcikge1xuICB2YXIgX2V4cGFuZGVkUGFyZW5zJGdldDtcbiAgaWYgKCFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgaWYgKGlzTmV3RXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUpIHtcbiAgICBpZiAoaXNPckhhc0NhbGxFeHByZXNzaW9uKG5vZGUpKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNEZWNvcmF0b3IocGFyZW50KSkge1xuICAgIHJldHVybiAhaXNEZWNvcmF0b3JNZW1iZXJFeHByZXNzaW9uKG5vZGUpICYmICEoaXNDYWxsRXhwcmVzc2lvbihub2RlKSAmJiBpc0RlY29yYXRvck1lbWJlckV4cHJlc3Npb24obm9kZS5jYWxsZWUpKSAmJiAhaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcbiAgfVxuICByZXR1cm4gKF9leHBhbmRlZFBhcmVucyRnZXQgPSBleHBhbmRlZFBhcmVucy5nZXQobm9kZS50eXBlKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9leHBhbmRlZFBhcmVucyRnZXQobm9kZSwgcGFyZW50LCB0b2tlbkNvbnRleHQsIGluRm9ySW5pdCwgZ2V0UmF3SWRlbnRpZmllcik7XG59XG5mdW5jdGlvbiBpc0RlY29yYXRvck1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuICFub2RlLmNvbXB1dGVkICYmIG5vZGUucHJvcGVydHkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgaXNEZWNvcmF0b3JNZW1iZXJFeHByZXNzaW9uKG5vZGUub2JqZWN0KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0xhc3RDaGlsZChwYXJlbnQsIGNoaWxkKSB7XG4gIGNvbnN0IHZpc2l0b3JLZXlzID0gVklTSVRPUl9LRVlTW3BhcmVudC50eXBlXTtcbiAgZm9yIChsZXQgaSA9IHZpc2l0b3JLZXlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgdmFsID0gcGFyZW50W3Zpc2l0b3JLZXlzW2ldXTtcbiAgICBpZiAodmFsID09PSBjaGlsZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGxldCBqID0gdmFsLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaiA+PSAwICYmIHZhbFtqXSA9PT0gbnVsbCkgai0tO1xuICAgICAgcmV0dXJuIGogPj0gMCAmJiB2YWxbal0gPT09IGNoaWxkO1xuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///31373\n')},11773:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ArrowFunctionExpression = exports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.UnaryLike = exports.TSTypeAssertion = UnaryLike;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\nvar _t = __webpack_require__(2352);\nvar _index = __webpack_require__(31373);\nconst {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement\n} = _t;\nconst PRECEDENCE = new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);\nfunction getBinaryPrecedence(node, nodeType) {\n  if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {\n    return PRECEDENCE.get(node.operator);\n  }\n  if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {\n    return PRECEDENCE.get("in");\n  }\n}\nfunction isTSTypeExpression(nodeType) {\n  return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";\n}\nconst isClassExtendsClause = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node;\n};\nconst hasPostfixPart = (node, parent) => {\n  const parentType = parent.type;\n  return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node || parentType === "TaggedTemplateExpression" && parent.tag === node || parentType === "TSNonNullExpression";\n};\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\nfunction FunctionTypeAnnotation(node, parent, tokenContext) {\n  const parentType = parent.type;\n  return (parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType)\n  );\n}\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\nfunction needsParenBeforeExpressionBrace(tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));\n}\nfunction ObjectExpression(node, parent, tokenContext) {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\nfunction DoExpression(node, parent, tokenContext) {\n  return !node.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);\n}\nfunction Binary(node, parent) {\n  const parentType = parent.type;\n  if (node.type === "BinaryExpression" && node.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {\n    return parent.left === node;\n  }\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n  if (hasPostfixPart(node, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {\n    return true;\n  }\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node || parentPos > nodePos) {\n      return true;\n    }\n  }\n  return undefined;\n}\nfunction UnionTypeAnnotation(node, parent) {\n  const parentType = parent.type;\n  return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";\n}\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\nfunction TSAsExpression(node, parent) {\n  if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node) {\n    return true;\n  }\n  if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node === parent.left) {\n    return true;\n  }\n  return Binary(node, parent);\n}\nfunction TSUnionType(node, parent) {\n  const parentType = parent.type;\n  return parentType === "TSArrayType" || parentType === "TSOptionalType" || parentType === "TSIntersectionType" || parentType === "TSRestType";\n}\nfunction TSInferType(node, parent) {\n  const parentType = parent.type;\n  return parentType === "TSArrayType" || parentType === "TSOptionalType";\n}\nfunction TSInstantiationExpression(node, parent) {\n  const parentType = parent.type;\n  return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;\n}\nfunction BinaryExpression(node, parent, tokenContext, inForStatementInit) {\n  return node.operator === "in" && inForStatementInit;\n}\nfunction SequenceExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node || parentType === "OptionalMemberExpression" && parent.property === node || parentType === "TemplateLiteral") {\n    return false;\n  }\n  if (parentType === "ClassDeclaration") {\n    return true;\n  }\n  if (parentType === "ForOfStatement") {\n    return parent.right === node;\n  }\n  if (parentType === "ExportDefaultDeclaration") {\n    return true;\n  }\n  return !isStatement(parent);\n}\nfunction YieldExpression(node, parent) {\n  const parentType = parent.type;\n  return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node, parent) || parentType === "AwaitExpression" && isYieldExpression(node) || parentType === "ConditionalExpression" && node === parent.test || isClassExtendsClause(node, parent) || isTSTypeExpression(parentType);\n}\nfunction ClassExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node || isClassExtendsClause(node, parent);\n}\nfunction FunctionExpression(node, parent, tokenContext) {\n  return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));\n}\nfunction ConditionalExpression(node, parent) {\n  const parentType = parent.type;\n  if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {\n    return true;\n  }\n  return UnaryLike(node, parent);\n}\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent) && parent.callee === node || isMemberExpression(parent) && parent.object === node;\n}\nfunction AssignmentExpression(node, parent, tokenContext) {\n  if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\nfunction LogicalExpression(node, parent) {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== "LogicalExpression") return false;\n  switch (node.operator) {\n    case "||":\n      return parent.operator === "??" || parent.operator === "&&";\n    case "&&":\n      return parent.operator === "??";\n    case "??":\n      return parent.operator !== "??";\n  }\n}\nfunction Identifier(node, parent, tokenContext, _inForInit, getRawIdentifier) {\n  var _node$extra;\n  const parentType = parent.type;\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node) {\n    const rightType = parent.right.type;\n    if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {\n      return true;\n    }\n  }\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n  if (node.name === "let") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {\n      return true;\n    }\n    return Boolean(tokenContext & _index.TokenContext.forOfHead);\n  }\n  return node.name === "async" && isForOfStatement(parent, {\n    left: node,\n    await: false\n  });\n}\n\n//# sourceMappingURL=parentheses.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3NzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNEJBQTRCO0FBQzVCLGNBQWM7QUFDZCx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLCtCQUErQixHQUFHLDZCQUE2QjtBQUMvRCxvQkFBb0I7QUFDcEIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5Qix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLDhCQUE4QixHQUFHLGdDQUFnQztBQUNqRSwwQkFBMEI7QUFDMUIsNkJBQTZCLEdBQUcsc0JBQXNCO0FBQ3RELG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakMsaUJBQWlCLEdBQUcsdUJBQXVCO0FBQzNDLDBCQUEwQixHQUFHLG1CQUFtQjtBQUNoRCxrQ0FBa0MsR0FBRywyQkFBMkI7QUFDaEUsd0JBQXdCO0FBQ3hCLHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixhQUFhLG1CQUFPLENBQUMsS0FBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9nZW5lcmF0b3IvbGliL25vZGUvcGFyZW50aGVzZXMuanM/MzY3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQXNzaWdubWVudEV4cHJlc3Npb24gPSBBc3NpZ25tZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuQ2xhc3NFeHByZXNzaW9uID0gQ2xhc3NFeHByZXNzaW9uO1xuZXhwb3J0cy5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5Eb0V4cHJlc3Npb24gPSBEb0V4cHJlc3Npb247XG5leHBvcnRzLkZ1bmN0aW9uRXhwcmVzc2lvbiA9IEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuRnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IEZ1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLklkZW50aWZpZXIgPSBJZGVudGlmaWVyO1xuZXhwb3J0cy5Mb2dpY2FsRXhwcmVzc2lvbiA9IExvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5OdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gTnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuT2JqZWN0RXhwcmVzc2lvbiA9IE9iamVjdEV4cHJlc3Npb247XG5leHBvcnRzLk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUgPSBPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5PcHRpb25hbENhbGxFeHByZXNzaW9uID0gZXhwb3J0cy5PcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBPcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLlNlcXVlbmNlRXhwcmVzc2lvbiA9IFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNTYXRpc2ZpZXNFeHByZXNzaW9uID0gZXhwb3J0cy5UU0FzRXhwcmVzc2lvbiA9IFRTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5UU0luZmVyVHlwZSA9IFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuVW5hcnlMaWtlID0gZXhwb3J0cy5UU1R5cGVBc3NlcnRpb24gPSBVbmFyeUxpa2U7XG5leHBvcnRzLlRTSW50ZXJzZWN0aW9uVHlwZSA9IGV4cG9ydHMuVFNVbmlvblR5cGUgPSBUU1VuaW9uVHlwZTtcbmV4cG9ydHMuSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBleHBvcnRzLlVuaW9uVHlwZUFubm90YXRpb24gPSBVbmlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5VcGRhdGVFeHByZXNzaW9uID0gVXBkYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuQXdhaXRFeHByZXNzaW9uID0gZXhwb3J0cy5ZaWVsZEV4cHJlc3Npb24gPSBZaWVsZEV4cHJlc3Npb247XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0FycmF5VHlwZUFubm90YXRpb24sXG4gIGlzQmluYXJ5RXhwcmVzc2lvbixcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNGb3JPZlN0YXRlbWVudCxcbiAgaXNJbmRleGVkQWNjZXNzVHlwZSxcbiAgaXNNZW1iZXJFeHByZXNzaW9uLFxuICBpc09iamVjdFBhdHRlcm4sXG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uLFxuICBpc1lpZWxkRXhwcmVzc2lvbixcbiAgaXNTdGF0ZW1lbnRcbn0gPSBfdDtcbmNvbnN0IFBSRUNFREVOQ0UgPSBuZXcgTWFwKFtbXCJ8fFwiLCAwXSwgW1wiPz9cIiwgMF0sIFtcInw+XCIsIDBdLCBbXCImJlwiLCAxXSwgW1wifFwiLCAyXSwgW1wiXlwiLCAzXSwgW1wiJlwiLCA0XSwgW1wiPT1cIiwgNV0sIFtcIj09PVwiLCA1XSwgW1wiIT1cIiwgNV0sIFtcIiE9PVwiLCA1XSwgW1wiPFwiLCA2XSwgW1wiPlwiLCA2XSwgW1wiPD1cIiwgNl0sIFtcIj49XCIsIDZdLCBbXCJpblwiLCA2XSwgW1wiaW5zdGFuY2VvZlwiLCA2XSwgW1wiPj5cIiwgN10sIFtcIjw8XCIsIDddLCBbXCI+Pj5cIiwgN10sIFtcIitcIiwgOF0sIFtcIi1cIiwgOF0sIFtcIipcIiwgOV0sIFtcIi9cIiwgOV0sIFtcIiVcIiwgOV0sIFtcIioqXCIsIDEwXV0pO1xuZnVuY3Rpb24gZ2V0QmluYXJ5UHJlY2VkZW5jZShub2RlLCBub2RlVHlwZSkge1xuICBpZiAobm9kZVR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gUFJFQ0VERU5DRS5nZXQobm9kZS5vcGVyYXRvcik7XG4gIH1cbiAgaWYgKG5vZGVUeXBlID09PSBcIlRTQXNFeHByZXNzaW9uXCIgfHwgbm9kZVR5cGUgPT09IFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gUFJFQ0VERU5DRS5nZXQoXCJpblwiKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUU1R5cGVFeHByZXNzaW9uKG5vZGVUeXBlKSB7XG4gIHJldHVybiBub2RlVHlwZSA9PT0gXCJUU0FzRXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiIHx8IG5vZGVUeXBlID09PSBcIlRTVHlwZUFzc2VydGlvblwiO1xufVxuY29uc3QgaXNDbGFzc0V4dGVuZHNDbGF1c2UgPSAobm9kZSwgcGFyZW50KSA9PiB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgcmV0dXJuIChwYXJlbnRUeXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkNsYXNzRXhwcmVzc2lvblwiKSAmJiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcbn07XG5jb25zdCBoYXNQb3N0Zml4UGFydCA9IChub2RlLCBwYXJlbnQpID0+IHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gKHBhcmVudFR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGUgfHwgKHBhcmVudFR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk5ld0V4cHJlc3Npb25cIikgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiICYmIHBhcmVudC50YWcgPT09IG5vZGUgfHwgcGFyZW50VHlwZSA9PT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCI7XG59O1xuZnVuY3Rpb24gTnVsbGFibGVUeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGlzQXJyYXlUeXBlQW5ub3RhdGlvbihwYXJlbnQpO1xufVxuZnVuY3Rpb24gRnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIHJldHVybiAocGFyZW50VHlwZSA9PT0gXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiIHx8IEJvb2xlYW4odG9rZW5Db250ZXh0ICYgX2luZGV4LlRva2VuQ29udGV4dC5hcnJvd0Zsb3dSZXR1cm5UeXBlKVxuICApO1xufVxuZnVuY3Rpb24gVXBkYXRlRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGhhc1Bvc3RmaXhQYXJ0KG5vZGUsIHBhcmVudCkgfHwgaXNDbGFzc0V4dGVuZHNDbGF1c2Uobm9kZSwgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIG5lZWRzUGFyZW5CZWZvcmVFeHByZXNzaW9uQnJhY2UodG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiBCb29sZWFuKHRva2VuQ29udGV4dCAmIChfaW5kZXguVG9rZW5Db250ZXh0LmV4cHJlc3Npb25TdGF0ZW1lbnQgfCBfaW5kZXguVG9rZW5Db250ZXh0LmFycm93Qm9keSkpO1xufVxuZnVuY3Rpb24gT2JqZWN0RXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICByZXR1cm4gbmVlZHNQYXJlbkJlZm9yZUV4cHJlc3Npb25CcmFjZSh0b2tlbkNvbnRleHQpO1xufVxuZnVuY3Rpb24gRG9FeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0KSB7XG4gIHJldHVybiAhbm9kZS5hc3luYyAmJiBCb29sZWFuKHRva2VuQ29udGV4dCAmIF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudCk7XG59XG5mdW5jdGlvbiBCaW5hcnkobm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgJiYgbm9kZS5vcGVyYXRvciA9PT0gXCIqKlwiICYmIHBhcmVudFR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCIqKlwiKSB7XG4gICAgcmV0dXJuIHBhcmVudC5sZWZ0ID09PSBub2RlO1xuICB9XG4gIGlmIChpc0NsYXNzRXh0ZW5kc0NsYXVzZShub2RlLCBwYXJlbnQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGhhc1Bvc3RmaXhQYXJ0KG5vZGUsIHBhcmVudCkgfHwgcGFyZW50VHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCBwYXJlbnRUeXBlID09PSBcIkF3YWl0RXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcGFyZW50UG9zID0gZ2V0QmluYXJ5UHJlY2VkZW5jZShwYXJlbnQsIHBhcmVudFR5cGUpO1xuICBpZiAocGFyZW50UG9zICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlUG9zID0gZ2V0QmluYXJ5UHJlY2VkZW5jZShub2RlLCBub2RlLnR5cGUpO1xuICAgIGlmIChwYXJlbnRQb3MgPT09IG5vZGVQb3MgJiYgcGFyZW50VHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIgJiYgcGFyZW50LnJpZ2h0ID09PSBub2RlIHx8IHBhcmVudFBvcyA+IG5vZGVQb3MpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gVW5pb25UeXBlQW5ub3RhdGlvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gcGFyZW50VHlwZSA9PT0gXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiO1xufVxuZnVuY3Rpb24gT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZShub2RlLCBwYXJlbnQpIHtcbiAgcmV0dXJuIGlzSW5kZXhlZEFjY2Vzc1R5cGUocGFyZW50KSAmJiBwYXJlbnQub2JqZWN0VHlwZSA9PT0gbm9kZTtcbn1cbmZ1bmN0aW9uIFRTQXNFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKHBhcmVudC50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIgfHwgcGFyZW50LnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikgJiYgcGFyZW50LmxlZnQgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGFyZW50LnR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiICYmIChwYXJlbnQub3BlcmF0b3IgPT09IFwifFwiIHx8IHBhcmVudC5vcGVyYXRvciA9PT0gXCImXCIpICYmIG5vZGUgPT09IHBhcmVudC5sZWZ0KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIEJpbmFyeShub2RlLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gVFNVbmlvblR5cGUobm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgcmV0dXJuIHBhcmVudFR5cGUgPT09IFwiVFNBcnJheVR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTUmVzdFR5cGVcIjtcbn1cbmZ1bmN0aW9uIFRTSW5mZXJUeXBlKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIHJldHVybiBwYXJlbnRUeXBlID09PSBcIlRTQXJyYXlUeXBlXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJUU09wdGlvbmFsVHlwZVwiO1xufVxuZnVuY3Rpb24gVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbihub2RlLCBwYXJlbnQpIHtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICByZXR1cm4gKHBhcmVudFR5cGUgPT09IFwiQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIk5ld0V4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIikgJiYgISFwYXJlbnQudHlwZVBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBCaW5hcnlFeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0LCBpbkZvclN0YXRlbWVudEluaXQpIHtcbiAgcmV0dXJuIG5vZGUub3BlcmF0b3IgPT09IFwiaW5cIiAmJiBpbkZvclN0YXRlbWVudEluaXQ7XG59XG5mdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24obm9kZSwgcGFyZW50KSB7XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnQudHlwZTtcbiAgaWYgKHBhcmVudFR5cGUgPT09IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiICYmIHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSB8fCBwYXJlbnRUeXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwYXJlbnRUeXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXJlbnRUeXBlID09PSBcIkZvck9mU3RhdGVtZW50XCIpIHtcbiAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuICB9XG4gIGlmIChwYXJlbnRUeXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICFpc1N0YXRlbWVudChwYXJlbnQpO1xufVxuZnVuY3Rpb24gWWllbGRFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIHJldHVybiBwYXJlbnRUeXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgfHwgcGFyZW50VHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCBoYXNQb3N0Zml4UGFydChub2RlLCBwYXJlbnQpIHx8IHBhcmVudFR5cGUgPT09IFwiQXdhaXRFeHByZXNzaW9uXCIgJiYgaXNZaWVsZEV4cHJlc3Npb24obm9kZSkgfHwgcGFyZW50VHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiAmJiBub2RlID09PSBwYXJlbnQudGVzdCB8fCBpc0NsYXNzRXh0ZW5kc0NsYXVzZShub2RlLCBwYXJlbnQpIHx8IGlzVFNUeXBlRXhwcmVzc2lvbihwYXJlbnRUeXBlKTtcbn1cbmZ1bmN0aW9uIENsYXNzRXhwcmVzc2lvbihub2RlLCBwYXJlbnQsIHRva2VuQ29udGV4dCkge1xuICByZXR1cm4gQm9vbGVhbih0b2tlbkNvbnRleHQgJiAoX2luZGV4LlRva2VuQ29udGV4dC5leHByZXNzaW9uU3RhdGVtZW50IHwgX2luZGV4LlRva2VuQ29udGV4dC5leHBvcnREZWZhdWx0KSk7XG59XG5mdW5jdGlvbiBVbmFyeUxpa2Uobm9kZSwgcGFyZW50KSB7XG4gIHJldHVybiBoYXNQb3N0Zml4UGFydChub2RlLCBwYXJlbnQpIHx8IGlzQmluYXJ5RXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5vcGVyYXRvciA9PT0gXCIqKlwiICYmIHBhcmVudC5sZWZ0ID09PSBub2RlIHx8IGlzQ2xhc3NFeHRlbmRzQ2xhdXNlKG5vZGUsIHBhcmVudCk7XG59XG5mdW5jdGlvbiBGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgcGFyZW50LCB0b2tlbkNvbnRleHQpIHtcbiAgcmV0dXJuIEJvb2xlYW4odG9rZW5Db250ZXh0ICYgKF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwcmVzc2lvblN0YXRlbWVudCB8IF9pbmRleC5Ub2tlbkNvbnRleHQuZXhwb3J0RGVmYXVsdCkpO1xufVxuZnVuY3Rpb24gQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIGlmIChwYXJlbnRUeXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiIHx8IHBhcmVudFR5cGUgPT09IFwiQmluYXJ5RXhwcmVzc2lvblwiIHx8IHBhcmVudFR5cGUgPT09IFwiTG9naWNhbEV4cHJlc3Npb25cIiB8fCBwYXJlbnRUeXBlID09PSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiICYmIHBhcmVudC50ZXN0ID09PSBub2RlIHx8IHBhcmVudFR5cGUgPT09IFwiQXdhaXRFeHByZXNzaW9uXCIgfHwgaXNUU1R5cGVFeHByZXNzaW9uKHBhcmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFVuYXJ5TGlrZShub2RlLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICByZXR1cm4gaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQpICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGUgfHwgaXNNZW1iZXJFeHByZXNzaW9uKHBhcmVudCkgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbn1cbmZ1bmN0aW9uIEFzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0KSB7XG4gIGlmIChuZWVkc1BhcmVuQmVmb3JlRXhwcmVzc2lvbkJyYWNlKHRva2VuQ29udGV4dCkgJiYgaXNPYmplY3RQYXR0ZXJuKG5vZGUubGVmdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ29uZGl0aW9uYWxFeHByZXNzaW9uKG5vZGUsIHBhcmVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIExvZ2ljYWxFeHByZXNzaW9uKG5vZGUsIHBhcmVudCkge1xuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50LnR5cGU7XG4gIGlmIChpc1RTVHlwZUV4cHJlc3Npb24ocGFyZW50VHlwZSkpIHJldHVybiB0cnVlO1xuICBpZiAocGFyZW50VHlwZSAhPT0gXCJMb2dpY2FsRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS5vcGVyYXRvcikge1xuICAgIGNhc2UgXCJ8fFwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5vcGVyYXRvciA9PT0gXCI/P1wiIHx8IHBhcmVudC5vcGVyYXRvciA9PT0gXCImJlwiO1xuICAgIGNhc2UgXCImJlwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5vcGVyYXRvciA9PT0gXCI/P1wiO1xuICAgIGNhc2UgXCI/P1wiOlxuICAgICAgcmV0dXJuIHBhcmVudC5vcGVyYXRvciAhPT0gXCI/P1wiO1xuICB9XG59XG5mdW5jdGlvbiBJZGVudGlmaWVyKG5vZGUsIHBhcmVudCwgdG9rZW5Db250ZXh0LCBfaW5Gb3JJbml0LCBnZXRSYXdJZGVudGlmaWVyKSB7XG4gIHZhciBfbm9kZSRleHRyYTtcbiAgY29uc3QgcGFyZW50VHlwZSA9IHBhcmVudC50eXBlO1xuICBpZiAoKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYS5wYXJlbnRoZXNpemVkICYmIHBhcmVudFR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSkge1xuICAgIGNvbnN0IHJpZ2h0VHlwZSA9IHBhcmVudC5yaWdodC50eXBlO1xuICAgIGlmICgocmlnaHRUeXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IHJpZ2h0VHlwZSA9PT0gXCJDbGFzc0V4cHJlc3Npb25cIikgJiYgcGFyZW50LnJpZ2h0LmlkID09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoZ2V0UmF3SWRlbnRpZmllciAmJiBnZXRSYXdJZGVudGlmaWVyKG5vZGUpICE9PSBub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUubmFtZSA9PT0gXCJsZXRcIikge1xuICAgIGNvbnN0IGlzRm9sbG93ZWRCeUJyYWNrZXQgPSBpc01lbWJlckV4cHJlc3Npb24ocGFyZW50LCB7XG4gICAgICBvYmplY3Q6IG5vZGUsXG4gICAgICBjb21wdXRlZDogdHJ1ZVxuICAgIH0pIHx8IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKHBhcmVudCwge1xuICAgICAgb2JqZWN0OiBub2RlLFxuICAgICAgY29tcHV0ZWQ6IHRydWUsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9KTtcbiAgICBpZiAoaXNGb2xsb3dlZEJ5QnJhY2tldCAmJiB0b2tlbkNvbnRleHQgJiAoX2luZGV4LlRva2VuQ29udGV4dC5leHByZXNzaW9uU3RhdGVtZW50IHwgX2luZGV4LlRva2VuQ29udGV4dC5mb3JIZWFkIHwgX2luZGV4LlRva2VuQ29udGV4dC5mb3JJbkhlYWQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4odG9rZW5Db250ZXh0ICYgX2luZGV4LlRva2VuQ29udGV4dC5mb3JPZkhlYWQpO1xuICB9XG4gIHJldHVybiBub2RlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiBpc0Zvck9mU3RhdGVtZW50KHBhcmVudCwge1xuICAgIGxlZnQ6IG5vZGUsXG4gICAgYXdhaXQ6IGZhbHNlXG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJlbnRoZXNlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11773\n')},42716:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.nodes = void 0;\nvar _t = __webpack_require__(2352);\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral\n} = _t;\nfunction crawlInternal(node, state) {\n  if (!node) return state;\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || node.callee && isHelper(node.callee);\n  }\n  return state;\n}\nfunction crawl(node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false\n  });\n}\nfunction isHelper(node) {\n  if (!node) return false;\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return node.name === "require" || node.name.charCodeAt(0) === 95;\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\nfunction isType(node) {\n  return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);\n}\nconst nodes = exports.nodes = {\n  AssignmentExpression(node) {\n    const state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return state.hasFunction ? 1 | 2 : 2;\n    }\n  },\n  SwitchCase(node, parent) {\n    return (!!node.consequent.length || parent.cases[0] === node ? 1 : 0) | (!node.consequent.length && parent.cases[parent.cases.length - 1] === node ? 2 : 0);\n  },\n  LogicalExpression(node) {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return 2;\n    }\n  },\n  Literal(node) {\n    if (isStringLiteral(node) && node.value === "use strict") {\n      return 2;\n    }\n  },\n  CallExpression(node) {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return 1 | 2;\n    }\n  },\n  OptionalCallExpression(node) {\n    if (isFunction(node.callee)) {\n      return 1 | 2;\n    }\n  },\n  VariableDeclaration(node) {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n      if (enabled) {\n        return 1 | 2;\n      }\n    }\n  },\n  IfStatement(node) {\n    if (isBlockStatement(node.consequent)) {\n      return 1 | 2;\n    }\n  }\n};\nnodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return 1;\n  }\n};\nnodes.ObjectTypeCallProperty = function (node, parent) {\n  var _parent$properties;\n  if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeIndexer = function (node, parent) {\n  var _parent$properties2, _parent$callPropertie;\n  if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {\n    return 1;\n  }\n};\nnodes.ObjectTypeInternalSlot = function (node, parent) {\n  var _parent$properties3, _parent$callPropertie2, _parent$indexers;\n  if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {\n    return 1;\n  }\n};\n[["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function ([type, amounts]) {\n  [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {\n    const ret = amounts ? 1 | 2 : 0;\n    nodes[type] = () => ret;\n  });\n});\n\n//# sourceMappingURL=whitespace.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDI3MTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLDhCQUE4QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvbm9kZS93aGl0ZXNwYWNlLmpzP2Y2ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vZGVzID0gdm9pZCAwO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgRkxJUFBFRF9BTElBU19LRVlTLFxuICBpc0FycmF5RXhwcmVzc2lvbixcbiAgaXNBc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgaXNCaW5hcnksXG4gIGlzQmxvY2tTdGF0ZW1lbnQsXG4gIGlzQ2FsbEV4cHJlc3Npb24sXG4gIGlzRnVuY3Rpb24sXG4gIGlzSWRlbnRpZmllcixcbiAgaXNMaXRlcmFsLFxuICBpc01lbWJlckV4cHJlc3Npb24sXG4gIGlzT2JqZWN0RXhwcmVzc2lvbixcbiAgaXNPcHRpb25hbENhbGxFeHByZXNzaW9uLFxuICBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNTdHJpbmdMaXRlcmFsXG59ID0gX3Q7XG5mdW5jdGlvbiBjcmF3bEludGVybmFsKG5vZGUsIHN0YXRlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIHN0YXRlO1xuICBpZiAoaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHx8IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgY3Jhd2xJbnRlcm5hbChub2RlLm9iamVjdCwgc3RhdGUpO1xuICAgIGlmIChub2RlLmNvbXB1dGVkKSBjcmF3bEludGVybmFsKG5vZGUucHJvcGVydHksIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChpc0JpbmFyeShub2RlKSB8fCBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgY3Jhd2xJbnRlcm5hbChub2RlLmxlZnQsIHN0YXRlKTtcbiAgICBjcmF3bEludGVybmFsKG5vZGUucmlnaHQsIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChpc0NhbGxFeHByZXNzaW9uKG5vZGUpIHx8IGlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHN0YXRlLmhhc0NhbGwgPSB0cnVlO1xuICAgIGNyYXdsSW50ZXJuYWwobm9kZS5jYWxsZWUsIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKG5vZGUpKSB7XG4gICAgc3RhdGUuaGFzRnVuY3Rpb24gPSB0cnVlO1xuICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllcihub2RlKSkge1xuICAgIHN0YXRlLmhhc0hlbHBlciA9IHN0YXRlLmhhc0hlbHBlciB8fCBub2RlLmNhbGxlZSAmJiBpc0hlbHBlcihub2RlLmNhbGxlZSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gY3Jhd2wobm9kZSkge1xuICByZXR1cm4gY3Jhd2xJbnRlcm5hbChub2RlLCB7XG4gICAgaGFzQ2FsbDogZmFsc2UsXG4gICAgaGFzRnVuY3Rpb246IGZhbHNlLFxuICAgIGhhc0hlbHBlcjogZmFsc2VcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0hlbHBlcihub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgcmV0dXJuIGlzSGVscGVyKG5vZGUub2JqZWN0KSB8fCBpc0hlbHBlcihub2RlLnByb3BlcnR5KTtcbiAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lID09PSBcInJlcXVpcmVcIiB8fCBub2RlLm5hbWUuY2hhckNvZGVBdCgwKSA9PT0gOTU7XG4gIH0gZWxzZSBpZiAoaXNDYWxsRXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBpc0hlbHBlcihub2RlLmNhbGxlZSk7XG4gIH0gZWxzZSBpZiAoaXNCaW5hcnkobm9kZSkgfHwgaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSkge1xuICAgIHJldHVybiBpc0lkZW50aWZpZXIobm9kZS5sZWZ0KSAmJiBpc0hlbHBlcihub2RlLmxlZnQpIHx8IGlzSGVscGVyKG5vZGUucmlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUeXBlKG5vZGUpIHtcbiAgcmV0dXJuIGlzTGl0ZXJhbChub2RlKSB8fCBpc09iamVjdEV4cHJlc3Npb24obm9kZSkgfHwgaXNBcnJheUV4cHJlc3Npb24obm9kZSkgfHwgaXNJZGVudGlmaWVyKG5vZGUpIHx8IGlzTWVtYmVyRXhwcmVzc2lvbihub2RlKTtcbn1cbmNvbnN0IG5vZGVzID0gZXhwb3J0cy5ub2RlcyA9IHtcbiAgQXNzaWdubWVudEV4cHJlc3Npb24obm9kZSkge1xuICAgIGNvbnN0IHN0YXRlID0gY3Jhd2wobm9kZS5yaWdodCk7XG4gICAgaWYgKHN0YXRlLmhhc0NhbGwgJiYgc3RhdGUuaGFzSGVscGVyIHx8IHN0YXRlLmhhc0Z1bmN0aW9uKSB7XG4gICAgICByZXR1cm4gc3RhdGUuaGFzRnVuY3Rpb24gPyAxIHwgMiA6IDI7XG4gICAgfVxuICB9LFxuICBTd2l0Y2hDYXNlKG5vZGUsIHBhcmVudCkge1xuICAgIHJldHVybiAoISFub2RlLmNvbnNlcXVlbnQubGVuZ3RoIHx8IHBhcmVudC5jYXNlc1swXSA9PT0gbm9kZSA/IDEgOiAwKSB8ICghbm9kZS5jb25zZXF1ZW50Lmxlbmd0aCAmJiBwYXJlbnQuY2FzZXNbcGFyZW50LmNhc2VzLmxlbmd0aCAtIDFdID09PSBub2RlID8gMiA6IDApO1xuICB9LFxuICBMb2dpY2FsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24obm9kZS5sZWZ0KSB8fCBpc0Z1bmN0aW9uKG5vZGUucmlnaHQpKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9XG4gIH0sXG4gIExpdGVyYWwobm9kZSkge1xuICAgIGlmIChpc1N0cmluZ0xpdGVyYWwobm9kZSkgJiYgbm9kZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgfSxcbiAgQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAgIGlmIChpc0Z1bmN0aW9uKG5vZGUuY2FsbGVlKSB8fCBpc0hlbHBlcihub2RlKSkge1xuICAgICAgcmV0dXJuIDEgfCAyO1xuICAgIH1cbiAgfSxcbiAgT3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24obm9kZS5jYWxsZWUpKSB7XG4gICAgICByZXR1cm4gMSB8IDI7XG4gICAgfVxuICB9LFxuICBWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkZWNsYXIgPSBub2RlLmRlY2xhcmF0aW9uc1tpXTtcbiAgICAgIGxldCBlbmFibGVkID0gaXNIZWxwZXIoZGVjbGFyLmlkKSAmJiAhaXNUeXBlKGRlY2xhci5pbml0KTtcbiAgICAgIGlmICghZW5hYmxlZCAmJiBkZWNsYXIuaW5pdCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNyYXdsKGRlY2xhci5pbml0KTtcbiAgICAgICAgZW5hYmxlZCA9IGlzSGVscGVyKGRlY2xhci5pbml0KSAmJiBzdGF0ZS5oYXNDYWxsIHx8IHN0YXRlLmhhc0Z1bmN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIDEgfCAyO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgSWZTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmIChpc0Jsb2NrU3RhdGVtZW50KG5vZGUuY29uc2VxdWVudCkpIHtcbiAgICAgIHJldHVybiAxIHwgMjtcbiAgICB9XG4gIH1cbn07XG5ub2Rlcy5PYmplY3RQcm9wZXJ0eSA9IG5vZGVzLk9iamVjdFR5cGVQcm9wZXJ0eSA9IG5vZGVzLk9iamVjdE1ldGhvZCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5wcm9wZXJ0aWVzWzBdID09PSBub2RlKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5ub2Rlcy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICB2YXIgX3BhcmVudCRwcm9wZXJ0aWVzO1xuICBpZiAocGFyZW50LmNhbGxQcm9wZXJ0aWVzWzBdID09PSBub2RlICYmICEoKF9wYXJlbnQkcHJvcGVydGllcyA9IHBhcmVudC5wcm9wZXJ0aWVzKSAhPSBudWxsICYmIF9wYXJlbnQkcHJvcGVydGllcy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5ub2Rlcy5PYmplY3RUeXBlSW5kZXhlciA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgdmFyIF9wYXJlbnQkcHJvcGVydGllczIsIF9wYXJlbnQkY2FsbFByb3BlcnRpZTtcbiAgaWYgKHBhcmVudC5pbmRleGVyc1swXSA9PT0gbm9kZSAmJiAhKChfcGFyZW50JHByb3BlcnRpZXMyID0gcGFyZW50LnByb3BlcnRpZXMpICE9IG51bGwgJiYgX3BhcmVudCRwcm9wZXJ0aWVzMi5sZW5ndGgpICYmICEoKF9wYXJlbnQkY2FsbFByb3BlcnRpZSA9IHBhcmVudC5jYWxsUHJvcGVydGllcykgIT0gbnVsbCAmJiBfcGFyZW50JGNhbGxQcm9wZXJ0aWUubGVuZ3RoKSkge1xuICAgIHJldHVybiAxO1xuICB9XG59O1xubm9kZXMuT2JqZWN0VHlwZUludGVybmFsU2xvdCA9IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgdmFyIF9wYXJlbnQkcHJvcGVydGllczMsIF9wYXJlbnQkY2FsbFByb3BlcnRpZTIsIF9wYXJlbnQkaW5kZXhlcnM7XG4gIGlmIChwYXJlbnQuaW50ZXJuYWxTbG90c1swXSA9PT0gbm9kZSAmJiAhKChfcGFyZW50JHByb3BlcnRpZXMzID0gcGFyZW50LnByb3BlcnRpZXMpICE9IG51bGwgJiYgX3BhcmVudCRwcm9wZXJ0aWVzMy5sZW5ndGgpICYmICEoKF9wYXJlbnQkY2FsbFByb3BlcnRpZTIgPSBwYXJlbnQuY2FsbFByb3BlcnRpZXMpICE9IG51bGwgJiYgX3BhcmVudCRjYWxsUHJvcGVydGllMi5sZW5ndGgpICYmICEoKF9wYXJlbnQkaW5kZXhlcnMgPSBwYXJlbnQuaW5kZXhlcnMpICE9IG51bGwgJiYgX3BhcmVudCRpbmRleGVycy5sZW5ndGgpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbn07XG5bW1wiRnVuY3Rpb25cIiwgdHJ1ZV0sIFtcIkNsYXNzXCIsIHRydWVdLCBbXCJMb29wXCIsIHRydWVdLCBbXCJMYWJlbGVkU3RhdGVtZW50XCIsIHRydWVdLCBbXCJTd2l0Y2hTdGF0ZW1lbnRcIiwgdHJ1ZV0sIFtcIlRyeVN0YXRlbWVudFwiLCB0cnVlXV0uZm9yRWFjaChmdW5jdGlvbiAoW3R5cGUsIGFtb3VudHNdKSB7XG4gIFt0eXBlXS5jb25jYXQoRkxJUFBFRF9BTElBU19LRVlTW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgY29uc3QgcmV0ID0gYW1vdW50cyA/IDEgfCAyIDogMDtcbiAgICBub2Rlc1t0eXBlXSA9ICgpID0+IHJldDtcbiAgfSk7XG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2hpdGVzcGFjZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42716\n')},66636:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _buffer = __webpack_require__(74960);\nvar n = __webpack_require__(31373);\nvar _t = __webpack_require__(2352);\nvar _tokenMap = __webpack_require__(49594);\nvar generatorFunctions = __webpack_require__(66735);\nconst {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\nfunction commentIsNewline(c) {\n  return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);\n}\nconst {\n  needsParens\n} = n;\nclass Printer {\n  constructor(format, map, tokens, originalCode) {\n    this.inForStatementInit = false;\n    this.tokenContext = 0;\n    this._tokens = null;\n    this._originalCode = null;\n    this._currentNode = null;\n    this._indent = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._noLineTerminator = false;\n    this._noLineTerminatorAfterNode = null;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._endsWithDiv = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.tokenMap = null;\n    this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n    this.format = format;\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = map == null ? void 0 : map._inputMap;\n    this._buf = new _buffer.default(map, format.indent.style[0]);\n  }\n  enterForStatementInit() {\n    if (this.inForStatementInit) return () => {};\n    this.inForStatementInit = true;\n    return () => {\n      this.inForStatementInit = false;\n    };\n  }\n  enterDelimited() {\n    const oldInForStatementInit = this.inForStatementInit;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {\n      return () => {};\n    }\n    this.inForStatementInit = false;\n    this._noLineTerminatorAfterNode = null;\n    return () => {\n      this.inForStatementInit = oldInForStatementInit;\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    };\n  }\n  generate(ast) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n    return this._buf.get();\n  }\n  indent() {\n    const {\n      format\n    } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n    this._indent++;\n  }\n  dedent() {\n    const {\n      format\n    } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n    this._indent--;\n  }\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(59);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, ";")) {\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode);\n        this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(59);\n    this._noLineTerminator = false;\n  }\n  rightBrace(node) {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset("end", node.loc, -1);\n    this.tokenChar(125);\n  }\n  rightParens(node) {\n    this.sourceWithOffset("end", node.loc, -1);\n    this.tokenChar(41);\n  }\n  space(force = false) {\n    const {\n      format\n    } = this;\n    if (format.compact || format.preserveFormat) return;\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n  word(str, noLineTerminatorAfter = false) {\n    this.tokenContext = 0;\n    this._maybePrintInnerComments(str);\n    if (this._endsWithWord || this._endsWithDiv && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, false);\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n  number(str, number) {\n    function isNonDecimalLiteral(str) {\n      if (str.length > 2 && str.charCodeAt(0) === 48) {\n        const secondChar = str.charCodeAt(1);\n        return secondChar === 98 || secondChar === 111 || secondChar === 120;\n      }\n      return false;\n    }\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n  token(str, maybeNewline = false, occurrenceCount = 0) {\n    this.tokenContext = 0;\n    this._maybePrintInnerComments(str, occurrenceCount);\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (lastChar === 33 && (str === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline, occurrenceCount);\n    this._noLineTerminator = false;\n  }\n  tokenChar(char) {\n    this.tokenContext = 0;\n    this._maybePrintInnerComments(String.fromCharCode(char));\n    const lastChar = this.getLastChar();\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n  newline(i = 1, force) {\n    if (i <= 0) return;\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n    if (i > 2) i = 2;\n    i -= this._buf.getNewlineCount();\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n    return;\n  }\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n  exactSource(loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp("start", loc);\n    this._buf.exactSource(loc, cb);\n  }\n  source(prop, loc) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.source(prop, loc);\n  }\n  sourceWithOffset(prop, loc, columnOffset) {\n    if (!loc || this.format.preserveFormat) return;\n    this._catchUp(prop, loc);\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n  sourceIdentifierName(identifierName, pos) {\n    if (!this._buf._canMarkIdName) return;\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n  _space() {\n    this._queue(32);\n  }\n  _newline() {\n    this._queue(10);\n  }\n  _append(str, maybeNewline, occurrenceCount = 0) {\n    if (this.tokenMap) {\n      const token = this.tokenMap.findMatching(this._currentNode, str, occurrenceCount);\n      if (token) this._catchUpTo(token.loc.start);\n    }\n    this._maybeIndent(str.charCodeAt(0));\n    this._buf.append(str, maybeNewline);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n  _appendChar(char) {\n    if (this.tokenMap) {\n      const token = this.tokenMap.findMatching(this._currentNode, String.fromCharCode(char));\n      if (token) this._catchUpTo(token.loc.start);\n    }\n    this._maybeIndent(char);\n    this._buf.appendChar(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n  _queue(char) {\n    this._maybeIndent(char);\n    this._buf.queue(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n  _shouldIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      return true;\n    }\n  }\n  catchUp(line) {\n    if (!this.format.retainLines) return;\n    const count = line - this._buf.getCurrentLine();\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n  _catchUp(prop, loc) {\n    const {\n      format\n    } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc != null && loc[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n    const pos = loc == null ? void 0 : loc[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n  _catchUpTo({\n    line,\n    column,\n    index\n  }) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      return;\n    }\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n    const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode ? this._originalCode.slice(index - spacesCount, index).replace(/[^\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]/gu, " ") : " ".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n  printTerminatorless(node) {\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n  print(node, noLineTerminatorAfter, trailingCommentsLineOffset) {\n    var _node$extra, _node$leadingComments, _node$leadingComments2;\n    if (!node) return;\n    this._endsWithInnerRaw = false;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n    if (node._compact) {\n      format.concise = true;\n    }\n    const printMethod = this[nodeType];\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n    const parent = this._currentNode;\n    this._currentNode = node;\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    const parenthesized = (_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized;\n    let shouldPrintParens = parenthesized && format.preserveFormat || parenthesized && format.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node, parent, this.tokenContext, this.inForStatementInit, format.preserveFormat ? this._boundGetRawIdentifier : undefined);\n    if (!shouldPrintParens && parenthesized && (_node$leadingComments = node.leadingComments) != null && _node$leadingComments.length && node.leadingComments[0].type === "CommentBlock") {\n      const parentType = parent == null ? void 0 : parent.type;\n      switch (parentType) {\n        case "ExpressionStatement":\n        case "VariableDeclarator":\n        case "AssignmentExpression":\n        case "ReturnStatement":\n          break;\n        case "CallExpression":\n        case "OptionalCallExpression":\n        case "NewExpression":\n          if (parent.callee !== node) break;\n        default:\n          shouldPrintParens = true;\n      }\n    }\n    let indentParenthesized = false;\n    if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node.loc && node.loc.start.line > this._buf.getCurrentLine())) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n    let oldNoLineTerminatorAfterNode;\n    let oldInForStatementInitWasTrue;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node));\n      if (noLineTerminatorAfter) {\n        var _node$trailingComment;\n        if ((_node$trailingComment = node.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n    if (shouldPrintParens) {\n      this.tokenChar(40);\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.inForStatementInit) {\n        oldInForStatementInitWasTrue = true;\n        this.inForStatementInit = false;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n    this._lastCommentLine = 0;\n    this._printLeadingComments(node, parent);\n    const loc = nodeType === "Program" || nodeType === "File" ? null : node.loc;\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.tokenChar(41);\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldInForStatementInitWasTrue) this.inForStatementInit = true;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n    this._endsWithInnerRaw = false;\n  }\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: "CommentBlock",\n        value: comment\n      }, 0);\n    }\n  }\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: "CommentBlock",\n        value: comment\n      }, 0);\n    }\n  }\n  getPossibleRaw(node) {\n    const extra = node.extra;\n    if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n  printJoin(nodes, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    let {\n      indent\n    } = opts;\n    if (indent == null && this.format.retainLines) {\n      var _nodes$0$loc;\n      const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n    if (indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0\n    };\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n      this.print(node, undefined, opts.trailingCommentsLineOffset || 0);\n      opts.iterator == null || opts.iterator(node, i);\n      if (separator != null) {\n        if (i < len - 1) separator(i, false);else if (opts.printTrailingSeparator) separator(i, true);\n      }\n      if (opts.statement) {\n        var _node$trailingComment2;\n        if (!((_node$trailingComment2 = node.trailingComments) != null && _node$trailingComment2.length)) {\n          this._lastCommentLine = 0;\n        }\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          var _nextNode$loc;\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n    if (indent) this.dedent();\n  }\n  printAndIndentOnComments(node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n  printBlock(parent) {\n    const node = parent.body;\n    if (node.type !== "EmptyStatement") {\n      this.space();\n    }\n    this.print(node);\n  }\n  _printTrailingComments(node, parent, lineOffset) {\n    const {\n      innerComments,\n      trailingComments\n    } = node;\n    if (innerComments != null && innerComments.length) {\n      this._printComments(2, innerComments, node, parent, lineOffset);\n    }\n    if (trailingComments != null && trailingComments.length) {\n      this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n  }\n  _printLeadingComments(node, parent) {\n    const comments = node.leadingComments;\n    if (!(comments != null && comments.length)) return;\n    this._printComments(0, comments, node, parent);\n  }\n  _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {\n    if (this._endsWithInnerRaw) {\n      var _this$tokenMap;\n      this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n  printInnerComments(nextToken) {\n    const node = this._currentNode;\n    const comments = node.innerComments;\n    if (!(comments != null && comments.length)) return;\n    const hasSpace = this.endsWith(32);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(1, comments, node, undefined, undefined, nextToken);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n  printSequence(nodes, opts = {}) {\n    var _opts$indent;\n    opts.statement = true;\n    (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;\n    this.printJoin(nodes, opts);\n  }\n  printList(items, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n    this.printJoin(items, opts);\n  }\n  shouldPrintTrailingComma(listEnd) {\n    if (!this.tokenMap) return null;\n    const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, token => this.tokenMap.matchesOriginal(token, listEnd));\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");\n  }\n  _printNewline(newLine, opts) {\n    const format = this.format;\n    if (format.retainLines || format.compact) return;\n    if (format.concise) {\n      this.space();\n      return;\n    }\n    if (!newLine) {\n      return;\n    }\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n    if (this._buf.hasContent()) {\n      this.newline(1);\n    }\n  }\n  _shouldPrintComment(comment, nextToken) {\n    if (comment.ignore) return 0;\n    if (this._printedComments.has(comment)) return 0;\n    if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)) {\n      return 2;\n    }\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(this._currentNode, token => token.value === comment.value);\n      if (commentTok && commentTok.start > nextToken.start) {\n        return 2;\n      }\n    }\n    this._printedComments.add(comment);\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return 0;\n    }\n    return 1;\n  }\n  _printComment(comment, skipNewLines) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === "CommentBlock";\n    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n      this.newline(1);\n    }\n    const lastCharCode = this.getLastChar();\n    if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {\n      this.space();\n    }\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp("\\\\n\\\\s{1," + offset + "}", "g");\n          val = val.replace(newlineRegex, "\\n");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n          if (this._shouldIndent(47) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n          val = val.replace(/\\n(?!$)/g, `\\n${" ".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n    if (this._endsWithDiv) this._space();\n    this.source("start", comment.loc);\n    this._append(val, isBlockComment);\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n    if (printNewLines && skipNewLines !== 3) {\n      this.newline(1);\n    }\n  }\n  _printComments(type, comments, node, parent, lineOffset = 0, nextToken) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === 2) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === 1) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === 0) {\n          let offset = 0;\n          if (i === 0) {\n            if (this._buf.hasContent() && (comment.type === "CommentLine" || commentStartLine !== commentEndLine)) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n            lastLine = nodeStartLine;\n          }\n        } else if (type === 1) {\n          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine));\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== 1) {\n          continue;\n        }\n        if (len === 1) {\n          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n          if (type === 0) {\n            this._printComment(comment, shouldSkipNewline && node.type !== "ObjectExpression" || singleLine && isFunction(parent, {\n              body: node\n            }) ? 1 : 0);\n          } else if (shouldSkipNewline && type === 2) {\n            this._printComment(comment, 1);\n          } else {\n            this._printComment(comment, 0);\n          }\n        } else if (type === 1 && !(node.type === "ObjectExpression" && node.properties.length > 1) && node.type !== "ClassBody" && node.type !== "TSInterfaceBody") {\n          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n        } else {\n          this._printComment(comment, 0);\n        }\n      }\n    }\n    if (type === 2 && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = exports["default"] = Printer;\nfunction commaSeparator(occurrenceCount, last) {\n  this.token(",", false, occurrenceCount);\n  if (!last) this.space();\n}\n\n//# sourceMappingURL=printer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY2MzYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixjQUFjLG1CQUFPLENBQUMsS0FBYTtBQUNuQyxRQUFRLG1CQUFPLENBQUMsS0FBaUI7QUFDakMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsS0FBZ0I7QUFDeEMseUJBQXlCLG1CQUFPLENBQUMsS0FBdUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELDBCQUEwQixtQkFBbUIsc0NBQXNDO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpQkFBaUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdUJBQXVCO0FBQ3BFO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUJBQWlCLGNBQWM7QUFDL0IsTUFBTTtBQUNOLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvcHJpbnRlci5qcz84Y2Q0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9idWZmZXIgPSByZXF1aXJlKFwiLi9idWZmZXIuanNcIik7XG52YXIgbiA9IHJlcXVpcmUoXCIuL25vZGUvaW5kZXguanNcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF90b2tlbk1hcCA9IHJlcXVpcmUoXCIuL3Rva2VuLW1hcC5qc1wiKTtcbnZhciBnZW5lcmF0b3JGdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3JzL2luZGV4LmpzXCIpO1xuY29uc3Qge1xuICBpc0V4cHJlc3Npb24sXG4gIGlzRnVuY3Rpb24sXG4gIGlzU3RhdGVtZW50LFxuICBpc0NsYXNzQm9keSxcbiAgaXNUU0ludGVyZmFjZUJvZHksXG4gIGlzVFNFbnVtRGVjbGFyYXRpb25cbn0gPSBfdDtcbmNvbnN0IFNDSUVOVElGSUNfTk9UQVRJT04gPSAvZS9pO1xuY29uc3QgWkVST19ERUNJTUFMX0lOVEVHRVIgPSAvXFwuMCskLztcbmNvbnN0IEhBU19ORVdMSU5FID0gL1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgSEFTX05FV0xJTkVfT1JfQmxPQ0tfQ09NTUVOVF9FTkQgPSAvW1xcblxcclxcdTIwMjhcXHUyMDI5XXxcXCpcXC8vO1xuZnVuY3Rpb24gY29tbWVudElzTmV3bGluZShjKSB7XG4gIHJldHVybiBjLnR5cGUgPT09IFwiQ29tbWVudExpbmVcIiB8fCBIQVNfTkVXTElORS50ZXN0KGMudmFsdWUpO1xufVxuY29uc3Qge1xuICBuZWVkc1BhcmVuc1xufSA9IG47XG5jbGFzcyBQcmludGVyIHtcbiAgY29uc3RydWN0b3IoZm9ybWF0LCBtYXAsIHRva2Vucywgb3JpZ2luYWxDb2RlKSB7XG4gICAgdGhpcy5pbkZvclN0YXRlbWVudEluaXQgPSBmYWxzZTtcbiAgICB0aGlzLnRva2VuQ29udGV4dCA9IDA7XG4gICAgdGhpcy5fdG9rZW5zID0gbnVsbDtcbiAgICB0aGlzLl9vcmlnaW5hbENvZGUgPSBudWxsO1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gbnVsbDtcbiAgICB0aGlzLl9pbmRlbnQgPSAwO1xuICAgIHRoaXMuX2luZGVudFJlcGVhdCA9IDA7XG4gICAgdGhpcy5faW5zaWRlQXV4ID0gZmFsc2U7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IGZhbHNlO1xuICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBudWxsO1xuICAgIHRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSA9IGZhbHNlO1xuICAgIHRoaXMuX3ByaW50ZWRDb21tZW50cyA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aFdvcmQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aERpdiA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RDb21tZW50TGluZSA9IDA7XG4gICAgdGhpcy5fZW5kc1dpdGhJbm5lclJhdyA9IGZhbHNlO1xuICAgIHRoaXMuX2luZGVudElubmVyQ29tbWVudHMgPSB0cnVlO1xuICAgIHRoaXMudG9rZW5NYXAgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kR2V0UmF3SWRlbnRpZmllciA9IHRoaXMuX2dldFJhd0lkZW50aWZpZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy5fb3JpZ2luYWxDb2RlID0gb3JpZ2luYWxDb2RlO1xuICAgIHRoaXMuX2luZGVudFJlcGVhdCA9IGZvcm1hdC5pbmRlbnQuc3R5bGUubGVuZ3RoO1xuICAgIHRoaXMuX2lucHV0TWFwID0gbWFwID09IG51bGwgPyB2b2lkIDAgOiBtYXAuX2lucHV0TWFwO1xuICAgIHRoaXMuX2J1ZiA9IG5ldyBfYnVmZmVyLmRlZmF1bHQobWFwLCBmb3JtYXQuaW5kZW50LnN0eWxlWzBdKTtcbiAgfVxuICBlbnRlckZvclN0YXRlbWVudEluaXQoKSB7XG4gICAgaWYgKHRoaXMuaW5Gb3JTdGF0ZW1lbnRJbml0KSByZXR1cm4gKCkgPT4ge307XG4gICAgdGhpcy5pbkZvclN0YXRlbWVudEluaXQgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmluRm9yU3RhdGVtZW50SW5pdCA9IGZhbHNlO1xuICAgIH07XG4gIH1cbiAgZW50ZXJEZWxpbWl0ZWQoKSB7XG4gICAgY29uc3Qgb2xkSW5Gb3JTdGF0ZW1lbnRJbml0ID0gdGhpcy5pbkZvclN0YXRlbWVudEluaXQ7XG4gICAgY29uc3Qgb2xkTm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9IHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGU7XG4gICAgaWYgKG9sZEluRm9yU3RhdGVtZW50SW5pdCA9PT0gZmFsc2UgJiYgb2xkTm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cbiAgICB0aGlzLmluRm9yU3RhdGVtZW50SW5pdCA9IGZhbHNlO1xuICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBudWxsO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLmluRm9yU3RhdGVtZW50SW5pdCA9IG9sZEluRm9yU3RhdGVtZW50SW5pdDtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlO1xuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGUoYXN0KSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0LnByZXNlcnZlRm9ybWF0KSB7XG4gICAgICB0aGlzLnRva2VuTWFwID0gbmV3IF90b2tlbk1hcC5Ub2tlbk1hcChhc3QsIHRoaXMuX3Rva2VucywgdGhpcy5fb3JpZ2luYWxDb2RlKTtcbiAgICB9XG4gICAgdGhpcy5wcmludChhc3QpO1xuICAgIHRoaXMuX21heWJlQWRkQXV4Q29tbWVudCgpO1xuICAgIHJldHVybiB0aGlzLl9idWYuZ2V0KCk7XG4gIH1cbiAgaW5kZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQucHJlc2VydmVGb3JtYXQgfHwgZm9ybWF0LmNvbXBhY3QgfHwgZm9ybWF0LmNvbmNpc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5kZW50Kys7XG4gIH1cbiAgZGVkZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQucHJlc2VydmVGb3JtYXQgfHwgZm9ybWF0LmNvbXBhY3QgfHwgZm9ybWF0LmNvbmNpc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5kZW50LS07XG4gIH1cbiAgc2VtaWNvbG9uKGZvcmNlID0gZmFsc2UpIHtcbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQoKTtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHRoaXMuX2FwcGVuZENoYXIoNTkpO1xuICAgICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2N1cnJlbnROb2RlO1xuICAgICAgaWYgKG5vZGUuc3RhcnQgIT0gbnVsbCAmJiBub2RlLmVuZCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbk1hcC5lbmRNYXRjaGVzKG5vZGUsIFwiO1wiKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleGVzID0gdGhpcy50b2tlbk1hcC5nZXRJbmRleGVzKHRoaXMuX2N1cnJlbnROb2RlKTtcbiAgICAgICAgdGhpcy5fY2F0Y2hVcFRvKHRoaXMuX3Rva2Vuc1tpbmRleGVzW2luZGV4ZXMubGVuZ3RoIC0gMV1dLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3F1ZXVlKDU5KTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gIH1cbiAgcmlnaHRCcmFjZShub2RlKSB7XG4gICAgaWYgKHRoaXMuZm9ybWF0Lm1pbmlmaWVkKSB7XG4gICAgICB0aGlzLl9idWYucmVtb3ZlTGFzdFNlbWljb2xvbigpO1xuICAgIH1cbiAgICB0aGlzLnNvdXJjZVdpdGhPZmZzZXQoXCJlbmRcIiwgbm9kZS5sb2MsIC0xKTtcbiAgICB0aGlzLnRva2VuQ2hhcigxMjUpO1xuICB9XG4gIHJpZ2h0UGFyZW5zKG5vZGUpIHtcbiAgICB0aGlzLnNvdXJjZVdpdGhPZmZzZXQoXCJlbmRcIiwgbm9kZS5sb2MsIC0xKTtcbiAgICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gIH1cbiAgc3BhY2UoZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChmb3JtYXQuY29tcGFjdCB8fCBmb3JtYXQucHJlc2VydmVGb3JtYXQpIHJldHVybjtcbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9idWYuaGFzQ29udGVudCgpKSB7XG4gICAgICBjb25zdCBsYXN0Q3AgPSB0aGlzLmdldExhc3RDaGFyKCk7XG4gICAgICBpZiAobGFzdENwICE9PSAzMiAmJiBsYXN0Q3AgIT09IDEwKSB7XG4gICAgICAgIHRoaXMuX3NwYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdvcmQoc3RyLCBub0xpbmVUZXJtaW5hdG9yQWZ0ZXIgPSBmYWxzZSkge1xuICAgIHRoaXMudG9rZW5Db250ZXh0ID0gMDtcbiAgICB0aGlzLl9tYXliZVByaW50SW5uZXJDb21tZW50cyhzdHIpO1xuICAgIGlmICh0aGlzLl9lbmRzV2l0aFdvcmQgfHwgdGhpcy5fZW5kc1dpdGhEaXYgJiYgc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ3KSB7XG4gICAgICB0aGlzLl9zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQoKTtcbiAgICB0aGlzLl9hcHBlbmQoc3RyLCBmYWxzZSk7XG4gICAgdGhpcy5fZW5kc1dpdGhXb3JkID0gdHJ1ZTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gbm9MaW5lVGVybWluYXRvckFmdGVyO1xuICB9XG4gIG51bWJlcihzdHIsIG51bWJlcikge1xuICAgIGZ1bmN0aW9uIGlzTm9uRGVjaW1hbExpdGVyYWwoc3RyKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA+IDIgJiYgc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ4KSB7XG4gICAgICAgIGNvbnN0IHNlY29uZENoYXIgPSBzdHIuY2hhckNvZGVBdCgxKTtcbiAgICAgICAgcmV0dXJuIHNlY29uZENoYXIgPT09IDk4IHx8IHNlY29uZENoYXIgPT09IDExMSB8fCBzZWNvbmRDaGFyID09PSAxMjA7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMud29yZChzdHIpO1xuICAgIHRoaXMuX2VuZHNXaXRoSW50ZWdlciA9IE51bWJlci5pc0ludGVnZXIobnVtYmVyKSAmJiAhaXNOb25EZWNpbWFsTGl0ZXJhbChzdHIpICYmICFTQ0lFTlRJRklDX05PVEFUSU9OLnRlc3Qoc3RyKSAmJiAhWkVST19ERUNJTUFMX0lOVEVHRVIudGVzdChzdHIpICYmIHN0ci5jaGFyQ29kZUF0KHN0ci5sZW5ndGggLSAxKSAhPT0gNDY7XG4gIH1cbiAgdG9rZW4oc3RyLCBtYXliZU5ld2xpbmUgPSBmYWxzZSwgb2NjdXJyZW5jZUNvdW50ID0gMCkge1xuICAgIHRoaXMudG9rZW5Db250ZXh0ID0gMDtcbiAgICB0aGlzLl9tYXliZVByaW50SW5uZXJDb21tZW50cyhzdHIsIG9jY3VycmVuY2VDb3VudCk7XG4gICAgY29uc3QgbGFzdENoYXIgPSB0aGlzLmdldExhc3RDaGFyKCk7XG4gICAgY29uc3Qgc3RyRmlyc3QgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgICBpZiAobGFzdENoYXIgPT09IDMzICYmIChzdHIgPT09IFwiLS1cIiB8fCBzdHJGaXJzdCA9PT0gNjEpIHx8IHN0ckZpcnN0ID09PSA0MyAmJiBsYXN0Q2hhciA9PT0gNDMgfHwgc3RyRmlyc3QgPT09IDQ1ICYmIGxhc3RDaGFyID09PSA0NSB8fCBzdHJGaXJzdCA9PT0gNDYgJiYgdGhpcy5fZW5kc1dpdGhJbnRlZ2VyKSB7XG4gICAgICB0aGlzLl9zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQoKTtcbiAgICB0aGlzLl9hcHBlbmQoc3RyLCBtYXliZU5ld2xpbmUsIG9jY3VycmVuY2VDb3VudCk7XG4gICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IGZhbHNlO1xuICB9XG4gIHRva2VuQ2hhcihjaGFyKSB7XG4gICAgdGhpcy50b2tlbkNvbnRleHQgPSAwO1xuICAgIHRoaXMuX21heWJlUHJpbnRJbm5lckNvbW1lbnRzKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcikpO1xuICAgIGNvbnN0IGxhc3RDaGFyID0gdGhpcy5nZXRMYXN0Q2hhcigpO1xuICAgIGlmIChjaGFyID09PSA0MyAmJiBsYXN0Q2hhciA9PT0gNDMgfHwgY2hhciA9PT0gNDUgJiYgbGFzdENoYXIgPT09IDQ1IHx8IGNoYXIgPT09IDQ2ICYmIHRoaXMuX2VuZHNXaXRoSW50ZWdlcikge1xuICAgICAgdGhpcy5fc3BhY2UoKTtcbiAgICB9XG4gICAgdGhpcy5fbWF5YmVBZGRBdXhDb21tZW50KCk7XG4gICAgdGhpcy5fYXBwZW5kQ2hhcihjaGFyKTtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gZmFsc2U7XG4gIH1cbiAgbmV3bGluZShpID0gMSwgZm9yY2UpIHtcbiAgICBpZiAoaSA8PSAwKSByZXR1cm47XG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgaWYgKHRoaXMuZm9ybWF0LnJldGFpbkxpbmVzIHx8IHRoaXMuZm9ybWF0LmNvbXBhY3QpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmZvcm1hdC5jb25jaXNlKSB7XG4gICAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA+IDIpIGkgPSAyO1xuICAgIGkgLT0gdGhpcy5fYnVmLmdldE5ld2xpbmVDb3VudCgpO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICB0aGlzLl9uZXdsaW5lKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBlbmRzV2l0aChjaGFyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGFzdENoYXIoKSA9PT0gY2hhcjtcbiAgfVxuICBnZXRMYXN0Q2hhcigpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmLmdldExhc3RDaGFyKCk7XG4gIH1cbiAgZW5kc1dpdGhDaGFyQW5kTmV3bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnVmLmVuZHNXaXRoQ2hhckFuZE5ld2xpbmUoKTtcbiAgfVxuICByZW1vdmVUcmFpbGluZ05ld2xpbmUoKSB7XG4gICAgdGhpcy5fYnVmLnJlbW92ZVRyYWlsaW5nTmV3bGluZSgpO1xuICB9XG4gIGV4YWN0U291cmNlKGxvYywgY2IpIHtcbiAgICBpZiAoIWxvYykge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2F0Y2hVcChcInN0YXJ0XCIsIGxvYyk7XG4gICAgdGhpcy5fYnVmLmV4YWN0U291cmNlKGxvYywgY2IpO1xuICB9XG4gIHNvdXJjZShwcm9wLCBsb2MpIHtcbiAgICBpZiAoIWxvYykgcmV0dXJuO1xuICAgIHRoaXMuX2NhdGNoVXAocHJvcCwgbG9jKTtcbiAgICB0aGlzLl9idWYuc291cmNlKHByb3AsIGxvYyk7XG4gIH1cbiAgc291cmNlV2l0aE9mZnNldChwcm9wLCBsb2MsIGNvbHVtbk9mZnNldCkge1xuICAgIGlmICghbG9jIHx8IHRoaXMuZm9ybWF0LnByZXNlcnZlRm9ybWF0KSByZXR1cm47XG4gICAgdGhpcy5fY2F0Y2hVcChwcm9wLCBsb2MpO1xuICAgIHRoaXMuX2J1Zi5zb3VyY2VXaXRoT2Zmc2V0KHByb3AsIGxvYywgY29sdW1uT2Zmc2V0KTtcbiAgfVxuICBzb3VyY2VJZGVudGlmaWVyTmFtZShpZGVudGlmaWVyTmFtZSwgcG9zKSB7XG4gICAgaWYgKCF0aGlzLl9idWYuX2Nhbk1hcmtJZE5hbWUpIHJldHVybjtcbiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHRoaXMuX2J1Zi5fc291cmNlUG9zaXRpb247XG4gICAgc291cmNlUG9zaXRpb24uaWRlbnRpZmllck5hbWVQb3MgPSBwb3M7XG4gICAgc291cmNlUG9zaXRpb24uaWRlbnRpZmllck5hbWUgPSBpZGVudGlmaWVyTmFtZTtcbiAgfVxuICBfc3BhY2UoKSB7XG4gICAgdGhpcy5fcXVldWUoMzIpO1xuICB9XG4gIF9uZXdsaW5lKCkge1xuICAgIHRoaXMuX3F1ZXVlKDEwKTtcbiAgfVxuICBfYXBwZW5kKHN0ciwgbWF5YmVOZXdsaW5lLCBvY2N1cnJlbmNlQ291bnQgPSAwKSB7XG4gICAgaWYgKHRoaXMudG9rZW5NYXApIHtcbiAgICAgIGNvbnN0IHRva2VuID0gdGhpcy50b2tlbk1hcC5maW5kTWF0Y2hpbmcodGhpcy5fY3VycmVudE5vZGUsIHN0ciwgb2NjdXJyZW5jZUNvdW50KTtcbiAgICAgIGlmICh0b2tlbikgdGhpcy5fY2F0Y2hVcFRvKHRva2VuLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIHRoaXMuX21heWJlSW5kZW50KHN0ci5jaGFyQ29kZUF0KDApKTtcbiAgICB0aGlzLl9idWYuYXBwZW5kKHN0ciwgbWF5YmVOZXdsaW5lKTtcbiAgICB0aGlzLl9lbmRzV2l0aFdvcmQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aERpdiA9IGZhbHNlO1xuICB9XG4gIF9hcHBlbmRDaGFyKGNoYXIpIHtcbiAgICBpZiAodGhpcy50b2tlbk1hcCkge1xuICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLnRva2VuTWFwLmZpbmRNYXRjaGluZyh0aGlzLl9jdXJyZW50Tm9kZSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyKSk7XG4gICAgICBpZiAodG9rZW4pIHRoaXMuX2NhdGNoVXBUbyh0b2tlbi5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLl9tYXliZUluZGVudChjaGFyKTtcbiAgICB0aGlzLl9idWYuYXBwZW5kQ2hhcihjaGFyKTtcbiAgICB0aGlzLl9lbmRzV2l0aFdvcmQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aEludGVnZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRzV2l0aERpdiA9IGZhbHNlO1xuICB9XG4gIF9xdWV1ZShjaGFyKSB7XG4gICAgdGhpcy5fbWF5YmVJbmRlbnQoY2hhcik7XG4gICAgdGhpcy5fYnVmLnF1ZXVlKGNoYXIpO1xuICAgIHRoaXMuX2VuZHNXaXRoV29yZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZHNXaXRoSW50ZWdlciA9IGZhbHNlO1xuICB9XG4gIF9tYXliZUluZGVudChmaXJzdENoYXIpIHtcbiAgICBpZiAodGhpcy5faW5kZW50ICYmIGZpcnN0Q2hhciAhPT0gMTAgJiYgdGhpcy5lbmRzV2l0aCgxMCkpIHtcbiAgICAgIHRoaXMuX2J1Zi5xdWV1ZUluZGVudGF0aW9uKHRoaXMuX2dldEluZGVudCgpKTtcbiAgICB9XG4gIH1cbiAgX3Nob3VsZEluZGVudChmaXJzdENoYXIpIHtcbiAgICBpZiAodGhpcy5faW5kZW50ICYmIGZpcnN0Q2hhciAhPT0gMTAgJiYgdGhpcy5lbmRzV2l0aCgxMCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBjYXRjaFVwKGxpbmUpIHtcbiAgICBpZiAoIXRoaXMuZm9ybWF0LnJldGFpbkxpbmVzKSByZXR1cm47XG4gICAgY29uc3QgY291bnQgPSBsaW5lIC0gdGhpcy5fYnVmLmdldEN1cnJlbnRMaW5lKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICB0aGlzLl9uZXdsaW5lKCk7XG4gICAgfVxuICB9XG4gIF9jYXRjaFVwKHByb3AsIGxvYykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcm1hdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZm9ybWF0LnByZXNlcnZlRm9ybWF0KSB7XG4gICAgICBpZiAoZm9ybWF0LnJldGFpbkxpbmVzICYmIGxvYyAhPSBudWxsICYmIGxvY1twcm9wXSkge1xuICAgICAgICB0aGlzLmNhdGNoVXAobG9jW3Byb3BdLmxpbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3MgPSBsb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGxvY1twcm9wXTtcbiAgICBpZiAocG9zICE9IG51bGwpIHRoaXMuX2NhdGNoVXBUbyhwb3MpO1xuICB9XG4gIF9jYXRjaFVwVG8oe1xuICAgIGxpbmUsXG4gICAgY29sdW1uLFxuICAgIGluZGV4XG4gIH0pIHtcbiAgICBjb25zdCBjb3VudCA9IGxpbmUgLSB0aGlzLl9idWYuZ2V0Q3VycmVudExpbmUoKTtcbiAgICBpZiAoY291bnQgPiAwICYmIHRoaXMuX25vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICB0aGlzLl9uZXdsaW5lKCk7XG4gICAgfVxuICAgIGNvbnN0IHNwYWNlc0NvdW50ID0gY291bnQgPiAwID8gY29sdW1uIDogY29sdW1uIC0gdGhpcy5fYnVmLmdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICBpZiAoc3BhY2VzQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCBzcGFjZXMgPSB0aGlzLl9vcmlnaW5hbENvZGUgPyB0aGlzLl9vcmlnaW5hbENvZGUuc2xpY2UoaW5kZXggLSBzcGFjZXNDb3VudCwgaW5kZXgpLnJlcGxhY2UoL1teXFx0XFx4MEJcXGYgXFx4QTBcXHUxNjgwXFx1MjAwMC1cXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1RkVGRl0vZ3UsIFwiIFwiKSA6IFwiIFwiLnJlcGVhdChzcGFjZXNDb3VudCk7XG4gICAgICB0aGlzLl9hcHBlbmQoc3BhY2VzLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9nZXRJbmRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGVudFJlcGVhdCAqIHRoaXMuX2luZGVudDtcbiAgfVxuICBwcmludFRlcm1pbmF0b3JsZXNzKG5vZGUpIHtcbiAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gdHJ1ZTtcbiAgICB0aGlzLnByaW50KG5vZGUpO1xuICB9XG4gIHByaW50KG5vZGUsIG5vTGluZVRlcm1pbmF0b3JBZnRlciwgdHJhaWxpbmdDb21tZW50c0xpbmVPZmZzZXQpIHtcbiAgICB2YXIgX25vZGUkZXh0cmEsIF9ub2RlJGxlYWRpbmdDb21tZW50cywgX25vZGUkbGVhZGluZ0NvbW1lbnRzMjtcbiAgICBpZiAoIW5vZGUpIHJldHVybjtcbiAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgY29uc3Qgb2xkQ29uY2lzZSA9IGZvcm1hdC5jb25jaXNlO1xuICAgIGlmIChub2RlLl9jb21wYWN0KSB7XG4gICAgICBmb3JtYXQuY29uY2lzZSA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHByaW50TWV0aG9kID0gdGhpc1tub2RlVHlwZV07XG4gICAgaWYgKHByaW50TWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihgdW5rbm93biBub2RlIG9mIHR5cGUgJHtKU09OLnN0cmluZ2lmeShub2RlVHlwZSl9IHdpdGggY29uc3RydWN0b3IgJHtKU09OLnN0cmluZ2lmeShub2RlLmNvbnN0cnVjdG9yLm5hbWUpfWApO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgY29uc3Qgb2xkSW5BdXggPSB0aGlzLl9pbnNpZGVBdXg7XG4gICAgdGhpcy5faW5zaWRlQXV4ID0gbm9kZS5sb2MgPT0gbnVsbDtcbiAgICB0aGlzLl9tYXliZUFkZEF1eENvbW1lbnQodGhpcy5faW5zaWRlQXV4ICYmICFvbGRJbkF1eCk7XG4gICAgY29uc3QgcGFyZW50aGVzaXplZCA9IChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRleHRyYS5wYXJlbnRoZXNpemVkO1xuICAgIGxldCBzaG91bGRQcmludFBhcmVucyA9IHBhcmVudGhlc2l6ZWQgJiYgZm9ybWF0LnByZXNlcnZlRm9ybWF0IHx8IHBhcmVudGhlc2l6ZWQgJiYgZm9ybWF0LnJldGFpbkZ1bmN0aW9uUGFyZW5zICYmIG5vZGVUeXBlID09PSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiIHx8IG5lZWRzUGFyZW5zKG5vZGUsIHBhcmVudCwgdGhpcy50b2tlbkNvbnRleHQsIHRoaXMuaW5Gb3JTdGF0ZW1lbnRJbml0LCBmb3JtYXQucHJlc2VydmVGb3JtYXQgPyB0aGlzLl9ib3VuZEdldFJhd0lkZW50aWZpZXIgOiB1bmRlZmluZWQpO1xuICAgIGlmICghc2hvdWxkUHJpbnRQYXJlbnMgJiYgcGFyZW50aGVzaXplZCAmJiAoX25vZGUkbGVhZGluZ0NvbW1lbnRzID0gbm9kZS5sZWFkaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX25vZGUkbGVhZGluZ0NvbW1lbnRzLmxlbmd0aCAmJiBub2RlLmxlYWRpbmdDb21tZW50c1swXS50eXBlID09PSBcIkNvbW1lbnRCbG9ja1wiKSB7XG4gICAgICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQudHlwZTtcbiAgICAgIHN3aXRjaCAocGFyZW50VHlwZSkge1xuICAgICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdG9yXCI6XG4gICAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGlmIChwYXJlbnQuY2FsbGVlICE9PSBub2RlKSBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzaG91bGRQcmludFBhcmVucyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpbmRlbnRQYXJlbnRoZXNpemVkID0gZmFsc2U7XG4gICAgaWYgKCFzaG91bGRQcmludFBhcmVucyAmJiB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yICYmICgoX25vZGUkbGVhZGluZ0NvbW1lbnRzMiA9IG5vZGUubGVhZGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJGxlYWRpbmdDb21tZW50czIuc29tZShjb21tZW50SXNOZXdsaW5lKSB8fCB0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcyAmJiBub2RlLmxvYyAmJiBub2RlLmxvYy5zdGFydC5saW5lID4gdGhpcy5fYnVmLmdldEN1cnJlbnRMaW5lKCkpKSB7XG4gICAgICBzaG91bGRQcmludFBhcmVucyA9IHRydWU7XG4gICAgICBpbmRlbnRQYXJlbnRoZXNpemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG9sZE5vTGluZVRlcm1pbmF0b3JBZnRlck5vZGU7XG4gICAgbGV0IG9sZEluRm9yU3RhdGVtZW50SW5pdFdhc1RydWU7XG4gICAgaWYgKCFzaG91bGRQcmludFBhcmVucykge1xuICAgICAgbm9MaW5lVGVybWluYXRvckFmdGVyIHx8IChub0xpbmVUZXJtaW5hdG9yQWZ0ZXIgPSBwYXJlbnQgJiYgdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9PT0gcGFyZW50ICYmIG4uaXNMYXN0Q2hpbGQocGFyZW50LCBub2RlKSk7XG4gICAgICBpZiAobm9MaW5lVGVybWluYXRvckFmdGVyKSB7XG4gICAgICAgIHZhciBfbm9kZSR0cmFpbGluZ0NvbW1lbnQ7XG4gICAgICAgIGlmICgoX25vZGUkdHJhaWxpbmdDb21tZW50ID0gbm9kZS50cmFpbGluZ0NvbW1lbnRzKSAhPSBudWxsICYmIF9ub2RlJHRyYWlsaW5nQ29tbWVudC5zb21lKGNvbW1lbnRJc05ld2xpbmUpKSB7XG4gICAgICAgICAgaWYgKGlzRXhwcmVzc2lvbihub2RlKSkgc2hvdWxkUHJpbnRQYXJlbnMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZE5vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlO1xuICAgICAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzaG91bGRQcmludFBhcmVucykge1xuICAgICAgdGhpcy50b2tlbkNoYXIoNDApO1xuICAgICAgaWYgKGluZGVudFBhcmVudGhlc2l6ZWQpIHRoaXMuaW5kZW50KCk7XG4gICAgICB0aGlzLl9lbmRzV2l0aElubmVyUmF3ID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5pbkZvclN0YXRlbWVudEluaXQpIHtcbiAgICAgICAgb2xkSW5Gb3JTdGF0ZW1lbnRJbml0V2FzVHJ1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5Gb3JTdGF0ZW1lbnRJbml0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvbGROb0xpbmVUZXJtaW5hdG9yQWZ0ZXJOb2RlID0gdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZTtcbiAgICAgIHRoaXMuX25vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9sYXN0Q29tbWVudExpbmUgPSAwO1xuICAgIHRoaXMuX3ByaW50TGVhZGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCk7XG4gICAgY29uc3QgbG9jID0gbm9kZVR5cGUgPT09IFwiUHJvZ3JhbVwiIHx8IG5vZGVUeXBlID09PSBcIkZpbGVcIiA/IG51bGwgOiBub2RlLmxvYztcbiAgICB0aGlzLmV4YWN0U291cmNlKGxvYywgcHJpbnRNZXRob2QuYmluZCh0aGlzLCBub2RlLCBwYXJlbnQpKTtcbiAgICBpZiAoc2hvdWxkUHJpbnRQYXJlbnMpIHtcbiAgICAgIHRoaXMuX3ByaW50VHJhaWxpbmdDb21tZW50cyhub2RlLCBwYXJlbnQpO1xuICAgICAgaWYgKGluZGVudFBhcmVudGhlc2l6ZWQpIHtcbiAgICAgICAgdGhpcy5kZWRlbnQoKTtcbiAgICAgICAgdGhpcy5uZXdsaW5lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnRva2VuQ2hhcig0MSk7XG4gICAgICB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yID0gbm9MaW5lVGVybWluYXRvckFmdGVyO1xuICAgICAgaWYgKG9sZEluRm9yU3RhdGVtZW50SW5pdFdhc1RydWUpIHRoaXMuaW5Gb3JTdGF0ZW1lbnRJbml0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5vTGluZVRlcm1pbmF0b3JBZnRlciAmJiAhdGhpcy5fbm9MaW5lVGVybWluYXRvcikge1xuICAgICAgdGhpcy5fbm9MaW5lVGVybWluYXRvciA9IHRydWU7XG4gICAgICB0aGlzLl9wcmludFRyYWlsaW5nQ29tbWVudHMobm9kZSwgcGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJpbnRUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCwgdHJhaWxpbmdDb21tZW50c0xpbmVPZmZzZXQpO1xuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IHBhcmVudDtcbiAgICBmb3JtYXQuY29uY2lzZSA9IG9sZENvbmNpc2U7XG4gICAgdGhpcy5faW5zaWRlQXV4ID0gb2xkSW5BdXg7XG4gICAgaWYgKG9sZE5vTGluZVRlcm1pbmF0b3JBZnRlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fbm9MaW5lVGVybWluYXRvckFmdGVyTm9kZSA9IG9sZE5vTGluZVRlcm1pbmF0b3JBZnRlck5vZGU7XG4gICAgfVxuICAgIHRoaXMuX2VuZHNXaXRoSW5uZXJSYXcgPSBmYWxzZTtcbiAgfVxuICBfbWF5YmVBZGRBdXhDb21tZW50KGVudGVyZWRQb3NpdGlvbmxlc3NOb2RlKSB7XG4gICAgaWYgKGVudGVyZWRQb3NpdGlvbmxlc3NOb2RlKSB0aGlzLl9wcmludEF1eEJlZm9yZUNvbW1lbnQoKTtcbiAgICBpZiAoIXRoaXMuX2luc2lkZUF1eCkgdGhpcy5fcHJpbnRBdXhBZnRlckNvbW1lbnQoKTtcbiAgfVxuICBfcHJpbnRBdXhCZWZvcmVDb21tZW50KCkge1xuICAgIGlmICh0aGlzLl9wcmludEF1eEFmdGVyT25OZXh0VXNlck5vZGUpIHJldHVybjtcbiAgICB0aGlzLl9wcmludEF1eEFmdGVyT25OZXh0VXNlck5vZGUgPSB0cnVlO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLmZvcm1hdC5hdXhpbGlhcnlDb21tZW50QmVmb3JlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICB0aGlzLl9wcmludENvbW1lbnQoe1xuICAgICAgICB0eXBlOiBcIkNvbW1lbnRCbG9ja1wiLFxuICAgICAgICB2YWx1ZTogY29tbWVudFxuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG4gIF9wcmludEF1eEFmdGVyQ29tbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSkgcmV0dXJuO1xuICAgIHRoaXMuX3ByaW50QXV4QWZ0ZXJPbk5leHRVc2VyTm9kZSA9IGZhbHNlO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLmZvcm1hdC5hdXhpbGlhcnlDb21tZW50QWZ0ZXI7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHRoaXMuX3ByaW50Q29tbWVudCh7XG4gICAgICAgIHR5cGU6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgICAgIHZhbHVlOiBjb21tZW50XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9zc2libGVSYXcobm9kZSkge1xuICAgIGNvbnN0IGV4dHJhID0gbm9kZS5leHRyYTtcbiAgICBpZiAoKGV4dHJhID09IG51bGwgPyB2b2lkIDAgOiBleHRyYS5yYXcpICE9IG51bGwgJiYgZXh0cmEucmF3VmFsdWUgIT0gbnVsbCAmJiBub2RlLnZhbHVlID09PSBleHRyYS5yYXdWYWx1ZSkge1xuICAgICAgcmV0dXJuIGV4dHJhLnJhdztcbiAgICB9XG4gIH1cbiAgcHJpbnRKb2luKG5vZGVzLCBvcHRzID0ge30pIHtcbiAgICBpZiAoIShub2RlcyAhPSBudWxsICYmIG5vZGVzLmxlbmd0aCkpIHJldHVybjtcbiAgICBsZXQge1xuICAgICAgaW5kZW50XG4gICAgfSA9IG9wdHM7XG4gICAgaWYgKGluZGVudCA9PSBudWxsICYmIHRoaXMuZm9ybWF0LnJldGFpbkxpbmVzKSB7XG4gICAgICB2YXIgX25vZGVzJDAkbG9jO1xuICAgICAgY29uc3Qgc3RhcnRMaW5lID0gKF9ub2RlcyQwJGxvYyA9IG5vZGVzWzBdLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlcyQwJGxvYy5zdGFydC5saW5lO1xuICAgICAgaWYgKHN0YXJ0TGluZSAhPSBudWxsICYmIHN0YXJ0TGluZSAhPT0gdGhpcy5fYnVmLmdldEN1cnJlbnRMaW5lKCkpIHtcbiAgICAgICAgaW5kZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluZGVudCkgdGhpcy5pbmRlbnQoKTtcbiAgICBjb25zdCBuZXdsaW5lT3B0cyA9IHtcbiAgICAgIGFkZE5ld2xpbmVzOiBvcHRzLmFkZE5ld2xpbmVzLFxuICAgICAgbmV4dE5vZGVTdGFydExpbmU6IDBcbiAgICB9O1xuICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdHMuc2VwYXJhdG9yID8gb3B0cy5zZXBhcmF0b3IuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgY29uc3QgbGVuID0gbm9kZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgICBpZiAob3B0cy5zdGF0ZW1lbnQpIHRoaXMuX3ByaW50TmV3bGluZShpID09PSAwLCBuZXdsaW5lT3B0cyk7XG4gICAgICB0aGlzLnByaW50KG5vZGUsIHVuZGVmaW5lZCwgb3B0cy50cmFpbGluZ0NvbW1lbnRzTGluZU9mZnNldCB8fCAwKTtcbiAgICAgIG9wdHMuaXRlcmF0b3IgPT0gbnVsbCB8fCBvcHRzLml0ZXJhdG9yKG5vZGUsIGkpO1xuICAgICAgaWYgKHNlcGFyYXRvciAhPSBudWxsKSB7XG4gICAgICAgIGlmIChpIDwgbGVuIC0gMSkgc2VwYXJhdG9yKGksIGZhbHNlKTtlbHNlIGlmIChvcHRzLnByaW50VHJhaWxpbmdTZXBhcmF0b3IpIHNlcGFyYXRvcihpLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnN0YXRlbWVudCkge1xuICAgICAgICB2YXIgX25vZGUkdHJhaWxpbmdDb21tZW50MjtcbiAgICAgICAgaWYgKCEoKF9ub2RlJHRyYWlsaW5nQ29tbWVudDIgPSBub2RlLnRyYWlsaW5nQ29tbWVudHMpICE9IG51bGwgJiYgX25vZGUkdHJhaWxpbmdDb21tZW50Mi5sZW5ndGgpKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdENvbW1lbnRMaW5lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSArIDEgPT09IGxlbikge1xuICAgICAgICAgIHRoaXMubmV3bGluZSgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX25leHROb2RlJGxvYztcbiAgICAgICAgICBjb25zdCBuZXh0Tm9kZSA9IG5vZGVzW2kgKyAxXTtcbiAgICAgICAgICBuZXdsaW5lT3B0cy5uZXh0Tm9kZVN0YXJ0TGluZSA9ICgoX25leHROb2RlJGxvYyA9IG5leHROb2RlLmxvYykgPT0gbnVsbCA/IHZvaWQgMCA6IF9uZXh0Tm9kZSRsb2Muc3RhcnQubGluZSkgfHwgMDtcbiAgICAgICAgICB0aGlzLl9wcmludE5ld2xpbmUodHJ1ZSwgbmV3bGluZU9wdHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbmRlbnQpIHRoaXMuZGVkZW50KCk7XG4gIH1cbiAgcHJpbnRBbmRJbmRlbnRPbkNvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBub2RlLmxlYWRpbmdDb21tZW50cyAmJiBub2RlLmxlYWRpbmdDb21tZW50cy5sZW5ndGggPiAwO1xuICAgIGlmIChpbmRlbnQpIHRoaXMuaW5kZW50KCk7XG4gICAgdGhpcy5wcmludChub2RlKTtcbiAgICBpZiAoaW5kZW50KSB0aGlzLmRlZGVudCgpO1xuICB9XG4gIHByaW50QmxvY2socGFyZW50KSB7XG4gICAgY29uc3Qgbm9kZSA9IHBhcmVudC5ib2R5O1xuICAgIGlmIChub2RlLnR5cGUgIT09IFwiRW1wdHlTdGF0ZW1lbnRcIikge1xuICAgICAgdGhpcy5zcGFjZSgpO1xuICAgIH1cbiAgICB0aGlzLnByaW50KG5vZGUpO1xuICB9XG4gIF9wcmludFRyYWlsaW5nQ29tbWVudHMobm9kZSwgcGFyZW50LCBsaW5lT2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaW5uZXJDb21tZW50cyxcbiAgICAgIHRyYWlsaW5nQ29tbWVudHNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoaW5uZXJDb21tZW50cyAhPSBudWxsICYmIGlubmVyQ29tbWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9wcmludENvbW1lbnRzKDIsIGlubmVyQ29tbWVudHMsIG5vZGUsIHBhcmVudCwgbGluZU9mZnNldCk7XG4gICAgfVxuICAgIGlmICh0cmFpbGluZ0NvbW1lbnRzICE9IG51bGwgJiYgdHJhaWxpbmdDb21tZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ByaW50Q29tbWVudHMoMiwgdHJhaWxpbmdDb21tZW50cywgbm9kZSwgcGFyZW50LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgX3ByaW50TGVhZGluZ0NvbW1lbnRzKG5vZGUsIHBhcmVudCkge1xuICAgIGNvbnN0IGNvbW1lbnRzID0gbm9kZS5sZWFkaW5nQ29tbWVudHM7XG4gICAgaWYgKCEoY29tbWVudHMgIT0gbnVsbCAmJiBjb21tZW50cy5sZW5ndGgpKSByZXR1cm47XG4gICAgdGhpcy5fcHJpbnRDb21tZW50cygwLCBjb21tZW50cywgbm9kZSwgcGFyZW50KTtcbiAgfVxuICBfbWF5YmVQcmludElubmVyQ29tbWVudHMobmV4dFRva2VuU3RyLCBuZXh0VG9rZW5PY2N1cnJlbmNlQ291bnQpIHtcbiAgICBpZiAodGhpcy5fZW5kc1dpdGhJbm5lclJhdykge1xuICAgICAgdmFyIF90aGlzJHRva2VuTWFwO1xuICAgICAgdGhpcy5wcmludElubmVyQ29tbWVudHMoKF90aGlzJHRva2VuTWFwID0gdGhpcy50b2tlbk1hcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHRva2VuTWFwLmZpbmRNYXRjaGluZyh0aGlzLl9jdXJyZW50Tm9kZSwgbmV4dFRva2VuU3RyLCBuZXh0VG9rZW5PY2N1cnJlbmNlQ291bnQpKTtcbiAgICB9XG4gICAgdGhpcy5fZW5kc1dpdGhJbm5lclJhdyA9IHRydWU7XG4gICAgdGhpcy5faW5kZW50SW5uZXJDb21tZW50cyA9IHRydWU7XG4gIH1cbiAgcHJpbnRJbm5lckNvbW1lbnRzKG5leHRUb2tlbikge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICBjb25zdCBjb21tZW50cyA9IG5vZGUuaW5uZXJDb21tZW50cztcbiAgICBpZiAoIShjb21tZW50cyAhPSBudWxsICYmIGNvbW1lbnRzLmxlbmd0aCkpIHJldHVybjtcbiAgICBjb25zdCBoYXNTcGFjZSA9IHRoaXMuZW5kc1dpdGgoMzIpO1xuICAgIGNvbnN0IGluZGVudCA9IHRoaXMuX2luZGVudElubmVyQ29tbWVudHM7XG4gICAgY29uc3QgcHJpbnRlZENvbW1lbnRzQ291bnQgPSB0aGlzLl9wcmludGVkQ29tbWVudHMuc2l6ZTtcbiAgICBpZiAoaW5kZW50KSB0aGlzLmluZGVudCgpO1xuICAgIHRoaXMuX3ByaW50Q29tbWVudHMoMSwgY29tbWVudHMsIG5vZGUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBuZXh0VG9rZW4pO1xuICAgIGlmIChoYXNTcGFjZSAmJiBwcmludGVkQ29tbWVudHNDb3VudCAhPT0gdGhpcy5fcHJpbnRlZENvbW1lbnRzLnNpemUpIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgaWYgKGluZGVudCkgdGhpcy5kZWRlbnQoKTtcbiAgfVxuICBub0luZGVudElubmVyQ29tbWVudHNIZXJlKCkge1xuICAgIHRoaXMuX2luZGVudElubmVyQ29tbWVudHMgPSBmYWxzZTtcbiAgfVxuICBwcmludFNlcXVlbmNlKG5vZGVzLCBvcHRzID0ge30pIHtcbiAgICB2YXIgX29wdHMkaW5kZW50O1xuICAgIG9wdHMuc3RhdGVtZW50ID0gdHJ1ZTtcbiAgICAoX29wdHMkaW5kZW50ID0gb3B0cy5pbmRlbnQpICE9IG51bGwgPyBfb3B0cyRpbmRlbnQgOiBvcHRzLmluZGVudCA9IGZhbHNlO1xuICAgIHRoaXMucHJpbnRKb2luKG5vZGVzLCBvcHRzKTtcbiAgfVxuICBwcmludExpc3QoaXRlbXMsIG9wdHMgPSB7fSkge1xuICAgIGlmIChvcHRzLnNlcGFyYXRvciA9PSBudWxsKSB7XG4gICAgICBvcHRzLnNlcGFyYXRvciA9IGNvbW1hU2VwYXJhdG9yO1xuICAgIH1cbiAgICB0aGlzLnByaW50Sm9pbihpdGVtcywgb3B0cyk7XG4gIH1cbiAgc2hvdWxkUHJpbnRUcmFpbGluZ0NvbW1hKGxpc3RFbmQpIHtcbiAgICBpZiAoIXRoaXMudG9rZW5NYXApIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGxpc3RFbmRJbmRleCA9IHRoaXMudG9rZW5NYXAuZmluZExhc3RJbmRleCh0aGlzLl9jdXJyZW50Tm9kZSwgdG9rZW4gPT4gdGhpcy50b2tlbk1hcC5tYXRjaGVzT3JpZ2luYWwodG9rZW4sIGxpc3RFbmQpKTtcbiAgICBpZiAobGlzdEVuZEluZGV4IDw9IDApIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnRva2VuTWFwLm1hdGNoZXNPcmlnaW5hbCh0aGlzLl90b2tlbnNbbGlzdEVuZEluZGV4IC0gMV0sIFwiLFwiKTtcbiAgfVxuICBfcHJpbnROZXdsaW5lKG5ld0xpbmUsIG9wdHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICBpZiAoZm9ybWF0LnJldGFpbkxpbmVzIHx8IGZvcm1hdC5jb21wYWN0KSByZXR1cm47XG4gICAgaWYgKGZvcm1hdC5jb25jaXNlKSB7XG4gICAgICB0aGlzLnNwYWNlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbmV3TGluZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExpbmUgPSBvcHRzLm5leHROb2RlU3RhcnRMaW5lO1xuICAgIGNvbnN0IGxhc3RDb21tZW50TGluZSA9IHRoaXMuX2xhc3RDb21tZW50TGluZTtcbiAgICBpZiAoc3RhcnRMaW5lID4gMCAmJiBsYXN0Q29tbWVudExpbmUgPiAwKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBzdGFydExpbmUgLSBsYXN0Q29tbWVudExpbmU7XG4gICAgICBpZiAob2Zmc2V0ID49IDApIHtcbiAgICAgICAgdGhpcy5uZXdsaW5lKG9mZnNldCB8fCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5fYnVmLmhhc0NvbnRlbnQoKSkge1xuICAgICAgdGhpcy5uZXdsaW5lKDEpO1xuICAgIH1cbiAgfVxuICBfc2hvdWxkUHJpbnRDb21tZW50KGNvbW1lbnQsIG5leHRUb2tlbikge1xuICAgIGlmIChjb21tZW50Lmlnbm9yZSkgcmV0dXJuIDA7XG4gICAgaWYgKHRoaXMuX3ByaW50ZWRDb21tZW50cy5oYXMoY29tbWVudCkpIHJldHVybiAwO1xuICAgIGlmICh0aGlzLl9ub0xpbmVUZXJtaW5hdG9yICYmIEhBU19ORVdMSU5FX09SX0JsT0NLX0NPTU1FTlRfRU5ELnRlc3QoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAobmV4dFRva2VuICYmIHRoaXMudG9rZW5NYXApIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRUb2sgPSB0aGlzLnRva2VuTWFwLmZpbmQodGhpcy5fY3VycmVudE5vZGUsIHRva2VuID0+IHRva2VuLnZhbHVlID09PSBjb21tZW50LnZhbHVlKTtcbiAgICAgIGlmIChjb21tZW50VG9rICYmIGNvbW1lbnRUb2suc3RhcnQgPiBuZXh0VG9rZW4uc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3ByaW50ZWRDb21tZW50cy5hZGQoY29tbWVudCk7XG4gICAgaWYgKCF0aGlzLmZvcm1hdC5zaG91bGRQcmludENvbW1lbnQoY29tbWVudC52YWx1ZSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfVxuICBfcHJpbnRDb21tZW50KGNvbW1lbnQsIHNraXBOZXdMaW5lcykge1xuICAgIGNvbnN0IG5vTGluZVRlcm1pbmF0b3IgPSB0aGlzLl9ub0xpbmVUZXJtaW5hdG9yO1xuICAgIGNvbnN0IGlzQmxvY2tDb21tZW50ID0gY29tbWVudC50eXBlID09PSBcIkNvbW1lbnRCbG9ja1wiO1xuICAgIGNvbnN0IHByaW50TmV3TGluZXMgPSBpc0Jsb2NrQ29tbWVudCAmJiBza2lwTmV3TGluZXMgIT09IDEgJiYgIXRoaXMuX25vTGluZVRlcm1pbmF0b3I7XG4gICAgaWYgKHByaW50TmV3TGluZXMgJiYgdGhpcy5fYnVmLmhhc0NvbnRlbnQoKSAmJiBza2lwTmV3TGluZXMgIT09IDIpIHtcbiAgICAgIHRoaXMubmV3bGluZSgxKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENoYXJDb2RlID0gdGhpcy5nZXRMYXN0Q2hhcigpO1xuICAgIGlmIChsYXN0Q2hhckNvZGUgIT09IDkxICYmIGxhc3RDaGFyQ29kZSAhPT0gMTIzICYmIGxhc3RDaGFyQ29kZSAhPT0gNDApIHtcbiAgICAgIHRoaXMuc3BhY2UoKTtcbiAgICB9XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoaXNCbG9ja0NvbW1lbnQpIHtcbiAgICAgIHZhbCA9IGAvKiR7Y29tbWVudC52YWx1ZX0qL2A7XG4gICAgICBpZiAodGhpcy5mb3JtYXQuaW5kZW50LmFkanVzdE11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgdmFyIF9jb21tZW50JGxvYztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKF9jb21tZW50JGxvYyA9IGNvbW1lbnQubG9jKSA9PSBudWxsID8gdm9pZCAwIDogX2NvbW1lbnQkbG9jLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgaWYgKG9mZnNldCkge1xuICAgICAgICAgIGNvbnN0IG5ld2xpbmVSZWdleCA9IG5ldyBSZWdFeHAoXCJcXFxcblxcXFxzezEsXCIgKyBvZmZzZXQgKyBcIn1cIiwgXCJnXCIpO1xuICAgICAgICAgIHZhbCA9IHZhbC5yZXBsYWNlKG5ld2xpbmVSZWdleCwgXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0LmNvbmNpc2UpIHtcbiAgICAgICAgICB2YWwgPSB2YWwucmVwbGFjZSgvXFxuKD8hJCkvZywgYFxcbmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpbmRlbnRTaXplID0gdGhpcy5mb3JtYXQucmV0YWluTGluZXMgPyAwIDogdGhpcy5fYnVmLmdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICAgICAgICBpZiAodGhpcy5fc2hvdWxkSW5kZW50KDQ3KSB8fCB0aGlzLmZvcm1hdC5yZXRhaW5MaW5lcykge1xuICAgICAgICAgICAgaW5kZW50U2l6ZSArPSB0aGlzLl9nZXRJbmRlbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoL1xcbig/ISQpL2csIGBcXG4ke1wiIFwiLnJlcGVhdChpbmRlbnRTaXplKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW5vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHZhbCA9IGAvLyR7Y29tbWVudC52YWx1ZX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBgLyoke2NvbW1lbnQudmFsdWV9Ki9gO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZW5kc1dpdGhEaXYpIHRoaXMuX3NwYWNlKCk7XG4gICAgdGhpcy5zb3VyY2UoXCJzdGFydFwiLCBjb21tZW50LmxvYyk7XG4gICAgdGhpcy5fYXBwZW5kKHZhbCwgaXNCbG9ja0NvbW1lbnQpO1xuICAgIGlmICghaXNCbG9ja0NvbW1lbnQgJiYgIW5vTGluZVRlcm1pbmF0b3IpIHtcbiAgICAgIHRoaXMubmV3bGluZSgxLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHByaW50TmV3TGluZXMgJiYgc2tpcE5ld0xpbmVzICE9PSAzKSB7XG4gICAgICB0aGlzLm5ld2xpbmUoMSk7XG4gICAgfVxuICB9XG4gIF9wcmludENvbW1lbnRzKHR5cGUsIGNvbW1lbnRzLCBub2RlLCBwYXJlbnQsIGxpbmVPZmZzZXQgPSAwLCBuZXh0VG9rZW4pIHtcbiAgICBjb25zdCBub2RlTG9jID0gbm9kZS5sb2M7XG4gICAgY29uc3QgbGVuID0gY29tbWVudHMubGVuZ3RoO1xuICAgIGxldCBoYXNMb2MgPSAhIW5vZGVMb2M7XG4gICAgY29uc3Qgbm9kZVN0YXJ0TGluZSA9IGhhc0xvYyA/IG5vZGVMb2Muc3RhcnQubGluZSA6IDA7XG4gICAgY29uc3Qgbm9kZUVuZExpbmUgPSBoYXNMb2MgPyBub2RlTG9jLmVuZC5saW5lIDogMDtcbiAgICBsZXQgbGFzdExpbmUgPSAwO1xuICAgIGxldCBsZWFkaW5nQ29tbWVudE5ld2xpbmUgPSAwO1xuICAgIGNvbnN0IG1heWJlTmV3bGluZSA9IHRoaXMuX25vTGluZVRlcm1pbmF0b3IgPyBmdW5jdGlvbiAoKSB7fSA6IHRoaXMubmV3bGluZS5iaW5kKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbW1lbnQgPSBjb21tZW50c1tpXTtcbiAgICAgIGNvbnN0IHNob3VsZFByaW50ID0gdGhpcy5fc2hvdWxkUHJpbnRDb21tZW50KGNvbW1lbnQsIG5leHRUb2tlbik7XG4gICAgICBpZiAoc2hvdWxkUHJpbnQgPT09IDIpIHtcbiAgICAgICAgaGFzTG9jID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGhhc0xvYyAmJiBjb21tZW50LmxvYyAmJiBzaG91bGRQcmludCA9PT0gMSkge1xuICAgICAgICBjb25zdCBjb21tZW50U3RhcnRMaW5lID0gY29tbWVudC5sb2Muc3RhcnQubGluZTtcbiAgICAgICAgY29uc3QgY29tbWVudEVuZExpbmUgPSBjb21tZW50LmxvYy5lbmQubGluZTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1Zi5oYXNDb250ZW50KCkgJiYgKGNvbW1lbnQudHlwZSA9PT0gXCJDb21tZW50TGluZVwiIHx8IGNvbW1lbnRTdGFydExpbmUgIT09IGNvbW1lbnRFbmRMaW5lKSkge1xuICAgICAgICAgICAgICBvZmZzZXQgPSBsZWFkaW5nQ29tbWVudE5ld2xpbmUgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBjb21tZW50U3RhcnRMaW5lIC0gbGFzdExpbmU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RMaW5lID0gY29tbWVudEVuZExpbmU7XG4gICAgICAgICAgbWF5YmVOZXdsaW5lKG9mZnNldCk7XG4gICAgICAgICAgdGhpcy5fcHJpbnRDb21tZW50KGNvbW1lbnQsIDEpO1xuICAgICAgICAgIGlmIChpICsgMSA9PT0gbGVuKSB7XG4gICAgICAgICAgICBtYXliZU5ld2xpbmUoTWF0aC5tYXgobm9kZVN0YXJ0TGluZSAtIGxhc3RMaW5lLCBsZWFkaW5nQ29tbWVudE5ld2xpbmUpKTtcbiAgICAgICAgICAgIGxhc3RMaW5lID0gbm9kZVN0YXJ0TGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGNvbW1lbnRTdGFydExpbmUgLSAoaSA9PT0gMCA/IG5vZGVTdGFydExpbmUgOiBsYXN0TGluZSk7XG4gICAgICAgICAgbGFzdExpbmUgPSBjb21tZW50RW5kTGluZTtcbiAgICAgICAgICBtYXliZU5ld2xpbmUob2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgMSk7XG4gICAgICAgICAgaWYgKGkgKyAxID09PSBsZW4pIHtcbiAgICAgICAgICAgIG1heWJlTmV3bGluZShNYXRoLm1pbigxLCBub2RlRW5kTGluZSAtIGxhc3RMaW5lKSk7XG4gICAgICAgICAgICBsYXN0TGluZSA9IG5vZGVFbmRMaW5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjb21tZW50U3RhcnRMaW5lIC0gKGkgPT09IDAgPyBub2RlRW5kTGluZSAtIGxpbmVPZmZzZXQgOiBsYXN0TGluZSk7XG4gICAgICAgICAgbGFzdExpbmUgPSBjb21tZW50RW5kTGluZTtcbiAgICAgICAgICBtYXliZU5ld2xpbmUob2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc0xvYyA9IGZhbHNlO1xuICAgICAgICBpZiAoc2hvdWxkUHJpbnQgIT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgY29uc3Qgc2luZ2xlTGluZSA9IGNvbW1lbnQubG9jID8gY29tbWVudC5sb2Muc3RhcnQubGluZSA9PT0gY29tbWVudC5sb2MuZW5kLmxpbmUgOiAhSEFTX05FV0xJTkUudGVzdChjb21tZW50LnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBzaG91bGRTa2lwTmV3bGluZSA9IHNpbmdsZUxpbmUgJiYgIWlzU3RhdGVtZW50KG5vZGUpICYmICFpc0NsYXNzQm9keShwYXJlbnQpICYmICFpc1RTSW50ZXJmYWNlQm9keShwYXJlbnQpICYmICFpc1RTRW51bURlY2xhcmF0aW9uKHBhcmVudCk7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW50Q29tbWVudChjb21tZW50LCBzaG91bGRTa2lwTmV3bGluZSAmJiBub2RlLnR5cGUgIT09IFwiT2JqZWN0RXhwcmVzc2lvblwiIHx8IHNpbmdsZUxpbmUgJiYgaXNGdW5jdGlvbihwYXJlbnQsIHtcbiAgICAgICAgICAgICAgYm9keTogbm9kZVxuICAgICAgICAgICAgfSkgPyAxIDogMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRTa2lwTmV3bGluZSAmJiB0eXBlID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3ByaW50Q29tbWVudChjb21tZW50LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMSAmJiAhKG5vZGUudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIgJiYgbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCA+IDEpICYmIG5vZGUudHlwZSAhPT0gXCJDbGFzc0JvZHlcIiAmJiBub2RlLnR5cGUgIT09IFwiVFNJbnRlcmZhY2VCb2R5XCIpIHtcbiAgICAgICAgICB0aGlzLl9wcmludENvbW1lbnQoY29tbWVudCwgaSA9PT0gMCA/IDIgOiBpID09PSBsZW4gLSAxID8gMyA6IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ByaW50Q29tbWVudChjb21tZW50LCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gMiAmJiBoYXNMb2MgJiYgbGFzdExpbmUpIHtcbiAgICAgIHRoaXMuX2xhc3RDb21tZW50TGluZSA9IGxhc3RMaW5lO1xuICAgIH1cbiAgfVxufVxuT2JqZWN0LmFzc2lnbihQcmludGVyLnByb3RvdHlwZSwgZ2VuZXJhdG9yRnVuY3Rpb25zKTtcbntcbiAgUHJpbnRlci5wcm90b3R5cGUuTm9vcCA9IGZ1bmN0aW9uIE5vb3AoKSB7fTtcbn1cbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IFByaW50ZXI7XG5mdW5jdGlvbiBjb21tYVNlcGFyYXRvcihvY2N1cnJlbmNlQ291bnQsIGxhc3QpIHtcbiAgdGhpcy50b2tlbihcIixcIiwgZmFsc2UsIG9jY3VycmVuY2VDb3VudCk7XG4gIGlmICghbGFzdCkgdGhpcy5zcGFjZSgpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///66636\n')},44068:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _genMapping = __webpack_require__(99320);\nvar _traceMapping = __webpack_require__(92802);\nclass SourceMap {\n  constructor(opts, code) {\n    var _opts$sourceFileName;\n    this._map = void 0;\n    this._rawMappings = void 0;\n    this._sourceFileName = void 0;\n    this._lastGenLine = 0;\n    this._lastSourceLine = 0;\n    this._lastSourceColumn = 0;\n    this._inputMap = void 0;\n    const map = this._map = new _genMapping.GenMapping({\n      sourceRoot: opts.sourceRoot\n    });\n    this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\\\/g, "/");\n    this._rawMappings = undefined;\n    if (opts.inputSourceMap) {\n      this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          var _this$_inputMap$sourc;\n          (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);\n        }\n      }\n    }\n    if (typeof code === "string" && !opts.inputSourceMap) {\n      (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);\n    } else if (typeof code === "object") {\n      for (const sourceFileName of Object.keys(code)) {\n        (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\\\/g, "/"), code[sourceFileName]);\n      }\n    }\n  }\n  get() {\n    return (0, _genMapping.toEncodedMap)(this._map);\n  }\n  getDecoded() {\n    return (0, _genMapping.toDecodedMap)(this._map);\n  }\n  getRawMappings() {\n    return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));\n  }\n  mark(generated, line, column, identifierName, identifierNamePos, filename) {\n    var _originalMapping;\n    this._rawMappings = undefined;\n    let originalMapping;\n    if (line != null) {\n      if (this._inputMap) {\n        originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {\n          line,\n          column\n        });\n        if (!originalMapping.name && identifierNamePos) {\n          const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          source: (filename == null ? void 0 : filename.replace(/\\\\/g, "/")) || this._sourceFileName,\n          line: line,\n          column: column\n        };\n      }\n    }\n    (0, _genMapping.maybeAddMapping)(this._map, {\n      name: identifierName,\n      generated,\n      source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,\n      original: originalMapping\n    });\n  }\n}\nexports["default"] = SourceMap;\n\n//# sourceMappingURL=source-map.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQwNjguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixrQkFBa0IsbUJBQU8sQ0FBQyxLQUF5QjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyxLQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvZ2VuZXJhdG9yL2xpYi9zb3VyY2UtbWFwLmpzP2MyYzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2dlbk1hcHBpbmcgPSByZXF1aXJlKFwiQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmdcIik7XG52YXIgX3RyYWNlTWFwcGluZyA9IHJlcXVpcmUoXCJAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nXCIpO1xuY2xhc3MgU291cmNlTWFwIHtcbiAgY29uc3RydWN0b3Iob3B0cywgY29kZSkge1xuICAgIHZhciBfb3B0cyRzb3VyY2VGaWxlTmFtZTtcbiAgICB0aGlzLl9tYXAgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmF3TWFwcGluZ3MgPSB2b2lkIDA7XG4gICAgdGhpcy5fc291cmNlRmlsZU5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5fbGFzdEdlbkxpbmUgPSAwO1xuICAgIHRoaXMuX2xhc3RTb3VyY2VMaW5lID0gMDtcbiAgICB0aGlzLl9sYXN0U291cmNlQ29sdW1uID0gMDtcbiAgICB0aGlzLl9pbnB1dE1hcCA9IHZvaWQgMDtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXAgPSBuZXcgX2dlbk1hcHBpbmcuR2VuTWFwcGluZyh7XG4gICAgICBzb3VyY2VSb290OiBvcHRzLnNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICB0aGlzLl9zb3VyY2VGaWxlTmFtZSA9IChfb3B0cyRzb3VyY2VGaWxlTmFtZSA9IG9wdHMuc291cmNlRmlsZU5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfb3B0cyRzb3VyY2VGaWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKTtcbiAgICB0aGlzLl9yYXdNYXBwaW5ncyA9IHVuZGVmaW5lZDtcbiAgICBpZiAob3B0cy5pbnB1dFNvdXJjZU1hcCkge1xuICAgICAgdGhpcy5faW5wdXRNYXAgPSBuZXcgX3RyYWNlTWFwcGluZy5UcmFjZU1hcChvcHRzLmlucHV0U291cmNlTWFwKTtcbiAgICAgIGNvbnN0IHJlc29sdmVkU291cmNlcyA9IHRoaXMuX2lucHV0TWFwLnJlc29sdmVkU291cmNlcztcbiAgICAgIGlmIChyZXNvbHZlZFNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRTb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF9pbnB1dE1hcCRzb3VyYztcbiAgICAgICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCByZXNvbHZlZFNvdXJjZXNbaV0sIChfdGhpcyRfaW5wdXRNYXAkc291cmMgPSB0aGlzLl9pbnB1dE1hcC5zb3VyY2VzQ29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJF9pbnB1dE1hcCRzb3VyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiICYmICFvcHRzLmlucHV0U291cmNlTWFwKSB7XG4gICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCB0aGlzLl9zb3VyY2VGaWxlTmFtZSwgY29kZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgZm9yIChjb25zdCBzb3VyY2VGaWxlTmFtZSBvZiBPYmplY3Qua2V5cyhjb2RlKSkge1xuICAgICAgICAoMCwgX2dlbk1hcHBpbmcuc2V0U291cmNlQ29udGVudCkobWFwLCBzb3VyY2VGaWxlTmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSwgY29kZVtzb3VyY2VGaWxlTmFtZV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQoKSB7XG4gICAgcmV0dXJuICgwLCBfZ2VuTWFwcGluZy50b0VuY29kZWRNYXApKHRoaXMuX21hcCk7XG4gIH1cbiAgZ2V0RGVjb2RlZCgpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5NYXBwaW5nLnRvRGVjb2RlZE1hcCkodGhpcy5fbWFwKTtcbiAgfVxuICBnZXRSYXdNYXBwaW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3TWFwcGluZ3MgfHwgKHRoaXMuX3Jhd01hcHBpbmdzID0gKDAsIF9nZW5NYXBwaW5nLmFsbE1hcHBpbmdzKSh0aGlzLl9tYXApKTtcbiAgfVxuICBtYXJrKGdlbmVyYXRlZCwgbGluZSwgY29sdW1uLCBpZGVudGlmaWVyTmFtZSwgaWRlbnRpZmllck5hbWVQb3MsIGZpbGVuYW1lKSB7XG4gICAgdmFyIF9vcmlnaW5hbE1hcHBpbmc7XG4gICAgdGhpcy5fcmF3TWFwcGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9yaWdpbmFsTWFwcGluZztcbiAgICBpZiAobGluZSAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5faW5wdXRNYXApIHtcbiAgICAgICAgb3JpZ2luYWxNYXBwaW5nID0gKDAsIF90cmFjZU1hcHBpbmcub3JpZ2luYWxQb3NpdGlvbkZvcikodGhpcy5faW5wdXRNYXAsIHtcbiAgICAgICAgICBsaW5lLFxuICAgICAgICAgIGNvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbE1hcHBpbmcubmFtZSAmJiBpZGVudGlmaWVyTmFtZVBvcykge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSWRlbnRpZmllck1hcHBpbmcgPSAoMCwgX3RyYWNlTWFwcGluZy5vcmlnaW5hbFBvc2l0aW9uRm9yKSh0aGlzLl9pbnB1dE1hcCwgaWRlbnRpZmllck5hbWVQb3MpO1xuICAgICAgICAgIGlmIChvcmlnaW5hbElkZW50aWZpZXJNYXBwaW5nLm5hbWUpIHtcbiAgICAgICAgICAgIGlkZW50aWZpZXJOYW1lID0gb3JpZ2luYWxJZGVudGlmaWVyTWFwcGluZy5uYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JpZ2luYWxNYXBwaW5nID0ge1xuICAgICAgICAgIHNvdXJjZTogKGZpbGVuYW1lID09IG51bGwgPyB2b2lkIDAgOiBmaWxlbmFtZS5yZXBsYWNlKC9cXFxcL2csIFwiL1wiKSkgfHwgdGhpcy5fc291cmNlRmlsZU5hbWUsXG4gICAgICAgICAgbGluZTogbGluZSxcbiAgICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICAoMCwgX2dlbk1hcHBpbmcubWF5YmVBZGRNYXBwaW5nKSh0aGlzLl9tYXAsIHtcbiAgICAgIG5hbWU6IGlkZW50aWZpZXJOYW1lLFxuICAgICAgZ2VuZXJhdGVkLFxuICAgICAgc291cmNlOiAoX29yaWdpbmFsTWFwcGluZyA9IG9yaWdpbmFsTWFwcGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcmlnaW5hbE1hcHBpbmcuc291cmNlLFxuICAgICAgb3JpZ2luYWw6IG9yaWdpbmFsTWFwcGluZ1xuICAgIH0pO1xuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTb3VyY2VNYXA7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvdXJjZS1tYXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44068\n')},49594:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.TokenMap = void 0;\nvar _t = __webpack_require__(2352);\nconst {\n  traverseFast,\n  VISITOR_KEYS\n} = _t;\nclass TokenMap {\n  constructor(ast, tokens, source) {\n    this._tokens = void 0;\n    this._source = void 0;\n    this._nodesToTokenIndexes = new Map();\n    this._nodesOccurrencesCountCache = new Map();\n    this._tokensCache = new Map();\n    this._tokens = tokens;\n    this._source = source;\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n    this._tokensCache = null;\n  }\n  has(node) {\n    return this._nodesToTokenIndexes.has(node);\n  }\n  getIndexes(node) {\n    return this._nodesToTokenIndexes.get(node);\n  }\n  find(node, condition) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n  findLastIndex(node, condition) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n  findMatching(node, test, occurrenceCount = 0) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache && cache.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, {\n                test,\n                count,\n                i\n              });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n  matchesOriginal(token, test) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n  startMatches(node, test) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n  endMatches(node, test) {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n  _getTokensIndexesOfNode(node) {\n    if (node.start == null || node.end == null) return [];\n    const {\n      first,\n      last\n    } = this._findTokensOfNode(node, 0, this._tokens.length - 1);\n    let low = first;\n    const children = childrenIterator(node);\n    if ((node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration") && node.declaration && node.declaration.type === "ClassDeclaration") {\n      children.next();\n    }\n    const indexes = [];\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n      const childTok = this._findTokensOfNode(child, low, last);\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n      low = childTok.last + 1;\n    }\n    for (let k = low; k <= last; k++) indexes.push(k);\n    return indexes;\n  }\n  _findTokensOfNode(node, low, high) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n    const first = this._findFirstTokenOfNode(node.start, low, high);\n    const last = this._findLastTokenOfNode(node.end, first, high);\n    this._tokensCache.set(node, {\n      first,\n      last\n    });\n    return {\n      first,\n      last\n    };\n  }\n  _findFirstTokenOfNode(start, low, high) {\n    while (low <= high) {\n      const mid = high + low >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n  _findLastTokenOfNode(end, low, high) {\n    while (low <= high) {\n      const mid = high + low >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\nexports.TokenMap = TokenMap;\nfunction* childrenIterator(node) {\n  if (node.type === "TemplateLiteral") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = node[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n\n//# sourceMappingURL=token-map.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk1OTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCO0FBQ2hCLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2dlbmVyYXRvci9saWIvdG9rZW4tbWFwLmpzP2NiYzUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlRva2VuTWFwID0gdm9pZCAwO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgdHJhdmVyc2VGYXN0LFxuICBWSVNJVE9SX0tFWVNcbn0gPSBfdDtcbmNsYXNzIFRva2VuTWFwIHtcbiAgY29uc3RydWN0b3IoYXN0LCB0b2tlbnMsIHNvdXJjZSkge1xuICAgIHRoaXMuX3Rva2VucyA9IHZvaWQgMDtcbiAgICB0aGlzLl9zb3VyY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub2Rlc09jY3VycmVuY2VzQ291bnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl90b2tlbnNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl90b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgIHRyYXZlcnNlRmFzdChhc3QsIG5vZGUgPT4ge1xuICAgICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuX2dldFRva2Vuc0luZGV4ZXNPZk5vZGUobm9kZSk7XG4gICAgICBpZiAoaW5kZXhlcy5sZW5ndGggPiAwKSB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLnNldChub2RlLCBpbmRleGVzKTtcbiAgICB9KTtcbiAgICB0aGlzLl90b2tlbnNDYWNoZSA9IG51bGw7XG4gIH1cbiAgaGFzKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcy5oYXMobm9kZSk7XG4gIH1cbiAgZ2V0SW5kZXhlcyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzVG9Ub2tlbkluZGV4ZXMuZ2V0KG5vZGUpO1xuICB9XG4gIGZpbmQobm9kZSwgY29uZGl0aW9uKSB7XG4gICAgY29uc3QgaW5kZXhlcyA9IHRoaXMuX25vZGVzVG9Ub2tlbkluZGV4ZXMuZ2V0KG5vZGUpO1xuICAgIGlmIChpbmRleGVzKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGluZGV4ZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleGVzW2tdO1xuICAgICAgICBjb25zdCB0b2sgPSB0aGlzLl90b2tlbnNbaW5kZXhdO1xuICAgICAgICBpZiAoY29uZGl0aW9uKHRvaywgaW5kZXgpKSByZXR1cm4gdG9rO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmaW5kTGFzdEluZGV4KG5vZGUsIGNvbmRpdGlvbikge1xuICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLmdldChub2RlKTtcbiAgICBpZiAoaW5kZXhlcykge1xuICAgICAgZm9yIChsZXQgayA9IGluZGV4ZXMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpbmRleGVzW2tdO1xuICAgICAgICBjb25zdCB0b2sgPSB0aGlzLl90b2tlbnNbaW5kZXhdO1xuICAgICAgICBpZiAoY29uZGl0aW9uKHRvaywgaW5kZXgpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kTWF0Y2hpbmcobm9kZSwgdGVzdCwgb2NjdXJyZW5jZUNvdW50ID0gMCkge1xuICAgIGNvbnN0IGluZGV4ZXMgPSB0aGlzLl9ub2Rlc1RvVG9rZW5JbmRleGVzLmdldChub2RlKTtcbiAgICBpZiAoaW5kZXhlcykge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgY29uc3QgY291bnQgPSBvY2N1cnJlbmNlQ291bnQ7XG4gICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fbm9kZXNPY2N1cnJlbmNlc0NvdW50Q2FjaGUuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoY2FjaGUgJiYgY2FjaGUudGVzdCA9PT0gdGVzdCAmJiBjYWNoZS5jb3VudCA8IGNvdW50KSB7XG4gICAgICAgICAgaSA9IGNhY2hlLmkgKyAxO1xuICAgICAgICAgIG9jY3VycmVuY2VDb3VudCAtPSBjYWNoZS5jb3VudCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoOyBpIDwgaW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0b2sgPSB0aGlzLl90b2tlbnNbaW5kZXhlc1tpXV07XG4gICAgICAgIGlmICh0aGlzLm1hdGNoZXNPcmlnaW5hbCh0b2ssIHRlc3QpKSB7XG4gICAgICAgICAgaWYgKG9jY3VycmVuY2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9ub2Rlc09jY3VycmVuY2VzQ291bnRDYWNoZS5zZXQobm9kZSwge1xuICAgICAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2s7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9jY3VycmVuY2VDb3VudC0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG1hdGNoZXNPcmlnaW5hbCh0b2tlbiwgdGVzdCkge1xuICAgIGlmICh0b2tlbi5lbmQgLSB0b2tlbi5zdGFydCAhPT0gdGVzdC5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBpZiAodG9rZW4udmFsdWUgIT0gbnVsbCkgcmV0dXJuIHRva2VuLnZhbHVlID09PSB0ZXN0O1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2Uuc3RhcnRzV2l0aCh0ZXN0LCB0b2tlbi5zdGFydCk7XG4gIH1cbiAgc3RhcnRNYXRjaGVzKG5vZGUsIHRlc3QpIHtcbiAgICBjb25zdCBpbmRleGVzID0gdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcy5nZXQobm9kZSk7XG4gICAgaWYgKCFpbmRleGVzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdG9rID0gdGhpcy5fdG9rZW5zW2luZGV4ZXNbMF1dO1xuICAgIGlmICh0b2suc3RhcnQgIT09IG5vZGUuc3RhcnQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzT3JpZ2luYWwodG9rLCB0ZXN0KTtcbiAgfVxuICBlbmRNYXRjaGVzKG5vZGUsIHRlc3QpIHtcbiAgICBjb25zdCBpbmRleGVzID0gdGhpcy5fbm9kZXNUb1Rva2VuSW5kZXhlcy5nZXQobm9kZSk7XG4gICAgaWYgKCFpbmRleGVzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgdG9rID0gdGhpcy5fdG9rZW5zW2luZGV4ZXNbaW5kZXhlcy5sZW5ndGggLSAxXV07XG4gICAgaWYgKHRvay5lbmQgIT09IG5vZGUuZW5kKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlc09yaWdpbmFsKHRvaywgdGVzdCk7XG4gIH1cbiAgX2dldFRva2Vuc0luZGV4ZXNPZk5vZGUobm9kZSkge1xuICAgIGlmIChub2RlLnN0YXJ0ID09IG51bGwgfHwgbm9kZS5lbmQgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdFxuICAgIH0gPSB0aGlzLl9maW5kVG9rZW5zT2ZOb2RlKG5vZGUsIDAsIHRoaXMuX3Rva2Vucy5sZW5ndGggLSAxKTtcbiAgICBsZXQgbG93ID0gZmlyc3Q7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbkl0ZXJhdG9yKG5vZGUpO1xuICAgIGlmICgobm9kZS50eXBlID09PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIiB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpICYmIG5vZGUuZGVjbGFyYXRpb24gJiYgbm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgY2hpbGRyZW4ubmV4dCgpO1xuICAgIH1cbiAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgaWYgKGNoaWxkLnN0YXJ0ID09IG51bGwgfHwgY2hpbGQuZW5kID09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgY2hpbGRUb2sgPSB0aGlzLl9maW5kVG9rZW5zT2ZOb2RlKGNoaWxkLCBsb3csIGxhc3QpO1xuICAgICAgY29uc3QgaGlnaCA9IGNoaWxkVG9rLmZpcnN0O1xuICAgICAgZm9yIChsZXQgayA9IGxvdzsgayA8IGhpZ2g7IGsrKykgaW5kZXhlcy5wdXNoKGspO1xuICAgICAgbG93ID0gY2hpbGRUb2subGFzdCArIDE7XG4gICAgfVxuICAgIGZvciAobGV0IGsgPSBsb3c7IGsgPD0gbGFzdDsgaysrKSBpbmRleGVzLnB1c2goayk7XG4gICAgcmV0dXJuIGluZGV4ZXM7XG4gIH1cbiAgX2ZpbmRUb2tlbnNPZk5vZGUobm9kZSwgbG93LCBoaWdoKSB7XG4gICAgY29uc3QgY2FjaGVkID0gdGhpcy5fdG9rZW5zQ2FjaGUuZ2V0KG5vZGUpO1xuICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLl9maW5kRmlyc3RUb2tlbk9mTm9kZShub2RlLnN0YXJ0LCBsb3csIGhpZ2gpO1xuICAgIGNvbnN0IGxhc3QgPSB0aGlzLl9maW5kTGFzdFRva2VuT2ZOb2RlKG5vZGUuZW5kLCBmaXJzdCwgaGlnaCk7XG4gICAgdGhpcy5fdG9rZW5zQ2FjaGUuc2V0KG5vZGUsIHtcbiAgICAgIGZpcnN0LFxuICAgICAgbGFzdFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3RcbiAgICB9O1xuICB9XG4gIF9maW5kRmlyc3RUb2tlbk9mTm9kZShzdGFydCwgbG93LCBoaWdoKSB7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICBjb25zdCBtaWQgPSBoaWdoICsgbG93ID4+IDE7XG4gICAgICBpZiAoc3RhcnQgPCB0aGlzLl90b2tlbnNbbWlkXS5zdGFydCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLl90b2tlbnNbbWlkXS5zdGFydCkge1xuICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfVxuICBfZmluZExhc3RUb2tlbk9mTm9kZShlbmQsIGxvdywgaGlnaCkge1xuICAgIHdoaWxlIChsb3cgPD0gaGlnaCkge1xuICAgICAgY29uc3QgbWlkID0gaGlnaCArIGxvdyA+PiAxO1xuICAgICAgaWYgKGVuZCA8IHRoaXMuX3Rva2Vuc1ttaWRdLmVuZCkge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kID4gdGhpcy5fdG9rZW5zW21pZF0uZW5kKSB7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGlnaDtcbiAgfVxufVxuZXhwb3J0cy5Ub2tlbk1hcCA9IFRva2VuTWFwO1xuZnVuY3Rpb24qIGNoaWxkcmVuSXRlcmF0b3Iobm9kZSkge1xuICBpZiAobm9kZS50eXBlID09PSBcIlRlbXBsYXRlTGl0ZXJhbFwiKSB7XG4gICAgeWllbGQgbm9kZS5xdWFzaXNbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBub2RlLnF1YXNpcy5sZW5ndGg7IGkrKykge1xuICAgICAgeWllbGQgbm9kZS5leHByZXNzaW9uc1tpIC0gMV07XG4gICAgICB5aWVsZCBub2RlLnF1YXNpc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGtleXMgPSBWSVNJVE9SX0tFWVNbbm9kZS50eXBlXTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IGNoaWxkID0gbm9kZVtrZXldO1xuICAgIGlmICghY2hpbGQpIGNvbnRpbnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgeWllbGQqIGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICB5aWVsZCBjaGlsZDtcbiAgICB9XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW4tbWFwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49594\n')},53973:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.readCodePoint = readCodePoint;\nexports.readInt = readInt;\nexports.readStringContents = readStringContents;\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = "";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === "template") {\n        out += input.slice(chunkStart, pos) + "\\n";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === "template") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === "double" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res("\\n");\n    case 114:\n      return res("\\r");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res("\\t");\n    case 98:\n      return res("\\b");\n    case 118:\n      return res("\\u000b");\n    case 102:\n      return res("\\f");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res("");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== "0" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== "bail") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM5NzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscUJBQXFCO0FBQ3JCLGVBQWU7QUFDZiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUE4RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL2hlbHBlci1zdHJpbmctcGFyc2VyL2xpYi9pbmRleC5qcz83NzgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5yZWFkQ29kZVBvaW50ID0gcmVhZENvZGVQb2ludDtcbmV4cG9ydHMucmVhZEludCA9IHJlYWRJbnQ7XG5leHBvcnRzLnJlYWRTdHJpbmdDb250ZW50cyA9IHJlYWRTdHJpbmdDb250ZW50cztcbnZhciBfaXNEaWdpdCA9IGZ1bmN0aW9uIGlzRGlnaXQoY29kZSkge1xuICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xufTtcbmNvbnN0IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncyA9IHtcbiAgZGVjQmluT2N0OiBuZXcgU2V0KFs0NiwgNjYsIDY5LCA3OSwgOTUsIDk4LCAxMDEsIDExMV0pLFxuICBoZXg6IG5ldyBTZXQoWzQ2LCA4OCwgOTUsIDEyMF0pXG59O1xuY29uc3QgaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcgPSB7XG4gIGJpbjogY2ggPT4gY2ggPT09IDQ4IHx8IGNoID09PSA0OSxcbiAgb2N0OiBjaCA9PiBjaCA+PSA0OCAmJiBjaCA8PSA1NSxcbiAgZGVjOiBjaCA9PiBjaCA+PSA0OCAmJiBjaCA8PSA1NyxcbiAgaGV4OiBjaCA9PiBjaCA+PSA0OCAmJiBjaCA8PSA1NyB8fCBjaCA+PSA2NSAmJiBjaCA8PSA3MCB8fCBjaCA+PSA5NyAmJiBjaCA8PSAxMDJcbn07XG5mdW5jdGlvbiByZWFkU3RyaW5nQ29udGVudHModHlwZSwgaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBlcnJvcnMpIHtcbiAgY29uc3QgaW5pdGlhbFBvcyA9IHBvcztcbiAgY29uc3QgaW5pdGlhbExpbmVTdGFydCA9IGxpbmVTdGFydDtcbiAgY29uc3QgaW5pdGlhbEN1ckxpbmUgPSBjdXJMaW5lO1xuICBsZXQgb3V0ID0gXCJcIjtcbiAgbGV0IGZpcnN0SW52YWxpZExvYyA9IG51bGw7XG4gIGxldCBjaHVua1N0YXJ0ID0gcG9zO1xuICBjb25zdCB7XG4gICAgbGVuZ3RoXG4gIH0gPSBpbnB1dDtcbiAgZm9yICg7Oykge1xuICAgIGlmIChwb3MgPj0gbGVuZ3RoKSB7XG4gICAgICBlcnJvcnMudW50ZXJtaW5hdGVkKGluaXRpYWxQb3MsIGluaXRpYWxMaW5lU3RhcnQsIGluaXRpYWxDdXJMaW5lKTtcbiAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IGNoID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChpc1N0cmluZ0VuZCh0eXBlLCBjaCwgaW5wdXQsIHBvcykpIHtcbiAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjaCA9PT0gOTIpIHtcbiAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpO1xuICAgICAgY29uc3QgcmVzID0gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgdHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiLCBlcnJvcnMpO1xuICAgICAgaWYgKHJlcy5jaCA9PT0gbnVsbCAmJiAhZmlyc3RJbnZhbGlkTG9jKSB7XG4gICAgICAgIGZpcnN0SW52YWxpZExvYyA9IHtcbiAgICAgICAgICBwb3MsXG4gICAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICAgIGN1ckxpbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dCArPSByZXMuY2g7XG4gICAgICB9XG4gICAgICAoe1xuICAgICAgICBwb3MsXG4gICAgICAgIGxpbmVTdGFydCxcbiAgICAgICAgY3VyTGluZVxuICAgICAgfSA9IHJlcyk7XG4gICAgICBjaHVua1N0YXJ0ID0gcG9zO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDgyMzIgfHwgY2ggPT09IDgyMzMpIHtcbiAgICAgICsrcG9zO1xuICAgICAgKytjdXJMaW5lO1xuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDEwIHx8IGNoID09PSAxMykge1xuICAgICAgaWYgKHR5cGUgPT09IFwidGVtcGxhdGVcIikge1xuICAgICAgICBvdXQgKz0gaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgcG9zKSArIFwiXFxuXCI7XG4gICAgICAgICsrcG9zO1xuICAgICAgICBpZiAoY2ggPT09IDEzICYmIGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuICAgICAgICArK2N1ckxpbmU7XG4gICAgICAgIGNodW5rU3RhcnQgPSBsaW5lU3RhcnQgPSBwb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMudW50ZXJtaW5hdGVkKGluaXRpYWxQb3MsIGluaXRpYWxMaW5lU3RhcnQsIGluaXRpYWxDdXJMaW5lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKytwb3M7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcG9zLFxuICAgIHN0cjogb3V0LFxuICAgIGZpcnN0SW52YWxpZExvYyxcbiAgICBsaW5lU3RhcnQsXG4gICAgY3VyTGluZSxcbiAgICBjb250YWluc0ludmFsaWQ6ICEhZmlyc3RJbnZhbGlkTG9jXG4gIH07XG59XG5mdW5jdGlvbiBpc1N0cmluZ0VuZCh0eXBlLCBjaCwgaW5wdXQsIHBvcykge1xuICBpZiAodHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgcmV0dXJuIGNoID09PSA5NiB8fCBjaCA9PT0gMzYgJiYgaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gMTIzO1xuICB9XG4gIHJldHVybiBjaCA9PT0gKHR5cGUgPT09IFwiZG91YmxlXCIgPyAzNCA6IDM5KTtcbn1cbmZ1bmN0aW9uIHJlYWRFc2NhcGVkQ2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGluVGVtcGxhdGUsIGVycm9ycykge1xuICBjb25zdCB0aHJvd09uSW52YWxpZCA9ICFpblRlbXBsYXRlO1xuICBwb3MrKztcbiAgY29uc3QgcmVzID0gY2ggPT4gKHtcbiAgICBwb3MsXG4gICAgY2gsXG4gICAgbGluZVN0YXJ0LFxuICAgIGN1ckxpbmVcbiAgfSk7XG4gIGNvbnN0IGNoID0gaW5wdXQuY2hhckNvZGVBdChwb3MrKyk7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDExMDpcbiAgICAgIHJldHVybiByZXMoXCJcXG5cIik7XG4gICAgY2FzZSAxMTQ6XG4gICAgICByZXR1cm4gcmVzKFwiXFxyXCIpO1xuICAgIGNhc2UgMTIwOlxuICAgICAge1xuICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAyLCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICAgICByZXR1cm4gcmVzKGNvZGUgPT09IG51bGwgPyBudWxsIDogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gICAgICB9XG4gICAgY2FzZSAxMTc6XG4gICAgICB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICAoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH0gPSByZWFkQ29kZVBvaW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICAgICByZXR1cm4gcmVzKGNvZGUgPT09IG51bGwgPyBudWxsIDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSkpO1xuICAgICAgfVxuICAgIGNhc2UgMTE2OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdFwiKTtcbiAgICBjYXNlIDk4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcYlwiKTtcbiAgICBjYXNlIDExODpcbiAgICAgIHJldHVybiByZXMoXCJcXHUwMDBiXCIpO1xuICAgIGNhc2UgMTAyOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcZlwiKTtcbiAgICBjYXNlIDEzOlxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMTApIHtcbiAgICAgICAgKytwb3M7XG4gICAgICB9XG4gICAgY2FzZSAxMDpcbiAgICAgIGxpbmVTdGFydCA9IHBvcztcbiAgICAgICsrY3VyTGluZTtcbiAgICBjYXNlIDgyMzI6XG4gICAgY2FzZSA4MjMzOlxuICAgICAgcmV0dXJuIHJlcyhcIlwiKTtcbiAgICBjYXNlIDU2OlxuICAgIGNhc2UgNTc6XG4gICAgICBpZiAoaW5UZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gcmVzKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3JzLnN0cmljdE51bWVyaWNFc2NhcGUocG9zIC0gMSwgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoID49IDQ4ICYmIGNoIDw9IDU1KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zID0gcG9zIC0gMTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSAvXlswLTddKy8uZXhlYyhpbnB1dC5zbGljZShzdGFydFBvcywgcG9zICsgMikpO1xuICAgICAgICBsZXQgb2N0YWxTdHIgPSBtYXRjaFswXTtcbiAgICAgICAgbGV0IG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICBpZiAob2N0YWwgPiAyNTUpIHtcbiAgICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgICBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gb2N0YWxTdHIubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3QgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKG9jdGFsU3RyICE9PSBcIjBcIiB8fCBuZXh0ID09PSA1NiB8fCBuZXh0ID09PSA1Nykge1xuICAgICAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzKG51bGwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShzdGFydFBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcyhTdHJpbmcuZnJvbUNoYXJDb2RlKG9jdGFsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCBsZW4sIGZvcmNlTGVuLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSB7XG4gIGNvbnN0IGluaXRpYWxQb3MgPSBwb3M7XG4gIGxldCBuO1xuICAoe1xuICAgIG4sXG4gICAgcG9zXG4gIH0gPSByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgMTYsIGxlbiwgZm9yY2VMZW4sIGZhbHNlLCBlcnJvcnMsICF0aHJvd09uSW52YWxpZCkpO1xuICBpZiAobiA9PT0gbnVsbCkge1xuICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgZXJyb3JzLmludmFsaWRFc2NhcGVTZXF1ZW5jZShpbml0aWFsUG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBpbml0aWFsUG9zIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2RlOiBuLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZEludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4LCBsZW4sIGZvcmNlTGVuLCBhbGxvd051bVNlcGFyYXRvciwgZXJyb3JzLCBiYWlsT25FcnJvcikge1xuICBjb25zdCBzdGFydCA9IHBvcztcbiAgY29uc3QgZm9yYmlkZGVuU2libGluZ3MgPSByYWRpeCA9PT0gMTYgPyBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuaGV4IDogZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzLmRlY0Jpbk9jdDtcbiAgY29uc3QgaXNBbGxvd2VkU2libGluZyA9IHJhZGl4ID09PSAxNiA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmhleCA6IHJhZGl4ID09PSAxMCA/IGlzQWxsb3dlZE51bWVyaWNTZXBhcmF0b3JTaWJsaW5nLmRlYyA6IHJhZGl4ID09PSA4ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcub2N0IDogaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuYmluO1xuICBsZXQgaW52YWxpZCA9IGZhbHNlO1xuICBsZXQgdG90YWwgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgZSA9IGxlbiA9PSBudWxsID8gSW5maW5pdHkgOiBsZW47IGkgPCBlOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIGxldCB2YWw7XG4gICAgaWYgKGNvZGUgPT09IDk1ICYmIGFsbG93TnVtU2VwYXJhdG9yICE9PSBcImJhaWxcIikge1xuICAgICAgY29uc3QgcHJldiA9IGlucHV0LmNoYXJDb2RlQXQocG9zIC0gMSk7XG4gICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICAgIGlmICghYWxsb3dOdW1TZXBhcmF0b3IpIHtcbiAgICAgICAgaWYgKGJhaWxPbkVycm9yKSByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICAgIGVycm9ycy5udW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZShwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9IGVsc2UgaWYgKE51bWJlci5pc05hTihuZXh0KSB8fCAhaXNBbGxvd2VkU2libGluZyhuZXh0KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMocHJldikgfHwgZm9yYmlkZGVuU2libGluZ3MuaGFzKG5leHQpKSB7XG4gICAgICAgIGlmIChiYWlsT25FcnJvcikgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgICBlcnJvcnMudW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3IocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfVxuICAgICAgKytwb3M7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvZGUgPj0gOTcpIHtcbiAgICAgIHZhbCA9IGNvZGUgLSA5NyArIDEwO1xuICAgIH0gZWxzZSBpZiAoY29kZSA+PSA2NSkge1xuICAgICAgdmFsID0gY29kZSAtIDY1ICsgMTA7XG4gICAgfSBlbHNlIGlmIChfaXNEaWdpdChjb2RlKSkge1xuICAgICAgdmFsID0gY29kZSAtIDQ4O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHZhbCA+PSByYWRpeCkge1xuICAgICAgaWYgKHZhbCA8PSA5ICYmIGJhaWxPbkVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDw9IDkgJiYgZXJyb3JzLmludmFsaWREaWdpdChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgpKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGZvcmNlTGVuKSB7XG4gICAgICAgIHZhbCA9IDA7XG4gICAgICAgIGludmFsaWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgICsrcG9zO1xuICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgfVxuICBpZiAocG9zID09PSBzdGFydCB8fCBsZW4gIT0gbnVsbCAmJiBwb3MgLSBzdGFydCAhPT0gbGVuIHx8IGludmFsaWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbjogbnVsbCxcbiAgICAgIHBvc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuOiB0b3RhbCxcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSB7XG4gIGNvbnN0IGNoID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICBsZXQgY29kZTtcbiAgaWYgKGNoID09PSAxMjMpIHtcbiAgICArK3BvcztcbiAgICAoe1xuICAgICAgY29kZSxcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGlucHV0LmluZGV4T2YoXCJ9XCIsIHBvcykgLSBwb3MsIHRydWUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgICArK3BvcztcbiAgICBpZiAoY29kZSAhPT0gbnVsbCAmJiBjb2RlID4gMHgxMGZmZmYpIHtcbiAgICAgIGlmICh0aHJvd09uSW52YWxpZCkge1xuICAgICAgICBlcnJvcnMuaW52YWxpZENvZGVQb2ludChwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvZGU6IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgNCwgZmFsc2UsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGUsXG4gICAgcG9zXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53973\n')},38721:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierName = isIdentifierName;\nexports.isIdentifierStart = isIdentifierStart;\nlet nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";\nlet nonASCIIidentifierChars = "\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65";\nconst nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");\nconst nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nfunction isIdentifierName(name) {\n  let isFirst = true;\n  for (let i = 0; i < name.length; i++) {\n    let cp = name.charCodeAt(i);\n    if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {\n      const trail = name.charCodeAt(++i);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    if (isFirst) {\n      isFirst = false;\n      if (!isIdentifierStart(cp)) {\n        return false;\n      }\n    } else if (!isIdentifierChar(cp)) {\n      return false;\n    }\n  }\n  return !isFirst;\n}\n\n//# sourceMappingURL=identifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3MjEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyL2xpYi9pZGVudGlmaWVyLmpzP2RmNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzSWRlbnRpZmllckNoYXIgPSBpc0lkZW50aWZpZXJDaGFyO1xuZXhwb3J0cy5pc0lkZW50aWZpZXJOYW1lID0gaXNJZGVudGlmaWVyTmFtZTtcbmV4cG9ydHMuaXNJZGVudGlmaWVyU3RhcnQgPSBpc0lkZW50aWZpZXJTdGFydDtcbmxldCBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2RcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZGNcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM5LCAyNywgMTAsIDIyLCAyNTEsIDQxLCA3LCAxLCAxNywgMiwgNjAsIDI4LCAxMSwgMCwgOSwgMjEsIDQzLCAxNywgNDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNTgsIDEsIDMsIDAsIDE0LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDIwLCAxLCA2NCwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMzEsIDksIDIsIDAsIDMsIDAsIDIsIDM3LCAyLCAwLCAyNiwgMCwgMiwgMCwgNDUsIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyMDAsIDMyLCAzMiwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MiwgOSwgODkzNiwgMywgMiwgNiwgMiwgMSwgMiwgMjkwLCAxNiwgMCwgMzAsIDIsIDMsIDAsIDE1LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMTg0NSwgMzAsIDcsIDUsIDI2MiwgNjEsIDE0NywgNDQsIDExLCA2LCAxNywgMCwgMzIyLCAyOSwgMTksIDQzLCA0ODUsIDI3LCAyMjksIDI5LCAzLCAwLCA0OTYsIDYsIDIsIDMsIDIsIDEsIDIsIDE0LCAyLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTksIDMzLCA0MTUzLCA3LCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAxNiwgNjIxLCAyNDY3LCA1NDEsIDE1MDcsIDQ5MzgsIDYsIDQxOTFdO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCA3LCA5LCAzMiwgNCwgMzE4LCAxLCA4MCwgMywgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDY4LCA4LCAyLCAwLCAzLCAwLCAyLCAzLCAyLCA0LCAyLCAwLCAxNSwgMSwgODMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA3LCAxOSwgNTgsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCAzNDMsIDksIDU0LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCAxMCwgNTM1MCwgMCwgNywgMTQsIDExNDY1LCAyNywgMjM0MywgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDUzNSwgOSwgNDcwLCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDE3OCwgOSwgNTE5LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgMjQ1LCAxLCAyLCA5LCA3MjYsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyTmFtZShuYW1lKSB7XG4gIGxldCBpc0ZpcnN0ID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNwID0gbmFtZS5jaGFyQ29kZUF0KGkpO1xuICAgIGlmICgoY3AgJiAweGZjMDApID09PSAweGQ4MDAgJiYgaSArIDEgPCBuYW1lLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHJhaWwgPSBuYW1lLmNoYXJDb2RlQXQoKytpKTtcbiAgICAgIGlmICgodHJhaWwgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgY3AgPSAweDEwMDAwICsgKChjcCAmIDB4M2ZmKSA8PCAxMCkgKyAodHJhaWwgJiAweDNmZik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0ZpcnN0KSB7XG4gICAgICBpc0ZpcnN0ID0gZmFsc2U7XG4gICAgICBpZiAoIWlzSWRlbnRpZmllclN0YXJ0KGNwKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNJZGVudGlmaWVyQ2hhcihjcCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFpc0ZpcnN0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pZGVudGlmaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38721\n')},61e3:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "isIdentifierChar", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierChar;\n  }\n}));\nObject.defineProperty(exports, "isIdentifierName", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierName;\n  }\n}));\nObject.defineProperty(exports, "isIdentifierStart", ({\n  enumerable: true,\n  get: function () {\n    return _identifier.isIdentifierStart;\n  }\n}));\nObject.defineProperty(exports, "isKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isKeyword;\n  }\n}));\nObject.defineProperty(exports, "isReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictBindOnlyReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindOnlyReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictBindReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictBindReservedWord;\n  }\n}));\nObject.defineProperty(exports, "isStrictReservedWord", ({\n  enumerable: true,\n  get: function () {\n    return _keyword.isStrictReservedWord;\n  }\n}));\nvar _identifier = __webpack_require__(38721);\nvar _keyword = __webpack_require__(43115);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEwMDAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCLG1CQUFPLENBQUMsS0FBaUI7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLEtBQWM7O0FBRXJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyL2xpYi9pbmRleC5qcz85MDIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJZGVudGlmaWVyQ2hhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJDaGFyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSWRlbnRpZmllck5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lkZW50aWZpZXIuaXNJZGVudGlmaWVyTmFtZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0lkZW50aWZpZXJTdGFydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaWRlbnRpZmllci5pc0lkZW50aWZpZXJTdGFydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0tleXdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzUmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzUmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2tleXdvcmQuaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU3RyaWN0UmVzZXJ2ZWRXb3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9rZXl3b3JkLmlzU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICB9XG59KTtcbnZhciBfaWRlbnRpZmllciA9IHJlcXVpcmUoXCIuL2lkZW50aWZpZXIuanNcIik7XG52YXIgX2tleXdvcmQgPSByZXF1aXJlKFwiLi9rZXl3b3JkLmpzXCIpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61000\n')},43115:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isKeyword = isKeyword;\nexports.isReservedWord = isReservedWord;\nexports.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;\nexports.isStrictBindReservedWord = isStrictBindReservedWord;\nexports.isStrictReservedWord = isStrictReservedWord;\nconst reservedWords = {\n  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],\n  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],\n  strictBind: ["eval", "arguments"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === "await" || word === "enum";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\n\n//# sourceMappingURL=keyword.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMxMTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvaGVscGVyLXZhbGlkYXRvci1pZGVudGlmaWVyL2xpYi9rZXl3b3JkLmpzP2I5YzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzS2V5d29yZCA9IGlzS2V5d29yZDtcbmV4cG9ydHMuaXNSZXNlcnZlZFdvcmQgPSBpc1Jlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCA9IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQ7XG5leHBvcnRzLmlzU3RyaWN0QmluZFJlc2VydmVkV29yZCA9IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZDtcbmV4cG9ydHMuaXNTdHJpY3RSZXNlcnZlZFdvcmQgPSBpc1N0cmljdFJlc2VydmVkV29yZDtcbmNvbnN0IHJlc2VydmVkV29yZHMgPSB7XG4gIGtleXdvcmQ6IFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiXSxcbiAgc3RyaWN0OiBbXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsIFwibGV0XCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJ5aWVsZFwiXSxcbiAgc3RyaWN0QmluZDogW1wiZXZhbFwiLCBcImFyZ3VtZW50c1wiXVxufTtcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3Jkcy5oYXMod29yZCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXdvcmQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43115\n')},22172:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with \'sourceType: "module"\'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `\'import\' and \'export\' may appear only with \'sourceType: "module"\'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: "array destructuring pattern",\n  AssignmentExpression: "assignment expression",\n  AssignmentPattern: "assignment expression",\n  ArrowFunctionExpression: "arrow function expression",\n  ConditionalExpression: "conditional expression",\n  CatchClause: "catch clause",\n  ForOfStatement: "for-of statement",\n  ForInStatement: "for-in statement",\n  ForStatement: "for-loop",\n  FormalParameters: "function parameter list",\n  Identifier: "identifier",\n  ImportSpecifier: "import specifier",\n  ImportDefaultSpecifier: "import default specifier",\n  ImportNamespaceSpecifier: "import namespace specifier",\n  ObjectPattern: "object destructuring pattern",\n  ParenthesizedExpression: "parenthesized expression",\n  RestElement: "rest element",\n  UpdateExpression: {\n    true: "prefix operation",\n    false: "postfix operation"\n  },\n  VariableDeclarator: "variable declaration",\n  YieldExpression: "yield expression"\n};\nconst toNodeDescription = node => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: "\'arguments\' is only allowed in functions and class methods.",\n  AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",\n  AwaitBindingIdentifier: "Can not use \'await\' as identifier inside an async function.",\n  AwaitBindingIdentifierInStaticBlock: "Can not use \'await\' as identifier inside a static block.",\n  AwaitExpressionFormalParameter: "\'await\' is not allowed in async function parameters.",\n  AwaitUsingNotInAsyncContext: "\'await using\' is only allowed within async functions and at the top levels of modules.",\n  AwaitNotInAsyncContext: "\'await\' is only allowed within async functions and at the top levels of modules.",\n  AwaitNotInAsyncFunction: "\'await\' is only allowed within async functions.",\n  BadGetterArity: "A \'get\' accessor must not have any formal parameters.",\n  BadSetterArity: "A \'set\' accessor must have exactly one formal parameter.",\n  BadSetterRestParameter: "A \'set\' accessor function argument must not be a rest parameter.",\n  ConstructorClassField: "Classes may not have a field named \'constructor\'.",\n  ConstructorClassPrivateField: "Classes may not have a private field named \'#constructor\'.",\n  ConstructorIsAccessor: "Class constructor may not be an accessor.",\n  ConstructorIsAsync: "Constructor can\'t be an async function.",\n  ConstructorIsGenerator: "Constructor can\'t be a generator.",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use \'@(decorator(args))\' instead of \'@(decorator)(args)\'.",\n  DecoratorBeforeExport: "Decorators must be placed *before* the \'export\' keyword. Remove the \'decoratorsBeforeExport: true\' option to use the \'export @decorator class {}\' syntax.",\n  DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the \'export\' keyword, but not in both locations at the same time.",\n  DecoratorConstructor: "Decorators can\'t be used with a constructor. Did you mean \'@dec class { ... }\'?",\n  DecoratorExportClass: "Decorators must be placed *after* the \'export\' keyword. Remove the \'decoratorsBeforeExport: false\' option to use the \'@decorator export class {}\' syntax.",\n  DecoratorSemicolon: "Decorators must not be followed by a semicolon.",\n  DecoratorStaticBlock: "Decorators can\'t be used with a static block.",\n  DeferImportRequiresNamespace: \'Only `import defer * as x from "./module"` is valid.\',\n  DeletePrivateField: "Deleting a private field is not allowed.",\n  DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",\n  DuplicateConstructor: "Duplicate constructor in the same class.",\n  DuplicateDefaultExport: "Only one default export allowed per module.",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: "Redefinition of __proto__ property.",\n  DuplicateRegExpFlags: "Duplicate regular expression flag.",\n  DynamicImportPhaseRequiresImportExpressions: ({\n    phase\n  }) => `\'import.${phase}(...)\' can only be parsed when using the \'createImportExpressions\' option.`,\n  ElementAfterRest: "Rest element must be last element.",\n  EscapedCharNotAnIdentifier: "Invalid Unicode escape.",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { \'${localName}\' as \'${exportName}\' } from \'some-module\'\\`?`,\n  ExportDefaultFromAsIdentifier: "\'from\' is not allowed as an identifier after \'export default\'.",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `\'${type === "ForInStatement" ? "for-in" : "for-of"}\' loop variable declaration may not have an initializer.`,\n  ForInUsing: "For-in loop may not start with \'using\' declaration.",\n  ForOfAsync: "The left-hand side of a for-of loop may not be \'async\'.",\n  ForOfLet: "The left-hand side of a for-of loop may not start with \'let\'.",\n  GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,\n  IllegalLanguageModeDirective: "Illegal \'use strict\' directive in function with non-simple parameter list.",\n  IllegalReturn: "\'return\' outside of function.",\n  ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { "${importName}" as foo }\\`?`,\n  ImportCallArity: `\\`import()\\` requires exactly one or two arguments.`,\n  ImportCallNotNewExpression: "Cannot use new with import(...).",\n  ImportCallSpreadArgument: "`...` is not allowed in `import()`.",\n  ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",\n  ImportReflectionHasAssertion: "`import module x` cannot have assertions.",\n  ImportReflectionNotBinding: \'Only `import module x from "./module"` is valid.\',\n  IncompatibleRegExpUVFlags: "The \'u\' and \'v\' regular expression flags cannot be enabled at the same time.",\n  InvalidBigIntLiteral: "Invalid BigIntLiteral.",\n  InvalidCodePoint: "Code point out of bounds.",\n  InvalidCoverInitializedName: "Invalid shorthand property initializer.",\n  InvalidDecimal: "Invalid decimal.",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: "Bad character escape sequence.",\n  InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: "Invalid number.",\n  InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the \'e\'.",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character \'${unexpected}\'.`,\n  InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: "Binding member expression.",\n  InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",\n  InvalidRestAssignmentPattern: "Invalid rest operator\'s argument.",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label \'${labelName}\' is already declared.`,\n  LetInLexicalBinding: "\'let\' is disallowed as a lexically bound name.",\n  LineTerminatorBeforeArrow: "No line break is allowed before \'=>\'.",\n  MalformedRegExpFlags: "Invalid regular expression flag.",\n  MissingClassName: "A class name is required.",\n  MissingEqInAssignment: "Only \'=\' operator can be used for specifying default value.",\n  MissingSemicolon: "Missing semicolon.",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(", ")}.`,\n  MissingUnicodeEscape: "Expecting Unicode escape sequence \\\\uXXXX.",\n  MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",\n  ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",\n  ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key "${key}" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found \'\\\\u${surrogateCharCode.toString(16)}\'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export \'${localName}\' is not defined.`,\n  MultipleDefaultsInSwitch: "Multiple default clauses.",\n  NewlineAfterThrow: "Illegal newline after throw.",\n  NoCatchOrFinally: "Missing catch or finally clause.",\n  NumberIdentifier: "Identifier directly after number.",\n  NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",\n  ObsoleteAwaitStar: "\'await*\' has been removed from the async functions proposal. Use Promise.all() instead.",\n  OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",\n  OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",\n  OverrideOnConstructor: "\'override\' modifier cannot appear on a constructor declaration.",\n  ParamDupe: "Argument name clash.",\n  PatternHasAccessor: "Object pattern can\'t contain getter or setter.",\n  PatternHasMethod: "Object pattern can\'t contain methods.",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with \'|}\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.",\n  RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with \'{|\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.",\n  RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with \'#{\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'hash\'.",\n  RecordNoProto: "\'__proto__\' is not allowed in Record expressions.",\n  RestTrailingComma: "Unexpected trailing comma after rest element.",\n  SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",\n  SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",\n  SourcePhaseImportRequiresDefault: \'Only `import source x from "./module"` is valid.\',\n  StaticPrototype: "Classes may not have static property named prototype.",\n  SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name (\'constructor\') or not extending another class?",\n  SuperPrivateField: "Private fields can\'t be accessed on super.",\n  TrailingDecorator: "Decorators must be attached to a class element.",\n  TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with \'|]\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.",\n  TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with \'[|\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'bar\'.",\n  TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with \'#[\' are only allowed when the \'syntaxType\' option of the \'recordAndTuple\' plugin is set to \'hash\'.",\n  UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",\n  UnexpectedAwaitAfterPipelineBody: \'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.\',\n  UnexpectedDigitAfterHash: "Unexpected digit after hash token.",\n  UnexpectedImportExport: "\'import\' and \'export\' may only appear at the top level.",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword \'${keyword}\'.`,\n  UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",\n  UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",\n  UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",\n  UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",\n  UnexpectedPrivateField: "Unexpected private name.",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word \'${reservedWord}\'.`,\n  UnexpectedSuper: "\'super\' is only allowed in object methods and classes.",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` \'${unexpected}\'.` : ""}${expected ? `, expected "${expected}"` : ""}`,\n  UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",\n  UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",\n  UnsupportedBind: "Binding should be performed on object property.",\n  UnsupportedDecoratorExport: "A decorated export must export a class declaration.",\n  UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",\n  UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",\n  UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",\n  UnsupportedSuper: "\'super\' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",\n  UnterminatedComment: "Unterminated comment.",\n  UnterminatedRegExp: "Unterminated regular expression.",\n  UnterminatedString: "Unterminated string constant.",\n  UnterminatedTemplate: "Unterminated template.",\n  UsingDeclarationExport: "Using declaration cannot be exported.",\n  UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier \'${identifierName}\' has already been declared.`,\n  YieldBindingIdentifier: "Can not use \'yield\' as identifier inside a generator.",\n  YieldInParameter: "Yield expression is not allowed in formal parameters.",\n  ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."\n};\nvar StrictModeErrors = {\n  StrictDelete: "Deleting local variable in strict mode.",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to \'${referenceName}\' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding \'${bindingName}\' in strict mode.`,\n  StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",\n  StrictNumericEscape: "The only valid numeric escape in strict mode is \'\\\\0\'.",\n  StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",\n  StrictWith: "\'with\' in strict mode."\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);\nvar PipelineOperatorErrors = {\n  PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",\n  PipeTopicRequiresHackPipes: \'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.\',\n  PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,\n  PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`,\n  PipelineBodyNoArrow: \'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.\',\n  PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",\n  PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",\n  PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",\n  PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",\n  PrimaryTopicRequiresSmartPipeline: \'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.\'\n};\nconst _excluded = ["message"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin\n}) {\n  const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";\n  {\n    const oldReasonCodes = {\n      AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",\n      AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",\n      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",\n      SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",\n      SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",\n      SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"\n    };\n    if (oldReasonCodes[reasonCode]) {\n      reasonCode = oldReasonCodes[reasonCode];\n    }\n  }\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    error.code = code;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = details.missingPlugin;\n    }\n    defineHidden(error, "clone", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, "details", details);\n    Object.defineProperty(error, "message", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, "message", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref = typeof template === "string" ? {\n        message: () => template\n      } : typeof template === "function" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const toMessage = typeof message === "string" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: "BABEL_PARSER_SYNTAX_ERROR",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => {\n  if (object) {\n    defineProperty(object, key, {\n      enumerable: false,\n      value: object[key]\n    });\n  }\n};\nfunction toESTreeLocation(node) {\n  toUnenumerable(node.loc.start, "index");\n  toUnenumerable(node.loc.end, "index");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.options.tokens) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (_) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, "Literal");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    expression.type = "Literal";\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = directive;\n    stmt.type = "ExpressionStatement";\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n    classBody.body.push(method);\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    {\n      if (!this.getPluginOption("estree", "classFeatures")) {\n        return node;\n      }\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    node = node;\n    delete node.id;\n    node.name = name;\n    node.type = "PrivateIdentifier";\n    return node;\n  }\n  isPrivateName(node) {\n    {\n      if (!this.getPluginOption("estree", "classFeatures")) {\n        return super.isPrivateName(node);\n      }\n    }\n    return node.type === "PrivateIdentifier";\n  }\n  getPrivateNameSV(node) {\n    {\n      if (!this.getPluginOption("estree", "classFeatures")) {\n        return super.getPrivateNameSV(node);\n      }\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== "BlockStatement";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = "FunctionExpression";\n    delete funcNode.kind;\n    node.value = funcNode;\n    if (type === "ClassPrivateMethod") {\n      node.computed = false;\n    }\n    return this.finishNode(node, "MethodDefinition");\n  }\n  nameIsConstructor(key) {\n    if (key.type === "Literal") return key.value === "constructor";\n    return super.nameIsConstructor(key);\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    {\n      if (!this.getPluginOption("estree", "classFeatures")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = "PropertyDefinition";\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    {\n      if (!this.getPluginOption("estree", "classFeatures")) {\n        return propertyNode;\n      }\n    }\n    propertyNode.type = "PropertyDefinition";\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);\n    if (node) {\n      node.type = "Property";\n      if (node.kind === "method") {\n        node.kind = "init";\n      }\n      node.shorthand = false;\n    }\n    return node;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = "init";\n      node.type = "Property";\n    }\n    return node;\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.type === "Property" && prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === "Import") {\n      var _ref, _ref2;\n      node.type = "ImportExpression";\n      node.source = node.arguments[0];\n      node.options = (_ref = node.arguments[1]) != null ? _ref : null;\n      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;\n      delete node.arguments;\n      delete node.callee;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === "ImportExpression") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case "ExportAllDeclaration":\n        node.exported = null;\n        break;\n      case "ExportNamedDeclaration":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {\n          node.type = "ExportAllDeclaration";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case "ExportDefaultDeclaration":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const node = super.parseSubscript(base, startLoc, noCalls, state);\n    if (state.optionalChainMember) {\n      if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {\n        node.type = node.type.substring(8);\n      }\n      if (state.stop) {\n        const chain = this.startNodeAtNode(node);\n        chain.expression = node;\n        return this.finishNode(chain, "ChainExpression");\n      }\n    } else if (node.type === "MemberExpression" || node.type === "CallExpression") {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === "ChainExpression") {\n      return node.expression.type === "MemberExpression";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === "ChainExpression") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === "Property" && node.kind === "init" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext("{"),\n  j_oTag: new TokContext("<tag"),\n  j_cTag: new TokContext("</tag"),\n  j_expr: new TokContext("<tag>...</tag>", true)\n};\n{\n  types.template = new TokContext("`", true);\n}\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    {\n      this.updateContext = null;\n    }\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType("name", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken("[", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken("#[", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken("[|", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken("]"),\n  bracketBarR: createToken("|]"),\n  braceL: createToken("{", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken("{|", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken("#{", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken("}"),\n  braceBarR: createToken("|}"),\n  parenL: createToken("(", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(")"),\n  comma: createToken(",", {\n    beforeExpr\n  }),\n  semi: createToken(";", {\n    beforeExpr\n  }),\n  colon: createToken(":", {\n    beforeExpr\n  }),\n  doubleColon: createToken("::", {\n    beforeExpr\n  }),\n  dot: createToken("."),\n  question: createToken("?", {\n    beforeExpr\n  }),\n  questionDot: createToken("?."),\n  arrow: createToken("=>", {\n    beforeExpr\n  }),\n  template: createToken("template"),\n  ellipsis: createToken("...", {\n    beforeExpr\n  }),\n  backQuote: createToken("`", {\n    startsExpr\n  }),\n  dollarBraceL: createToken("${", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken("...`", {\n    startsExpr\n  }),\n  templateNonTail: createToken("...${", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken("@"),\n  hash: createToken("#", {\n    startsExpr\n  }),\n  interpreterDirective: createToken("#!..."),\n  eq: createToken("=", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken("_=", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken("_=", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken("_=", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken("_=", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken("++/--", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken("!", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken("~", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken("^^", {\n    startsExpr\n  }),\n  doubleAt: createToken("@@", {\n    startsExpr\n  }),\n  pipeline: createBinop("|>", 0),\n  nullishCoalescing: createBinop("??", 1),\n  logicalOR: createBinop("||", 1),\n  logicalAND: createBinop("&&", 2),\n  bitwiseOR: createBinop("|", 3),\n  bitwiseXOR: createBinop("^", 4),\n  bitwiseAND: createBinop("&", 5),\n  equality: createBinop("==/!=/===/!==", 6),\n  lt: createBinop("</>/<=/>=", 7),\n  gt: createBinop("</>/<=/>=", 7),\n  relational: createBinop("</>/<=/>=", 7),\n  bitShift: createBinop("<</>>/>>>", 8),\n  bitShiftL: createBinop("<</>>/>>>", 8),\n  bitShiftR: createBinop("<</>>/>>>", 8),\n  plusMin: createToken("+/-", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken("%", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken("*", {\n    binop: 10\n  }),\n  slash: createBinop("/", 10),\n  exponent: createToken("**", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword("in", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword("instanceof", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword("break"),\n  _case: createKeyword("case", {\n    beforeExpr\n  }),\n  _catch: createKeyword("catch"),\n  _continue: createKeyword("continue"),\n  _debugger: createKeyword("debugger"),\n  _default: createKeyword("default", {\n    beforeExpr\n  }),\n  _else: createKeyword("else", {\n    beforeExpr\n  }),\n  _finally: createKeyword("finally"),\n  _function: createKeyword("function", {\n    startsExpr\n  }),\n  _if: createKeyword("if"),\n  _return: createKeyword("return", {\n    beforeExpr\n  }),\n  _switch: createKeyword("switch"),\n  _throw: createKeyword("throw", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword("try"),\n  _var: createKeyword("var"),\n  _const: createKeyword("const"),\n  _with: createKeyword("with"),\n  _new: createKeyword("new", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword("this", {\n    startsExpr\n  }),\n  _super: createKeyword("super", {\n    startsExpr\n  }),\n  _class: createKeyword("class", {\n    startsExpr\n  }),\n  _extends: createKeyword("extends", {\n    beforeExpr\n  }),\n  _export: createKeyword("export"),\n  _import: createKeyword("import", {\n    startsExpr\n  }),\n  _null: createKeyword("null", {\n    startsExpr\n  }),\n  _true: createKeyword("true", {\n    startsExpr\n  }),\n  _false: createKeyword("false", {\n    startsExpr\n  }),\n  _typeof: createKeyword("typeof", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword("void", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword("delete", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword("do", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword("for", {\n    isLoop\n  }),\n  _while: createKeyword("while", {\n    isLoop\n  }),\n  _as: createKeywordLike("as", {\n    startsExpr\n  }),\n  _assert: createKeywordLike("assert", {\n    startsExpr\n  }),\n  _async: createKeywordLike("async", {\n    startsExpr\n  }),\n  _await: createKeywordLike("await", {\n    startsExpr\n  }),\n  _defer: createKeywordLike("defer", {\n    startsExpr\n  }),\n  _from: createKeywordLike("from", {\n    startsExpr\n  }),\n  _get: createKeywordLike("get", {\n    startsExpr\n  }),\n  _let: createKeywordLike("let", {\n    startsExpr\n  }),\n  _meta: createKeywordLike("meta", {\n    startsExpr\n  }),\n  _of: createKeywordLike("of", {\n    startsExpr\n  }),\n  _sent: createKeywordLike("sent", {\n    startsExpr\n  }),\n  _set: createKeywordLike("set", {\n    startsExpr\n  }),\n  _source: createKeywordLike("source", {\n    startsExpr\n  }),\n  _static: createKeywordLike("static", {\n    startsExpr\n  }),\n  _using: createKeywordLike("using", {\n    startsExpr\n  }),\n  _yield: createKeywordLike("yield", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike("asserts", {\n    startsExpr\n  }),\n  _checks: createKeywordLike("checks", {\n    startsExpr\n  }),\n  _exports: createKeywordLike("exports", {\n    startsExpr\n  }),\n  _global: createKeywordLike("global", {\n    startsExpr\n  }),\n  _implements: createKeywordLike("implements", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike("intrinsic", {\n    startsExpr\n  }),\n  _infer: createKeywordLike("infer", {\n    startsExpr\n  }),\n  _is: createKeywordLike("is", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike("mixins", {\n    startsExpr\n  }),\n  _proto: createKeywordLike("proto", {\n    startsExpr\n  }),\n  _require: createKeywordLike("require", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike("satisfies", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike("keyof", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike("readonly", {\n    startsExpr\n  }),\n  _unique: createKeywordLike("unique", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike("abstract", {\n    startsExpr\n  }),\n  _declare: createKeywordLike("declare", {\n    startsExpr\n  }),\n  _enum: createKeywordLike("enum", {\n    startsExpr\n  }),\n  _module: createKeywordLike("module", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike("namespace", {\n    startsExpr\n  }),\n  _interface: createKeywordLike("interface", {\n    startsExpr\n  }),\n  _type: createKeywordLike("type", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike("opaque", {\n    startsExpr\n  }),\n  name: createToken("name", {\n    startsExpr\n  }),\n  placeholder: createToken("%%", {\n    startsExpr: true\n  }),\n  string: createToken("string", {\n    startsExpr\n  }),\n  num: createToken("num", {\n    startsExpr\n  }),\n  bigint: createToken("bigint", {\n    startsExpr\n  }),\n  decimal: createToken("decimal", {\n    startsExpr\n  }),\n  regexp: createToken("regexp", {\n    startsExpr\n  }),\n  privateName: createToken("#name", {\n    startsExpr\n  }),\n  eof: createToken("eof"),\n  jsxName: createToken("jsxName"),\n  jsxText: createToken("jsxText", {\n    beforeExpr: true\n  }),\n  jsxTagStart: createToken("jsxTagStart", {\n    startsExpr: true\n  }),\n  jsxTagEnd: createToken("jsxTagEnd")\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 133;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 133;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 137;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\n{\n  tokenTypes[8].updateContext = context => {\n    context.pop();\n  };\n  tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n    context.push(types.brace);\n  };\n  tokenTypes[22].updateContext = context => {\n    if (context[context.length - 1] === types.template) {\n      context.pop();\n    } else {\n      context.push(types.template);\n    }\n  };\n  tokenTypes[143].updateContext = context => {\n    context.push(types.j_expr, types.j_oTag);\n  };\n}\nlet nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088e\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7cd\\ua7d0\\ua7d1\\ua7d3\\ua7d5-\\ua7dc\\ua7f2-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";\nlet nonASCIIidentifierChars = "\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1ace\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65";\nconst nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");\nconst nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],\n  strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],\n  strictBind: ["eval", "arguments"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === "await" || word === "enum";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = "";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (387 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 387) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name);\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 387) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (387 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  sourceToOffsetPos(sourcePos) {\n    return sourcePos + this.startIndex;\n  }\n  offsetToSourcePos(offsetPos) {\n    return offsetPos - this.startIndex;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === "string") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length !== commentsLen) {\n      this.comments.length = commentsLen;\n    }\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const {\n        containingNode: node,\n        start: commentStart\n      } = commentWS;\n      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {\n        switch (node.type) {\n          case "ObjectExpression":\n          case "ObjectPattern":\n          case "RecordExpression":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case "CallExpression":\n          case "OptionalCallExpression":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case "FunctionDeclaration":\n          case "FunctionExpression":\n          case "ArrowFunctionExpression":\n          case "ObjectMethod":\n          case "ClassMethod":\n          case "ClassPrivateMethod":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case "ArrayExpression":\n          case "ArrayPattern":\n          case "TupleExpression":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case "ExportNamedDeclaration":\n          case "ImportDeclaration":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          default:\n            {\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  resetPreviousIdentifierLeadingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    if (commentStack[length - 1].trailingNode === node) {\n      commentStack[length - 1].trailingNode = null;\n    } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {\n      commentStack[length - 2].trailingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nconst lineBreak = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, "g");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction hasNewLine(input, start, end) {\n  for (let i = start; i < end; i++) {\n    if (isNewLine(input.charCodeAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.startIndex = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 140;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(v) {\n    if (v) this.flags |= 1;else this.flags &= -2;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startIndex,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";\n    this.startIndex = startIndex;\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(v) {\n    if (v) this.flags |= 2;else this.flags &= -3;\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(v) {\n    if (v) this.flags |= 4;else this.flags &= -5;\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(v) {\n    if (v) this.flags |= 8;else this.flags &= -9;\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(v) {\n    if (v) this.flags |= 16;else this.flags &= -17;\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(v) {\n    if (v) this.flags |= 32;else this.flags &= -33;\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(v) {\n    if (v) this.flags |= 64;else this.flags &= -65;\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(v) {\n    if (v) this.flags |= 128;else this.flags &= -129;\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(v) {\n    if (v) this.flags |= 256;else this.flags &= -257;\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(v) {\n    if (v) this.flags |= 512;else this.flags &= -513;\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(v) {\n    if (v) this.flags |= 1024;else this.flags &= -1025;\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(v) {\n    if (v) this.flags |= 2048;else this.flags &= -2049;\n  }\n  get hasTopLevelAwait() {\n    return (this.flags & 4096) > 0;\n  }\n  set hasTopLevelAwait(v) {\n    if (v) this.flags |= 4096;else this.flags &= -4097;\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.startIndex = this.startIndex;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = "";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === "template") {\n        out += input.slice(chunkStart, pos) + "\\n";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === "template") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === "double" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res("\\n");\n    case 114:\n      return res("\\r");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res("\\t");\n    case 98:\n      return res("\\b");\n    case 118:\n      return res("\\u000b");\n    case 102:\n      return res("\\f");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res("");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== "0" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== "bail") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!this.options.errorRecovery) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.options.tokens) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(140);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: "CommentBlock",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: "CommentLine",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = [];\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment("*/");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  if (this.options.attachComment) comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.options.annexB) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.options.annexB) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                if (this.options.attachComment) comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if (comments.length > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {\n      this.expectPlugin("recordAndTuple");\n      if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin("recordAndTuple") && next === 125) {\n        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin("recordAndTuple") && next === 93) {\n        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin(["pipelineOperator", {\n      proposal: "hack",\n      topicToken: "^^"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin(["pipelineOperator", {\n      proposal: "hack",\n      topicToken: "@@"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = "";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes("u")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes("v")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(138, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");\n      this.finishToken(136, str);\n      return;\n    }\n    this.finishToken(135, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf("_");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin("decimal", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      var isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");\n    if (isBigInt) {\n      this.finishToken(136, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(137, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(135, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(134, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = "";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!this.options.errorRecovery) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    let {\n      extra\n    } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    if (this.input.slice(nameStart, nameEnd) === name) {\n      const nextCh = this.input.charCodeAt(nameEnd);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);\n  }\n  hasFollowingLineBreak() {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === "PrivateName";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === "ObjectProperty";\n  }\n  isObjectMethod(node) {\n    return node.type === "ObjectMethod";\n  }\n  initializeScopes(inModule = this.options.sourceType === "module") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule) {\n      paramFlags |= 2;\n    }\n    this.scope.enter(1);\n    this.prodParam.enter(paramFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin("destructuringPrivate", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = "";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser != null && parser.options.ranges) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\n{\n  NodePrototype.__clone = function () {\n    const newNode = new Node(undefined, this.start, this.loc.start);\n    const keys = Object.keys(this);\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {\n        newNode[key] = this[key];\n      }\n    }\n    return newNode;\n  };\n}\nfunction clonePlaceholder(node) {\n  return cloneIdentifier(node);\n}\nfunction cloneIdentifier(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra,\n    name\n  } = node;\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  cloned.extra = extra;\n  cloned.name = name;\n  if (type === "Placeholder") {\n    cloned.expectedNode = node.expectedNode;\n  }\n  return cloned;\n}\nfunction cloneStringLiteral(node) {\n  const {\n    type,\n    start,\n    end,\n    loc,\n    range,\n    extra\n  } = node;\n  if (type === "Placeholder") {\n    return clonePlaceholder(node);\n  }\n  const cloned = Object.create(NodePrototype);\n  cloned.type = type;\n  cloned.start = start;\n  cloned.end = end;\n  cloned.loc = loc;\n  cloned.range = range;\n  if (node.raw !== undefined) {\n    cloned.raw = node.raw;\n  } else {\n    cloned.extra = extra;\n  }\n  cloned.value = node.value;\n  return cloned;\n}\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n    if (this.options.attachComment) this.processComment(node);\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n}\nconst reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",\n  AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: "The `declare` modifier can only appear on class fields.",\n  DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",\n  DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase \'a\' through \'z\'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",\n  ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",\n  ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",\n  InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",\n  InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",\n  InexactVariance: "Explicit inexact syntax cannot have variance.",\n  InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",\n  MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",\n  NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",\n  NestedFlowComment: "Cannot have a flow comment inside another flow comment.",\n  PatternIsOptional: Object.assign({\n    message: "A binding pattern parameter cannot be optional in an implementation signature."\n  }, {\n    reasonCode: "OptionalBindingPattern"\n  }),\n  SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",\n  SpreadVariance: "Spread properties cannot have variance.",\n  ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",\n  ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don\'t bind `this` like other functions.",\n  ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",\n  ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",\n  ThisParamNoDefault: "The `this` parameter may not have a default value.",\n  TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",\n  TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",\n  UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",\n  UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",\n  UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",\n  UnexpectedSubtractionOperand: \'Unexpected token, expected "number" or "bigint".\',\n  UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",\n  UnterminatedFlowComment: "Unterminated flow-comment."\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === "type" || node.importKind === "typeof";\n}\nconst exportSuggestions = {\n  const: "declare export var",\n  let: "declare export var",\n  type: "export type",\n  interface: "export interface"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption("flow", "all") || this.flowPragma === "flow";\n  }\n  finishToken(type, val) {\n    if (type !== 134 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === "flow") {\n        this.flowPragma = "flow";\n      } else if (matches[1] === "noflow") {\n        this.flowPragma = "noflow";\n      } else {\n        throw new Error("Unexpected flow pragma");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, "DeclaredPredicate");\n    } else {\n      return this.finishNode(node, "InferredPredicate");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, "DeclareClass");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");\n    id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, "DeclareFunction");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      this.unexpected();\n    }\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, "DeclareVariable");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(134)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      let bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        super.parseImport(bodyNode);\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n      body.push(bodyNode);\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, "BlockStatement");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === "CommonJS") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = "ES";\n      } else if (bodyElement.type === "DeclareModuleExports") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === "ES") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = "CommonJS";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || "CommonJS";\n    return this.finishNode(node, "DeclareModule");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, "DeclareExportDeclaration");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, "DeclareExportDeclaration");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === "ExportNamedDeclaration") {\n          node.type = "ExportDeclaration";\n          node.default = false;\n          delete node.exportKind;\n        }\n        node.type = "Declare" + node.type;\n        return node;\n      }\n    }\n    this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, "DeclareModuleExports");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    finished.type = "DeclareTypeAlias";\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    finished.type = "DeclareOpaqueType";\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, "DeclareInterface");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, "InterfaceExtends");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, "InterfaceDeclaration");\n  }\n  checkNotUnderscore(word) {\n    if (word === "_") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, "TypeAlias");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, "OpaqueType");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, "TypeParameter");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, "TypeParameterDeclaration");\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n    while (!this.match(48)) {\n      node.params.push(this.flowParseType());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, "TypeParameterInstantiation");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, "TypeParameterInstantiation");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, "InterfaceTypeAnnotation");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, "ObjectTypeIndexer");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, "ObjectTypeInternalSlot");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, "FunctionTypeAnnotation");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, "ObjectTypeCallProperty");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = "init";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, "ObjectTypeSpreadProperty");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === "get" || kind === "set") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === "constructor" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== "init") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, "ObjectTypeProperty");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === "get" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === "set" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    var _startLoc;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, "QualifiedTypeIdentifier");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, "GenericTypeAnnotation");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, "TypeofTypeAnnotation");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, "TupleTypeAnnotation");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, "FunctionTypeParam");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, "FunctionTypeParam");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case "any":\n        return this.finishNode(node, "AnyTypeAnnotation");\n      case "bool":\n      case "boolean":\n        return this.finishNode(node, "BooleanTypeAnnotation");\n      case "mixed":\n        return this.finishNode(node, "MixedTypeAnnotation");\n      case "empty":\n        return this.finishNode(node, "EmptyTypeAnnotation");\n      case "number":\n        return this.finishNode(node, "NumberTypeAnnotation");\n      case "string":\n        return this.finishNode(node, "StringTypeAnnotation");\n      case "symbol":\n        return this.finishNode(node, "SymbolTypeAnnotation");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        {\n          const node = this.startNode();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, "FunctionTypeAnnotation");\n        }\n      case 10:\n        {\n          const node = this.startNode();\n          this.next();\n          if (!this.match(11) && !this.match(21)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== 17 && token !== 14;\n            } else {\n              isGroupedType = true;\n            }\n          }\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n              this.expect(11);\n              return type;\n            } else {\n              this.eat(12);\n            }\n          }\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, "FunctionTypeAnnotation");\n        }\n      case 134:\n        return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, "BooleanLiteralTypeAnnotation");\n      case 53:\n        if (this.state.value === "-") {\n          this.next();\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);\n          }\n          if (this.match(136)) {\n            return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        this.unexpected();\n        return;\n      case 135:\n        return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");\n      case 136:\n        return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");\n      case 88:\n        this.next();\n        return this.finishNode(node, "VoidTypeAnnotation");\n      case 84:\n        this.next();\n        return this.finishNode(node, "NullLiteralTypeAnnotation");\n      case 78:\n        this.next();\n        return this.finishNode(node, "ThisTypeAnnotation");\n      case 55:\n        this.next();\n        return this.finishNode(node, "ExistsTypeAnnotation");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, "ArrayTypeAnnotation");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, "OptionalIndexedAccessType");\n        } else {\n          type = this.finishNode(node, "IndexedAccessType");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, "NullableTypeAnnotation");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, "FunctionTypeAnnotation");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === "_") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, "TypeAnnotation");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === "+") {\n        variance.kind = "plus";\n      } else {\n        variance.kind = "minus";\n      }\n      this.next();\n      return this.finishNode(variance, "Variance");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === "Identifier") {\n      if (expr.name === "declare") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === "interface") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === "type") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === "opaque") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, "ConditionalExpression");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === "ConditionalExpression") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(2 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = newNode;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, "TypeCastExpression");\n    }\n    return newNode;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = "type";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = "type";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = "type";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.isContextual(126)) {\n      node.exportKind = "value";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = "type";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === "type") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === "iterator" || word === "asyncIterator";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = "@@" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === "TypeCastExpression") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (canBePattern && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && this.match(47)) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, "ClassImplements"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === "get") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      if (param.type !== "Identifier") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== "value") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === "type" ? phase : "value";\n    } else {\n      if (phase === "type" && this.match(55)) this.unexpected();\n      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === "Identifier") {\n      if (firstIdent.name === "type") {\n        specifierTypeKind = "type";\n      } else if (firstIdent.name === "typeof") {\n        specifierTypeKind = "typeof";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual("as")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, "ImportSpecifier");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== "get" && kind !== "set" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== "ArrowFunctionExpression") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments(11);\n      base = this.finishNode(node, "CallExpression");\n    } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments(11);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments(11);\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin("flowComments") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf("*/", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 135:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: "number",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: "invalid",\n            loc: startLoc\n          };\n        }\n      case 134:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: "string",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: "invalid",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: "boolean",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: "invalid",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: "invalid",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: "none",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === "") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case "boolean":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));\n            break;\n          }\n        case "number":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));\n            break;\n          }\n        case "string":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));\n            break;\n          }\n        case "invalid":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case "none":\n          {\n            switch (explicitType) {\n              case "boolean":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case "number":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case "boolean":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, "EnumBooleanBody");\n      case "number":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, "EnumNumberBody");\n      case "string":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, "EnumStringBody");\n      case "symbol":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, "EnumSymbolBody");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, "EnumStringBody");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, "EnumStringBody");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, "EnumBooleanBody");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, "EnumNumberBody");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, "EnumDeclaration");\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === "TypeCastExpression" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: "\\u0022",\n  amp: "&",\n  apos: "\\u0027",\n  lt: "<",\n  gt: ">",\n  nbsp: "\\u00A0",\n  iexcl: "\\u00A1",\n  cent: "\\u00A2",\n  pound: "\\u00A3",\n  curren: "\\u00A4",\n  yen: "\\u00A5",\n  brvbar: "\\u00A6",\n  sect: "\\u00A7",\n  uml: "\\u00A8",\n  copy: "\\u00A9",\n  ordf: "\\u00AA",\n  laquo: "\\u00AB",\n  not: "\\u00AC",\n  shy: "\\u00AD",\n  reg: "\\u00AE",\n  macr: "\\u00AF",\n  deg: "\\u00B0",\n  plusmn: "\\u00B1",\n  sup2: "\\u00B2",\n  sup3: "\\u00B3",\n  acute: "\\u00B4",\n  micro: "\\u00B5",\n  para: "\\u00B6",\n  middot: "\\u00B7",\n  cedil: "\\u00B8",\n  sup1: "\\u00B9",\n  ordm: "\\u00BA",\n  raquo: "\\u00BB",\n  frac14: "\\u00BC",\n  frac12: "\\u00BD",\n  frac34: "\\u00BE",\n  iquest: "\\u00BF",\n  Agrave: "\\u00C0",\n  Aacute: "\\u00C1",\n  Acirc: "\\u00C2",\n  Atilde: "\\u00C3",\n  Auml: "\\u00C4",\n  Aring: "\\u00C5",\n  AElig: "\\u00C6",\n  Ccedil: "\\u00C7",\n  Egrave: "\\u00C8",\n  Eacute: "\\u00C9",\n  Ecirc: "\\u00CA",\n  Euml: "\\u00CB",\n  Igrave: "\\u00CC",\n  Iacute: "\\u00CD",\n  Icirc: "\\u00CE",\n  Iuml: "\\u00CF",\n  ETH: "\\u00D0",\n  Ntilde: "\\u00D1",\n  Ograve: "\\u00D2",\n  Oacute: "\\u00D3",\n  Ocirc: "\\u00D4",\n  Otilde: "\\u00D5",\n  Ouml: "\\u00D6",\n  times: "\\u00D7",\n  Oslash: "\\u00D8",\n  Ugrave: "\\u00D9",\n  Uacute: "\\u00DA",\n  Ucirc: "\\u00DB",\n  Uuml: "\\u00DC",\n  Yacute: "\\u00DD",\n  THORN: "\\u00DE",\n  szlig: "\\u00DF",\n  agrave: "\\u00E0",\n  aacute: "\\u00E1",\n  acirc: "\\u00E2",\n  atilde: "\\u00E3",\n  auml: "\\u00E4",\n  aring: "\\u00E5",\n  aelig: "\\u00E6",\n  ccedil: "\\u00E7",\n  egrave: "\\u00E8",\n  eacute: "\\u00E9",\n  ecirc: "\\u00EA",\n  euml: "\\u00EB",\n  igrave: "\\u00EC",\n  iacute: "\\u00ED",\n  icirc: "\\u00EE",\n  iuml: "\\u00EF",\n  eth: "\\u00F0",\n  ntilde: "\\u00F1",\n  ograve: "\\u00F2",\n  oacute: "\\u00F3",\n  ocirc: "\\u00F4",\n  otilde: "\\u00F5",\n  ouml: "\\u00F6",\n  divide: "\\u00F7",\n  oslash: "\\u00F8",\n  ugrave: "\\u00F9",\n  uacute: "\\u00FA",\n  ucirc: "\\u00FB",\n  uuml: "\\u00FC",\n  yacute: "\\u00FD",\n  thorn: "\\u00FE",\n  yuml: "\\u00FF",\n  OElig: "\\u0152",\n  oelig: "\\u0153",\n  Scaron: "\\u0160",\n  scaron: "\\u0161",\n  Yuml: "\\u0178",\n  fnof: "\\u0192",\n  circ: "\\u02C6",\n  tilde: "\\u02DC",\n  Alpha: "\\u0391",\n  Beta: "\\u0392",\n  Gamma: "\\u0393",\n  Delta: "\\u0394",\n  Epsilon: "\\u0395",\n  Zeta: "\\u0396",\n  Eta: "\\u0397",\n  Theta: "\\u0398",\n  Iota: "\\u0399",\n  Kappa: "\\u039A",\n  Lambda: "\\u039B",\n  Mu: "\\u039C",\n  Nu: "\\u039D",\n  Xi: "\\u039E",\n  Omicron: "\\u039F",\n  Pi: "\\u03A0",\n  Rho: "\\u03A1",\n  Sigma: "\\u03A3",\n  Tau: "\\u03A4",\n  Upsilon: "\\u03A5",\n  Phi: "\\u03A6",\n  Chi: "\\u03A7",\n  Psi: "\\u03A8",\n  Omega: "\\u03A9",\n  alpha: "\\u03B1",\n  beta: "\\u03B2",\n  gamma: "\\u03B3",\n  delta: "\\u03B4",\n  epsilon: "\\u03B5",\n  zeta: "\\u03B6",\n  eta: "\\u03B7",\n  theta: "\\u03B8",\n  iota: "\\u03B9",\n  kappa: "\\u03BA",\n  lambda: "\\u03BB",\n  mu: "\\u03BC",\n  nu: "\\u03BD",\n  xi: "\\u03BE",\n  omicron: "\\u03BF",\n  pi: "\\u03C0",\n  rho: "\\u03C1",\n  sigmaf: "\\u03C2",\n  sigma: "\\u03C3",\n  tau: "\\u03C4",\n  upsilon: "\\u03C5",\n  phi: "\\u03C6",\n  chi: "\\u03C7",\n  psi: "\\u03C8",\n  omega: "\\u03C9",\n  thetasym: "\\u03D1",\n  upsih: "\\u03D2",\n  piv: "\\u03D6",\n  ensp: "\\u2002",\n  emsp: "\\u2003",\n  thinsp: "\\u2009",\n  zwnj: "\\u200C",\n  zwj: "\\u200D",\n  lrm: "\\u200E",\n  rlm: "\\u200F",\n  ndash: "\\u2013",\n  mdash: "\\u2014",\n  lsquo: "\\u2018",\n  rsquo: "\\u2019",\n  sbquo: "\\u201A",\n  ldquo: "\\u201C",\n  rdquo: "\\u201D",\n  bdquo: "\\u201E",\n  dagger: "\\u2020",\n  Dagger: "\\u2021",\n  bull: "\\u2022",\n  hellip: "\\u2026",\n  permil: "\\u2030",\n  prime: "\\u2032",\n  Prime: "\\u2033",\n  lsaquo: "\\u2039",\n  rsaquo: "\\u203A",\n  oline: "\\u203E",\n  frasl: "\\u2044",\n  euro: "\\u20AC",\n  image: "\\u2111",\n  weierp: "\\u2118",\n  real: "\\u211C",\n  trade: "\\u2122",\n  alefsym: "\\u2135",\n  larr: "\\u2190",\n  uarr: "\\u2191",\n  rarr: "\\u2192",\n  darr: "\\u2193",\n  harr: "\\u2194",\n  crarr: "\\u21B5",\n  lArr: "\\u21D0",\n  uArr: "\\u21D1",\n  rArr: "\\u21D2",\n  dArr: "\\u21D3",\n  hArr: "\\u21D4",\n  forall: "\\u2200",\n  part: "\\u2202",\n  exist: "\\u2203",\n  empty: "\\u2205",\n  nabla: "\\u2207",\n  isin: "\\u2208",\n  notin: "\\u2209",\n  ni: "\\u220B",\n  prod: "\\u220F",\n  sum: "\\u2211",\n  minus: "\\u2212",\n  lowast: "\\u2217",\n  radic: "\\u221A",\n  prop: "\\u221D",\n  infin: "\\u221E",\n  ang: "\\u2220",\n  and: "\\u2227",\n  or: "\\u2228",\n  cap: "\\u2229",\n  cup: "\\u222A",\n  int: "\\u222B",\n  there4: "\\u2234",\n  sim: "\\u223C",\n  cong: "\\u2245",\n  asymp: "\\u2248",\n  ne: "\\u2260",\n  equiv: "\\u2261",\n  le: "\\u2264",\n  ge: "\\u2265",\n  sub: "\\u2282",\n  sup: "\\u2283",\n  nsub: "\\u2284",\n  sube: "\\u2286",\n  supe: "\\u2287",\n  oplus: "\\u2295",\n  otimes: "\\u2297",\n  perp: "\\u22A5",\n  sdot: "\\u22C5",\n  lceil: "\\u2308",\n  rceil: "\\u2309",\n  lfloor: "\\u230A",\n  rfloor: "\\u230B",\n  lang: "\\u2329",\n  rang: "\\u232A",\n  loz: "\\u25CA",\n  spades: "\\u2660",\n  clubs: "\\u2663",\n  hearts: "\\u2665",\n  diams: "\\u2666"\n};\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",\n  UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{\'${unexpected}\'}\\`?`,\n  UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",\n  UnterminatedJsxContent: "Unterminated JSX contents.",\n  UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"\n});\nfunction isFragment(object) {\n  return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === "JSXIdentifier") {\n    return object.name;\n  }\n  if (object.type === "JSXNamespacedName") {\n    return object.namespace.name + ":" + object.name.name;\n  }\n  if (object.type === "JSXMemberExpression") {\n    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);\n  }\n  throw new Error("Node had unexpected type: " + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = "";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(143);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(142, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? "\\n" : "\\r\\n";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = "";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(134, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, "bail");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return "&";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(141, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(141)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, "JSXIdentifier");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, "JSXNamespacedName");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === "JSXNamespacedName") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, "JSXMemberExpression");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === "JSXEmptyExpression") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 143:\n      case 134:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, "JSXSpreadChild");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, "JSXExpressionContainer");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, "JSXSpreadAttribute");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, "JSXAttribute");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, "JSXOpeningFragment");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(144)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(144);\n    return this.finishNode(node, "JSXOpeningElement");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, "JSXClosingFragment");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(144);\n    return this.finishNode(node, "JSXClosingElement");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 143:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 142:\n            children.push(this.parseLiteral(this.state.value, "JSXText"));\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(143)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(143);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(144);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(143);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 143) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 143) {\n      context.push(types.j_oTag);\n    } else if (type === 144) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags === 256) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags === 256) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nconst unwrapParenthesizedExpression = node => {\n  return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === "Identifier") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case "Identifier":\n      case "ObjectPattern":\n      case "ArrayPattern":\n      case "AssignmentPattern":\n      case "RestElement":\n        break;\n      case "ObjectExpression":\n        node.type = "ObjectPattern";\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case "ObjectProperty":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case "SpreadElement":\n        {\n          throw new Error("Internal @babel/parser error (this is a bug, please report it)." + " SpreadElement should be converted by .toAssignable\'s caller.");\n        }\n      case "ArrayExpression":\n        node.type = "ArrayPattern";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case "AssignmentExpression":\n        if (node.operator !== "=") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        node.type = "AssignmentPattern";\n        delete node.operator;\n        this.toAssignable(node.left, isLHS);\n        break;\n      case "ParenthesizedExpression":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === "ObjectMethod") {\n      this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === "SpreadElement") {\n      prop.type = "RestElement";\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      if (elt.type === "SpreadElement") {\n        elt.type = "RestElement";\n        const arg = elt.argument;\n        this.checkToRestConversion(arg, true);\n        this.toAssignable(arg, isLHS);\n      } else {\n        this.toAssignable(elt, isLHS);\n      }\n      if (elt.type === "RestElement") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case "Identifier":\n      case "ObjectPattern":\n      case "ArrayPattern":\n      case "AssignmentPattern":\n      case "RestElement":\n        return true;\n      case "ObjectExpression":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);\n          });\n        }\n      case "ObjectProperty":\n        return this.isAssignable(node.value);\n      case "SpreadElement":\n        return this.isAssignable(node.argument);\n      case "ArrayExpression":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case "AssignmentExpression":\n        return node.operator === "=";\n      case "ParenthesizedExpression":\n        return this.isAssignable(node.expression);\n      case "MemberExpression":\n      case "OptionalMemberExpression":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, "SpreadElement");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, "RestElement");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, "ArrayPattern");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        let rest = this.parseRestBinding();\n        if (this.hasPlugin("flow") || flags & 2) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (this.match(26) && this.hasPlugin("decorators")) {\n          this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n        }\n        while (this.match(26)) {\n          decorators.push(this.parseDecorator());\n        }\n        elts.push(this.parseAssignableListItem(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    prop.argument = this.parseIdentifier();\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, "RestElement");\n  }\n  parseBindingProperty() {\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n    const prop = this.startNode();\n    if (type === 139) {\n      this.expectPlugin("destructuringPrivate", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseAssignableListItem(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    if (this.hasPlugin("flow") || flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  parseFunctionParamType(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    var _startLoc, _left;\n    (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;\n    left = (_left = left) != null ? _left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, "AssignmentPattern");\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case "AssignmentPattern":\n        return "left";\n      case "RestElement":\n        return "argument";\n      case "ObjectProperty":\n        return "value";\n      case "ParenthesizedExpression":\n        return "expression";\n      case "ArrayPattern":\n        return "elements";\n      case "ObjectPattern":\n        return "properties";\n    }\n    return false;\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === "OptionalMemberExpression";\n  }\n  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === "MemberExpression") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin("optionalChainingAssign", expression.loc.start);\n        if (ancestor.type !== "AssignmentExpression") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === "Identifier") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    }\n    const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    let key, isParenthesizedExpression;\n    if (typeof validity === "string") {\n      key = validity;\n      isParenthesizedExpression = type === "ParenthesizedExpression";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n    const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {\n      type\n    } : ancestor;\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n        }\n      }\n    } else if (val) {\n      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === "let") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case "ParenthesizedExpression":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case "Identifier":\n      case "MemberExpression":\n        break;\n      case "ArrayExpression":\n      case "ObjectExpression":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error("Assert fail");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method \'${methodName}\' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property \'${propertyName}\' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional: "An \'accessor\' property cannot be declared optional.",\n  AccessorCannotDeclareThisParameter: "\'get\' and \'set\' accessors cannot declare \'this\' parameters.",\n  AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",\n  ClassMethodHasDeclare: "Class methods cannot have the \'declare\' modifier.",\n  ClassMethodHasReadonly: "Class methods cannot have the \'readonly\' modifier.",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A \'const\' initializer in an ambient context must be a string or numeric literal or literal enum reference.",\n  ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",\n  DeclareAccessor: ({\n    kind\n  }) => `\'declare\' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",\n  DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: \'${modifier}\'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `\'${token}\' list cannot be empty.`,\n  EmptyTypeArguments: "Type argument list cannot be empty.",\n  EmptyTypeParameters: "Type parameter list cannot be empty.",\n  ExpectedAmbientAfterExportDeclare: "\'export declare\' must be followed by an ambient declaration.",\n  ImportAliasHasImportType: "An import alias can not use \'import type\'.",\n  ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `\'${modifiers[0]}\' modifier cannot be used with \'${modifiers[1]}\' modifier.`,\n  IndexSignatureHasAbstract: "Index signatures cannot have the \'abstract\' modifier.",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier (\'${modifier}\').`,\n  IndexSignatureHasDeclare: "Index signatures cannot have the \'declare\' modifier.",\n  IndexSignatureHasOverride: "\'override\' modifier cannot appear on an index signature.",\n  IndexSignatureHasStatic: "Index signatures cannot have the \'static\' modifier.",\n  InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `\'${modifier}\' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `\'${modifier}\' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `\'${modifier}\' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `\'${orderedModifiers[0]}\' modifier must precede \'${orderedModifiers[1]}\' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. " + "You can either wrap the instantiation expression in parentheses, or delete the type arguments.",\n  InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",\n  MissingInterfaceName: "\'interface\' declarations must be followed by an identifier.",\n  NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",\n  NonClassMethodPropertyHasAbstractModifer: "\'abstract\' modifier can only appear on a class, method, or property declaration.",\n  OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",\n  OverrideNotInSubClass: "This member cannot have an \'override\' modifier because its containing class does not extend another class.",\n  PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",\n  PrivateElementHasAbstract: "Private elements cannot have the \'abstract\' modifier.",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier (\'${modifier}\').`,\n  ReadonlyForMethodSignature: "\'readonly\' modifier can only appear on a property declaration or index signature.",\n  ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",\n  ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",\n  SetAccessorCannotHaveOptionalParameter: "A \'set\' accessor cannot have an optional parameter.",\n  SetAccessorCannotHaveRestParameter: "A \'set\' accessor cannot have rest parameter.",\n  SetAccessorCannotHaveReturnType: "A \'set\' accessor cannot have a return type annotation.",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",\n  TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",\n  TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",\n  TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",\n  TypeModifierIsUsedInTypeExports: "The \'type\' modifier cannot be used on a named export when \'export type\' is used on its export statement.",\n  TypeModifierIsUsedInTypeImports: "The \'type\' modifier cannot be used on a named import when \'import type\' is used on its import statement.",\n  UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",\n  UnexpectedReadonly: "\'readonly\' type modifier is only permitted on array and tuple literal types.",\n  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",\n  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",\n  UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",\n  UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case "any":\n      return "TSAnyKeyword";\n    case "boolean":\n      return "TSBooleanKeyword";\n    case "bigint":\n      return "TSBigIntKeyword";\n    case "never":\n      return "TSNeverKeyword";\n    case "number":\n      return "TSNumberKeyword";\n    case "object":\n      return "TSObjectKeyword";\n    case "string":\n      return "TSStringKeyword";\n    case "symbol":\n      return "TSSymbolKeyword";\n    case "undefined":\n      return "TSUndefinedKeyword";\n    case "unknown":\n      return "TSUnknownKeyword";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === "private" || modifier === "public" || modifier === "protected";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === "in" || modifier === "out";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: ["in", "out"],\n      disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: ["const"],\n      disallowedModifiers: ["in", "out"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: ["in", "out", "const"],\n      disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();\n  }\n  tsNextTokenOnSameLineAndCanFollowModifier() {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      return false;\n    }\n    return this.tsTokenCanFollowModifier();\n  }\n  tsNextTokenCanFollowModifier() {\n    if (this.match(106)) {\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n    return this.tsNextTokenOnSameLineAndCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.includes(modifier)) {\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, "override");\n          enforceOrder(startLoc, modifier, modifier, "static");\n          enforceOrder(startLoc, modifier, modifier, "readonly");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, "in", "out");\n      } else {\n        if (hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, "static", "readonly");\n          enforceOrder(startLoc, modifier, "static", "override");\n          enforceOrder(startLoc, modifier, "override", "readonly");\n          enforceOrder(startLoc, modifier, "abstract", "override");\n          incompatible(startLoc, modifier, "declare", "override");\n          incompatible(startLoc, modifier, "static", "abstract");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case "EnumMembers":\n      case "TypeMembers":\n        return this.match(8);\n      case "HeritageClauseElement":\n        return this.match(5);\n      case "TupleElementTypes":\n        return this.match(3);\n      case "TypeParametersOrArguments":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n    }\n    node.argument = super.parseExprAtom();\n    if (this.eat(12) && !this.match(11)) {\n      node.options = super.parseMaybeAssignAllowIn();\n      this.eat(12);\n    } else {\n      node.options = null;\n    }\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName();\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, "TSImportType");\n  }\n  tsParseEntityName(allowReservedWords = true) {\n    let entity = this.parseIdentifier(allowReservedWords);\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, "TSQualifiedName");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName();\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, "TSTypeReference");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, "TSTypePredicate");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, "TSThisType");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName();\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, "TSTypeQuery");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, "TSTypeParameter");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, "trailingComma", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, "TSTypeParameterDeclaration");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = "parameters";\n    const returnTypeKey = "typeAnnotation";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === "AssignmentPattern" || type === "TSParameterProperty") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, "TSIndexSignature");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    const nodeAny = node;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = nodeAny;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = "parameters";\n      const returnTypeKey = "typeAnnotation";\n      if (method.kind === "get") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === "set") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === "Identifier" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === "RestElement") {\n            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = "method";\n      }\n      return this.finishNode(method, "TSMethodSignature");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, "TSPropertySignature");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);\n      } else {\n        node.key = this.createIdentifier(id, "new");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: ["readonly"],\n      disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, "TSTypeLiteral");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    {\n      const typeParameter = this.startNode();\n      typeParameter.name = this.tsParseTypeParameterName();\n      typeParameter.constraint = this.tsExpectThenParseType(58);\n      node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");\n    }\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, "TSMappedType");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");\n    });\n    return this.finishNode(node, "TSTupleType");\n  }\n  tsParseTupleElementType() {\n    const {\n      startLoc\n    } = this.state;\n    const rest = this.eat(21);\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const startLoc = this.state.startLoc;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAtNode(label);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAtNode(type);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, "TSNamedTupleMember");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, "TSOptionalType");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(startLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, "TSRestType");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, "TSParenthesizedType");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === "TSConstructorType") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 135:\n      case 136:\n      case 134:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, "TSLiteralType");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, "TSLiteralType");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 136:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === "-") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 135 && nextToken.type !== 136) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, "TSLiteralType");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, "TSArrayType");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, "TSIndexedAccessType");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === "readonly") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, "TSTypeOperator");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case "TSTupleType":\n      case "TSArrayType":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");\n    return this.finishNode(node, "TSInferType");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === "TSThisType") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, "TSTypePredicate");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, "TSTypeAnnotation");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, "TSTypePredicate");\n        return this.finishNode(t, "TSTypeAnnotation");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, "TSTypePredicate");\n      return this.finishNode(t, "TSTypeAnnotation");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: "asserts"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, "TSTypeAnnotation");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, "TSConditionalType");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.lookahead().type === 77;\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType("TSFunctionType");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType("TSConstructorType");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType("TSConstructorType", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, "TSTypeAssertion");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName();\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, "TSExpressionWithTypeArguments");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause("extends");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, "TSInterfaceBody");\n    return this.finishNode(node, "TSInterfaceDeclaration");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookahead().type !== 16) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, "TSIntrinsicKeyword");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, "TSTypeAliasDeclaration");\n  }\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, "TSEnumMember");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, "TSEnumDeclaration");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, "TSModuleBlock");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, "TSModuleDeclaration");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.kind = "global";\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(134)) {\n      node.kind = "module";\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(256);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, "TSModuleDeclaration");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, "TSImportEqualsDeclaration");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, "TSExternalModuleReference");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    let startType = this.state.type;\n    let kind;\n    if (this.isContextual(100)) {\n      startType = 74;\n      kind = "let";\n    }\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          nany.declare = true;\n          return super.parseFunctionStatement(nany, false, false);\n        case 80:\n          nany.declare = true;\n          return this.parseClass(nany, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(nany, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(nany);\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual("enum")) {\n            nany.declare = true;\n            return this.parseVarStatement(nany, kind || this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(nany, {\n            const: true,\n            declare: true\n          });\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(nany, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(nany, this.state.value, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);\n  }\n  tsParseExpressionStatement(node, expr, decorators) {\n    switch (expr.name) {\n      case "declare":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n          if (declaration) {\n            declaration.declare = true;\n          }\n          return declaration;\n        }\n      case "global":\n        if (this.match(5)) {\n          this.scope.enter(256);\n          this.prodParam.enter(0);\n          const mod = node;\n          mod.kind = "global";\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, "TSModuleDeclaration");\n        }\n        break;\n      default:\n        return this.tsParseDeclaration(node, expr.name, false, decorators);\n    }\n  }\n  tsParseDeclaration(node, value, next, decorators) {\n    switch (value) {\n      case "abstract":\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case "module":\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(134)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            node.kind = "module";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case "namespace":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          node.kind = "namespace";\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case "type":\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, "TSTypeParameterInstantiation");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseAssignableListItem(flags, decorators) {\n    const startLoc = this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: ["public", "private", "protected", "override", "readonly"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    if (flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, "TSParameterProperty");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);\n    if (node.type === "ArrayExpression") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, "TSNonNullExpression");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments(11);\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, "TSInstantiationExpression");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {\n          this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: "const"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== "value") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === "type" ? "type" : "value";\n    } else {\n      node.importKind = phase === "type" || phase === "typeof" ? phase : "value";\n    }\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      node.importKind = "value";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = "value";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      this.next();\n      const nodeImportEquals = node;\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);\n      } else {\n        nodeImportEquals.importKind = "value";\n      }\n      return this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, "TSExportAssignment");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, "TSNamespaceExportDeclaration");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.lookahead().type === 80;\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind !== "const" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {\n        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (this.match(75) && this.isLookaheadContextual("enum")) {\n      const node = this.startNode();\n      this.expect(75);\n      return this.tsParseEnumDeclaration(node, {\n        const: true\n      });\n    }\n    if (this.isContextual(126)) {\n      return this.tsParseEnumDeclaration(this.startNode());\n    }\n    if (this.isContextual(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier(["public", "protected", "private"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: ["in", "out"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : undefined;\n    return decl || super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.state.maybeInArrowParameters || !this.match(17)) {\n      return super.parseConditional(expr, startLoc, refExpressionErrors);\n    }\n    const result = this.tryParse(() => super.parseConditional(expr, startLoc));\n    if (!result.node) {\n      if (result.error) {\n        super.setOptionalParametersError(refExpressionErrors, result.error);\n      }\n      return expr;\n    }\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, "TSTypeCastExpression");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {\n      node.exportKind = "type";\n    }\n    if (isDeclare) {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === "get" || kind === "set")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === "TSDeclareMethod") return;\n    if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {\n      return;\n    }\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause("implements");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin("jsx"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin("jsx") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case "TSTypeCastExpression":\n        return this.isAssignable(node.expression, isBinding);\n      case "TSParameterProperty":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case "ParenthesizedExpression":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case "TSAsExpression":\n      case "TSSatisfiesExpression":\n      case "TSNonNullExpression":\n      case "TSTypeAssertion":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case "AssignmentExpression":\n        if (!isLHS && node.left.type === "TSTypeCastExpression") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case "TSAsExpression":\n      case "TSSatisfiesExpression":\n      case "TSNonNullExpression":\n      case "TSTypeAssertion":\n      case "ParenthesizedExpression":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case "TSAsExpression":\n      case "TSSatisfiesExpression":\n      case "TSTypeAssertion":\n      case "TSNonNullExpression":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case "TSTypeCastExpression":\n        return true;\n      case "TSParameterProperty":\n        return "parameter";\n      case "TSNonNullExpression":\n      case "TSInstantiationExpression":\n        return "expression";\n      case "TSAsExpression":\n      case "TSSatisfiesExpression":\n      case "TSTypeAssertion":\n        return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];\n      default:\n        return super.isValidLVal(type, isUnparenthesizedInAssign, binding);\n    }\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const {\n      isAmbientContext: oldIsAmbientContext,\n      strict: oldStrict\n    } = this.state;\n    this.state.isAmbientContext = true;\n    this.state.strict = false;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n      this.state.strict = oldStrict;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);\n        return this.tsParseInterfaceDeclaration(node);\n      }\n    } else {\n      this.unexpected(null, 80);\n    }\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract) {\n      const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;\n      if (hasBody) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption("typescript", "dts");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, "ExportSpecifier");\n    }\n    node.exportKind = "value";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, "ImportSpecifier");\n    }\n    specifier.importKind = "value";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? "imported" : "local";\n    const rightOfAsKey = isImport ? "local" : "exported";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? "importKind" : "exportKind";\n    node[kindKey] = hasTypeSpecifier ? "type" : "value";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== "MemberExpression") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === "Literal") {\n      const {\n        value\n      } = expression;\n      if (typeof value === "string" || typeof value === "boolean") {\n        return true;\n      }\n    }\n  } else {\n    if (type === "StringLiteral" || type === "BooleanLiteral") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === "TemplateLiteral" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);\n  }\n  return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === "UnaryExpression") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === "-" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === "Identifier") return true;\n  if (expression.type !== "MemberExpression" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: "A class name is required.",\n  UnexpectedSpace: "Unexpected space in placeholder."\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(133)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(133);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    let placeholder = node;\n    if (!placeholder.expectedNode || !placeholder.type) {\n      placeholder = this.finishNode(placeholder, "Placeholder");\n    }\n    placeholder.expectedNode = expectedNode;\n    return placeholder;\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(133, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder("Pattern") || super.parseBindingAtom();\n  }\n  isValidLVal(type, isParenthesized, binding) {\n    return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {\n      node.expectedNode = "Pattern";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const nextToken = this.lookahead();\n    if (nextToken.type === 133) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    if (node.label && node.label.type === "Placeholder") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, "Identifier");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, "LabeledStatement");\n    }\n    this.semicolon();\n    const stmtPlaceholder = node;\n    stmtPlaceholder.name = expr.name;\n    return this.finishPlaceholder(stmtPlaceholder, "Statement");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? "ClassDeclaration" : "ClassExpression";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder("Identifier");\n    if (placeholder) {\n      if (this.match(81) || this.match(133) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, "ClassBody");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder("Identifier");\n    if (!placeholder) return super.parseExport(node, decorators);\n    const node2 = node;\n    if (!this.isContextual(98) && !this.match(12)) {\n      node2.specifiers = [];\n      node2.source = null;\n      node2.declaration = this.finishPlaceholder(placeholder, "Declaration");\n      return this.finishNode(node2, "ExportNamedDeclaration");\n    }\n    this.expectPlugin("exportDefaultFrom");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];\n    return super.parseExport(node2, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, "from")) {\n        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === "Placeholder");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder("Identifier");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, "StringLiteral");\n      this.semicolon();\n      return this.finishNode(node, "ImportDeclaration");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, "ImportDeclaration");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder("StringLiteral") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = "V8IntrinsicIdentifier";\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nconst PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];\nconst TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];\nfunction validatePlugins(pluginsMap) {\n  if (pluginsMap.has("decorators")) {\n    if (pluginsMap.has("decorators-legacy")) {\n      throw new Error("Cannot use the decorators and decorators-legacy plugin together");\n    }\n    const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {\n      throw new Error("\'decoratorsBeforeExport\' must be a boolean, if specified.");\n    }\n    const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {\n      throw new Error("\'allowCallParenthesized\' must be a boolean.");\n    }\n  }\n  if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {\n    throw new Error("Cannot combine flow and typescript plugins.");\n  }\n  if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {\n    throw new Error("Cannot combine placeholders and v8intrinsic plugins.");\n  }\n  if (pluginsMap.has("pipelineOperator")) {\n    var _pluginsMap$get;\n    const proposal = pluginsMap.get("pipelineOperator").proposal;\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `"${p}"`).join(", ");\n      throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);\n    }\n    const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";\n    if (proposal === "hack") {\n      if (pluginsMap.has("placeholders")) {\n        throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");\n      }\n      if (pluginsMap.has("v8intrinsic")) {\n        throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");\n      }\n      const topicToken = pluginsMap.get("pipelineOperator").topicToken;\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `"${t}"`).join(", ");\n        throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === "#" && tupleSyntaxIsHash) {\n        throw new Error(`Plugin conflict between \\`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\\` and \\`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\\`.`);\n      }\n    } else if (proposal === "smart" && tupleSyntaxIsHash) {\n      throw new Error(`Plugin conflict between \\`["pipelineOperator", { proposal: "smart" }]\\` and \\`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\\`.`);\n    }\n  }\n  if (pluginsMap.has("moduleAttributes")) {\n    {\n      if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {\n        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");\n      }\n      const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;\n      if (moduleAttributesVersionPluginOption !== "may-2020") {\n        throw new Error("The \'moduleAttributes\' plugin requires a \'version\' option," + " representing the last proposal update. Currently, the" + " only supported value is \'may-2020\'.");\n      }\n    }\n  }\n  if (pluginsMap.has("importAssertions")) {\n    if (pluginsMap.has("deprecatedImportAssert")) {\n      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");\n    }\n  }\n  if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {\n    {\n      pluginsMap.set("deprecatedImportAssert", {});\n    }\n  }\n  if (pluginsMap.has("recordAndTuple")) {\n    const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;\n    if (syntaxType != null) {\n      {\n        const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];\n        if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {\n          throw new Error("The \'syntaxType\' option of the \'recordAndTuple\' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `\'${p}\'`).join(", "));\n        }\n      }\n    }\n  }\n  if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {\n    const error = new Error("\'asyncDoExpressions\' requires \'doExpressions\', please add \'doExpressions\' to parser plugins.");\n    error.missingPlugins = "doExpressions";\n    throw error;\n  }\n  if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {\n    throw new Error("The \'optionalChainingAssign\' plugin requires a \'version\' option," + " representing the last proposal update. Currently, the" + " only supported value is \'2023-07\'.");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nfunction createDefaultOptions() {\n  return {\n    sourceType: "script",\n    sourceFilename: undefined,\n    startIndex: 0,\n    startColumn: 0,\n    startLine: 1,\n    allowAwaitOutsideFunction: false,\n    allowReturnOutsideFunction: false,\n    allowNewTargetOutsideFunction: false,\n    allowImportExportEverywhere: false,\n    allowSuperOutsideMethod: false,\n    allowUndeclaredExports: false,\n    plugins: [],\n    strictMode: null,\n    ranges: false,\n    tokens: false,\n    createImportExpressions: false,\n    createParenthesizedExpressions: false,\n    errorRecovery: false,\n    attachComment: true,\n    annexB: true\n  };\n}\nfunction getOptions(opts) {\n  const options = createDefaultOptions();\n  if (opts == null) {\n    return options;\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error("The `annexB` option can only be set to `false`.");\n  }\n  for (const key of Object.keys(options)) {\n    if (opts[key] != null) options[key] = opts[key];\n  }\n  if (options.startLine === 1) {\n    if (opts.startIndex == null && options.startColumn > 0) {\n      options.startIndex = options.startColumn;\n    } else if (opts.startColumn == null && options.startIndex > 0) {\n      options.startColumn = options.startIndex;\n    }\n  } else if (opts.startColumn == null || opts.startIndex == null) {\n    if (opts.startIndex != null) {\n      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");\n    }\n  }\n  return options;\n}\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, protoRef, refExpressionErrors) {\n    if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return;\n    }\n    const key = prop.key;\n    const name = key.type === "Identifier" ? key.name : key.value;\n    if (name === "__proto__") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return;\n      }\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      protoRef.used = true;\n    }\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    const expr = this.parseExpression();\n    if (!this.match(140)) {\n      this.unexpected();\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.options.tokens) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, "SequenceExpression");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors, resultError) {\n    var _resultError$loc;\n    refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    if (this.isContextual(108)) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield();\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, "AssignmentExpression"));\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, "ConditionalExpression");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin("pipelineOperator");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin(["pipelineOperator", {\n          proposal: "minimal"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption("pipelineOperator", "proposal")) {\n          case "hack":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case "smart":\n            return this.withTopicBindingContext(() => {\n              if (this.prodParam.hasYield && this.isContextual(108)) {\n                throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n              }\n              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n            });\n          case "fsharp":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin("throwExpressions");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === "Identifier") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, "UnaryExpression");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousAwait()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, expr = this.finishNode(node, "UpdateExpression"));\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          state.stop = true;\n          return base;\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        state.stop = true;\n        return base;\n      }\n    }\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(139)) {\n      if (base.type === "Super") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, "OptionalMemberExpression");\n    } else {\n      return this.finishNode(node, "MemberExpression");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments(11);\n    } else {\n      node.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, "TaggedTemplateExpression");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === "Import") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === "SpreadElement") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");\n  }\n  parseCallExpressionArguments(close, allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaProperty(node);\n        }\n        if (this.match(10)) {\n          if (this.options.createImportExpressions) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, "Import");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, "Import");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, "ThisExpression");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 135:\n        return this.parseNumericLiteral(this.state.value);\n      case 136:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 2:\n      case 1:\n        {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, true, false, refExpressionErrors);\n        }\n      case 6:\n      case 7:\n        {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === "MemberExpression") {\n            return this.finishNode(node, "BindExpression");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 139:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, "%");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, "^");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference("hack");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          this.unexpected();\n          break;\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            this.expectOnePlugin(["jsx", "flow", "typescript"]);\n          } else {\n            this.unexpected();\n          }\n          break;\n        }\n      default:\n        if (type === 137) {\n          return this.parseDecimalLiteral(this.state.value);\n        }\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    } else {\n      this.unexpected();\n    }\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";\n      if (!this.topicReferenceIsAllowedInCurrentContext()) {\n        this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);\n      }\n      this.registerTopicReference();\n      return this.finishNode(node, nodeType);\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case "hack":\n        {\n          return this.hasPlugin(["pipelineOperator", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case "smart":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin("doExpressions");\n    if (isAsync) {\n      this.expectPlugin("asyncDoExpressions");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, "DoExpression");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.SuperNotAllowed, node);\n    } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n      this.raise(Errors.UnexpectedSuper, node);\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, "Super");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, "PrivateName");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), "function");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin("functionSent");\n      } else if (!this.hasPlugin("functionSent")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, "sent");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, "MetaProperty");\n  }\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), "import");\n    this.next();\n    if (this.isContextual(101)) {\n      if (!this.inModule) {\n        this.raise(Errors.ImportMetaOutsideModule, id);\n      }\n      this.sawUnambiguousESM = true;\n    } else if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      if (!isSource) this.unexpected();\n      this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");\n      if (!this.options.createImportExpressions) {\n        throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {\n          phase: this.state.value\n        });\n      }\n      this.next();\n      node.phase = isSource ? "source" : "defer";\n      return this.parseImportCall(node);\n    }\n    return this.parseMetaProperty(node, id, "meta");\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, "rawValue", value);\n    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, "StringLiteral");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, "NumericLiteral");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, "BigIntLiteral");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, "DecimalLiteral");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.startNode();\n    this.addExtra(node, "raw", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, "RegExpLiteral");\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, "BooleanLiteral");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, "NullLiteral");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, "SequenceExpression");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(expression, "parenthesized", true);\n      this.addExtra(expression, "parenStart", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, "ParenthesizedExpression");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), "new");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, "target");\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, "NewExpression");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, "\\n"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, "TemplateElement");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    node.expressions = substitutions;\n    node.quasis = quasis;\n    return this.finishNode(node, "TemplateLiteral");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin("recordAndTuple");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        this.checkProto(prop, isRecord, propHash, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      {\n        if (prop.shorthand) {\n          this.addExtra(prop, "shorthand", true);\n        }\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = "ObjectExpression";\n    if (isPattern) {\n      type = "ObjectPattern";\n    } else if (isRecord) {\n      type = "RecordExpression";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);\n    this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin("decorators")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const {\n        key\n      } = prop;\n      const keyName = key.name;\n      if (keyName === "async" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === "get" || keyName === "set") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === "get" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = "method";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);\n      return this.finishNode(prop, "ObjectProperty");\n    }\n    if (!prop.computed && prop.key.type === "Identifier") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));\n      } else {\n        prop.value = cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishNode(prop, "ObjectProperty");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 135:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 134:\n            key = this.parseStringLiteral(value);\n            break;\n          case 136:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 139:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            if (type === 137) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 139) {\n        prop.computed = false;\n      }\n    }\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin("recordAndTuple");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(2 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, "ArrowFunctionExpression");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === "Identifier";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: "FormalParameters"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: ","\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin("partialApplication");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, "ArgumentPlaceholder");\n    } else {\n      elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, "Identifier");\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === "yield") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === "await") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === "arguments") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  recordAwaitIfAllowed() {\n    const isAwaitAllowed = this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction;\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n    return isAwaitAllowed;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.isAmbiguousAwait()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, "AwaitExpression");\n  }\n  isAmbiguousAwait() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;\n  }\n  parseYield() {\n    const node = this.startNode();\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    this.next();\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 140:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, "YieldExpression");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(12)) {\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        if (this.eat(12) && !this.match(11)) {\n          do {\n            this.parseMaybeAssignAllowIn();\n          } while (this.eat(12) && !this.match(11));\n          this.raise(Errors.ImportCallArity, node);\n        }\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, "ImportExpression");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin(["pipelineOperator", {\n      proposal: "smart"\n    }])) {\n      if (left.type === "SequenceExpression") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, "PipelineBareFunction");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, "PipelineTopicExpression");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case "MemberExpression":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case "Identifier":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin(["pipelineOperator", {\n      proposal: "smart"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin("moduleBlocks");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, "module");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, "ModuleExpression");\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input, startIndex) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === "number") {\n      {\n        if (type === 139) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(i, 1, new Token({\n            type: getExportedToken(27),\n            value: "#",\n            start: start,\n            end: hashEndPos,\n            startLoc: loc.start,\n            endLoc: hashEndLoc\n          }), new Token({\n            type: getExportedToken(132),\n            value: value,\n            start: hashEndPos,\n            end: end,\n            startLoc: hashEndLoc,\n            endLoc: loc.end\n          }));\n          i++;\n          continue;\n        }\n        if (tokenIsTemplate(type)) {\n          const {\n            loc,\n            start,\n            value,\n            end\n          } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start - startIndex) === 96) {\n            startToken = new Token({\n              type: getExportedToken(22),\n              value: "`",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          } else {\n            startToken = new Token({\n              type: getExportedToken(8),\n              value: "}",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc\n            });\n          }\n          let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n          if (type === 24) {\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              type: getExportedToken(22),\n              value: "`",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          } else {\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              type: getExportedToken(23),\n              value: "${",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end\n            });\n          }\n          tokens.splice(i, 1, startToken, new Token({\n            type: getExportedToken(20),\n            value: templateValue,\n            start: backquoteEnd,\n            end: templateElementEnd,\n            startLoc: backquoteEndLoc,\n            endLoc: templateElementEndLoc\n          }), endToken);\n          i += 2;\n          continue;\n        }\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program);\n    file.comments = this.comments;\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);\n    }\n    return this.finishNode(file, "File");\n  }\n  parseProgram(program, end = 140, sourceType = this.options.sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (!this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, {\n            localName\n          });\n        }\n      }\n      this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram;\n    if (end === 140) {\n      finishedProgram = this.finishNode(program, "Program");\n    } else {\n      finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = stmt;\n    directive.type = "Directive";\n    directive.value = directive.expression;\n    delete directive.expression;\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, "raw", raw);\n    this.addExtra(directiveLiteral, "rawValue", val);\n    this.addExtra(directiveLiteral, "expressionValue", expressionValue);\n    directiveLiteral.type = "DirectiveLiteral";\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, "InterpreterDirective");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifierOrBrace() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  startsUsingForOf() {\n    const {\n      type,\n      containsEsc\n    } = this.lookahead();\n    if (type === 102 && !containsEsc) {\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin("explicitResourceManagement");\n      return true;\n    }\n  }\n  startsAwaitUsing() {\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, "using")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        this.expectPlugin("explicitResourceManagement");\n        return true;\n      }\n    }\n    return false;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (startType) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (!this.state.containsEsc && this.startsAwaitUsing()) {\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, "await using");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {\n          break;\n        }\n        this.expectPlugin("explicitResourceManagement");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, "using");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (startType === 83) {\n            result = this.parseImport(node);\n            if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node, decorators);\n            if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin("decorators-legacy")) return true;\n    return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin(["decorators", "decorators-legacy"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin("decorators")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(139)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, "MemberExpression");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, "Decorator");\n  }\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(10)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(11);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, "CallExpression");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? "BreakStatement" : "ContinueStatement";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, "DebuggerStatement");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, "DoWhileStatement");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = "await using";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, "VariableDeclaration");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === "Identifier") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? "ForOfStatement" : "ForInStatement";\n      this.checkLVal(init, {\n        type\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, "IfStatement");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, "ReturnStatement");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(0);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, "SwitchCase");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, "SwitchCase");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, "SwitchStatement");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, "ThrowStatement");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);\n    this.checkLVal(param, {\n      type: "CatchClause"\n    }, 9);\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, "CatchClause");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, "TryStatement");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, "VariableDeclaration");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, "WhileStatement");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, "WithStatement");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, "EmptyStatement");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start)\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, "LabeledStatement");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, "ExpressionStatement");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, "BlockStatement");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === "use strict") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, "ForStatement");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? "ForInStatement" : "ForOfStatement"\n      });\n    }\n    if (init.type === "AssignmentPattern") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: "ForStatement"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: "destructuring"\n          });\n        } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, "VariableDeclarator"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === "using" || kind === "await using") {\n      if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(id, {\n      type: "VariableDeclarator"\n    }, kind === "var" ? 5 : 8201);\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(2);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  nameIsConstructor(key) {\n    return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && this.nameIsConstructor(method.key);\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, "ClassBody");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = "method";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = "method";\n      const isPrivateName = this.match(139);\n      this.parseClassElementName(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? key.name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = "method";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = "constructor";\n        if (state.hadConstructor && !this.hasPlugin("typescript")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin("typescript") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = "method";\n      const isPrivate = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {\n      this.expectPlugin("decoratorAutoAccessors");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 134) && member.static && value === "prototype") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 139) {\n      if (value === "constructor") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    this.parsePropertyName(member);\n    return member.key;\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(64 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, "StaticBlock"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);\n    classBody.body.push(node);\n    const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, "ClassPrivateProperty");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, "ClassProperty");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, "ClassAccessorProperty");\n  }\n  parseInitializer(node) {\n    this.scope.enter(64 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, "ExportAllDeclaration");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      return this.finishNode(node2, "ExportNamedDeclaration");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === "ClassDeclaration") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      return this.finishNode(node2, "ExportDefaultDeclaration");\n    }\n    this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      var _ref, _ref$specifiers;\n      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      const node2 = node;\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === "type";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      node2.declaration = null;\n      if (this.hasPlugin("importAssertions")) {\n        node2.assertions = [];\n      }\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin("importAssertions")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, "function");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const {\n          type: nextType\n        } = this.lookahead();\n        if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {\n          this.expectOnePlugin(["flow", "typescript"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, "from");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin(["decorators", "decorators-legacy"]);\n      if (this.hasPlugin("decorators")) {\n        if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    if (this.isContextual(107)) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    if (this.isContextual(96) && this.startsAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, "default");\n        if (this.hasPlugin("exportDefaultFrom")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === "Identifier" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== "Identifier") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        const decl = node.declaration;\n        if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {\n          const {\n            id\n          } = decl;\n          if (!id) throw new Error("Assertion failure");\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === "VariableDeclaration") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === "Identifier") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === "ObjectPattern") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === "ArrayPattern") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === "ObjectProperty") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === "RestElement") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === "AssignmentPattern") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === "default") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(134);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, "ExportSpecifier");\n  }\n  parseModuleExportName() {\n    if (this.match(134)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === "source") {\n      if (singleBindingType !== "ImportDefaultSpecifier") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === "defer") {\n      if (singleBindingType !== "ImportNamespaceSpecifier") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== "ImportDefaultSpecifier") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === "ExportSpecifier") {\n            imported = specifier.local;\n          } else if (specifier.type === "ImportSpecifier") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === "module") {\n      this.expectPlugin("importReflection", loc);\n      node.module = true;\n    } else if (this.hasPlugin("importReflection")) {\n      node.module = false;\n    }\n    if (phase === "source") {\n      this.expectPlugin("sourcePhaseImports", loc);\n      node.phase = "source";\n    } else if (phase === "defer") {\n      this.expectPlugin("deferredImportEvaluation", loc);\n      node.phase = "defer";\n    } else if (this.hasPlugin("sourcePhaseImports")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.parseIdentifier(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.resetPreviousIdentifierLeadingComments(phaseIdentifier);\n      this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return phaseIdentifier;\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    return this.finishNode(node, "ImportDeclaration");\n  }\n  parseImportSource() {\n    if (!this.match(134)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      type\n    }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(134)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, "ImportAttribute"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== "type") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, "ImportAttribute"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    {\n      var useWith = false;\n    }\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      if (this.hasPlugin("moduleAttributes")) {\n        attributes = this.parseModuleAttributes();\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      {\n        useWith = true;\n      }\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (!this.hasPlugin("importAssertions")) {\n        this.addExtra(node, "deprecatedAssertSyntax", true);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n    if (!useWith && this.hasPlugin("importAssertions")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(134);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === "Identifier" && param.name === "this";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input, pluginsMap) {\n    options = getOptions(options);\n    super(options, input);\n    this.options = options;\n    this.initializeScopes();\n    this.plugins = pluginsMap;\n    this.filename = options.sourceFilename;\n    this.startIndex = options.startIndex;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    file.comments.length = this.state.commentsLen;\n    return file;\n  }\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = "module";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = "script";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = "script";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = "script";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  const pluginsMap = new Map();\n  if (options != null && options.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === "string") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n  return new cls(options, input, pluginsMap);\n}\nconst parserClassCache = new Map();\nfunction getParserClass(pluginsMap) {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join("|");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxNzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxZQUFZO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsK0JBQStCLE1BQU07QUFDeEM7QUFDQSwwS0FBMEs7QUFDMUs7QUFDQSxpR0FBaUcsS0FBSztBQUN0Ryx5S0FBeUs7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBHQUEwRyxHQUFHLFVBQVUsUUFBUSxXQUFXLElBQUk7QUFDako7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUZBQXlGLEdBQUcsV0FBVyxVQUFVO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUNBQW1DLGFBQWE7QUFDbkQ7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLGVBQWU7QUFDN0M7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0EsR0FBRywwQ0FBMEMsNEJBQTRCO0FBQ3pFO0FBQ0E7QUFDQSxHQUFHLDJEQUEyRCw0QkFBNEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhCQUE4QixXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0JBQXNCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxlQUFlLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsc0VBQXNFLDJEQUEyRDtBQUNwSTtBQUNBO0FBQ0EsR0FBRywwRkFBMEYsMkRBQTJEO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLElBQUk7QUFDOUI7QUFDQTtBQUNBLEdBQUcsa0VBQWtFLCtCQUErQjtBQUNwRztBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvRUFBb0UsZUFBZSxtQ0FBbUMsZ0JBQWdCO0FBQ3pJO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQyxlQUFlO0FBQ2xELGdGQUFnRjtBQUNoRixtRkFBbUY7QUFDbkYscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsa0NBQWtDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdCQUF3QixrQkFBa0IsV0FBVyxTQUFTLEVBQUUsMEJBQTBCLFNBQVMsUUFBUTtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlDQUF5QyxRQUFRLEtBQUssT0FBTyxHQUFHLHNCQUFzQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvQkFBb0IsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsY0FBYztBQUN2QztBQUNBO0FBQ0EsR0FBRyxpQkFBaUIsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0EsR0FBRyw0QkFBNEIsTUFBTSxvQkFBb0IsT0FBTyw0RUFBNEUscUNBQXFDLE1BQU0sR0FBRztBQUMxTCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLEdBQUcsMERBQTBEO0FBQzdEO0FBQ0EsR0FBRyxJQUFJO0FBQ1AsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsNEVBQTRFO0FBQzVFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0IsR0FBRyxTQUFTLEdBQUcsV0FBVztBQUN6RTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUE4RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUNBQXVDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrRUFBa0UsWUFBWSxpQkFBaUIsWUFBWSx1QkFBdUIsU0FBUztBQUM5STtBQUNBO0FBQ0E7QUFDQSxHQUFHLDREQUE0RCxXQUFXLDRDQUE0QyxTQUFTO0FBQy9IO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixnQkFBZ0IsMkZBQTJGLFNBQVM7QUFDM0k7QUFDQTtBQUNBLEdBQUcsaUhBQWlILFNBQVM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUyxnQkFBZ0IsYUFBYSw4QkFBOEIsV0FBVyxtQkFBbUIsY0FBYztBQUNsSTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlEQUF5RCxXQUFXLGdCQUFnQixTQUFTO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMENBQTBDLFdBQVcsMkVBQTJFLFNBQVM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBGQUEwRixXQUFXLHVCQUF1QixXQUFXLGdCQUFnQixTQUFTO0FBQ25LO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkRBQTJELFlBQVksa0JBQWtCLFNBQVM7QUFDckc7QUFDQTtBQUNBLEdBQUcsZ0hBQWdILFNBQVM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLHlCQUF5QjtBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLHlCQUF5QixzQkFBc0IsNkJBQTZCLFdBQVc7QUFDMUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0RBQW9ELGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkJBQTJCLFdBQVcscUJBQXFCLFdBQVcsU0FBUyxHQUFHLFdBQVcsRUFBRTtBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsWUFBWTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxHQUFHO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxHQUFHLGtCQUFrQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0NBQW9DLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsNkJBQTZCLFNBQVM7QUFDekM7QUFDQTtBQUNBLEdBQUcsU0FBUyxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGFBQWEsa0NBQWtDLGFBQWE7QUFDeEU7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpRUFBaUUsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQjtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHLFNBQVMsb0JBQW9CLDJCQUEyQixvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUVBQWlFLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEJBQThCLG1CQUFtQixnREFBZ0Qsa0JBQWtCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhGQUE4RixLQUFLO0FBQ3RHLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxtRkFBbUYscUZBQXFGO0FBQ3hLLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EscUZBQXFGLHFGQUFxRjtBQUMxSyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsbUdBQW1HLGFBQWE7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3RELHlJQUF5SSxVQUFVO0FBQ25KO0FBQ0E7QUFDQSwwRUFBMEUsbUNBQW1DLFlBQVkscUVBQXFFO0FBQzlMO0FBQ0EsTUFBTTtBQUNOLHdFQUF3RSxtQkFBbUIsWUFBWSxxRUFBcUU7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUpBQWlKLEVBQUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanM/NjJmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoZS5pbmNsdWRlcyhuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5jbGFzcyBQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxpbmUsIGNvbCwgaW5kZXgpIHtcbiAgICB0aGlzLmxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2x1bW4gPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxufVxuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGVuYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuaWRlbnRpZmllck5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQocG9zaXRpb24sIGNvbHVtbk9mZnNldCkge1xuICBjb25zdCB7XG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXhcbiAgfSA9IHBvc2l0aW9uO1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbiArIGNvbHVtbk9mZnNldCwgaW5kZXggKyBjb2x1bW5PZmZzZXQpO1xufVxuY29uc3QgY29kZSA9IFwiQkFCRUxfUEFSU0VSX1NPVVJDRVRZUEVfTU9EVUxFX1JFUVVJUkVEXCI7XG52YXIgTW9kdWxlRXJyb3JzID0ge1xuICBJbXBvcnRNZXRhT3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGBpbXBvcnQubWV0YSBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXCJtb2R1bGVcIidgLFxuICAgIGNvZGVcbiAgfSxcbiAgSW1wb3J0T3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGAnaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IFwibW9kdWxlXCInYCxcbiAgICBjb2RlXG4gIH1cbn07XG5jb25zdCBOb2RlRGVzY3JpcHRpb25zID0ge1xuICBBcnJheVBhdHRlcm46IFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiLFxuICBBc3NpZ25tZW50UGF0dGVybjogXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIixcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IFwiYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb246IFwiY29uZGl0aW9uYWwgZXhwcmVzc2lvblwiLFxuICBDYXRjaENsYXVzZTogXCJjYXRjaCBjbGF1c2VcIixcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFwiZm9yLW9mIHN0YXRlbWVudFwiLFxuICBGb3JJblN0YXRlbWVudDogXCJmb3ItaW4gc3RhdGVtZW50XCIsXG4gIEZvclN0YXRlbWVudDogXCJmb3ItbG9vcFwiLFxuICBGb3JtYWxQYXJhbWV0ZXJzOiBcImZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0XCIsXG4gIElkZW50aWZpZXI6IFwiaWRlbnRpZmllclwiLFxuICBJbXBvcnRTcGVjaWZpZXI6IFwiaW1wb3J0IHNwZWNpZmllclwiLFxuICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBcImltcG9ydCBkZWZhdWx0IHNwZWNpZmllclwiLFxuICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFwiaW1wb3J0IG5hbWVzcGFjZSBzcGVjaWZpZXJcIixcbiAgT2JqZWN0UGF0dGVybjogXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uOiBcInBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiLFxuICBSZXN0RWxlbWVudDogXCJyZXN0IGVsZW1lbnRcIixcbiAgVXBkYXRlRXhwcmVzc2lvbjoge1xuICAgIHRydWU6IFwicHJlZml4IG9wZXJhdGlvblwiLFxuICAgIGZhbHNlOiBcInBvc3RmaXggb3BlcmF0aW9uXCJcbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yOiBcInZhcmlhYmxlIGRlY2xhcmF0aW9uXCIsXG4gIFlpZWxkRXhwcmVzc2lvbjogXCJ5aWVsZCBleHByZXNzaW9uXCJcbn07XG5jb25zdCB0b05vZGVEZXNjcmlwdGlvbiA9IG5vZGUgPT4gbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiA/IE5vZGVEZXNjcmlwdGlvbnMuVXBkYXRlRXhwcmVzc2lvbltgJHtub2RlLnByZWZpeH1gXSA6IE5vZGVEZXNjcmlwdGlvbnNbbm9kZS50eXBlXTtcbnZhciBTdGFuZGFyZEVycm9ycyA9IHtcbiAgQWNjZXNzb3JJc0dlbmVyYXRvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGBBICR7a2luZH10ZXIgY2Fubm90IGJlIGEgZ2VuZXJhdG9yLmAsXG4gIEFyZ3VtZW50c0luQ2xhc3M6IFwiJ2FyZ3VtZW50cycgaXMgb25seSBhbGxvd2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3MgbWV0aG9kcy5cIixcbiAgQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgQXdhaXRCaW5kaW5nSWRlbnRpZmllcjogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uLlwiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jazogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgc3RhdGljIGJsb2NrLlwiLFxuICBBd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXI6IFwiJ2F3YWl0JyBpcyBub3QgYWxsb3dlZCBpbiBhc3luYyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlwiLFxuICBBd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQ6IFwiJ2F3YWl0IHVzaW5nJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGFzeW5jIGZ1bmN0aW9ucyBhbmQgYXQgdGhlIHRvcCBsZXZlbHMgb2YgbW9kdWxlcy5cIixcbiAgQXdhaXROb3RJbkFzeW5jQ29udGV4dDogXCInYXdhaXQnIGlzIG9ubHkgYWxsb3dlZCB3aXRoaW4gYXN5bmMgZnVuY3Rpb25zIGFuZCBhdCB0aGUgdG9wIGxldmVscyBvZiBtb2R1bGVzLlwiLFxuICBBd2FpdE5vdEluQXN5bmNGdW5jdGlvbjogXCInYXdhaXQnIGlzIG9ubHkgYWxsb3dlZCB3aXRoaW4gYXN5bmMgZnVuY3Rpb25zLlwiLFxuICBCYWRHZXR0ZXJBcml0eTogXCJBICdnZXQnIGFjY2Vzc29yIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBCYWRTZXR0ZXJBcml0eTogXCJBICdzZXQnIGFjY2Vzc29yIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyLlwiLFxuICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlci5cIixcbiAgQ29uc3RydWN0b3JDbGFzc0ZpZWxkOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJy5cIixcbiAgQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHByaXZhdGUgZmllbGQgbmFtZWQgJyNjb25zdHJ1Y3RvcicuXCIsXG4gIENvbnN0cnVjdG9ySXNBY2Nlc3NvcjogXCJDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yLlwiLFxuICBDb25zdHJ1Y3RvcklzQXN5bmM6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgZnVuY3Rpb24uXCIsXG4gIENvbnN0cnVjdG9ySXNHZW5lcmF0b3I6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3IuXCIsXG4gIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYE1pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJHtraW5kfSBkZWNsYXJhdGlvbi5gLFxuICBEZWNvcmF0b3JBcmd1bWVudHNPdXRzaWRlUGFyZW50aGVzZXM6IFwiRGVjb3JhdG9yIGFyZ3VtZW50cyBtdXN0IGJlIG1vdmVkIGluc2lkZSBwYXJlbnRoZXNlczogdXNlICdAKGRlY29yYXRvcihhcmdzKSknIGluc3RlYWQgb2YgJ0AoZGVjb3JhdG9yKShhcmdzKScuXCIsXG4gIERlY29yYXRvckJlZm9yZUV4cG9ydDogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICpiZWZvcmUqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBSZW1vdmUgdGhlICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0OiB0cnVlJyBvcHRpb24gdG8gdXNlIHRoZSAnZXhwb3J0IEBkZWNvcmF0b3IgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yc0JlZm9yZUFmdGVyRXhwb3J0OiBcIkRlY29yYXRvcnMgY2FuIGJlIHBsYWNlZCAqZWl0aGVyKiBiZWZvcmUgb3IgYWZ0ZXIgdGhlICdleHBvcnQnIGtleXdvcmQsIGJ1dCBub3QgaW4gYm90aCBsb2NhdGlvbnMgYXQgdGhlIHNhbWUgdGltZS5cIixcbiAgRGVjb3JhdG9yQ29uc3RydWN0b3I6IFwiRGVjb3JhdG9ycyBjYW4ndCBiZSB1c2VkIHdpdGggYSBjb25zdHJ1Y3Rvci4gRGlkIHlvdSBtZWFuICdAZGVjIGNsYXNzIHsgLi4uIH0nP1wiLFxuICBEZWNvcmF0b3JFeHBvcnRDbGFzczogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICphZnRlciogdGhlICdleHBvcnQnIGtleXdvcmQuIFJlbW92ZSB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IGZhbHNlJyBvcHRpb24gdG8gdXNlIHRoZSAnQGRlY29yYXRvciBleHBvcnQgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yU2VtaWNvbG9uOiBcIkRlY29yYXRvcnMgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgYSBzZW1pY29sb24uXCIsXG4gIERlY29yYXRvclN0YXRpY0Jsb2NrOiBcIkRlY29yYXRvcnMgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgc3RhdGljIGJsb2NrLlwiLFxuICBEZWZlckltcG9ydFJlcXVpcmVzTmFtZXNwYWNlOiAnT25seSBgaW1wb3J0IGRlZmVyICogYXMgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgRGVsZXRlUHJpdmF0ZUZpZWxkOiBcIkRlbGV0aW5nIGEgcHJpdmF0ZSBmaWVsZCBpcyBub3QgYWxsb3dlZC5cIixcbiAgRGVzdHJ1Y3R1cmVOYW1lZEltcG9ydDogXCJFUzIwMTUgbmFtZWQgaW1wb3J0cyBkbyBub3QgZGVzdHJ1Y3R1cmUuIFVzZSBhbm90aGVyIHN0YXRlbWVudCBmb3IgZGVzdHJ1Y3R1cmluZyBhZnRlciB0aGUgaW1wb3J0LlwiLFxuICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3MuXCIsXG4gIER1cGxpY2F0ZURlZmF1bHRFeHBvcnQ6IFwiT25seSBvbmUgZGVmYXVsdCBleHBvcnQgYWxsb3dlZCBwZXIgbW9kdWxlLlwiLFxuICBEdXBsaWNhdGVFeHBvcnQ6ICh7XG4gICAgZXhwb3J0TmFtZVxuICB9KSA9PiBgXFxgJHtleHBvcnROYW1lfVxcYCBoYXMgYWxyZWFkeSBiZWVuIGV4cG9ydGVkLiBFeHBvcnRlZCBpZGVudGlmaWVycyBtdXN0IGJlIHVuaXF1ZS5gLFxuICBEdXBsaWNhdGVQcm90bzogXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5LlwiLFxuICBEdXBsaWNhdGVSZWdFeHBGbGFnczogXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWcuXCIsXG4gIER5bmFtaWNJbXBvcnRQaGFzZVJlcXVpcmVzSW1wb3J0RXhwcmVzc2lvbnM6ICh7XG4gICAgcGhhc2VcbiAgfSkgPT4gYCdpbXBvcnQuJHtwaGFzZX0oLi4uKScgY2FuIG9ubHkgYmUgcGFyc2VkIHdoZW4gdXNpbmcgdGhlICdjcmVhdGVJbXBvcnRFeHByZXNzaW9ucycgb3B0aW9uLmAsXG4gIEVsZW1lbnRBZnRlclJlc3Q6IFwiUmVzdCBlbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50LlwiLFxuICBFc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllcjogXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlLlwiLFxuICBFeHBvcnRCaW5kaW5nSXNTdHJpbmc6ICh7XG4gICAgbG9jYWxOYW1lLFxuICAgIGV4cG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IFxcYGZyb21cXGAuXFxuLSBEaWQgeW91IG1lYW4gXFxgZXhwb3J0IHsgJyR7bG9jYWxOYW1lfScgYXMgJyR7ZXhwb3J0TmFtZX0nIH0gZnJvbSAnc29tZS1tb2R1bGUnXFxgP2AsXG4gIEV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyOiBcIidmcm9tJyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpZGVudGlmaWVyIGFmdGVyICdleHBvcnQgZGVmYXVsdCcuXCIsXG4gIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgJyR7dHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCJ9JyBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplci5gLFxuICBGb3JJblVzaW5nOiBcIkZvci1pbiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAndXNpbmcnIGRlY2xhcmF0aW9uLlwiLFxuICBGb3JPZkFzeW5jOiBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3QgYmUgJ2FzeW5jJy5cIixcbiAgRm9yT2ZMZXQ6IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLlwiLFxuICBHZW5lcmF0b3JJblNpbmdsZVN0YXRlbWVudENvbnRleHQ6IFwiR2VuZXJhdG9ycyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0aGUgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBJbGxlZ2FsQnJlYWtDb250aW51ZTogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBVbnN5bnRhY3RpYyAke3R5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIiA/IFwiYnJlYWtcIiA6IFwiY29udGludWVcIn0uYCxcbiAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0LlwiLFxuICBJbGxlZ2FsUmV0dXJuOiBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb24uXCIsXG4gIEltcG9ydEF0dHJpYnV0ZXNVc2VBc3NlcnQ6IFwiVGhlIGBhc3NlcnRgIGtleXdvcmQgaW4gaW1wb3J0IGF0dHJpYnV0ZXMgaXMgZGVwcmVjYXRlZCBhbmQgaXQgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGB3aXRoYCBrZXl3b3JkLiBZb3UgY2FuIGVuYWJsZSB0aGUgYGRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRgIHBhcnNlciBwbHVnaW4gdG8gc3VwcHJlc3MgdGhpcyBlcnJvci5cIixcbiAgSW1wb3J0QmluZGluZ0lzU3RyaW5nOiAoe1xuICAgIGltcG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gaW1wb3J0ZWQgYmluZGluZy5cXG4tIERpZCB5b3UgbWVhbiBcXGBpbXBvcnQgeyBcIiR7aW1wb3J0TmFtZX1cIiBhcyBmb28gfVxcYD9gLFxuICBJbXBvcnRDYWxsQXJpdHk6IGBcXGBpbXBvcnQoKVxcYCByZXF1aXJlcyBleGFjdGx5IG9uZSBvciB0d28gYXJndW1lbnRzLmAsXG4gIEltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uOiBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLikuXCIsXG4gIEltcG9ydENhbGxTcHJlYWRBcmd1bWVudDogXCJgLi4uYCBpcyBub3QgYWxsb3dlZCBpbiBgaW1wb3J0KClgLlwiLFxuICBJbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQ6IFwiQSBKU09OIG1vZHVsZSBjYW4gb25seSBiZSBpbXBvcnRlZCB3aXRoIGBkZWZhdWx0YC5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0Fzc2VydGlvbjogXCJgaW1wb3J0IG1vZHVsZSB4YCBjYW5ub3QgaGF2ZSBhc3NlcnRpb25zLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uTm90QmluZGluZzogJ09ubHkgYGltcG9ydCBtb2R1bGUgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgSW5jb21wYXRpYmxlUmVnRXhwVVZGbGFnczogXCJUaGUgJ3UnIGFuZCAndicgcmVndWxhciBleHByZXNzaW9uIGZsYWdzIGNhbm5vdCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUuXCIsXG4gIEludmFsaWRCaWdJbnRMaXRlcmFsOiBcIkludmFsaWQgQmlnSW50TGl0ZXJhbC5cIixcbiAgSW52YWxpZENvZGVQb2ludDogXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHMuXCIsXG4gIEludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZTogXCJJbnZhbGlkIHNob3J0aGFuZCBwcm9wZXJ0eSBpbml0aWFsaXplci5cIixcbiAgSW52YWxpZERlY2ltYWw6IFwiSW52YWxpZCBkZWNpbWFsLlwiLFxuICBJbnZhbGlkRGlnaXQ6ICh7XG4gICAgcmFkaXhcbiAgfSkgPT4gYEV4cGVjdGVkIG51bWJlciBpbiByYWRpeCAke3JhZGl4fS5gLFxuICBJbnZhbGlkRXNjYXBlU2VxdWVuY2U6IFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2UuXCIsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZVRlbXBsYXRlOiBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlLlwiLFxuICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogKHtcbiAgICByZXNlcnZlZFdvcmRcbiAgfSkgPT4gYEVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkICR7cmVzZXJ2ZWRXb3JkfS5gLFxuICBJbnZhbGlkSWRlbnRpZmllcjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgSW52YWxpZCBpZGVudGlmaWVyICR7aWRlbnRpZmllck5hbWV9LmAsXG4gIEludmFsaWRMaHM6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNCaW5kaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBCaW5kaW5nIGludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNPcHRpb25hbENoYWluaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBJbnZhbGlkIG9wdGlvbmFsIGNoYWluaW5nIGluIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZE51bWJlcjogXCJJbnZhbGlkIG51bWJlci5cIixcbiAgSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50OiBcIkZsb2F0aW5nLXBvaW50IG51bWJlcnMgcmVxdWlyZSBhIHZhbGlkIGV4cG9uZW50IGFmdGVyIHRoZSAnZScuXCIsXG4gIEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIGNoYXJhY3RlciAnJHt1bmV4cGVjdGVkfScuYCxcbiAgSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50OiBcIkludmFsaWQgcGFyZW50aGVzaXplZCBhc3NpZ25tZW50IHBhdHRlcm4uXCIsXG4gIEludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBQcml2YXRlIG5hbWUgIyR7aWRlbnRpZmllck5hbWV9IGlzIG5vdCBkZWZpbmVkLmAsXG4gIEludmFsaWRQcm9wZXJ0eUJpbmRpbmdQYXR0ZXJuOiBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24uXCIsXG4gIEludmFsaWRSZWNvcmRQcm9wZXJ0eTogXCJPbmx5IHByb3BlcnRpZXMgYW5kIHNwcmVhZCBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiByZWNvcmQgZGVmaW5pdGlvbnMuXCIsXG4gIEludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm46IFwiSW52YWxpZCByZXN0IG9wZXJhdG9yJ3MgYXJndW1lbnQuXCIsXG4gIExhYmVsUmVkZWNsYXJhdGlvbjogKHtcbiAgICBsYWJlbE5hbWVcbiAgfSkgPT4gYExhYmVsICcke2xhYmVsTmFtZX0nIGlzIGFscmVhZHkgZGVjbGFyZWQuYCxcbiAgTGV0SW5MZXhpY2FsQmluZGluZzogXCInbGV0JyBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUuXCIsXG4gIExpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3c6IFwiTm8gbGluZSBicmVhayBpcyBhbGxvd2VkIGJlZm9yZSAnPT4nLlwiLFxuICBNYWxmb3JtZWRSZWdFeHBGbGFnczogXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnLlwiLFxuICBNaXNzaW5nQ2xhc3NOYW1lOiBcIkEgY2xhc3MgbmFtZSBpcyByZXF1aXJlZC5cIixcbiAgTWlzc2luZ0VxSW5Bc3NpZ25tZW50OiBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIsXG4gIE1pc3NpbmdTZW1pY29sb246IFwiTWlzc2luZyBzZW1pY29sb24uXCIsXG4gIE1pc3NpbmdQbHVnaW46ICh7XG4gICAgbWlzc2luZ1BsdWdpblxuICB9KSA9PiBgVGhpcyBleHBlcmltZW50YWwgc3ludGF4IHJlcXVpcmVzIGVuYWJsaW5nIHRoZSBwYXJzZXIgcGx1Z2luOiAke21pc3NpbmdQbHVnaW4ubWFwKG5hbWUgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpLmpvaW4oXCIsIFwiKX0uYCxcbiAgTWlzc2luZ09uZU9mUGx1Z2luczogKHtcbiAgICBtaXNzaW5nUGx1Z2luXG4gIH0pID0+IGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFyc2VyIHBsdWdpbihzKTogJHttaXNzaW5nUGx1Z2luLm1hcChuYW1lID0+IEpTT04uc3RyaW5naWZ5KG5hbWUpKS5qb2luKFwiLCBcIil9LmAsXG4gIE1pc3NpbmdVbmljb2RlRXNjYXBlOiBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFguXCIsXG4gIE1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWw6IFwiTnVsbGlzaCBjb2FsZXNjaW5nIG9wZXJhdG9yKD8/KSByZXF1aXJlcyBwYXJlbnMgd2hlbiBtaXhpbmcgd2l0aCBsb2dpY2FsIG9wZXJhdG9ycy5cIixcbiAgTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGU6IFwiVGhlIG9ubHkgYWNjZXB0ZWQgbW9kdWxlIGF0dHJpYnV0ZSBpcyBgdHlwZWAuXCIsXG4gIE1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZTogXCJPbmx5IHN0cmluZyBsaXRlcmFscyBhcmUgYWxsb3dlZCBhcyBtb2R1bGUgYXR0cmlidXRlIHZhbHVlcy5cIixcbiAgTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzOiAoe1xuICAgIGtleVxuICB9KSA9PiBgRHVwbGljYXRlIGtleSBcIiR7a2V5fVwiIGlzIG5vdCBhbGxvd2VkIGluIG1vZHVsZSBhdHRyaWJ1dGVzLmAsXG4gIE1vZHVsZUV4cG9ydE5hbWVIYXNMb25lU3Vycm9nYXRlOiAoe1xuICAgIHN1cnJvZ2F0ZUNoYXJDb2RlXG4gIH0pID0+IGBBbiBleHBvcnQgbmFtZSBjYW5ub3QgaW5jbHVkZSBhIGxvbmUgc3Vycm9nYXRlLCBmb3VuZCAnXFxcXHUke3N1cnJvZ2F0ZUNoYXJDb2RlLnRvU3RyaW5nKDE2KX0nLmAsXG4gIE1vZHVsZUV4cG9ydFVuZGVmaW5lZDogKHtcbiAgICBsb2NhbE5hbWVcbiAgfSkgPT4gYEV4cG9ydCAnJHtsb2NhbE5hbWV9JyBpcyBub3QgZGVmaW5lZC5gLFxuICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6IFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzLlwiLFxuICBOZXdsaW5lQWZ0ZXJUaHJvdzogXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cuXCIsXG4gIE5vQ2F0Y2hPckZpbmFsbHk6IFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZS5cIixcbiAgTnVtYmVySWRlbnRpZmllcjogXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlci5cIixcbiAgTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6IFwiTnVtZXJpYyBzZXBhcmF0b3JzIGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzIG9yIGhleCBlc2NhcGUgc2VxdWVuY2VzLlwiLFxuICBPYnNvbGV0ZUF3YWl0U3RhcjogXCInYXdhaXQqJyBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vTmV3OiBcIkNvbnN0cnVjdG9ycyBpbi9hZnRlciBhbiBPcHRpb25hbCBDaGFpbiBhcmUgbm90IGFsbG93ZWQuXCIsXG4gIE9wdGlvbmFsQ2hhaW5pbmdOb1RlbXBsYXRlOiBcIlRhZ2dlZCBUZW1wbGF0ZSBMaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gb3B0aW9uYWxDaGFpbi5cIixcbiAgT3ZlcnJpZGVPbkNvbnN0cnVjdG9yOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIGNvbnN0cnVjdG9yIGRlY2xhcmF0aW9uLlwiLFxuICBQYXJhbUR1cGU6IFwiQXJndW1lbnQgbmFtZSBjbGFzaC5cIixcbiAgUGF0dGVybkhhc0FjY2Vzc29yOiBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlci5cIixcbiAgUGF0dGVybkhhc01ldGhvZDogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHMuXCIsXG4gIFByaXZhdGVJbkV4cGVjdGVkSW46ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYFByaXZhdGUgbmFtZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBwcm9wZXJ0eSBhY2Nlc3NlcyAoXFxgb2JqLiMke2lkZW50aWZpZXJOYW1lfVxcYCkgb3IgaW4gXFxgaW5cXGAgZXhwcmVzc2lvbnMgKFxcYCMke2lkZW50aWZpZXJOYW1lfSBpbiBvYmpcXGApLmAsXG4gIFByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgRHVwbGljYXRlIHByaXZhdGUgbmFtZSAjJHtpZGVudGlmaWVyTmFtZX0uYCxcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8fScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJ3t8JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgUmVjb3JkRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJyN7JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnaGFzaCcuXCIsXG4gIFJlY29yZE5vUHJvdG86IFwiJ19fcHJvdG9fXycgaXMgbm90IGFsbG93ZWQgaW4gUmVjb3JkIGV4cHJlc3Npb25zLlwiLFxuICBSZXN0VHJhaWxpbmdDb21tYTogXCJVbmV4cGVjdGVkIHRyYWlsaW5nIGNvbW1hIGFmdGVyIHJlc3QgZWxlbWVudC5cIixcbiAgU2xvcHB5RnVuY3Rpb246IFwiSW4gbm9uLXN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFNsb3BweUZ1bmN0aW9uQW5uZXhCOiBcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlwiLFxuICBTb3VyY2VQaGFzZUltcG9ydFJlcXVpcmVzRGVmYXVsdDogJ09ubHkgYGltcG9ydCBzb3VyY2UgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgU3RhdGljUHJvdG90eXBlOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUuXCIsXG4gIFN1cGVyTm90QWxsb3dlZDogXCJgc3VwZXIoKWAgaXMgb25seSB2YWxpZCBpbnNpZGUgYSBjbGFzcyBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzLiBNYXliZSBhIHR5cG8gaW4gdGhlIG1ldGhvZCBuYW1lICgnY29uc3RydWN0b3InKSBvciBub3QgZXh0ZW5kaW5nIGFub3RoZXIgY2xhc3M/XCIsXG4gIFN1cGVyUHJpdmF0ZUZpZWxkOiBcIlByaXZhdGUgZmllbGRzIGNhbid0IGJlIGFjY2Vzc2VkIG9uIHN1cGVyLlwiLFxuICBUcmFpbGluZ0RlY29yYXRvcjogXCJEZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBlbGVtZW50LlwiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8XScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICdbfCcgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI1snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXI6IFwiVW5leHBlY3RlZCBhcmd1bWVudCBwbGFjZWhvbGRlci5cIixcbiAgVW5leHBlY3RlZEF3YWl0QWZ0ZXJQaXBlbGluZUJvZHk6ICdVbmV4cGVjdGVkIFwiYXdhaXRcIiBhZnRlciBwaXBlbGluZSBib2R5OyBhd2FpdCBtdXN0IGhhdmUgcGFyZW50aGVzZXMgaW4gbWluaW1hbCBwcm9wb3NhbC4nLFxuICBVbmV4cGVjdGVkRGlnaXRBZnRlckhhc2g6IFwiVW5leHBlY3RlZCBkaWdpdCBhZnRlciBoYXNoIHRva2VuLlwiLFxuICBVbmV4cGVjdGVkSW1wb3J0RXhwb3J0OiBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbC5cIixcbiAgVW5leHBlY3RlZEtleXdvcmQ6ICh7XG4gICAga2V5d29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCBrZXl3b3JkICcke2tleXdvcmR9Jy5gLFxuICBVbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcjogXCJMZWFkaW5nIGRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uOiBcIkxleGljYWwgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiBhIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dC5cIixcbiAgVW5leHBlY3RlZE5ld1RhcmdldDogXCJgbmV3LnRhcmdldGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgb3IgY2xhc3MgcHJvcGVydGllcy5cIixcbiAgVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IFwiQSBudW1lcmljIHNlcGFyYXRvciBpcyBvbmx5IGFsbG93ZWQgYmV0d2VlbiB0d28gZGlnaXRzLlwiLFxuICBVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOiBcIlVuZXhwZWN0ZWQgcHJpdmF0ZSBuYW1lLlwiLFxuICBVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICcke3Jlc2VydmVkV29yZH0nLmAsXG4gIFVuZXhwZWN0ZWRTdXBlcjogXCInc3VwZXInIGlzIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbWV0aG9kcyBhbmQgY2xhc3Nlcy5cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIGV4cGVjdGVkLFxuICAgIHVuZXhwZWN0ZWRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4ke3VuZXhwZWN0ZWQgPyBgICcke3VuZXhwZWN0ZWR9Jy5gIDogXCJcIn0ke2V4cGVjdGVkID8gYCwgZXhwZWN0ZWQgXCIke2V4cGVjdGVkfVwiYCA6IFwiXCJ9YCxcbiAgVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbjogXCJJbGxlZ2FsIGV4cHJlc3Npb24uIFdyYXAgbGVmdCBoYW5kIHNpZGUgb3IgZW50aXJlIGV4cG9uZW50aWF0aW9uIGluIHBhcmVudGhlc2VzLlwiLFxuICBVbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbjogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgYXBwZWFyIGluIHRoZSB0b3AgbGV2ZWwgd2hlbiBzb3VyY2UgdHlwZSBpcyBgc2NyaXB0YC5cIixcbiAgVW5zdXBwb3J0ZWRCaW5kOiBcIkJpbmRpbmcgc2hvdWxkIGJlIHBlcmZvcm1lZCBvbiBvYmplY3QgcHJvcGVydHkuXCIsXG4gIFVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0OiBcIkEgZGVjb3JhdGVkIGV4cG9ydCBtdXN0IGV4cG9ydCBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbnN1cHBvcnRlZERlZmF1bHRFeHBvcnQ6IFwiT25seSBleHByZXNzaW9ucywgZnVuY3Rpb25zIG9yIGNsYXNzZXMgYXJlIGFsbG93ZWQgYXMgdGhlIGBkZWZhdWx0YCBleHBvcnQuXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0OiBcImBpbXBvcnRgIGNhbiBvbmx5IGJlIHVzZWQgaW4gYGltcG9ydCgpYCBvciBgaW1wb3J0Lm1ldGFgLlwiLFxuICBVbnN1cHBvcnRlZE1ldGFQcm9wZXJ0eTogKHtcbiAgICB0YXJnZXQsXG4gICAgb25seVZhbGlkUHJvcGVydHlOYW1lXG4gIH0pID0+IGBUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciAke3RhcmdldH0gaXMgJHt0YXJnZXR9LiR7b25seVZhbGlkUHJvcGVydHlOYW1lfS5gLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlckRlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIHBhcmFtZXRlcnMuXCIsXG4gIFVuc3VwcG9ydGVkUHJvcGVydHlEZWNvcmF0b3I6IFwiRGVjb3JhdG9ycyBjYW5ub3QgYmUgdXNlZCB0byBkZWNvcmF0ZSBvYmplY3QgbGl0ZXJhbCBwcm9wZXJ0aWVzLlwiLFxuICBVbnN1cHBvcnRlZFN1cGVyOiBcIidzdXBlcicgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGZ1bmN0aW9uIGNhbGxzIChpLmUuIHN1cGVyKCkpIG9yIGluIHByb3BlcnR5IGFjY2Vzc2VzIChpLmUuIHN1cGVyLnByb3Agb3Igc3VwZXJbcHJvcF0pLlwiLFxuICBVbnRlcm1pbmF0ZWRDb21tZW50OiBcIlVudGVybWluYXRlZCBjb21tZW50LlwiLFxuICBVbnRlcm1pbmF0ZWRSZWdFeHA6IFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cIixcbiAgVW50ZXJtaW5hdGVkU3RyaW5nOiBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnQuXCIsXG4gIFVudGVybWluYXRlZFRlbXBsYXRlOiBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZS5cIixcbiAgVXNpbmdEZWNsYXJhdGlvbkV4cG9ydDogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgYmUgZXhwb3J0ZWQuXCIsXG4gIFVzaW5nRGVjbGFyYXRpb25IYXNCaW5kaW5nUGF0dGVybjogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgaGF2ZSBkZXN0cnVjdHVyaW5nIHBhdHRlcm5zLlwiLFxuICBWYXJSZWRlY2xhcmF0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBJZGVudGlmaWVyICcke2lkZW50aWZpZXJOYW1lfScgaGFzIGFscmVhZHkgYmVlbiBkZWNsYXJlZC5gLFxuICBZaWVsZEJpbmRpbmdJZGVudGlmaWVyOiBcIkNhbiBub3QgdXNlICd5aWVsZCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYSBnZW5lcmF0b3IuXCIsXG4gIFlpZWxkSW5QYXJhbWV0ZXI6IFwiWWllbGQgZXhwcmVzc2lvbiBpcyBub3QgYWxsb3dlZCBpbiBmb3JtYWwgcGFyYW1ldGVycy5cIixcbiAgWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvcjogXCJOdW1lcmljIHNlcGFyYXRvciBjYW4gbm90IGJlIHVzZWQgYWZ0ZXIgbGVhZGluZyAwLlwiXG59O1xudmFyIFN0cmljdE1vZGVFcnJvcnMgPSB7XG4gIFN0cmljdERlbGV0ZTogXCJEZWxldGluZyBsb2NhbCB2YXJpYWJsZSBpbiBzdHJpY3QgbW9kZS5cIixcbiAgU3RyaWN0RXZhbEFyZ3VtZW50czogKHtcbiAgICByZWZlcmVuY2VOYW1lXG4gIH0pID0+IGBBc3NpZ25pbmcgdG8gJyR7cmVmZXJlbmNlTmFtZX0nIGluIHN0cmljdCBtb2RlLmAsXG4gIFN0cmljdEV2YWxBcmd1bWVudHNCaW5kaW5nOiAoe1xuICAgIGJpbmRpbmdOYW1lXG4gIH0pID0+IGBCaW5kaW5nICcke2JpbmRpbmdOYW1lfScgaW4gc3RyaWN0IG1vZGUuYCxcbiAgU3RyaWN0RnVuY3Rpb246IFwiSW4gc3RyaWN0IG1vZGUgY29kZSwgZnVuY3Rpb25zIGNhbiBvbmx5IGJlIGRlY2xhcmVkIGF0IHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgU3RyaWN0TnVtZXJpY0VzY2FwZTogXCJUaGUgb25seSB2YWxpZCBudW1lcmljIGVzY2FwZSBpbiBzdHJpY3QgbW9kZSBpcyAnXFxcXDAnLlwiLFxuICBTdHJpY3RPY3RhbExpdGVyYWw6IFwiTGVnYWN5IG9jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS5cIixcbiAgU3RyaWN0V2l0aDogXCInd2l0aCcgaW4gc3RyaWN0IG1vZGUuXCJcbn07XG5jb25zdCBVbnBhcmVudGhlc2l6ZWRQaXBlQm9keURlc2NyaXB0aW9ucyA9IG5ldyBTZXQoW1wiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBcIllpZWxkRXhwcmVzc2lvblwiXSk7XG52YXIgUGlwZWxpbmVPcGVyYXRvckVycm9ycyA9IHtcbiAgUGlwZUJvZHlJc1RpZ2h0ZXI6IFwiVW5leHBlY3RlZCB5aWVsZCBhZnRlciBwaXBlbGluZSBib2R5OyBhbnkgeWllbGQgZXhwcmVzc2lvbiBhY3RpbmcgYXMgSGFjay1zdHlsZSBwaXBlIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkIGR1ZSB0byBpdHMgbG9vc2Ugb3BlcmF0b3IgcHJlY2VkZW5jZS5cIixcbiAgUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXM6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nLFxuICBQaXBlVG9waWNVbmJvdW5kOiBcIlRvcGljIHJlZmVyZW5jZSBpcyB1bmJvdW5kOyBpdCBtdXN0IGJlIGluc2lkZSBhIHBpcGUgYm9keS5cIixcbiAgUGlwZVRvcGljVW5jb25maWd1cmVkVG9rZW46ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYEludmFsaWQgdG9waWMgdG9rZW4gJHt0b2tlbn0uIEluIG9yZGVyIHRvIHVzZSAke3Rva2VufSBhcyBhIHRvcGljIHJlZmVyZW5jZSwgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIG11c3QgYmUgY29uZmlndXJlZCB3aXRoIHsgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiwgXCJ0b3BpY1Rva2VuXCI6IFwiJHt0b2tlbn1cIiB9LmAsXG4gIFBpcGVUb3BpY1VudXNlZDogXCJIYWNrLXN0eWxlIHBpcGUgYm9keSBkb2VzIG5vdCBjb250YWluIGEgdG9waWMgcmVmZXJlbmNlOyBIYWNrLXN0eWxlIHBpcGVzIG11c3QgdXNlIHRvcGljIGF0IGxlYXN0IG9uY2UuXCIsXG4gIFBpcGVVbnBhcmVudGhlc2l6ZWRCb2R5OiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYEhhY2stc3R5bGUgcGlwZSBib2R5IGNhbm5vdCBiZSBhbiB1bnBhcmVudGhlc2l6ZWQgJHt0b05vZGVEZXNjcmlwdGlvbih7XG4gICAgdHlwZVxuICB9KX07IHBsZWFzZSB3cmFwIGl0IGluIHBhcmVudGhlc2VzLmAsXG4gIFBpcGVsaW5lQm9keU5vQXJyb3c6ICdVbmV4cGVjdGVkIGFycm93IFwiPT5cIiBhZnRlciBwaXBlbGluZSBib2R5OyBhcnJvdyBmdW5jdGlvbiBpbiBwaXBlbGluZSBib2R5IG11c3QgYmUgcGFyZW50aGVzaXplZC4nLFxuICBQaXBlbGluZUJvZHlTZXF1ZW5jZUV4cHJlc3Npb246IFwiUGlwZWxpbmUgYm9keSBtYXkgbm90IGJlIGEgY29tbWEtc2VwYXJhdGVkIHNlcXVlbmNlIGV4cHJlc3Npb24uXCIsXG4gIFBpcGVsaW5lSGVhZFNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBoZWFkIHNob3VsZCBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvbi5cIixcbiAgUGlwZWxpbmVUb3BpY1VudXNlZDogXCJQaXBlbGluZSBpcyBpbiB0b3BpYyBzdHlsZSBidXQgZG9lcyBub3QgdXNlIHRvcGljIHJlZmVyZW5jZS5cIixcbiAgUHJpbWFyeVRvcGljTm90QWxsb3dlZDogXCJUb3BpYyByZWZlcmVuY2Ugd2FzIHVzZWQgaW4gYSBsZXhpY2FsIGNvbnRleHQgd2l0aG91dCB0b3BpYyBiaW5kaW5nLlwiLFxuICBQcmltYXJ5VG9waWNSZXF1aXJlc1NtYXJ0UGlwZWxpbmU6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nXG59O1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wibWVzc2FnZVwiXTtcbmZ1bmN0aW9uIGRlZmluZUhpZGRlbihvYmosIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9QYXJzZUVycm9yQ29uc3RydWN0b3Ioe1xuICB0b01lc3NhZ2UsXG4gIGNvZGUsXG4gIHJlYXNvbkNvZGUsXG4gIHN5bnRheFBsdWdpblxufSkge1xuICBjb25zdCBoYXNNaXNzaW5nUGx1Z2luID0gcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nUGx1Z2luXCIgfHwgcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nT25lT2ZQbHVnaW5zXCI7XG4gIHtcbiAgICBjb25zdCBvbGRSZWFzb25Db2RlcyA9IHtcbiAgICAgIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyXCIsXG4gICAgICBBY2Nlc3NvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVyczogXCJBY2Nlc29yQ2Fubm90SGF2ZVR5cGVQYXJhbWV0ZXJzXCIsXG4gICAgICBDb25zdEluaXRpYWxpemVyTXVzdEJlU3RyaW5nT3JOdW1lcmljTGl0ZXJhbE9yTGl0ZXJhbEVudW1SZWZlcmVuY2U6IFwiQ29uc3RJbml0aWFpbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZVwiLFxuICAgICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVPcHRpb25hbFBhcmFtZXRlclwiLFxuICAgICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmVzdFBhcmFtZXRlcjogXCJTZXRBY2Nlc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXJcIixcbiAgICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVSZXR1cm5UeXBlXCJcbiAgICB9O1xuICAgIGlmIChvbGRSZWFzb25Db2Rlc1tyZWFzb25Db2RlXSkge1xuICAgICAgcmVhc29uQ29kZSA9IG9sZFJlYXNvbkNvZGVzW3JlYXNvbkNvZGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0b3IobG9jLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3ludGF4RXJyb3IoKTtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgICBlcnJvci5yZWFzb25Db2RlID0gcmVhc29uQ29kZTtcbiAgICBlcnJvci5sb2MgPSBsb2M7XG4gICAgZXJyb3IucG9zID0gbG9jLmluZGV4O1xuICAgIGVycm9yLnN5bnRheFBsdWdpbiA9IHN5bnRheFBsdWdpbjtcbiAgICBpZiAoaGFzTWlzc2luZ1BsdWdpbikge1xuICAgICAgZXJyb3IubWlzc2luZ1BsdWdpbiA9IGRldGFpbHMubWlzc2luZ1BsdWdpbjtcbiAgICB9XG4gICAgZGVmaW5lSGlkZGVuKGVycm9yLCBcImNsb25lXCIsIGZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICB2YXIgX292ZXJyaWRlcyRsb2M7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxpbmUsXG4gICAgICAgIGNvbHVtbixcbiAgICAgICAgaW5kZXhcbiAgICAgIH0gPSAoX292ZXJyaWRlcyRsb2MgPSBvdmVycmlkZXMubG9jKSAhPSBudWxsID8gX292ZXJyaWRlcyRsb2MgOiBsb2M7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IobmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbiwgaW5kZXgpLCBPYmplY3QuYXNzaWduKHt9LCBkZXRhaWxzLCBvdmVycmlkZXMuZGV0YWlscykpO1xuICAgIH0pO1xuICAgIGRlZmluZUhpZGRlbihlcnJvciwgXCJkZXRhaWxzXCIsIGRldGFpbHMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJtZXNzYWdlXCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke3RvTWVzc2FnZShkZXRhaWxzKX0gKCR7bG9jLmxpbmV9OiR7bG9jLmNvbHVtbn0pYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9LFxuICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfTtcbn1cbmZ1bmN0aW9uIFBhcnNlRXJyb3JFbnVtKGFyZ3VtZW50LCBzeW50YXhQbHVnaW4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnQpKSB7XG4gICAgcmV0dXJuIHBhcnNlRXJyb3JUZW1wbGF0ZXMgPT4gUGFyc2VFcnJvckVudW0ocGFyc2VFcnJvclRlbXBsYXRlcywgYXJndW1lbnRbMF0pO1xuICB9XG4gIGNvbnN0IFBhcnNlRXJyb3JDb25zdHJ1Y3RvcnMgPSB7fTtcbiAgZm9yIChjb25zdCByZWFzb25Db2RlIG9mIE9iamVjdC5rZXlzKGFyZ3VtZW50KSkge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gYXJndW1lbnRbcmVhc29uQ29kZV07XG4gICAgY29uc3QgX3JlZiA9IHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIiA/IHtcbiAgICAgICAgbWVzc2FnZTogKCkgPT4gdGVtcGxhdGVcbiAgICAgIH0gOiB0eXBlb2YgdGVtcGxhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgICAgbWVzc2FnZTogdGVtcGxhdGVcbiAgICAgIH0gOiB0ZW1wbGF0ZSxcbiAgICAgIHtcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSA9IF9yZWYsXG4gICAgICByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgICBjb25zdCB0b01lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/ICgpID0+IG1lc3NhZ2UgOiBtZXNzYWdlO1xuICAgIFBhcnNlRXJyb3JDb25zdHJ1Y3RvcnNbcmVhc29uQ29kZV0gPSB0b1BhcnNlRXJyb3JDb25zdHJ1Y3RvcihPYmplY3QuYXNzaWduKHtcbiAgICAgIGNvZGU6IFwiQkFCRUxfUEFSU0VSX1NZTlRBWF9FUlJPUlwiLFxuICAgICAgcmVhc29uQ29kZSxcbiAgICAgIHRvTWVzc2FnZVxuICAgIH0sIHN5bnRheFBsdWdpbiA/IHtcbiAgICAgIHN5bnRheFBsdWdpblxuICAgIH0gOiB7fSwgcmVzdCkpO1xuICB9XG4gIHJldHVybiBQYXJzZUVycm9yQ29uc3RydWN0b3JzO1xufVxuY29uc3QgRXJyb3JzID0gT2JqZWN0LmFzc2lnbih7fSwgUGFyc2VFcnJvckVudW0oTW9kdWxlRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RhbmRhcmRFcnJvcnMpLCBQYXJzZUVycm9yRW51bShTdHJpY3RNb2RlRXJyb3JzKSwgUGFyc2VFcnJvckVudW1gcGlwZWxpbmVPcGVyYXRvcmAoUGlwZWxpbmVPcGVyYXRvckVycm9ycykpO1xuY29uc3Qge1xuICBkZWZpbmVQcm9wZXJ0eVxufSA9IE9iamVjdDtcbmNvbnN0IHRvVW5lbnVtZXJhYmxlID0gKG9iamVjdCwga2V5KSA9PiB7XG4gIGlmIChvYmplY3QpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogb2JqZWN0W2tleV1cbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHRvRVNUcmVlTG9jYXRpb24obm9kZSkge1xuICB0b1VuZW51bWVyYWJsZShub2RlLmxvYy5zdGFydCwgXCJpbmRleFwiKTtcbiAgdG9VbmVudW1lcmFibGUobm9kZS5sb2MuZW5kLCBcImluZGV4XCIpO1xuICByZXR1cm4gbm9kZTtcbn1cbnZhciBlc3RyZWUgPSBzdXBlckNsYXNzID0+IGNsYXNzIEVTVHJlZVBhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlKCkge1xuICAgIGNvbnN0IGZpbGUgPSB0b0VTVHJlZUxvY2F0aW9uKHN1cGVyLnBhcnNlKCkpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB7XG4gICAgICBmaWxlLnRva2VucyA9IGZpbGUudG9rZW5zLm1hcCh0b0VTVHJlZUxvY2F0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbiAgcGFyc2VSZWdFeHBMaXRlcmFsKHtcbiAgICBwYXR0ZXJuLFxuICAgIGZsYWdzXG4gIH0pIHtcbiAgICBsZXQgcmVnZXggPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICByZWdleCA9IG5ldyBSZWdFeHAocGF0dGVybiwgZmxhZ3MpO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKHJlZ2V4KTtcbiAgICBub2RlLnJlZ2V4ID0ge1xuICAgICAgcGF0dGVybixcbiAgICAgIGZsYWdzXG4gICAgfTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUJpZ0ludExpdGVyYWwodmFsdWUpIHtcbiAgICBsZXQgYmlnSW50O1xuICAgIHRyeSB7XG4gICAgICBiaWdJbnQgPSBCaWdJbnQodmFsdWUpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIGJpZ0ludCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChiaWdJbnQpO1xuICAgIG5vZGUuYmlnaW50ID0gU3RyaW5nKG5vZGUudmFsdWUgfHwgdmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gbnVsbDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwoZGVjaW1hbCk7XG4gICAgbm9kZS5kZWNpbWFsID0gU3RyaW5nKG5vZGUudmFsdWUgfHwgdmFsdWUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cbiAgcGFyc2VOdW1lcmljTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwobnVsbCk7XG4gIH1cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbCh2YWx1ZSk7XG4gIH1cbiAgZGlyZWN0aXZlVG9TdG10KGRpcmVjdGl2ZSkge1xuICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkaXJlY3RpdmUudmFsdWU7XG4gICAgZGVsZXRlIGRpcmVjdGl2ZS52YWx1ZTtcbiAgICBleHByZXNzaW9uLnR5cGUgPSBcIkxpdGVyYWxcIjtcbiAgICBleHByZXNzaW9uLnJhdyA9IGV4cHJlc3Npb24uZXh0cmEucmF3O1xuICAgIGV4cHJlc3Npb24udmFsdWUgPSBleHByZXNzaW9uLmV4dHJhLmV4cHJlc3Npb25WYWx1ZTtcbiAgICBjb25zdCBzdG10ID0gZGlyZWN0aXZlO1xuICAgIHN0bXQudHlwZSA9IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiO1xuICAgIHN0bXQuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgc3RtdC5kaXJlY3RpdmUgPSBleHByZXNzaW9uLmV4dHJhLnJhd1ZhbHVlO1xuICAgIGRlbGV0ZSBleHByZXNzaW9uLmV4dHJhO1xuICAgIHJldHVybiBzdG10O1xuICB9XG4gIGluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gICAgc3VwZXIuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICB9XG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLmNoZWNrRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICB9XG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC52YWx1ZS5wYXJhbXM7XG4gIH1cbiAgaXNWYWxpZERpcmVjdGl2ZShzdG10KSB7XG4gICAgdmFyIF9zdG10JGV4cHJlc3Npb24kZXh0cjtcbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJMaXRlcmFsXCIgJiYgdHlwZW9mIHN0bXQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhKChfc3RtdCRleHByZXNzaW9uJGV4dHIgPSBzdG10LmV4cHJlc3Npb24uZXh0cmEpICE9IG51bGwgJiYgX3N0bXQkZXhwcmVzc2lvbiRleHRyLnBhcmVudGhlc2l6ZWQpO1xuICB9XG4gIHBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgc3VwZXIucGFyc2VCbG9ja0JvZHkobm9kZSwgYWxsb3dEaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZVN0YXRlbWVudHMgPSBub2RlLmRpcmVjdGl2ZXMubWFwKGQgPT4gdGhpcy5kaXJlY3RpdmVUb1N0bXQoZCkpO1xuICAgIG5vZGUuYm9keSA9IGRpcmVjdGl2ZVN0YXRlbWVudHMuY29uY2F0KG5vZGUuYm9keSk7XG4gICAgZGVsZXRlIG5vZGUuZGlyZWN0aXZlcztcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIHRoaXMucGFyc2VNZXRob2QobWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIsIFwiQ2xhc3NNZXRob2RcIiwgdHJ1ZSk7XG4gICAgaWYgKG1ldGhvZC50eXBlUGFyYW1ldGVycykge1xuICAgICAgbWV0aG9kLnZhbHVlLnR5cGVQYXJhbWV0ZXJzID0gbWV0aG9kLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgZGVsZXRlIG1ldGhvZC50eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChtZXRob2QpO1xuICB9XG4gIHBhcnNlUHJpdmF0ZU5hbWUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuICBjb252ZXJ0UHJpdmF0ZU5hbWVUb1ByaXZhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBuYW1lID0gc3VwZXIuZ2V0UHJpdmF0ZU5hbWVTVihub2RlKTtcbiAgICBub2RlID0gbm9kZTtcbiAgICBkZWxldGUgbm9kZS5pZDtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUudHlwZSA9IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNQcml2YXRlTmFtZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcml2YXRlSWRlbnRpZmllclwiO1xuICB9XG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRQcml2YXRlTmFtZVNWKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG4gIHBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUxpdGVyYWwodmFsdWUsIHR5cGUpO1xuICAgIG5vZGUucmF3ID0gbm9kZS5leHRyYS5yYXc7XG4gICAgZGVsZXRlIG5vZGUuZXh0cmE7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCk7XG4gICAgbm9kZS5leHByZXNzaW9uID0gbm9kZS5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIjtcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlID0gZmFsc2UpIHtcbiAgICBsZXQgZnVuY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGZ1bmNOb2RlLmtpbmQgPSBub2RlLmtpbmQ7XG4gICAgZnVuY05vZGUgPSBzdXBlci5wYXJzZU1ldGhvZChmdW5jTm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgZnVuY05vZGUudHlwZSA9IFwiRnVuY3Rpb25FeHByZXNzaW9uXCI7XG4gICAgZGVsZXRlIGZ1bmNOb2RlLmtpbmQ7XG4gICAgbm9kZS52YWx1ZSA9IGZ1bmNOb2RlO1xuICAgIGlmICh0eXBlID09PSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiKSB7XG4gICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRob2REZWZpbml0aW9uXCIpO1xuICB9XG4gIG5hbWVJc0NvbnN0cnVjdG9yKGtleSkge1xuICAgIGlmIChrZXkudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHJldHVybiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgICByZXR1cm4gc3VwZXIubmFtZUlzQ29uc3RydWN0b3Ioa2V5KTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKTtcbiAgICB7XG4gICAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wZXJ0eU5vZGUudHlwZSA9IFwiUHJvcGVydHlEZWZpbml0aW9uXCI7XG4gICAgcmV0dXJuIHByb3BlcnR5Tm9kZTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpIHtcbiAgICBjb25zdCBwcm9wZXJ0eU5vZGUgPSBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KC4uLmFyZ3MpO1xuICAgIHtcbiAgICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHByb3BlcnR5Tm9kZS50eXBlID0gXCJQcm9wZXJ0eURlZmluaXRpb25cIjtcbiAgICBwcm9wZXJ0eU5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VPYmplY3RNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3Nvcik7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGUudHlwZSA9IFwiUHJvcGVydHlcIjtcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICB9XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICBub2RlLnR5cGUgPSBcIlByb3BlcnR5XCI7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHByb3AubWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICAgIG5vZGUudHlwZSA9IFwiSW1wb3J0RXhwcmVzc2lvblwiO1xuICAgICAgbm9kZS5zb3VyY2UgPSBub2RlLmFyZ3VtZW50c1swXTtcbiAgICAgIG5vZGUub3B0aW9ucyA9IChfcmVmID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbiAgICAgIG5vZGUuYXR0cmlidXRlcyA9IChfcmVmMiA9IG5vZGUuYXJndW1lbnRzWzFdKSAhPSBudWxsID8gX3JlZjIgOiBudWxsO1xuICAgICAgZGVsZXRlIG5vZGUuYXJndW1lbnRzO1xuICAgICAgZGVsZXRlIG5vZGUuY2FsbGVlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydCh1bmZpbmlzaGVkLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgZXhwb3J0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCwgZGVjb3JhdG9ycyk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgIG5vZGUudHlwZSA9IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjtcbiAgICAgICAgICBub2RlLmV4cG9ydGVkID0gbm9kZS5zcGVjaWZpZXJzWzBdLmV4cG9ydGVkO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLnNwZWNpZmllcnM7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfZGVjbGFyYXRpb24kZGVjb3JhdG87XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGVjbGFyYXRpb25cbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBpZiAoKGRlY2xhcmF0aW9uID09IG51bGwgPyB2b2lkIDAgOiBkZWNsYXJhdGlvbi50eXBlKSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgJiYgKChfZGVjbGFyYXRpb24kZGVjb3JhdG8gPSBkZWNsYXJhdGlvbi5kZWNvcmF0b3JzKSA9PSBudWxsID8gdm9pZCAwIDogX2RlY2xhcmF0aW9uJGRlY29yYXRvLmxlbmd0aCkgPiAwICYmIGRlY2xhcmF0aW9uLnN0YXJ0ID09PSBub2RlLnN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBleHBvcnRTdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiB8fCBub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIG5vZGUudHlwZSA9IG5vZGUudHlwZS5zdWJzdHJpbmcoOCk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuc3RvcCkge1xuICAgICAgICBjb25zdCBjaGFpbiA9IHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpO1xuICAgICAgICBjaGFpbi5leHByZXNzaW9uID0gbm9kZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjaGFpbiwgXCJDaGFpbkV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNoYWluRXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24obm9kZSk7XG4gIH1cbiAgaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkNoYWluRXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlID0gbm9kZS5leHByZXNzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpO1xuICB9XG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiBub2RlLmtpbmQgPT09IFwiaW5pdFwiICYmICFub2RlLm1ldGhvZDtcbiAgfVxuICBpc09iamVjdE1ldGhvZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIChub2RlLm1ldGhvZCB8fCBub2RlLmtpbmQgPT09IFwiZ2V0XCIgfHwgbm9kZS5raW5kID09PSBcInNldFwiKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgcmV0dXJuIHRvRVNUcmVlTG9jYXRpb24oc3VwZXIuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykpO1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIHN1cGVyLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIHN1cGVyLnJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jKTtcbiAgICB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpO1xuICB9XG59O1xuY2xhc3MgVG9rQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuLCBwcmVzZXJ2ZVNwYWNlKSB7XG4gICAgdGhpcy50b2tlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgfVxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbntcbiAgdHlwZXMudGVtcGxhdGUgPSBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSk7XG59XG5jb25zdCBiZWZvcmVFeHByID0gdHJ1ZTtcbmNvbnN0IHN0YXJ0c0V4cHIgPSB0cnVlO1xuY29uc3QgaXNMb29wID0gdHJ1ZTtcbmNvbnN0IGlzQXNzaWduID0gdHJ1ZTtcbmNvbnN0IHByZWZpeCA9IHRydWU7XG5jb25zdCBwb3N0Zml4ID0gdHJ1ZTtcbmNsYXNzIEV4cG9ydGVkVG9rZW5UeXBlIHtcbiAgY29uc3RydWN0b3IobGFiZWwsIGNvbmYgPSB7fSkge1xuICAgIHRoaXMubGFiZWwgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXl3b3JkID0gdm9pZCAwO1xuICAgIHRoaXMuYmVmb3JlRXhwciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSB2b2lkIDA7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNMb29wID0gdm9pZCAwO1xuICAgIHRoaXMuaXNBc3NpZ24gPSB2b2lkIDA7XG4gICAgdGhpcy5wcmVmaXggPSB2b2lkIDA7XG4gICAgdGhpcy5wb3N0Zml4ID0gdm9pZCAwO1xuICAgIHRoaXMuYmlub3AgPSB2b2lkIDA7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMua2V5d29yZCA9IGNvbmYua2V5d29yZDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSAhIWNvbmYuYmVmb3JlRXhwcjtcbiAgICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgICB0aGlzLnJpZ2h0QXNzb2NpYXRpdmUgPSAhIWNvbmYucmlnaHRBc3NvY2lhdGl2ZTtcbiAgICB0aGlzLmlzTG9vcCA9ICEhY29uZi5pc0xvb3A7XG4gICAgdGhpcy5pc0Fzc2lnbiA9ICEhY29uZi5pc0Fzc2lnbjtcbiAgICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gICAgdGhpcy5wb3N0Zml4ID0gISFjb25mLnBvc3RmaXg7XG4gICAgdGhpcy5iaW5vcCA9IGNvbmYuYmlub3AgIT0gbnVsbCA/IGNvbmYuYmlub3AgOiBudWxsO1xuICAgIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBjcmVhdGVCaW5vcChuYW1lLCBiaW5vcCkge1xuICByZXR1cm4gY3JlYXRlVG9rZW4obmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5sZXQgdG9rZW5UeXBlQ291bnRlciA9IC0xO1xuY29uc3QgdG9rZW5UeXBlcyA9IFtdO1xuY29uc3QgdG9rZW5MYWJlbHMgPSBbXTtcbmNvbnN0IHRva2VuQmlub3BzID0gW107XG5jb25zdCB0b2tlbkJlZm9yZUV4cHJzID0gW107XG5jb25zdCB0b2tlblN0YXJ0c0V4cHJzID0gW107XG5jb25zdCB0b2tlblByZWZpeGVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAgdG9rZW5MYWJlbHMucHVzaChuYW1lKTtcbiAgdG9rZW5CaW5vcHMucHVzaCgoX29wdGlvbnMkYmlub3AgPSBvcHRpb25zLmJpbm9wKSAhPSBudWxsID8gX29wdGlvbnMkYmlub3AgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwciA9IG9wdGlvbnMuYmVmb3JlRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJGJlZm9yZUV4cHIgOiBmYWxzZSk7XG4gIHRva2VuU3RhcnRzRXhwcnMucHVzaCgoX29wdGlvbnMkc3RhcnRzRXhwciA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIgOiBmYWxzZSk7XG4gIHRva2VuUHJlZml4ZXMucHVzaCgoX29wdGlvbnMkcHJlZml4ID0gb3B0aW9ucy5wcmVmaXgpICE9IG51bGwgPyBfb3B0aW9ucyRwcmVmaXggOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUobmFtZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdG9rZW5UeXBlQ291bnRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX29wdGlvbnMkYmlub3AyLCBfb3B0aW9ucyRiZWZvcmVFeHByMiwgX29wdGlvbnMkc3RhcnRzRXhwcjIsIF9vcHRpb25zJHByZWZpeDI7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5jb25zdCB0dCA9IHtcbiAgYnJhY2tldEw6IGNyZWF0ZVRva2VuKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IGNyZWF0ZVRva2VuKFwiI1tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldEJhckw6IGNyZWF0ZVRva2VuKFwiW3xcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldFI6IGNyZWF0ZVRva2VuKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IGNyZWF0ZVRva2VuKFwifF1cIiksXG4gIGJyYWNlTDogY3JlYXRlVG9rZW4oXCJ7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlQmFyTDogY3JlYXRlVG9rZW4oXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBjcmVhdGVUb2tlbihcIiN7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlUjogY3JlYXRlVG9rZW4oXCJ9XCIpLFxuICBicmFjZUJhclI6IGNyZWF0ZVRva2VuKFwifH1cIiksXG4gIHBhcmVuTDogY3JlYXRlVG9rZW4oXCIoXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBhcmVuUjogY3JlYXRlVG9rZW4oXCIpXCIpLFxuICBjb21tYTogY3JlYXRlVG9rZW4oXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBjcmVhdGVUb2tlbihcIjtcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGNvbG9uOiBjcmVhdGVUb2tlbihcIjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdWJsZUNvbG9uOiBjcmVhdGVUb2tlbihcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IGNyZWF0ZVRva2VuKFwiLlwiKSxcbiAgcXVlc3Rpb246IGNyZWF0ZVRva2VuKFwiP1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgcXVlc3Rpb25Eb3Q6IGNyZWF0ZVRva2VuKFwiPy5cIiksXG4gIGFycm93OiBjcmVhdGVUb2tlbihcIj0+XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZTogY3JlYXRlVG9rZW4oXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IGNyZWF0ZVRva2VuKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IGNyZWF0ZVRva2VuKFwiYFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG9sbGFyQnJhY2VMOiBjcmVhdGVUb2tlbihcIiR7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlVGFpbDogY3JlYXRlVG9rZW4oXCIuLi5gXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZU5vblRhaWw6IGNyZWF0ZVRva2VuKFwiLi4uJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYXQ6IGNyZWF0ZVRva2VuKFwiQFwiKSxcbiAgaGFzaDogY3JlYXRlVG9rZW4oXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogY3JlYXRlVG9rZW4oXCIjIS4uLlwiKSxcbiAgZXE6IGNyZWF0ZVRva2VuKFwiPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgYXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBzbGFzaEFzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgeG9yQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBtb2R1bG9Bc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGluY0RlYzogY3JlYXRlVG9rZW4oXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogY3JlYXRlVG9rZW4oXCIhXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0aWxkZTogY3JlYXRlVG9rZW4oXCJ+XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVDYXJldDogY3JlYXRlVG9rZW4oXCJeXlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG91YmxlQXQ6IGNyZWF0ZVRva2VuKFwiQEBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBpcGVsaW5lOiBjcmVhdGVCaW5vcChcInw+XCIsIDApLFxuICBudWxsaXNoQ29hbGVzY2luZzogY3JlYXRlQmlub3AoXCI/P1wiLCAxKSxcbiAgbG9naWNhbE9SOiBjcmVhdGVCaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBjcmVhdGVCaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGNyZWF0ZUJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogY3JlYXRlQmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBjcmVhdGVCaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBjcmVhdGVCaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIGx0OiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgZ3Q6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICByZWxhdGlvbmFsOiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdEw6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdFI6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBjcmVhdGVUb2tlbihcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBjcmVhdGVUb2tlbihcIiVcIiwge1xuICAgIGJpbm9wOiAxMCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdGFyOiBjcmVhdGVUb2tlbihcIipcIiwge1xuICAgIGJpbm9wOiAxMFxuICB9KSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBjcmVhdGVUb2tlbihcIioqXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiAxMSxcbiAgICByaWdodEFzc29jaWF0aXZlOiB0cnVlXG4gIH0pLFxuICBfaW46IGNyZWF0ZUtleXdvcmQoXCJpblwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX2luc3RhbmNlb2Y6IGNyZWF0ZUtleXdvcmQoXCJpbnN0YW5jZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfYnJlYWs6IGNyZWF0ZUtleXdvcmQoXCJicmVha1wiKSxcbiAgX2Nhc2U6IGNyZWF0ZUtleXdvcmQoXCJjYXNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfY2F0Y2g6IGNyZWF0ZUtleXdvcmQoXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBjcmVhdGVLZXl3b3JkKFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjogY3JlYXRlS2V5d29yZChcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDogY3JlYXRlS2V5d29yZChcImRlZmF1bHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9lbHNlOiBjcmVhdGVLZXl3b3JkKFwiZWxzZVwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZpbmFsbHk6IGNyZWF0ZUtleXdvcmQoXCJmaW5hbGx5XCIpLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZG86IGNyZWF0ZUtleXdvcmQoXCJkb1wiLCB7XG4gICAgaXNMb29wLFxuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9mb3I6IGNyZWF0ZUtleXdvcmQoXCJmb3JcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX2FzOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFzc2VydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2FzeW5jOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzeW5jXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXdhaXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXdhaXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWZlcjogY3JlYXRlS2V5d29yZExpa2UoXCJkZWZlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc291cmNlOiBjcmVhdGVLZXl3b3JkTGlrZShcInNvdXJjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N0YXRpYzogY3JlYXRlS2V5d29yZExpa2UoXCJzdGF0aWNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91c2luZzogY3JlYXRlS2V5d29yZExpa2UoXCJ1c2luZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3NhdGlzZmllczogY3JlYXRlS2V5d29yZExpa2UoXCJzYXRpc2ZpZXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9rZXlvZjogY3JlYXRlS2V5d29yZExpa2UoXCJrZXlvZlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlYWRvbmx5OiBjcmVhdGVLZXl3b3JkTGlrZShcInJlYWRvbmx5XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdW5pcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcInVuaXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Fic3RyYWN0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFic3RyYWN0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVjbGFyZTogY3JlYXRlS2V5d29yZExpa2UoXCJkZWNsYXJlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZW51bTogY3JlYXRlS2V5d29yZExpa2UoXCJlbnVtXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbW9kdWxlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm1vZHVsZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX25hbWVzcGFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJuYW1lc3BhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRlcmZhY2U6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50ZXJmYWNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZTogY3JlYXRlS2V5d29yZExpa2UoXCJ0eXBlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb3BhcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm9wYXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbmFtZTogY3JlYXRlVG9rZW4oXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwbGFjZWhvbGRlcjogY3JlYXRlVG9rZW4oXCIlJVwiLCB7XG4gICAgc3RhcnRzRXhwcjogdHJ1ZVxuICB9KSxcbiAgc3RyaW5nOiBjcmVhdGVUb2tlbihcInN0cmluZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbnVtOiBjcmVhdGVUb2tlbihcIm51bVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmlnaW50OiBjcmVhdGVUb2tlbihcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZGVjaW1hbDogY3JlYXRlVG9rZW4oXCJkZWNpbWFsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICByZWdleHA6IGNyZWF0ZVRva2VuKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwcml2YXRlTmFtZTogY3JlYXRlVG9rZW4oXCIjbmFtZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZW9mOiBjcmVhdGVUb2tlbihcImVvZlwiKSxcbiAganN4TmFtZTogY3JlYXRlVG9rZW4oXCJqc3hOYW1lXCIpLFxuICBqc3hUZXh0OiBjcmVhdGVUb2tlbihcImpzeFRleHRcIiwge1xuICAgIGJlZm9yZUV4cHI6IHRydWVcbiAgfSksXG4gIGpzeFRhZ1N0YXJ0OiBjcmVhdGVUb2tlbihcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgICBzdGFydHNFeHByOiB0cnVlXG4gIH0pLFxuICBqc3hUYWdFbmQ6IGNyZWF0ZVRva2VuKFwianN4VGFnRW5kXCIpXG59O1xuZnVuY3Rpb24gdG9rZW5Jc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDkzICYmIHRva2VuIDw9IDEzMztcbn1cbmZ1bmN0aW9uIHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDU4ICYmIHRva2VuIDw9IDEzNztcbn1cbmZ1bmN0aW9uIHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJlZm9yZUV4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblN0YXJ0c0V4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuSXNBc3NpZ25tZW50KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyOSAmJiB0b2tlbiA8PSAzMztcbn1cbmZ1bmN0aW9uIHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDEyOSAmJiB0b2tlbiA8PSAxMzE7XG59XG5mdW5jdGlvbiB0b2tlbklzTG9vcCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTAgJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDM5ICYmIHRva2VuIDw9IDU5O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1Bvc3RmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSAzNDtcbn1cbmZ1bmN0aW9uIHRva2VuSXNQcmVmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuUHJlZml4ZXNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjEgJiYgdG9rZW4gPD0gMTIzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI0ICYmIHRva2VuIDw9IDEzMDtcbn1cbmZ1bmN0aW9uIHRva2VuTGFiZWxOYW1lKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkxhYmVsc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW5CaW5vcHNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSA1Nztcbn1cbmZ1bmN0aW9uIHRva2VuSXNUZW1wbGF0ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMjQgJiYgdG9rZW4gPD0gMjU7XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlZFRva2VuKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblR5cGVzW3Rva2VuXTtcbn1cbntcbiAgdG9rZW5UeXBlc1s4XS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wb3AoKTtcbiAgfTtcbiAgdG9rZW5UeXBlc1s1XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1s3XS51cGRhdGVDb250ZXh0ID0gdG9rZW5UeXBlc1syM10udXBkYXRlQ29udGV4dCA9IGNvbnRleHQgPT4ge1xuICAgIGNvbnRleHQucHVzaCh0eXBlcy5icmFjZSk7XG4gIH07XG4gIHRva2VuVHlwZXNbMjJdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgICBpZiAoY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy50ZW1wbGF0ZSkge1xuICAgICAgY29udGV4dC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLnRlbXBsYXRlKTtcbiAgICB9XG4gIH07XG4gIHRva2VuVHlwZXNbMTQzXS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gICAgY29udGV4dC5wdXNoKHR5cGVzLmpfZXhwciwgdHlwZXMual9vVGFnKTtcbiAgfTtcbn1cbmxldCBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MC1cXHUwNTg4XFx1MDVkMC1cXHUwNWVhXFx1MDVlZi1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4NjAtXFx1MDg2YVxcdTA4NzAtXFx1MDg4N1xcdTA4ODktXFx1MDg4ZVxcdTA4YTAtXFx1MDhjOVxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MDlmY1xcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBhZjlcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzOVxcdTBjM2RcXHUwYzU4LVxcdTBjNWFcXHUwYzVkXFx1MGM2MFxcdTBjNjFcXHUwYzgwXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3Y2RcXHVhN2QwXFx1YTdkMVxcdWE3ZDNcXHVhN2Q1LVxcdWE3ZGNcXHVhN2YyLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhY2VcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcxLCA1NSwgNywgMSwgNjUsIDAsIDE2LCAzLCAyLCAyLCAyLCAyOCwgNDMsIDI4LCA0LCAyOCwgMzYsIDcsIDIsIDI3LCAyOCwgNTMsIDExLCAyMSwgMTEsIDE4LCAxNCwgMTcsIDExMSwgNzIsIDU2LCA1MCwgMTQsIDUwLCAxNCwgMzUsIDM5LCAyNywgMTAsIDIyLCAyNTEsIDQxLCA3LCAxLCAxNywgMiwgNjAsIDI4LCAxMSwgMCwgOSwgMjEsIDQzLCAxNywgNDcsIDIwLCAyOCwgMjIsIDEzLCA1MiwgNTgsIDEsIDMsIDAsIDE0LCA0NCwgMzMsIDI0LCAyNywgMzUsIDMwLCAwLCAzLCAwLCA5LCAzNCwgNCwgMCwgMTMsIDQ3LCAxNSwgMywgMjIsIDAsIDIsIDAsIDM2LCAxNywgMiwgMjQsIDIwLCAxLCA2NCwgNiwgMiwgMCwgMiwgMywgMiwgMTQsIDIsIDksIDgsIDQ2LCAzOSwgNywgMywgMSwgMywgMjEsIDIsIDYsIDIsIDEsIDIsIDQsIDQsIDAsIDE5LCAwLCAxMywgNCwgMzEsIDksIDIsIDAsIDMsIDAsIDIsIDM3LCAyLCAwLCAyNiwgMCwgMiwgMCwgNDUsIDUyLCAxOSwgMywgMjEsIDIsIDMxLCA0NywgMjEsIDEsIDIsIDAsIDE4NSwgNDYsIDQyLCAzLCAzNywgNDcsIDIxLCAwLCA2MCwgNDIsIDE0LCAwLCA3MiwgMjYsIDM4LCA2LCAxODYsIDQzLCAxMTcsIDYzLCAzMiwgNywgMywgMCwgMywgNywgMiwgMSwgMiwgMjMsIDE2LCAwLCAyLCAwLCA5NSwgNywgMywgMzgsIDE3LCAwLCAyLCAwLCAyOSwgMCwgMTEsIDM5LCA4LCAwLCAyMiwgMCwgMTIsIDQ1LCAyMCwgMCwgMTksIDcyLCAyMDAsIDMyLCAzMiwgOCwgMiwgMzYsIDE4LCAwLCA1MCwgMjksIDExMywgNiwgMiwgMSwgMiwgMzcsIDIyLCAwLCAyNiwgNSwgMiwgMSwgMiwgMzEsIDE1LCAwLCAzMjgsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDEyOSwgNzQsIDYsIDAsIDY3LCAxMiwgNjUsIDEsIDIsIDAsIDI5LCA2MTM1LCA5LCAxMjM3LCA0MiwgOSwgODkzNiwgMywgMiwgNiwgMiwgMSwgMiwgMjkwLCAxNiwgMCwgMzAsIDIsIDMsIDAsIDE1LCAzLCA5LCAzOTUsIDIzMDksIDEwNiwgNiwgMTIsIDQsIDgsIDgsIDksIDU5OTEsIDg0LCAyLCA3MCwgMiwgMSwgMywgMCwgMywgMSwgMywgMywgMiwgMTEsIDIsIDAsIDIsIDYsIDIsIDY0LCAyLCAzLCAzLCA3LCAyLCA2LCAyLCAyNywgMiwgMywgMiwgNCwgMiwgMCwgNCwgNiwgMiwgMzM5LCAzLCAyNCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgNywgMTg0NSwgMzAsIDcsIDUsIDI2MiwgNjEsIDE0NywgNDQsIDExLCA2LCAxNywgMCwgMzIyLCAyOSwgMTksIDQzLCA0ODUsIDI3LCAyMjksIDI5LCAzLCAwLCA0OTYsIDYsIDIsIDMsIDIsIDEsIDIsIDE0LCAyLCAxOTYsIDYwLCA2NywgOCwgMCwgMTIwNSwgMywgMiwgMjYsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDksIDIsIDMsIDIsIDAsIDIsIDAsIDcsIDAsIDUsIDAsIDIsIDAsIDIsIDAsIDIsIDIsIDIsIDEsIDIsIDAsIDMsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDAsIDIsIDEsIDIsIDAsIDMsIDMsIDIsIDYsIDIsIDMsIDIsIDMsIDIsIDAsIDIsIDksIDIsIDE2LCA2LCAyLCAyLCA0LCAyLCAxNiwgNDQyMSwgNDI3MTksIDMzLCA0MTUzLCA3LCAyMjEsIDMsIDU3NjEsIDE1LCA3NDcyLCAxNiwgNjIxLCAyNDY3LCA1NDEsIDE1MDcsIDQ5MzgsIDYsIDQxOTFdO1xuY29uc3QgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwgMCwgMjI3LCAwLCAxNTAsIDQsIDI5NCwgOSwgMTM2OCwgMiwgMiwgMSwgNiwgMywgNDEsIDIsIDUsIDAsIDE2NiwgMSwgNTc0LCAzLCA5LCA5LCA3LCA5LCAzMiwgNCwgMzE4LCAxLCA4MCwgMywgNzEsIDEwLCA1MCwgMywgMTIzLCAyLCA1NCwgMTQsIDMyLCAxMCwgMywgMSwgMTEsIDMsIDQ2LCAxMCwgOCwgMCwgNDYsIDksIDcsIDIsIDM3LCAxMywgMiwgOSwgNiwgMSwgNDUsIDAsIDEzLCAyLCA0OSwgMTMsIDksIDMsIDIsIDExLCA4MywgMTEsIDcsIDAsIDMsIDAsIDE1OCwgMTEsIDYsIDksIDcsIDMsIDU2LCAxLCAyLCA2LCAzLCAxLCAzLCAyLCAxMCwgMCwgMTEsIDEsIDMsIDYsIDQsIDQsIDY4LCA4LCAyLCAwLCAzLCAwLCAyLCAzLCAyLCA0LCAyLCAwLCAxNSwgMSwgODMsIDE3LCAxMCwgOSwgNSwgMCwgODIsIDE5LCAxMywgOSwgMjE0LCA2LCAzLCA4LCAyOCwgMSwgODMsIDE2LCAxNiwgOSwgODIsIDEyLCA5LCA5LCA3LCAxOSwgNTgsIDE0LCA1LCA5LCAyNDMsIDE0LCAxNjYsIDksIDcxLCA1LCAyLCAxLCAzLCAzLCAyLCAwLCAyLCAxLCAxMywgOSwgMTIwLCA2LCAzLCA2LCA0LCAwLCAyOSwgOSwgNDEsIDYsIDIsIDMsIDksIDAsIDEwLCAxMCwgNDcsIDE1LCAzNDMsIDksIDU0LCA3LCAyLCA3LCAxNywgOSwgNTcsIDIxLCAyLCAxMywgMTIzLCA1LCA0LCAwLCAyLCAxLCAyLCA2LCAyLCAwLCA5LCA5LCA0OSwgNCwgMiwgMSwgMiwgNCwgOSwgOSwgMzMwLCAzLCAxMCwgMSwgMiwgMCwgNDksIDYsIDQsIDQsIDE0LCAxMCwgNTM1MCwgMCwgNywgMTQsIDExNDY1LCAyNywgMjM0MywgOSwgODcsIDksIDM5LCA0LCA2MCwgNiwgMjYsIDksIDUzNSwgOSwgNDcwLCAwLCAyLCA1NCwgOCwgMywgODIsIDAsIDEyLCAxLCAxOTYyOCwgMSwgNDE3OCwgOSwgNTE5LCA0NSwgMywgMjIsIDU0MywgNCwgNCwgNSwgOSwgNywgMywgNiwgMzEsIDMsIDE0OSwgMiwgMTQxOCwgNDksIDUxMywgNTQsIDUsIDQ5LCA5LCAwLCAxNSwgMCwgMjMsIDQsIDIsIDE0LCAxMzYxLCA2LCAyLCAxNiwgMywgNiwgMiwgMSwgMiwgNCwgMTAxLCAwLCAxNjEsIDYsIDEwLCA5LCAzNTcsIDAsIDYyLCAxMywgNDk5LCAxMywgMjQ1LCAxLCAyLCA5LCA3MjYsIDYsIDExMCwgNiwgNiwgOSwgNDc1OSwgOSwgNzg3NzE5LCAyMzldO1xuZnVuY3Rpb24gaXNJbkFzdHJhbFNldChjb2RlLCBzZXQpIHtcbiAgbGV0IHBvcyA9IDB4MTAwMDA7XG4gIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzZXQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSByZXR1cm4gZmFsc2U7XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJTdGFydChjb2RlKSB7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2Rlcyk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJDaGFyKGNvZGUpIHtcbiAgaWYgKGNvZGUgPCA0OCkgcmV0dXJuIGNvZGUgPT09IDM2O1xuICBpZiAoY29kZSA8IDU4KSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA2NSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29kZSA8PSA5MCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgOTcpIHJldHVybiBjb2RlID09PSA5NTtcbiAgaWYgKGNvZGUgPD0gMTIyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPD0gMHhmZmZmKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgfVxuICByZXR1cm4gaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyU3RhcnRDb2RlcykgfHwgaXNJbkFzdHJhbFNldChjb2RlLCBhc3RyYWxJZGVudGlmaWVyQ29kZXMpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IHtcbiAga2V5d29yZDogW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCJdLFxuICBzdHJpY3Q6IFtcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCJdLFxuICBzdHJpY3RCaW5kOiBbXCJldmFsXCIsIFwiYXJndW1lbnRzXCJdXG59O1xuY29uc3Qga2V5d29yZHMgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMua2V5d29yZCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0ID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLnN0cmljdCk7XG5jb25zdCByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3RCaW5kKTtcbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpbk1vZHVsZSAmJiB3b3JkID09PSBcImF3YWl0XCIgfHwgd29yZCA9PT0gXCJlbnVtXCI7XG59XG5mdW5jdGlvbiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaXNSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHx8IHJlc2VydmVkV29yZHNTdHJpY3RTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRzU3RyaWN0QmluZFNldC5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc1N0cmljdEJpbmRSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzU3RyaWN0UmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCBpc1N0cmljdEJpbmRPbmx5UmVzZXJ2ZWRXb3JkKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNLZXl3b3JkKHdvcmQpIHtcbiAgcmV0dXJuIGtleXdvcmRzLmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmF0b3JTdGFydChjdXJyZW50LCBuZXh0LCBuZXh0Mikge1xuICByZXR1cm4gY3VycmVudCA9PT0gNjQgJiYgbmV4dCA9PT0gNjQgJiYgaXNJZGVudGlmaWVyU3RhcnQobmV4dDIpO1xufVxuY29uc3QgcmVzZXJ2ZWRXb3JkTGlrZVNldCA9IG5ldyBTZXQoW1wiYnJlYWtcIiwgXCJjYXNlXCIsIFwiY2F0Y2hcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVmYXVsdFwiLCBcImRvXCIsIFwiZWxzZVwiLCBcImZpbmFsbHlcIiwgXCJmb3JcIiwgXCJmdW5jdGlvblwiLCBcImlmXCIsIFwicmV0dXJuXCIsIFwic3dpdGNoXCIsIFwidGhyb3dcIiwgXCJ0cnlcIiwgXCJ2YXJcIiwgXCJjb25zdFwiLCBcIndoaWxlXCIsIFwid2l0aFwiLCBcIm5ld1wiLCBcInRoaXNcIiwgXCJzdXBlclwiLCBcImNsYXNzXCIsIFwiZXh0ZW5kc1wiLCBcImV4cG9ydFwiLCBcImltcG9ydFwiLCBcIm51bGxcIiwgXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCIsIFwiZGVsZXRlXCIsIFwiaW1wbGVtZW50c1wiLCBcImludGVyZmFjZVwiLCBcImxldFwiLCBcInBhY2thZ2VcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIFwicHVibGljXCIsIFwic3RhdGljXCIsIFwieWllbGRcIiwgXCJldmFsXCIsIFwiYXJndW1lbnRzXCIsIFwiZW51bVwiLCBcImF3YWl0XCJdKTtcbmZ1bmN0aW9uIGNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpIHtcbiAgcmV0dXJuIHJlc2VydmVkV29yZExpa2VTZXQuaGFzKHdvcmQpO1xufVxuY2xhc3MgU2NvcGUge1xuICBjb25zdHJ1Y3RvcihmbGFncykge1xuICAgIHRoaXMuZmxhZ3MgPSAwO1xuICAgIHRoaXMubmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5maXJzdExleGljYWxOYW1lID0gXCJcIjtcbiAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gIH1cbn1cbmNsYXNzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5Nb2R1bGUpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnNjb3BlU3RhY2sgPSBbXTtcbiAgICB0aGlzLmluTW9kdWxlID0gdm9pZCAwO1xuICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gIH1cbiAgZ2V0IGluVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTY29wZSgpLmZsYWdzICYgMSkgPiAwO1xuICB9XG4gIGdldCBpbkZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VmFyU2NvcGVGbGFncygpICYgMikgPiAwO1xuICB9XG4gIGdldCBhbGxvd1N1cGVyKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDE2KSA+IDA7XG4gIH1cbiAgZ2V0IGFsbG93RGlyZWN0U3VwZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpICYgMzIpID4gMDtcbiAgfVxuICBnZXQgaW5DbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiA2NCkgPiAwO1xuICB9XG4gIGdldCBpbkNsYXNzQW5kTm90SW5Ob25BcnJvd0Z1bmN0aW9uKCkge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKTtcbiAgICByZXR1cm4gKGZsYWdzICYgNjQpID4gMCAmJiAoZmxhZ3MgJiAyKSA9PT0gMDtcbiAgfVxuICBnZXQgaW5TdGF0aWNCbG9jaygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAxMjgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoZmxhZ3MgJiAoMzg3IHwgNjQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluTm9uQXJyb3dGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAyKSA+IDA7XG4gIH1cbiAgZ2V0IHRyZWF0RnVuY3Rpb25zQXNWYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSk7XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBzY29wZS5mbGFncztcbiAgfVxuICB0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkge1xuICAgIHJldHVybiAhIShzY29wZS5mbGFncyAmICgyIHwgMTI4KSB8fCAhdGhpcy5wYXJzZXIuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiAxKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4IHx8IGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICBsZXQgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKSB8fCAwO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzY29wZS5maXJzdExleGljYWxOYW1lKSB7XG4gICAgICAgICAgc2NvcGUuZmlyc3RMZXhpY2FsTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHR5cGUgfCAyO1xuICAgICAgfVxuICAgICAgc2NvcGUubmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgOCkge1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSAmIDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHNjb3BlLm5hbWVzLnNldChuYW1lLCAoc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDApIHwgMSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgMzg3KSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgbWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyLmluTW9kdWxlICYmIHNjb3BlLmZsYWdzICYgMSkge1xuICAgICAgdGhpcy51bmRlZmluZWRFeHBvcnRzLmRlbGV0ZShuYW1lKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGlmICh0aGlzLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlZhclJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiAxKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDgpIHtcbiAgICAgIHJldHVybiBzY29wZS5uYW1lcy5oYXMobmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBzY29wZS5uYW1lcy5nZXQobmFtZSk7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHJldHVybiAodHlwZSAmIDIpID4gMCB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiAxKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiAodHlwZSAmIDIpID4gMCAmJiAhKHNjb3BlLmZsYWdzICYgOCAmJiBzY29wZS5maXJzdExleGljYWxOYW1lID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiA0KSA+IDA7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBpZiAoIXRvcExldmVsU2NvcGUubmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBjdXJyZW50VmFyU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAzODcpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxOzsgaS0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZsYWdzXG4gICAgICB9ID0gdGhpcy5zY29wZVN0YWNrW2ldO1xuICAgICAgaWYgKGZsYWdzICYgKDM4NyB8IDY0KSAmJiAhKGZsYWdzICYgNCkpIHtcbiAgICAgICAgcmV0dXJuIGZsYWdzO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgRmxvd1Njb3BlIGV4dGVuZHMgU2NvcGUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5kZWNsYXJlRnVuY3Rpb25zID0gbmV3IFNldCgpO1xuICB9XG59XG5jbGFzcyBGbG93U2NvcGVIYW5kbGVyIGV4dGVuZHMgU2NvcGVIYW5kbGVyIHtcbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IEZsb3dTY29wZShmbGFncyk7XG4gIH1cbiAgZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYykge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4KSB7XG4gICAgICB0aGlzLmNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5hZGQobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMjA0OCAmJiAhc2NvcGUuZGVjbGFyZUZ1bmN0aW9ucy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY29wZS5uYW1lcy5nZXQobmFtZSk7XG4gICAgICByZXR1cm4gKHR5cGUgJiA0KSA+IDAgfHwgKHR5cGUgJiAyKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgaWYgKCF0aGlzLnNjb3BlU3RhY2tbMF0uZGVjbGFyZUZ1bmN0aW9ucy5oYXMoaWQubmFtZSkpIHtcbiAgICAgIHN1cGVyLmNoZWNrTG9jYWxFeHBvcnQoaWQpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgQmFzZVBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSBmYWxzZTtcbiAgICB0aGlzLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCA9IGZhbHNlO1xuICB9XG4gIHNvdXJjZVRvT2Zmc2V0UG9zKHNvdXJjZVBvcykge1xuICAgIHJldHVybiBzb3VyY2VQb3MgKyB0aGlzLnN0YXJ0SW5kZXg7XG4gIH1cbiAgb2Zmc2V0VG9Tb3VyY2VQb3Mob2Zmc2V0UG9zKSB7XG4gICAgcmV0dXJuIG9mZnNldFBvcyAtIHRoaXMuc3RhcnRJbmRleDtcbiAgfVxuICBoYXNQbHVnaW4ocGx1Z2luQ29uZmlnKSB7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW5Db25maWcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdWdpbnMuaGFzKHBsdWdpbkNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtwbHVnaW5OYW1lLCBwbHVnaW5PcHRpb25zXSA9IHBsdWdpbkNvbmZpZztcbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luTmFtZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwbHVnaW5PcHRpb25zKSkge1xuICAgICAgICBpZiAoKGFjdHVhbE9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdHVhbE9wdGlvbnNba2V5XSkgIT09IHBsdWdpbk9wdGlvbnNba2V5XSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIGdldFBsdWdpbk9wdGlvbihwbHVnaW4sIG5hbWUpIHtcbiAgICB2YXIgX3RoaXMkcGx1Z2lucyRnZXQ7XG4gICAgcmV0dXJuIChfdGhpcyRwbHVnaW5zJGdldCA9IHRoaXMucGx1Z2lucy5nZXQocGx1Z2luKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBsdWdpbnMkZ2V0W25hbWVdO1xuICB9XG59XG5mdW5jdGlvbiBzZXRUcmFpbGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLnRyYWlsaW5nQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUudHJhaWxpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TGVhZGluZ0NvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLmxlYWRpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS5sZWFkaW5nQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cykge1xuICBpZiAobm9kZS5pbm5lckNvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMgPSBjb21tZW50cztcbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVyQ29tbWVudHMudW5zaGlmdCguLi5jb21tZW50cyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgZWxlbWVudHMsIGNvbW1lbnRXUykge1xuICBsZXQgbGFzdEVsZW1lbnQgPSBudWxsO1xuICBsZXQgaSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgd2hpbGUgKGxhc3RFbGVtZW50ID09PSBudWxsICYmIGkgPiAwKSB7XG4gICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50c1stLWldO1xuICB9XG4gIGlmIChsYXN0RWxlbWVudCA9PT0gbnVsbCB8fCBsYXN0RWxlbWVudC5zdGFydCA+IGNvbW1lbnRXUy5zdGFydCkge1xuICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudFdTLmNvbW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGxhc3RFbGVtZW50LCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9XG59XG5jbGFzcyBDb21tZW50c1BhcnNlciBleHRlbmRzIEJhc2VQYXJzZXIge1xuICBhZGRDb21tZW50KGNvbW1lbnQpIHtcbiAgICBpZiAodGhpcy5maWxlbmFtZSkgY29tbWVudC5sb2MuZmlsZW5hbWUgPSB0aGlzLmZpbGVuYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRzTGVuXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRoaXMuY29tbWVudHMubGVuZ3RoICE9PSBjb21tZW50c0xlbikge1xuICAgICAgdGhpcy5jb21tZW50cy5sZW5ndGggPSBjb21tZW50c0xlbjtcbiAgICB9XG4gICAgdGhpcy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgIHRoaXMuc3RhdGUuY29tbWVudHNMZW4rKztcbiAgfVxuICBwcm9jZXNzQ29tbWVudChub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgY29tbWVudFN0YWNrTGVuZ3RoID0gY29tbWVudFN0YWNrLmxlbmd0aDtcbiAgICBpZiAoY29tbWVudFN0YWNrTGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgbGV0IGkgPSBjb21tZW50U3RhY2tMZW5ndGggLSAxO1xuICAgIGNvbnN0IGxhc3RDb21tZW50V1MgPSBjb21tZW50U3RhY2tbaV07XG4gICAgaWYgKGxhc3RDb21tZW50V1Muc3RhcnQgPT09IG5vZGUuZW5kKSB7XG4gICAgICBsYXN0Q29tbWVudFdTLmxlYWRpbmdOb2RlID0gbm9kZTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnQ6IG5vZGVTdGFydFxuICAgIH0gPSBub2RlO1xuICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2ldO1xuICAgICAgY29uc3QgY29tbWVudEVuZCA9IGNvbW1lbnRXUy5lbmQ7XG4gICAgICBpZiAoY29tbWVudEVuZCA+IG5vZGVTdGFydCkge1xuICAgICAgICBjb21tZW50V1MuY29udGFpbmluZ05vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50V1MpO1xuICAgICAgICBjb21tZW50U3RhY2suc3BsaWNlKGksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbW1lbnRFbmQgPT09IG5vZGVTdGFydCkge1xuICAgICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5hbGl6ZUNvbW1lbnQoY29tbWVudFdTKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudHNcbiAgICB9ID0gY29tbWVudFdTO1xuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgIT09IG51bGwgfHwgY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRUcmFpbGluZ0NvbW1lbnRzKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1lbnRXUy50cmFpbGluZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc2V0TGVhZGluZ0NvbW1lbnRzKGNvbW1lbnRXUy50cmFpbGluZ05vZGUsIGNvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250YWluaW5nTm9kZTogbm9kZSxcbiAgICAgICAgc3RhcnQ6IGNvbW1lbnRTdGFydFxuICAgICAgfSA9IGNvbW1lbnRXUztcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhjb21tZW50U3RhcnQpIC0gMSkgPT09IDQ0KSB7XG4gICAgICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAgIGNhc2UgXCJSZWNvcmRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucHJvcGVydGllcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgICAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgICAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5wYXJhbXMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICAgIGNhc2UgXCJUdXBsZUV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5lbGVtZW50cywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuc3BlY2lmaWVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluYWxpemVSZW1haW5pbmdDb21tZW50cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKGxldCBpID0gY29tbWVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0aGlzLmZpbmFsaXplQ29tbWVudChjb21tZW50U3RhY2tbaV0pO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmNvbW1lbnRTdGFjayA9IFtdO1xuICB9XG4gIHJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudFN0YWNrXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IGNvbW1lbnRTdGFjaztcbiAgICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgY29uc3QgY29tbWVudFdTID0gY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdO1xuICAgIGlmIChjb21tZW50V1MubGVhZGluZ05vZGUgPT09IG5vZGUpIHtcbiAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJlc2V0UHJldmlvdXNJZGVudGlmaWVyTGVhZGluZ0NvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gY29tbWVudFN0YWNrO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBpZiAoY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdLnRyYWlsaW5nTm9kZSA9PT0gbm9kZSkge1xuICAgICAgY29tbWVudFN0YWNrW2xlbmd0aCAtIDFdLnRyYWlsaW5nTm9kZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPj0gMiAmJiBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMl0udHJhaWxpbmdOb2RlID09PSBub2RlKSB7XG4gICAgICBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMl0udHJhaWxpbmdOb2RlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdGFrZVN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBjb21tZW50V1MuZW5kO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKGNvbW1lbnRTdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1lbnRFbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgfSBlbHNlIGlmIChjb21tZW50RW5kIDwgc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jb25zdCBsaW5lQnJlYWsgPSAvXFxyXFxufFtcXHJcXG5cXHUyMDI4XFx1MjAyOV0vO1xuY29uc3QgbGluZUJyZWFrRyA9IG5ldyBSZWdFeHAobGluZUJyZWFrLnNvdXJjZSwgXCJnXCIpO1xuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAxMDpcbiAgICBjYXNlIDEzOlxuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBoYXNOZXdMaW5lKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGlzTmV3TGluZShpbnB1dC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IHNraXBXaGl0ZVNwYWNlID0gLyg/Olxcc3xcXC9cXC8uKnxcXC9cXCpbXl0qP1xcKlxcLykqL2c7XG5jb25zdCBza2lwV2hpdGVTcGFjZUluTGluZSA9IC8oPzpbXlxcU1xcblxcclxcdTIwMjhcXHUyMDI5XXxcXC9cXC8uKnxcXC9cXCouKj9cXCpcXC8pKi9nO1xuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDAwMDk6XG4gICAgY2FzZSAweDAwMGI6XG4gICAgY2FzZSAweDAwMGM6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDE2MDpcbiAgICBjYXNlIDU3NjA6XG4gICAgY2FzZSAweDIwMDA6XG4gICAgY2FzZSAweDIwMDE6XG4gICAgY2FzZSAweDIwMDI6XG4gICAgY2FzZSAweDIwMDM6XG4gICAgY2FzZSAweDIwMDQ6XG4gICAgY2FzZSAweDIwMDU6XG4gICAgY2FzZSAweDIwMDY6XG4gICAgY2FzZSAweDIwMDc6XG4gICAgY2FzZSAweDIwMDg6XG4gICAgY2FzZSAweDIwMDk6XG4gICAgY2FzZSAweDIwMGE6XG4gICAgY2FzZSAweDIwMmY6XG4gICAgY2FzZSAweDIwNWY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgY2FzZSAweGZlZmY6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmxhZ3MgPSAxMDI0O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ckxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuY29tbWVudHNMZW4gPSAwO1xuICAgIHRoaXMuY29tbWVudFN0YWNrID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudHlwZSA9IDE0MDtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzLmJyYWNlXTtcbiAgICB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRva2Vuc0xlbmd0aCA9IDA7XG4gIH1cbiAgZ2V0IHN0cmljdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgc2V0IHN0cmljdCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMTtlbHNlIHRoaXMuZmxhZ3MgJj0gLTI7XG4gIH1cbiAgaW5pdCh7XG4gICAgc3RyaWN0TW9kZSxcbiAgICBzb3VyY2VUeXBlLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgc3RhcnRMaW5lLFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0pIHtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBzdHJpY3RNb2RlID09PSB0cnVlID8gdHJ1ZSA6IHNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmN1ckxpbmUgPSBzdGFydExpbmU7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAtc3RhcnRDb2x1bW47XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gbmV3IFBvc2l0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIHN0YXJ0SW5kZXgpO1xuICB9XG4gIGdldCBtYXliZUluQXJyb3dQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgbWF5YmVJbkFycm93UGFyYW1ldGVycyh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTM7XG4gIH1cbiAgZ2V0IGluVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0KSA+IDA7XG4gIH1cbiAgc2V0IGluVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNDtlbHNlIHRoaXMuZmxhZ3MgJj0gLTU7XG4gIH1cbiAgZ2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4KSA+IDA7XG4gIH1cbiAgc2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gODtlbHNlIHRoaXMuZmxhZ3MgJj0gLTk7XG4gIH1cbiAgZ2V0IGhhc0Zsb3dDb21tZW50KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDE2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc0Zsb3dDb21tZW50KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxNjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTE3O1xuICB9XG4gIGdldCBpc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDMyKSA+IDA7XG4gIH1cbiAgc2V0IGlzQW1iaWVudENvbnRleHQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDMyO2Vsc2UgdGhpcy5mbGFncyAmPSAtMzM7XG4gIH1cbiAgZ2V0IGluQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA2NCkgPiAwO1xuICB9XG4gIHNldCBpbkFic3RyYWN0Q2xhc3Modikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDY0O2Vsc2UgdGhpcy5mbGFncyAmPSAtNjU7XG4gIH1cbiAgZ2V0IGluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMjgpID4gMDtcbiAgfVxuICBzZXQgaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxMjg7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMjk7XG4gIH1cbiAgZ2V0IHNvbG9Bd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyNTYpID4gMDtcbiAgfVxuICBzZXQgc29sb0F3YWl0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyNTY7ZWxzZSB0aGlzLmZsYWdzICY9IC0yNTc7XG4gIH1cbiAgZ2V0IGluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDUxMikgPiAwO1xuICB9XG4gIHNldCBpbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNTEyO2Vsc2UgdGhpcy5mbGFncyAmPSAtNTEzO1xuICB9XG4gIGdldCBjYW5TdGFydEpTWEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCkgPiAwO1xuICB9XG4gIHNldCBjYW5TdGFydEpTWEVsZW1lbnQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDEwMjQ7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMDI1O1xuICB9XG4gIGdldCBjb250YWluc0VzYygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDQ4KSA+IDA7XG4gIH1cbiAgc2V0IGNvbnRhaW5zRXNjKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyMDQ4O2Vsc2UgdGhpcy5mbGFncyAmPSAtMjA0OTtcbiAgfVxuICBnZXQgaGFzVG9wTGV2ZWxBd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0MDk2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc1RvcExldmVsQXdhaXQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDQwOTY7ZWxzZSB0aGlzLmZsYWdzICY9IC00MDk3O1xuICB9XG4gIGN1clBvc2l0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0LCB0aGlzLnBvcyArIHRoaXMuc3RhcnRJbmRleCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5mbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgc3RhdGUuc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleDtcbiAgICBzdGF0ZS5jdXJMaW5lID0gdGhpcy5jdXJMaW5lO1xuICAgIHN0YXRlLmxpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuICAgIHN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBzdGF0ZS5lbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICBzdGF0ZS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgIHN0YXRlLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnBvdGVudGlhbEFycm93QXQ7XG4gICAgc3RhdGUubm9BcnJvd0F0ID0gdGhpcy5ub0Fycm93QXQuc2xpY2UoKTtcbiAgICBzdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnNsaWNlKCk7XG4gICAgc3RhdGUudG9waWNDb250ZXh0ID0gdGhpcy50b3BpY0NvbnRleHQ7XG4gICAgc3RhdGUubGFiZWxzID0gdGhpcy5sYWJlbHMuc2xpY2UoKTtcbiAgICBzdGF0ZS5jb21tZW50c0xlbiA9IHRoaXMuY29tbWVudHNMZW47XG4gICAgc3RhdGUuY29tbWVudFN0YWNrID0gdGhpcy5jb21tZW50U3RhY2suc2xpY2UoKTtcbiAgICBzdGF0ZS5wb3MgPSB0aGlzLnBvcztcbiAgICBzdGF0ZS50eXBlID0gdGhpcy50eXBlO1xuICAgIHN0YXRlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBzdGF0ZS5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgc3RhdGUuZW5kID0gdGhpcy5lbmQ7XG4gICAgc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICBzdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYztcbiAgICBzdGF0ZS5jb250ZXh0ID0gdGhpcy5jb250ZXh0LnNsaWNlKCk7XG4gICAgc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zO1xuICAgIHN0YXRlLnN0cmljdEVycm9ycyA9IHRoaXMuc3RyaWN0RXJyb3JzO1xuICAgIHN0YXRlLnRva2Vuc0xlbmd0aCA9IHRoaXMudG9rZW5zTGVuZ3RoO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxudmFyIF9pc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59O1xuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IG5ldyBTZXQoWzQ2LCA2NiwgNjksIDc5LCA5NSwgOTgsIDEwMSwgMTExXSksXG4gIGhleDogbmV3IFNldChbNDYsIDg4LCA5NSwgMTIwXSlcbn07XG5jb25zdCBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZyA9IHtcbiAgYmluOiBjaCA9PiBjaCA9PT0gNDggfHwgY2ggPT09IDQ5LFxuICBvY3Q6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU1LFxuICBkZWM6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3LFxuICBoZXg6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3IHx8IGNoID49IDY1ICYmIGNoIDw9IDcwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMlxufTtcbmZ1bmN0aW9uIHJlYWRTdHJpbmdDb250ZW50cyh0eXBlLCBpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBjb25zdCBpbml0aWFsTGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICBjb25zdCBpbml0aWFsQ3VyTGluZSA9IGN1ckxpbmU7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgZmlyc3RJbnZhbGlkTG9jID0gbnVsbDtcbiAgbGV0IGNodW5rU3RhcnQgPSBwb3M7XG4gIGNvbnN0IHtcbiAgICBsZW5ndGhcbiAgfSA9IGlucHV0O1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHtcbiAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSkge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBjb25zdCByZXMgPSByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0eXBlID09PSBcInRlbXBsYXRlXCIsIGVycm9ycyk7XG4gICAgICBpZiAocmVzLmNoID09PSBudWxsICYmICFmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgICAgZmlyc3RJbnZhbGlkTG9jID0ge1xuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgY3VyTGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IHJlcy5jaDtcbiAgICAgIH1cbiAgICAgICh7XG4gICAgICAgIHBvcyxcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBjdXJMaW5lXG4gICAgICB9ID0gcmVzKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgKytwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpICsgXCJcXG5cIjtcbiAgICAgICAgKytwb3M7XG4gICAgICAgIGlmIChjaCA9PT0gMTMgJiYgaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgICsrY3VyTGluZTtcbiAgICAgICAgY2h1bmtTdGFydCA9IGxpbmVTdGFydCA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3MsXG4gICAgc3RyOiBvdXQsXG4gICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lLFxuICAgIGNvbnRhaW5zSW52YWxpZDogISFmaXJzdEludmFsaWRMb2NcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSB7XG4gIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAxMjM7XG4gIH1cbiAgcmV0dXJuIGNoID09PSAodHlwZSA9PT0gXCJkb3VibGVcIiA/IDM0IDogMzkpO1xufVxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5UZW1wbGF0ZSwgZXJyb3JzKSB7XG4gIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gIHBvcysrO1xuICBjb25zdCByZXMgPSBjaCA9PiAoe1xuICAgIHBvcyxcbiAgICBjaCxcbiAgICBsaW5lU3RhcnQsXG4gICAgY3VyTGluZVxuICB9KTtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcblwiKTtcbiAgICBjYXNlIDExNDpcbiAgICAgIHJldHVybiByZXMoXCJcXHJcIik7XG4gICAgY2FzZSAxMjA6XG4gICAgICB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICAoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDIsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNzpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gICAgICB9XG4gICAgY2FzZSAxMTY6XG4gICAgICByZXR1cm4gcmVzKFwiXFx0XCIpO1xuICAgIGNhc2UgOTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFxiXCIpO1xuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdTAwMGJcIik7XG4gICAgY2FzZSAxMDI6XG4gICAgICByZXR1cm4gcmVzKFwiXFxmXCIpO1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOlxuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgKytjdXJMaW5lO1xuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gcmVzKFwiXCIpO1xuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwb3MgLSAxO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHN0YXJ0UG9zLCBwb3MgKyAyKSk7XG4gICAgICAgIGxldCBvY3RhbFN0ciA9IG1hdGNoWzBdO1xuICAgICAgICBsZXQgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiIHx8IG5leHQgPT09IDU2IHx8IG5leHQgPT09IDU3KSB7XG4gICAgICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHN0YXJ0UG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xuICB9XG59XG5mdW5jdGlvbiByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGxlbiwgZm9yY2VMZW4sIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgaW5pdGlhbFBvcyA9IHBvcztcbiAgbGV0IG47XG4gICh7XG4gICAgbixcbiAgICBwb3NcbiAgfSA9IHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAxNiwgbGVuLCBmb3JjZUxlbiwgZmFsc2UsIGVycm9ycywgIXRocm93T25JbnZhbGlkKSk7XG4gIGlmIChuID09PSBudWxsKSB7XG4gICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICBlcnJvcnMuaW52YWxpZEVzY2FwZVNlcXVlbmNlKGluaXRpYWxQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGluaXRpYWxQb3MgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGU6IG4sXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCBlcnJvcnMsIGJhaWxPbkVycm9yKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcG9zO1xuICBjb25zdCBmb3JiaWRkZW5TaWJsaW5ncyA9IHJhZGl4ID09PSAxNiA/IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5oZXggOiBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuZGVjQmluT2N0O1xuICBjb25zdCBpc0FsbG93ZWRTaWJsaW5nID0gcmFkaXggPT09IDE2ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuaGV4IDogcmFkaXggPT09IDEwID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuZGVjIDogcmFkaXggPT09IDggPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5vY3QgOiBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5iaW47XG4gIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoY29kZSA9PT0gOTUgJiYgYWxsb3dOdW1TZXBhcmF0b3IgIT09IFwiYmFpbFwiKSB7XG4gICAgICBjb25zdCBwcmV2ID0gaW5wdXQuY2hhckNvZGVBdChwb3MgLSAxKTtcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKCFhbGxvd051bVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLm51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKG5leHQpIHx8ICFpc0FsbG93ZWRTaWJsaW5nKG5leHQpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhwcmV2KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMobmV4dCkpIHtcbiAgICAgICAgaWYgKGJhaWxPbkVycm9yKSByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICAgIGVycm9ycy51bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDY1KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICB9IGVsc2UgaWYgKF9pc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7XG4gICAgICBpZiAodmFsIDw9IDkgJiYgYmFpbE9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gOSAmJiBlcnJvcnMuaW52YWxpZERpZ2l0KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZm9yY2VMZW4pIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgKytwb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmIChwb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHBvcyAtIHN0YXJ0ICE9PSBsZW4gfHwgaW52YWxpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuOiBudWxsLFxuICAgICAgcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG46IHRvdGFsLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gIGxldCBjb2RlO1xuICBpZiAoY2ggPT09IDEyMykge1xuICAgICsrcG9zO1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5wdXQuaW5kZXhPZihcIn1cIiwgcG9zKSAtIHBvcywgdHJ1ZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICsrcG9zO1xuICAgIGlmIChjb2RlICE9PSBudWxsICYmIGNvZGUgPiAweDEwZmZmZikge1xuICAgICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICAgIGVycm9ycy5pbnZhbGlkQ29kZVBvaW50KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCA0LCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihjdXJMaW5lLCBwb3MgLSBsaW5lU3RhcnQsIHBvcyk7XG59XG5jb25zdCBWQUxJRF9SRUdFWF9GTEFHUyA9IG5ldyBTZXQoWzEwMywgMTA5LCAxMTUsIDEwNSwgMTIxLCAxMTcsIDEwMCwgMTE4XSk7XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXRlLnN0YXJ0SW5kZXggfHwgMDtcbiAgICB0aGlzLnR5cGUgPSBzdGF0ZS50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRJbmRleCArIHN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gc3RhcnRJbmRleCArIHN0YXRlLmVuZDtcbiAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbiAgfVxufVxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgQ29tbWVudHNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50ID0ge1xuICAgICAgaW52YWxpZERpZ2l0OiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVycm9yUmVjb3ZlcnkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZERpZ2l0LCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSwge1xuICAgICAgICAgIHJhZGl4XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBudW1lcmljU2VwYXJhdG9ySW5Fc2NhcGVTZXF1ZW5jZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLk51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKSxcbiAgICAgIHVuZXhwZWN0ZWROdW1lcmljU2VwYXJhdG9yOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3IpXG4gICAgfTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50LCB7XG4gICAgICBpbnZhbGlkRXNjYXBlU2VxdWVuY2U6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5JbnZhbGlkRXNjYXBlU2VxdWVuY2UpLFxuICAgICAgaW52YWxpZENvZGVQb2ludDogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLkludmFsaWRDb2RlUG9pbnQpXG4gICAgfSk7XG4gICAgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c19zdHJpbmcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICAgIHRoaXMucmVjb3JkU3RyaWN0TW9kZUVycm9ycyhFcnJvcnMuU3RyaWN0TnVtZXJpY0VzY2FwZSwgYnVpbGRQb3NpdGlvbihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSkpO1xuICAgICAgfSxcbiAgICAgIHVudGVybWluYXRlZDogKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFN0cmluZywgYnVpbGRQb3NpdGlvbihwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3RlbXBsYXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRDb2RlUG9pbnQsIHtcbiAgICAgIHN0cmljdE51bWVyaWNFc2NhcGU6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5TdHJpY3ROdW1lcmljRXNjYXBlKSxcbiAgICAgIHVudGVybWluYXRlZDogKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFRlbXBsYXRlLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5pdChvcHRpb25zKTtcbiAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgdGhpcy5sZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgdGhpcy5jb21tZW50cyA9IFtdO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSBmYWxzZTtcbiAgfVxuICBwdXNoVG9rZW4odG9rZW4pIHtcbiAgICB0aGlzLnRva2Vucy5sZW5ndGggPSB0aGlzLnN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgICArK3RoaXMuc3RhdGUudG9rZW5zTGVuZ3RoO1xuICB9XG4gIG5leHQoKSB7XG4gICAgdGhpcy5jaGVja0tleXdvcmRFc2NhcGVzKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50b2tlbnMpIHtcbiAgICAgIHRoaXMucHVzaFRva2VuKG5ldyBUb2tlbih0aGlzLnN0YXRlKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMuc3RhdGUuZW5kTG9jO1xuICAgIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICB9XG4gIGVhdCh0eXBlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgbWF0Y2godHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHR5cGU7XG4gIH1cbiAgY3JlYXRlTG9va2FoZWFkU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zOiBzdGF0ZS5wb3MsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHR5cGU6IHN0YXRlLnR5cGUsXG4gICAgICBzdGFydDogc3RhdGUuc3RhcnQsXG4gICAgICBlbmQ6IHN0YXRlLmVuZCxcbiAgICAgIGNvbnRleHQ6IFt0aGlzLmN1ckNvbnRleHQoKV0sXG4gICAgICBpblR5cGU6IHN0YXRlLmluVHlwZSxcbiAgICAgIHN0YXJ0TG9jOiBzdGF0ZS5zdGFydExvYyxcbiAgICAgIGxhc3RUb2tFbmRMb2M6IHN0YXRlLmxhc3RUb2tFbmRMb2MsXG4gICAgICBjdXJMaW5lOiBzdGF0ZS5jdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0OiBzdGF0ZS5saW5lU3RhcnQsXG4gICAgICBjdXJQb3NpdGlvbjogc3RhdGUuY3VyUG9zaXRpb25cbiAgICB9O1xuICB9XG4gIGxvb2thaGVhZCgpIHtcbiAgICBjb25zdCBvbGQgPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNyZWF0ZUxvb2thaGVhZFN0YXRlKG9sZCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHRydWU7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gZmFsc2U7XG4gICAgY29uc3QgY3VyciA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IG9sZDtcbiAgICByZXR1cm4gY3VycjtcbiAgfVxuICBuZXh0VG9rZW5TdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5TdGFydFNpbmNlKHRoaXMuc3RhdGUucG9zKTtcbiAgfVxuICBuZXh0VG9rZW5TdGFydFNpbmNlKHBvcykge1xuICAgIHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA9IHBvcztcbiAgICByZXR1cm4gc2tpcFdoaXRlU3BhY2UudGVzdCh0aGlzLmlucHV0KSA/IHNraXBXaGl0ZVNwYWNlLmxhc3RJbmRleCA6IHBvcztcbiAgfVxuICBsb29rYWhlYWRDaGFyQ29kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZShwb3MpIHtcbiAgICBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgcmV0dXJuIHNraXBXaGl0ZVNwYWNlSW5MaW5lLnRlc3QodGhpcy5pbnB1dCkgPyBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggOiBwb3M7XG4gIH1cbiAgbG9va2FoZWFkSW5MaW5lQ2hhckNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCkpO1xuICB9XG4gIGNvZGVQb2ludEF0UG9zKHBvcykge1xuICAgIGxldCBjcCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICgoY3AgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKytwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdHJhaWwgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodHJhaWwgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgY3AgPSAweDEwMDAwICsgKChjcCAmIDB4M2ZmKSA8PCAxMCkgKyAodHJhaWwgJiAweDNmZik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcDtcbiAgfVxuICBzZXRTdHJpY3Qoc3RyaWN0KSB7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuZm9yRWFjaCgoW3RvUGFyc2VFcnJvciwgYXRdKSA9PiB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpKTtcbiAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgfVxuICB9XG4gIGN1ckNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udGV4dFt0aGlzLnN0YXRlLmNvbnRleHQubGVuZ3RoIC0gMV07XG4gIH1cbiAgbmV4dFRva2VuKCkge1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgdGhpcy5zdGF0ZS5zdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5zdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZXRUb2tlbkZyb21Db2RlKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKTtcbiAgfVxuICBza2lwQmxvY2tDb21tZW50KGNvbW1lbnRFbmQpIHtcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihjb21tZW50RW5kLCBzdGFydCArIDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIGNvbW1lbnRFbmQubGVuZ3RoO1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQgKyAyO1xuICAgIHdoaWxlIChsaW5lQnJlYWtHLnRlc3QodGhpcy5pbnB1dCkgJiYgbGluZUJyZWFrRy5sYXN0SW5kZXggPD0gZW5kKSB7XG4gICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZUJyZWFrRy5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgICB2YWx1ZTogdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksXG4gICAgICBzdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhzdGFydCksXG4gICAgICBlbmQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZW5kICsgY29tbWVudEVuZC5sZW5ndGgpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwTGluZUNvbW1lbnQoc3RhcnRTa2lwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKCFpc05ld0xpbmUoY2gpICYmICsrdGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCBlbmQpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHN0YXJ0KSxcbiAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwU3BhY2UoKSB7XG4gICAgY29uc3Qgc3BhY2VTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gW107XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDgyMzI6XG4gICAgICAgIGNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBCbG9ja0NvbW1lbnQoXCIqL1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF0dGFjaENvbW1lbnQpIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0YWNoQ29tbWVudCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9ucy5hbm5leEIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiAmJiAoc3BhY2VTdGFydCA9PT0gMCB8fCB0aGlzLnN0YXRlLmxpbmVTdGFydCA+IHNwYWNlU3RhcnQpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBMaW5lQ29tbWVudCgzKTtcbiAgICAgICAgICAgICAgaWYgKGNvbW1lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF0dGFjaENvbW1lbnQpIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25zLmFubmV4Qikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAzMyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAzKSA9PT0gNDUpIHtcbiAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb21tZW50KGNvbW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXR0YWNoQ29tbWVudCkgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlbmQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIGNvbnN0IGNvbW1lbnRXaGl0ZXNwYWNlID0ge1xuICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhzcGFjZVN0YXJ0KSxcbiAgICAgICAgZW5kOiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKGVuZCksXG4gICAgICAgIGNvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nTm9kZTogbnVsbCxcbiAgICAgICAgdHJhaWxpbmdOb2RlOiBudWxsLFxuICAgICAgICBjb250YWluaW5nTm9kZTogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrLnB1c2goY29tbWVudFdoaXRlc3BhY2UpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLnN0YXRlLmVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUuZW5kTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHZhbDtcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gICAgfVxuICB9XG4gIHJlcGxhY2VUb2tlbih0eXBlKSB7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQoKTtcbiAgfVxuICByZWFkVG9rZW5fbnVtYmVyU2lnbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IDAgJiYgdGhpcy5yZWFkVG9rZW5faW50ZXJwcmV0ZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9zID0gdGhpcy5zdGF0ZS5wb3MgKyAxO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHRQb3MpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDEyMyB8fCBuZXh0ID09PSA5MSAmJiB0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpID09PSBcImJhclwiKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UobmV4dCA9PT0gMTIzID8gRXJyb3JzLlJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlIDogRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgaWYgKG5leHQgPT09IDEyMykge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHQpKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKG5leHQpKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IDkyKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDI3LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2RvdCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDQ2KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAzO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE2KTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX3NsYXNoKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzEsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDU2LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2ludGVycHJldGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyAhPT0gMCB8fCB0aGlzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY2ggIT09IDMzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAxO1xuICAgIHdoaWxlICghaXNOZXdMaW5lKGNoKSAmJiArK3RoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMjgsIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGxldCB0eXBlID0gY29kZSA9PT0gNDIgPyA1NSA6IDU0O1xuICAgIGxldCB3aWR0aCA9IDE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgICB0eXBlID0gNTc7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gY29kZSA9PT0gMzcgPyAzMyA6IDMwO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKHR5cGUsIHdpZHRoKTtcbiAgfVxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gNDEgOiA0MiwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIGlmIChuZXh0ID09PSA2Mikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDM5LCAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDkzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbig0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IDQzIDogNDUsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9jYXJldCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxICYmICF0aGlzLnN0YXRlLmluVHlwZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMiwgMik7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiXl5cIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNywgMik7XG4gICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGxvb2thaGVhZENoID09PSA5NCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCg0NCwgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9hdFNpZ24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiQEBcIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzOCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMjYsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNCwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNTMsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjApIHtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUxLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0NywgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYyKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyBzaXplKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzMCwgc2l6ZSArIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUyLCBzaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDYsIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxOSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyAyOSA6IDM1LCAxKTtcbiAgfVxuICByZWFkVG9rZW5fcXVlc3Rpb24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGNvbnN0IG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICBpZiAobmV4dDIgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0MCwgMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA0NiAmJiAhKG5leHQyID49IDQ4ICYmIG5leHQyIDw9IDU3KSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTgpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNyk7XG4gICAgfVxuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZG90KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTApO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQxOlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDExKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA1OTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDkxOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbig2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjU6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uQmluZFwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaE9wKDE1LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIHRoaXMucmVhZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0ODpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigxNik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA0OTpcbiAgICAgIGNhc2UgNTA6XG4gICAgICBjYXNlIDUxOlxuICAgICAgY2FzZSA1MjpcbiAgICAgIGNhc2UgNTM6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSA1NTpcbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDU3OlxuICAgICAgICB0aGlzLnJlYWROdW1iZXIoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdGhpcy5yZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSA0MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI0OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2NhcmV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDM6XG4gICAgICBjYXNlIDQ1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MTpcbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICB0aGlzLmZpbmlzaE9wKDM2LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fYXRTaWduKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MjpcbiAgICAgICAgdGhpcy5yZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgICAgICB0aGlzLnJlYWRXb3JkKGNvZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JVbmV4cGVjdGVkVG9rZW4sIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSwge1xuICAgICAgdW5leHBlY3RlZDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9KTtcbiAgfVxuICBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBzaXplO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuICByZWFkUmVnZXhwKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQgKyAxO1xuICAgIGxldCBlc2NhcGVkLCBpbkNsYXNzO1xuICAgIGxldCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKDs7ICsrcG9zKSB7XG4gICAgICBpZiAocG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFJlZ0V4cCwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkUmVnRXhwLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gOTEpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTMgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IDkyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgcG9zKTtcbiAgICArK3BvcztcbiAgICBsZXQgbW9kcyA9IFwiXCI7XG4gICAgY29uc3QgbmV4dFBvcyA9ICgpID0+IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgcG9zICsgMiAtIHN0YXJ0KTtcbiAgICB3aGlsZSAocG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhwb3MpO1xuICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgICAgaWYgKFZBTElEX1JFR0VYX0ZMQUdTLmhhcyhjcCkpIHtcbiAgICAgICAgaWYgKGNwID09PSAxMTgpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInVcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNwID09PSAxMTcpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInZcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RzLmluY2x1ZGVzKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUmVnRXhwRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyQ2hhcihjcCkgfHwgY3AgPT09IDkyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1hbGZvcm1lZFJlZ0V4cEZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIG1vZHMgKz0gY2hhcjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzgsIHtcbiAgICAgIHBhdHRlcm46IGNvbnRlbnQsXG4gICAgICBmbGFnczogbW9kc1xuICAgIH0pO1xuICB9XG4gIHJlYWRJbnQocmFkaXgsIGxlbiwgZm9yY2VMZW4gPSBmYWxzZSwgYWxsb3dOdW1TZXBhcmF0b3IgPSB0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbixcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50LCBmYWxzZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmVhZFJhZGl4TnVtYmVyKHJhZGl4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgIGNvbnN0IHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMiksIHtcbiAgICAgICAgcmFkaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdJbnQpIHtcbiAgICAgIGNvbnN0IHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKS5yZXBsYWNlKC9bX25dL2csIFwiXCIpO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzYsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGlzRmxvYXQgPSBmYWxzZTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICBsZXQgaGFzRXhwb25lbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNPY3RhbCA9IGZhbHNlO1xuICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTnVtYmVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBoYXNMZWFkaW5nWmVybyA9IHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgICBpZiAoaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgIGNvbnN0IGludGVnZXIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB0aGlzLnJlY29yZFN0cmljdE1vZGVFcnJvcnMoRXJyb3JzLlN0cmljdE9jdGFsTGl0ZXJhbCwgc3RhcnRMb2MpO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgICBjb25zdCB1bmRlcnNjb3JlUG9zID0gaW50ZWdlci5pbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKHVuZGVyc2NvcmVQb3MgPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvciwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCB1bmRlcnNjb3JlUG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzT2N0YWwgPSBoYXNMZWFkaW5nWmVybyAmJiAhL1s4OV0vLnRlc3QoaW50ZWdlcik7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIWlzT2N0YWwpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFpc09jdGFsKSB7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JNaXNzaW5nRXhwb25lbnQsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAxMTApIHtcbiAgICAgIGlmIChpc0Zsb2F0IHx8IGhhc0xlYWRpbmdaZXJvKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRCaWdJbnRMaXRlcmFsLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlY2ltYWxcIiwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgIGlmIChoYXNFeHBvbmVudCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHZhciBpc0RlY2ltYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19tbl0vZywgXCJcIik7XG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzNiwgc3RyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRGVjaW1hbCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzcsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IGlzT2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWRDb2RlUG9pbnQodGhyb3dPbkludmFsaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRDb2RlUG9pbnQodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRocm93T25JbnZhbGlkLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbiAgcmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cixcbiAgICAgIHBvcyxcbiAgICAgIGN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnRcbiAgICB9ID0gcmVhZFN0cmluZ0NvbnRlbnRzKHF1b3RlID09PSAzNCA/IFwiZG91YmxlXCIgOiBcInNpbmdsZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfc3RyaW5nKTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IHBvcyArIDE7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgdGhpcy5zdGF0ZS5jdXJMaW5lID0gY3VyTGluZTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgc3RyKTtcbiAgfVxuICByZWFkVGVtcGxhdGVDb250aW51YXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgOCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgdGhpcy5yZWFkVGVtcGxhdGVUb2tlbigpO1xuICB9XG4gIHJlYWRUZW1wbGF0ZVRva2VuKCkge1xuICAgIGNvbnN0IG9wZW5pbmcgPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBmaXJzdEludmFsaWRMb2MsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhcInRlbXBsYXRlXCIsIHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zICsgMSwgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c190ZW1wbGF0ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgaWYgKGZpcnN0SW52YWxpZExvYykge1xuICAgICAgdGhpcy5zdGF0ZS5maXJzdEludmFsaWRUZW1wbGF0ZUVzY2FwZVBvcyA9IG5ldyBQb3NpdGlvbihmaXJzdEludmFsaWRMb2MuY3VyTGluZSwgZmlyc3RJbnZhbGlkTG9jLnBvcyAtIGZpcnN0SW52YWxpZExvYy5saW5lU3RhcnQsIHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZmlyc3RJbnZhbGlkTG9jLnBvcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dC5jb2RlUG9pbnRBdChwb3MpID09PSA5Nikge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNCwgZmlyc3RJbnZhbGlkTG9jID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcImBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zKys7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDI1LCBmaXJzdEludmFsaWRMb2MgPyBudWxsIDogb3BlbmluZyArIHN0ciArIFwiJHtcIik7XG4gICAgfVxuICB9XG4gIHJlY29yZFN0cmljdE1vZGVFcnJvcnModG9QYXJzZUVycm9yLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmICF0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5zZXQoaW5kZXgsIFt0b1BhcnNlRXJyb3IsIGF0XSk7XG4gICAgfVxuICB9XG4gIHJlYWRXb3JkMShmaXJzdENvZGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgbGV0IGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAoZmlyc3RDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IGZpcnN0Q29kZSA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZXNjU3RhcnQgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJDaGVjayA9IHRoaXMuc3RhdGUucG9zID09PSBzdGFydCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcjtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKSAhPT0gMTE3KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1VuaWNvZGVFc2NhcGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBjb25zdCBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQodHJ1ZSk7XG4gICAgICAgIGlmIChlc2MgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGVjayhlc2MpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Fc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllciwgZXNjU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JkICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgcmVhZFdvcmQoZmlyc3RDb2RlKSB7XG4gICAgY29uc3Qgd29yZCA9IHRoaXMucmVhZFdvcmQxKGZpcnN0Q29kZSk7XG4gICAgY29uc3QgdHlwZSA9IGtleXdvcmRzJDEuZ2V0KHdvcmQpO1xuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgdG9rZW5MYWJlbE5hbWUodHlwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzMiwgd29yZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrS2V5d29yZEVzY2FwZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzS2V5d29yZCh0eXBlKSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IHRva2VuTGFiZWxOYW1lKHR5cGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGVycm9yID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZXJyb3JSZWNvdmVyeSkgdGhyb3cgZXJyb3I7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSB0aGlzLnN0YXRlLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgcmFpc2VPdmVyd3JpdGUodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHBvcyA9IGxvYy5pbmRleDtcbiAgICBjb25zdCBlcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBmb3IgKGxldCBpID0gZXJyb3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBlcnJvciA9IGVycm9yc1tpXTtcbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPT09IHBvcykge1xuICAgICAgICByZXR1cm4gZXJyb3JzW2ldID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubG9jLmluZGV4IDwgcG9zKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge31cbiAgdW5leHBlY3RlZChsb2MsIHR5cGUpIHtcbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW4sIGxvYyAhPSBudWxsID8gbG9jIDogdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgZXhwZWN0ZWQ6IHR5cGUgPyB0b2tlbkxhYmVsTmFtZSh0eXBlKSA6IG51bGxcbiAgICB9KTtcbiAgfVxuICBleHBlY3RQbHVnaW4ocGx1Z2luTmFtZSwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKHBsdWdpbk5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1BsdWdpbiwgbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICBtaXNzaW5nUGx1Z2luOiBbcGx1Z2luTmFtZV1cbiAgICB9KTtcbiAgfVxuICBleHBlY3RPbmVQbHVnaW4ocGx1Z2luTmFtZXMpIHtcbiAgICBpZiAoIXBsdWdpbk5hbWVzLnNvbWUobmFtZSA9PiB0aGlzLmhhc1BsdWdpbihuYW1lKSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdPbmVPZlBsdWdpbnMsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgbWlzc2luZ1BsdWdpbjogcGx1Z2luTmFtZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlcnJvckJ1aWxkZXIoZXJyb3IpIHtcbiAgICByZXR1cm4gKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSA9PiB7XG4gICAgICB0aGlzLnJhaXNlKGVycm9yLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgfTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJpdmF0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHRoaXMubG9uZUFjY2Vzc29ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgQ2xhc3NTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy51bmRlZmluZWRQcml2YXRlTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgY3VycmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG4gIGVudGVyKCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChuZXcgQ2xhc3NTY29wZSgpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IG9sZENsYXNzU2NvcGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBsb2NdIG9mIEFycmF5LmZyb20ob2xkQ2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMpKSB7XG4gICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICBpZiAoIWN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIGN1cnJlbnQudW5kZWZpbmVkUHJpdmF0ZU5hbWVzLnNldChuYW1lLCBsb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlci5yYWlzZShFcnJvcnMuSW52YWxpZFByaXZhdGVGaWVsZFJlc29sdXRpb24sIGxvYywge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBkZWNsYXJlUHJpdmF0ZU5hbWUobmFtZSwgZWxlbWVudFR5cGUsIGxvYykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVOYW1lcyxcbiAgICAgIGxvbmVBY2Nlc3NvcnMsXG4gICAgICB1bmRlZmluZWRQcml2YXRlTmFtZXNcbiAgICB9ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgbGV0IHJlZGVmaW5lZCA9IHByaXZhdGVOYW1lcy5oYXMobmFtZSk7XG4gICAgaWYgKGVsZW1lbnRUeXBlICYgMykge1xuICAgICAgY29uc3QgYWNjZXNzb3IgPSByZWRlZmluZWQgJiYgbG9uZUFjY2Vzc29ycy5nZXQobmFtZSk7XG4gICAgICBpZiAoYWNjZXNzb3IpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGljID0gYWNjZXNzb3IgJiA0O1xuICAgICAgICBjb25zdCBuZXdTdGF0aWMgPSBlbGVtZW50VHlwZSAmIDQ7XG4gICAgICAgIGNvbnN0IG9sZEtpbmQgPSBhY2Nlc3NvciAmIDM7XG4gICAgICAgIGNvbnN0IG5ld0tpbmQgPSBlbGVtZW50VHlwZSAmIDM7XG4gICAgICAgIHJlZGVmaW5lZCA9IG9sZEtpbmQgPT09IG5ld0tpbmQgfHwgb2xkU3RhdGljICE9PSBuZXdTdGF0aWM7XG4gICAgICAgIGlmICghcmVkZWZpbmVkKSBsb25lQWNjZXNzb3JzLmRlbGV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlZGVmaW5lZCkge1xuICAgICAgICBsb25lQWNjZXNzb3JzLnNldChuYW1lLCBlbGVtZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZWRlZmluZWQpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5Qcml2YXRlTmFtZVJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHByaXZhdGVOYW1lcy5hZGQobmFtZSk7XG4gICAgdW5kZWZpbmVkUHJpdmF0ZU5hbWVzLmRlbGV0ZShuYW1lKTtcbiAgfVxuICB1c2VQcml2YXRlTmFtZShuYW1lLCBsb2MpIHtcbiAgICBsZXQgY2xhc3NTY29wZTtcbiAgICBmb3IgKGNsYXNzU2NvcGUgb2YgdGhpcy5zdGFjaykge1xuICAgICAgaWYgKGNsYXNzU2NvcGUucHJpdmF0ZU5hbWVzLmhhcyhuYW1lKSkgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xhc3NTY29wZSkge1xuICAgICAgY2xhc3NTY29wZS51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbG9jLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUgPSAwKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgfVxuICBjYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gMiB8fCB0aGlzLnR5cGUgPT09IDE7XG4gIH1cbiAgaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAzO1xuICB9XG59XG5jbGFzcyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUgZXh0ZW5kcyBFeHByZXNzaW9uU2NvcGUge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIodHlwZSk7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycyA9IG5ldyBNYXAoKTtcbiAgfVxuICByZWNvcmREZWNsYXJhdGlvbkVycm9yKFBhcnNpbmdFcnJvckNsYXNzLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5zZXQoaW5kZXgsIFtQYXJzaW5nRXJyb3JDbGFzcywgYXRdKTtcbiAgfVxuICBjbGVhckRlY2xhcmF0aW9uRXJyb3IoaW5kZXgpIHtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLmRlbGV0ZShpbmRleCk7XG4gIH1cbiAgaXRlcmF0ZUVycm9ycyhpdGVyYXRvcikge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZm9yRWFjaChpdGVyYXRvcik7XG4gIH1cbn1cbmNsYXNzIEV4cHJlc3Npb25TY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YWNrID0gW25ldyBFeHByZXNzaW9uU2NvcGUoKV07XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gIH1cbiAgZW50ZXIoc2NvcGUpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goc2NvcGUpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgfVxuICByZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKHRvUGFyc2VFcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUubG9jLnN0YXJ0O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlICghc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBpZiAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2NvcGUucmVjb3JkRGVjbGFyYXRpb25FcnJvcih0b1BhcnNlRXJyb3IsIG9yaWdpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgfVxuICAgIHRoaXMucGFyc2VyLnJhaXNlKHRvUGFyc2VFcnJvciwgb3JpZ2luKTtcbiAgfVxuICByZWNvcmRBcnJvd1BhcmFtZXRlckJpbmRpbmdFcnJvcihlcnJvciwgbm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLmxvYy5zdGFydDtcbiAgICBpZiAoc2NvcGUuaXNDZXJ0YWlubHlQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZShlcnJvciwgb3JpZ2luKTtcbiAgICB9IGVsc2UgaWYgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlY29yZEFzeW5jQXJyb3dQYXJhbWV0ZXJzRXJyb3IoYXQpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICB3aGlsZSAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChzY29wZS50eXBlID09PSAyKSB7XG4gICAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIGF0KTtcbiAgICAgIH1cbiAgICAgIHNjb3BlID0gc3RhY2tbLS1pXTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVBc1BhdHRlcm4oKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjdXJyZW50U2NvcGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIWN1cnJlbnRTY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGN1cnJlbnRTY29wZS5pdGVyYXRlRXJyb3JzKChbdG9QYXJzZUVycm9yLCBsb2NdKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlci5yYWlzZSh0b1BhcnNlRXJyb3IsIGxvYyk7XG4gICAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDI7XG4gICAgICBsZXQgc2NvcGUgPSBzdGFja1tpXTtcbiAgICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5jbGVhckRlY2xhcmF0aW9uRXJyb3IobG9jLmluZGV4KTtcbiAgICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBuZXdQYXJhbWV0ZXJEZWNsYXJhdGlvblNjb3BlKCkge1xuICByZXR1cm4gbmV3IEV4cHJlc3Npb25TY29wZSgzKTtcbn1cbmZ1bmN0aW9uIG5ld0Fycm93SGVhZFNjb3BlKCkge1xuICByZXR1cm4gbmV3IEFycm93SGVhZFBhcnNpbmdTY29wZSgxKTtcbn1cbmZ1bmN0aW9uIG5ld0FzeW5jQXJyb3dTY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBBcnJvd0hlYWRQYXJzaW5nU2NvcGUoMik7XG59XG5mdW5jdGlvbiBuZXdFeHByZXNzaW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKCk7XG59XG5jbGFzcyBQcm9kdWN0aW9uUGFyYW1ldGVySGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhY2tzID0gW107XG4gIH1cbiAgZW50ZXIoZmxhZ3MpIHtcbiAgICB0aGlzLnN0YWNrcy5wdXNoKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIHRoaXMuc3RhY2tzLnBvcCgpO1xuICB9XG4gIGN1cnJlbnRGbGFncygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja3NbdGhpcy5zdGFja3MubGVuZ3RoIC0gMV07XG4gIH1cbiAgZ2V0IGhhc0F3YWl0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgaGFzWWllbGQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgMSkgPiAwO1xuICB9XG4gIGdldCBoYXNSZXR1cm4oKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgNCkgPiAwO1xuICB9XG4gIGdldCBoYXNJbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiA4KSA+IDA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgaXNHZW5lcmF0b3IpIHtcbiAgcmV0dXJuIChpc0FzeW5jID8gMiA6IDApIHwgKGlzR2VuZXJhdG9yID8gMSA6IDApO1xufVxuY2xhc3MgVXRpbFBhcnNlciBleHRlbmRzIFRva2VuaXplciB7XG4gIGFkZEV4dHJhKG5vZGUsIGtleSwgdmFsdWUsIGVudW1lcmFibGUgPSB0cnVlKSB7XG4gICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgbGV0IHtcbiAgICAgIGV4dHJhXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKGV4dHJhID09IG51bGwpIHtcbiAgICAgIGV4dHJhID0ge307XG4gICAgICBub2RlLmV4dHJhID0gZXh0cmE7XG4gICAgfVxuICAgIGlmIChlbnVtZXJhYmxlKSB7XG4gICAgICBleHRyYVtrZXldID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHRyYSwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaXNDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdG9rZW4gJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gIH1cbiAgaXNVbnBhcnNlZENvbnRleHR1YWwobmFtZVN0YXJ0LCBuYW1lKSB7XG4gICAgY29uc3QgbmFtZUVuZCA9IG5hbWVTdGFydCArIG5hbWUubGVuZ3RoO1xuICAgIGlmICh0aGlzLmlucHV0LnNsaWNlKG5hbWVTdGFydCwgbmFtZUVuZCkgPT09IG5hbWUpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuYW1lRW5kKTtcbiAgICAgIHJldHVybiAhKGlzSWRlbnRpZmllckNoYXIobmV4dENoKSB8fCAobmV4dENoICYgMHhmYzAwKSA9PT0gMHhkODAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuICBlYXRDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cGVjdENvbnRleHR1YWwodG9rZW4sIHRvUGFyc2VFcnJvcikge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgaWYgKHRvUGFyc2VFcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0b2tlbik7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFNlbWljb2xvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNDApIHx8IHRoaXMubWF0Y2goOCkgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKTtcbiAgfVxuICBoYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpLCB0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgfVxuICBoYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5lbmQsIHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cbiAgaXNMaW5lVGVybWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoMTMpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgc2VtaWNvbG9uKGFsbG93QXNpID0gdHJ1ZSkge1xuICAgIGlmIChhbGxvd0FzaSA/IHRoaXMuaXNMaW5lVGVybWluYXRvcigpIDogdGhpcy5lYXQoMTMpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1NlbWljb2xvbiwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBleHBlY3QodHlwZSwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKGxvYywgdHlwZSk7XG4gICAgfVxuICB9XG4gIHRyeVBhcnNlKGZuLCBvbGRTdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmbigobm9kZSA9IG51bGwpID0+IHtcbiAgICAgICAgYWJvcnRTaWduYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRocm93IGFib3J0U2lnbmFsO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoID4gb2xkU3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoID0gZmFpbFN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgdGhyb3duOiBmYWxzZSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZmFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aHJvd246IHRydWUsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZFeHByZXNzaW9uRXJyb3JzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgc2hvcnRoYW5kQXNzaWduTG9jLFxuICAgICAgZG91YmxlUHJvdG9Mb2MsXG4gICAgICBwcml2YXRlS2V5TG9jLFxuICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzTG9jXG4gICAgfSA9IHJlZkV4cHJlc3Npb25FcnJvcnM7XG4gICAgY29uc3QgaGFzRXJyb3JzID0gISFzaG9ydGhhbmRBc3NpZ25Mb2MgfHwgISFkb3VibGVQcm90b0xvYyB8fCAhIW9wdGlvbmFsUGFyYW1ldGVyc0xvYyB8fCAhIXByaXZhdGVLZXlMb2M7XG4gICAgaWYgKCFhbmRUaHJvdykge1xuICAgICAgcmV0dXJuIGhhc0Vycm9ycztcbiAgICB9XG4gICAgaWYgKHNob3J0aGFuZEFzc2lnbkxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJJbml0aWFsaXplZE5hbWUsIHNob3J0aGFuZEFzc2lnbkxvYyk7XG4gICAgfVxuICAgIGlmIChkb3VibGVQcm90b0xvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVQcm90bywgZG91YmxlUHJvdG9Mb2MpO1xuICAgIH1cbiAgICBpZiAocHJpdmF0ZUtleUxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUHJpdmF0ZUZpZWxkLCBwcml2YXRlS2V5TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsUGFyYW1ldGVyc0xvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQob3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICB9XG4gIH1cbiAgaXNMaXRlcmFsUHJvcGVydHlOYW1lKCkge1xuICAgIHJldHVybiB0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIGlzUHJpdmF0ZU5hbWUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZU5hbWVcIjtcbiAgfVxuICBnZXRQcml2YXRlTmFtZVNWKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pZC5uYW1lO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikgJiYgdGhpcy5pc1ByaXZhdGVOYW1lKG5vZGUucHJvcGVydHkpO1xuICB9XG4gIGlzT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIjtcbiAgfVxuICBpc09iamVjdE1ldGhvZChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIjtcbiAgfVxuICBpbml0aWFsaXplU2NvcGVzKGluTW9kdWxlID0gdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCIpIHtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIGNvbnN0IG9sZEV4cG9ydGVkSWRlbnRpZmllcnMgPSB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG9sZEluTW9kdWxlID0gdGhpcy5pbk1vZHVsZTtcbiAgICB0aGlzLmluTW9kdWxlID0gaW5Nb2R1bGU7XG4gICAgY29uc3Qgb2xkU2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGNvbnN0IFNjb3BlSGFuZGxlciA9IHRoaXMuZ2V0U2NvcGVIYW5kbGVyKCk7XG4gICAgdGhpcy5zY29wZSA9IG5ldyBTY29wZUhhbmRsZXIodGhpcywgaW5Nb2R1bGUpO1xuICAgIGNvbnN0IG9sZFByb2RQYXJhbSA9IHRoaXMucHJvZFBhcmFtO1xuICAgIHRoaXMucHJvZFBhcmFtID0gbmV3IFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyKCk7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuY2xhc3NTY29wZTtcbiAgICB0aGlzLmNsYXNzU2NvcGUgPSBuZXcgQ2xhc3NTY29wZUhhbmRsZXIodGhpcyk7XG4gICAgY29uc3Qgb2xkRXhwcmVzc2lvblNjb3BlID0gdGhpcy5leHByZXNzaW9uU2NvcGU7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBuZXcgRXhwcmVzc2lvblNjb3BlSGFuZGxlcih0aGlzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBvbGRFeHBvcnRlZElkZW50aWZpZXJzO1xuICAgICAgdGhpcy5pbk1vZHVsZSA9IG9sZEluTW9kdWxlO1xuICAgICAgdGhpcy5zY29wZSA9IG9sZFNjb3BlO1xuICAgICAgdGhpcy5wcm9kUGFyYW0gPSBvbGRQcm9kUGFyYW07XG4gICAgICB0aGlzLmNsYXNzU2NvcGUgPSBvbGRDbGFzc1Njb3BlO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUgPSBvbGRFeHByZXNzaW9uU2NvcGU7XG4gICAgfTtcbiAgfVxuICBlbnRlckluaXRpYWxTY29wZXMoKSB7XG4gICAgbGV0IHBhcmFtRmxhZ3MgPSAwO1xuICAgIGlmICh0aGlzLmluTW9kdWxlKSB7XG4gICAgICBwYXJhbUZsYWdzIHw9IDI7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZW50ZXIoMSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIocGFyYW1GbGFncyk7XG4gIH1cbiAgY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleUxvY1xuICAgIH0gPSByZWZFeHByZXNzaW9uRXJyb3JzO1xuICAgIGlmIChwcml2YXRlS2V5TG9jICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHByaXZhdGVLZXlMb2MpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbkVycm9ycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduTG9jID0gbnVsbDtcbiAgICB0aGlzLmRvdWJsZVByb3RvTG9jID0gbnVsbDtcbiAgICB0aGlzLnByaXZhdGVLZXlMb2MgPSBudWxsO1xuICAgIHRoaXMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKGxvYyk7XG4gICAgaWYgKHBhcnNlciAhPSBudWxsICYmIHBhcnNlci5vcHRpb25zLnJhbmdlcykgdGhpcy5yYW5nZSA9IFtwb3MsIDBdO1xuICAgIGlmIChwYXJzZXIgIT0gbnVsbCAmJiBwYXJzZXIuZmlsZW5hbWUpIHRoaXMubG9jLmZpbGVuYW1lID0gcGFyc2VyLmZpbGVuYW1lO1xuICB9XG59XG5jb25zdCBOb2RlUHJvdG90eXBlID0gTm9kZS5wcm90b3R5cGU7XG57XG4gIE5vZGVQcm90b3R5cGUuX19jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUodW5kZWZpbmVkLCB0aGlzLnN0YXJ0LCB0aGlzLmxvYy5zdGFydCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGtleSAhPT0gXCJsZWFkaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwidHJhaWxpbmdDb21tZW50c1wiICYmIGtleSAhPT0gXCJpbm5lckNvbW1lbnRzXCIpIHtcbiAgICAgICAgbmV3Tm9kZVtrZXldID0gdGhpc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsb25lUGxhY2Vob2xkZXIobm9kZSkge1xuICByZXR1cm4gY2xvbmVJZGVudGlmaWVyKG5vZGUpO1xufVxuZnVuY3Rpb24gY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGxvYyxcbiAgICByYW5nZSxcbiAgICBleHRyYSxcbiAgICBuYW1lXG4gIH0gPSBub2RlO1xuICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE5vZGVQcm90b3R5cGUpO1xuICBjbG9uZWQudHlwZSA9IHR5cGU7XG4gIGNsb25lZC5zdGFydCA9IHN0YXJ0O1xuICBjbG9uZWQuZW5kID0gZW5kO1xuICBjbG9uZWQubG9jID0gbG9jO1xuICBjbG9uZWQucmFuZ2UgPSByYW5nZTtcbiAgY2xvbmVkLmV4dHJhID0gZXh0cmE7XG4gIGNsb25lZC5uYW1lID0gbmFtZTtcbiAgaWYgKHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuZnVuY3Rpb24gY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHR5cGUsXG4gICAgc3RhcnQsXG4gICAgZW5kLFxuICAgIGxvYyxcbiAgICByYW5nZSxcbiAgICBleHRyYVxuICB9ID0gbm9kZTtcbiAgaWYgKHR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgIHJldHVybiBjbG9uZVBsYWNlaG9sZGVyKG5vZGUpO1xuICB9XG4gIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvdHlwZSk7XG4gIGNsb25lZC50eXBlID0gdHlwZTtcbiAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gIGNsb25lZC5lbmQgPSBlbmQ7XG4gIGNsb25lZC5sb2MgPSBsb2M7XG4gIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICBpZiAobm9kZS5yYXcgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsb25lZC5yYXcgPSBub2RlLnJhdztcbiAgfSBlbHNlIHtcbiAgICBjbG9uZWQuZXh0cmEgPSBleHRyYTtcbiAgfVxuICBjbG9uZWQudmFsdWUgPSBub2RlLnZhbHVlO1xuICByZXR1cm4gY2xvbmVkO1xufVxuY2xhc3MgTm9kZVV0aWxzIGV4dGVuZHMgVXRpbFBhcnNlciB7XG4gIHN0YXJ0Tm9kZSgpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBsb2MuaW5kZXgsIGxvYyk7XG4gIH1cbiAgc3RhcnROb2RlQXQobG9jKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIGxvYy5pbmRleCwgbG9jKTtcbiAgfVxuICBzdGFydE5vZGVBdE5vZGUodHlwZSkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgfVxuICBmaW5pc2hOb2RlKG5vZGUsIHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgbm9kZS50eXBlID0gdHlwZTtcbiAgICBub2RlLmVuZCA9IGVuZExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBlbmRMb2MuaW5kZXg7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hdHRhY2hDb21tZW50KSB0aGlzLnByb2Nlc3NDb21tZW50KG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIG5vZGUuc3RhcnQgPSBzdGFydExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5zdGFydCA9IHN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSBub2RlLnJhbmdlWzBdID0gc3RhcnRMb2MuaW5kZXg7XG4gIH1cbiAgcmVzZXRFbmRMb2NhdGlvbihub2RlLCBlbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpIHtcbiAgICBub2RlLmVuZCA9IGVuZExvYy5pbmRleDtcbiAgICBub2RlLmxvYy5lbmQgPSBlbmRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIG5vZGUucmFuZ2VbMV0gPSBlbmRMb2MuaW5kZXg7XG4gIH1cbiAgcmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUobm9kZSwgbG9jYXRpb25Ob2RlKSB7XG4gICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb24obm9kZSwgbG9jYXRpb25Ob2RlLmxvYy5zdGFydCk7XG4gIH1cbn1cbmNvbnN0IHJlc2VydmVkVHlwZXMgPSBuZXcgU2V0KFtcIl9cIiwgXCJhbnlcIiwgXCJib29sXCIsIFwiYm9vbGVhblwiLCBcImVtcHR5XCIsIFwiZXh0ZW5kc1wiLCBcImZhbHNlXCIsIFwiaW50ZXJmYWNlXCIsIFwibWl4ZWRcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwic3RhdGljXCIsIFwic3RyaW5nXCIsIFwidHJ1ZVwiLCBcInR5cGVvZlwiLCBcInZvaWRcIl0pO1xuY29uc3QgRmxvd0Vycm9ycyA9IFBhcnNlRXJyb3JFbnVtYGZsb3dgKHtcbiAgQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdzogXCJBbWJpZ3VvdXMgZXhwcmVzc2lvbjogd3JhcCB0aGUgYXJyb3cgZnVuY3Rpb25zIGluIHBhcmVudGhlc2VzIHRvIGRpc2FtYmlndWF0ZS5cIixcbiAgQW1iaWd1b3VzRGVjbGFyZU1vZHVsZUtpbmQ6IFwiRm91bmQgYm90aCBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2AgYW5kIGBkZWNsYXJlIGV4cG9ydGAgaW4gdGhlIHNhbWUgbW9kdWxlLiBNb2R1bGVzIGNhbiBvbmx5IGhhdmUgMSBzaW5jZSB0aGV5IGFyZSBlaXRoZXIgYW4gRVMgbW9kdWxlIG9yIHRoZXkgYXJlIGEgQ29tbW9uSlMgbW9kdWxlLlwiLFxuICBBc3NpZ25SZXNlcnZlZFR5cGU6ICh7XG4gICAgcmVzZXJ2ZWRUeXBlXG4gIH0pID0+IGBDYW5ub3Qgb3ZlcndyaXRlIHJlc2VydmVkIHR5cGUgJHtyZXNlcnZlZFR5cGV9LmAsXG4gIERlY2xhcmVDbGFzc0VsZW1lbnQ6IFwiVGhlIGBkZWNsYXJlYCBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gY2xhc3MgZmllbGRzLlwiLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEluaXRpYWxpemVyOiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gZmllbGRzIHdpdGggdGhlIGBkZWNsYXJlYCBtb2RpZmllci5cIixcbiAgRHVwbGljYXRlRGVjbGFyZU1vZHVsZUV4cG9ydHM6IFwiRHVwbGljYXRlIGBkZWNsYXJlIG1vZHVsZS5leHBvcnRzYCBzdGF0ZW1lbnQuXCIsXG4gIEVudW1Cb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQ6ICh7XG4gICAgbWVtYmVyTmFtZSxcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgQm9vbGVhbiBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZC4gVXNlIGVpdGhlciBcXGAke21lbWJlck5hbWV9ID0gdHJ1ZSxcXGAgb3IgXFxgJHttZW1iZXJOYW1lfSA9IGZhbHNlLFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1EdXBsaWNhdGVNZW1iZXJOYW1lOiAoe1xuICAgIG1lbWJlck5hbWUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gbWVtYmVyIG5hbWVzIG5lZWQgdG8gYmUgdW5pcXVlLCBidXQgdGhlIG5hbWUgXFxgJHttZW1iZXJOYW1lfVxcYCBoYXMgYWxyZWFkeSBiZWVuIHVzZWQgYmVmb3JlIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUluY29uc2lzdGVudE1lbWJlclZhbHVlczogKHtcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgRW51bSBcXGAke2VudW1OYW1lfVxcYCBoYXMgaW5jb25zaXN0ZW50IG1lbWJlciBpbml0aWFsaXplcnMuIEVpdGhlciB1c2Ugbm8gaW5pdGlhbGl6ZXJzLCBvciBjb25zaXN0ZW50bHkgdXNlIGxpdGVyYWxzIChlaXRoZXIgYm9vbGVhbnMsIG51bWJlcnMsIG9yIHN0cmluZ3MpIGZvciBhbGwgbWVtYmVyIGluaXRpYWxpemVycy5gLFxuICBFbnVtSW52YWxpZEV4cGxpY2l0VHlwZTogKHtcbiAgICBpbnZhbGlkRW51bVR5cGUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gdHlwZSBcXGAke2ludmFsaWRFbnVtVHlwZX1cXGAgaXMgbm90IHZhbGlkLiBVc2Ugb25lIG9mIFxcYGJvb2xlYW5cXGAsIFxcYG51bWJlclxcYCwgXFxgc3RyaW5nXFxgLCBvciBcXGBzeW1ib2xcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZEV4cGxpY2l0VHlwZVVua25vd25TdXBwbGllZDogKHtcbiAgICBlbnVtTmFtZVxuICB9KSA9PiBgU3VwcGxpZWQgZW51bSB0eXBlIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBcXGBib29sZWFuXFxgLCBcXGBudW1iZXJcXGAsIFxcYHN0cmluZ1xcYCwgb3IgXFxgc3ltYm9sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclByaW1hcnlUeXBlOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWUsXG4gICAgZXhwbGljaXRUeXBlXG4gIH0pID0+IGBFbnVtIFxcYCR7ZW51bU5hbWV9XFxgIGhhcyB0eXBlIFxcYCR7ZXhwbGljaXRUeXBlfVxcYCwgc28gdGhlIGluaXRpYWxpemVyIG9mIFxcYCR7bWVtYmVyTmFtZX1cXGAgbmVlZHMgdG8gYmUgYSAke2V4cGxpY2l0VHlwZX0gbGl0ZXJhbC5gLFxuICBFbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyU3ltYm9sVHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBTeW1ib2wgZW51bSBtZW1iZXJzIGNhbm5vdCBiZSBpbml0aWFsaXplZC4gVXNlIFxcYCR7bWVtYmVyTmFtZX0sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclVua25vd25UeXBlOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYFRoZSBlbnVtIG1lbWJlciBpbml0aWFsaXplciBmb3IgXFxgJHttZW1iZXJOYW1lfVxcYCBuZWVkcyB0byBiZSBhIGxpdGVyYWwgKGVpdGhlciBhIGJvb2xlYW4sIG51bWJlciwgb3Igc3RyaW5nKSBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVyTmFtZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lLFxuICAgIHN1Z2dlc3Rpb25cbiAgfSkgPT4gYEVudW0gbWVtYmVyIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoIGxvd2VyY2FzZSAnYScgdGhyb3VnaCAneicuIEluc3RlYWQgb2YgdXNpbmcgXFxgJHttZW1iZXJOYW1lfVxcYCwgY29uc2lkZXIgdXNpbmcgXFxgJHtzdWdnZXN0aW9ufVxcYCwgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQ6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgTnVtYmVyIGVudW0gbWVtYmVycyBuZWVkIHRvIGJlIGluaXRpYWxpemVkLCBlLmcuIFxcYCR7bWVtYmVyTmFtZX0gPSAxXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bVN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQ6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYFN0cmluZyBlbnVtIG1lbWJlcnMgbmVlZCB0byBjb25zaXN0ZW50bHkgZWl0aGVyIGFsbCB1c2UgaW5pdGlhbGl6ZXJzLCBvciB1c2Ugbm8gaW5pdGlhbGl6ZXJzLCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEdldHRlck1heU5vdEhhdmVUaGlzUGFyYW06IFwiQSBnZXR0ZXIgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZTogXCJBbiBgaW1wb3J0IG1vZHVsZWAgZGVjbGFyYXRpb24gY2FuIG5vdCB1c2UgYHR5cGVgIG9yIGB0eXBlb2ZgIGtleXdvcmQuXCIsXG4gIEltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0OiBcIlRoZSBgdHlwZWAgYW5kIGB0eXBlb2ZgIGtleXdvcmRzIG9uIG5hbWVkIGltcG9ydHMgY2FuIG9ubHkgYmUgdXNlZCBvbiByZWd1bGFyIGBpbXBvcnRgIHN0YXRlbWVudHMuIEl0IGNhbm5vdCBiZSB1c2VkIHdpdGggYGltcG9ydCB0eXBlYCBvciBgaW1wb3J0IHR5cGVvZmAgc3RhdGVtZW50cy5cIixcbiAgSW5leGFjdEluc2lkZUV4YWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBhcHBlYXIgaW5zaWRlIGFuIGV4cGxpY2l0IGV4YWN0IG9iamVjdCB0eXBlLlwiLFxuICBJbmV4YWN0SW5zaWRlTm9uT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBJbmV4YWN0VmFyaWFuY2U6IFwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggY2Fubm90IGhhdmUgdmFyaWFuY2UuXCIsXG4gIEludmFsaWROb25UeXBlSW1wb3J0SW5EZWNsYXJlTW9kdWxlOiBcIkltcG9ydHMgd2l0aGluIGEgYGRlY2xhcmUgbW9kdWxlYCBib2R5IG11c3QgYWx3YXlzIGJlIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgLlwiLFxuICBNaXNzaW5nVHlwZVBhcmFtRGVmYXVsdDogXCJUeXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBuZWVkcyBhIGRlZmF1bHQsIHNpbmNlIGEgcHJlY2VkaW5nIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uIGhhcyBhIGRlZmF1bHQuXCIsXG4gIE5lc3RlZERlY2xhcmVNb2R1bGU6IFwiYGRlY2xhcmUgbW9kdWxlYCBjYW5ub3QgYmUgdXNlZCBpbnNpZGUgYW5vdGhlciBgZGVjbGFyZSBtb2R1bGVgLlwiLFxuICBOZXN0ZWRGbG93Q29tbWVudDogXCJDYW5ub3QgaGF2ZSBhIGZsb3cgY29tbWVudCBpbnNpZGUgYW5vdGhlciBmbG93IGNvbW1lbnQuXCIsXG4gIFBhdHRlcm5Jc09wdGlvbmFsOiBPYmplY3QuYXNzaWduKHtcbiAgICBtZXNzYWdlOiBcIkEgYmluZGluZyBwYXR0ZXJuIHBhcmFtZXRlciBjYW5ub3QgYmUgb3B0aW9uYWwgaW4gYW4gaW1wbGVtZW50YXRpb24gc2lnbmF0dXJlLlwiXG4gIH0sIHtcbiAgICByZWFzb25Db2RlOiBcIk9wdGlvbmFsQmluZGluZ1BhdHRlcm5cIlxuICB9KSxcbiAgU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbTogXCJBIHNldHRlciBjYW5ub3QgaGF2ZSBhIGB0aGlzYCBwYXJhbWV0ZXIuXCIsXG4gIFNwcmVhZFZhcmlhbmNlOiBcIlNwcmVhZCBwcm9wZXJ0aWVzIGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBUaGlzUGFyYW1Bbm5vdGF0aW9uUmVxdWlyZWQ6IFwiQSB0eXBlIGFubm90YXRpb24gaXMgcmVxdWlyZWQgZm9yIHRoZSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBUaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yOiBcIkNvbnN0cnVjdG9ycyBjYW5ub3QgaGF2ZSBhIGB0aGlzYCBwYXJhbWV0ZXI7IGNvbnN0cnVjdG9ycyBkb24ndCBiaW5kIGB0aGlzYCBsaWtlIG90aGVyIGZ1bmN0aW9ucy5cIixcbiAgVGhpc1BhcmFtTWF5Tm90QmVPcHRpb25hbDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBjYW5ub3QgYmUgb3B0aW9uYWwuXCIsXG4gIFRoaXNQYXJhbU11c3RCZUZpcnN0OiBcIlRoZSBgdGhpc2AgcGFyYW1ldGVyIG11c3QgYmUgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtTm9EZWZhdWx0OiBcIlRoZSBgdGhpc2AgcGFyYW1ldGVyIG1heSBub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUuXCIsXG4gIFR5cGVCZWZvcmVJbml0aWFsaXplcjogXCJUeXBlIGFubm90YXRpb25zIG11c3QgY29tZSBiZWZvcmUgZGVmYXVsdCBhc3NpZ25tZW50cywgZS5nLiBpbnN0ZWFkIG9mIGBhZ2UgPSAyNTogbnVtYmVyYCB1c2UgYGFnZTogbnVtYmVyID0gMjVgLlwiLFxuICBUeXBlQ2FzdEluUGF0dGVybjogXCJUaGUgdHlwZSBjYXN0IGV4cHJlc3Npb24gaXMgZXhwZWN0ZWQgdG8gYmUgd3JhcHBlZCB3aXRoIHBhcmVudGhlc2lzLlwiLFxuICBVbmV4cGVjdGVkRXhwbGljaXRJbmV4YWN0SW5PYmplY3Q6IFwiRXhwbGljaXQgaW5leGFjdCBzeW50YXggbXVzdCBhcHBlYXIgYXQgdGhlIGVuZCBvZiBhbiBpbmV4YWN0IG9iamVjdC5cIixcbiAgVW5leHBlY3RlZFJlc2VydmVkVHlwZTogKHtcbiAgICByZXNlcnZlZFR5cGVcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgcmVzZXJ2ZWQgdHlwZSAke3Jlc2VydmVkVHlwZX0uYCxcbiAgVW5leHBlY3RlZFJlc2VydmVkVW5kZXJzY29yZTogXCJgX2AgaXMgb25seSBhbGxvd2VkIGFzIGEgdHlwZSBhcmd1bWVudCB0byBjYWxsIG9yIG5ldy5cIixcbiAgVW5leHBlY3RlZFNwYWNlQmV0d2Vlbk1vZHVsb0NoZWNrczogXCJTcGFjZXMgYmV0d2VlbiBgJWAgYW5kIGBjaGVja3NgIGFyZSBub3QgYWxsb3dlZCBoZXJlLlwiLFxuICBVbmV4cGVjdGVkU3ByZWFkVHlwZTogXCJTcHJlYWQgb3BlcmF0b3IgY2Fubm90IGFwcGVhciBpbiBjbGFzcyBvciBpbnRlcmZhY2UgZGVmaW5pdGlvbnMuXCIsXG4gIFVuZXhwZWN0ZWRTdWJ0cmFjdGlvbk9wZXJhbmQ6ICdVbmV4cGVjdGVkIHRva2VuLCBleHBlY3RlZCBcIm51bWJlclwiIG9yIFwiYmlnaW50XCIuJyxcbiAgVW5leHBlY3RlZFRva2VuQWZ0ZXJUeXBlUGFyYW1ldGVyOiBcIkV4cGVjdGVkIGFuIGFycm93IGZ1bmN0aW9uIGFmdGVyIHRoaXMgdHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRUeXBlUGFyYW1ldGVyQmVmb3JlQXN5bmNBcnJvd0Z1bmN0aW9uOiBcIlR5cGUgcGFyYW1ldGVycyBtdXN0IGNvbWUgYWZ0ZXIgdGhlIGFzeW5jIGtleXdvcmQsIGUuZy4gaW5zdGVhZCBvZiBgPFQ+IGFzeW5jICgpID0+IHt9YCwgdXNlIGBhc3luYyA8VD4oKSA9PiB7fWAuXCIsXG4gIFVuc3VwcG9ydGVkRGVjbGFyZUV4cG9ydEtpbmQ6ICh7XG4gICAgdW5zdXBwb3J0ZWRFeHBvcnRLaW5kLFxuICAgIHN1Z2dlc3Rpb25cbiAgfSkgPT4gYFxcYGRlY2xhcmUgZXhwb3J0ICR7dW5zdXBwb3J0ZWRFeHBvcnRLaW5kfVxcYCBpcyBub3Qgc3VwcG9ydGVkLiBVc2UgXFxgJHtzdWdnZXN0aW9ufVxcYCBpbnN0ZWFkLmAsXG4gIFVuc3VwcG9ydGVkU3RhdGVtZW50SW5EZWNsYXJlTW9kdWxlOiBcIk9ubHkgZGVjbGFyZXMgYW5kIHR5cGUgaW1wb3J0cyBhcmUgYWxsb3dlZCBpbnNpZGUgZGVjbGFyZSBtb2R1bGUuXCIsXG4gIFVudGVybWluYXRlZEZsb3dDb21tZW50OiBcIlVudGVybWluYXRlZCBmbG93LWNvbW1lbnQuXCJcbn0pO1xuZnVuY3Rpb24gaXNFc01vZHVsZVR5cGUoYm9keUVsZW1lbnQpIHtcbiAgcmV0dXJuIGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIgfHwgYm9keUVsZW1lbnQudHlwZSA9PT0gXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiAmJiAoIWJvZHlFbGVtZW50LmRlY2xhcmF0aW9uIHx8IGJvZHlFbGVtZW50LmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiVHlwZUFsaWFzXCIgJiYgYm9keUVsZW1lbnQuZGVjbGFyYXRpb24udHlwZSAhPT0gXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiKTtcbn1cbmZ1bmN0aW9uIGhhc1R5cGVJbXBvcnRLaW5kKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiO1xufVxuY29uc3QgZXhwb3J0U3VnZ2VzdGlvbnMgPSB7XG4gIGNvbnN0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICBsZXQ6IFwiZGVjbGFyZSBleHBvcnQgdmFyXCIsXG4gIHR5cGU6IFwiZXhwb3J0IHR5cGVcIixcbiAgaW50ZXJmYWNlOiBcImV4cG9ydCBpbnRlcmZhY2VcIlxufTtcbmZ1bmN0aW9uIHBhcnRpdGlvbihsaXN0LCB0ZXN0KSB7XG4gIGNvbnN0IGxpc3QxID0gW107XG4gIGNvbnN0IGxpc3QyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICh0ZXN0KGxpc3RbaV0sIGksIGxpc3QpID8gbGlzdDEgOiBsaXN0MikucHVzaChsaXN0W2ldKTtcbiAgfVxuICByZXR1cm4gW2xpc3QxLCBsaXN0Ml07XG59XG5jb25zdCBGTE9XX1BSQUdNQV9SRUdFWCA9IC9cXCo/XFxzKkAoKD86bm8pP2Zsb3cpXFxiLztcbnZhciBmbG93ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBGbG93UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuZmxvd1ByYWdtYSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRTY29wZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIEZsb3dTY29wZUhhbmRsZXI7XG4gIH1cbiAgc2hvdWxkUGFyc2VUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJmbG93XCIsIFwiYWxsXCIpIHx8IHRoaXMuZmxvd1ByYWdtYSA9PT0gXCJmbG93XCI7XG4gIH1cbiAgZmluaXNoVG9rZW4odHlwZSwgdmFsKSB7XG4gICAgaWYgKHR5cGUgIT09IDEzNCAmJiB0eXBlICE9PSAxMyAmJiB0eXBlICE9PSAyOCkge1xuICAgICAgaWYgKHRoaXMuZmxvd1ByYWdtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmZpbmlzaFRva2VuKHR5cGUsIHZhbCk7XG4gIH1cbiAgYWRkQ29tbWVudChjb21tZW50KSB7XG4gICAgaWYgKHRoaXMuZmxvd1ByYWdtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gRkxPV19QUkFHTUFfUkVHRVguZXhlYyhjb21tZW50LnZhbHVlKTtcbiAgICAgIGlmICghbWF0Y2hlcykgO2Vsc2UgaWYgKG1hdGNoZXNbMV0gPT09IFwiZmxvd1wiKSB7XG4gICAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IFwiZmxvd1wiO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcIm5vZmxvd1wiKSB7XG4gICAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IFwibm9mbG93XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGZsb3cgcHJhZ21hXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5hZGRDb21tZW50KGNvbW1lbnQpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcih0b2spIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QodG9rIHx8IDE0KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgZmxvd1BhcnNlUHJlZGljYXRlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG1vZHVsb0xvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDExMCk7XG4gICAgaWYgKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLmluZGV4ID4gbW9kdWxvTG9jLmluZGV4ICsgMSkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3MsIG1vZHVsb0xvYyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgxMCkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBzdXBlci5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlZFByZWRpY2F0ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkluZmVycmVkUHJlZGljYXRlXCIpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICBsZXQgdHlwZSA9IG51bGw7XG4gICAgbGV0IHByZWRpY2F0ZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNTQpKSB7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICAgIHByZWRpY2F0ZSA9IHRoaXMuZmxvd1BhcnNlUHJlZGljYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNTQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHRoaXMuZmxvd1BhcnNlUHJlZGljYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbdHlwZSwgcHJlZGljYXRlXTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlQ2xhc3Mobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlQ2xhc3NcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBpZCA9IG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCB0eXBlQ29udGFpbmVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZU5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgY29uc3QgdG1wID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbXMoKTtcbiAgICB0eXBlTm9kZS5wYXJhbXMgPSB0bXAucGFyYW1zO1xuICAgIHR5cGVOb2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICB0eXBlTm9kZS50aGlzID0gdG1wLl90aGlzO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBbdHlwZU5vZGUucmV0dXJuVHlwZSwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICB0eXBlQ29udGFpbmVyLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgaWQudHlwZUFubm90YXRpb24gPSB0aGlzLmZpbmlzaE5vZGUodHlwZUNvbnRhaW5lciwgXCJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oaWQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsIDIwNDgsIG5vZGUuaWQubG9jLnN0YXJ0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUZ1bmN0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmUobm9kZSwgaW5zaWRlTW9kdWxlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlQ2xhc3Mobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDY4KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUZ1bmN0aW9uKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg3NCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMjcpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW5zaWRlTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLk5lc3RlZERlY2xhcmVNb2R1bGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyhub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVPcGFxdWVUeXBlKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUludGVyZmFjZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goODIpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgaW5zaWRlTW9kdWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcih0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgNSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVWYXJpYWJsZVwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUuaWQgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgICBjb25zdCBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYm9keSA9IGJvZHlOb2RlLmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgIGxldCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4MykpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTMwKSAmJiAhdGhpcy5tYXRjaCg4NykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW52YWxpZE5vblR5cGVJbXBvcnRJbkRlY2xhcmVNb2R1bGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZUltcG9ydChib2R5Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI1LCBGbG93RXJyb3JzLlVuc3VwcG9ydGVkU3RhdGVtZW50SW5EZWNsYXJlTW9kdWxlKTtcbiAgICAgICAgYm9keU5vZGUgPSB0aGlzLmZsb3dQYXJzZURlY2xhcmUoYm9keU5vZGUsIHRydWUpO1xuICAgICAgfVxuICAgICAgYm9keS5wdXNoKGJvZHlOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgIGxldCBraW5kID0gbnVsbDtcbiAgICBsZXQgaGFzTW9kdWxlRXhwb3J0ID0gZmFsc2U7XG4gICAgYm9keS5mb3JFYWNoKGJvZHlFbGVtZW50ID0+IHtcbiAgICAgIGlmIChpc0VzTW9kdWxlVHlwZShib2R5RWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiQ29tbW9uSlNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkVTXCI7XG4gICAgICB9IGVsc2UgaWYgKGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikge1xuICAgICAgICBpZiAoaGFzTW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkR1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzLCBib2R5RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IFwiRVNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkNvbW1vbkpTXCI7XG4gICAgICAgIGhhc01vZHVsZUV4cG9ydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbm9kZS5raW5kID0ga2luZCB8fCBcIkNvbW1vbkpTXCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIHRoaXMuZXhwZWN0KDgyKTtcbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg3NSkgfHwgdGhpcy5pc0xldCgpIHx8ICh0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpICYmICFpbnNpZGVNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5zdXBwb3J0ZWREZWNsYXJlRXhwb3J0S2luZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZDogbGFiZWwsXG4gICAgICAgICAgc3VnZ2VzdGlvbjogZXhwb3J0U3VnZ2VzdGlvbnNbbGFiZWxdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goODApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI5KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgbnVsbCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgbm9kZS50eXBlID0gXCJFeHBvcnREZWNsYXJhdGlvblwiO1xuICAgICAgICAgIG5vZGUuZGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgIGRlbGV0ZSBub2RlLmV4cG9ydEtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50eXBlID0gXCJEZWNsYXJlXCIgKyBub2RlLnR5cGU7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlRXhwb3J0cyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDExMSk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlVHlwZUFsaWFzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBmaW5pc2hlZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFsaWFzKG5vZGUpO1xuICAgIGZpbmlzaGVkLnR5cGUgPSBcIkRlY2xhcmVUeXBlQWxpYXNcIjtcbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIHRydWUpO1xuICAgIGZpbmlzaGVkLnR5cGUgPSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI7XG4gICAgcmV0dXJuIGZpbmlzaGVkO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgaXNDbGFzcykge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCFpc0NsYXNzLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgaXNDbGFzcyA/IDE3IDogODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLmV4dGVuZHMgPSBbXTtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBkbyB7XG4gICAgICAgIG5vZGUuZXh0ZW5kcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgIH0gd2hpbGUgKCFpc0NsYXNzICYmIHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICAgIGlmIChpc0NsYXNzKSB7XG4gICAgICBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgIG5vZGUubWl4aW5zID0gW107XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExNykpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5vZGUubWl4aW5zLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMTMpKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBub2RlLmltcGxlbWVudHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUuYm9keSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgICBhbGxvd1N0YXRpYzogaXNDbGFzcyxcbiAgICAgIGFsbG93RXhhY3Q6IGZhbHNlLFxuICAgICAgYWxsb3dTcHJlYWQ6IGZhbHNlLFxuICAgICAgYWxsb3dQcm90bzogaXNDbGFzcyxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyZmFjZUV4dGVuZHNcIik7XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIGNoZWNrTm90VW5kZXJzY29yZSh3b3JkKSB7XG4gICAgaWYgKHdvcmQgPT09IFwiX1wiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkVW5kZXJzY29yZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICB9XG4gIGNoZWNrUmVzZXJ2ZWRUeXBlKHdvcmQsIHN0YXJ0TG9jLCBkZWNsYXJhdGlvbikge1xuICAgIGlmICghcmVzZXJ2ZWRUeXBlcy5oYXMod29yZCkpIHJldHVybjtcbiAgICB0aGlzLnJhaXNlKGRlY2xhcmF0aW9uID8gRmxvd0Vycm9ycy5Bc3NpZ25SZXNlcnZlZFR5cGUgOiBGbG93RXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFR5cGUsIHN0YXJ0TG9jLCB7XG4gICAgICByZXNlcnZlZFR5cGU6IHdvcmRcbiAgICB9KTtcbiAgfVxuICBmbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcihsaWJlcmFsLCBkZWNsYXJhdGlvbikge1xuICAgIHRoaXMuY2hlY2tSZXNlcnZlZFR5cGUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYywgZGVjbGFyYXRpb24pO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcihsaWJlcmFsKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlQWxpYXMobm9kZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMjkpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbGlhc1wiKTtcbiAgfVxuICBmbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGRlY2xhcmUpIHtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTMwKTtcbiAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlLCB0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgODIwMSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLnN1cGVydHlwZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnN1cGVydHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKDE0KTtcbiAgICB9XG4gICAgbm9kZS5pbXBsdHlwZSA9IG51bGw7XG4gICAgaWYgKCFkZWNsYXJlKSB7XG4gICAgICBub2RlLmltcGx0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMjkpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcGFxdWVUeXBlXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIocmVxdWlyZURlZmF1bHQgPSBmYWxzZSkge1xuICAgIGNvbnN0IG5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gICAgY29uc3QgaWRlbnQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLm5hbWUgPSBpZGVudC5uYW1lO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICBub2RlLmJvdW5kID0gaWRlbnQudHlwZUFubm90YXRpb247XG4gICAgaWYgKHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICB0aGlzLmVhdCgyOSk7XG4gICAgICBub2RlLmRlZmF1bHQgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlcXVpcmVEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5NaXNzaW5nVHlwZVBhcmFtRGVmYXVsdCwgbm9kZVN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJcIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgbGV0IGRlZmF1bHRSZXF1aXJlZCA9IGZhbHNlO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXIoZGVmYXVsdFJlcXVpcmVkKTtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godHlwZVBhcmFtZXRlcik7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlci5kZWZhdWx0KSB7XG4gICAgICAgIGRlZmF1bHRSZXF1aXJlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9IHdoaWxlICghdGhpcy5tYXRjaCg0OCkpO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDQ3KTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlKCkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNDcpO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgIG5vZGUucGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKSk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goNDgpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2VUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjkpO1xuICAgIG5vZGUuZXh0ZW5kcyA9IFtdO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgIGFsbG93U3RhdGljOiBmYWxzZSxcbiAgICAgIGFsbG93RXhhY3Q6IGZhbHNlLFxuICAgICAgYWxsb3dTcHJlYWQ6IGZhbHNlLFxuICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDEzNSkgfHwgdGhpcy5tYXRjaCgxMzQpID8gc3VwZXIucGFyc2VFeHByQXRvbSgpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgaXNTdGF0aWMsIHZhcmlhbmNlKSB7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBpZiAodGhpcy5sb29rYWhlYWQoKS50eXBlID09PSAxNCkge1xuICAgICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVJbmRleGVyXCIpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgaXNTdGF0aWMpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTApKSB7XG4gICAgICBub2RlLm1ldGhvZCA9IHRydWU7XG4gICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5sb2Muc3RhcnQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5tZXRob2QgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgICAgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB9XG4gICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaChub2RlKSB7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICBub2RlLnJlc3QgPSBudWxsO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIG5vZGUudGhpcyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGlmICh0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgbm9kZS50aGlzID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbSh0cnVlKTtcbiAgICAgIG5vZGUudGhpcy5uYW1lID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKSk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgbm9kZS5yZXN0ID0gdGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgaXNTdGF0aWMpIHtcbiAgICBjb25zdCB2YWx1ZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCh2YWx1ZU5vZGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIpO1xuICB9XG4gIGZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgIGFsbG93U3RhdGljLFxuICAgIGFsbG93RXhhY3QsXG4gICAgYWxsb3dTcHJlYWQsXG4gICAgYWxsb3dQcm90byxcbiAgICBhbGxvd0luZXhhY3RcbiAgfSkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCBub2RlU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcyA9IFtdO1xuICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LmluZGV4ZXJzID0gW107XG4gICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMgPSBbXTtcbiAgICBsZXQgZW5kRGVsaW07XG4gICAgbGV0IGV4YWN0O1xuICAgIGxldCBpbmV4YWN0ID0gZmFsc2U7XG4gICAgaWYgKGFsbG93RXhhY3QgJiYgdGhpcy5tYXRjaCg2KSkge1xuICAgICAgdGhpcy5leHBlY3QoNik7XG4gICAgICBlbmREZWxpbSA9IDk7XG4gICAgICBleGFjdCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgICAgZW5kRGVsaW0gPSA4O1xuICAgICAgZXhhY3QgPSBmYWxzZTtcbiAgICB9XG4gICAgbm9kZVN0YXJ0LmV4YWN0ID0gZXhhY3Q7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGVuZERlbGltKSkge1xuICAgICAgbGV0IGlzU3RhdGljID0gZmFsc2U7XG4gICAgICBsZXQgcHJvdG9TdGFydExvYyA9IG51bGw7XG4gICAgICBsZXQgaW5leGFjdFN0YXJ0TG9jID0gbnVsbDtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKGFsbG93UHJvdG8gJiYgdGhpcy5pc0NvbnRleHR1YWwoMTE4KSkge1xuICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICBpZiAobG9va2FoZWFkLnR5cGUgIT09IDE0ICYmIGxvb2thaGVhZC50eXBlICE9PSAxNykge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHByb3RvU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICAgIGFsbG93U3RhdGljID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd1N0YXRpYyAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMDYpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gMTQgJiYgbG9va2FoZWFkLnR5cGUgIT09IDE3KSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgaXNTdGF0aWMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcbiAgICAgIGlmICh0aGlzLmVhdCgwKSkge1xuICAgICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVhdCgwKSkge1xuICAgICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGVTdGFydC5pbnRlcm5hbFNsb3RzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUsIGlzU3RhdGljKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YXJ0LmluZGV4ZXJzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlSW5kZXhlcihub2RlLCBpc1N0YXRpYywgdmFyaWFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICBpZiAocHJvdG9TdGFydExvYyAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YXJpYW5jZSkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCh2YXJpYW5jZS5sb2Muc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGVTdGFydC5jYWxsUHJvcGVydGllcy5wdXNoKHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBpc1N0YXRpYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGtpbmQgPSBcImluaXRcIjtcbiAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDk5KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDQpKSB7XG4gICAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgICBpZiAodG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUobG9va2FoZWFkLnR5cGUpKSB7XG4gICAgICAgICAgICBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wT3JJbmV4YWN0ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnRMb2MsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0ICE9IG51bGwgPyBhbGxvd0luZXhhY3QgOiAhZXhhY3QpO1xuICAgICAgICBpZiAocHJvcE9ySW5leGFjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIGluZXhhY3QgPSB0cnVlO1xuICAgICAgICAgIGluZXhhY3RTdGFydExvYyA9IHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGVTdGFydC5wcm9wZXJ0aWVzLnB1c2gocHJvcE9ySW5leGFjdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZmxvd09iamVjdFR5cGVTZW1pY29sb24oKTtcbiAgICAgIGlmIChpbmV4YWN0U3RhcnRMb2MgJiYgIXRoaXMubWF0Y2goOCkgJiYgIXRoaXMubWF0Y2goOSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRFeHBsaWNpdEluZXhhY3RJbk9iamVjdCwgaW5leGFjdFN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoZW5kRGVsaW0pO1xuICAgIGlmIChhbGxvd1NwcmVhZCkge1xuICAgICAgbm9kZVN0YXJ0LmluZXhhY3QgPSBpbmV4YWN0O1xuICAgIH1cbiAgICBjb25zdCBvdXQgPSB0aGlzLmZpbmlzaE5vZGUobm9kZVN0YXJ0LCBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZVByb3BlcnR5KG5vZGUsIGlzU3RhdGljLCBwcm90b1N0YXJ0TG9jLCB2YXJpYW5jZSwga2luZCwgYWxsb3dTcHJlYWQsIGFsbG93SW5leGFjdCkge1xuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIGNvbnN0IGlzSW5leGFjdFRva2VuID0gdGhpcy5tYXRjaCgxMikgfHwgdGhpcy5tYXRjaCgxMykgfHwgdGhpcy5tYXRjaCg4KSB8fCB0aGlzLm1hdGNoKDkpO1xuICAgICAgaWYgKGlzSW5leGFjdFRva2VuKSB7XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdEluc2lkZU5vbk9iamVjdCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0luZXhhY3QpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdEluc2lkZUV4YWN0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkluZXhhY3RWYXJpYW5jZSwgdmFyaWFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFhbGxvd1NwcmVhZCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFNwcmVhZFR5cGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3RvU3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5TcHJlYWRWYXJpYW5jZSwgdmFyaWFuY2UpO1xuICAgICAgfVxuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgICAgbm9kZS5wcm90byA9IHByb3RvU3RhcnRMb2MgIT0gbnVsbDtcbiAgICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgICBsZXQgb3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBub2RlLm1ldGhvZCA9IHRydWU7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS52YWx1ZSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0VHlwZU1ldGhvZGlzaCh0aGlzLnN0YXJ0Tm9kZUF0KG5vZGUubG9jLnN0YXJ0KSk7XG4gICAgICAgIGlmIChraW5kID09PSBcImdldFwiIHx8IGtpbmQgPT09IFwic2V0XCIpIHtcbiAgICAgICAgICB0aGlzLmZsb3dDaGVja0dldHRlclNldHRlclBhcmFtcyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93U3ByZWFkICYmIG5vZGUua2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiAmJiBub2RlLnZhbHVlLnRoaXMpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3Rvciwgbm9kZS52YWx1ZS50aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtpbmQgIT09IFwiaW5pdFwiKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgbm9kZS5tZXRob2QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICAgICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgICAgfVxuICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiKTtcbiAgICB9XG4gIH1cbiAgZmxvd0NoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKHByb3BlcnR5KSB7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHByb3BlcnR5LmtpbmQgPT09IFwiZ2V0XCIgPyAwIDogMTtcbiAgICBjb25zdCBsZW5ndGggPSBwcm9wZXJ0eS52YWx1ZS5wYXJhbXMubGVuZ3RoICsgKHByb3BlcnR5LnZhbHVlLnJlc3QgPyAxIDogMCk7XG4gICAgaWYgKHByb3BlcnR5LnZhbHVlLnRoaXMpIHtcbiAgICAgIHRoaXMucmFpc2UocHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IEZsb3dFcnJvcnMuR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSA6IEZsb3dFcnJvcnMuU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcHJvcGVydHkudmFsdWUudGhpcyk7XG4gICAgfVxuICAgIGlmIChsZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UocHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IEVycm9ycy5CYWRHZXR0ZXJBcml0eSA6IEVycm9ycy5CYWRTZXR0ZXJBcml0eSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHkua2luZCA9PT0gXCJzZXRcIiAmJiBwcm9wZXJ0eS52YWx1ZS5yZXN0KSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG4gIGZsb3dPYmplY3RUeXBlU2VtaWNvbG9uKCkge1xuICAgIGlmICghdGhpcy5lYXQoMTMpICYmICF0aGlzLmVhdCgxMikgJiYgIXRoaXMubWF0Y2goOCkgJiYgIXRoaXMubWF0Y2goOSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VRdWFsaWZpZWRUeXBlSWRlbnRpZmllcihzdGFydExvYywgaWQpIHtcbiAgICB2YXIgX3N0YXJ0TG9jO1xuICAgIChfc3RhcnRMb2MgPSBzdGFydExvYykgIT0gbnVsbCA/IF9zdGFydExvYyA6IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IGlkIHx8IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUyLnF1YWxpZmljYXRpb24gPSBub2RlO1xuICAgICAgbm9kZTIuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVzID0gW107XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIXRoaXMubWF0Y2goMykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgzKSkgYnJlYWs7XG4gICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZpcnN0KSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGxldCB0eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgIGNvbnN0IGlzVGhpcyA9IHRoaXMuc3RhdGUudHlwZSA9PT0gNzg7XG4gICAgaWYgKGxoLnR5cGUgPT09IDE0IHx8IGxoLnR5cGUgPT09IDE3KSB7XG4gICAgICBpZiAoaXNUaGlzICYmICFmaXJzdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTXVzdEJlRmlyc3QsIG5vZGUpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzVGhpcyk7XG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG4gIHJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgICBub2RlLm5hbWUgPSBudWxsO1xuICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgbGV0IHJlc3QgPSBudWxsO1xuICAgIGxldCBfdGhpcyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBfdGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIHJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3QsXG4gICAgICBfdGhpc1xuICAgIH07XG4gIH1cbiAgZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1peGVkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwiZW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ltYm9sVHlwZUFubm90YXRpb25cIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGlzR3JvdXBlZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkKCkudHlwZTtcbiAgICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSAxNyAmJiB0b2tlbiAhPT0gMTQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gMTkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVhdCgxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCg4NSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODQ6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA1NTpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODc6XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVvZlR5cGUoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0b2tlbklzS2V5d29yZCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgY29uc3QgbGFiZWwgPSB0b2tlbkxhYmVsTmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIHJldHVybiBzdXBlci5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIGxhYmVsKTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZVR5cGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgdGhpcy5wYXJzZUlkZW50aWZpZXIoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgZmxvd1BhcnNlUG9zdGZpeFR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB0eXBlID0gdGhpcy5mbG93UGFyc2VQcmltYXJ5VHlwZSgpO1xuICAgIGxldCBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzID0gZmFsc2U7XG4gICAgd2hpbGUgKCh0aGlzLm1hdGNoKDApIHx8IHRoaXMubWF0Y2goMTgpKSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxOCk7XG4gICAgICBzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzID0gc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyB8fCBvcHRpb25hbDtcbiAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgaWYgKCFvcHRpb25hbCAmJiB0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIG5vZGUuZWxlbWVudFR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5VHlwZUFubm90YXRpb25cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLm9iamVjdFR5cGUgPSB0eXBlO1xuICAgICAgICBub2RlLmluZGV4VHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgaWYgKHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkluZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWZpeFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlUHJlZml4VHlwZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVBvc3RmaXhUeXBlKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZUFub25GdW5jdGlvbldpdGhvdXRQYXJlbnMoKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICBpZiAoIXRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlICYmIHRoaXMuZWF0KDE5KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQocGFyYW0ubG9jLnN0YXJ0KTtcbiAgICAgIG5vZGUucGFyYW1zID0gW3RoaXMucmVpbnRlcnByZXRUeXBlQXNGdW5jdGlvblR5cGVQYXJhbShwYXJhbSldO1xuICAgICAgbm9kZS5yZXN0ID0gbnVsbDtcbiAgICAgIG5vZGUudGhpcyA9IG51bGw7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQ1KTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgICB3aGlsZSAodGhpcy5lYXQoNDUpKSB7XG4gICAgICBub2RlLnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVW5pb25UeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZWF0KDQzKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCk7XG4gICAgbm9kZS50eXBlcyA9IFt0eXBlXTtcbiAgICB3aGlsZSAodGhpcy5lYXQoNDMpKSB7XG4gICAgICBub2RlLnR5cGVzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcnNlY3Rpb25UeXBlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS50eXBlcy5sZW5ndGggPT09IDEgPyB0eXBlIDogdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5mbG93UGFyc2VVbmlvblR5cGUoKTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBmbG93UGFyc2VUeXBlT3JJbXBsaWNpdEluc3RhbnRpYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gMTMyICYmIHRoaXMuc3RhdGUudmFsdWUgPT09IFwiX1wiKSB7XG4gICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUdlbmVyaWNUeXBlKHN0YXJ0TG9jLCBub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcihhbGxvd1ByaW1pdGl2ZU92ZXJyaWRlKSB7XG4gICAgY29uc3QgaWRlbnQgPSBhbGxvd1ByaW1pdGl2ZU92ZXJyaWRlID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGlkZW50LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50O1xuICB9XG4gIHR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkge1xuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIGZsb3dQYXJzZVZhcmlhbmNlKCkge1xuICAgIGxldCB2YXJpYW5jZSA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNTMpKSB7XG4gICAgICB2YXJpYW5jZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCIrXCIpIHtcbiAgICAgICAgdmFyaWFuY2Uua2luZCA9IFwicGx1c1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyaWFuY2Uua2luZCA9IFwibWludXNcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh2YXJpYW5jZSwgXCJWYXJpYW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhbmNlO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGFsbG93RXhwcmVzc2lvbkJvZHksIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAoYWxsb3dFeHByZXNzaW9uQm9keSkge1xuICAgICAgdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdChub2RlLCAoKSA9PiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlLCBpc01ldGhvZCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgaXNNZXRob2QpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIFt0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiwgbm9kZS5wcmVkaWNhdGVdID0gdGhpcy5mbG93UGFyc2VUeXBlQW5kUHJlZGljYXRlSW5pdGlhbGlzZXIoKTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID8gdGhpcy5maW5pc2hOb2RlKHR5cGVOb2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudExpa2UoZmxhZ3MpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcihsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBzdG10ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKTtcbiAgICBpZiAodGhpcy5mbG93UHJhZ21hID09PSB1bmRlZmluZWQgJiYgIXRoaXMuaXNWYWxpZERpcmVjdGl2ZShzdG10KSkge1xuICAgICAgdGhpcy5mbG93UHJhZ21hID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0bXQ7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJkZWNsYXJlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goODApIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgfHwgdGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg3NCkgfHwgdGhpcy5tYXRjaCg4MikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgaWYgKGV4cHIubmFtZSA9PT0gXCJpbnRlcmZhY2VcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUludGVyZmFjZShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlVHlwZUFsaWFzKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGV4cHIubmFtZSA9PT0gXCJvcGFxdWVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDEyNiB8fCB0b2tlbklzRmxvd0ludGVyZmFjZU9yVHlwZU9yT3BhcXVlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMTI2IHx8IHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDE3KSkgcmV0dXJuIGV4cHI7XG4gICAgaWYgKHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgaWYgKG5leHRDaCA9PT0gNDQgfHwgbmV4dENoID09PSA2MSB8fCBuZXh0Q2ggPT09IDU4IHx8IG5leHRDaCA9PT0gNDEpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25hbFBhcmFtZXRlcnNFcnJvcihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE3KTtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCBvcmlnaW5hbE5vQXJyb3dBdCA9IHRoaXMuc3RhdGUubm9BcnJvd0F0O1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBsZXQge1xuICAgICAgY29uc2VxdWVudCxcbiAgICAgIGZhaWxlZFxuICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCk7XG4gICAgbGV0IFt2YWxpZCwgaW52YWxpZF0gPSB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQpO1xuICAgIGlmIChmYWlsZWQgfHwgaW52YWxpZC5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub0Fycm93QXQgPSBbLi4ub3JpZ2luYWxOb0Fycm93QXRdO1xuICAgICAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGludmFsaWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub0Fycm93QXQucHVzaChpbnZhbGlkW2ldLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgICBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID4gMSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuQW1iaWd1b3VzQ29uZGl0aW9uYWxBcnJvdywgc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKGZhaWxlZCAmJiB2YWxpZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICBub0Fycm93QXQucHVzaCh2YWxpZFswXS5zdGFydCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gbm9BcnJvd0F0O1xuICAgICAgICAoe1xuICAgICAgICAgIGNvbnNlcXVlbnQsXG4gICAgICAgICAgZmFpbGVkXG4gICAgICAgIH0gPSB0aGlzLnRyeVBhcnNlQ29uZGl0aW9uYWxDb25zZXF1ZW50KCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdldEFycm93TGlrZUV4cHJlc3Npb25zKGNvbnNlcXVlbnQsIHRydWUpO1xuICAgIHRoaXMuc3RhdGUubm9BcnJvd0F0ID0gb3JpZ2luYWxOb0Fycm93QXQ7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgbm9kZS5jb25zZXF1ZW50ID0gY29uc2VxdWVudDtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHVuZGVmaW5lZCwgdW5kZWZpbmVkKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgfVxuICB0cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpIHtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucHVzaCh0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgICBjb25zdCBjb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIGNvbnN0IGZhaWxlZCA9ICF0aGlzLm1hdGNoKDE0KTtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQucG9wKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9O1xuICB9XG4gIGdldEFycm93TGlrZUV4cHJlc3Npb25zKG5vZGUsIGRpc2FsbG93SW52YWxpZCkge1xuICAgIGNvbnN0IHN0YWNrID0gW25vZGVdO1xuICAgIGNvbnN0IGFycm93cyA9IFtdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBub2RlLmJvZHkudHlwZSAhPT0gXCJCbG9ja1N0YXRlbWVudFwiKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGVQYXJhbWV0ZXJzIHx8ICFub2RlLnJldHVyblR5cGUpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJvd3MucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYm9keSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikge1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuY29uc2VxdWVudCk7XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5hbHRlcm5hdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlzYWxsb3dJbnZhbGlkKSB7XG4gICAgICBhcnJvd3MuZm9yRWFjaChub2RlID0+IHRoaXMuZmluaXNoQXJyb3dWYWxpZGF0aW9uKG5vZGUpKTtcbiAgICAgIHJldHVybiBbYXJyb3dzLCBbXV07XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aXRpb24oYXJyb3dzLCBub2RlID0+IG5vZGUucGFyYW1zLmV2ZXJ5KHBhcmFtID0+IHRoaXMuaXNBc3NpZ25hYmxlKHBhcmFtLCB0cnVlKSkpO1xuICB9XG4gIGZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhO1xuICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLnBhcmFtcywgKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MsIGZhbHNlKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDIgfCA0KTtcbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cbiAgZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgcGFyc2UpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5ld05vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5ld05vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgJiYgKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0cnVlKTtcbiAgICAgICAgc3VwZXIucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMxKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGRlY2xhcmF0aW9uTm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgaWYgKHN1cGVyLmVhdEV4cG9ydFN0YXIobm9kZSkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNTUpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBzdXBlci5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc05hbWVzcGFjZTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgaWYgKHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1lbWJlci5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgaWYgKG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiICYmIG1lbWJlci50eXBlICE9PSBcIlByb3BlcnR5RGVmaW5pdGlvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EZWNsYXJlQ2xhc3NFbGVtZW50LCBzdGFydExvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci52YWx1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplciwgbWVtYmVyLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiaXRlcmF0b3JcIiB8fCB3b3JkID09PSBcImFzeW5jSXRlcmF0b3JcIjtcbiAgfVxuICByZWFkSXRlcmF0b3IoKSB7XG4gICAgY29uc3Qgd29yZCA9IHN1cGVyLnJlYWRXb3JkMSgpO1xuICAgIGNvbnN0IGZ1bGxXb3JkID0gXCJAQFwiICsgd29yZDtcbiAgICBpZiAoIXRoaXMuaXNJdGVyYXRvcih3b3JkKSB8fCAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IGZ1bGxXb3JkXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIGZ1bGxXb3JkKTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyMyAmJiBuZXh0ID09PSAxMjQpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNiwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYyID8gNDggOiA0NywgMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBjb2RlID09PSA2Mykge1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMTgsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgxNywgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0l0ZXJhdG9yU3RhcnQoY29kZSwgbmV4dCwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikpKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5yZWFkSXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzTEhTICYmIG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIG5vZGUubGVmdC50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICBleHByTGlzdFtpXSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihleHByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpO1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgICBjb25zdCBleHByID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZXhwciAmJiBleHByLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgJiYgISgoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIChleHByTGlzdC5sZW5ndGggPiAxIHx8ICFpc1BhcmVudGhlc2l6ZWRFeHByKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUNhc3RJblBhdHRlcm4sIGV4cHIudHlwZUFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3Q7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGNhbkJlUGF0dGVybiwgaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoY2FuQmVQYXR0ZXJuICYmICF0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChub2RlLmVsZW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNDcpIHx8IHN1cGVyLmlzQ2xhc3NNZXRob2QoKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG4gIGlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKSB7XG4gICAgcmV0dXJuICF0aGlzLm1hdGNoKDE0KSAmJiBzdXBlci5pc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCk7XG4gIH1cbiAgcHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpIHtcbiAgICBpZiAobWV0aG9kLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobWV0aG9kLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBtZXRob2QudmFyaWFuY2U7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gICAgaWYgKG1ldGhvZC5wYXJhbXMgJiYgaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgY29uc3QgcGFyYW1zID0gbWV0aG9kLnBhcmFtcztcbiAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCAmJiB0aGlzLmlzVGhpc1BhcmFtKHBhcmFtc1swXSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUJhbm5lZEluQ29uc3RydWN0b3IsIG1ldGhvZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZXRob2QudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgaXNDb25zdHJ1Y3RvciAmJiBtZXRob2QudmFsdWUucGFyYW1zKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBtZXRob2QudmFsdWUucGFyYW1zO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW1zWzBdKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvciwgbWV0aG9kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBpZiAobWV0aG9kLnZhcmlhbmNlKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobWV0aG9kLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBtZXRob2QudmFyaWFuY2U7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICBzdXBlci5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS5zdXBlclR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTEzKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBpbXBsZW1lbnRlZCA9IG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaW1wbGVtZW50ZWQucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc0ltcGxlbWVudHNcIikpO1xuICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKSB7XG4gICAgc3VwZXIuY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHBhcmFtID0gcGFyYW1zWzBdO1xuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pICYmIG1ldGhvZC5raW5kID09PSBcImdldFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5HZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCBwYXJhbSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5TZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlUHJvcGVydHlOYW1lUHJlZml4T3BlcmF0b3Iobm9kZSkge1xuICAgIG5vZGUudmFyaWFuY2UgPSB0aGlzLmZsb3dQYXJzZVZhcmlhbmNlKCk7XG4gIH1cbiAgcGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC52YXJpYW5jZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHByb3AudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIHByb3AudmFyaWFuY2U7XG4gICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSAmJiAhaXNBY2Nlc3Nvcikge1xuICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDEwKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgIChyZXN1bHQudmFsdWUgfHwgcmVzdWx0KS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocGFyYW0pIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWwsIHBhcmFtKTtcbiAgICAgIH1cbiAgICAgIHBhcmFtLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBwYXJhbS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkLCBwYXJhbSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDI5KSAmJiB0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU5vRGVmYXVsdCwgcGFyYW0pO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24ocGFyYW0pO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBwYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgbGVmdCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgbGVmdCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiICYmIG5vZGUudHlwZUFubm90YXRpb24gJiYgbm9kZS5yaWdodC5zdGFydCA8IG5vZGUudHlwZUFubm90YXRpb24uc3RhcnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UeXBlQmVmb3JlSW5pdGlhbGl6ZXIsIG5vZGUudHlwZUFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSkge1xuICAgIHN1cGVyLmNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKTtcbiAgICBpZiAobm9kZS5tb2R1bGUgJiYgbm9kZS5pbXBvcnRLaW5kICE9PSBcInZhbHVlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZSwgbm9kZS5zcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgc3BlY2lmaWVyLCB0eXBlKSB7XG4gICAgc3BlY2lmaWVyLmxvY2FsID0gaGFzVHlwZUltcG9ydEtpbmQobm9kZSkgPyB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpIDogdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLnNwZWNpZmllcnMucHVzaCh0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIHR5cGUpKTtcbiAgfVxuICBpc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSB7XG4gICAgaWYgKHN1cGVyLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgaWYgKCFpc0V4cG9ydCkgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBjaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIHJldHVybiBjaCA9PT0gMTIzIHx8IGNoID09PSA0MjtcbiAgICB9XG4gICAgcmV0dXJuICFpc0V4cG9ydCAmJiB0aGlzLmlzQ29udGV4dHVhbCg4Nyk7XG4gIH1cbiAgYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYykge1xuICAgIHN1cGVyLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpO1xuICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgaWYgKCFwaGFzZSAmJiB0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBwaGFzZSA9PT0gXCJ0eXBlXCIgPyBwaGFzZSA6IFwidmFsdWVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBoYXNlID09PSBcInR5cGVcIiAmJiB0aGlzLm1hdGNoKDU1KSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBwaGFzZSA9PT0gXCJ0eXBlXCIgfHwgcGhhc2UgPT09IFwidHlwZW9mXCIgPyBwaGFzZSA6IFwidmFsdWVcIjtcbiAgICB9XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBpbXBvcnRlZElzU3RyaW5nLCBpc0luVHlwZU9ubHlJbXBvcnQsIGlzTWF5YmVUeXBlT25seSwgYmluZGluZ1R5cGUpIHtcbiAgICBjb25zdCBmaXJzdElkZW50ID0gc3BlY2lmaWVyLmltcG9ydGVkO1xuICAgIGxldCBzcGVjaWZpZXJUeXBlS2luZCA9IG51bGw7XG4gICAgaWYgKGZpcnN0SWRlbnQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZVwiKSB7XG4gICAgICAgIHNwZWNpZmllclR5cGVLaW5kID0gXCJ0eXBlXCI7XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0SWRlbnQubmFtZSA9PT0gXCJ0eXBlb2ZcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZW9mXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBpc0JpbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpICYmICF0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBjb25zdCBhc19pZGVudCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgaWYgKHNwZWNpZmllclR5cGVLaW5kICE9PSBudWxsICYmICF0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IGFzX2lkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IHNwZWNpZmllclR5cGVLaW5kO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBjbG9uZUlkZW50aWZpZXIoYXNfaWRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbXBvcnRlZElzU3RyaW5nKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICAgIGltcG9ydE5hbWU6IGZpcnN0SWRlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBmaXJzdElkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gY2xvbmVJZGVudGlmaWVyKHNwZWNpZmllci5pbXBvcnRlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpZmllcklzVHlwZUltcG9ydCA9IGhhc1R5cGVJbXBvcnRLaW5kKHNwZWNpZmllcik7XG4gICAgaWYgKGlzSW5UeXBlT25seUltcG9ydCAmJiBzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydCwgc3BlY2lmaWVyKTtcbiAgICB9XG4gICAgaWYgKGlzSW5UeXBlT25seUltcG9ydCB8fCBzcGVjaWZpZXJJc1R5cGVJbXBvcnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFR5cGUoc3BlY2lmaWVyLmxvY2FsLm5hbWUsIHNwZWNpZmllci5sb2NhbC5sb2Muc3RhcnQsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNCaW5kaW5nICYmICFpc0luVHlwZU9ubHlJbXBvcnQgJiYgIXNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaEltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIFwiSW1wb3J0U3BlY2lmaWVyXCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGtpbmQgPSBub2RlLmtpbmQ7XG4gICAgaWYgKGtpbmQgIT09IFwiZ2V0XCIgJiYga2luZCAhPT0gXCJzZXRcIiAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGRlY2wuaWQudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBc3luY0Fycm93KCk7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHZhciBfanN4O1xuICAgIGxldCBzdGF0ZSA9IG51bGw7XG4gICAgbGV0IGpzeDtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJqc3hcIikgJiYgKHRoaXMubWF0Y2goMTQzKSB8fCB0aGlzLm1hdGNoKDQ3KSkpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAganN4ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSwgc3RhdGUpO1xuICAgICAgaWYgKCFqc3guZXJyb3IpIHJldHVybiBqc3gubm9kZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChfanN4ID0ganN4KSAhPSBudWxsICYmIF9qc3guZXJyb3IgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHZhciBfanN4MiwgX2pzeDM7XG4gICAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICAgIHZhciBfYXJyb3dFeHByZXNzaW9uJGV4dHI7XG4gICAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgICAgY29uc3QgYXJyb3dFeHByZXNzaW9uID0gdGhpcy5mb3J3YXJkTm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdCh0eXBlUGFyYW1ldGVycywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUocmVzdWx0LCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICgoX2Fycm93RXhwcmVzc2lvbiRleHRyID0gYXJyb3dFeHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9hcnJvd0V4cHJlc3Npb24kZXh0ci5wYXJlbnRoZXNpemVkKSBhYm9ydCgpO1xuICAgICAgICBjb25zdCBleHByID0gdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvd0V4cHJlc3Npb24pO1xuICAgICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIGFib3J0KCk7XG4gICAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHByLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgIHJldHVybiBhcnJvd0V4cHJlc3Npb247XG4gICAgICB9LCBzdGF0ZSk7XG4gICAgICBsZXQgYXJyb3dFeHByZXNzaW9uID0gbnVsbDtcbiAgICAgIGlmIChhcnJvdy5ub2RlICYmIHRoaXMubWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24oYXJyb3cubm9kZSkudHlwZSA9PT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmICghYXJyb3cuZXJyb3IgJiYgIWFycm93LmFib3J0ZWQpIHtcbiAgICAgICAgICBpZiAoYXJyb3cubm9kZS5hc3luYykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRUeXBlUGFyYW1ldGVyQmVmb3JlQXN5bmNBcnJvd0Z1bmN0aW9uLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgICB9XG4gICAgICAgIGFycm93RXhwcmVzc2lvbiA9IGFycm93Lm5vZGU7XG4gICAgICB9XG4gICAgICBpZiAoKF9qc3gyID0ganN4KSAhPSBudWxsICYmIF9qc3gyLm5vZGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGpzeC5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJvd0V4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGFycm93LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmICgoX2pzeDMgPSBqc3gpICE9IG51bGwgJiYgX2pzeDMudGhyb3duKSB0aHJvdyBqc3guZXJyb3I7XG4gICAgICBpZiAoYXJyb3cudGhyb3duKSB0aHJvdyBhcnJvdy5lcnJvcjtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkVG9rZW5BZnRlclR5cGVQYXJhbWV0ZXIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICB9XG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgW3R5cGVOb2RlLnR5cGVBbm5vdGF0aW9uLCBub2RlLnByZWRpY2F0ZV0gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbmRQcmVkaWNhdGVJbml0aWFsaXNlcigpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTkpKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVOb2RlO1xuICAgICAgfSk7XG4gICAgICBpZiAocmVzdWx0LnRocm93bikgcmV0dXJuIG51bGw7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJlc3VsdC5ub2RlLnR5cGVBbm5vdGF0aW9uID8gdGhpcy5maW5pc2hOb2RlKHJlc3VsdC5ub2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpO1xuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcykge1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIG5vZGUucGFyYW1zID0gcGFyYW1zO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgfVxuICBjaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQgPSB0cnVlKSB7XG4gICAgaWYgKGlzQXJyb3dGdW5jdGlvbiAmJiB0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLnBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0obm9kZS5wYXJhbXNbaV0pICYmIGkgPiAwKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NdXN0QmVGaXJzdCwgbm9kZS5wYXJhbXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBhbGxvd0R1cGxpY2F0ZXMsIGlzQXJyb3dGdW5jdGlvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICB9XG4gIHBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdykge1xuICAgIHJldHVybiBzdXBlci5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cgJiYgIXRoaXMuc3RhdGUubm9BcnJvd0F0LmluY2x1ZGVzKHRoaXMuc291cmNlVG9PZmZzZXRQb3ModGhpcy5zdGF0ZS5zdGFydCkpKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBpZiAoYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnN0YXRlLm5vQXJyb3dBdC5pbmNsdWRlcyhzdGFydExvYy5pbmRleCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBzdXBlci5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHRoaXMucGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0TG9jKSB8fCBhYm9ydCgpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlICYmICFyZXN1bHQuZXJyb3IpIHJldHVybiByZXN1bHQubm9kZTtcbiAgICAgIGlmIChhcnJvdy5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBhcnJvdy5lcnJvciB8fCByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdWJzY3JpcHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmlzTG9va2FoZWFkVG9rZW5fbHQoKSkge1xuICAgICAgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlciA9IHRydWU7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdWJzY3JpcHRTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExKTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICghbm9DYWxscyAmJiB0aGlzLnNob3VsZFBhcnNlVHlwZXMoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBzdWJzY3JpcHRTdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3Vic2NyaXB0U3RhdGUpO1xuICB9XG4gIHBhcnNlTmV3Q2FsbGVlKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBsZXQgdGFyZ3MgPSBudWxsO1xuICAgIGlmICh0aGlzLnNob3VsZFBhcnNlVHlwZXMoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdGFyZ3MgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKSkubm9kZTtcbiAgICB9XG4gICAgbm9kZS50eXBlQXJndW1lbnRzID0gdGFyZ3M7XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgaWYgKCF0aGlzLnBhcnNlQXJyb3cobm9kZSkpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvd0V4cHJlc3Npb24obm9kZSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgfVxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDcgJiYgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgdGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMubmV4dFRva2VuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYWRUb2tlbl9tdWx0X21vZHVsbyhjb2RlKTtcbiAgfVxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gMTI0ICYmIG5leHQgPT09IDEyNSkge1xuICAgICAgdGhpcy5maW5pc2hPcCg5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpO1xuICB9XG4gIHBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSkge1xuICAgIGNvbnN0IGZpbGVOb2RlID0gc3VwZXIucGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVudGVybWluYXRlZEZsb3dDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZU5vZGU7XG4gIH1cbiAgc2tpcEJsb2NrQ29tbWVudCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93Q29tbWVudHNcIikgJiYgdGhpcy5za2lwRmxvd0NvbW1lbnQoKSkge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLk5lc3RlZEZsb3dDb21tZW50LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCk7XG4gICAgICBjb25zdCBjb21tZW50U2tpcCA9IHRoaXMuc2tpcEZsb3dDb21tZW50KCk7XG4gICAgICBpZiAoY29tbWVudFNraXApIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY29tbWVudFNraXA7XG4gICAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2tpcEJsb2NrQ29tbWVudCh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID8gXCIqLS9cIiA6IFwiKi9cIik7XG4gIH1cbiAgc2tpcEZsb3dDb21tZW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlID0gMjtcbiAgICB3aGlsZSAoWzMyLCA5XS5pbmNsdWRlcyh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSkpKSB7XG4gICAgICBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlKys7XG4gICAgfVxuICAgIGNvbnN0IGNoMiA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgcG9zKTtcbiAgICBjb25zdCBjaDMgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyArIDEpO1xuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyA9PT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5wdXQuc2xpY2Uoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcywgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyArIDEyKSA9PT0gXCJmbG93LWluY2x1ZGVcIikge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyAxMjtcbiAgICB9XG4gICAgaWYgKGNoMiA9PT0gNTggJiYgY2gzICE9PSA1OCkge1xuICAgICAgcmV0dXJuIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoYXNGbG93Q29tbWVudENvbXBsZXRpb24oKSB7XG4gICAgY29uc3QgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBmbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGxvYywge1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkLCBsb2MsIHtcbiAgICAgIG1lbWJlck5hbWUsXG4gICAgICBlbnVtTmFtZVxuICAgIH0pO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JJbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXIobG9jLCBlbnVtQ29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLnJhaXNlKCFlbnVtQ29udGV4dC5leHBsaWNpdFR5cGUgPyBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZSA6IGVudW1Db250ZXh0LmV4cGxpY2l0VHlwZSA9PT0gXCJzeW1ib2xcIiA/IEZsb3dFcnJvcnMuRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGUgOiBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZSwgbG9jLCBlbnVtQ29udGV4dCk7XG4gIH1cbiAgZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKGxvYywgZGV0YWlscykge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQsIGxvYywgZGV0YWlscyk7XG4gIH1cbiAgZmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQobm9kZSwgZGV0YWlscykge1xuICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZCwgbm9kZSwgZGV0YWlscyk7XG4gIH1cbiAgZmxvd0VudW1NZW1iZXJJbml0KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBlbmRPZkluaXQgPSAoKSA9PiB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDgpO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDEzNTpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgaWYgKGVuZE9mSW5pdCgpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTM0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbGl0ZXJhbCA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlIDg1OlxuICAgICAgY2FzZSA4NjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwodGhpcy5tYXRjaCg4NSkpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtTWVtYmVyUmF3KCkge1xuICAgIGNvbnN0IGxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5lYXQoMjkpID8gdGhpcy5mbG93RW51bU1lbWJlckluaXQoKSA6IHtcbiAgICAgIHR5cGU6IFwibm9uZVwiLFxuICAgICAgbG9jXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICBpbml0XG4gICAgfTtcbiAgfVxuICBmbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2gobG9jLCBjb250ZXh0LCBleHBlY3RlZFR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9ID0gY29udGV4dDtcbiAgICBpZiAoZXhwbGljaXRUeXBlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChleHBsaWNpdFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGxvYywgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtTWVtYmVycyh7XG4gICAgZW51bU5hbWUsXG4gICAgZXhwbGljaXRUeXBlXG4gIH0pIHtcbiAgICBjb25zdCBzZWVuTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgbWVtYmVycyA9IHtcbiAgICAgIGJvb2xlYW5NZW1iZXJzOiBbXSxcbiAgICAgIG51bWJlck1lbWJlcnM6IFtdLFxuICAgICAgc3RyaW5nTWVtYmVyczogW10sXG4gICAgICBkZWZhdWx0ZWRNZW1iZXJzOiBbXVxuICAgIH07XG4gICAgbGV0IGhhc1Vua25vd25NZW1iZXJzID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICAgIGhhc1Vua25vd25NZW1iZXJzID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBtZW1iZXJOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRcbiAgICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVyUmF3KCk7XG4gICAgICBjb25zdCBtZW1iZXJOYW1lID0gaWQubmFtZTtcbiAgICAgIGlmIChtZW1iZXJOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKC9eW2Etel0vLnRlc3QobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVyTmFtZSwgaWQsIHtcbiAgICAgICAgICBtZW1iZXJOYW1lLFxuICAgICAgICAgIHN1Z2dlc3Rpb246IG1lbWJlck5hbWVbMF0udG9VcHBlckNhc2UoKSArIG1lbWJlck5hbWUuc2xpY2UoMSksXG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoc2Vlbk5hbWVzLmhhcyhtZW1iZXJOYW1lKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUR1cGxpY2F0ZU1lbWJlck5hbWUsIGlkLCB7XG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHNlZW5OYW1lcy5hZGQobWVtYmVyTmFtZSk7XG4gICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgZXhwbGljaXRUeXBlLFxuICAgICAgICBtZW1iZXJOYW1lXG4gICAgICB9O1xuICAgICAgbWVtYmVyTm9kZS5pZCA9IGlkO1xuICAgICAgc3dpdGNoIChpbml0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJib29sZWFuXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMuYm9vbGVhbk1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtQm9vbGVhbk1lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJudW1iZXJcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5udW1iZXJNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bU51bWJlck1lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmZsb3dFbnVtQ2hlY2tFeHBsaWNpdFR5cGVNaXNtYXRjaChpbml0LmxvYywgY29udGV4dCwgXCJzdHJpbmdcIik7XG4gICAgICAgICAgICBtZW1iZXJOb2RlLmluaXQgPSBpbml0LnZhbHVlO1xuICAgICAgICAgICAgbWVtYmVycy5zdHJpbmdNZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bVN0cmluZ01lbWJlclwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJpbnZhbGlkXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5mbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJub25lXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JCb29sZWFuTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQoaW5pdC5sb2MsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBtZW1iZXJzLFxuICAgICAgaGFzVW5rbm93bk1lbWJlcnNcbiAgICB9O1xuICB9XG4gIGZsb3dFbnVtU3RyaW5nTWVtYmVycyhpbml0aWFsaXplZE1lbWJlcnMsIGRlZmF1bHRlZE1lbWJlcnMsIHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKGluaXRpYWxpemVkTWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBkZWZhdWx0ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBpbml0aWFsaXplZE1lbWJlcnM7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aCA+IGluaXRpYWxpemVkTWVtYmVycy5sZW5ndGgpIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGluaXRpYWxpemVkTWVtYmVycykge1xuICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkKG1lbWJlciwge1xuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmF1bHRlZE1lbWJlcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIGRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbml0aWFsaXplZE1lbWJlcnM7XG4gICAgfVxuICB9XG4gIGZsb3dFbnVtUGFyc2VFeHBsaWNpdFR5cGUoe1xuICAgIGVudW1OYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuZWF0Q29udGV4dHVhbCgxMDIpKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZVVua25vd25TdXBwbGllZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBlbnVtTmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHZhbHVlICE9PSBcImJvb2xlYW5cIiAmJiB2YWx1ZSAhPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSAhPT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSAhPT0gXCJzeW1ib2xcIikge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbnZhbGlkRXhwbGljaXRUeXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIGVudW1OYW1lLFxuICAgICAgICBpbnZhbGlkRW51bVR5cGU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZsb3dFbnVtQm9keShub2RlLCBpZCkge1xuICAgIGNvbnN0IGVudW1OYW1lID0gaWQubmFtZTtcbiAgICBjb25zdCBuYW1lTG9jID0gaWQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGV4cGxpY2l0VHlwZSA9IHRoaXMuZmxvd0VudW1QYXJzZUV4cGxpY2l0VHlwZSh7XG4gICAgICBlbnVtTmFtZVxuICAgIH0pO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lbWJlcnMsXG4gICAgICBoYXNVbmtub3duTWVtYmVyc1xuICAgIH0gPSB0aGlzLmZsb3dFbnVtTWVtYmVycyh7XG4gICAgICBlbnVtTmFtZSxcbiAgICAgIGV4cGxpY2l0VHlwZVxuICAgIH0pO1xuICAgIG5vZGUuaGFzVW5rbm93bk1lbWJlcnMgPSBoYXNVbmtub3duTWVtYmVycztcbiAgICBzd2l0Y2ggKGV4cGxpY2l0VHlwZSkge1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1Cb29sZWFuQm9keVwiKTtcbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgbm9kZS5leHBsaWNpdFR5cGUgPSB0cnVlO1xuICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLm51bWJlck1lbWJlcnM7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bU51bWJlckJvZHlcIik7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gdGhpcy5mbG93RW51bVN0cmluZ01lbWJlcnMobWVtYmVycy5zdHJpbmdNZW1iZXJzLCBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TeW1ib2xCb2R5XCIpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGVtcHR5ID0gKCkgPT4ge1xuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgYm9vbHNMZW4gPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBudW1zTGVuID0gbWVtYmVycy5udW1iZXJNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBzdHJzTGVuID0gbWVtYmVycy5zdHJpbmdNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0ZWRMZW4gPSBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoO1xuICAgICAgICAgIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgIWRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIW51bXNMZW4pIHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1TdHJpbmdCb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW51bXNMZW4gJiYgIXN0cnNMZW4gJiYgYm9vbHNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKG1lbWJlci5sb2Muc3RhcnQsIHtcbiAgICAgICAgICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgICAgICAgICBtZW1iZXJOYW1lOiBtZW1iZXIuaWQubmFtZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuYm9vbGVhbk1lbWJlcnM7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtQm9vbGVhbkJvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIGlmICghYm9vbHNMZW4gJiYgIXN0cnNMZW4gJiYgbnVtc0xlbiA+PSBkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycykge1xuICAgICAgICAgICAgICB0aGlzLmZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIubG9jLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyLmlkLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLm51bWJlck1lbWJlcnM7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtTnVtYmVyQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXMsIG5hbWVMb2MsIHtcbiAgICAgICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGVtcHR5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIG5vZGUuaWQgPSBpZDtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dFbnVtQm9keSh0aGlzLnN0YXJ0Tm9kZSgpLCBpZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1EZWNsYXJhdGlvblwiKTtcbiAgfVxuICBpc0xvb2thaGVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNjApIHtcbiAgICAgIGNvbnN0IGFmdGVyTmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICByZXR1cm4gYWZ0ZXJOZXh0ICE9PSA2MCAmJiBhZnRlck5leHQgIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVVbndyYXBUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgPyBub2RlLmV4cHJlc3Npb24gOiBub2RlO1xuICB9XG59O1xuY29uc3QgZW50aXRpZXMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcXVvdDogXCJcXHUwMDIyXCIsXG4gIGFtcDogXCImXCIsXG4gIGFwb3M6IFwiXFx1MDAyN1wiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbmJzcDogXCJcXHUwMEEwXCIsXG4gIGlleGNsOiBcIlxcdTAwQTFcIixcbiAgY2VudDogXCJcXHUwMEEyXCIsXG4gIHBvdW5kOiBcIlxcdTAwQTNcIixcbiAgY3VycmVuOiBcIlxcdTAwQTRcIixcbiAgeWVuOiBcIlxcdTAwQTVcIixcbiAgYnJ2YmFyOiBcIlxcdTAwQTZcIixcbiAgc2VjdDogXCJcXHUwMEE3XCIsXG4gIHVtbDogXCJcXHUwMEE4XCIsXG4gIGNvcHk6IFwiXFx1MDBBOVwiLFxuICBvcmRmOiBcIlxcdTAwQUFcIixcbiAgbGFxdW86IFwiXFx1MDBBQlwiLFxuICBub3Q6IFwiXFx1MDBBQ1wiLFxuICBzaHk6IFwiXFx1MDBBRFwiLFxuICByZWc6IFwiXFx1MDBBRVwiLFxuICBtYWNyOiBcIlxcdTAwQUZcIixcbiAgZGVnOiBcIlxcdTAwQjBcIixcbiAgcGx1c21uOiBcIlxcdTAwQjFcIixcbiAgc3VwMjogXCJcXHUwMEIyXCIsXG4gIHN1cDM6IFwiXFx1MDBCM1wiLFxuICBhY3V0ZTogXCJcXHUwMEI0XCIsXG4gIG1pY3JvOiBcIlxcdTAwQjVcIixcbiAgcGFyYTogXCJcXHUwMEI2XCIsXG4gIG1pZGRvdDogXCJcXHUwMEI3XCIsXG4gIGNlZGlsOiBcIlxcdTAwQjhcIixcbiAgc3VwMTogXCJcXHUwMEI5XCIsXG4gIG9yZG06IFwiXFx1MDBCQVwiLFxuICByYXF1bzogXCJcXHUwMEJCXCIsXG4gIGZyYWMxNDogXCJcXHUwMEJDXCIsXG4gIGZyYWMxMjogXCJcXHUwMEJEXCIsXG4gIGZyYWMzNDogXCJcXHUwMEJFXCIsXG4gIGlxdWVzdDogXCJcXHUwMEJGXCIsXG4gIEFncmF2ZTogXCJcXHUwMEMwXCIsXG4gIEFhY3V0ZTogXCJcXHUwMEMxXCIsXG4gIEFjaXJjOiBcIlxcdTAwQzJcIixcbiAgQXRpbGRlOiBcIlxcdTAwQzNcIixcbiAgQXVtbDogXCJcXHUwMEM0XCIsXG4gIEFyaW5nOiBcIlxcdTAwQzVcIixcbiAgQUVsaWc6IFwiXFx1MDBDNlwiLFxuICBDY2VkaWw6IFwiXFx1MDBDN1wiLFxuICBFZ3JhdmU6IFwiXFx1MDBDOFwiLFxuICBFYWN1dGU6IFwiXFx1MDBDOVwiLFxuICBFY2lyYzogXCJcXHUwMENBXCIsXG4gIEV1bWw6IFwiXFx1MDBDQlwiLFxuICBJZ3JhdmU6IFwiXFx1MDBDQ1wiLFxuICBJYWN1dGU6IFwiXFx1MDBDRFwiLFxuICBJY2lyYzogXCJcXHUwMENFXCIsXG4gIEl1bWw6IFwiXFx1MDBDRlwiLFxuICBFVEg6IFwiXFx1MDBEMFwiLFxuICBOdGlsZGU6IFwiXFx1MDBEMVwiLFxuICBPZ3JhdmU6IFwiXFx1MDBEMlwiLFxuICBPYWN1dGU6IFwiXFx1MDBEM1wiLFxuICBPY2lyYzogXCJcXHUwMEQ0XCIsXG4gIE90aWxkZTogXCJcXHUwMEQ1XCIsXG4gIE91bWw6IFwiXFx1MDBENlwiLFxuICB0aW1lczogXCJcXHUwMEQ3XCIsXG4gIE9zbGFzaDogXCJcXHUwMEQ4XCIsXG4gIFVncmF2ZTogXCJcXHUwMEQ5XCIsXG4gIFVhY3V0ZTogXCJcXHUwMERBXCIsXG4gIFVjaXJjOiBcIlxcdTAwREJcIixcbiAgVXVtbDogXCJcXHUwMERDXCIsXG4gIFlhY3V0ZTogXCJcXHUwMEREXCIsXG4gIFRIT1JOOiBcIlxcdTAwREVcIixcbiAgc3psaWc6IFwiXFx1MDBERlwiLFxuICBhZ3JhdmU6IFwiXFx1MDBFMFwiLFxuICBhYWN1dGU6IFwiXFx1MDBFMVwiLFxuICBhY2lyYzogXCJcXHUwMEUyXCIsXG4gIGF0aWxkZTogXCJcXHUwMEUzXCIsXG4gIGF1bWw6IFwiXFx1MDBFNFwiLFxuICBhcmluZzogXCJcXHUwMEU1XCIsXG4gIGFlbGlnOiBcIlxcdTAwRTZcIixcbiAgY2NlZGlsOiBcIlxcdTAwRTdcIixcbiAgZWdyYXZlOiBcIlxcdTAwRThcIixcbiAgZWFjdXRlOiBcIlxcdTAwRTlcIixcbiAgZWNpcmM6IFwiXFx1MDBFQVwiLFxuICBldW1sOiBcIlxcdTAwRUJcIixcbiAgaWdyYXZlOiBcIlxcdTAwRUNcIixcbiAgaWFjdXRlOiBcIlxcdTAwRURcIixcbiAgaWNpcmM6IFwiXFx1MDBFRVwiLFxuICBpdW1sOiBcIlxcdTAwRUZcIixcbiAgZXRoOiBcIlxcdTAwRjBcIixcbiAgbnRpbGRlOiBcIlxcdTAwRjFcIixcbiAgb2dyYXZlOiBcIlxcdTAwRjJcIixcbiAgb2FjdXRlOiBcIlxcdTAwRjNcIixcbiAgb2NpcmM6IFwiXFx1MDBGNFwiLFxuICBvdGlsZGU6IFwiXFx1MDBGNVwiLFxuICBvdW1sOiBcIlxcdTAwRjZcIixcbiAgZGl2aWRlOiBcIlxcdTAwRjdcIixcbiAgb3NsYXNoOiBcIlxcdTAwRjhcIixcbiAgdWdyYXZlOiBcIlxcdTAwRjlcIixcbiAgdWFjdXRlOiBcIlxcdTAwRkFcIixcbiAgdWNpcmM6IFwiXFx1MDBGQlwiLFxuICB1dW1sOiBcIlxcdTAwRkNcIixcbiAgeWFjdXRlOiBcIlxcdTAwRkRcIixcbiAgdGhvcm46IFwiXFx1MDBGRVwiLFxuICB5dW1sOiBcIlxcdTAwRkZcIixcbiAgT0VsaWc6IFwiXFx1MDE1MlwiLFxuICBvZWxpZzogXCJcXHUwMTUzXCIsXG4gIFNjYXJvbjogXCJcXHUwMTYwXCIsXG4gIHNjYXJvbjogXCJcXHUwMTYxXCIsXG4gIFl1bWw6IFwiXFx1MDE3OFwiLFxuICBmbm9mOiBcIlxcdTAxOTJcIixcbiAgY2lyYzogXCJcXHUwMkM2XCIsXG4gIHRpbGRlOiBcIlxcdTAyRENcIixcbiAgQWxwaGE6IFwiXFx1MDM5MVwiLFxuICBCZXRhOiBcIlxcdTAzOTJcIixcbiAgR2FtbWE6IFwiXFx1MDM5M1wiLFxuICBEZWx0YTogXCJcXHUwMzk0XCIsXG4gIEVwc2lsb246IFwiXFx1MDM5NVwiLFxuICBaZXRhOiBcIlxcdTAzOTZcIixcbiAgRXRhOiBcIlxcdTAzOTdcIixcbiAgVGhldGE6IFwiXFx1MDM5OFwiLFxuICBJb3RhOiBcIlxcdTAzOTlcIixcbiAgS2FwcGE6IFwiXFx1MDM5QVwiLFxuICBMYW1iZGE6IFwiXFx1MDM5QlwiLFxuICBNdTogXCJcXHUwMzlDXCIsXG4gIE51OiBcIlxcdTAzOURcIixcbiAgWGk6IFwiXFx1MDM5RVwiLFxuICBPbWljcm9uOiBcIlxcdTAzOUZcIixcbiAgUGk6IFwiXFx1MDNBMFwiLFxuICBSaG86IFwiXFx1MDNBMVwiLFxuICBTaWdtYTogXCJcXHUwM0EzXCIsXG4gIFRhdTogXCJcXHUwM0E0XCIsXG4gIFVwc2lsb246IFwiXFx1MDNBNVwiLFxuICBQaGk6IFwiXFx1MDNBNlwiLFxuICBDaGk6IFwiXFx1MDNBN1wiLFxuICBQc2k6IFwiXFx1MDNBOFwiLFxuICBPbWVnYTogXCJcXHUwM0E5XCIsXG4gIGFscGhhOiBcIlxcdTAzQjFcIixcbiAgYmV0YTogXCJcXHUwM0IyXCIsXG4gIGdhbW1hOiBcIlxcdTAzQjNcIixcbiAgZGVsdGE6IFwiXFx1MDNCNFwiLFxuICBlcHNpbG9uOiBcIlxcdTAzQjVcIixcbiAgemV0YTogXCJcXHUwM0I2XCIsXG4gIGV0YTogXCJcXHUwM0I3XCIsXG4gIHRoZXRhOiBcIlxcdTAzQjhcIixcbiAgaW90YTogXCJcXHUwM0I5XCIsXG4gIGthcHBhOiBcIlxcdTAzQkFcIixcbiAgbGFtYmRhOiBcIlxcdTAzQkJcIixcbiAgbXU6IFwiXFx1MDNCQ1wiLFxuICBudTogXCJcXHUwM0JEXCIsXG4gIHhpOiBcIlxcdTAzQkVcIixcbiAgb21pY3JvbjogXCJcXHUwM0JGXCIsXG4gIHBpOiBcIlxcdTAzQzBcIixcbiAgcmhvOiBcIlxcdTAzQzFcIixcbiAgc2lnbWFmOiBcIlxcdTAzQzJcIixcbiAgc2lnbWE6IFwiXFx1MDNDM1wiLFxuICB0YXU6IFwiXFx1MDNDNFwiLFxuICB1cHNpbG9uOiBcIlxcdTAzQzVcIixcbiAgcGhpOiBcIlxcdTAzQzZcIixcbiAgY2hpOiBcIlxcdTAzQzdcIixcbiAgcHNpOiBcIlxcdTAzQzhcIixcbiAgb21lZ2E6IFwiXFx1MDNDOVwiLFxuICB0aGV0YXN5bTogXCJcXHUwM0QxXCIsXG4gIHVwc2loOiBcIlxcdTAzRDJcIixcbiAgcGl2OiBcIlxcdTAzRDZcIixcbiAgZW5zcDogXCJcXHUyMDAyXCIsXG4gIGVtc3A6IFwiXFx1MjAwM1wiLFxuICB0aGluc3A6IFwiXFx1MjAwOVwiLFxuICB6d25qOiBcIlxcdTIwMENcIixcbiAgendqOiBcIlxcdTIwMERcIixcbiAgbHJtOiBcIlxcdTIwMEVcIixcbiAgcmxtOiBcIlxcdTIwMEZcIixcbiAgbmRhc2g6IFwiXFx1MjAxM1wiLFxuICBtZGFzaDogXCJcXHUyMDE0XCIsXG4gIGxzcXVvOiBcIlxcdTIwMThcIixcbiAgcnNxdW86IFwiXFx1MjAxOVwiLFxuICBzYnF1bzogXCJcXHUyMDFBXCIsXG4gIGxkcXVvOiBcIlxcdTIwMUNcIixcbiAgcmRxdW86IFwiXFx1MjAxRFwiLFxuICBiZHF1bzogXCJcXHUyMDFFXCIsXG4gIGRhZ2dlcjogXCJcXHUyMDIwXCIsXG4gIERhZ2dlcjogXCJcXHUyMDIxXCIsXG4gIGJ1bGw6IFwiXFx1MjAyMlwiLFxuICBoZWxsaXA6IFwiXFx1MjAyNlwiLFxuICBwZXJtaWw6IFwiXFx1MjAzMFwiLFxuICBwcmltZTogXCJcXHUyMDMyXCIsXG4gIFByaW1lOiBcIlxcdTIwMzNcIixcbiAgbHNhcXVvOiBcIlxcdTIwMzlcIixcbiAgcnNhcXVvOiBcIlxcdTIwM0FcIixcbiAgb2xpbmU6IFwiXFx1MjAzRVwiLFxuICBmcmFzbDogXCJcXHUyMDQ0XCIsXG4gIGV1cm86IFwiXFx1MjBBQ1wiLFxuICBpbWFnZTogXCJcXHUyMTExXCIsXG4gIHdlaWVycDogXCJcXHUyMTE4XCIsXG4gIHJlYWw6IFwiXFx1MjExQ1wiLFxuICB0cmFkZTogXCJcXHUyMTIyXCIsXG4gIGFsZWZzeW06IFwiXFx1MjEzNVwiLFxuICBsYXJyOiBcIlxcdTIxOTBcIixcbiAgdWFycjogXCJcXHUyMTkxXCIsXG4gIHJhcnI6IFwiXFx1MjE5MlwiLFxuICBkYXJyOiBcIlxcdTIxOTNcIixcbiAgaGFycjogXCJcXHUyMTk0XCIsXG4gIGNyYXJyOiBcIlxcdTIxQjVcIixcbiAgbEFycjogXCJcXHUyMUQwXCIsXG4gIHVBcnI6IFwiXFx1MjFEMVwiLFxuICByQXJyOiBcIlxcdTIxRDJcIixcbiAgZEFycjogXCJcXHUyMUQzXCIsXG4gIGhBcnI6IFwiXFx1MjFENFwiLFxuICBmb3JhbGw6IFwiXFx1MjIwMFwiLFxuICBwYXJ0OiBcIlxcdTIyMDJcIixcbiAgZXhpc3Q6IFwiXFx1MjIwM1wiLFxuICBlbXB0eTogXCJcXHUyMjA1XCIsXG4gIG5hYmxhOiBcIlxcdTIyMDdcIixcbiAgaXNpbjogXCJcXHUyMjA4XCIsXG4gIG5vdGluOiBcIlxcdTIyMDlcIixcbiAgbmk6IFwiXFx1MjIwQlwiLFxuICBwcm9kOiBcIlxcdTIyMEZcIixcbiAgc3VtOiBcIlxcdTIyMTFcIixcbiAgbWludXM6IFwiXFx1MjIxMlwiLFxuICBsb3dhc3Q6IFwiXFx1MjIxN1wiLFxuICByYWRpYzogXCJcXHUyMjFBXCIsXG4gIHByb3A6IFwiXFx1MjIxRFwiLFxuICBpbmZpbjogXCJcXHUyMjFFXCIsXG4gIGFuZzogXCJcXHUyMjIwXCIsXG4gIGFuZDogXCJcXHUyMjI3XCIsXG4gIG9yOiBcIlxcdTIyMjhcIixcbiAgY2FwOiBcIlxcdTIyMjlcIixcbiAgY3VwOiBcIlxcdTIyMkFcIixcbiAgaW50OiBcIlxcdTIyMkJcIixcbiAgdGhlcmU0OiBcIlxcdTIyMzRcIixcbiAgc2ltOiBcIlxcdTIyM0NcIixcbiAgY29uZzogXCJcXHUyMjQ1XCIsXG4gIGFzeW1wOiBcIlxcdTIyNDhcIixcbiAgbmU6IFwiXFx1MjI2MFwiLFxuICBlcXVpdjogXCJcXHUyMjYxXCIsXG4gIGxlOiBcIlxcdTIyNjRcIixcbiAgZ2U6IFwiXFx1MjI2NVwiLFxuICBzdWI6IFwiXFx1MjI4MlwiLFxuICBzdXA6IFwiXFx1MjI4M1wiLFxuICBuc3ViOiBcIlxcdTIyODRcIixcbiAgc3ViZTogXCJcXHUyMjg2XCIsXG4gIHN1cGU6IFwiXFx1MjI4N1wiLFxuICBvcGx1czogXCJcXHUyMjk1XCIsXG4gIG90aW1lczogXCJcXHUyMjk3XCIsXG4gIHBlcnA6IFwiXFx1MjJBNVwiLFxuICBzZG90OiBcIlxcdTIyQzVcIixcbiAgbGNlaWw6IFwiXFx1MjMwOFwiLFxuICByY2VpbDogXCJcXHUyMzA5XCIsXG4gIGxmbG9vcjogXCJcXHUyMzBBXCIsXG4gIHJmbG9vcjogXCJcXHUyMzBCXCIsXG4gIGxhbmc6IFwiXFx1MjMyOVwiLFxuICByYW5nOiBcIlxcdTIzMkFcIixcbiAgbG96OiBcIlxcdTI1Q0FcIixcbiAgc3BhZGVzOiBcIlxcdTI2NjBcIixcbiAgY2x1YnM6IFwiXFx1MjY2M1wiLFxuICBoZWFydHM6IFwiXFx1MjY2NVwiLFxuICBkaWFtczogXCJcXHUyNjY2XCJcbn07XG5jb25zdCBKc3hFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBqc3hgKHtcbiAgQXR0cmlidXRlSXNFbXB0eTogXCJKU1ggYXR0cmlidXRlcyBtdXN0IG9ubHkgYmUgYXNzaWduZWQgYSBub24tZW1wdHkgZXhwcmVzc2lvbi5cIixcbiAgTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50OiAoe1xuICAgIG9wZW5pbmdUYWdOYW1lXG4gIH0pID0+IGBFeHBlY3RlZCBjb3JyZXNwb25kaW5nIEpTWCBjbG9zaW5nIHRhZyBmb3IgPCR7b3BlbmluZ1RhZ05hbWV9Pi5gLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0ZyYWdtZW50OiBcIkV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8Pi5cIixcbiAgVW5leHBlY3RlZFNlcXVlbmNlRXhwcmVzc2lvbjogXCJTZXF1ZW5jZSBleHByZXNzaW9ucyBjYW5ub3QgYmUgZGlyZWN0bHkgbmVzdGVkIGluc2lkZSBKU1guIERpZCB5b3UgbWVhbiB0byB3cmFwIGl0IGluIHBhcmVudGhlc2VzICguLi4pP1wiLFxuICBVbmV4cGVjdGVkVG9rZW46ICh7XG4gICAgdW5leHBlY3RlZCxcbiAgICBIVE1MRW50aXR5XG4gIH0pID0+IGBVbmV4cGVjdGVkIHRva2VuIFxcYCR7dW5leHBlY3RlZH1cXGAuIERpZCB5b3UgbWVhbiBcXGAke0hUTUxFbnRpdHl9XFxgIG9yIFxcYHsnJHt1bmV4cGVjdGVkfSd9XFxgP2AsXG4gIFVuc3VwcG9ydGVkSnN4VmFsdWU6IFwiSlNYIHZhbHVlIHNob3VsZCBiZSBlaXRoZXIgYW4gZXhwcmVzc2lvbiBvciBhIHF1b3RlZCBKU1ggdGV4dC5cIixcbiAgVW50ZXJtaW5hdGVkSnN4Q29udGVudDogXCJVbnRlcm1pbmF0ZWQgSlNYIGNvbnRlbnRzLlwiLFxuICBVbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzOiBcIkFkamFjZW50IEpTWCBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gYW4gZW5jbG9zaW5nIHRhZy4gRGlkIHlvdSB3YW50IGEgSlNYIGZyYWdtZW50IDw+Li4uPC8+P1wiXG59KTtcbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPyBvYmplY3QudHlwZSA9PT0gXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiB8fCBvYmplY3QudHlwZSA9PT0gXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiA6IGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UXVhbGlmaWVkSlNYTmFtZShvYmplY3QpIHtcbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWElkZW50aWZpZXJcIikge1xuICAgIHJldHVybiBvYmplY3QubmFtZTtcbiAgfVxuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikge1xuICAgIHJldHVybiBvYmplY3QubmFtZXNwYWNlLm5hbWUgKyBcIjpcIiArIG9iamVjdC5uYW1lLm5hbWU7XG4gIH1cbiAgaWYgKG9iamVjdC50eXBlID09PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIHJldHVybiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5vYmplY3QpICsgXCIuXCIgKyBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdC5wcm9wZXJ0eSk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBoYWQgdW5leHBlY3RlZCB0eXBlOiBcIiArIG9iamVjdC50eXBlKTtcbn1cbnZhciBqc3ggPSBzdXBlckNsYXNzID0+IGNsYXNzIEpTWFBhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGpzeFJlYWRUb2tlbigpIHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBsZXQgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLnBvcyA+PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbnRlcm1pbmF0ZWRKc3hDb250ZW50LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID09PSB0aGlzLnN0YXRlLnN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDYwICYmIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50KSB7XG4gICAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDIsIG91dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDYyOlxuICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUodHJ1ZSk7XG4gICAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBqc3hSZWFkTmV3TGluZShub3JtYWxpemVDUkxGKSB7XG4gICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgIGxldCBvdXQ7XG4gICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAoY2ggPT09IDEzICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcykgPT09IDEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgb3V0ID0gbm9ybWFsaXplQ1JMRiA/IFwiXFxuXCIgOiBcIlxcclxcblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICB9XG4gICAgKyt0aGlzLnN0YXRlLmN1ckxpbmU7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGpzeFJlYWRTdHJpbmcocXVvdGUpIHtcbiAgICBsZXQgb3V0ID0gXCJcIjtcbiAgICBsZXQgY2h1bmtTdGFydCA9ICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFN0cmluZywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoY2ggPT09IHF1b3RlKSBicmVhaztcbiAgICAgIGlmIChjaCA9PT0gMzgpIHtcbiAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkRW50aXR5KCk7XG4gICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWROZXdMaW5lKGZhbHNlKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MrKyk7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzQsIG91dCk7XG4gIH1cbiAganN4UmVhZEVudGl0eSgpIHtcbiAgICBjb25zdCBzdGFydFBvcyA9ICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgaWYgKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSAzNSkge1xuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIGxldCByYWRpeCA9IDEwO1xuICAgICAgaWYgKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSAxMjApIHtcbiAgICAgICAgcmFkaXggPSAxNjtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHRoaXMucmVhZEludChyYWRpeCwgdW5kZWZpbmVkLCBmYWxzZSwgXCJiYWlsXCIpO1xuICAgICAgaWYgKGNvZGVQb2ludCAhPT0gbnVsbCAmJiB0aGlzLmNvZGVQb2ludEF0UG9zKHRoaXMuc3RhdGUucG9zKSA9PT0gNTkpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICBsZXQgc2VtaSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGNvdW50KysgPCAxMCAmJiB0aGlzLnN0YXRlLnBvcyA8IHRoaXMubGVuZ3RoICYmICEoc2VtaSA9IHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSA1OSkpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIH1cbiAgICAgIGlmIChzZW1pKSB7XG4gICAgICAgIGNvbnN0IGRlc2MgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0UG9zLCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIGNvbnN0IGVudGl0eSA9IGVudGl0aWVzW2Rlc2NdO1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBpZiAoZW50aXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcyA9IHN0YXJ0UG9zO1xuICAgIHJldHVybiBcIiZcIjtcbiAgfVxuICBqc3hSZWFkV29yZCgpIHtcbiAgICBsZXQgY2g7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBkbyB7XG4gICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKTtcbiAgICB9IHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKGNoKSB8fCBjaCA9PT0gNDUpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTQxLCB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykpO1xuICB9XG4gIGpzeFBhcnNlSWRlbnRpZmllcigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDEpKSB7XG4gICAgICBub2RlLm5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5uYW1lID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hJZGVudGlmaWVyXCIpO1xuICB9XG4gIGpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmpzeFBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICghdGhpcy5lYXQoMTQpKSByZXR1cm4gbmFtZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5uYW1lc3BhY2UgPSBuYW1lO1xuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudE5hbWUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBub2RlID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbmV3Tm9kZS5vYmplY3QgPSBub2RlO1xuICAgICAgbmV3Tm9kZS5wcm9wZXJ0eSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICBub2RlID0gdGhpcy5maW5pc2hOb2RlKG5ld05vZGUsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAganN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICBsZXQgbm9kZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmJyYWNlKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIG5vZGUgPSB0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCB0eXBlcy5qX29UYWcpO1xuICAgICAgICBpZiAobm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEpzeEVycm9ycy5BdHRyaWJ1dGVJc0VtcHR5LCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIGNhc2UgMTQzOlxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVuc3VwcG9ydGVkSnN4VmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBqc3hQYXJzZUVtcHR5RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdCh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGVBdChub2RlLCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgfVxuICBqc3hQYXJzZVNwcmVhZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX2V4cHIpO1xuICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYU3ByZWFkQ2hpbGRcIik7XG4gIH1cbiAganN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHByZXZpb3VzQ29udGV4dCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLmpzeFBhcnNlRW1wdHlFeHByZXNzaW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgdGhpcy5zZXRDb250ZXh0KHByZXZpb3VzQ29udGV4dCk7XG4gICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpO1xuICB9XG4gIGpzeFBhcnNlQXR0cmlidXRlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDUpKSB7XG4gICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgyMSk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfb1RhZyk7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmVhdCgyOSkgPyB0aGlzLmpzeFBhcnNlQXR0cmlidXRlVmFsdWUoKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEF0dHJpYnV0ZVwiKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE0NCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHJldHVybiB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSk7XG4gIH1cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg1NikgJiYgIXRoaXMubWF0Y2goMTQ0KSkge1xuICAgICAgYXR0cmlidXRlcy5wdXNoKHRoaXMuanN4UGFyc2VBdHRyaWJ1dGUoKSk7XG4gICAgfVxuICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgbm9kZS5zZWxmQ2xvc2luZyA9IHRoaXMuZWF0KDU2KTtcbiAgICB0aGlzLmV4cGVjdCgxNDQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hPcGVuaW5nRWxlbWVudFwiKTtcbiAgfVxuICBqc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE0NCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIik7XG4gICAgfVxuICAgIG5vZGUubmFtZSA9IHRoaXMuanN4UGFyc2VFbGVtZW50TmFtZSgpO1xuICAgIHRoaXMuZXhwZWN0KDE0NCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0TG9jKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgY29uc3Qgb3BlbmluZ0VsZW1lbnQgPSB0aGlzLmpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdChzdGFydExvYyk7XG4gICAgbGV0IGNsb3NpbmdFbGVtZW50ID0gbnVsbDtcbiAgICBpZiAoIW9wZW5pbmdFbGVtZW50LnNlbGZDbG9zaW5nKSB7XG4gICAgICBjb250ZW50czogZm9yICg7Oykge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgMTQzOlxuICAgICAgICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5lYXQoNTYpKSB7XG4gICAgICAgICAgICAgIGNsb3NpbmdFbGVtZW50ID0gdGhpcy5qc3hQYXJzZUNsb3NpbmdFbGVtZW50QXQoc3RhcnRMb2MpO1xuICAgICAgICAgICAgICBicmVhayBjb250ZW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydExvYykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNDI6XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiSlNYVGV4dFwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlU3ByZWFkQ2hpbGQobm9kZSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5qc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgdHlwZXMual9leHByKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgIWlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpICYmIGNsb3NpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQsIGNsb3NpbmdFbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpICYmIGlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIHtcbiAgICAgICAgICBvcGVuaW5nVGFnTmFtZTogZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpICYmICFpc0ZyYWdtZW50KGNsb3NpbmdFbGVtZW50KSkge1xuICAgICAgICBpZiAoZ2V0UXVhbGlmaWVkSlNYTmFtZShjbG9zaW5nRWxlbWVudC5uYW1lKSAhPT0gZ2V0UXVhbGlmaWVkSlNYTmFtZShvcGVuaW5nRWxlbWVudC5uYW1lKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLk1pc3NpbmdDbG9zaW5nVGFnRWxlbWVudCwgY2xvc2luZ0VsZW1lbnQsIHtcbiAgICAgICAgICAgIG9wZW5pbmdUYWdOYW1lOiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpKSB7XG4gICAgICBub2RlLm9wZW5pbmdGcmFnbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICAgICAgbm9kZS5jbG9zaW5nRnJhZ21lbnQgPSBjbG9zaW5nRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcGVuaW5nRWxlbWVudCA9IG9wZW5pbmdFbGVtZW50O1xuICAgICAgbm9kZS5jbG9zaW5nRWxlbWVudCA9IGNsb3NpbmdFbGVtZW50O1xuICAgIH1cbiAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEpzeEVycm9ycy5VbndyYXBwZWRBZGphY2VudEpTWEVsZW1lbnRzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRnJhZ21lbnQob3BlbmluZ0VsZW1lbnQpID8gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYRnJhZ21lbnRcIikgOiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlRWxlbWVudCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50QXQoc3RhcnRMb2MpO1xuICB9XG4gIHNldENvbnRleHQobmV3Q29udGV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHRcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPSBuZXdDb250ZXh0O1xuICB9XG4gIHBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0MykpIHtcbiAgICAgIHJldHVybiB0aGlzLmpzeFBhcnNlRWxlbWVudCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg0NykgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSAhPT0gMzMpIHtcbiAgICAgIHRoaXMucmVwbGFjZVRva2VuKDE0Myk7XG4gICAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuICB9XG4gIHNraXBTcGFjZSgpIHtcbiAgICBjb25zdCBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gICAgaWYgKCFjdXJDb250ZXh0LnByZXNlcnZlU3BhY2UpIHN1cGVyLnNraXBTcGFjZSgpO1xuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMual9leHByKSB7XG4gICAgICB0aGlzLmpzeFJlYWRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGNvbnRleHQgPT09IHR5cGVzLmpfY1RhZykge1xuICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGNvZGUpKSB7XG4gICAgICAgIHRoaXMuanN4UmVhZFdvcmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDYyKSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChjb2RlID09PSAzNCB8fCBjb2RlID09PSAzOSkgJiYgY29udGV4dCA9PT0gdHlwZXMual9vVGFnKSB7XG4gICAgICAgIHRoaXMuanN4UmVhZFN0cmluZyhjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSkgIT09IDMzKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG4gIHVwZGF0ZUNvbnRleHQocHJldlR5cGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1NiAmJiBwcmV2VHlwZSA9PT0gMTQzKSB7XG4gICAgICBjb250ZXh0LnNwbGljZSgtMiwgMiwgdHlwZXMual9jVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxNDMpIHtcbiAgICAgIGNvbnRleHQucHVzaCh0eXBlcy5qX29UYWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMTQ0KSB7XG4gICAgICBjb25zdCBvdXQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV07XG4gICAgICBpZiAob3V0ID09PSB0eXBlcy5qX29UYWcgJiYgcHJldlR5cGUgPT09IDU2IHx8IG91dCA9PT0gdHlwZXMual9jVGFnKSB7XG4gICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdID09PSB0eXBlcy5qX2V4cHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9leHByKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHR5cGUpO1xuICAgIH1cbiAgfVxufTtcbmNsYXNzIFR5cGVTY3JpcHRTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNOYW1lcyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuY2xhc3MgVHlwZVNjcmlwdFNjb3BlSGFuZGxlciBleHRlbmRzIFNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmltcG9ydHNTdGFjayA9IFtdO1xuICB9XG4gIGNyZWF0ZVNjb3BlKGZsYWdzKSB7XG4gICAgdGhpcy5pbXBvcnRzU3RhY2sucHVzaChuZXcgU2V0KCkpO1xuICAgIHJldHVybiBuZXcgVHlwZVNjcmlwdFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIGlmIChmbGFncyA9PT0gMjU2KSB7XG4gICAgICB0aGlzLmltcG9ydHNTdGFjay5wdXNoKG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIHN1cGVyLmVudGVyKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IGZsYWdzID0gc3VwZXIuZXhpdCgpO1xuICAgIGlmIChmbGFncyA9PT0gMjU2KSB7XG4gICAgICB0aGlzLmltcG9ydHNTdGFjay5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xuICB9XG4gIGhhc0ltcG9ydChuYW1lLCBhbGxvd1NoYWRvdykge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuaW1wb3J0c1N0YWNrLmxlbmd0aDtcbiAgICBpZiAodGhpcy5pbXBvcnRzU3RhY2tbbGVuIC0gMV0uaGFzKG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd1NoYWRvdyAmJiBsZW4gPiAxKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbiAtIDE7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5pbXBvcnRzU3RhY2tbaV0uaGFzKG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpIHtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA0MDk2KSB7XG4gICAgICBpZiAodGhpcy5oYXNJbXBvcnQobmFtZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlZhclJlZGVjbGFyYXRpb24sIGxvYywge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbXBvcnRzU3RhY2tbdGhpcy5pbXBvcnRzU3RhY2subGVuZ3RoIC0gMV0uYWRkKG5hbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgbGV0IHR5cGUgPSBzY29wZS50c05hbWVzLmdldChuYW1lKSB8fCAwO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDEwMjQpIHtcbiAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIHNjb3BlLnRzTmFtZXMuc2V0KG5hbWUsIHR5cGUgfCAxNik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRlY2xhcmVOYW1lKG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDIpIHtcbiAgICAgIGlmICghKGJpbmRpbmdUeXBlICYgMSkpIHtcbiAgICAgICAgdGhpcy5jaGVja1JlZGVjbGFyYXRpb25JblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICAgICAgdGhpcy5tYXliZUV4cG9ydERlZmluZWQoc2NvcGUsIG5hbWUpO1xuICAgICAgfVxuICAgICAgdHlwZSA9IHR5cGUgfCAxO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyNTYpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHwgMjtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNTEyKSB7XG4gICAgICB0eXBlID0gdHlwZSB8IDQ7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDEyOCkge1xuICAgICAgdHlwZSA9IHR5cGUgfCA4O1xuICAgIH1cbiAgICBpZiAodHlwZSkgc2NvcGUudHNOYW1lcy5zZXQobmFtZSwgdHlwZSk7XG4gIH1cbiAgaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpIHtcbiAgICBjb25zdCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSk7XG4gICAgaWYgKCh0eXBlICYgMikgPiAwKSB7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgJiAyNTYpIHtcbiAgICAgICAgY29uc3QgaXNDb25zdCA9ICEhKGJpbmRpbmdUeXBlICYgNTEyKTtcbiAgICAgICAgY29uc3Qgd2FzQ29uc3QgPSAodHlwZSAmIDQpID4gMDtcbiAgICAgICAgcmV0dXJuIGlzQ29uc3QgIT09IHdhc0NvbnN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDEyOCAmJiAodHlwZSAmIDgpID4gMCkge1xuICAgICAgaWYgKHNjb3BlLm5hbWVzLmdldChuYW1lKSAmIDIpIHtcbiAgICAgICAgcmV0dXJuICEhKGJpbmRpbmdUeXBlICYgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDIgJiYgKHR5cGUgJiAxKSA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpO1xuICB9XG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lXG4gICAgfSA9IGlkO1xuICAgIGlmICh0aGlzLmhhc0ltcG9ydChuYW1lKSkgcmV0dXJuO1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuc2NvcGVTdGFjay5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGNvbnN0IHR5cGUgPSBzY29wZS50c05hbWVzLmdldChuYW1lKTtcbiAgICAgIGlmICgodHlwZSAmIDEpID4gMCB8fCAodHlwZSAmIDE2KSA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5jaGVja0xvY2FsRXhwb3J0KGlkKTtcbiAgfVxufVxuY29uc3QgdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSBub2RlID0+IHtcbiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiID8gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZS5leHByZXNzaW9uKSA6IG5vZGU7XG59O1xuY2xhc3MgTFZhbFBhcnNlciBleHRlbmRzIE5vZGVVdGlscyB7XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhLCBfbm9kZSRleHRyYTM7XG4gICAgbGV0IHBhcmVudGhlc2l6ZWQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiIHx8IChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcGFyZW50aGVzaXplZCA9IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUpO1xuICAgICAgaWYgKGlzTEhTKSB7XG4gICAgICAgIGlmIChwYXJlbnRoZXNpemVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXJyb3dQYXJhbWV0ZXJCaW5kaW5nRXJyb3IoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyZW50aGVzaXplZC50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiAmJiAhdGhpcy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihwYXJlbnRoZXNpemVkKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQYXJlbnRoZXNpemVkQXNzaWdubWVudCwgbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoLCBsYXN0ID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIF9ub2RlJGV4dHJhMjtcbiAgICAgICAgICBjb25zdCBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IGkgPT09IGxhc3Q7XG4gICAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QsIGlzTEhTKTtcbiAgICAgICAgICBpZiAoaXNMYXN0ICYmIHByb3AudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIChfbm9kZSRleHRyYTIgPSBub2RlLmV4dHJhKSAhPSBudWxsICYmIF9ub2RlJGV4dHJhMi50cmFpbGluZ0NvbW1hTG9jKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgbm9kZS5leHRyYS50cmFpbGluZ0NvbW1hTG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IG5vZGU7XG4gICAgICAgICAgaWYgKHRoaXMuaXNQcml2YXRlTmFtZShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5nZXRQcml2YXRlTmFtZVNWKGtleSksIGtleS5sb2Muc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZSh2YWx1ZSwgaXNMSFMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgQGJhYmVsL3BhcnNlciBlcnJvciAodGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdCkuXCIgKyBcIiBTcHJlYWRFbGVtZW50IHNob3VsZCBiZSBjb252ZXJ0ZWQgYnkgLnRvQXNzaWduYWJsZSdzIGNhbGxlci5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS50eXBlID0gXCJBcnJheVBhdHRlcm5cIjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KG5vZGUuZWxlbWVudHMsIChfbm9kZSRleHRyYTMgPSBub2RlLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZXh0cmEzLnRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ0VxSW5Bc3NpZ25tZW50LCBub2RlLmxlZnQubG9jLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS50eXBlID0gXCJBc3NpZ25tZW50UGF0dGVyblwiO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5sZWZ0LCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHBhcmVudGhlc2l6ZWQsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIgPyBFcnJvcnMuUGF0dGVybkhhc0FjY2Vzc29yIDogRXJyb3JzLlBhdHRlcm5IYXNNZXRob2QsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgIHByb3AudHlwZSA9IFwiUmVzdEVsZW1lbnRcIjtcbiAgICAgIGNvbnN0IGFyZyA9IHByb3AuYXJndW1lbnQ7XG4gICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihhcmcsIGZhbHNlKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIHByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKSB7XG4gICAgY29uc3QgZW5kID0gZXhwckxpc3QubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoIWVsdCkgY29udGludWU7XG4gICAgICBpZiAoZWx0LnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgIGVsdC50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgICBjb25zdCBhcmcgPSBlbHQuYXJndW1lbnQ7XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKGFyZywgdHJ1ZSk7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUoZWx0LCBpc0xIUyk7XG4gICAgICB9XG4gICAgICBpZiAoZWx0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICBpZiAoaSA8IGVuZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBlbHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxhc3QgPSBub2RlLnByb3BlcnRpZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzLmV2ZXJ5KChwcm9wLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcC50eXBlICE9PSBcIk9iamVjdE1ldGhvZFwiICYmIChpID09PSBsYXN0IHx8IHByb3AudHlwZSAhPT0gXCJTcHJlYWRFbGVtZW50XCIpICYmIHRoaXMuaXNBc3NpZ25hYmxlKHByb3ApO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUudmFsdWUpO1xuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuYXJndW1lbnQpO1xuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5lbGVtZW50cy5ldmVyeShlbGVtZW50ID0+IGVsZW1lbnQgPT09IG51bGwgfHwgdGhpcy5pc0Fzc2lnbmFibGUoZWxlbWVudCkpO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBub2RlLm9wZXJhdG9yID09PSBcIj1cIjtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uKTtcbiAgICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiAhaXNCaW5kaW5nO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc1BhcmVudGhlc2l6ZWRFeHByKTtcbiAgICBmb3IgKGNvbnN0IGV4cHIgb2YgZXhwckxpc3QpIHtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJBcnJheUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHIuZWxlbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ByZWFkRWxlbWVudFwiKTtcbiAgfVxuICBwYXJzZVJlc3RCaW5kaW5nKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCgzLCA5MywgMSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICB9XG4gIHBhcnNlQmluZGluZ0xpc3QoY2xvc2UsIGNsb3NlQ2hhckNvZGUsIGZsYWdzKSB7XG4gICAgY29uc3QgYWxsb3dFbXB0eSA9IGZsYWdzICYgMTtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgICAgbGV0IHJlc3QgPSB0aGlzLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZmxvd1wiKSB8fCBmbGFncyAmIDIpIHtcbiAgICAgICAgICByZXN0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2VDaGFyQ29kZSkpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdChjbG9zZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMjYpICYmIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkUGFyYW1ldGVyRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUFzc2lnbmFibGVMaXN0SXRlbShmbGFncywgZGVjb3JhdG9ycykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBwYXJzZUJpbmRpbmdSZXN0UHJvcGVydHkocHJvcCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdCgxMjUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJSZXN0RWxlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdQcm9wZXJ0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMjEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQmluZGluZ1Jlc3RQcm9wZXJ0eSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICB9XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZXN0cnVjdHVyaW5nUHJpdmF0ZVwiLCBzdGFydExvYyk7XG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgc3RhcnRMb2MpO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICB9XG4gICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgZmFsc2UsIGZhbHNlLCB0cnVlLCBmYWxzZSk7XG4gIH1cbiAgcGFyc2VBc3NpZ25hYmxlTGlzdEl0ZW0oZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZsb3dcIikgfHwgZmxhZ3MgJiAyKSB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUobGVmdCk7XG4gICAgfVxuICAgIGNvbnN0IGVsdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQobGVmdC5sb2Muc3RhcnQsIGxlZnQpO1xuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgbGVmdC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICB9XG4gICAgcmV0dXJuIGVsdDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgdmFyIF9zdGFydExvYywgX2xlZnQ7XG4gICAgKF9zdGFydExvYyA9IHN0YXJ0TG9jKSAhPSBudWxsID8gX3N0YXJ0TG9jIDogc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxlZnQgPSAoX2xlZnQgPSBsZWZ0KSAhPSBudWxsID8gX2xlZnQgOiB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoIXRoaXMuZWF0KDI5KSkgcmV0dXJuIGxlZnQ7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJhcmd1bWVudFwiO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBcInZhbHVlXCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwcmVzc2lvblwiO1xuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gXCJlbGVtZW50c1wiO1xuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydGllc1wiO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI7XG4gIH1cbiAgY2hlY2tMVmFsKGV4cHJlc3Npb24sIGFuY2VzdG9yLCBiaW5kaW5nID0gNjQsIGNoZWNrQ2xhc2hlcyA9IGZhbHNlLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlLCBoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgPSBmYWxzZSkge1xuICAgIHZhciBfZXhwcmVzc2lvbiRleHRyYTtcbiAgICBjb25zdCB0eXBlID0gZXhwcmVzc2lvbi50eXBlO1xuICAgIGlmICh0aGlzLmlzT2JqZWN0TWV0aG9kKGV4cHJlc3Npb24pKSByZXR1cm47XG4gICAgY29uc3QgaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSB0aGlzLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKGV4cHJlc3Npb24pO1xuICAgIGlmIChpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiB8fCB0eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgaWYgKGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiLCBleHByZXNzaW9uLmxvYy5zdGFydCk7XG4gICAgICAgIGlmIChhbmNlc3Rvci50eXBlICE9PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTGhzT3B0aW9uYWxDaGFpbmluZywgZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgYW5jZXN0b3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGJpbmRpbmcgIT09IDY0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRQcm9wZXJ0eUJpbmRpbmdQYXR0ZXJuLCBleHByZXNzaW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihleHByZXNzaW9uLCBiaW5kaW5nLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBleHByZXNzaW9uO1xuICAgICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgICBpZiAoY2hlY2tDbGFzaGVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBhcmFtRHVwZSwgZXhwcmVzc2lvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hlY2tDbGFzaGVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB2YWxpZGl0eSA9IHRoaXMuaXNWYWxpZExWYWwodHlwZSwgIShoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgfHwgKF9leHByZXNzaW9uJGV4dHJhID0gZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfZXhwcmVzc2lvbiRleHRyYS5wYXJlbnRoZXNpemVkKSAmJiBhbmNlc3Rvci50eXBlID09PSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIGJpbmRpbmcpO1xuICAgIGlmICh2YWxpZGl0eSA9PT0gdHJ1ZSkgcmV0dXJuO1xuICAgIGlmICh2YWxpZGl0eSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IFBhcnNlRXJyb3JDbGFzcyA9IGJpbmRpbmcgPT09IDY0ID8gRXJyb3JzLkludmFsaWRMaHMgOiBFcnJvcnMuSW52YWxpZExoc0JpbmRpbmc7XG4gICAgICB0aGlzLnJhaXNlKFBhcnNlRXJyb3JDbGFzcywgZXhwcmVzc2lvbiwge1xuICAgICAgICBhbmNlc3RvclxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBrZXksIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb247XG4gICAgaWYgKHR5cGVvZiB2YWxpZGl0eSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAga2V5ID0gdmFsaWRpdHk7XG4gICAgICBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gdHlwZSA9PT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBba2V5LCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uXSA9IHZhbGlkaXR5O1xuICAgIH1cbiAgICBjb25zdCBuZXh0QW5jZXN0b3IgPSB0eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IHR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiID8ge1xuICAgICAgdHlwZVxuICAgIH0gOiBhbmNlc3RvcjtcbiAgICBjb25zdCB2YWwgPSBleHByZXNzaW9uW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB2YWwpIHtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0xWYWwoY2hpbGQsIG5leHRBbmNlc3RvciwgYmluZGluZywgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCkge1xuICAgICAgdGhpcy5jaGVja0xWYWwodmFsLCBuZXh0QW5jZXN0b3IsIGJpbmRpbmcsIGNoZWNrQ2xhc2hlcywgc3RyaWN0TW9kZUNoYW5nZWQsIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24pO1xuICAgIH1cbiAgfVxuICBjaGVja0lkZW50aWZpZXIoYXQsIGJpbmRpbmdUeXBlLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIChzdHJpY3RNb2RlQ2hhbmdlZCA/IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZChhdC5uYW1lLCB0aGlzLmluTW9kdWxlKSA6IGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQoYXQubmFtZSkpKSB7XG4gICAgICBpZiAoYmluZGluZ1R5cGUgPT09IDY0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdEV2YWxBcmd1bWVudHMsIGF0LCB7XG4gICAgICAgICAgcmVmZXJlbmNlTmFtZTogYXQubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdEV2YWxBcmd1bWVudHNCaW5kaW5nLCBhdCwge1xuICAgICAgICAgIGJpbmRpbmdOYW1lOiBhdC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4MTkyICYmIGF0Lm5hbWUgPT09IFwibGV0XCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxldEluTGV4aWNhbEJpbmRpbmcsIGF0KTtcbiAgICB9XG4gICAgaWYgKCEoYmluZGluZ1R5cGUgJiA2NCkpIHtcbiAgICAgIHRoaXMuZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihhdCwgYmluZGluZ1R5cGUpO1xuICAgIH1cbiAgfVxuICBkZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKGlkZW50aWZpZXIsIGJpbmRpbmcpIHtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKGlkZW50aWZpZXIubmFtZSwgYmluZGluZywgaWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICB9XG4gIGNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUuZXhwcmVzc2lvbiwgYWxsb3dQYXR0ZXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXJyYXlFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoYWxsb3dQYXR0ZXJuKSBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm4sIG5vZGUpO1xuICAgIH1cbiAgfVxuICBjaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnJhaXNlKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gY2xvc2UgPyBFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEgOiBFcnJvcnMuRWxlbWVudEFmdGVyUmVzdCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vbk51bGwoeCkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkICR7eH0gdmFsdWUuYCk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhc3NlcnQoeCkge1xuICBpZiAoIXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnQgZmFpbFwiKTtcbiAgfVxufVxuY29uc3QgVFNFcnJvcnMgPSBQYXJzZUVycm9yRW51bWB0eXBlc2NyaXB0YCh7XG4gIEFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb246ICh7XG4gICAgbWV0aG9kTmFtZVxuICB9KSA9PiBgTWV0aG9kICcke21ldGhvZE5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBYnN0cmFjdFByb3BlcnR5SGFzSW5pdGlhbGl6ZXI6ICh7XG4gICAgcHJvcGVydHlOYW1lXG4gIH0pID0+IGBQcm9wZXJ0eSAnJHtwcm9wZXJ0eU5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbml0aWFsaXplciBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBY2Nlc3NvckNhbm5vdEJlT3B0aW9uYWw6IFwiQW4gJ2FjY2Vzc29yJyBwcm9wZXJ0eSBjYW5ub3QgYmUgZGVjbGFyZWQgb3B0aW9uYWwuXCIsXG4gIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiJ2dldCcgYW5kICdzZXQnIGFjY2Vzc29ycyBjYW5ub3QgZGVjbGFyZSAndGhpcycgcGFyYW1ldGVycy5cIixcbiAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQW4gYWNjZXNzb3IgY2Fubm90IGhhdmUgdHlwZSBwYXJhbWV0ZXJzLlwiLFxuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBDbGFzc01ldGhvZEhhc1JlYWRvbmx5OiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXIuXCIsXG4gIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJBICdjb25zdCcgaW5pdGlhbGl6ZXIgaW4gYW4gYW1iaWVudCBjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtZXJpYyBsaXRlcmFsIG9yIGxpdGVyYWwgZW51bSByZWZlcmVuY2UuXCIsXG4gIENvbnN0cnVjdG9ySGFzVHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbm5vdCBhcHBlYXIgb24gYSBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi5cIixcbiAgRGVjbGFyZUFjY2Vzc29yOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYCdkZWNsYXJlJyBpcyBub3QgYWxsb3dlZCBpbiAke2tpbmR9dGVycy5gLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgRGVjbGFyZUZ1bmN0aW9uSGFzSW1wbGVtZW50YXRpb246IFwiQW4gaW1wbGVtZW50YXRpb24gY2Fubm90IGJlIGRlY2xhcmVkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIER1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgQWNjZXNzaWJpbGl0eSBtb2RpZmllciBhbHJlYWR5IHNlZW4uYCxcbiAgRHVwbGljYXRlTW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYER1cGxpY2F0ZSBtb2RpZmllcjogJyR7bW9kaWZpZXJ9Jy5gLFxuICBFbXB0eUhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbm5vdCBiZSBlbXB0eS5gLFxuICBFbXB0eVR5cGVBcmd1bWVudHM6IFwiVHlwZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRW1wdHlUeXBlUGFyYW1ldGVyczogXCJUeXBlIHBhcmFtZXRlciBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRXhwZWN0ZWRBbWJpZW50QWZ0ZXJFeHBvcnREZWNsYXJlOiBcIidleHBvcnQgZGVjbGFyZScgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBhbWJpZW50IGRlY2xhcmF0aW9uLlwiLFxuICBJbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGU6IFwiQW4gaW1wb3J0IGFsaWFzIGNhbiBub3QgdXNlICdpbXBvcnQgdHlwZScuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25IYXNJbXBvcnRUeXBlOiBcIkFuIGBpbXBvcnQgbW9kdWxlYCBkZWNsYXJhdGlvbiBjYW4gbm90IHVzZSBgdHlwZWAgbW9kaWZpZXJcIixcbiAgSW5jb21wYXRpYmxlTW9kaWZpZXJzOiAoe1xuICAgIG1vZGlmaWVyc1xuICB9KSA9PiBgJyR7bW9kaWZpZXJzWzBdfScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgd2l0aCAnJHttb2RpZmllcnNbMV19JyBtb2RpZmllci5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0OiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdhYnN0cmFjdCcgbW9kaWZpZXIuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eTogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJHttb2RpZmllcn0nKS5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0RlY2xhcmU6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc092ZXJyaWRlOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhbiBpbmRleCBzaWduYXR1cmUuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzU3RhdGljOiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdzdGF0aWMnIG1vZGlmaWVyLlwiLFxuICBJbml0aWFsaXplck5vdEFsbG93ZWRJbkFtYmllbnRDb250ZXh0OiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlTWVtYmVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB0eXBlIG1lbWJlci5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIHR5cGUgcGFyYW1ldGVyLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uczogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSB0eXBlIHBhcmFtZXRlciBvZiBhIGNsYXNzLCBpbnRlcmZhY2Ugb3IgdHlwZSBhbGlhcy5gLFxuICBJbnZhbGlkTW9kaWZpZXJzT3JkZXI6ICh7XG4gICAgb3JkZXJlZE1vZGlmaWVyc1xuICB9KSA9PiBgJyR7b3JkZXJlZE1vZGlmaWVyc1swXX0nIG1vZGlmaWVyIG11c3QgcHJlY2VkZSAnJHtvcmRlcmVkTW9kaWZpZXJzWzFdfScgbW9kaWZpZXIuYCxcbiAgSW52YWxpZFByb3BlcnR5QWNjZXNzQWZ0ZXJJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjogXCJJbnZhbGlkIHByb3BlcnR5IGFjY2VzcyBhZnRlciBhbiBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24uIFwiICsgXCJZb3UgY2FuIGVpdGhlciB3cmFwIHRoZSBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24gaW4gcGFyZW50aGVzZXMsIG9yIGRlbGV0ZSB0aGUgdHlwZSBhcmd1bWVudHMuXCIsXG4gIEludmFsaWRUdXBsZU1lbWJlckxhYmVsOiBcIlR1cGxlIG1lbWJlcnMgbXVzdCBiZSBsYWJlbGVkIHdpdGggYSBzaW1wbGUgaWRlbnRpZmllci5cIixcbiAgTWlzc2luZ0ludGVyZmFjZU5hbWU6IFwiJ2ludGVyZmFjZScgZGVjbGFyYXRpb25zIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllci5cIixcbiAgTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kOiBcIkFic3RyYWN0IG1ldGhvZHMgY2FuIG9ubHkgYXBwZWFyIHdpdGhpbiBhbiBhYnN0cmFjdCBjbGFzcy5cIixcbiAgTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZlcjogXCInYWJzdHJhY3QnIG1vZGlmaWVyIGNhbiBvbmx5IGFwcGVhciBvbiBhIGNsYXNzLCBtZXRob2QsIG9yIHByb3BlcnR5IGRlY2xhcmF0aW9uLlwiLFxuICBPcHRpb25hbFR5cGVCZWZvcmVSZXF1aXJlZDogXCJBIHJlcXVpcmVkIGVsZW1lbnQgY2Fubm90IGZvbGxvdyBhbiBvcHRpb25hbCBlbGVtZW50LlwiLFxuICBPdmVycmlkZU5vdEluU3ViQ2xhc3M6IFwiVGhpcyBtZW1iZXIgY2Fubm90IGhhdmUgYW4gJ292ZXJyaWRlJyBtb2RpZmllciBiZWNhdXNlIGl0cyBjb250YWluaW5nIGNsYXNzIGRvZXMgbm90IGV4dGVuZCBhbm90aGVyIGNsYXNzLlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBYnN0cmFjdDogXCJQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIHRoZSAnYWJzdHJhY3QnIG1vZGlmaWVyLlwiLFxuICBQcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHk6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYFByaXZhdGUgZWxlbWVudHMgY2Fubm90IGhhdmUgYW4gYWNjZXNzaWJpbGl0eSBtb2RpZmllciAoJyR7bW9kaWZpZXJ9JykuYCxcbiAgUmVhZG9ubHlGb3JNZXRob2RTaWduYXR1cmU6IFwiJ3JlYWRvbmx5JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSBwcm9wZXJ0eSBkZWNsYXJhdGlvbiBvciBpbmRleCBzaWduYXR1cmUuXCIsXG4gIFJlc2VydmVkQXJyb3dUeXBlUGFyYW06IFwiVGhpcyBzeW50YXggaXMgcmVzZXJ2ZWQgaW4gZmlsZXMgd2l0aCB0aGUgLm10cyBvciAuY3RzIGV4dGVuc2lvbi4gQWRkIGEgdHJhaWxpbmcgY29tbWEsIGFzIGluIGA8VCw+KCkgPT4gLi4uYC5cIixcbiAgUmVzZXJ2ZWRUeXBlQXNzZXJ0aW9uOiBcIlRoaXMgc3ludGF4IGlzIHJlc2VydmVkIGluIGZpbGVzIHdpdGggdGhlIC5tdHMgb3IgLmN0cyBleHRlbnNpb24uIFVzZSBhbiBgYXNgIGV4cHJlc3Npb24gaW5zdGVhZC5cIixcbiAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXI6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSBhbiBvcHRpb25hbCBwYXJhbWV0ZXIuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXI6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSByZXN0IHBhcmFtZXRlci5cIixcbiAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZTogXCJBICdzZXQnIGFjY2Vzc29yIGNhbm5vdCBoYXZlIGEgcmV0dXJuIHR5cGUgYW5ub3RhdGlvbi5cIixcbiAgU2luZ2xlVHlwZVBhcmFtZXRlcldpdGhvdXRUcmFpbGluZ0NvbW1hOiAoe1xuICAgIHR5cGVQYXJhbWV0ZXJOYW1lXG4gIH0pID0+IGBTaW5nbGUgdHlwZSBwYXJhbWV0ZXIgJHt0eXBlUGFyYW1ldGVyTmFtZX0gc2hvdWxkIGhhdmUgYSB0cmFpbGluZyBjb21tYS4gRXhhbXBsZSB1c2FnZTogPCR7dHlwZVBhcmFtZXRlck5hbWV9LD4uYCxcbiAgU3RhdGljQmxvY2tDYW5ub3RIYXZlTW9kaWZpZXI6IFwiU3RhdGljIGNsYXNzIGJsb2NrcyBjYW5ub3QgaGF2ZSBhbnkgbW9kaWZpZXIuXCIsXG4gIFR1cGxlT3B0aW9uYWxBZnRlclR5cGU6IFwiQSBsYWJlbGVkIHR1cGxlIG9wdGlvbmFsIGVsZW1lbnQgbXVzdCBiZSBkZWNsYXJlZCB1c2luZyBhIHF1ZXN0aW9uIG1hcmsgYWZ0ZXIgdGhlIG5hbWUgYW5kIGJlZm9yZSB0aGUgY29sb24gKGBuYW1lPzogdHlwZWApLCByYXRoZXIgdGhhbiBhZnRlciB0aGUgdHlwZSAoYG5hbWU6IHR5cGU/YCkuXCIsXG4gIFR5cGVBbm5vdGF0aW9uQWZ0ZXJBc3NpZ246IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YC5cIixcbiAgVHlwZUltcG9ydENhbm5vdFNwZWNpZnlEZWZhdWx0QW5kTmFtZWQ6IFwiQSB0eXBlLW9ubHkgaW1wb3J0IGNhbiBzcGVjaWZ5IGEgZGVmYXVsdCBpbXBvcnQgb3IgbmFtZWQgYmluZGluZ3MsIGJ1dCBub3QgYm90aC5cIixcbiAgVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlRXhwb3J0czogXCJUaGUgJ3R5cGUnIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbmFtZWQgZXhwb3J0IHdoZW4gJ2V4cG9ydCB0eXBlJyBpcyB1c2VkIG9uIGl0cyBleHBvcnQgc3RhdGVtZW50LlwiLFxuICBUeXBlTW9kaWZpZXJJc1VzZWRJblR5cGVJbXBvcnRzOiBcIlRoZSAndHlwZScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgb24gYSBuYW1lZCBpbXBvcnQgd2hlbiAnaW1wb3J0IHR5cGUnIGlzIHVzZWQgb24gaXRzIGltcG9ydCBzdGF0ZW1lbnQuXCIsXG4gIFVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllcjogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBpcyBvbmx5IGFsbG93ZWQgaW4gYSBjb25zdHJ1Y3RvciBpbXBsZW1lbnRhdGlvbi5cIixcbiAgVW5leHBlY3RlZFJlYWRvbmx5OiBcIidyZWFkb25seScgdHlwZSBtb2RpZmllciBpcyBvbmx5IHBlcm1pdHRlZCBvbiBhcnJheSBhbmQgdHVwbGUgbGl0ZXJhbCB0eXBlcy5cIixcbiAgVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uOiBcIkRpZCBub3QgZXhwZWN0IGEgdHlwZSBhbm5vdGF0aW9uIGhlcmUuXCIsXG4gIFVuZXhwZWN0ZWRUeXBlQ2FzdEluUGFyYW1ldGVyOiBcIlVuZXhwZWN0ZWQgdHlwZSBjYXN0IGluIHBhcmFtZXRlciBwb3NpdGlvbi5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnRUeXBlQXJndW1lbnQ6IFwiQXJndW1lbnQgaW4gYSB0eXBlIGltcG9ydCBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuXCIsXG4gIFVuc3VwcG9ydGVkUGFyYW1ldGVyUHJvcGVydHlLaW5kOiBcIkEgcGFyYW1ldGVyIHByb3BlcnR5IG1heSBub3QgYmUgZGVjbGFyZWQgdXNpbmcgYSBiaW5kaW5nIHBhdHRlcm4uXCIsXG4gIFVuc3VwcG9ydGVkU2lnbmF0dXJlUGFyYW1ldGVyS2luZDogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBOYW1lIGluIGEgc2lnbmF0dXJlIG11c3QgYmUgYW4gSWRlbnRpZmllciwgT2JqZWN0UGF0dGVybiBvciBBcnJheVBhdHRlcm4sIGluc3RlYWQgZ290ICR7dHlwZX0uYFxufSk7XG5mdW5jdGlvbiBrZXl3b3JkVHlwZUZyb21OYW1lKHZhbHVlKSB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwiYW55XCI6XG4gICAgICByZXR1cm4gXCJUU0FueUtleXdvcmRcIjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFwiVFNCb29sZWFuS2V5d29yZFwiO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBcIlRTQmlnSW50S2V5d29yZFwiO1xuICAgIGNhc2UgXCJuZXZlclwiOlxuICAgICAgcmV0dXJuIFwiVFNOZXZlcktleXdvcmRcIjtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICByZXR1cm4gXCJUU051bWJlcktleXdvcmRcIjtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gXCJUU09iamVjdEtleXdvcmRcIjtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gXCJUU1N0cmluZ0tleXdvcmRcIjtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gXCJUU1N5bWJvbEtleXdvcmRcIjtcbiAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICByZXR1cm4gXCJUU1VuZGVmaW5lZEtleXdvcmRcIjtcbiAgICBjYXNlIFwidW5rbm93blwiOlxuICAgICAgcmV0dXJuIFwiVFNVbmtub3duS2V5d29yZFwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5mdW5jdGlvbiB0c0lzQWNjZXNzTW9kaWZpZXIobW9kaWZpZXIpIHtcbiAgcmV0dXJuIG1vZGlmaWVyID09PSBcInByaXZhdGVcIiB8fCBtb2RpZmllciA9PT0gXCJwdWJsaWNcIiB8fCBtb2RpZmllciA9PT0gXCJwcm90ZWN0ZWRcIjtcbn1cbmZ1bmN0aW9uIHRzSXNWYXJpYW5jZUFubm90YXRpb25zKG1vZGlmaWVyKSB7XG4gIHJldHVybiBtb2RpZmllciA9PT0gXCJpblwiIHx8IG1vZGlmaWVyID09PSBcIm91dFwiO1xufVxudmFyIHR5cGVzY3JpcHQgPSBzdXBlckNsYXNzID0+IGNsYXNzIFR5cGVTY3JpcHRQYXJzZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMgPSB0aGlzLnRzUGFyc2VNb2RpZmllcnMuYmluZCh0aGlzLCB7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcImNvbnN0XCIsIFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInJlYWRvbmx5XCIsIFwiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJcbiAgICB9KTtcbiAgICB0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiY29uc3RcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIGVycm9yVGVtcGxhdGU6IFRTRXJyb3JzLkludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMgPSB0aGlzLnRzUGFyc2VNb2RpZmllcnMuYmluZCh0aGlzLCB7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiLCBcImNvbnN0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInJlYWRvbmx5XCIsIFwiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJcbiAgICB9KTtcbiAgfVxuICBnZXRTY29wZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIFR5cGVTY3JpcHRTY29wZUhhbmRsZXI7XG4gIH1cbiAgdHNJc0lkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgdHNUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDApIHx8IHRoaXMubWF0Y2goNSkgfHwgdGhpcy5tYXRjaCg1NSkgfHwgdGhpcy5tYXRjaCgyMSkgfHwgdGhpcy5tYXRjaCgxMzkpIHx8IHRoaXMuaXNMaXRlcmFsUHJvcGVydHlOYW1lKCk7XG4gIH1cbiAgdHNOZXh0VG9rZW5PblNhbWVMaW5lQW5kQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCk7XG4gIH1cbiAgdHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMDYpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c05leHRUb2tlbk9uU2FtZUxpbmVBbmRDYW5Gb2xsb3dNb2RpZmllcigpO1xuICB9XG4gIHRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jaykge1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDU4ICYmIHRoaXMuc3RhdGUudHlwZSAhPT0gNzUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoYWxsb3dlZE1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpIHtcbiAgICAgIGlmIChzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jayAmJiB0aGlzLnRzSXNTdGFydE9mU3RhdGljQmxvY2tzKCkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRzVHJ5UGFyc2UodGhpcy50c05leHRUb2tlbkNhbkZvbGxvd01vZGlmaWVyLmJpbmQodGhpcykpKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICB0c1BhcnNlTW9kaWZpZXJzKHtcbiAgICBhbGxvd2VkTW9kaWZpZXJzLFxuICAgIGRpc2FsbG93ZWRNb2RpZmllcnMsXG4gICAgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2ssXG4gICAgZXJyb3JUZW1wbGF0ZSA9IFRTRXJyb3JzLkludmFsaWRNb2RpZmllck9uVHlwZU1lbWJlclxuICB9LCBtb2RpZmllZCkge1xuICAgIGNvbnN0IGVuZm9yY2VPcmRlciA9IChsb2MsIG1vZGlmaWVyLCBiZWZvcmUsIGFmdGVyKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZXIgPT09IGJlZm9yZSAmJiBtb2RpZmllZFthZnRlcl0pIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJzT3JkZXIsIGxvYywge1xuICAgICAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtiZWZvcmUsIGFmdGVyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGluY29tcGF0aWJsZSA9IChsb2MsIG1vZGlmaWVyLCBtb2QxLCBtb2QyKSA9PiB7XG4gICAgICBpZiAobW9kaWZpZWRbbW9kMV0gJiYgbW9kaWZpZXIgPT09IG1vZDIgfHwgbW9kaWZpZWRbbW9kMl0gJiYgbW9kaWZpZXIgPT09IG1vZDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmNvbXBhdGlibGVNb2RpZmllcnMsIGxvYywge1xuICAgICAgICAgIG1vZGlmaWVyczogW21vZDEsIG1vZDJdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdGFydExvY1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBtb2RpZmllciA9IHRoaXMudHNQYXJzZU1vZGlmaWVyKGFsbG93ZWRNb2RpZmllcnMuY29uY2F0KGRpc2FsbG93ZWRNb2RpZmllcnMgIT0gbnVsbCA/IGRpc2FsbG93ZWRNb2RpZmllcnMgOiBbXSksIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrKTtcbiAgICAgIGlmICghbW9kaWZpZXIpIGJyZWFrO1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwic3RhdGljXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkgPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkW21vZGlmaWVyXSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkW21vZGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwiaW5cIiwgXCJvdXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChtb2RpZmllZCwgbW9kaWZpZXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJkZWNsYXJlXCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJhYnN0cmFjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FsbG93ZWRNb2RpZmllcnMgIT0gbnVsbCAmJiBkaXNhbGxvd2VkTW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGVycm9yVGVtcGxhdGUsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgbW9kaWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRzSXNMaXN0VGVybWluYXRvcihraW5kKSB7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIFwiRW51bU1lbWJlcnNcIjpcbiAgICAgIGNhc2UgXCJUeXBlTWVtYmVyc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg4KTtcbiAgICAgIGNhc2UgXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNSk7XG4gICAgICBjYXNlIFwiVHVwbGVFbGVtZW50VHlwZXNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMyk7XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg0OCk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlRWxlbWVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICByZXR1cm4gbm9uTnVsbCh0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcykpO1xuICB9XG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgZXhwZWN0U3VjY2VzcywgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFpbGluZ0NvbW1hUG9zID0gLTE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlRWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWFQb3MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0U3VjY2Vzcykge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgICAgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSA9IHRyYWlsaW5nQ29tbWFQb3M7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUJyYWNrZXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50LCBicmFja2V0LCBza2lwRmlyc3RUb2tlbiwgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGlmICghc2tpcEZpcnN0VG9rZW4pIHtcbiAgICAgIGlmIChicmFja2V0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODMpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIG5vZGUuYXJndW1lbnQgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmVhdCgxMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBub2RlLnF1YWxpZmllciA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbXBvcnRUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VFbnRpdHlOYW1lKGFsbG93UmVzZXJ2ZWRXb3JkcyA9IHRydWUpIHtcbiAgICBsZXQgZW50aXR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoYWxsb3dSZXNlcnZlZFdvcmRzKTtcbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoZW50aXR5KTtcbiAgICAgIG5vZGUubGVmdCA9IGVudGl0eTtcbiAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihhbGxvd1Jlc2VydmVkV29yZHMpO1xuICAgICAgZW50aXR5ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNRdWFsaWZpZWROYW1lXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZW50aXR5O1xuICB9XG4gIHRzUGFyc2VUeXBlUmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZU5hbWUgPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKCk7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZShsaHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobGhzKTtcbiAgICBub2RlLnBhcmFtZXRlck5hbWUgPSBsaHM7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICBub2RlLmFzc2VydHMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVGhpc1R5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVRdWVyeSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg4Nyk7XG4gICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVRdWVyeVwiKTtcbiAgfVxuICB0c1BhcnNlVHlwZVBhcmFtZXRlcihwYXJzZU1vZGlmaWVycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHBhcnNlTW9kaWZpZXJzKG5vZGUpO1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgbm9kZS5jb25zdHJhaW50ID0gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUoODEpO1xuICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMudHNFYXRUaGVuUGFyc2VUeXBlKDI5KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICB9XG4gIHRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyhwYXJzZU1vZGlmaWVycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJzKHBhcnNlTW9kaWZpZXJzKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVQYXJhbWV0ZXJzKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTQzKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZWZUcmFpbGluZ0NvbW1hUG9zID0ge1xuICAgICAgdmFsdWU6IC0xXG4gICAgfTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMudHNQYXJzZUJyYWNrZXRlZExpc3QoXCJUeXBlUGFyYW1ldGVyc09yQXJndW1lbnRzXCIsIHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXIuYmluZCh0aGlzLCBwYXJzZU1vZGlmaWVycyksIGZhbHNlLCB0cnVlLCByZWZUcmFpbGluZ0NvbW1hUG9zKTtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkVtcHR5VHlwZVBhcmFtZXRlcnMsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHJlZlRyYWlsaW5nQ29tbWFQb3MudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNGaWxsU2lnbmF0dXJlKHJldHVyblRva2VuLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCByZXR1cm5Ub2tlblJlcXVpcmVkID0gcmV0dXJuVG9rZW4gPT09IDE5O1xuICAgIGNvbnN0IHBhcmFtc0tleSA9IFwicGFyYW1ldGVyc1wiO1xuICAgIGNvbnN0IHJldHVyblR5cGVLZXkgPSBcInR5cGVBbm5vdGF0aW9uXCI7XG4gICAgc2lnbmF0dXJlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIHNpZ25hdHVyZVtwYXJhbXNLZXldID0gdGhpcy50c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKTtcbiAgICBpZiAocmV0dXJuVG9rZW5SZXF1aXJlZCkge1xuICAgICAgc2lnbmF0dXJlW3JldHVyblR5cGVLZXldID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaChyZXR1cm5Ub2tlbikpIHtcbiAgICAgIHNpZ25hdHVyZVtyZXR1cm5UeXBlS2V5XSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZUJpbmRpbmdMaXN0Rm9yU2lnbmF0dXJlKCkge1xuICAgIGNvbnN0IGxpc3QgPSBzdXBlci5wYXJzZUJpbmRpbmdMaXN0KDExLCA0MSwgMik7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIGxpc3QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHBhdHRlcm47XG4gICAgICBpZiAodHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiIHx8IHR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5zdXBwb3J0ZWRTaWduYXR1cmVQYXJhbWV0ZXJLaW5kLCBwYXR0ZXJuLCB7XG4gICAgICAgICAgdHlwZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgdHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCgxMikgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdCgxMyk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VTaWduYXR1cmVNZW1iZXIoa2luZCwgbm9kZSkge1xuICAgIHRoaXMudHNGaWxsU2lnbmF0dXJlKDE0LCBub2RlKTtcbiAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBraW5kKTtcbiAgfVxuICB0c0lzVW5hbWJpZ3VvdXNseUluZGV4U2lnbmF0dXJlKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShub2RlKSB7XG4gICAgaWYgKCEodGhpcy5tYXRjaCgwKSAmJiB0aGlzLnRzTG9va0FoZWFkKHRoaXMudHNJc1VuYW1iaWd1b3VzbHlJbmRleFNpZ25hdHVyZS5iaW5kKHRoaXMpKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oaWQpO1xuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIG5vZGUucGFyYW1ldGVycyA9IFtpZF07XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbmRleFNpZ25hdHVyZVwiKTtcbiAgfVxuICB0c1BhcnNlUHJvcGVydHlPck1ldGhvZFNpZ25hdHVyZShub2RlLCByZWFkb25seSkge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGVBbnkgPSBub2RlO1xuICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgaWYgKHJlYWRvbmx5KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVhZG9ubHlGb3JNZXRob2RTaWduYXR1cmUsIG5vZGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgbWV0aG9kID0gbm9kZUFueTtcbiAgICAgIGlmIChtZXRob2Qua2luZCAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90SGF2ZVR5cGVQYXJhbWV0ZXJzLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy50c0ZpbGxTaWduYXR1cmUoMTQsIG1ldGhvZCk7XG4gICAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgICBjb25zdCBwYXJhbXNLZXkgPSBcInBhcmFtZXRlcnNcIjtcbiAgICAgIGNvbnN0IHJldHVyblR5cGVLZXkgPSBcInR5cGVBbm5vdGF0aW9uXCI7XG4gICAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgaWYgKG1ldGhvZFtwYXJhbXNLZXldLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRHZXR0ZXJBcml0eSwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShtZXRob2RbcGFyYW1zS2V5XVswXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3REZWNsYXJlVGhpc1BhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmtpbmQgPT09IFwic2V0XCIpIHtcbiAgICAgICAgaWYgKG1ldGhvZFtwYXJhbXNLZXldLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlckFyaXR5LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZpcnN0UGFyYW1ldGVyID0gbWV0aG9kW3BhcmFtc0tleV1bMF07XG4gICAgICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0oZmlyc3RQYXJhbWV0ZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmaXJzdFBhcmFtZXRlci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBmaXJzdFBhcmFtZXRlci5vcHRpb25hbCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TZXRBY2Nlc3NvckNhbm5vdEhhdmVPcHRpb25hbFBhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpcnN0UGFyYW1ldGVyLnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kW3JldHVyblR5cGVLZXldKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXR1cm5UeXBlLCBtZXRob2RbcmV0dXJuVHlwZUtleV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG1ldGhvZCwgXCJUU01ldGhvZFNpZ25hdHVyZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBub2RlQW55O1xuICAgICAgaWYgKHJlYWRvbmx5KSBwcm9wZXJ0eS5yZWFkb25seSA9IHRydWU7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIGlmICh0eXBlKSBwcm9wZXJ0eS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnRzUGFyc2VUeXBlTWVtYmVyU2VtaWNvbG9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHByb3BlcnR5LCBcIlRTUHJvcGVydHlTaWduYXR1cmVcIik7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VUeXBlTWVtYmVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDEwKSB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NykpIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VTaWduYXR1cmVNZW1iZXIoXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIoaWQsIFwibmV3XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlUHJvcGVydHlPck1ldGhvZFNpZ25hdHVyZShub2RlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBbXCJyZWFkb25seVwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJvdmVycmlkZVwiXVxuICAgIH0sIG5vZGUpO1xuICAgIGNvbnN0IGlkeCA9IHRoaXMudHNUcnlQYXJzZUluZGV4U2lnbmF0dXJlKG5vZGUpO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlUHJvcGVydHlOYW1lKG5vZGUpO1xuICAgIGlmICghbm9kZS5jb21wdXRlZCAmJiBub2RlLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAobm9kZS5rZXkubmFtZSA9PT0gXCJnZXRcIiB8fCBub2RlLmtleS5uYW1lID09PSBcInNldFwiKSAmJiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpKSB7XG4gICAgICBub2RlLmtpbmQgPSBub2RlLmtleS5uYW1lO1xuICAgICAgc3VwZXIucGFyc2VQcm9wZXJ0eU5hbWUobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsICEhbm9kZS5yZWFkb25seSk7XG4gIH1cbiAgdHNQYXJzZVR5cGVMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUxpdGVyYWxcIik7XG4gIH1cbiAgdHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCkge1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLnRzUGFyc2VMaXN0KFwiVHlwZU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlVHlwZU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuICB0c0lzU3RhcnRPZk1hcHBlZFR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KDUzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyMik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjIpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdGhpcy50c0lzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDU4KTtcbiAgfVxuICB0c1BhcnNlTWFwcGVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTIyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMjIpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAge1xuICAgICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0eXBlUGFyYW1ldGVyLm5hbWUgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpO1xuICAgICAgdHlwZVBhcmFtZXRlci5jb25zdHJhaW50ID0gdGhpcy50c0V4cGVjdFRoZW5QYXJzZVR5cGUoNTgpO1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIH1cbiAgICBub2RlLm5hbWVUeXBlID0gdGhpcy5lYXRDb250ZXh0dWFsKDkzKSA/IHRoaXMudHNQYXJzZVR5cGUoKSA6IG51bGw7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgaWYgKHRoaXMubWF0Y2goNTMpKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNUcnlQYXJzZVR5cGUoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01hcHBlZFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLmVsZW1lbnRUeXBlcyA9IHRoaXMudHNQYXJzZUJyYWNrZXRlZExpc3QoXCJUdXBsZUVsZW1lbnRUeXBlc1wiLCB0aGlzLnRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlLmJpbmQodGhpcyksIHRydWUsIGZhbHNlKTtcbiAgICBsZXQgc2Vlbk9wdGlvbmFsRWxlbWVudCA9IGZhbHNlO1xuICAgIG5vZGUuZWxlbWVudFR5cGVzLmZvckVhY2goZWxlbWVudE5vZGUgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gZWxlbWVudE5vZGU7XG4gICAgICBpZiAoc2Vlbk9wdGlvbmFsRWxlbWVudCAmJiB0eXBlICE9PSBcIlRTUmVzdFR5cGVcIiAmJiB0eXBlICE9PSBcIlRTT3B0aW9uYWxUeXBlXCIgJiYgISh0eXBlID09PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiICYmIGVsZW1lbnROb2RlLm9wdGlvbmFsKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk9wdGlvbmFsVHlwZUJlZm9yZVJlcXVpcmVkLCBlbGVtZW50Tm9kZSk7XG4gICAgICB9XG4gICAgICBzZWVuT3B0aW9uYWxFbGVtZW50IHx8IChzZWVuT3B0aW9uYWxFbGVtZW50ID0gdHlwZSA9PT0gXCJUU05hbWVkVHVwbGVNZW1iZXJcIiAmJiBlbGVtZW50Tm9kZS5vcHRpb25hbCB8fCB0eXBlID09PSBcIlRTT3B0aW9uYWxUeXBlXCIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R1cGxlVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlVHVwbGVFbGVtZW50VHlwZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IHJlc3QgPSB0aGlzLmVhdCgyMSk7XG4gICAgbGV0IGxhYmVsZWQ7XG4gICAgbGV0IGxhYmVsO1xuICAgIGxldCBvcHRpb25hbDtcbiAgICBsZXQgdHlwZTtcbiAgICBjb25zdCBpc1dvcmQgPSB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGNoQWZ0ZXJXb3JkID0gaXNXb3JkID8gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpIDogbnVsbDtcbiAgICBpZiAoY2hBZnRlcldvcmQgPT09IDU4KSB7XG4gICAgICBsYWJlbGVkID0gdHJ1ZTtcbiAgICAgIG9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBsYWJlbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9IGVsc2UgaWYgKGNoQWZ0ZXJXb3JkID09PSA2Mykge1xuICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgd29yZE5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgY29uc3QgdHlwZU9yTGFiZWwgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcbiAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDU4KSB7XG4gICAgICAgIGxhYmVsZWQgPSB0cnVlO1xuICAgICAgICBsYWJlbCA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKSwgd29yZE5hbWUpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgICAgdHlwZSA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsZWQgPSBmYWxzZTtcbiAgICAgICAgdHlwZSA9IHR5cGVPckxhYmVsO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICBvcHRpb25hbCA9IHRoaXMuZWF0KDE3KTtcbiAgICAgIGxhYmVsZWQgPSB0aGlzLmVhdCgxNCk7XG4gICAgfVxuICAgIGlmIChsYWJlbGVkKSB7XG4gICAgICBsZXQgbGFiZWxlZE5vZGU7XG4gICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShsYWJlbCk7XG4gICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR1cGxlT3B0aW9uYWxBZnRlclR5cGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkVHVwbGVNZW1iZXJMYWJlbCwgdHlwZSk7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gdHlwZTtcbiAgICAgICAgbGFiZWxlZE5vZGUuZWxlbWVudFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKGxhYmVsZWROb2RlLCBcIlRTTmFtZWRUdXBsZU1lbWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgICBjb25zdCBvcHRpb25hbFR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgICBvcHRpb25hbFR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUob3B0aW9uYWxUeXBlTm9kZSwgXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICByZXN0Tm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKHJlc3ROb2RlLCBcIlRTUmVzdFR5cGVcIik7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHRzUGFyc2VQYXJlbnRoZXNpemVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUodHlwZSwgYWJzdHJhY3QpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodHlwZSA9PT0gXCJUU0NvbnN0cnVjdG9yVHlwZVwiKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gISFhYnN0cmFjdDtcbiAgICAgIGlmIChhYnN0cmFjdCkgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxOSwgbm9kZSkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgdHNQYXJzZUxpdGVyYWxUeXBlTm9kZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzU6XG4gICAgICBjYXNlIDEzNjpcbiAgICAgIGNhc2UgMTM0OlxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIG5vZGUubGl0ZXJhbCA9IHN1cGVyLnBhcnNlRXhwckF0b20oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVRlbXBsYXRlTGl0ZXJhbFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5saXRlcmFsID0gc3VwZXIucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gIH1cbiAgcGFyc2VUZW1wbGF0ZVN1YnN0aXR1dGlvbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUpIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKTtcbiAgfVxuICB0c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCkge1xuICAgIGNvbnN0IHRoaXNLZXl3b3JkID0gdGhpcy50c1BhcnNlVGhpc1R5cGVOb2RlKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNikgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZSh0aGlzS2V5d29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzS2V5d29yZDtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZU5vbkFycmF5VHlwZSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzQ6XG4gICAgICBjYXNlIDEzNTpcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgICAgaWYgKG5leHRUb2tlbi50eXBlICE9PSAxMzUgJiYgbmV4dFRva2VuLnR5cGUgIT09IDEzNikge1xuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUubGl0ZXJhbCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTGl0ZXJhbFR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDc4OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVPclRoaXNUeXBlUHJlZGljYXRlKCk7XG4gICAgICBjYXNlIDg3OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVF1ZXJ5KCk7XG4gICAgICBjYXNlIDgzOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNTdGFydE9mTWFwcGVkVHlwZS5iaW5kKHRoaXMpKSA/IHRoaXMudHNQYXJzZU1hcHBlZFR5cGUoKSA6IHRoaXMudHNQYXJzZVR5cGVMaXRlcmFsKCk7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VQYXJlbnRoZXNpemVkVHlwZSgpO1xuICAgICAgY2FzZSAyNTpcbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdHlwZVxuICAgICAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSB8fCB0eXBlID09PSA4OCB8fCB0eXBlID09PSA4NCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVR5cGUgPSB0eXBlID09PSA4OCA/IFwiVFNWb2lkS2V5d29yZFwiIDogdHlwZSA9PT0gODQgPyBcIlRTTnVsbEtleXdvcmRcIiA6IGtleXdvcmRUeXBlRnJvbU5hbWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAobm9kZVR5cGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQ2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBub2RlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0c1BhcnNlQXJyYXlUeXBlT3JIaWdoZXIoKSB7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcbiAgICB3aGlsZSAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5lYXQoMCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0Tm9kZSh0eXBlKTtcbiAgICAgICAgbm9kZS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNBcnJheVR5cGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUodHlwZSk7XG4gICAgICAgIG5vZGUub2JqZWN0VHlwZSA9IHR5cGU7XG4gICAgICAgIG5vZGUuaW5kZXhUeXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHRzUGFyc2VUeXBlT3BlcmF0b3IoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIoKTtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwicmVhZG9ubHlcIikge1xuICAgICAgdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZU9wZXJhdG9yXCIpO1xuICB9XG4gIHRzQ2hlY2tUeXBlQW5ub3RhdGlvbkZvclJlYWRPbmx5KG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZUFubm90YXRpb24udHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkUmVhZG9ubHksIG5vZGUpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlSW5mZXJUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTUpO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHR5cGVQYXJhbWV0ZXIubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgdHlwZVBhcmFtZXRlci5jb25zdHJhaW50ID0gdGhpcy50c1RyeVBhcnNlKCgpID0+IHRoaXMudHNQYXJzZUNvbnN0cmFpbnRGb3JJbmZlclR5cGUoKSk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZmVyVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlQ29uc3RyYWludEZvckluZmVyVHlwZSgpIHtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0IHx8ICF0aGlzLm1hdGNoKDE3KSkge1xuICAgICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCkge1xuICAgIGNvbnN0IGlzVHlwZU9wZXJhdG9yID0gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgcmV0dXJuIGlzVHlwZU9wZXJhdG9yID8gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yKCkgOiB0aGlzLmlzQ29udGV4dHVhbCgxMTUpID8gdGhpcy50c1BhcnNlSW5mZXJUeXBlKCkgOiB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkpO1xuICB9XG4gIHRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShraW5kLCBwYXJzZUNvbnN0aXR1ZW50VHlwZSwgb3BlcmF0b3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBoYXNMZWFkaW5nT3BlcmF0b3IgPSB0aGlzLmVhdChvcGVyYXRvcik7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICBkbyB7XG4gICAgICB0eXBlcy5wdXNoKHBhcnNlQ29uc3RpdHVlbnRUeXBlKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KG9wZXJhdG9yKSk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAhaGFzTGVhZGluZ09wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gdHlwZXNbMF07XG4gICAgfVxuICAgIG5vZGUudHlwZXMgPSB0eXBlcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHRzUGFyc2VJbnRlcnNlY3Rpb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyLmJpbmQodGhpcyksIDQ1KTtcbiAgfVxuICB0c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNVbmlvblR5cGVcIiwgdGhpcy50c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyLmJpbmQodGhpcyksIDQzKTtcbiAgfVxuICB0c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCkgJiYgdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5U3RhcnRPZkZ1bmN0aW9uVHlwZS5iaW5kKHRoaXMpKTtcbiAgfVxuICB0c1NraXBQYXJhbWV0ZXJTdGFydCgpIHtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyb3JzXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBhcnNlT2JqZWN0TGlrZSg4LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IHByZXZpb3VzRXJyb3JDb3VudDtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgwKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBwcmV2aW91c0Vycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwZXIucGFyc2VCaW5kaW5nTGlzdCgzLCA5MywgMSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSBwcmV2aW91c0Vycm9yQ291bnQ7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTEpIHx8IHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHNTa2lwUGFyYW1ldGVyU3RhcnQoKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTQpIHx8IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTcpIHx8IHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxOSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLmV4cGVjdChyZXR1cm5Ub2tlbik7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGFzc2VydHMgPSAhIXRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlQXNzZXJ0cy5iaW5kKHRoaXMpKTtcbiAgICAgIGlmIChhc3NlcnRzICYmIHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICAgIGxldCB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuICAgICAgICBpZiAodGhpc1R5cGVQcmVkaWNhdGUudHlwZSA9PT0gXCJUU1RoaXNUeXBlXCIpIHtcbiAgICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgICBub2RlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUodGhpc1R5cGVQcmVkaWNhdGUsIG5vZGUpO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlUHJlZGljYXRlVmFyaWFibGUgPSB0aGlzLnRzSXNJZGVudGlmaWVyKCkgJiYgdGhpcy50c1RyeVBhcnNlKHRoaXMudHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXguYmluZCh0aGlzKSk7XG4gICAgICBpZiAoIXR5cGVQcmVkaWNhdGVWYXJpYWJsZSkge1xuICAgICAgICBpZiAoIWFzc2VydHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oZmFsc2UsIHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0eXBlUHJlZGljYXRlVmFyaWFibGU7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgfSk7XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHRzVHJ5UGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgxNCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXgoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTYpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgIT09IDEwOSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKCF0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IFwiYXNzZXJ0c1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbm5vdGF0aW9uKGVhdENvbG9uID0gdHJ1ZSwgdCA9IHRoaXMuc3RhcnROb2RlKCkpIHtcbiAgICB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIGlmIChlYXRDb2xvbikgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlVHlwZSgpIHtcbiAgICBhc3NlcnQodGhpcy5zdGF0ZS5pblR5cGUpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB8fCAhdGhpcy5lYXQoODEpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgIG5vZGUuY2hlY2tUeXBlID0gdHlwZTtcbiAgICBub2RlLmV4dGVuZHNUeXBlID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIG5vZGUudHJ1ZVR5cGUgPSB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIG5vZGUuZmFsc2VUeXBlID0gdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0NvbmRpdGlvbmFsVHlwZVwiKTtcbiAgfVxuICBpc0Fic3RyYWN0Q29uc3RydWN0b3JTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyNCkgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlID09PSA3NztcbiAgfVxuICB0c1BhcnNlTm9uQ29uZGl0aW9uYWxUeXBlKCkge1xuICAgIGlmICh0aGlzLnRzSXNTdGFydE9mRnVuY3Rpb25UeXBlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNGdW5jdGlvblR5cGVcIik7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUZ1bmN0aW9uT3JDb25zdHJ1Y3RvclR5cGUoXCJUU0NvbnN0cnVjdG9yVHlwZVwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNBYnN0cmFjdENvbnN0cnVjdG9yU2lnbmF0dXJlKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VVbmlvblR5cGVPckhpZ2hlcigpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXNzZXJ0aW9uKCkge1xuICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkaXNhbGxvd0FtYmlndW91c0pTWExpa2VcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVzZXJ2ZWRUeXBlQXNzZXJ0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRjaCg3NSkgPyB0aGlzLnRzUGFyc2VUeXBlUmVmZXJlbmNlKCkgOiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFzc2VydGlvblwiKTtcbiAgfVxuICB0c1BhcnNlSGVyaXRhZ2VDbGF1c2UodG9rZW4pIHtcbiAgICBjb25zdCBvcmlnaW5hbFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBkZWxpbWl0ZWRMaXN0ID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIkhlcml0YWdlQ2xhdXNlRWxlbWVudFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpO1xuICAgIH0pO1xuICAgIGlmICghZGVsaW1pdGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGUsIG9yaWdpbmFsU3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVkTGlzdDtcbiAgfVxuICB0c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBudWxsO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjkpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgMTMwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk1pc3NpbmdJbnRlcmZhY2VOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMpO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIG5vZGUuZXh0ZW5kcyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgYm9keS5ib2R5ID0gdGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoYm9keSwgXCJUU0ludGVyZmFjZUJvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAyKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMpO1xuICAgICAgdGhpcy5leHBlY3QoMjkpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNCkgJiYgdGhpcy5sb29rYWhlYWQoKS50eXBlICE9PSAxNikge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ludHJpbnNpY0tleXdvcmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJbk5vQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gW29sZENvbnRleHRbMF1dO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICB9XG4gIH1cbiAgdHNJblR5cGUoY2IpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICB9XG4gIH1cbiAgdHNJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoY2IpIHtcbiAgICBjb25zdCBvbGRJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB9XG4gIH1cbiAgdHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoY2IpIHtcbiAgICBjb25zdCBvbGRJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2IoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgPSBvbGRJbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQ7XG4gICAgfVxuICB9XG4gIHRzRWF0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIGlmICh0aGlzLm1hdGNoKHRva2VuKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNOZXh0VGhlblBhcnNlVHlwZSgpO1xuICAgIH1cbiAgfVxuICB0c0V4cGVjdFRoZW5QYXJzZVR5cGUodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICB0aGlzLmV4cGVjdCh0b2tlbik7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICB9XG4gIHRzTmV4dFRoZW5QYXJzZVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICB9XG4gIHRzUGFyc2VFbnVtTWVtYmVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuaWQgPSB0aGlzLm1hdGNoKDEzNCkgPyBzdXBlci5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAodGhpcy5lYXQoMjkpKSB7XG4gICAgICBub2RlLmluaXRpYWxpemVyID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRW51bU1lbWJlclwiKTtcbiAgfVxuICB0c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHByb3BlcnRpZXMgPSB7fSkge1xuICAgIGlmIChwcm9wZXJ0aWVzLmNvbnN0KSBub2RlLmNvbnN0ID0gdHJ1ZTtcbiAgICBpZiAocHJvcGVydGllcy5kZWNsYXJlKSBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjYpO1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIG5vZGUuY29uc3QgPyA4OTcxIDogODQ1OSk7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgbm9kZS5tZW1iZXJzID0gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIkVudW1NZW1iZXJzXCIsIHRoaXMudHNQYXJzZUVudW1NZW1iZXIuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRW51bURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVCbG9jaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHN1cGVyLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShub2RlLmJvZHkgPSBbXSwgdW5kZWZpbmVkLCB0cnVlLCA4KTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVCbG9ja1wiKTtcbiAgfVxuICB0c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlLCBuZXN0ZWQgPSBmYWxzZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICghbmVzdGVkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAxMDI0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihpbm5lciwgdHJ1ZSk7XG4gICAgICBub2RlLmJvZHkgPSBpbm5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigyNTYpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExMikpIHtcbiAgICAgIG5vZGUua2luZCA9IFwiZ2xvYmFsXCI7XG4gICAgICBub2RlLmdsb2JhbCA9IHRydWU7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgbm9kZS5raW5kID0gXCJtb2R1bGVcIjtcbiAgICAgIG5vZGUuaWQgPSBzdXBlci5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigyNTYpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnRzUGFyc2VNb2R1bGVCbG9jaygpO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyLCBpc0V4cG9ydCkge1xuICAgIG5vZGUuaXNFeHBvcnQgPSBpc0V4cG9ydCB8fCBmYWxzZTtcbiAgICBub2RlLmlkID0gbWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDQwOTYpO1xuICAgIHRoaXMuZXhwZWN0KDI5KTtcbiAgICBjb25zdCBtb2R1bGVSZWZlcmVuY2UgPSB0aGlzLnRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKTtcbiAgICBpZiAobm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiAmJiBtb2R1bGVSZWZlcmVuY2UudHlwZSAhPT0gXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW1wb3J0QWxpYXNIYXNJbXBvcnRUeXBlLCBtb2R1bGVSZWZlcmVuY2UpO1xuICAgIH1cbiAgICBub2RlLm1vZHVsZVJlZmVyZW5jZSA9IG1vZHVsZVJlZmVyZW5jZTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHRzSXNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTE5KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQwO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgPyB0aGlzLnRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlRW50aXR5TmFtZShmYWxzZSk7XG4gIH1cbiAgdHNQYXJzZUV4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTkpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwckF0b20oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIik7XG4gIH1cbiAgdHNMb29rQWhlYWQoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlcyA9IGYoKTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICB0c1RyeVBhcnNlQW5kQ2F0Y2goZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoYWJvcnQgPT4gZigpIHx8IGFib3J0KCkpO1xuICAgIGlmIChyZXN1bHQuYWJvcnRlZCB8fCAhcmVzdWx0Lm5vZGUpIHJldHVybjtcbiAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gIH1cbiAgdHNUcnlQYXJzZShmKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gZigpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH1cbiAgdHNUcnlQYXJzZURlY2xhcmUobmFueSkge1xuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhcnRUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGxldCBraW5kO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMDApKSB7XG4gICAgICBzdGFydFR5cGUgPSA3NDtcbiAgICAgIGtpbmQgPSBcImxldFwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4ge1xuICAgICAgc3dpdGNoIChzdGFydFR5cGUpIHtcbiAgICAgICAgY2FzZSA2ODpcbiAgICAgICAgICBuYW55LmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5hbnksIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIGNhc2UgODA6XG4gICAgICAgICAgbmFueS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKG5hbnksIHRydWUsIGZhbHNlKTtcbiAgICAgICAgY2FzZSAxMjY6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihuYW55LCB7XG4gICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VBbWJpZW50RXh0ZXJuYWxNb2R1bGVEZWNsYXJhdGlvbihuYW55KTtcbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goNzUpIHx8ICF0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgICAgICAgIG5hbnkuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChuYW55LCBraW5kIHx8IHRoaXMuc3RhdGUudmFsdWUsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmV4cGVjdCg3NSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUVudW1EZWNsYXJhdGlvbihuYW55LCB7XG4gICAgICAgICAgICBjb25zdDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAxMjk6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obmFueSwge1xuICAgICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcihzdGFydFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVjbGFyYXRpb24obmFueSwgdGhpcy5zdGF0ZS52YWx1ZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSwgdGhpcy5zdGF0ZS52YWx1ZSwgdHJ1ZSwgbnVsbCk7XG4gIH1cbiAgdHNQYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIHN3aXRjaCAoZXhwci5uYW1lKSB7XG4gICAgICBjYXNlIFwiZGVjbGFyZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLnRzVHJ5UGFyc2VEZWNsYXJlKG5vZGUpO1xuICAgICAgICAgIGlmIChkZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImdsb2JhbFwiOlxuICAgICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMjU2KTtcbiAgICAgICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgICAgICBjb25zdCBtb2QgPSBub2RlO1xuICAgICAgICAgIG1vZC5raW5kID0gXCJnbG9iYWxcIjtcbiAgICAgICAgICBtb2QuZ2xvYmFsID0gdHJ1ZTtcbiAgICAgICAgICBtb2QuaWQgPSBleHByO1xuICAgICAgICAgIG1vZC5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShtb2QsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCBleHByLm5hbWUsIGZhbHNlLCBkZWNvcmF0b3JzKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIHZhbHVlLCBuZXh0LCBkZWNvcmF0b3JzKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImFic3RyYWN0XCI6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiAodGhpcy5tYXRjaCg4MCkgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtb2R1bGVcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgICAgbm9kZS5raW5kID0gXCJtb2R1bGVcIjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJuYW1lc3BhY2VcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpICYmIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBub2RlLmtpbmQgPSBcIm5hbWVzcGFjZVwiO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2R1bGVPck5hbWVzcGFjZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInR5cGVcIjpcbiAgICAgICAgaWYgKHRoaXMudHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpICYmIHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSB7XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIGlmICh0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gIXRoaXMuaXNMaW5lVGVybWluYXRvcigpO1xuICB9XG4gIHRzVHJ5UGFyc2VHZW5lcmljQXN5bmNBcnJvd0Z1bmN0aW9uKHN0YXJ0TG9jKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDQ3KSkgcmV0dXJuO1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICBjb25zdCByZXMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgICBzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUpO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0pO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgaWYgKCFyZXMpIHJldHVybjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvd0V4cHJlc3Npb24ocmVzLCBudWxsLCB0cnVlKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5yZVNjYW5fbHQoKSAhPT0gNDcpIHJldHVybjtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c0luVHlwZSgoKSA9PiB0aGlzLnRzSW5Ob0NvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJUeXBlUGFyYW1ldGVyc09yQXJndW1lbnRzXCIsIHRoaXMudHNQYXJzZVR5cGUuYmluZCh0aGlzKSk7XG4gICAgfSkpO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlUeXBlQXJndW1lbnRzLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnN0YXRlLmluVHlwZSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKTtcbiAgfVxuICB0c0lzRGVjbGFyYXRpb25TdGFydCgpIHtcbiAgICByZXR1cm4gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBpZiAodGhpcy50c0lzRGVjbGFyYXRpb25TdGFydCgpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIHBhcnNlQXNzaWduYWJsZUxpc3RJdGVtKGZsYWdzLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG1vZGlmaWVkID0ge307XG4gICAgdGhpcy50c1BhcnNlTW9kaWZpZXJzKHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJvdmVycmlkZVwiLCBcInJlYWRvbmx5XCJdXG4gICAgfSwgbW9kaWZpZWQpO1xuICAgIGNvbnN0IGFjY2Vzc2liaWxpdHkgPSBtb2RpZmllZC5hY2Nlc3NpYmlsaXR5O1xuICAgIGNvbnN0IG92ZXJyaWRlID0gbW9kaWZpZWQub3ZlcnJpZGU7XG4gICAgY29uc3QgcmVhZG9ubHkgPSBtb2RpZmllZC5yZWFkb25seTtcbiAgICBpZiAoIShmbGFncyAmIDQpICYmIChhY2Nlc3NpYmlsaXR5IHx8IHJlYWRvbmx5IHx8IG92ZXJyaWRlKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkUGFyYW1ldGVyTW9kaWZpZXIsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoKTtcbiAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUobGVmdCk7XG4gICAgfVxuICAgIGNvbnN0IGVsdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQobGVmdC5sb2Muc3RhcnQsIGxlZnQpO1xuICAgIGlmIChhY2Nlc3NpYmlsaXR5IHx8IHJlYWRvbmx5IHx8IG92ZXJyaWRlKSB7XG4gICAgICBjb25zdCBwcCA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIHBwLmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgICAgfVxuICAgICAgaWYgKGFjY2Vzc2liaWxpdHkpIHBwLmFjY2Vzc2liaWxpdHkgPSBhY2Nlc3NpYmlsaXR5O1xuICAgICAgaWYgKHJlYWRvbmx5KSBwcC5yZWFkb25seSA9IHJlYWRvbmx5O1xuICAgICAgaWYgKG92ZXJyaWRlKSBwcC5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgICAgaWYgKGVsdC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiBlbHQudHlwZSAhPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5zdXBwb3J0ZWRQYXJhbWV0ZXJQcm9wZXJ0eUtpbmQsIHBwKTtcbiAgICAgIH1cbiAgICAgIHBwLnBhcmFtZXRlciA9IGVsdDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHAsIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiKTtcbiAgICB9XG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICBsZWZ0LmRlY29yYXRvcnMgPSBkZWNvcmF0b3JzO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIGlzU2ltcGxlUGFyYW1ldGVyKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiAmJiBzdXBlci5pc1NpbXBsZVBhcmFtZXRlcihub2RlLnBhcmFtZXRlcikgfHwgc3VwZXIuaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSk7XG4gIH1cbiAgdHNEaXNhbGxvd09wdGlvbmFsUGF0dGVybihub2RlKSB7XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBub2RlLnBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLm9wdGlvbmFsICYmICF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5QYXR0ZXJuSXNPcHRpb25hbCwgcGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICBzdXBlci5zZXRBcnJvd0Z1bmN0aW9uUGFyYW1ldGVycyhub2RlLCBwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MpO1xuICAgIHRoaXMudHNEaXNhbGxvd09wdGlvbmFsUGF0dGVybihub2RlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigxNCk7XG4gICAgfVxuICAgIGNvbnN0IGJvZGlsZXNzVHlwZSA9IHR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiID8gXCJUU0RlY2xhcmVGdW5jdGlvblwiIDogdHlwZSA9PT0gXCJDbGFzc01ldGhvZFwiIHx8IHR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIgPyBcIlRTRGVjbGFyZU1ldGhvZFwiIDogdW5kZWZpbmVkO1xuICAgIGlmIChib2RpbGVzc1R5cGUgJiYgIXRoaXMubWF0Y2goNSkgJiYgdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgYm9kaWxlc3NUeXBlKTtcbiAgICB9XG4gICAgaWYgKGJvZGlsZXNzVHlwZSA9PT0gXCJUU0RlY2xhcmVGdW5jdGlvblwiICYmIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlRnVuY3Rpb25IYXNJbXBsZW1lbnRhdGlvbiwgbm9kZSk7XG4gICAgICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCBib2RpbGVzc1R5cGUsIGlzTWV0aG9kKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCk7XG4gIH1cbiAgcmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUuYm9keSAmJiBub2RlLmlkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAxMDI0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIucmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpO1xuICAgIH1cbiAgfVxuICB0c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhpdGVtcykge1xuICAgIGl0ZW1zLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAoKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZSkgPT09IFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbiwgbm9kZS50eXBlQW5ub3RhdGlvbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNJblBhcmVucykge1xuICAgIHRoaXMudHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMoZXhwckxpc3QpO1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuICBwYXJzZUFycmF5TGlrZShjbG9zZSwgY2FuQmVQYXR0ZXJuLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgIHRoaXMudHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMobm9kZS5lbGVtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSkge1xuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDM1KSkge1xuICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9uTnVsbEV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vbk51bGxFeHByZXNzaW9uLmV4cHJlc3Npb24gPSBiYXNlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub25OdWxsRXhwcmVzc2lvbiwgXCJUU05vbk51bGxFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICBsZXQgaXNPcHRpb25hbENhbGwgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5tYXRjaCgxOCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MCkge1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgfVxuICAgICAgc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlciA9IGlzT3B0aW9uYWxDYWxsID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGxldCBtaXNzaW5nUGFyZW5FcnJvckxvYztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgICAgaWYgKCFub0NhbGxzICYmIHRoaXMuYXRQb3NzaWJsZUFzeW5jQXJyb3coYmFzZSkpIHtcbiAgICAgICAgICBjb25zdCBhc3luY0Fycm93Rm4gPSB0aGlzLnRzVHJ5UGFyc2VHZW5lcmljQXN5bmNBcnJvd0Z1bmN0aW9uKHN0YXJ0TG9jKTtcbiAgICAgICAgICBpZiAoYXN5bmNBcnJvd0ZuKSB7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNBcnJvd0ZuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIXR5cGVBcmd1bWVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWxDYWxsICYmICF0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIG1pc3NpbmdQYXJlbkVycm9yTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihiYXNlLCBzdGFydExvYywgc3RhdGUpO1xuICAgICAgICAgIHJlc3VsdC50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoMTApKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygxMSk7XG4gICAgICAgICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhub2RlLmFyZ3VtZW50cyk7XG4gICAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgICAgICAgIG5vZGUub3B0aW9uYWwgPSBpc09wdGlvbmFsQ2FsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICBpZiAodG9rZW5UeXBlID09PSA0OCB8fCB0b2tlblR5cGUgPT09IDUyIHx8IHRva2VuVHlwZSAhPT0gMTAgJiYgdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odG9rZW5UeXBlKSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IGJhc2U7XG4gICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKG1pc3NpbmdQYXJlbkVycm9yTG9jKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChtaXNzaW5nUGFyZW5FcnJvckxvYywgMTApO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiICYmICh0aGlzLm1hdGNoKDE2KSB8fCB0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQwKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZFByb3BlcnR5QWNjZXNzQWZ0ZXJJbnN0YW50aWF0aW9uRXhwcmVzc2lvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIHZhciBfY2FsbGVlJGV4dHJhO1xuICAgIHN1cGVyLnBhcnNlTmV3Q2FsbGVlKG5vZGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbGxlZVxuICAgIH0gPSBub2RlO1xuICAgIGlmIChjYWxsZWUudHlwZSA9PT0gXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIgJiYgISgoX2NhbGxlZSRleHRyYSA9IGNhbGxlZS5leHRyYSkgIT0gbnVsbCAmJiBfY2FsbGVlJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gY2FsbGVlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgbm9kZS5jYWxsZWUgPSBjYWxsZWUuZXhwcmVzc2lvbjtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgbGV0IGlzU2F0aXNmaWVzO1xuICAgIGlmICh0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgPiBtaW5QcmVjICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmICh0aGlzLmlzQ29udGV4dHVhbCg5MykgfHwgKGlzU2F0aXNmaWVzID0gdGhpcy5pc0NvbnRleHR1YWwoMTIwKSkpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChsZWZ0U3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gbGVmdDtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDc1KSkge1xuICAgICAgICAgIGlmIChpc1NhdGlzZmllcykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEtleXdvcmQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgICAgICAga2V5d29yZDogXCJjb25zdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTYXRpc2ZpZXMgPyBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiIDogXCJUU0FzRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChub2RlLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKTtcbiAgfVxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQpIHtcbiAgICAgIHN1cGVyLmNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBjaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSkge1xuICAgIHN1cGVyLmNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKTtcbiAgICBpZiAobm9kZS5tb2R1bGUgJiYgbm9kZS5pbXBvcnRLaW5kICE9PSBcInZhbHVlXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGUsIG5vZGUuc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBjaGVja0R1cGxpY2F0ZUV4cG9ydHMoKSB7fVxuICBpc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSB7XG4gICAgaWYgKHN1cGVyLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICByZXR1cm4gaXNFeHBvcnQgPyBjaCA9PT0gMTIzIHx8IGNoID09PSA0MiA6IGNoICE9PSA2MTtcbiAgICB9XG4gICAgcmV0dXJuICFpc0V4cG9ydCAmJiB0aGlzLmlzQ29udGV4dHVhbCg4Nyk7XG4gIH1cbiAgYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYykge1xuICAgIHN1cGVyLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpO1xuICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiID8gXCJ0eXBlXCIgOiBcInZhbHVlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IHBoYXNlID09PSBcInR5cGVcIiB8fCBwaGFzZSA9PT0gXCJ0eXBlb2ZcIiA/IHBoYXNlIDogXCJ2YWx1ZVwiO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gXCJ2YWx1ZVwiO1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0KG5vZGUpO1xuICAgIH1cbiAgICBsZXQgaW1wb3J0Tm9kZTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYxKSB7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBjb25zdCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gdGhpcy5wYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgZmFsc2UpO1xuICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1wb3J0Tm9kZSA9IHN1cGVyLnBhcnNlSW1wb3J0U3BlY2lmaWVyc0FuZEFmdGVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbXBvcnROb2RlID0gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgfVxuICAgIGlmIChpbXBvcnROb2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiICYmIGltcG9ydE5vZGUuc3BlY2lmaWVycy5sZW5ndGggPiAxICYmIGltcG9ydE5vZGUuc3BlY2lmaWVyc1swXS50eXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlSW1wb3J0Q2Fubm90U3BlY2lmeURlZmF1bHRBbmROYW1lZCwgaW1wb3J0Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnROb2RlO1xuICB9XG4gIHBhcnNlRXhwb3J0KG5vZGUsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3Qgbm9kZUltcG9ydEVxdWFscyA9IG5vZGU7XG4gICAgICBsZXQgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IG51bGw7XG4gICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSAmJiB0aGlzLmlzUG90ZW50aWFsSW1wb3J0UGhhc2UoZmFsc2UpKSB7XG4gICAgICAgIG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlSW1wb3J0RXF1YWxzLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlSW1wb3J0RXF1YWxzLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZUltcG9ydEVxdWFscywgbWF5YmVEZWZhdWx0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IG5vZGU7XG4gICAgICBhc3NpZ24uZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShhc3NpZ24sIFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgY29uc3QgZGVjbCA9IG5vZGU7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI4KTtcbiAgICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGlzQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTI0KSAmJiB0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDgwO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNscy5hYnN0cmFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3VwZXIucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgfHwgaXNBbWJpZW50Q29udGV4dCk7XG4gICAgaWYgKCFpc0FtYmllbnRDb250ZXh0KSByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGluaXRcbiAgICB9IG9mIGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykge1xuICAgICAgaWYgKCFpbml0KSBjb250aW51ZTtcbiAgICAgIGlmIChraW5kICE9PSBcImNvbnN0XCIgfHwgISFpZC50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluaXRpYWxpemVyTm90QWxsb3dlZEluQW1iaWVudENvbnRleHQsIGluaXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZEFtYmllbnRDb25zdEluaXRpYWxpemVyKGluaXQsIHRoaXMuaGFzUGx1Z2luKFwiZXN0cmVlXCIpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg3NSkgJiYgdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJlbnVtXCIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDc1KTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwge1xuICAgICAgICBjb25zdDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjYpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdGF0ZW1lbnRDb250ZW50KGZsYWdzLCBkZWNvcmF0b3JzKTtcbiAgfVxuICBwYXJzZUFjY2Vzc01vZGlmaWVyKCkge1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VNb2RpZmllcihbXCJwdWJsaWNcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwcml2YXRlXCJdKTtcbiAgfVxuICB0c0hhc1NvbWVNb2RpZmllcnMobWVtYmVyLCBtb2RpZmllcnMpIHtcbiAgICByZXR1cm4gbW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4ge1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgcmV0dXJuIG1lbWJlci5hY2Nlc3NpYmlsaXR5ID09PSBtb2RpZmllcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhIW1lbWJlclttb2RpZmllcl07XG4gICAgfSk7XG4gIH1cbiAgdHNJc1N0YXJ0T2ZTdGF0aWNCbG9ja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEwNikgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSAxMjM7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpIHtcbiAgICBjb25zdCBtb2RpZmllcnMgPSBbXCJkZWNsYXJlXCIsIFwicHJpdmF0ZVwiLCBcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwiYWJzdHJhY3RcIiwgXCJyZWFkb25seVwiLCBcInN0YXRpY1wiXTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jazogdHJ1ZSxcbiAgICAgIGVycm9yVGVtcGxhdGU6IFRTRXJyb3JzLkludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uc1xuICAgIH0sIG1lbWJlcik7XG4gICAgY29uc3QgY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMudHNIYXNTb21lTW9kaWZpZXJzKG1lbWJlciwgbW9kaWZpZXJzKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuU3RhdGljQmxvY2tDYW5ub3RIYXZlTW9kaWZpZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsICEhbWVtYmVyLnN0YXRpYyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgIHRoaXMudHNJbkFtYmllbnRDb250ZXh0KGNhbGxQYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobWVtYmVyKTtcbiAgICBpZiAoaWR4KSB7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKGlkeCk7XG4gICAgICBpZiAobWVtYmVyLmFic3RyYWN0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBYnN0cmFjdCwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChtZW1iZXIuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eSwgbWVtYmVyLCB7XG4gICAgICAgICAgbW9kaWZpZXI6IG1lbWJlci5hY2Nlc3NpYmlsaXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5kZWNsYXJlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNEZWNsYXJlLCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluZGV4U2lnbmF0dXJlSGFzT3ZlcnJpZGUsIG1lbWJlcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5zdGF0ZS5pbkFic3RyYWN0Q2xhc3MgJiYgbWVtYmVyLmFic3RyYWN0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk5vbkFic3RyYWN0Q2xhc3NIYXNBYnN0cmFjdE1ldGhvZCwgbWVtYmVyKTtcbiAgICB9XG4gICAgaWYgKG1lbWJlci5vdmVycmlkZSkge1xuICAgICAgaWYgKCFzdGF0ZS5oYWRTdXBlckNsYXNzKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuT3ZlcnJpZGVOb3RJblN1YkNsYXNzLCBtZW1iZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpO1xuICB9XG4gIHBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMobWV0aG9kT3JQcm9wKSB7XG4gICAgY29uc3Qgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgaWYgKG9wdGlvbmFsKSBtZXRob2RPclByb3Aub3B0aW9uYWwgPSB0cnVlO1xuICAgIGlmIChtZXRob2RPclByb3AucmVhZG9ubHkgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNSZWFkb25seSwgbWV0aG9kT3JQcm9wKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZE9yUHJvcC5kZWNsYXJlICYmIHRoaXMubWF0Y2goMTApKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNsYXNzTWV0aG9kSGFzRGVjbGFyZSwgbWV0aG9kT3JQcm9wKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBkZWNsID0gZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IHRoaXMudHNQYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRlY2wgfHwgc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMudHNJc0RlY2xhcmF0aW9uU3RhcnQoKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHN1cGVyLnNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKTtcbiAgfVxuICBwYXJzZUNvbmRpdGlvbmFsKGV4cHIsIHN0YXJ0TG9jLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKCF0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgfHwgIXRoaXMubWF0Y2goMTcpKSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYykpO1xuICAgIGlmICghcmVzdWx0Lm5vZGUpIHtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgc3VwZXIuc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycywgcmVzdWx0LmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gIH1cbiAgcGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gc3VwZXIucGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVDYXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdHlwZUNhc3ROb2RlLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjUpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzRGVjbGFyZSA9IHRoaXMuZWF0Q29udGV4dHVhbCgxMjUpO1xuICAgIGlmIChpc0RlY2xhcmUgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNSkgfHwgIXRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShUU0Vycm9ycy5FeHBlY3RlZEFtYmllbnRBZnRlckV4cG9ydERlY2xhcmUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBpc0lkZW50aWZpZXIgPSB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gaXNJZGVudGlmaWVyICYmIHRoaXMudHNUcnlQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkgfHwgc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIgfHwgaXNEZWNsYXJlKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG4gICAgaWYgKGlzRGVjbGFyZSkge1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb24oZGVjbGFyYXRpb24sIHN0YXJ0TG9jKTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICgoIWlzU3RhdGVtZW50IHx8IG9wdGlvbmFsSWQpICYmIHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBub2RlLmRlY2xhcmUgPyAxMDI0IDogODMzMSk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUub3B0aW9uYWwpIHtcbiAgICAgIGlmICh0aGlzLmVhdCgzNSkpIHtcbiAgICAgICAgbm9kZS5kZWZpbml0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgIShub2RlLnJlYWRvbmx5ICYmICFub2RlLnR5cGVBbm5vdGF0aW9uKSAmJiB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWJzdHJhY3QgJiYgdGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWJzdHJhY3RQcm9wZXJ0eUhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIHByb3BlcnR5TmFtZToga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFub2RlLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0LCBub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHksIG5vZGUsIHtcbiAgICAgICAgbW9kaWZpZXI6IG5vZGUuYWNjZXNzaWJpbGl0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90QmVPcHRpb25hbCwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzICYmIGlzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ29uc3RydWN0b3JIYXNUeXBlUGFyYW1ldGVycywgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNsYXJlID0gZmFsc2UsXG4gICAgICBraW5kXG4gICAgfSA9IG1ldGhvZDtcbiAgICBpZiAoZGVjbGFyZSAmJiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQWNjZXNzb3IsIG1ldGhvZCwge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9XG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgIWhhc093blByb3BlcnR5LmNhbGwobm9kZS52YWx1ZSwgXCJib2R5XCIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHBhcnNlQ2xhc3NTdXBlcihub2RlKSB7XG4gICAgc3VwZXIucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAgbm9kZS5zdXBlclR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIG5vZGUuaW1wbGVtZW50cyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiaW1wbGVtZW50c1wiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgcHJvcC50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHJldHVybiBzdXBlci5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpO1xuICB9XG4gIHBhcnNlVmFySWQoZGVjbCwga2luZCkge1xuICAgIHN1cGVyLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKGRlY2wuaWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5lYXQoMzUpKSB7XG4gICAgICBkZWNsLmRlZmluaXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGRlY2wuaWQudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGRlY2wuaWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgdmFyIF9qc3gsIF9qc3gyLCBfdHlwZUNhc3QsIF9qc3gzLCBfdHlwZUNhc3QyO1xuICAgIGxldCBzdGF0ZTtcbiAgICBsZXQganN4O1xuICAgIGxldCB0eXBlQ2FzdDtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJqc3hcIikgJiYgKHRoaXMubWF0Y2goMTQzKSB8fCB0aGlzLm1hdGNoKDQ3KSkpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAganN4ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSwgc3RhdGUpO1xuICAgICAgaWYgKCFqc3guZXJyb3IpIHJldHVybiBqc3gubm9kZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29udGV4dFxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChjdXJyZW50Q29udGV4dCA9PT0gdHlwZXMual9vVGFnIHx8IGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCEoKF9qc3ggPSBqc3gpICE9IG51bGwgJiYgX2pzeC5lcnJvcikgJiYgIXRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgfVxuICAgIGlmICghc3RhdGUgfHwgc3RhdGUgPT09IHRoaXMuc3RhdGUpIHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICBjb25zdCBhcnJvdyA9IHRoaXMudHJ5UGFyc2UoYWJvcnQgPT4ge1xuICAgICAgdmFyIF9leHByJGV4dHJhLCBfdHlwZVBhcmFtZXRlcnM7XG4gICAgICB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgICAgY29uc3QgZXhwciA9IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpO1xuICAgICAgaWYgKGV4cHIudHlwZSAhPT0gXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiIHx8IChfZXhwciRleHRyYSA9IGV4cHIuZXh0cmEpICE9IG51bGwgJiYgX2V4cHIkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgICBhYm9ydCgpO1xuICAgICAgfVxuICAgICAgaWYgKCgoX3R5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnMpID09IG51bGwgPyB2b2lkIDAgOiBfdHlwZVBhcmFtZXRlcnMucGFyYW1zLmxlbmd0aCkgIT09IDApIHtcbiAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHByLCB0eXBlUGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgICBleHByLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9LCBzdGF0ZSk7XG4gICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkge1xuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB0aGlzLnJlcG9ydFJlc2VydmVkQXJyb3dUeXBlUGFyYW0odHlwZVBhcmFtZXRlcnMpO1xuICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgfVxuICAgIGlmICghanN4KSB7XG4gICAgICBhc3NlcnQoIXRoaXMuaGFzUGx1Z2luKFwianN4XCIpKTtcbiAgICAgIHR5cGVDYXN0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSwgc3RhdGUpO1xuICAgICAgaWYgKCF0eXBlQ2FzdC5lcnJvcikgcmV0dXJuIHR5cGVDYXN0Lm5vZGU7XG4gICAgfVxuICAgIGlmICgoX2pzeDIgPSBqc3gpICE9IG51bGwgJiYgX2pzeDIubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IGpzeC5mYWlsU3RhdGU7XG4gICAgICByZXR1cm4ganN4Lm5vZGU7XG4gICAgfVxuICAgIGlmIChhcnJvdy5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB0aGlzLnJlcG9ydFJlc2VydmVkQXJyb3dUeXBlUGFyYW0odHlwZVBhcmFtZXRlcnMpO1xuICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgfVxuICAgIGlmICgoX3R5cGVDYXN0ID0gdHlwZUNhc3QpICE9IG51bGwgJiYgX3R5cGVDYXN0Lm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB0eXBlQ2FzdC5mYWlsU3RhdGU7XG4gICAgICByZXR1cm4gdHlwZUNhc3Qubm9kZTtcbiAgICB9XG4gICAgdGhyb3cgKChfanN4MyA9IGpzeCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9qc3gzLmVycm9yKSB8fCBhcnJvdy5lcnJvciB8fCAoKF90eXBlQ2FzdDIgPSB0eXBlQ2FzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90eXBlQ2FzdDIuZXJyb3IpO1xuICB9XG4gIHJlcG9ydFJlc2VydmVkQXJyb3dUeXBlUGFyYW0obm9kZSkge1xuICAgIHZhciBfbm9kZSRleHRyYTtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICFub2RlLnBhcmFtc1swXS5jb25zdHJhaW50ICYmICEoKF9ub2RlJGV4dHJhID0gbm9kZS5leHRyYSkgIT0gbnVsbCAmJiBfbm9kZSRleHRyYS50cmFpbGluZ0NvbW1hKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcInR5cGVzY3JpcHRcIiwgXCJkaXNhbGxvd0FtYmlndW91c0pTWExpa2VcIikpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuUmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSwgbm9kZSk7XG4gICAgfVxuICB9XG4gIHBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSkge1xuICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJqc3hcIikgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXNzZXJ0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycywgc2F3VW5hcnkpO1xuICB9XG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICAgIGNvbnN0IHJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigxNCk7XG4gICAgICAgIGlmICh0aGlzLmNhbkluc2VydFNlbWljb2xvbigpIHx8ICF0aGlzLm1hdGNoKDE5KSkgYWJvcnQoKTtcbiAgICAgICAgcmV0dXJuIHJldHVyblR5cGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQuYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgaWYgKCFyZXN1bHQudGhyb3duKSB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICBub2RlLnJldHVyblR5cGUgPSByZXN1bHQubm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3cobm9kZSk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtVHlwZShwYXJhbSkge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIHBhcmFtLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIHBhcmFtLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24ocGFyYW0pO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBpc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcpO1xuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIGlmIChpc0xIUykge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKFRTRXJyb3JzLlVuZXhwZWN0ZWRUeXBlQ2FzdEluUGFyYW1ldGVyLCBub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRUeXBlQ2FzdEluUGFyYW1ldGVyLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzTEhTKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgICAgaWYgKCFpc0xIUyAmJiBub2RlLmxlZnQudHlwZSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgbm9kZS5sZWZ0ID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUubGVmdCk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIGlzTEhTKSB7XG4gICAgc3dpdGNoIChub2RlLmV4cHJlc3Npb24udHlwZSkge1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLmV4cHJlc3Npb24sIGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXBlci5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZSwgYWxsb3dQYXR0ZXJuKTtcbiAgICB9XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgICAgcmV0dXJuIFwicGFyYW1ldGVyXCI7XG4gICAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwcmVzc2lvblwiO1xuICAgICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICAgIHJldHVybiAoYmluZGluZyAhPT0gNjQgfHwgIWlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24pICYmIFtcImV4cHJlc3Npb25cIiwgdHJ1ZV07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gICAgfVxuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gNzgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgfVxuICBwYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgY29uc3QgY2FsbCA9IHN1cGVyLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwcik7XG4gICAgICAgIGNhbGwudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIpO1xuICB9XG4gIGNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ICYmIHRoaXMubWF0Y2goMTIpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gY2xvc2UpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZSk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg0NykgfHwgc3VwZXIuaXNDbGFzc01ldGhvZCgpO1xuICB9XG4gIGlzQ2xhc3NQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgzNSkgfHwgdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuaXNDbGFzc1Byb3BlcnR5KCk7XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVBbm5vdGF0aW9uQWZ0ZXJBc3NpZ24sIG5vZGUudHlwZUFubm90YXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIGlmIChjb2RlID09PSA2Mikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDQ4LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDYwKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gIH1cbiAgcmVTY2FuX2x0X2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNDcpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNDgpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9ndCgpO1xuICAgIH1cbiAgfVxuICByZVNjYW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1MSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMjtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgcmV0dXJuIDQ3O1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGV4cHJMaXN0W2ldID0gdGhpcy50eXBlQ2FzdFRvUGFyYW1ldGVyKGV4cHIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci50b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gIH1cbiAgdHlwZUNhc3RUb1BhcmFtZXRlcihub2RlKSB7XG4gICAgbm9kZS5leHByZXNzaW9uLnR5cGVBbm5vdGF0aW9uID0gbm9kZS50eXBlQW5ub3RhdGlvbjtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZS5leHByZXNzaW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uLmxvYy5lbmQpO1xuICAgIHJldHVybiBub2RlLmV4cHJlc3Npb247XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIHJldHVybiBwYXJhbXMuZXZlcnkoZXhwciA9PiB0aGlzLmlzQXNzaWduYWJsZShleHByLCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuICBjYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpIHtcbiAgICByZXR1cm4gc3VwZXIuY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB8fCB0aGlzLmlzQWJzdHJhY3RDbGFzcygpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBZnRlck5hbWUobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKSk7XG4gICAgICBpZiAodHlwZUFyZ3VtZW50cykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICBjb25zdCBiYXNlQ291bnQgPSBzdXBlci5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBjb25zdCBmaXJzdFBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGNvbnN0IGhhc0NvbnRleHRQYXJhbSA9IGZpcnN0UGFyYW0gJiYgdGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtKTtcbiAgICByZXR1cm4gaGFzQ29udGV4dFBhcmFtID8gYmFzZUNvdW50ICsgMSA6IGJhc2VDb3VudDtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSBzdXBlci5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHRzSW5BbWJpZW50Q29udGV4dChjYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzQW1iaWVudENvbnRleHQ6IG9sZElzQW1iaWVudENvbnRleHQsXG4gICAgICBzdHJpY3Q6IG9sZFN0cmljdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IG9sZElzQW1iaWVudENvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IG9sZEluQWJzdHJhY3RDbGFzcyA9IHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzO1xuICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gISFub2RlLmFic3RyYWN0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gb2xkSW5BYnN0cmFjdENsYXNzO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUsIGZhbHNlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgbm9kZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZlciwgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDgwKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHN1cGVyLnBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUpO1xuICAgIGlmIChtZXRob2QuYWJzdHJhY3QpIHtcbiAgICAgIGNvbnN0IGhhc0JvZHkgPSB0aGlzLmhhc1BsdWdpbihcImVzdHJlZVwiKSA/ICEhbWV0aG9kLnZhbHVlLmJvZHkgOiAhIW1ldGhvZC5ib2R5O1xuICAgICAgaWYgKGhhc0JvZHkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb24sIG1ldGhvZCwge1xuICAgICAgICAgIG1ldGhvZE5hbWU6IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbWV0aG9kLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHR5cGVOYW1lLm5hbWU7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImR0c1wiKTtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlKCk7XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICghaXNTdHJpbmcgJiYgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgICB0aGlzLnBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgZmFsc2UsIGlzSW5UeXBlRXhwb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgfVxuICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpO1xuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCFpbXBvcnRlZElzU3RyaW5nICYmIGlzTWF5YmVUeXBlT25seSkge1xuICAgICAgdGhpcy5wYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHJ1ZSwgaXNJblR5cGVPbmx5SW1wb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICB9XG4gICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGlzSW5UeXBlT25seUltcG9ydCA/IDQwOTggOiA0MDk2KTtcbiAgfVxuICBwYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzSW1wb3J0LCBpc0luVHlwZU9ubHlJbXBvcnRFeHBvcnQpIHtcbiAgICBjb25zdCBsZWZ0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRlZFwiIDogXCJsb2NhbFwiO1xuICAgIGNvbnN0IHJpZ2h0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJsb2NhbFwiIDogXCJleHBvcnRlZFwiO1xuICAgIGxldCBsZWZ0T2ZBcyA9IG5vZGVbbGVmdE9mQXNLZXldO1xuICAgIGxldCByaWdodE9mQXM7XG4gICAgbGV0IGhhc1R5cGVTcGVjaWZpZXIgPSBmYWxzZTtcbiAgICBsZXQgY2FuUGFyc2VBc0tleXdvcmQgPSB0cnVlO1xuICAgIGNvbnN0IGxvYyA9IGxlZnRPZkFzLmxvYy5zdGFydDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBmaXJzdEFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgICAgIGxlZnRPZkFzID0gZmlyc3RBcztcbiAgICAgICAgICByaWdodE9mQXMgPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmlnaHRPZkFzID0gc2Vjb25kQXM7XG4gICAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIHJpZ2h0T2ZBcyA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgbGVmdE9mQXMgPSBmaXJzdEFzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG4gICAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgICAgbGVmdE9mQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGxlZnRPZkFzLm5hbWUsIGxlZnRPZkFzLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRPZkFzID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1R5cGVTcGVjaWZpZXIgJiYgaXNJblR5cGVPbmx5SW1wb3J0RXhwb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKGlzSW1wb3J0ID8gVFNFcnJvcnMuVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0cyA6IFRTRXJyb3JzLlR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHMsIGxvYyk7XG4gICAgfVxuICAgIG5vZGVbbGVmdE9mQXNLZXldID0gbGVmdE9mQXM7XG4gICAgbm9kZVtyaWdodE9mQXNLZXldID0gcmlnaHRPZkFzO1xuICAgIGNvbnN0IGtpbmRLZXkgPSBpc0ltcG9ydCA/IFwiaW1wb3J0S2luZFwiIDogXCJleHBvcnRLaW5kXCI7XG4gICAgbm9kZVtraW5kS2V5XSA9IGhhc1R5cGVTcGVjaWZpZXIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICBpZiAoY2FuUGFyc2VBc0tleXdvcmQgJiYgdGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgbm9kZVtyaWdodE9mQXNLZXldID0gaXNJbXBvcnQgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9XG4gICAgaWYgKCFub2RlW3JpZ2h0T2ZBc0tleV0pIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IGNsb25lSWRlbnRpZmllcihub2RlW2xlZnRPZkFzS2V5XSk7XG4gICAgfVxuICAgIGlmIChpc0ltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZVtyaWdodE9mQXNLZXldLCBoYXNUeXBlU3BlY2lmaWVyID8gNDA5OCA6IDQwOTYpO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGlzUG9zc2libHlMaXRlcmFsRW51bShleHByZXNzaW9uKSB7XG4gIGlmIChleHByZXNzaW9uLnR5cGUgIT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHtcbiAgICBjb21wdXRlZCxcbiAgICBwcm9wZXJ0eVxuICB9ID0gZXhwcmVzc2lvbjtcbiAgaWYgKGNvbXB1dGVkICYmIHByb3BlcnR5LnR5cGUgIT09IFwiU3RyaW5nTGl0ZXJhbFwiICYmIChwcm9wZXJ0eS50eXBlICE9PSBcIlRlbXBsYXRlTGl0ZXJhbFwiIHx8IHByb3BlcnR5LmV4cHJlc3Npb25zLmxlbmd0aCA+IDApKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1VuY29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uQ2hhaW4oZXhwcmVzc2lvbi5vYmplY3QpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEFtYmllbnRDb25zdEluaXRpYWxpemVyKGV4cHJlc3Npb24sIGVzdHJlZSkge1xuICB2YXIgX2V4cHJlc3Npb24kZXh0cmE7XG4gIGNvbnN0IHtcbiAgICB0eXBlXG4gIH0gPSBleHByZXNzaW9uO1xuICBpZiAoKF9leHByZXNzaW9uJGV4dHJhID0gZXhwcmVzc2lvbi5leHRyYSkgIT0gbnVsbCAmJiBfZXhwcmVzc2lvbiRleHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlc3RyZWUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSBleHByZXNzaW9uO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgfHwgdHlwZSA9PT0gXCJCb29sZWFuTGl0ZXJhbFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkgfHwgaXNOZWdhdGl2ZU51bWJlcihleHByZXNzaW9uLCBlc3RyZWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgJiYgZXhwcmVzc2lvbi5leHByZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaXNQb3NzaWJseUxpdGVyYWxFbnVtKGV4cHJlc3Npb24pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB7XG4gIGlmIChlc3RyZWUpIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJiAodHlwZW9mIGV4cHJlc3Npb24udmFsdWUgPT09IFwibnVtYmVyXCIgfHwgXCJiaWdpbnRcIiBpbiBleHByZXNzaW9uKTtcbiAgfVxuICByZXR1cm4gZXhwcmVzc2lvbi50eXBlID09PSBcIk51bWVyaWNMaXRlcmFsXCIgfHwgZXhwcmVzc2lvbi50eXBlID09PSBcIkJpZ0ludExpdGVyYWxcIjtcbn1cbmZ1bmN0aW9uIGlzTmVnYXRpdmVOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB7XG4gIGlmIChleHByZXNzaW9uLnR5cGUgPT09IFwiVW5hcnlFeHByZXNzaW9uXCIpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRvcixcbiAgICAgIGFyZ3VtZW50XG4gICAgfSA9IGV4cHJlc3Npb247XG4gICAgaWYgKG9wZXJhdG9yID09PSBcIi1cIiAmJiBpc051bWJlcihhcmd1bWVudCwgZXN0cmVlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uKSB7XG4gIGlmIChleHByZXNzaW9uLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgZXhwcmVzc2lvbi5jb21wdXRlZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNVbmNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbkNoYWluKGV4cHJlc3Npb24ub2JqZWN0KTtcbn1cbmNvbnN0IFBsYWNlaG9sZGVyRXJyb3JzID0gUGFyc2VFcnJvckVudW1gcGxhY2Vob2xkZXJzYCh7XG4gIENsYXNzTmFtZUlzUmVxdWlyZWQ6IFwiQSBjbGFzcyBuYW1lIGlzIHJlcXVpcmVkLlwiLFxuICBVbmV4cGVjdGVkU3BhY2U6IFwiVW5leHBlY3RlZCBzcGFjZSBpbiBwbGFjZWhvbGRlci5cIlxufSk7XG52YXIgcGxhY2Vob2xkZXJzID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBQbGFjZWhvbGRlcnNQYXJzZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBwYXJzZVBsYWNlaG9sZGVyKGV4cGVjdGVkTm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDEzMykpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmFzc2VydE5vU3BhY2UoKTtcbiAgICAgIG5vZGUubmFtZSA9IHN1cGVyLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm9TcGFjZSgpO1xuICAgICAgdGhpcy5leHBlY3QoMTMzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKG5vZGUsIGV4cGVjdGVkTm9kZSk7XG4gICAgfVxuICB9XG4gIGZpbmlzaFBsYWNlaG9sZGVyKG5vZGUsIGV4cGVjdGVkTm9kZSkge1xuICAgIGxldCBwbGFjZWhvbGRlciA9IG5vZGU7XG4gICAgaWYgKCFwbGFjZWhvbGRlci5leHBlY3RlZE5vZGUgfHwgIXBsYWNlaG9sZGVyLnR5cGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyID0gdGhpcy5maW5pc2hOb2RlKHBsYWNlaG9sZGVyLCBcIlBsYWNlaG9sZGVyXCIpO1xuICAgIH1cbiAgICBwbGFjZWhvbGRlci5leHBlY3RlZE5vZGUgPSBleHBlY3RlZE5vZGU7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIGlmIChjb2RlID09PSAzNyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMzcpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMTMzLCAyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIkV4cHJlc3Npb25cIikgfHwgc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUlkZW50aWZpZXIobGliZXJhbCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpIHx8IHN1cGVyLnBhcnNlSWRlbnRpZmllcihsaWJlcmFsKTtcbiAgfVxuICBjaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKSB7XG4gICAgaWYgKHdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3VwZXIuY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlBhdHRlcm5cIikgfHwgc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGlzUGFyZW50aGVzaXplZCwgYmluZGluZykge1xuICAgIHJldHVybiB0eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUuZXhwZWN0ZWROb2RlID0gXCJQYXR0ZXJuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChzdXBlci5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICBpZiAobmV4dFRva2VuLnR5cGUgPT09IDEzMykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspIHtcbiAgICBpZiAobm9kZS5sYWJlbCAmJiBub2RlLmxhYmVsLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikgcmV0dXJuO1xuICAgIHN1cGVyLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiIHx8IChfZXhwciRleHRyYSA9IGV4cHIuZXh0cmEpICE9IG51bGwgJiYgX2V4cHIkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBzdG10ID0gbm9kZTtcbiAgICAgIHN0bXQubGFiZWwgPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGV4cHIsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3RtdC5ib2R5ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3RtdCwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIGNvbnN0IHN0bXRQbGFjZWhvbGRlciA9IG5vZGU7XG4gICAgc3RtdFBsYWNlaG9sZGVyLm5hbWUgPSBleHByLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIoc3RtdFBsYWNlaG9sZGVyLCBcIlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcywgY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIikgfHwgc3VwZXIucGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMsIGNyZWF0ZU5ld0xleGljYWxTY29wZSwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4MSkgfHwgdGhpcy5tYXRjaCgxMzMpIHx8IHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgbm9kZS5pZCA9IHBsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJDbGFzc0JvZHlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLkNsYXNzTmFtZUlzUmVxdWlyZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJDbGFzc0JvZHlcIikgfHwgc3VwZXIucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5OCkgJiYgIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyLCBcIkRlY2xhcmF0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gcGxhY2Vob2xkZXI7XG4gICAgbm9kZTIuc3BlY2lmaWVycyA9IFt0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlMiwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zdGFydHNXaXRoKHRva2VuTGFiZWxOYW1lKDEzMyksIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICB2YXIgX3NwZWNpZmllcnM7XG4gICAgaWYgKChfc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsICYmIHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmZpbHRlcihub2RlID0+IG5vZGUuZXhwb3J0ZWQudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG4gICAgc3VwZXIuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk4KSAmJiAhdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUocGxhY2Vob2xkZXIpO1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHBsYWNlaG9sZGVyO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgY29uc3QgaGFzU3RhckltcG9ydCA9IHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAoIWhhc1N0YXJJbXBvcnQpIHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlN0cmluZ0xpdGVyYWxcIikgfHwgc3VwZXIucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgfVxuICBhc3NlcnROb1NwYWNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXJ0ID4gdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLlVuZXhwZWN0ZWRTcGFjZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgICB9XG4gIH1cbn07XG52YXIgdjhpbnRyaW5zaWMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFY4SW50cmluc2ljTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VWOEludHJpbnNpYygpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NCkpIHtcbiAgICAgIGNvbnN0IHY4SW50cmluc2ljU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKTtcbiAgICAgICAgaWRlbnRpZmllci50eXBlID0gXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIjtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZCh2OEludHJpbnNpY1N0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VWOEludHJpbnNpYygpIHx8IHN1cGVyLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbn07XG5jb25zdCBQSVBFTElORV9QUk9QT1NBTFMgPSBbXCJtaW5pbWFsXCIsIFwiZnNoYXJwXCIsIFwiaGFja1wiLCBcInNtYXJ0XCJdO1xuY29uc3QgVE9QSUNfVE9LRU5TID0gW1wiXl5cIiwgXCJAQFwiLCBcIl5cIiwgXCIlXCIsIFwiI1wiXTtcbmZ1bmN0aW9uIHZhbGlkYXRlUGx1Z2lucyhwbHVnaW5zTWFwKSB7XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlY29yYXRvcnNcIikpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZWNvcmF0b3JzLWxlZ2FjeVwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgZGVjb3JhdG9ycyBhbmQgZGVjb3JhdG9ycy1sZWdhY3kgcGx1Z2luIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ID0gcGx1Z2luc01hcC5nZXQoXCJkZWNvcmF0b3JzXCIpLmRlY29yYXRvcnNCZWZvcmVFeHBvcnQ7XG4gICAgaWYgKGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgIT0gbnVsbCAmJiB0eXBlb2YgZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidkZWNvcmF0b3JzQmVmb3JlRXhwb3J0JyBtdXN0IGJlIGEgYm9vbGVhbiwgaWYgc3BlY2lmaWVkLlwiKTtcbiAgICB9XG4gICAgY29uc3QgYWxsb3dDYWxsUGFyZW50aGVzaXplZCA9IHBsdWdpbnNNYXAuZ2V0KFwiZGVjb3JhdG9yc1wiKS5hbGxvd0NhbGxQYXJlbnRoZXNpemVkO1xuICAgIGlmIChhbGxvd0NhbGxQYXJlbnRoZXNpemVkICE9IG51bGwgJiYgdHlwZW9mIGFsbG93Q2FsbFBhcmVudGhlc2l6ZWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCInYWxsb3dDYWxsUGFyZW50aGVzaXplZCcgbXVzdCBiZSBhIGJvb2xlYW4uXCIpO1xuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJmbG93XCIpICYmIHBsdWdpbnNNYXAuaGFzKFwidHlwZXNjcmlwdFwiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIGZsb3cgYW5kIHR5cGVzY3JpcHQgcGx1Z2lucy5cIik7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGxhY2Vob2xkZXJzXCIpICYmIHBsdWdpbnNNYXAuaGFzKFwidjhpbnRyaW5zaWNcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBwbGFjZWhvbGRlcnMgYW5kIHY4aW50cmluc2ljIHBsdWdpbnMuXCIpO1xuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcInBpcGVsaW5lT3BlcmF0b3JcIikpIHtcbiAgICB2YXIgX3BsdWdpbnNNYXAkZ2V0O1xuICAgIGNvbnN0IHByb3Bvc2FsID0gcGx1Z2luc01hcC5nZXQoXCJwaXBlbGluZU9wZXJhdG9yXCIpLnByb3Bvc2FsO1xuICAgIGlmICghUElQRUxJTkVfUFJPUE9TQUxTLmluY2x1ZGVzKHByb3Bvc2FsKSkge1xuICAgICAgY29uc3QgcHJvcG9zYWxMaXN0ID0gUElQRUxJTkVfUFJPUE9TQUxTLm1hcChwID0+IGBcIiR7cH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgcmVxdWlyZXMgXCJwcm9wb3NhbFwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtwcm9wb3NhbExpc3R9LmApO1xuICAgIH1cbiAgICBjb25zdCB0dXBsZVN5bnRheElzSGFzaCA9ICgoX3BsdWdpbnNNYXAkZ2V0ID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbHVnaW5zTWFwJGdldC5zeW50YXhUeXBlKSA9PT0gXCJoYXNoXCI7XG4gICAgaWYgKHByb3Bvc2FsID09PSBcImhhY2tcIikge1xuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGxhY2Vob2xkZXJzXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBwbHVnaW4gYW5kIEhhY2stc3R5bGUgcGlwZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwidjhpbnRyaW5zaWNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgdjhpbnRyaW5zaWMgcGx1Z2luIGFuZCBIYWNrLXN0eWxlIHBpcGVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcGljVG9rZW4gPSBwbHVnaW5zTWFwLmdldChcInBpcGVsaW5lT3BlcmF0b3JcIikudG9waWNUb2tlbjtcbiAgICAgIGlmICghVE9QSUNfVE9LRU5TLmluY2x1ZGVzKHRvcGljVG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IHRva2VuTGlzdCA9IFRPUElDX1RPS0VOUy5tYXAodCA9PiBgXCIke3R9XCJgKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgaW4gXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBtb2RlIGFsc28gcmVxdWlyZXMgYSBcInRvcGljVG9rZW5cIiBvcHRpb24gd2hvc2UgdmFsdWUgbXVzdCBiZSBvbmUgb2Y6ICR7dG9rZW5MaXN0fS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3BpY1Rva2VuID09PSBcIiNcIiAmJiB0dXBsZVN5bnRheElzSGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbiBjb25mbGljdCBiZXR3ZWVuIFxcYFtcInBpcGVsaW5lT3BlcmF0b3JcIiwgeyBwcm9wb3NhbDogXCJoYWNrXCIsIHRvcGljVG9rZW46IFwiI1wiIH1dXFxgIGFuZCBcXGAke0pTT04uc3RyaW5naWZ5KFtcInJlY29yZEFuZFR1cGxlXCIsIHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIildKX1cXGAuYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wb3NhbCA9PT0gXCJzbWFydFwiICYmIHR1cGxlU3ludGF4SXNIYXNoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbiBjb25mbGljdCBiZXR3ZWVuIFxcYFtcInBpcGVsaW5lT3BlcmF0b3JcIiwgeyBwcm9wb3NhbDogXCJzbWFydFwiIH1dXFxgIGFuZCBcXGAke0pTT04uc3RyaW5naWZ5KFtcInJlY29yZEFuZFR1cGxlXCIsIHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIildKX1cXGAuYCk7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHtcbiAgICB7XG4gICAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpIHx8IHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tYmluZSBpbXBvcnRBc3NlcnRpb25zLCBkZXByZWNhdGVkSW1wb3J0QXNzZXJ0IGFuZCBtb2R1bGVBdHRyaWJ1dGVzIHBsdWdpbnMuXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgbW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gPSBwbHVnaW5zTWFwLmdldChcIm1vZHVsZUF0dHJpYnV0ZXNcIikudmVyc2lvbjtcbiAgICAgIGlmIChtb2R1bGVBdHRyaWJ1dGVzVmVyc2lvblBsdWdpbk9wdGlvbiAhPT0gXCJtYXktMjAyMFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnbW9kdWxlQXR0cmlidXRlcycgcGx1Z2luIHJlcXVpcmVzIGEgJ3ZlcnNpb24nIG9wdGlvbixcIiArIFwiIHJlcHJlc2VudGluZyB0aGUgbGFzdCBwcm9wb3NhbCB1cGRhdGUuIEN1cnJlbnRseSwgdGhlXCIgKyBcIiBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpcyAnbWF5LTIwMjAnLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIGltcG9ydEFzc2VydGlvbnMgYW5kIGRlcHJlY2F0ZWRJbXBvcnRBc3NlcnQgcGx1Z2lucy5cIik7XG4gICAgfVxuICB9XG4gIGlmICghcGx1Z2luc01hcC5oYXMoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpICYmIHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXR0cmlidXRlc1wiKSAmJiBwbHVnaW5zTWFwLmdldChcImltcG9ydEF0dHJpYnV0ZXNcIikuZGVwcmVjYXRlZEFzc2VydFN5bnRheCkge1xuICAgIHtcbiAgICAgIHBsdWdpbnNNYXAuc2V0KFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiLCB7fSk7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcInJlY29yZEFuZFR1cGxlXCIpKSB7XG4gICAgY29uc3Qgc3ludGF4VHlwZSA9IHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIikuc3ludGF4VHlwZTtcbiAgICBpZiAoc3ludGF4VHlwZSAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGNvbnN0IFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTID0gW1wiaGFzaFwiLCBcImJhclwiXTtcbiAgICAgICAgaWYgKCFSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUy5pbmNsdWRlcyhzeW50YXhUeXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBtdXN0IGJlIG9uZSBvZjogXCIgKyBSRUNPUkRfQU5EX1RVUExFX1NZTlRBWF9UWVBFUy5tYXAocCA9PiBgJyR7cH0nYCkuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJhc3luY0RvRXhwcmVzc2lvbnNcIikgJiYgIXBsdWdpbnNNYXAuaGFzKFwiZG9FeHByZXNzaW9uc1wiKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiJ2FzeW5jRG9FeHByZXNzaW9ucycgcmVxdWlyZXMgJ2RvRXhwcmVzc2lvbnMnLCBwbGVhc2UgYWRkICdkb0V4cHJlc3Npb25zJyB0byBwYXJzZXIgcGx1Z2lucy5cIik7XG4gICAgZXJyb3IubWlzc2luZ1BsdWdpbnMgPSBcImRvRXhwcmVzc2lvbnNcIjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiKS52ZXJzaW9uICE9PSBcIjIwMjMtMDdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnb3B0aW9uYWxDaGFpbmluZ0Fzc2lnbicgcGx1Z2luIHJlcXVpcmVzIGEgJ3ZlcnNpb24nIG9wdGlvbixcIiArIFwiIHJlcHJlc2VudGluZyB0aGUgbGFzdCBwcm9wb3NhbCB1cGRhdGUuIEN1cnJlbnRseSwgdGhlXCIgKyBcIiBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpcyAnMjAyMy0wNycuXCIpO1xuICB9XG59XG5jb25zdCBtaXhpblBsdWdpbnMgPSB7XG4gIGVzdHJlZSxcbiAganN4LFxuICBmbG93LFxuICB0eXBlc2NyaXB0LFxuICB2OGludHJpbnNpYyxcbiAgcGxhY2Vob2xkZXJzXG59O1xuY29uc3QgbWl4aW5QbHVnaW5OYW1lcyA9IE9iamVjdC5rZXlzKG1peGluUGx1Z2lucyk7XG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0T3B0aW9ucygpIHtcbiAgcmV0dXJuIHtcbiAgICBzb3VyY2VUeXBlOiBcInNjcmlwdFwiLFxuICAgIHNvdXJjZUZpbGVuYW1lOiB1bmRlZmluZWQsXG4gICAgc3RhcnRJbmRleDogMCxcbiAgICBzdGFydENvbHVtbjogMCxcbiAgICBzdGFydExpbmU6IDEsXG4gICAgYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IGZhbHNlLFxuICAgIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiBmYWxzZSxcbiAgICBhbGxvd1VuZGVjbGFyZWRFeHBvcnRzOiBmYWxzZSxcbiAgICBwbHVnaW5zOiBbXSxcbiAgICBzdHJpY3RNb2RlOiBudWxsLFxuICAgIHJhbmdlczogZmFsc2UsXG4gICAgdG9rZW5zOiBmYWxzZSxcbiAgICBjcmVhdGVJbXBvcnRFeHByZXNzaW9uczogZmFsc2UsXG4gICAgY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zOiBmYWxzZSxcbiAgICBlcnJvclJlY292ZXJ5OiBmYWxzZSxcbiAgICBhdHRhY2hDb21tZW50OiB0cnVlLFxuICAgIGFubmV4QjogdHJ1ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjcmVhdGVEZWZhdWx0T3B0aW9ucygpO1xuICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgaWYgKG9wdHMuYW5uZXhCICE9IG51bGwgJiYgb3B0cy5hbm5leEIgIT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGBhbm5leEJgIG9wdGlvbiBjYW4gb25seSBiZSBzZXQgdG8gYGZhbHNlYC5cIik7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob3B0aW9ucykpIHtcbiAgICBpZiAob3B0c1trZXldICE9IG51bGwpIG9wdGlvbnNba2V5XSA9IG9wdHNba2V5XTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGFydExpbmUgPT09IDEpIHtcbiAgICBpZiAob3B0cy5zdGFydEluZGV4ID09IG51bGwgJiYgb3B0aW9ucy5zdGFydENvbHVtbiA+IDApIHtcbiAgICAgIG9wdGlvbnMuc3RhcnRJbmRleCA9IG9wdGlvbnMuc3RhcnRDb2x1bW47XG4gICAgfSBlbHNlIGlmIChvcHRzLnN0YXJ0Q29sdW1uID09IG51bGwgJiYgb3B0aW9ucy5zdGFydEluZGV4ID4gMCkge1xuICAgICAgb3B0aW9ucy5zdGFydENvbHVtbiA9IG9wdGlvbnMuc3RhcnRJbmRleDtcbiAgICB9XG4gIH0gZWxzZSBpZiAob3B0cy5zdGFydENvbHVtbiA9PSBudWxsIHx8IG9wdHMuc3RhcnRJbmRleCA9PSBudWxsKSB7XG4gICAgaWYgKG9wdHMuc3RhcnRJbmRleCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaXRoIGEgYHN0YXJ0TGluZSA+IDFgIHlvdSBtdXN0IGFsc28gc3BlY2lmeSBgc3RhcnRJbmRleGAgYW5kIGBzdGFydENvbHVtbmAuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBMVmFsUGFyc2VyIHtcbiAgY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgcHJvdG9SZWYsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCB0aGlzLmlzT2JqZWN0TWV0aG9kKHByb3ApIHx8IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcHJvcC5rZXk7XG4gICAgY29uc3QgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBpZiAoaXNSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVjb3JkTm9Qcm90bywga2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvUmVmLnVzZWQpIHtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9IGtleS5sb2Muc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVByb3RvLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm90b1JlZi51c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkge1xuICAgIHJldHVybiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiB0aGlzLm9mZnNldFRvU291cmNlUG9zKGV4cHIuc3RhcnQpID09PSBwb3RlbnRpYWxBcnJvd0F0O1xuICB9XG4gIGdldEV4cHJlc3Npb24oKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmICghdGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZVJlbWFpbmluZ0NvbW1lbnRzKCk7XG4gICAgZXhwci5jb21tZW50cyA9IHRoaXMuY29tbWVudHM7XG4gICAgZXhwci5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBpZiAodGhpcy5vcHRpb25zLnRva2Vucykge1xuICAgICAgZXhwci50b2tlbnMgPSB0aGlzLnRva2VucztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uKGRpc2FsbG93SW4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoZGlzYWxsb3dJbikge1xuICAgICAgcmV0dXJuIHRoaXMuZGlzYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uQmFzZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb25zID0gW2V4cHJdO1xuICAgICAgd2hpbGUgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgICBub2RlLmV4cHJlc3Npb25zLnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChub2RlLmV4cHJlc3Npb25zKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ25EaXNhbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHJldHVybiB0aGlzLmFsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSk7XG4gIH1cbiAgc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycywgcmVzdWx0RXJyb3IpIHtcbiAgICB2YXIgX3Jlc3VsdEVycm9yJGxvYztcbiAgICByZWZFeHByZXNzaW9uRXJyb3JzLm9wdGlvbmFsUGFyYW1ldGVyc0xvYyA9IChfcmVzdWx0RXJyb3IkbG9jID0gcmVzdWx0RXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3VsdEVycm9yLmxvYykgIT0gbnVsbCA/IF9yZXN1bHRFcnJvciRsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwOCkpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkge1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VZaWVsZCgpO1xuICAgICAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvd25FeHByZXNzaW9uRXJyb3JzO1xuICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICBvd25FeHByZXNzaW9uRXJyb3JzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgICAgb3duRXhwcmVzc2lvbkVycm9ycyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gMTAgfHwgdG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgfVxuICAgIGxldCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlQ29uZGl0aW9uYWwocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgICBsZWZ0ID0gYWZ0ZXJMZWZ0UGFyc2UuY2FsbCh0aGlzLCBsZWZ0LCBzdGFydExvYyk7XG4gICAgfVxuICAgIGlmICh0b2tlbklzQXNzaWdubWVudCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobGVmdCwgdHJ1ZSk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBzdGFydExvYy5pbmRleDtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLmRvdWJsZVByb3RvTG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MuaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChsZWZ0LCB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG93bkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBwYXJzZU1heWJlQ29uZGl0aW9uYWwocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwck9wcyhyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlQ29uZGl0aW9uYWwoZXhwciwgc3RhcnRMb2MsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLnRlc3QgPSBleHByO1xuICAgICAgbm9kZS5jb25zZXF1ZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM5KSA/IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpIDogdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcChleHByLCBzdGFydExvYywgLTEpO1xuICB9XG4gIHBhcnNlRXhwck9wKGxlZnQsIGxlZnRTdGFydExvYywgbWluUHJlYykge1xuICAgIGlmICh0aGlzLmlzUHJpdmF0ZU5hbWUobGVmdCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRQcml2YXRlTmFtZVNWKGxlZnQpO1xuICAgICAgaWYgKG1pblByZWMgPj0gdG9rZW5PcGVyYXRvclByZWNlZGVuY2UoNTgpIHx8ICF0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUHJpdmF0ZUluRXhwZWN0ZWRJbiwgbGVmdCwge1xuICAgICAgICAgIGlkZW50aWZpZXJOYW1lOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh2YWx1ZSwgbGVmdC5sb2Muc3RhcnQpO1xuICAgIH1cbiAgICBjb25zdCBvcCA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBpZiAodG9rZW5Jc09wZXJhdG9yKG9wKSAmJiAodGhpcy5wcm9kUGFyYW0uaGFzSW4gfHwgIXRoaXMubWF0Y2goNTgpKSkge1xuICAgICAgbGV0IHByZWMgPSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZShvcCk7XG4gICAgICBpZiAocHJlYyA+IG1pblByZWMpIHtcbiAgICAgICAgaWYgKG9wID09PSAzOSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGlwZWxpbmVPcGVyYXRvclwiKTtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY2hlY2tQaXBlbGluZUF0SW5maXhPcGVyYXRvcihsZWZ0LCBsZWZ0U3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KGxlZnRTdGFydExvYyk7XG4gICAgICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICBjb25zdCBsb2dpY2FsID0gb3AgPT09IDQxIHx8IG9wID09PSA0MjtcbiAgICAgICAgY29uc3QgY29hbGVzY2UgPSBvcCA9PT0gNDA7XG4gICAgICAgIGlmIChjb2FsZXNjZSkge1xuICAgICAgICAgIHByZWMgPSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg0Mik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChvcCA9PT0gMzkgJiYgdGhpcy5oYXNQbHVnaW4oW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7XG4gICAgICAgICAgcHJvcG9zYWw6IFwibWluaW1hbFwiXG4gICAgICAgIH1dKSkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDk2ICYmIHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXdhaXRBZnRlclBpcGVsaW5lQm9keSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUucmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICAgICAgY29uc3QgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGxvZ2ljYWwgfHwgY29hbGVzY2UgPyBcIkxvZ2ljYWxFeHByZXNzaW9uXCIgOiBcIkJpbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICAgIGNvbnN0IG5leHRPcCA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICAgICAgaWYgKGNvYWxlc2NlICYmIChuZXh0T3AgPT09IDQxIHx8IG5leHRPcCA9PT0gNDIpIHx8IGxvZ2ljYWwgJiYgbmV4dE9wID09PSA0MCkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWwsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGZpbmlzaGVkTm9kZSwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgcGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKSkge1xuICAgICAgICAgIGNhc2UgXCJoYWNrXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGFja1BpcGVCb2R5KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwic21hcnRcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhUb3BpY0JpbmRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkICYmIHRoaXMuaXNDb250ZXh0dWFsKDEwOCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlQm9keUlzVGlnaHRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTbWFydFBpcGVsaW5lQm9keUluU3R5bGUodGhpcy5wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMpLCBzdGFydExvYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICBjYXNlIFwiZnNoYXJwXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aXRoU29sb0F3YWl0UGVybWl0dGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZTaGFycFBpcGVsaW5lQm9keShwcmVjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJPcEJhc2VSaWdodEV4cHIob3AsIHByZWMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUoKSwgc3RhcnRMb2MsIHRva2VuSXNSaWdodEFzc29jaWF0aXZlKG9wKSA/IHByZWMgLSAxIDogcHJlYyk7XG4gIH1cbiAgcGFyc2VIYWNrUGlwZUJvZHkoKSB7XG4gICAgdmFyIF9ib2R5JGV4dHJhO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgIGNvbnN0IHJlcXVpcmVkUGFyZW50aGVzZXMgPSBVbnBhcmVudGhlc2l6ZWRQaXBlQm9keURlc2NyaXB0aW9ucy5oYXMoYm9keS50eXBlKTtcbiAgICBpZiAocmVxdWlyZWRQYXJlbnRoZXNlcyAmJiAhKChfYm9keSRleHRyYSA9IGJvZHkuZXh0cmEpICE9IG51bGwgJiYgX2JvZHkkZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVVbnBhcmVudGhlc2l6ZWRCb2R5LCBzdGFydExvYywge1xuICAgICAgICB0eXBlOiBib2R5LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50Q29udGV4dCgpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbnVzZWQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgY2hlY2tFeHBvbmVudGlhbEFmdGVyVW5hcnkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDU3KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbiwgbm9kZS5hcmd1bWVudCk7XG4gICAgfVxuICB9XG4gIHBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc0F3YWl0ID0gdGhpcy5pc0NvbnRleHR1YWwoOTYpO1xuICAgIGlmIChpc0F3YWl0ICYmIHRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUF3YWl0KHN0YXJ0TG9jKTtcbiAgICAgIGlmICghc2F3VW5hcnkpIHRoaXMuY2hlY2tFeHBvbmVudGlhbEFmdGVyVW5hcnkoZXhwcik7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5tYXRjaCgzNCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRva2VuSXNQcmVmaXgodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5tYXRjaCg3MikpIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJ0aHJvd0V4cHJlc3Npb25zXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNEZWxldGUgPSB0aGlzLm1hdGNoKDg5KTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgaXNEZWxldGUpIHtcbiAgICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgICAgaWYgKGFyZy50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdERlbGV0ZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQcm9wZXJ0eUFzUHJpdmF0ZU5hbWUoYXJnKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlbGV0ZVByaXZhdGVGaWVsZCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdXBkYXRlKSB7XG4gICAgICAgIGlmICghc2F3VW5hcnkpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJVbmFyeUV4cHJlc3Npb25cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlVXBkYXRlKG5vZGUsIHVwZGF0ZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKGlzQXdhaXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBzdGFydHNFeHByID0gdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSA/IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpIDogdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgJiYgIXRoaXMubWF0Y2goNTQpO1xuICAgICAgaWYgKHN0YXJ0c0V4cHIgJiYgIXRoaXMuaXNBbWJpZ3VvdXNBd2FpdCgpKSB7XG4gICAgICAgIHRoaXMucmFpc2VPdmVyd3JpdGUoRXJyb3JzLkF3YWl0Tm90SW5Bc3luY0NvbnRleHQsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBd2FpdChzdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlVXBkYXRlKG5vZGUsIHVwZGF0ZSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZUV4cHJlc3Npb25Ob2RlID0gbm9kZTtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKHVwZGF0ZUV4cHJlc3Npb25Ob2RlLmFyZ3VtZW50LCB0aGlzLmZpbmlzaE5vZGUodXBkYXRlRXhwcmVzc2lvbk5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCBleHByID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCBmYWxzZSkpIHJldHVybiBleHByO1xuICAgIHdoaWxlICh0b2tlbklzUG9zdGZpeCh0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLm9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUucHJlZml4ID0gZmFsc2U7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gZXhwcjtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5jaGVja0xWYWwoZXhwciwgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVwZGF0ZUV4cHJlc3Npb25cIikpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUV4cHJTdWJzY3JpcHRzKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdDtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXI6IGZhbHNlLFxuICAgICAgbWF5YmVBc3luY0Fycm93OiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpLFxuICAgICAgc3RvcDogZmFsc2VcbiAgICB9O1xuICAgIGRvIHtcbiAgICAgIGJhc2UgPSB0aGlzLnBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5tYXliZUFzeW5jQXJyb3cgPSBmYWxzZTtcbiAgICB9IHdoaWxlICghc3RhdGUuc3RvcCk7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbiAgcGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICghbm9DYWxscyAmJiB0eXBlID09PSAxNSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSk7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzVGVtcGxhdGUodHlwZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSk7XG4gICAgfVxuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSAxOCkge1xuICAgICAgaWYgKG5vQ2FsbHMpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3B0aW9uYWxDaGFpbmluZ05vTmV3LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlciA9IG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgIH1cbiAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ292ZXJDYWxsQW5kQXN5bmNBcnJvd0hlYWQoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBvcHRpb25hbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5lYXQoMCk7XG4gICAgICBpZiAoY29tcHV0ZWQgfHwgb3B0aW9uYWwgfHwgdGhpcy5lYXQoMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWVtYmVyKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSwgY29tcHV0ZWQsIG9wdGlvbmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VNZW1iZXIoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBjb21wdXRlZCwgb3B0aW9uYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgIG5vZGUuY29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICBpZiAoY29tcHV0ZWQpIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzOSkpIHtcbiAgICAgIGlmIChiYXNlLnR5cGUgPT09IFwiU3VwZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdXBlclByaXZhdGVGaWVsZCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuc3RhdGUudmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VCaW5kKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKSwgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG4gIHBhcnNlQ292ZXJDYWxsQW5kQXN5bmNBcnJvd0hlYWQoYmFzZSwgc3RhcnRMb2MsIHN0YXRlLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgbGV0IHJlZkV4cHJlc3Npb25FcnJvcnMgPSBudWxsO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICBjb25zdCB7XG4gICAgICBtYXliZUFzeW5jQXJyb3csXG4gICAgICBvcHRpb25hbENoYWluTWVtYmVyXG4gICAgfSA9IHN0YXRlO1xuICAgIGlmIChtYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0FzeW5jQXJyb3dTY29wZSgpKTtcbiAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMgPSBuZXcgRXhwcmVzc2lvbkVycm9ycygpO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgIH1cbiAgICBpZiAob3B0aW9uYWwpIHtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKDExKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEsIGJhc2UudHlwZSAhPT0gXCJTdXBlclwiLCBub2RlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICB9XG4gICAgbGV0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXN5bmNBcnJvdygpICYmICFvcHRpb25hbCkge1xuICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS52YWxpZGF0ZUFzUGF0dGVybigpO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgZmluaXNoZWROb2RlID0gdGhpcy5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydExvYyksIGZpbmlzaGVkTm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cpIHtcbiAgICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkQXJndW1lbnRzKGZpbmlzaGVkTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgcmV0dXJuIGZpbmlzaGVkTm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAobm9kZS5hcmd1bWVudHMsIGlzUGFyZW50aGVzaXplZEV4cHIpO1xuICB9XG4gIHBhcnNlVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLnRhZyA9IGJhc2U7XG4gICAgbm9kZS5xdWFzaSA9IHRoaXMucGFyc2VUZW1wbGF0ZSh0cnVlKTtcbiAgICBpZiAoc3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3B0aW9uYWxDaGFpbmluZ05vVGVtcGxhdGUsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgfVxuICBhdFBvc3NpYmxlQXN5bmNBcnJvdyhiYXNlKSB7XG4gICAgcmV0dXJuIGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4ID09PSBiYXNlLmVuZCAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiBiYXNlLmVuZCAtIGJhc2Uuc3RhcnQgPT09IDUgJiYgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhiYXNlLnN0YXJ0KSA9PT0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICB9XG4gIGZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIG9wdGlvbmFsKSB7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIGlmIChub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgbm9kZS5hcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRDYWxsQXJpdHksIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2Ygbm9kZS5hcmd1bWVudHMpIHtcbiAgICAgICAgICBpZiAoYXJnLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRDYWxsU3ByZWFkQXJndW1lbnQsIGFyZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgb3B0aW9uYWwgPyBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiA6IFwiQ2FsbEV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cyhjbG9zZSwgYWxsb3dQbGFjZWhvbGRlciwgbm9kZUZvckV4dHJhLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3QgZWx0cyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGVGb3JFeHRyYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShmYWxzZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWxsb3dQbGFjZWhvbGRlcikpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgcmV0dXJuIGVsdHM7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE5KSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKTtcbiAgfVxuICBwYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCkge1xuICAgIHZhciBfY2FsbCRleHRyYTtcbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhjYWxsKTtcbiAgICB0aGlzLmV4cGVjdCgxOSk7XG4gICAgdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBjYWxsLmFyZ3VtZW50cywgdHJ1ZSwgKF9jYWxsJGV4dHJhID0gY2FsbC5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYWxsJGV4dHJhLnRyYWlsaW5nQ29tbWFMb2MpO1xuICAgIGlmIChjYWxsLmlubmVyQ29tbWVudHMpIHtcbiAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY2FsbC5pbm5lckNvbW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKGNhbGwuY2FsbGVlLnRyYWlsaW5nQ29tbWVudHMpIHtcbiAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY2FsbC5jYWxsZWUudHJhaWxpbmdDb21tZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlTm9DYWxsRXhwcigpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMucGFyc2VFeHByQXRvbSgpLCBzdGFydExvYywgdHJ1ZSk7XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGRlY29yYXRvcnMgPSBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgNzk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3VwZXIoKTtcbiAgICAgIGNhc2UgODM6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRNZXRhUHJvcGVydHkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jcmVhdGVJbXBvcnRFeHByZXNzaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRDYWxsKG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZEltcG9ydCwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzg6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGUoKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDU2OlxuICAgICAgY2FzZSAzMTpcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMucmVhZFJlZ2V4cCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVnRXhwTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjYXNlIDEzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNhc2UgODQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTnVsbExpdGVyYWwoKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwodHJ1ZSk7XG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKGZhbHNlKTtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBjYW5CZUFycm93ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID09PSB0aGlzLnN0YXRlLnN0YXJ0O1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gMiA/IDQgOiAzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKDMsIHRydWUsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA2OlxuICAgICAgY2FzZSA3OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gNiA/IDkgOiA4LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0TGlrZSg4LCBmYWxzZSwgZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDY4OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uT3JGdW5jdGlvblNlbnQoKTtcbiAgICAgIGNhc2UgMjY6XG4gICAgICAgIGRlY29yYXRvcnMgPSB0aGlzLnBhcnNlRGVjb3JhdG9ycygpO1xuICAgICAgY2FzZSA4MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5zdGFydE5vZGUoKSksIGZhbHNlKTtcbiAgICAgIGNhc2UgNzc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTmV3T3JOZXdUYXJnZXQoKTtcbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRlbXBsYXRlKGZhbHNlKTtcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBub2RlLm9iamVjdCA9IG51bGw7XG4gICAgICAgICAgY29uc3QgY2FsbGVlID0gbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlTm9DYWxsRXhwcigpO1xuICAgICAgICAgIGlmIChjYWxsZWUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCaW5kRXhwcmVzc2lvblwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRCaW5kLCBjYWxsZWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzk6XG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBpZGVudGlmaWVyTmFtZTogdGhpcy5zdGF0ZS52YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAzMzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbig1NCwgXCIlXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDMyOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZVRoZW5FcXVhbHNTaWduKDQ0LCBcIl5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzc6XG4gICAgICBjYXNlIDM4OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShcImhhY2tcIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDQ6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSAyNzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuICAgICAgICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5uZXh0VG9rZW5TdGFydCgpKTtcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQobG9va2FoZWFkQ2gpIHx8IGxvb2thaGVhZENoID09PSA2Mikge1xuICAgICAgICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wianN4XCIsIFwiZmxvd1wiLCBcInR5cGVzY3JpcHRcIl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURlY2ltYWxMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjcpICYmIHRoaXMubG9va2FoZWFkSW5MaW5lQ2hhckNvZGUoKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1vZHVsZUV4cHJlc3Npb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY2FuQmVBcnJvdyA9IHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9PT0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICAgICAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgICAgICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICAgIGlmICghY29udGFpbnNFc2MgJiYgaWQubmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDY4KSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGlkKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jQXJyb3dVbmFyeUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDkwKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGlkKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEbyh0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLm1hdGNoKDE5KSAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCksIFtpZF0sIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbih0b3BpY1Rva2VuVHlwZSwgdG9waWNUb2tlblZhbHVlKSB7XG4gICAgY29uc3QgcGlwZVByb3Bvc2FsID0gdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJwaXBlbGluZU9wZXJhdG9yXCIsIFwicHJvcG9zYWxcIik7XG4gICAgaWYgKHBpcGVQcm9wb3NhbCkge1xuICAgICAgdGhpcy5zdGF0ZS50eXBlID0gdG9waWNUb2tlblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLnZhbHVlID0gdG9waWNUb2tlblZhbHVlO1xuICAgICAgdGhpcy5zdGF0ZS5wb3MtLTtcbiAgICAgIHRoaXMuc3RhdGUuZW5kLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmVuZExvYywgLTEpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSk7XG4gIH1cbiAgZmluaXNoVG9waWNSZWZlcmVuY2Uobm9kZSwgc3RhcnRMb2MsIHBpcGVQcm9wb3NhbCwgdG9rZW5UeXBlKSB7XG4gICAgaWYgKHRoaXMudGVzdFRvcGljUmVmZXJlbmNlQ29uZmlndXJhdGlvbihwaXBlUHJvcG9zYWwsIHN0YXJ0TG9jLCB0b2tlblR5cGUpKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IHBpcGVQcm9wb3NhbCA9PT0gXCJzbWFydFwiID8gXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiIDogXCJUb3BpY1JlZmVyZW5jZVwiO1xuICAgICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpKSB7XG4gICAgICAgIHRoaXMucmFpc2UocGlwZVByb3Bvc2FsID09PSBcInNtYXJ0XCIgPyBFcnJvcnMuUHJpbWFyeVRvcGljTm90QWxsb3dlZCA6IEVycm9ycy5QaXBlVG9waWNVbmJvdW5kLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbm9kZVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmNvbmZpZ3VyZWRUb2tlbiwgc3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW46IHRva2VuTGFiZWxOYW1lKHRva2VuVHlwZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0ZXN0VG9waWNSZWZlcmVuY2VDb25maWd1cmF0aW9uKHBpcGVQcm9wb3NhbCwgc3RhcnRMb2MsIHRva2VuVHlwZSkge1xuICAgIHN3aXRjaCAocGlwZVByb3Bvc2FsKSB7XG4gICAgICBjYXNlIFwiaGFja1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgdG9waWNUb2tlbjogdG9rZW5MYWJlbE5hbWUodG9rZW5UeXBlKVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInNtYXJ0XCI6XG4gICAgICAgIHJldHVybiB0b2tlblR5cGUgPT09IDI3O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXMsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyh0cnVlLCB0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFt0aGlzLnBhcnNlSWRlbnRpZmllcigpXTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3csIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIHRydWUpO1xuICB9XG4gIHBhcnNlRG8obm9kZSwgaXNBc3luYykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZG9FeHByZXNzaW9uc1wiKTtcbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJhc3luY0RvRXhwcmVzc2lvbnNcIik7XG4gICAgfVxuICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDIpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9FeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlU3VwZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApICYmICF0aGlzLnNjb3BlLmFsbG93RGlyZWN0U3VwZXIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3VwZXJOb3RBbGxvd2VkLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNjb3BlLmFsbG93U3VwZXIgJiYgIXRoaXMub3B0aW9ucy5hbGxvd1N1cGVyT3V0c2lkZU1ldGhvZCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFN1cGVyLCBub2RlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEwKSAmJiAhdGhpcy5tYXRjaCgwKSAmJiAhdGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkU3VwZXIsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIik7XG4gIH1cbiAgcGFyc2VQcml2YXRlTmFtZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlQXQoY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHRoaXMuc3RhdGUuc3RhcnRMb2MsIDEpKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmlkID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZU5hbWVcIik7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbk9yRnVuY3Rpb25TZW50KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCAmJiB0aGlzLm1hdGNoKDE2KSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJmdW5jdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTAzKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJzZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUpO1xuICB9XG4gIHBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIHByb3BlcnR5TmFtZSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUgfHwgY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkTWV0YVByb3BlcnR5LCBub2RlLnByb3BlcnR5LCB7XG4gICAgICAgIHRhcmdldDogbWV0YS5uYW1lLFxuICAgICAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRNZXRhUHJvcGVydHkobm9kZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpLCBcImltcG9ydFwiKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTAxKSkge1xuICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydE1ldGFPdXRzaWRlTW9kdWxlLCBpZCk7XG4gICAgICB9XG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoOTcpKSB7XG4gICAgICBjb25zdCBpc1NvdXJjZSA9IHRoaXMuaXNDb250ZXh0dWFsKDEwNSk7XG4gICAgICBpZiAoIWlzU291cmNlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKGlzU291cmNlID8gXCJzb3VyY2VQaGFzZUltcG9ydHNcIiA6IFwiZGVmZXJyZWRJbXBvcnRFdmFsdWF0aW9uXCIpO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY3JlYXRlSW1wb3J0RXhwcmVzc2lvbnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRHluYW1pY0ltcG9ydFBoYXNlUmVxdWlyZXNJbXBvcnRFeHByZXNzaW9ucywgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgIHBoYXNlOiB0aGlzLnN0YXRlLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBub2RlLnBoYXNlID0gaXNTb3VyY2UgPyBcInNvdXJjZVwiIDogXCJkZWZlclwiO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VJbXBvcnRDYWxsKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU1ldGFQcm9wZXJ0eShub2RlLCBpZCwgXCJtZXRhXCIpO1xuICB9XG4gIHBhcnNlTGl0ZXJhbEF0Tm9kZSh2YWx1ZSwgdHlwZSwgbm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKTtcbiAgfVxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiRGVjaW1hbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VSZWdFeHBMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICBub2RlLmZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlZ0V4cExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB2YWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXJyb3dIZWFkU2NvcGUoKSk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3QgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwckxpc3QgPSBbXTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydExvYztcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0TG9jO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIsIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID09PSBudWxsID8gbnVsbCA6IHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgb3B0aW9uYWxDb21tYVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoNDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCB0aGlzLnBhcnNlUGFyZW5JdGVtKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlubmVyRW5kTG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICBsZXQgYXJyb3dOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5zaG91bGRQYXJzZUFycm93KGV4cHJMaXN0KSAmJiAoYXJyb3dOb2RlID0gdGhpcy5wYXJzZUFycm93KGFycm93Tm9kZSkpKSB7XG4gICAgICB0aGlzLmNoZWNrRGVzdHJ1Y3R1cmluZ1ByaXZhdGUocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS52YWxpZGF0ZUFzUGF0dGVybigpO1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihhcnJvd05vZGUsIGV4cHJMaXN0LCBmYWxzZSk7XG4gICAgICByZXR1cm4gYXJyb3dOb2RlO1xuICAgIH1cbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgaWYgKCFleHByTGlzdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbENvbW1hU3RhcnRMb2MpIHRoaXMudW5leHBlY3RlZChvcHRpb25hbENvbW1hU3RhcnRMb2MpO1xuICAgIGlmIChzcHJlYWRTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKHNwcmVhZFN0YXJ0TG9jKTtcbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3REZWVwKGV4cHJMaXN0LCB0cnVlKTtcbiAgICBpZiAoZXhwckxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgdmFsID0gdGhpcy5zdGFydE5vZGVBdChpbm5lclN0YXJ0TG9jKTtcbiAgICAgIHZhbC5leHByZXNzaW9ucyA9IGV4cHJMaXN0O1xuICAgICAgdGhpcy5maW5pc2hOb2RlKHZhbCwgXCJTZXF1ZW5jZUV4cHJlc3Npb25cIik7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24odmFsLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy53cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIHZhbCk7XG4gIH1cbiAgd3JhcFBhcmVudGhlc2lzKHN0YXJ0TG9jLCBleHByZXNzaW9uKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuY3JlYXRlUGFyZW50aGVzaXplZEV4cHJlc3Npb25zKSB7XG4gICAgICB0aGlzLmFkZEV4dHJhKGV4cHJlc3Npb24sIFwicGFyZW50aGVzaXplZFwiLCB0cnVlKTtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlblN0YXJ0XCIsIHN0YXJ0TG9jLmluZGV4KTtcbiAgICAgIHRoaXMudGFrZVN1cnJvdW5kaW5nQ29tbWVudHMoZXhwcmVzc2lvbiwgc3RhcnRMb2MuaW5kZXgsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYy5pbmRleCk7XG4gICAgICByZXR1cm4gZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgY29uc3QgcGFyZW5FeHByZXNzaW9uID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgcGFyZW5FeHByZXNzaW9uLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocGFyZW5FeHByZXNzaW9uLCBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpO1xuICB9XG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgcmV0dXJuICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG4gIHBhcnNlQXJyb3cobm9kZSkge1xuICAgIGlmICh0aGlzLmVhdCgxOSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlTmV3T3JOZXdUYXJnZXQoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKHRoaXMuc3RhcnROb2RlQXROb2RlKG5vZGUpLCBcIm5ld1wiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgbWV0YVByb3AgPSB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIFwidGFyZ2V0XCIpO1xuICAgICAgaWYgKCF0aGlzLnNjb3BlLmluTm9uQXJyb3dGdW5jdGlvbiAmJiAhdGhpcy5zY29wZS5pbkNsYXNzICYmICF0aGlzLm9wdGlvbnMuYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZE5ld1RhcmdldCwgbWV0YVByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuICBwYXJzZU5ldyhub2RlKSB7XG4gICAgdGhpcy5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUV4cHJMaXN0KDExKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIGNvbnN0IGlzSW1wb3J0ID0gdGhpcy5tYXRjaCg4Myk7XG4gICAgY29uc3QgY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgKGNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IGNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCBjYWxsZWUpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zLCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzVGFpbCA9IHRoaXMubWF0Y2goMjQpO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzVGFpbCA/IC0xIDogLTI7XG4gICAgY29uc3QgZWxlbUVuZCA9IGVuZCArIGVuZE9mZnNldDtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKGVsZW1TdGFydCwgZWxlbUVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgZW5kT2Zmc2V0KVxuICAgIH07XG4gICAgZWxlbS50YWlsID0gaXNUYWlsO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZmluaXNoZWROb2RlLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCBlbmRPZmZzZXQpKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlVGVtcGxhdGUoaXNUYWdnZWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gICAgY29uc3QgcXVhc2lzID0gW2N1ckVsdF07XG4gICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh0aGlzLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSk7XG4gICAgICB0aGlzLnJlYWRUZW1wbGF0ZUNvbnRpbnVhdGlvbigpO1xuICAgICAgcXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb25zID0gc3Vic3RpdHV0aW9ucztcbiAgICBub2RlLnF1YXNpcyA9IHF1YXNpcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VPYmplY3RMaWtlKGNsb3NlLCBpc1BhdHRlcm4sIGlzUmVjb3JkLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGNvbnN0IHByb3BIYXNoID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUucHJvcGVydGllcyA9IFtdO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHByb3A7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlQmluZGluZ1Byb3BlcnR5KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wID0gdGhpcy5wYXJzZVByb3BlcnR5RGVmaW5pdGlvbihyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgdGhpcy5jaGVja1Byb3RvKHByb3AsIGlzUmVjb3JkLCBwcm9wSGFzaCwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWNvcmQgJiYgIXRoaXMuaXNPYmplY3RQcm9wZXJ0eShwcm9wKSAmJiBwcm9wLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRSZWNvcmRQcm9wZXJ0eSwgcHJvcCk7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGlmIChwcm9wLnNob3J0aGFuZCkge1xuICAgICAgICAgIHRoaXMuYWRkRXh0cmEocHJvcCwgXCJzaG9ydGhhbmRcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgbGV0IHR5cGUgPSBcIk9iamVjdEV4cHJlc3Npb25cIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICB0eXBlID0gXCJPYmplY3RQYXR0ZXJuXCI7XG4gICAgfSBlbHNlIGlmIChpc1JlY29yZCkge1xuICAgICAgdHlwZSA9IFwiUmVjb3JkRXhwcmVzc2lvblwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIGFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlKSB7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInRyYWlsaW5nQ29tbWFcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MuaW5kZXgpO1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hTG9jXCIsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLCBmYWxzZSk7XG4gIH1cbiAgbWF5YmVBc3luY09yQWNjZXNzb3JQcm9wKHByb3ApIHtcbiAgICByZXR1cm4gIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgKHRoaXMuaXNMaXRlcmFsUHJvcGVydHlOYW1lKCkgfHwgdGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDU1KSk7XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eURlZmluaXRpb24ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGxldCBkZWNvcmF0b3JzID0gW107XG4gICAgaWYgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkUHJvcGVydHlEZWNvcmF0b3IsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHRoaXMubWF0Y2goMjYpKSB7XG4gICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgaXNBc3luYyA9IGZhbHNlO1xuICAgIGxldCBpc0FjY2Vzc29yID0gZmFsc2U7XG4gICAgbGV0IHN0YXJ0TG9jO1xuICAgIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3ByZWFkKCk7XG4gICAgfVxuICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgcHJvcC5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICB9XG4gICAgcHJvcC5tZXRob2QgPSBmYWxzZTtcbiAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgICAgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIH1cbiAgICBsZXQgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKHByb3ApO1xuICAgIGNvbnN0IGNvbnRhaW5zRXNjID0gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICghaXNHZW5lcmF0b3IgJiYgIWNvbnRhaW5zRXNjICYmIHRoaXMubWF5YmVBc3luY09yQWNjZXNzb3JQcm9wKHByb3ApKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleVxuICAgICAgfSA9IHByb3A7XG4gICAgICBjb25zdCBrZXlOYW1lID0ga2V5Lm5hbWU7XG4gICAgICBpZiAoa2V5TmFtZSA9PT0gXCJhc3luY1wiICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgICBpc0dlbmVyYXRvciA9IHRoaXMuZWF0KDU1KTtcbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChrZXlOYW1lID09PSBcImdldFwiIHx8IGtleU5hbWUgPT09IFwic2V0XCIpIHtcbiAgICAgICAgaXNBY2Nlc3NvciA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICAgIHByb3Aua2luZCA9IGtleU5hbWU7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDU1KSkge1xuICAgICAgICAgIGlzR2VuZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5BY2Nlc3NvcklzR2VuZXJhdG9yLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgICAgIGtpbmQ6IGtleU5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBnZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gIH1cbiAgZ2V0T2JqZWN0T3JDbGFzc01ldGhvZFBhcmFtcyhtZXRob2QpIHtcbiAgICByZXR1cm4gbWV0aG9kLnBhcmFtcztcbiAgfVxuICBjaGVja0dldHRlclNldHRlclBhcmFtcyhtZXRob2QpIHtcbiAgICB2YXIgX3BhcmFtcztcbiAgICBjb25zdCBwYXJhbUNvdW50ID0gdGhpcy5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdGhpcy5yYWlzZShtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IEVycm9ycy5CYWRHZXR0ZXJBcml0eSA6IEVycm9ycy5CYWRTZXR0ZXJBcml0eSwgbWV0aG9kKTtcbiAgICB9XG4gICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmICgoX3BhcmFtcyA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBfcGFyYW1zLnR5cGUpID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIsIG1ldGhvZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHtcbiAgICBpZiAoaXNBY2Nlc3Nvcikge1xuICAgICAgY29uc3QgZmluaXNoZWRQcm9wID0gdGhpcy5wYXJzZU1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgXCJPYmplY3RNZXRob2RcIik7XG4gICAgICB0aGlzLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKGZpbmlzaGVkUHJvcCk7XG4gICAgICByZXR1cm4gZmluaXNoZWRQcm9wO1xuICAgIH1cbiAgICBpZiAoaXNBc3luYyB8fCBpc0dlbmVyYXRvciB8fCB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgaWYgKGlzUGF0dGVybikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICBwcm9wLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgcHJvcC5tZXRob2QgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJPYmplY3RNZXRob2RcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHByb3Auc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuZWF0KDE0KSkge1xuICAgICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGF0ZS5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIk9iamVjdFByb3BlcnR5XCIpO1xuICAgIH1cbiAgICBpZiAoIXByb3AuY29tcHV0ZWQgJiYgcHJvcC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQocHJvcC5rZXkubmFtZSwgcHJvcC5rZXkubG9jLnN0YXJ0LCB0cnVlLCBmYWxzZSk7XG4gICAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBjbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRoYW5kQXNzaWduTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBzaG9ydGhhbmRBc3NpZ25Mb2M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwgc2hvcnRoYW5kQXNzaWduTG9jKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgY2xvbmVJZGVudGlmaWVyKHByb3Aua2V5KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLnZhbHVlID0gY2xvbmVJZGVudGlmaWVyKHByb3Aua2V5KTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yKSB8fCB0aGlzLnBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKCFub2RlKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gdHJ1ZTtcbiAgICAgIHByb3Aua2V5ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgICBrZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMTM1OlxuICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM0OlxuICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzY6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzOTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5wcml2YXRlS2V5TG9jID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPSBwcml2YXRlS2V5TG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkUHJpdmF0ZUZpZWxkLCBwcml2YXRlS2V5TG9jKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICAgICAga2V5ID0gdGhpcy5wYXJzZURlY2ltYWxMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcC5rZXkgPSBrZXk7XG4gICAgICBpZiAodHlwZSAhPT0gMTM5KSB7XG4gICAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpIHtcbiAgICBub2RlLmlkID0gbnVsbDtcbiAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICB9XG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUgPSBmYWxzZSkge1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gaXNHZW5lcmF0b3I7XG4gICAgdGhpcy5zY29wZS5lbnRlcigyIHwgMTYgfCAoaW5DbGFzc1Njb3BlID8gNjQgOiAwKSB8IChhbGxvd0RpcmVjdFN1cGVyID8gMzIgOiAwKSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKTtcbiAgICBjb25zdCBmaW5pc2hlZE5vZGUgPSB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIHRydWUpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBjYW5CZVBhdHRlcm4sIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoaXNUdXBsZSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KGNsb3NlLCAhaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgbm9kZSk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNUdXBsZSA/IFwiVHVwbGVFeHByZXNzaW9uXCIgOiBcIkFycmF5RXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDIgfCA0KTtcbiAgICBsZXQgZmxhZ3MgPSBmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIGZhbHNlKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goNSkgJiYgdGhpcy5wcm9kUGFyYW0uaGFzSW4pIHtcbiAgICAgIGZsYWdzIHw9IDg7XG4gICAgfVxuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZsYWdzKTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIGlmIChwYXJhbXMpIHtcbiAgICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRydWU7XG4gICAgICB0aGlzLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IGZhbHNlO1xuICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChwYXJhbXMsIHRyYWlsaW5nQ29tbWFMb2MsIGZhbHNlKTtcbiAgICBub2RlLnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBmYWxzZSwgaXNNZXRob2QpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgYWxsb3dFeHByZXNzaW9uLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgaXNFeHByZXNzaW9uID0gYWxsb3dFeHByZXNzaW9uICYmICF0aGlzLm1hdGNoKDUpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0V4cHJlc3Npb25TY29wZSgpKTtcbiAgICBpZiAoaXNFeHByZXNzaW9uKSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UsIGFsbG93RXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBbXTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKHRoaXMucHJvZFBhcmFtLmN1cnJlbnRGbGFncygpIHwgNCk7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2sodHJ1ZSwgZmFsc2UsIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPT4ge1xuICAgICAgICBjb25zdCBub25TaW1wbGUgPSAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgICAgIGlmIChoYXNTdHJpY3RNb2RlRGlyZWN0aXZlICYmIG5vblNpbXBsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLklsbGVnYWxMYW5ndWFnZU1vZGVEaXJlY3RpdmUsIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIgfHwgbm9kZS5raW5kID09PSBcImNvbnN0cnVjdG9yXCIpICYmICEhbm9kZS5rZXkgPyBub2RlLmtleS5sb2MuZW5kIDogbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaWN0TW9kZUNoYW5nZWQgPSAhb2xkU3RyaWN0ICYmIHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICF0aGlzLnN0YXRlLnN0cmljdCAmJiAhYWxsb3dFeHByZXNzaW9uICYmICFpc01ldGhvZCAmJiAhbm9uU2ltcGxlLCBhbGxvd0V4cHJlc3Npb24sIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIG5vZGUuaWQpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCA2NSwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIH1cbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiO1xuICB9XG4gIGlzU2ltcGxlUGFyYW1MaXN0KHBhcmFtcykge1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYXJhbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghdGhpcy5pc1NpbXBsZVBhcmFtZXRlcihwYXJhbXNbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IHRydWUpIHtcbiAgICBjb25zdCBjaGVja0NsYXNoZXMgPSAhYWxsb3dEdXBsaWNhdGVzICYmIG5ldyBTZXQoKTtcbiAgICBjb25zdCBmb3JtYWxQYXJhbWV0ZXJzID0ge1xuICAgICAgdHlwZTogXCJGb3JtYWxQYXJhbWV0ZXJzXCJcbiAgICB9O1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2Ygbm9kZS5wYXJhbXMpIHtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKHBhcmFtLCBmb3JtYWxQYXJhbWV0ZXJzLCA1LCBjaGVja0NsYXNoZXMsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByTGlzdChjbG9zZSwgYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycywgbm9kZUZvckV4dHJhKSB7XG4gICAgY29uc3QgZWx0cyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaChjbG9zZSkpIHtcbiAgICAgICAgICBpZiAobm9kZUZvckV4dHJhKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlRm9yRXh0cmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VFeHByTGlzdEl0ZW0oYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBwYXJzZUV4cHJMaXN0SXRlbShhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzLCBhbGxvd1BsYWNlaG9sZGVyKSB7XG4gICAgbGV0IGVsdDtcbiAgICBpZiAodGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIGlmICghYWxsb3dFbXB0eSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVG9rZW4sIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSwge1xuICAgICAgICAgIHVuZXhwZWN0ZWQ6IFwiLFwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBjb25zdCBzcHJlYWROb2RlU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZVBhcmVuSXRlbSh0aGlzLnBhcnNlU3ByZWFkKHJlZkV4cHJlc3Npb25FcnJvcnMpLCBzcHJlYWROb2RlU3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgxNykpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwicGFydGlhbEFwcGxpY2F0aW9uXCIpO1xuICAgICAgaWYgKCFhbGxvd1BsYWNlaG9sZGVyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRBcmd1bWVudFBsYWNlaG9sZGVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBlbHQgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShsaWJlcmFsKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpO1xuICB9XG4gIGNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSkge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG4gIHBhcnNlSWRlbnRpZmllck5hbWUobGliZXJhbCkge1xuICAgIGxldCBuYW1lO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jLFxuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgbmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbklzS2V5d29yZCA9IHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0eXBlKTtcbiAgICBpZiAobGliZXJhbCkge1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkKSB7XG4gICAgICAgIHRoaXMucmVwbGFjZVRva2VuKDEzMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQobmFtZSwgc3RhcnRMb2MsIHRva2VuSXNLZXl3b3JkLCBmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiBuYW1lO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAod29yZC5sZW5ndGggPiAxMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNhbkJlUmVzZXJ2ZWRXb3JkKHdvcmQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjaGVja0tleXdvcmRzICYmIGlzS2V5d29yZCh3b3JkKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEtleXdvcmQsIHN0YXJ0TG9jLCB7XG4gICAgICAgIGtleXdvcmQ6IHdvcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNlcnZlZFRlc3QgPSAhdGhpcy5zdGF0ZS5zdHJpY3QgPyBpc1Jlc2VydmVkV29yZCA6IGlzQmluZGluZyA/IGlzU3RyaWN0QmluZFJlc2VydmVkV29yZCA6IGlzU3RyaWN0UmVzZXJ2ZWRXb3JkO1xuICAgIGlmIChyZXNlcnZlZFRlc3Qod29yZCwgdGhpcy5pbk1vZHVsZSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRSZXNlcnZlZFdvcmQsIHN0YXJ0TG9jLCB7XG4gICAgICAgIHJlc2VydmVkV29yZDogd29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh3b3JkID09PSBcInlpZWxkXCIpIHtcbiAgICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5ZaWVsZEJpbmRpbmdJZGVudGlmaWVyLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwiYXdhaXRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc0F3YWl0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXIsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2NvcGUuaW5TdGF0aWNCbG9jaykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jaywgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRBc3luY0Fycm93UGFyYW1ldGVyc0Vycm9yKHN0YXJ0TG9jKTtcbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwiYXJndW1lbnRzXCIpIHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmluQ2xhc3NBbmROb3RJbk5vbkFycm93RnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXJndW1lbnRzSW5DbGFzcywgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlY29yZEF3YWl0SWZBbGxvd2VkKCkge1xuICAgIGNvbnN0IGlzQXdhaXRBbGxvd2VkID0gdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQgfHwgdGhpcy5vcHRpb25zLmFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb24gJiYgIXRoaXMuc2NvcGUuaW5GdW5jdGlvbjtcbiAgICBpZiAoaXNBd2FpdEFsbG93ZWQgJiYgIXRoaXMuc2NvcGUuaW5GdW5jdGlvbikge1xuICAgICAgdGhpcy5zdGF0ZS5oYXNUb3BMZXZlbEF3YWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXdhaXRBbGxvd2VkO1xuICB9XG4gIHBhcnNlQXdhaXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyLCBub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoNTUpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PYnNvbGV0ZUF3YWl0U3Rhciwgbm9kZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zY29wZS5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgaWYgKHRoaXMuaXNBbWJpZ3VvdXNBd2FpdCgpKSB7XG4gICAgICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGUuc29sb0F3YWl0KSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgaXNBbWJpZ3VvdXNBd2FpdCgpIHtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkgcmV0dXJuIHRydWU7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHJldHVybiB0eXBlID09PSA1MyB8fCB0eXBlID09PSAxMCB8fCB0eXBlID09PSAwIHx8IHRva2VuSXNUZW1wbGF0ZSh0eXBlKSB8fCB0eXBlID09PSAxMDIgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgfHwgdHlwZSA9PT0gMTM4IHx8IHR5cGUgPT09IDU2IHx8IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgJiYgdHlwZSA9PT0gNTQ7XG4gIH1cbiAgcGFyc2VZaWVsZCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5yZWNvcmRQYXJhbWV0ZXJJbml0aWFsaXplckVycm9yKEVycm9ycy5ZaWVsZEluUGFyYW1ldGVyLCBub2RlKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBsZXQgZGVsZWdhdGluZyA9IGZhbHNlO1xuICAgIGxldCBhcmd1bWVudCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICBkZWxlZ2F0aW5nID0gdGhpcy5lYXQoNTUpO1xuICAgICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgY2FzZSAxNDA6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgaWYgKCFkZWxlZ2F0aW5nKSBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLmRlbGVnYXRlID0gZGVsZWdhdGluZztcbiAgICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUltcG9ydENhbGwobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICBub2RlLm9wdGlvbnMgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxMikgJiYgIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpO1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxBcml0eSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpO1xuICB9XG4gIGNoZWNrUGlwZWxpbmVBdEluZml4T3BlcmF0b3IobGVmdCwgbGVmdFN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgcHJvcG9zYWw6IFwic21hcnRcIlxuICAgIH1dKSkge1xuICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlbGluZUhlYWRTZXF1ZW5jZUV4cHJlc3Npb24sIGxlZnRTdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlU21hcnRQaXBlbGluZUJvZHlJblN0eWxlKGNoaWxkRXhwciwgc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5pc1NpbXBsZVJlZmVyZW5jZShjaGlsZEV4cHIpKSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgYm9keU5vZGUuY2FsbGVlID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIHRoaXMuY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYyk7XG4gICAgICBib2R5Tm9kZS5leHByZXNzaW9uID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbikge1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uY29tcHV0ZWQgJiYgdGhpcy5pc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uLm9iamVjdCk7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDE5KSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZWxpbmVCb2R5Tm9BcnJvdywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lVG9waWNVbnVzZWQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgd2l0aFRvcGljQmluZGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRUb3BpY1N0YXRlID0gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDEsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICB9XG4gIH1cbiAgd2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcInNtYXJ0XCJcbiAgICB9XSkpIHtcbiAgICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0ge1xuICAgICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIHdpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFNvbG9Bd2FpdFN0YXRlID0gdGhpcy5zdGF0ZS5zb2xvQXdhaXQ7XG4gICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZTtcbiAgICB9XG4gIH1cbiAgYWxsb3dJbkFuZChjYWxsYmFjaykge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCk7XG4gICAgY29uc3QgcHJvZFBhcmFtVG9TZXQgPSA4ICYgfmZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub1NldCkge1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZmxhZ3MgfCA4KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICBkaXNhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub0NsZWFyID0gOCAmIGZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub0NsZWFyKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyAmIH44KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICByZWdpc3RlclRvcGljUmVmZXJlbmNlKCkge1xuICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPSAwO1xuICB9XG4gIHRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzID49IDE7XG4gIH1cbiAgdG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCAhPSBudWxsICYmIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPj0gMDtcbiAgfVxuICBwYXJzZUZTaGFycFBpcGVsaW5lQm9keShwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0cnVlO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUoKSwgc3RhcnRMb2MsIHByZWMpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHBhcnNlTW9kdWxlRXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm1vZHVsZUJsb2Nrc1wiKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5lbmRMb2MpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IHJldmVydFNjb3BlcyA9IHRoaXMuaW5pdGlhbGl6ZVNjb3Blcyh0cnVlKTtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIHRyeSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUHJvZ3JhbShwcm9ncmFtLCA4LCBcIm1vZHVsZVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmV2ZXJ0U2NvcGVzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNb2R1bGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlUHJvcGVydHlOYW1lUHJlZml4T3BlcmF0b3IocHJvcCkge31cbn1cbmNvbnN0IGxvb3BMYWJlbCA9IHtcbiAgICBraW5kOiAxXG4gIH0sXG4gIHN3aXRjaExhYmVsID0ge1xuICAgIGtpbmQ6IDJcbiAgfTtcbmNvbnN0IGxvbmVTdXJyb2dhdGUgPSAvW1xcdUQ4MDAtXFx1REZGRl0vdTtcbmNvbnN0IGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IgPSAvaW4oPzpzdGFuY2VvZik/L3k7XG5mdW5jdGlvbiBiYWJlbDdDb21wYXRUb2tlbnModG9rZW5zLCBpbnB1dCwgc3RhcnRJbmRleCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdG9rZW47XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlID09PSAxMzkpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBsb2MsXG4gICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZW5kXG4gICAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICAgIGNvbnN0IGhhc2hFbmRQb3MgPSBzdGFydCArIDE7XG4gICAgICAgICAgY29uc3QgaGFzaEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2Muc3RhcnQsIDEpO1xuICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSwgbmV3IFRva2VuKHtcbiAgICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjcpLFxuICAgICAgICAgICAgdmFsdWU6IFwiI1wiLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBoYXNoRW5kUG9zLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgIGVuZExvYzogaGFzaEVuZExvY1xuICAgICAgICAgIH0pLCBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigxMzIpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IGhhc2hFbmRQb3MsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiBoYXNoRW5kTG9jLFxuICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHR5cGUpKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbG9jLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGVuZFxuICAgICAgICAgIH0gPSB0b2tlbjtcbiAgICAgICAgICBjb25zdCBiYWNrcXVvdGVFbmQgPSBzdGFydCArIDE7XG4gICAgICAgICAgY29uc3QgYmFja3F1b3RlRW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5zdGFydCwgMSk7XG4gICAgICAgICAgbGV0IHN0YXJ0VG9rZW47XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQoc3RhcnQgLSBzdGFydEluZGV4KSA9PT0gOTYpIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgICAgdmFsdWU6IFwiYFwiLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgICBlbmRMb2M6IGJhY2txdW90ZUVuZExvY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0VG9rZW4gPSBuZXcgVG9rZW4oe1xuICAgICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDgpLFxuICAgICAgICAgICAgICB2YWx1ZTogXCJ9XCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jOiBsb2Muc3RhcnQsXG4gICAgICAgICAgICAgIGVuZExvYzogYmFja3F1b3RlRW5kTG9jXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHRlbXBsYXRlVmFsdWUsIHRlbXBsYXRlRWxlbWVudEVuZCwgdGVtcGxhdGVFbGVtZW50RW5kTG9jLCBlbmRUb2tlbjtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gMjQpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZCA9IGVuZCAtIDE7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLmVuZCwgLTEpO1xuICAgICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgIGVuZFRva2VuID0gbmV3IFRva2VuKHtcbiAgICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigyMiksXG4gICAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgICAgc3RhcnQ6IHRlbXBsYXRlRWxlbWVudEVuZCxcbiAgICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICAgIHN0YXJ0TG9jOiB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsXG4gICAgICAgICAgICAgIGVuZExvYzogbG9jLmVuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZCA9IGVuZCAtIDI7XG4gICAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLmVuZCwgLTIpO1xuICAgICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0yKTtcbiAgICAgICAgICAgIGVuZFRva2VuID0gbmV3IFRva2VuKHtcbiAgICAgICAgICAgICAgdHlwZTogZ2V0RXhwb3J0ZWRUb2tlbigyMyksXG4gICAgICAgICAgICAgIHZhbHVlOiBcIiR7XCIsXG4gICAgICAgICAgICAgIHN0YXJ0OiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICBzdGFydExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jLFxuICAgICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b2tlbnMuc3BsaWNlKGksIDEsIHN0YXJ0VG9rZW4sIG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIwKSxcbiAgICAgICAgICAgIHZhbHVlOiB0ZW1wbGF0ZVZhbHVlLFxuICAgICAgICAgICAgc3RhcnQ6IGJhY2txdW90ZUVuZCxcbiAgICAgICAgICAgIGVuZDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGJhY2txdW90ZUVuZExvYyxcbiAgICAgICAgICAgIGVuZExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jXG4gICAgICAgICAgfSksIGVuZFRva2VuKTtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRva2VuLnR5cGUgPSBnZXRFeHBvcnRlZFRva2VuKHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9rZW5zO1xufVxuY2xhc3MgU3RhdGVtZW50UGFyc2VyIGV4dGVuZHMgRXhwcmVzc2lvblBhcnNlciB7XG4gIHBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSkge1xuICAgIGZpbGUucHJvZ3JhbSA9IHRoaXMucGFyc2VQcm9ncmFtKHByb2dyYW0pO1xuICAgIGZpbGUuY29tbWVudHMgPSB0aGlzLmNvbW1lbnRzO1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG9rZW5zKSB7XG4gICAgICBmaWxlLnRva2VucyA9IGJhYmVsN0NvbXBhdFRva2Vucyh0aGlzLnRva2VucywgdGhpcy5pbnB1dCwgdGhpcy5zdGFydEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShmaWxlLCBcIkZpbGVcIik7XG4gIH1cbiAgcGFyc2VQcm9ncmFtKHByb2dyYW0sIGVuZCA9IDE0MCwgc291cmNlVHlwZSA9IHRoaXMub3B0aW9ucy5zb3VyY2VUeXBlKSB7XG4gICAgcHJvZ3JhbS5zb3VyY2VUeXBlID0gc291cmNlVHlwZTtcbiAgICBwcm9ncmFtLmludGVycHJldGVyID0gdGhpcy5wYXJzZUludGVycHJldGVyRGlyZWN0aXZlKCk7XG4gICAgdGhpcy5wYXJzZUJsb2NrQm9keShwcm9ncmFtLCB0cnVlLCB0cnVlLCBlbmQpO1xuICAgIGlmICh0aGlzLmluTW9kdWxlKSB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd1VuZGVjbGFyZWRFeHBvcnRzICYmIHRoaXMuc2NvcGUudW5kZWZpbmVkRXhwb3J0cy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtsb2NhbE5hbWUsIGF0XSBvZiBBcnJheS5mcm9tKHRoaXMuc2NvcGUudW5kZWZpbmVkRXhwb3J0cykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVFeHBvcnRVbmRlZmluZWQsIGF0LCB7XG4gICAgICAgICAgICBsb2NhbE5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hZGRFeHRyYShwcm9ncmFtLCBcInRvcExldmVsQXdhaXRcIiwgdGhpcy5zdGF0ZS5oYXNUb3BMZXZlbEF3YWl0KTtcbiAgICB9XG4gICAgbGV0IGZpbmlzaGVkUHJvZ3JhbTtcbiAgICBpZiAoZW5kID09PSAxNDApIHtcbiAgICAgIGZpbmlzaGVkUHJvZ3JhbSA9IHRoaXMuZmluaXNoTm9kZShwcm9ncmFtLCBcIlByb2dyYW1cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmlzaGVkUHJvZ3JhbSA9IHRoaXMuZmluaXNoTm9kZUF0KHByb2dyYW0sIFwiUHJvZ3JhbVwiLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5zdGFydExvYywgLTEpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaGVkUHJvZ3JhbTtcbiAgfVxuICBzdG10VG9EaXJlY3RpdmUoc3RtdCkge1xuICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHN0bXQ7XG4gICAgZGlyZWN0aXZlLnR5cGUgPSBcIkRpcmVjdGl2ZVwiO1xuICAgIGRpcmVjdGl2ZS52YWx1ZSA9IGRpcmVjdGl2ZS5leHByZXNzaW9uO1xuICAgIGRlbGV0ZSBkaXJlY3RpdmUuZXhwcmVzc2lvbjtcbiAgICBjb25zdCBkaXJlY3RpdmVMaXRlcmFsID0gZGlyZWN0aXZlLnZhbHVlO1xuICAgIGNvbnN0IGV4cHJlc3Npb25WYWx1ZSA9IGRpcmVjdGl2ZUxpdGVyYWwudmFsdWU7XG4gICAgY29uc3QgcmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGRpcmVjdGl2ZUxpdGVyYWwuc3RhcnQpLCB0aGlzLm9mZnNldFRvU291cmNlUG9zKGRpcmVjdGl2ZUxpdGVyYWwuZW5kKSk7XG4gICAgY29uc3QgdmFsID0gZGlyZWN0aXZlTGl0ZXJhbC52YWx1ZSA9IHJhdy5zbGljZSgxLCAtMSk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1wiLCByYXcpO1xuICAgIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJyYXdWYWx1ZVwiLCB2YWwpO1xuICAgIHRoaXMuYWRkRXh0cmEoZGlyZWN0aXZlTGl0ZXJhbCwgXCJleHByZXNzaW9uVmFsdWVcIiwgZXhwcmVzc2lvblZhbHVlKTtcbiAgICBkaXJlY3RpdmVMaXRlcmFsLnR5cGUgPSBcIkRpcmVjdGl2ZUxpdGVyYWxcIjtcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xuICB9XG4gIHBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDI4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKTtcbiAgfVxuICBpc0xldCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKTtcbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIGlmIChrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QodGhpcy5pbnB1dCkpIHtcbiAgICAgICAgY29uc3QgZW5kQ2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSA5MSB8fCBjaCA9PT0gMTIzO1xuICB9XG4gIGhhc0ZvbGxvd2luZ0JpbmRpbmdBdG9tKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKG5leHRDaCkgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgaGFzSW5MaW5lRm9sbG93aW5nQmluZGluZ0lkZW50aWZpZXJPckJyYWNlKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gbmV4dENoID09PSAxMjMgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgc3RhcnRzVXNpbmdGb3JPZigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgY29udGFpbnNFc2NcbiAgICB9ID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICBpZiAodHlwZSA9PT0gMTAyICYmICFjb250YWluc0VzYykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgJiYgIXRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwbGljaXRSZXNvdXJjZU1hbmFnZW1lbnRcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgc3RhcnRzQXdhaXRVc2luZygpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInVzaW5nXCIpKSB7XG4gICAgICBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKG5leHQgKyA1KTtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJleHBsaWNpdFJlc291cmNlTWFuYWdlbWVudFwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZU1vZHVsZUl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDEgfCAyIHwgNCB8IDgpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDIgfCA0IHwgKCF0aGlzLm9wdGlvbnMuYW5uZXhCIHx8IHRoaXMuc3RhdGUuc3RyaWN0ID8gMCA6IDgpKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbihhbGxvd0xhYmVsZWRGdW5jdGlvbiA9IGZhbHNlKSB7XG4gICAgbGV0IGZsYWdzID0gMDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmFubmV4QiAmJiAhdGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIGZsYWdzIHw9IDQ7XG4gICAgICBpZiAoYWxsb3dMYWJlbGVkRnVuY3Rpb24pIHtcbiAgICAgICAgZmxhZ3MgfD0gODtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudExpa2UoMCk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKSB7XG4gICAgbGV0IGRlY29yYXRvcnMgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgZGVjb3JhdG9ycyA9IHRoaXMucGFyc2VEZWNvcmF0b3JzKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50Q29udGVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0VHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBhbGxvd0RlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiAyKTtcbiAgICBjb25zdCBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24gPSAhIShmbGFncyAmIDQpO1xuICAgIGNvbnN0IHRvcExldmVsID0gZmxhZ3MgJiAxO1xuICAgIHN3aXRjaCAoc3RhcnRUeXBlKSB7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgdHJ1ZSk7XG4gICAgICBjYXNlIDYzOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgZmFsc2UpO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgOTE6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA2ODpcbiAgICAgICAgaWYgKHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDYpIGJyZWFrO1xuICAgICAgICBpZiAoIWFsbG93RnVuY3Rpb25EZWNsYXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2UodGhpcy5zdGF0ZS5zdHJpY3QgPyBFcnJvcnMuU3RyaWN0RnVuY3Rpb24gOiB0aGlzLm9wdGlvbnMuYW5uZXhCID8gRXJyb3JzLlNsb3BweUZ1bmN0aW9uQW5uZXhCIDogRXJyb3JzLlNsb3BweUZ1bmN0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlLCAhYWxsb3dEZWNsYXJhdGlvbiAmJiBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgY2FzZSA4MDpcbiAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgbm9kZSksIHRydWUpO1xuICAgICAgY2FzZSA2OTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDcyOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRocm93U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUcnlTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDk2OlxuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdGhpcy5zdGFydHNBd2FpdFVzaW5nKCkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0LCBub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJhd2FpdCB1c2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA3OlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYyB8fCAhdGhpcy5oYXNJbkxpbmVGb2xsb3dpbmdCaW5kaW5nSWRlbnRpZmllck9yQnJhY2UoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwbGljaXRSZXNvdXJjZU1hbmFnZW1lbnRcIik7XG4gICAgICAgIGlmICghdGhpcy5zY29wZS5pbk1vZHVsZSAmJiB0aGlzLnNjb3BlLmluVG9wTGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcInVzaW5nXCIpO1xuICAgICAgY2FzZSAxMDA6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICAgICAgICBpZiAobmV4dENoICE9PSA5MSkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uICYmIHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIGJyZWFrO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoLCBuZXh0KSAmJiBuZXh0Q2ggIT09IDEyMykge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzU6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA3NDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDkyOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3NjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHRUb2tlbkNoYXJDb2RlID0gdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpO1xuICAgICAgICAgIGlmIChuZXh0VG9rZW5DaGFyQ29kZSA9PT0gNDAgfHwgbmV4dFRva2VuQ2hhckNvZGUgPT09IDQ2KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgODI6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUgJiYgIXRvcExldmVsKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkSW1wb3J0RXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICBpZiAoc3RhcnRUeXBlID09PSA4Mykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUltcG9ydChub2RlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiICYmICghcmVzdWx0LmltcG9ydEtpbmQgfHwgcmVzdWx0LmltcG9ydEtpbmQgPT09IFwidmFsdWVcIikpIHtcbiAgICAgICAgICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmICghcmVzdWx0LmV4cG9ydEtpbmQgfHwgcmVzdWx0LmV4cG9ydEtpbmQgPT09IFwidmFsdWVcIikgfHwgcmVzdWx0LnR5cGUgPT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiAmJiAoIXJlc3VsdC5leHBvcnRLaW5kIHx8IHJlc3VsdC5leHBvcnRLaW5kID09PSBcInZhbHVlXCIpIHx8IHJlc3VsdC50eXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKHJlc3VsdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICAgICAgICBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgdHJ1ZSwgIWFsbG93RGVjbGFyYXRpb24gJiYgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWF5YmVOYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIoc3RhcnRUeXBlKSAmJiBleHByLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHRoaXMuZWF0KDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgZmxhZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5hbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmUgJiYgIXRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydE91dHNpZGVNb2R1bGUsIG5vZGUpO1xuICAgIH1cbiAgfVxuICBkZWNvcmF0b3JzRW5hYmxlZEJlZm9yZUV4cG9ydCgpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzLWxlZ2FjeVwiKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpICE9PSBmYWxzZTtcbiAgfVxuICBtYXliZVRha2VEZWNvcmF0b3JzKG1heWJlRGVjb3JhdG9ycywgY2xhc3NOb2RlLCBleHBvcnROb2RlKSB7XG4gICAgaWYgKG1heWJlRGVjb3JhdG9ycykge1xuICAgICAgaWYgKGNsYXNzTm9kZS5kZWNvcmF0b3JzICYmIGNsYXNzTm9kZS5kZWNvcmF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvcnNCZWZvcmVBZnRlckV4cG9ydCwgY2xhc3NOb2RlLmRlY29yYXRvcnNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTm9kZS5kZWNvcmF0b3JzLnVuc2hpZnQoLi4ubWF5YmVEZWNvcmF0b3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzTm9kZS5kZWNvcmF0b3JzID0gbWF5YmVEZWNvcmF0b3JzO1xuICAgICAgfVxuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShjbGFzc05vZGUsIG1heWJlRGVjb3JhdG9yc1swXSk7XG4gICAgICBpZiAoZXhwb3J0Tm9kZSkgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShleHBvcnROb2RlLCBjbGFzc05vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOb2RlO1xuICB9XG4gIGNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDgwKTtcbiAgfVxuICBwYXJzZURlY29yYXRvcnMoYWxsb3dFeHBvcnQpIHtcbiAgICBjb25zdCBkZWNvcmF0b3JzID0gW107XG4gICAgZG8ge1xuICAgICAgZGVjb3JhdG9ycy5wdXNoKHRoaXMucGFyc2VEZWNvcmF0b3IoKSk7XG4gICAgfSB3aGlsZSAodGhpcy5tYXRjaCgyNikpO1xuICAgIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgaWYgKCFhbGxvd0V4cG9ydCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5kZWNvcmF0b3JzRW5hYmxlZEJlZm9yZUV4cG9ydCgpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckV4cG9ydENsYXNzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZWFkaW5nRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRvcnM7XG4gIH1cbiAgcGFyc2VEZWNvcmF0b3IoKSB7XG4gICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnMtbGVnYWN5XCJdKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpKSB7XG4gICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICBsZXQgZXhwcjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICBleHByID0gdGhpcy53cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHIpO1xuICAgICAgICBjb25zdCBwYXJhbXNTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByKTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImFsbG93Q2FsbFBhcmVudGhlc2l6ZWRcIikgPT09IGZhbHNlICYmIG5vZGUuZXhwcmVzc2lvbiAhPT0gZXhwcikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckFyZ3VtZW50c091dHNpZGVQYXJlbnRoZXNlcywgcGFyYW1zU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleHByID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoZmFsc2UpO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUub2JqZWN0ID0gZXhwcjtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMzkpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICAgIGV4cHIgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNvcmF0b3JcIik7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByKSB7XG4gICAgaWYgKHRoaXMuZWF0KDEwKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGV4cHIpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBleHByO1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoMTEpO1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGlzQnJlYWspIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIG5vZGUubGFiZWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmxhYmVsID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHRoaXMudmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpO1xuICB9XG4gIHZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhaykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgbGFiID0gdGhpcy5zdGF0ZS5sYWJlbHNbaV07XG4gICAgICBpZiAobm9kZS5sYWJlbCA9PSBudWxsIHx8IGxhYi5uYW1lID09PSBub2RlLmxhYmVsLm5hbWUpIHtcbiAgICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubGFiZWwgJiYgaXNCcmVhaykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBpc0JyZWFrID8gXCJCcmVha1N0YXRlbWVudFwiIDogXCJDb250aW51ZVN0YXRlbWVudFwiO1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSWxsZWdhbEJyZWFrQ29udGludWUsIG5vZGUsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlSGVhZGVyRXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgY29uc3QgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBwYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICB0aGlzLmV4cGVjdCg5Mik7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICB0aGlzLmVhdCgxMyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VGb3JTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBsZXQgYXdhaXRBdCA9IG51bGw7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDk2KSAmJiB0aGlzLnJlY29yZEF3YWl0SWZBbGxvd2VkKCkpIHtcbiAgICAgIGF3YWl0QXQgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZW50ZXIoMCk7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGlmICh0aGlzLm1hdGNoKDEzKSkge1xuICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0c1dpdGhMZXQgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDApO1xuICAgIHtcbiAgICAgIGNvbnN0IHN0YXJ0c1dpdGhBd2FpdFVzaW5nID0gdGhpcy5pc0NvbnRleHR1YWwoOTYpICYmIHRoaXMuc3RhcnRzQXdhaXRVc2luZygpO1xuICAgICAgY29uc3Qgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbiA9IHN0YXJ0c1dpdGhBd2FpdFVzaW5nIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwNykgJiYgdGhpcy5zdGFydHNVc2luZ0Zvck9mKCk7XG4gICAgICBjb25zdCBpc0xldE9yVXNpbmcgPSBzdGFydHNXaXRoTGV0ICYmIHRoaXMuaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKSB8fCBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNzUpIHx8IGlzTGV0T3JVc2luZykge1xuICAgICAgICBjb25zdCBpbml0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGxldCBraW5kO1xuICAgICAgICBpZiAoc3RhcnRzV2l0aEF3YWl0VXNpbmcpIHtcbiAgICAgICAgICBraW5kID0gXCJhd2FpdCB1c2luZ1wiO1xuICAgICAgICAgIGlmICghdGhpcy5yZWNvcmRBd2FpdElmQWxsb3dlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgdGhpcy5wYXJzZVZhcihpbml0Tm9kZSwgdHJ1ZSwga2luZCk7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmZpbmlzaE5vZGUoaW5pdE5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgICAgICAgY29uc3QgaXNGb3JJbiA9IHRoaXMubWF0Y2goNTgpO1xuICAgICAgICBpZiAoaXNGb3JJbiAmJiBzdGFyc1dpdGhVc2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9ySW5Vc2luZywgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpc0ZvckluIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwMikpICYmIGluaXQuZGVjbGFyYXRpb25zLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0c1dpdGhBc3luYyA9IHRoaXMuaXNDb250ZXh0dWFsKDk1KTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgY29uc3QgaXNGb3JPZiA9IHRoaXMuaXNDb250ZXh0dWFsKDEwMik7XG4gICAgaWYgKGlzRm9yT2YpIHtcbiAgICAgIGlmIChzdGFydHNXaXRoTGV0KSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvck9mTGV0LCBpbml0KTtcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdEF0ID09PSBudWxsICYmIHN0YXJ0c1dpdGhBc3luYyAmJiBpbml0LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvck9mQXN5bmMsIGluaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGb3JPZiB8fCB0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgdGhpcy5jaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCwgdHJ1ZSk7XG4gICAgICBjb25zdCB0eXBlID0gaXNGb3JPZiA/IFwiRm9yT2ZTdGF0ZW1lbnRcIiA6IFwiRm9ySW5TdGF0ZW1lbnRcIjtcbiAgICAgIHRoaXMuY2hlY2tMVmFsKGluaXQsIHtcbiAgICAgICAgdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3Iobm9kZSwgaW5pdCk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBpc0FzeW5jLCBpc0hhbmdpbmdEZWNsYXJhdGlvbikge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgMSB8IChpc0hhbmdpbmdEZWNsYXJhdGlvbiA/IDIgOiAwKSB8IChpc0FzeW5jID8gOCA6IDApKTtcbiAgfVxuICBwYXJzZUlmU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMuZWF0KDY2KSA/IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKSA6IG51bGw7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIklmU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAoIXRoaXMucHJvZFBhcmFtLmhhc1JldHVybiAmJiAhdGhpcy5vcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsUmV0dXJuLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmV0dXJuU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmRpc2NyaW1pbmFudCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgY29uc3QgY2FzZXMgPSBub2RlLmNhc2VzID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChzd2l0Y2hMYWJlbCk7XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICBsZXQgY3VyO1xuICAgIGZvciAobGV0IHNhd0RlZmF1bHQ7ICF0aGlzLm1hdGNoKDgpOykge1xuICAgICAgaWYgKHRoaXMubWF0Y2goNjEpIHx8IHRoaXMubWF0Y2goNjUpKSB7XG4gICAgICAgIGNvbnN0IGlzQ2FzZSA9IHRoaXMubWF0Y2goNjEpO1xuICAgICAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgICAgIGNhc2VzLnB1c2goY3VyID0gdGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGN1ci5jb25zZXF1ZW50ID0gW107XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgICAgY3VyLnRlc3QgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzYXdEZWZhdWx0KSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5NdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2gsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgY3VyLnRlc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXIpIHtcbiAgICAgICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoY3VyKSB0aGlzLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVRocm93U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTmV3bGluZUFmdGVyVGhyb3csIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgfVxuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRocm93U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpIHtcbiAgICBjb25zdCBwYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIodGhpcy5vcHRpb25zLmFubmV4QiAmJiBwYXJhbS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IDggOiAwKTtcbiAgICB0aGlzLmNoZWNrTFZhbChwYXJhbSwge1xuICAgICAgdHlwZTogXCJDYXRjaENsYXVzZVwiXG4gICAgfSwgOSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmJsb2NrID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgbm9kZS5oYW5kbGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg2MikpIHtcbiAgICAgIGNvbnN0IGNsYXVzZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VDYXRjaENsYXVzZVBhcmFtKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXVzZS5wYXJhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMCk7XG4gICAgICB9XG4gICAgICBjbGF1c2UuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlQmxvY2soZmFsc2UsIGZhbHNlKSk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gICAgfVxuICAgIG5vZGUuZmluYWxpemVyID0gdGhpcy5lYXQoNjcpID8gdGhpcy5wYXJzZUJsb2NrKCkgOiBudWxsO1xuICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTm9DYXRjaE9yRmluYWxseSwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIobm9kZSwgZmFsc2UsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO1xuICB9XG4gIHBhcnNlV2hpbGVTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUudGVzdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0V2l0aCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub2JqZWN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2l0aFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUVtcHR5U3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG1heWJlTmFtZSwgZXhwciwgZmxhZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGxhYmVsIG9mIHRoaXMuc3RhdGUubGFiZWxzKSB7XG4gICAgICBpZiAobGFiZWwubmFtZSA9PT0gbWF5YmVOYW1lKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxhYmVsUmVkZWNsYXJhdGlvbiwgZXhwciwge1xuICAgICAgICAgIGxhYmVsTmFtZTogbWF5YmVOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBraW5kID0gdG9rZW5Jc0xvb3AodGhpcy5zdGF0ZS50eXBlKSA/IDEgOiB0aGlzLm1hdGNoKDcxKSA/IDIgOiBudWxsO1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlLmxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChsYWJlbC5zdGF0ZW1lbnRTdGFydCA9PT0gbm9kZS5zdGFydCkge1xuICAgICAgICBsYWJlbC5zdGF0ZW1lbnRTdGFydCA9IHRoaXMuc291cmNlVG9PZmZzZXRQb3ModGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgICAgIGxhYmVsLmtpbmQgPSBraW5kO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2goe1xuICAgICAgbmFtZTogbWF5YmVOYW1lLFxuICAgICAga2luZDoga2luZCxcbiAgICAgIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpXG4gICAgfSk7XG4gICAgbm9kZS5ib2R5ID0gZmxhZ3MgJiA4ID8gdGhpcy5wYXJzZVN0YXRlbWVudE9yU2xvcHB5QW5uZXhCRnVuY3Rpb25EZWNsYXJhdGlvbih0cnVlKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICBub2RlLmxhYmVsID0gZXhwcjtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgZXhwciwgZGVjb3JhdG9ycykge1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcyA9IGZhbHNlLCBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAoYWxsb3dEaXJlY3RpdmVzKSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAoY3JlYXRlTmV3TGV4aWNhbFNjb3BlKSB7XG4gICAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgZmFsc2UsIDgsIGFmdGVyQmxvY2tQYXJzZSk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKTtcbiAgfVxuICBpc1ZhbGlkRGlyZWN0aXZlKHN0bXQpIHtcbiAgICByZXR1cm4gc3RtdC50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiAmJiBzdG10LmV4cHJlc3Npb24udHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgIXN0bXQuZXhwcmVzc2lvbi5leHRyYS5wYXJlbnRoZXNpemVkO1xuICB9XG4gIHBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3QgYm9keSA9IG5vZGUuYm9keSA9IFtdO1xuICAgIGNvbnN0IGRpcmVjdGl2ZXMgPSBub2RlLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICB0aGlzLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBhbGxvd0RpcmVjdGl2ZXMgPyBkaXJlY3RpdmVzIDogdW5kZWZpbmVkLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpO1xuICB9XG4gIHBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShib2R5LCBkaXJlY3RpdmVzLCB0b3BMZXZlbCwgZW5kLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBsZXQgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9IGZhbHNlO1xuICAgIGxldCBwYXJzZWROb25EaXJlY3RpdmUgPSBmYWxzZTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kKSkge1xuICAgICAgY29uc3Qgc3RtdCA9IHRvcExldmVsID8gdGhpcy5wYXJzZU1vZHVsZUl0ZW0oKSA6IHRoaXMucGFyc2VTdGF0ZW1lbnRMaXN0SXRlbSgpO1xuICAgICAgaWYgKGRpcmVjdGl2ZXMgJiYgIXBhcnNlZE5vbkRpcmVjdGl2ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRGlyZWN0aXZlKHN0bXQpKSB7XG4gICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5zdG10VG9EaXJlY3RpdmUoc3RtdCk7XG4gICAgICAgICAgZGlyZWN0aXZlcy5wdXNoKGRpcmVjdGl2ZSk7XG4gICAgICAgICAgaWYgKCFoYXNTdHJpY3RNb2RlRGlyZWN0aXZlICYmIGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgICAgIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHJpY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZE5vbkRpcmVjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgICBib2R5LnB1c2goc3RtdCk7XG4gICAgfVxuICAgIGFmdGVyQmxvY2tQYXJzZSA9PSBudWxsIHx8IGFmdGVyQmxvY2tQYXJzZS5jYWxsKHRoaXMsIGhhc1N0cmljdE1vZGVEaXJlY3RpdmUpO1xuICAgIGlmICghb2xkU3RyaWN0KSB7XG4gICAgICB0aGlzLnNldFN0cmljdChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICB9XG4gIHBhcnNlRm9yKG5vZGUsIGluaXQpIHtcbiAgICBub2RlLmluaXQgPSBpbml0O1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLm1hdGNoKDEzKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKGZhbHNlKTtcbiAgICBub2RlLnVwZGF0ZSA9IHRoaXMubWF0Y2goMTEpID8gbnVsbCA6IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGb3JTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KSB7XG4gICAgY29uc3QgaXNGb3JJbiA9IHRoaXMubWF0Y2goNTgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmIChpc0ZvckluKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF3YWl0ID0gYXdhaXRBdCAhPT0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaW5pdCAhPSBudWxsICYmICghaXNGb3JJbiB8fCAhdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBpbml0LmtpbmQgIT09IFwidmFyXCIgfHwgaW5pdC5kZWNsYXJhdGlvbnNbMF0uaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JJbk9mTG9vcEluaXRpYWxpemVyLCBpbml0LCB7XG4gICAgICAgIHR5cGU6IGlzRm9ySW4gPyBcIkZvckluU3RhdGVtZW50XCIgOiBcIkZvck9mU3RhdGVtZW50XCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW5pdC50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHMsIGluaXQsIHtcbiAgICAgICAgYW5jZXN0b3I6IHtcbiAgICAgICAgICB0eXBlOiBcIkZvclN0YXRlbWVudFwiXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBub2RlLmxlZnQgPSBpbml0O1xuICAgIG5vZGUucmlnaHQgPSBpc0ZvckluID8gdGhpcy5wYXJzZUV4cHJlc3Npb24oKSA6IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVZhcihub2RlLCBpc0Zvciwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgPSBmYWxzZSkge1xuICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IG5vZGUuZGVjbGFyYXRpb25zID0gW107XG4gICAgbm9kZS5raW5kID0ga2luZDtcbiAgICBmb3IgKDs7KSB7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICAgIGRlY2wuaW5pdCA9ICF0aGlzLmVhdCgyOSkgPyBudWxsIDogaXNGb3IgPyB0aGlzLnBhcnNlTWF5YmVBc3NpZ25EaXNhbGxvd0luKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICBpZiAoZGVjbC5pbml0ID09PSBudWxsICYmICFhbGxvd01pc3NpbmdJbml0aWFsaXplcikge1xuICAgICAgICBpZiAoZGVjbC5pZC50eXBlICE9PSBcIklkZW50aWZpZXJcIiAmJiAhKGlzRm9yICYmICh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCB7XG4gICAgICAgICAgICBraW5kOiBcImRlc3RydWN0dXJpbmdcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChraW5kID09PSBcImNvbnN0XCIgfHwga2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikgJiYgISh0aGlzLm1hdGNoKDU4KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MsIHtcbiAgICAgICAgICAgIGtpbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVjbGFyYXRpb25zLnB1c2godGhpcy5maW5pc2hOb2RlKGRlY2wsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKTtcbiAgICAgIGlmICghdGhpcy5lYXQoMTIpKSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoa2luZCA9PT0gXCJ1c2luZ1wiIHx8IGtpbmQgPT09IFwiYXdhaXQgdXNpbmdcIikge1xuICAgICAgaWYgKGlkLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgaWQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuLCBpZC5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNoZWNrTFZhbChpZCwge1xuICAgICAgdHlwZTogXCJWYXJpYWJsZURlY2xhcmF0b3JcIlxuICAgIH0sIGtpbmQgPT09IFwidmFyXCIgPyA1IDogODIwMSk7XG4gICAgZGVjbC5pZCA9IGlkO1xuICB9XG4gIHBhcnNlQXN5bmNGdW5jdGlvbkV4cHJlc3Npb24obm9kZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgOCk7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbihub2RlLCBmbGFncyA9IDApIHtcbiAgICBjb25zdCBoYW5naW5nRGVjbGFyYXRpb24gPSBmbGFncyAmIDI7XG4gICAgY29uc3QgaXNEZWNsYXJhdGlvbiA9ICEhKGZsYWdzICYgMSk7XG4gICAgY29uc3QgcmVxdWlyZUlkID0gaXNEZWNsYXJhdGlvbiAmJiAhKGZsYWdzICYgNCk7XG4gICAgY29uc3QgaXNBc3luYyA9ICEhKGZsYWdzICYgOCk7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICBpZiAoaGFuZ2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkdlbmVyYXRvckluU2luZ2xlU3RhdGVtZW50Q29udGV4dCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZ2VuZXJhdG9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVjbGFyYXRpb24pIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpO1xuICAgIH1cbiAgICBjb25zdCBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IGZhbHNlO1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoMik7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBub2RlLmdlbmVyYXRvcikpO1xuICAgIGlmICghaXNEZWNsYXJhdGlvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKCk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBmYWxzZSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgaXNEZWNsYXJhdGlvbiA/IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIDogXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gICAgfSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIGlmIChpc0RlY2xhcmF0aW9uICYmICFoYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJGdW5jdGlvblN0YXRlbWVudElkKG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSBvbGRNYXliZUluQXJyb3dQYXJhbWV0ZXJzO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25JZChyZXF1aXJlSWQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlkIHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogbnVsbDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3UGFyYW1ldGVyRGVjbGFyYXRpb25TY29wZSgpKTtcbiAgICBub2RlLnBhcmFtcyA9IHRoaXMucGFyc2VCaW5kaW5nTGlzdCgxMSwgNDEsIDIgfCAoaXNDb25zdHJ1Y3RvciA/IDQgOiAwKSk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICB9XG4gIHJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKSB7XG4gICAgaWYgKCFub2RlLmlkKSByZXR1cm47XG4gICAgdGhpcy5zY29wZS5kZWNsYXJlTmFtZShub2RlLmlkLm5hbWUsICF0aGlzLm9wdGlvbnMuYW5uZXhCIHx8IHRoaXMuc3RhdGUuc3RyaWN0IHx8IG5vZGUuZ2VuZXJhdG9yIHx8IG5vZGUuYXN5bmMgPyB0aGlzLnNjb3BlLnRyZWF0RnVuY3Rpb25zQXNWYXIgPyA1IDogODIwMSA6IDE3LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgIHRoaXMuc3RhdGUuc3RyaWN0ID0gdHJ1ZTtcbiAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgdGhpcy5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUNsYXNzQm9keSghIW5vZGUuc3VwZXJDbGFzcywgb2xkU3RyaWN0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzU3RhdGVtZW50ID8gXCJDbGFzc0RlY2xhcmF0aW9uXCIgOiBcIkNsYXNzRXhwcmVzc2lvblwiKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMjkpIHx8IHRoaXMubWF0Y2goMTMpIHx8IHRoaXMubWF0Y2goOCk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCk7XG4gIH1cbiAgbmFtZUlzQ29uc3RydWN0b3Ioa2V5KSB7XG4gICAgcmV0dXJuIGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiAmJiBrZXkudmFsdWUgPT09IFwiY29uc3RydWN0b3JcIjtcbiAgfVxuICBpc05vbnN0YXRpY0NvbnN0cnVjdG9yKG1ldGhvZCkge1xuICAgIHJldHVybiAhbWV0aG9kLmNvbXB1dGVkICYmICFtZXRob2Quc3RhdGljICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IobWV0aG9kLmtleSk7XG4gIH1cbiAgcGFyc2VDbGFzc0JvZHkoaGFkU3VwZXJDbGFzcywgb2xkU3RyaWN0KSB7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmVudGVyKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICBoYWRDb25zdHJ1Y3RvcjogZmFsc2UsXG4gICAgICBoYWRTdXBlckNsYXNzXG4gICAgfTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGNvbnN0IGNsYXNzQm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY2xhc3NCb2R5LmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4ge1xuICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxMykpIHtcbiAgICAgICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTZW1pY29sb24sIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgIG1lbWJlci5kZWNvcmF0b3JzID0gZGVjb3JhdG9ycztcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKG1lbWJlciwgZGVjb3JhdG9yc1swXSk7XG4gICAgICAgICAgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgICAgICBpZiAobWVtYmVyLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIiAmJiBtZW1iZXIuZGVjb3JhdG9ycyAmJiBtZW1iZXIuZGVjb3JhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQ29uc3RydWN0b3IsIG1lbWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlRyYWlsaW5nRGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgdGhpcy5jbGFzc1Njb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKGNsYXNzQm9keSwgXCJDbGFzc0JvZHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikge1xuICAgIGNvbnN0IGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmlzQ2xhc3NNZXRob2QoKSkge1xuICAgICAgY29uc3QgbWV0aG9kID0gbWVtYmVyO1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgbWV0aG9kLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBtZXRob2Qua2V5ID0ga2V5O1xuICAgICAgbWV0aG9kLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgY29uc3QgcHJvcCA9IG1lbWJlcjtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICAgIHByb3Aua2V5ID0ga2V5O1xuICAgICAgcHJvcC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkocHJvcCkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3QgaXNTdGF0aWMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDYpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgaWYgKHRoaXMucGFyc2VDbGFzc01lbWJlckZyb21Nb2RpZmllcihjbGFzc0JvZHksIG1lbWJlcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZWF0KDUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyhjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUsIGlzU3RhdGljKSB7XG4gICAgY29uc3QgcHVibGljTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHByaXZhdGVNZXRob2QgPSBtZW1iZXI7XG4gICAgY29uc3QgcHVibGljUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlUHJvcCA9IG1lbWJlcjtcbiAgICBjb25zdCBhY2Nlc3NvclByb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgbWV0aG9kID0gcHVibGljTWV0aG9kO1xuICAgIGNvbnN0IHB1YmxpY01lbWJlciA9IHB1YmxpY01ldGhvZDtcbiAgICBtZW1iZXIuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG1lbWJlcik7XG4gICAgaWYgKHRoaXMuZWF0KDU1KSkge1xuICAgICAgbWV0aG9kLmtpbmQgPSBcIm1ldGhvZFwiO1xuICAgICAgY29uc3QgaXNQcml2YXRlTmFtZSA9IHRoaXMubWF0Y2goMTM5KTtcbiAgICAgIHRoaXMucGFyc2VDbGFzc0VsZW1lbnROYW1lKG1ldGhvZCk7XG4gICAgICBpZiAoaXNQcml2YXRlTmFtZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvcklzR2VuZXJhdG9yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDb250ZXh0dWFsID0gIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZW1iZXIpO1xuICAgIGNvbnN0IG1heWJlQ29udGV4dHVhbEt3ID0gaXNDb250ZXh0dWFsID8ga2V5Lm5hbWUgOiBudWxsO1xuICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMuaXNQcml2YXRlTmFtZShrZXkpO1xuICAgIGNvbnN0IG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpO1xuICAgICAgbGV0IGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgICBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBwdWJsaWNNZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgaWYgKHN0YXRlLmhhZENvbnN0cnVjdG9yICYmICF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVDb25zdHJ1Y3Rvciwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciAmJiB0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikgJiYgbWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3ZlcnJpZGVPbkNvbnN0cnVjdG9yLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBzdGF0ZS5oYWRTdXBlckNsYXNzO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByaXZhdGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwdWJsaWNQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgY29uc3QgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICBpZiAocHVibGljTWVtYmVyLm9wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChtYXliZVF1ZXN0aW9uVG9rZW5TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHB1YmxpY01lbWJlcik7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNBc3luYywgcHVibGljTWV0aG9kLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImdldFwiIHx8IG1heWJlQ29udGV4dHVhbEt3ID09PSBcInNldFwiKSAmJiAhKHRoaXMubWF0Y2goNTUpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSkge1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgIG1ldGhvZC5raW5kID0gbWF5YmVDb250ZXh0dWFsS3c7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNNZXRob2QpO1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FjY2Vzc29yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiYWNjZXNzb3JcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVjb3JhdG9yQXV0b0FjY2Vzc29yc1wiKTtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNQcm9wKTtcbiAgICAgIHRoaXMucHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIGFjY2Vzc29yUHJvcCwgaXNQcml2YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJpdmF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eShjbGFzc0JvZHksIHB1YmxpY1Byb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICgodHlwZSA9PT0gMTMyIHx8IHR5cGUgPT09IDEzNCkgJiYgbWVtYmVyLnN0YXRpYyAmJiB2YWx1ZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RhdGljUHJvdG90eXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgIG1lbWJlci5rZXkgPSBrZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1lbWJlcik7XG4gICAgcmV0dXJuIG1lbWJlci5rZXk7XG4gIH1cbiAgcGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKSB7XG4gICAgdmFyIF9tZW1iZXIkZGVjb3JhdG9ycztcbiAgICB0aGlzLnNjb3BlLmVudGVyKDY0IHwgMTI4IHwgMTYpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgY29uc3QgYm9keSA9IG1lbWJlci5ib2R5ID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgdW5kZWZpbmVkLCBmYWxzZSwgOCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gb2xkTGFiZWxzO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlciwgXCJTdGF0aWNCbG9ja1wiKSk7XG4gICAgaWYgKChfbWVtYmVyJGRlY29yYXRvcnMgPSBtZW1iZXIuZGVjb3JhdG9ycykgIT0gbnVsbCAmJiBfbWVtYmVyJGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JTdGF0aWNCbG9jaywgbWVtYmVyKTtcbiAgICB9XG4gIH1cbiAgcHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wKSB7XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlQ2xhc3NQcm9wZXJ0eShwcm9wKSk7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cbiAgcHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIHByb3AsIGlzUHJpdmF0ZSkge1xuICAgIGlmICghaXNQcml2YXRlICYmICFwcm9wLmNvbXB1dGVkICYmIHRoaXMubmFtZUlzQ29uc3RydWN0b3IocHJvcC5rZXkpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvckNsYXNzRmllbGQsIHByb3Aua2V5KTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkocHJvcCk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIDAsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKSB7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyLCBcIkNsYXNzTWV0aG9kXCIsIHRydWUpKTtcbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlTWV0aG9kKG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGZhbHNlLCBmYWxzZSwgXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgdHJ1ZSk7XG4gICAgY2xhc3NCb2R5LmJvZHkucHVzaChub2RlKTtcbiAgICBjb25zdCBraW5kID0gbm9kZS5raW5kID09PSBcImdldFwiID8gbm9kZS5zdGF0aWMgPyA2IDogMiA6IG5vZGUua2luZCA9PT0gXCJzZXRcIiA/IG5vZGUuc3RhdGljID8gNSA6IDEgOiAwO1xuICAgIHRoaXMuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5kZWNsYXJlUHJpdmF0ZU5hbWUodGhpcy5nZXRQcml2YXRlTmFtZVNWKG5vZGUua2V5KSwga2luZCwgbm9kZS5rZXkubG9jLnN0YXJ0KTtcbiAgfVxuICBwYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZE9yUHJvcCkge31cbiAgcGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUluaXRpYWxpemVyKG5vZGUpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNsYXNzUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbml0aWFsaXplcihub2RlKSB7XG4gICAgdGhpcy5zY29wZS5lbnRlcig2NCB8IDE2KTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5lbnRlcihuZXdFeHByZXNzaW9uU2NvcGUoKSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoMCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKSA6IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQsIGJpbmRpbmdUeXBlID0gODMzMSkge1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmIChpc1N0YXRlbWVudCkge1xuICAgICAgICB0aGlzLmRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIobm9kZS5pZCwgYmluZGluZ1R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9uYWxJZCB8fCAhaXNTdGF0ZW1lbnQpIHtcbiAgICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nQ2xhc3NOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCg4MSkgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCB0cnVlKTtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKTtcbiAgICBjb25zdCBwYXJzZUFmdGVyRGVmYXVsdCA9ICFoYXNEZWZhdWx0IHx8IHRoaXMuZWF0KDEyKTtcbiAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VBZnRlckRlZmF1bHQgJiYgdGhpcy5lYXRFeHBvcnRTdGFyKG5vZGUpO1xuICAgIGNvbnN0IGhhc05hbWVzcGFjZSA9IGhhc1N0YXIgJiYgdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJOYW1lc3BhY2UgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiAoIWhhc05hbWVzcGFjZSB8fCB0aGlzLmVhdCgxMikpO1xuICAgIGNvbnN0IGlzRnJvbVJlcXVpcmVkID0gaGFzRGVmYXVsdCB8fCBoYXNTdGFyO1xuICAgIGlmIChoYXNTdGFyICYmICFoYXNOYW1lc3BhY2UpIHtcbiAgICAgIGlmIChoYXNEZWZhdWx0KSB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBoYXNTcGVjaWZpZXJzID0gdGhpcy5tYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpO1xuICAgIGlmIChoYXNEZWZhdWx0ICYmIHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICFoYXNTdGFyICYmICFoYXNTcGVjaWZpZXJzKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgNSk7XG4gICAgfVxuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgcGFyc2VBZnRlck5hbWVzcGFjZSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDk4KTtcbiAgICB9XG4gICAgbGV0IGhhc0RlY2xhcmF0aW9uO1xuICAgIGlmIChpc0Zyb21SZXF1aXJlZCB8fCBoYXNTcGVjaWZpZXJzKSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IGZhbHNlO1xuICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgaXNGcm9tUmVxdWlyZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYXNEZWNsYXJhdGlvbiA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycyB8fCBoYXNEZWNsYXJhdGlvbikge1xuICAgICAgdmFyIF9ub2RlMiRkZWNsYXJhdGlvbjtcbiAgICAgIGNvbnN0IG5vZGUyID0gbm9kZTtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZTIsIHRydWUsIGZhbHNlLCAhIW5vZGUyLnNvdXJjZSk7XG4gICAgICBpZiAoKChfbm9kZTIkZGVjbGFyYXRpb24gPSBub2RlMi5kZWNsYXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlMiRkZWNsYXJhdGlvbi50eXBlKSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIG5vZGUyLmRlY2xhcmF0aW9uLCBub2RlMik7XG4gICAgICB9IGVsc2UgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gICAgICBub2RlMi5kZWNsYXJhdGlvbiA9IGRlY2w7XG4gICAgICBpZiAoZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgZGVjbCwgbm9kZTIpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZTIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIik7XG4gICAgfVxuICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgfVxuICBlYXRFeHBvcnRTdGFyKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoNTUpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICBpZiAobWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIsIG1heWJlRGVmYXVsdElkZW50aWZpZXIgPT0gbnVsbCA/IHZvaWQgMCA6IG1heWJlRGVmYXVsdElkZW50aWZpZXIubG9jLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGlkID0gbWF5YmVEZWZhdWx0SWRlbnRpZmllciB8fCB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKTtcbiAgICAgIHNwZWNpZmllci5leHBvcnRlZCA9IGlkO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzID0gW3RoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmJHNwZWNpZmllcnM7XG4gICAgICAoX3JlZiRzcGVjaWZpZXJzID0gKF9yZWYgPSBub2RlKS5zcGVjaWZpZXJzKSAhPSBudWxsID8gX3JlZiRzcGVjaWZpZXJzIDogX3JlZi5zcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVkU3BlY2lmaWVycyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGNvbnN0IG5vZGUyID0gbm9kZTtcbiAgICAgIGlmICghbm9kZTIuc3BlY2lmaWVycykgbm9kZTIuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgY29uc3QgaXNUeXBlRXhwb3J0ID0gbm9kZTIuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCI7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzLnB1c2goLi4udGhpcy5wYXJzZUV4cG9ydFNwZWNpZmllcnMoaXNUeXBlRXhwb3J0KSk7XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICBub2RlMi5hc3NlcnRpb25zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgbm9kZS5hc3NlcnRpb25zID0gW107XG4gICAgICB9XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0FzeW5jRnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5NSkpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIHJldHVybiB0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnVuY3Rpb25cIik7XG4gIH1cbiAgcGFyc2VFeHBvcnREZWZhdWx0RXhwcmVzc2lvbigpIHtcbiAgICBjb25zdCBleHByID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihleHByLCAxIHwgNCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQXN5bmNGdW5jdGlvbigpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihleHByLCAxIHwgNCB8IDgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3MoZXhwciwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSAmJiB0aGlzLmdldFBsdWdpbk9wdGlvbihcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzQmVmb3JlRXhwb3J0XCIpID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckJlZm9yZUV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyh0aGlzLnBhcnNlRGVjb3JhdG9ycyhmYWxzZSksIHRoaXMuc3RhcnROb2RlKCkpLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNzUpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMuaXNMZXQoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWZhdWx0RXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgfVxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgaWYgKHR5cGUgPT09IDk1ICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8IHR5cGUgPT09IDEwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgPT09IDEzMCB8fCB0eXBlID09PSAxMjkpICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0eXBlOiBuZXh0VHlwZVxuICAgICAgICB9ID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKG5leHRUeXBlKSAmJiBuZXh0VHlwZSAhPT0gOTggfHwgbmV4dFR5cGUgPT09IDUpIHtcbiAgICAgICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJmbG93XCIsIFwidHlwZXNjcmlwdFwiXSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBjb25zdCBoYXNGcm9tID0gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZyb21cIik7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNDQgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiBoYXNGcm9tKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNjUpICYmIGhhc0Zyb20pIHtcbiAgICAgIGNvbnN0IG5leHRBZnRlckZyb20gPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5uZXh0VG9rZW5TdGFydFNpbmNlKG5leHQgKyA0KSk7XG4gICAgICByZXR1cm4gbmV4dEFmdGVyRnJvbSA9PT0gMzQgfHwgbmV4dEFmdGVyRnJvbSA9PT0gMzk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZUV4cG9ydEZyb20obm9kZSwgZXhwZWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5OCkpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgICAgdGhpcy5jaGVja0V4cG9ydChub2RlKTtcbiAgICAgIHRoaXMubWF5YmVQYXJzZUltcG9ydEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgICB0aGlzLmNoZWNrSlNPTk1vZHVsZUltcG9ydChub2RlKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cbiAgc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDI2KSB7XG4gICAgICB0aGlzLmV4cGVjdE9uZVBsdWdpbihbXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9ycy1sZWdhY3lcIl0pO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckJlZm9yZUV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMDcpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Vc2luZ0RlY2xhcmF0aW9uRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTYpICYmIHRoaXMuc3RhcnRzQXdhaXRVc2luZygpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Vc2luZ0RlY2xhcmF0aW9uRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gNzQgfHwgdHlwZSA9PT0gNzUgfHwgdHlwZSA9PT0gNjggfHwgdHlwZSA9PT0gODAgfHwgdGhpcy5pc0xldCgpIHx8IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSwgY2hlY2tOYW1lcywgaXNEZWZhdWx0LCBpc0Zyb20pIHtcbiAgICBpZiAoY2hlY2tOYW1lcykge1xuICAgICAgdmFyIF9ub2RlJHNwZWNpZmllcnM7XG4gICAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIikpIHtcbiAgICAgICAgICB2YXIgX2RlY2xhcmF0aW9uJGV4dHJhO1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZGVjbGFyYXRpb24ubmFtZSA9PT0gXCJmcm9tXCIgJiYgZGVjbGFyYXRpb24uZW5kIC0gZGVjbGFyYXRpb24uc3RhcnQgPT09IDQgJiYgISgoX2RlY2xhcmF0aW9uJGV4dHJhID0gZGVjbGFyYXRpb24uZXh0cmEpICE9IG51bGwgJiYgX2RlY2xhcmF0aW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5FeHBvcnREZWZhdWx0RnJvbUFzSWRlbnRpZmllciwgZGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX25vZGUkc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfbm9kZSRzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleHBvcnRlZFxuICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IGV4cG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gZXhwb3J0ZWQubmFtZSA6IGV4cG9ydGVkLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHNwZWNpZmllciwgZXhwb3J0TmFtZSk7XG4gICAgICAgICAgaWYgKCFpc0Zyb20gJiYgc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxvY2FsXG4gICAgICAgICAgICB9ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgaWYgKGxvY2FsLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkV4cG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lOiBsb2NhbC52YWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChsb2NhbC5uYW1lLCBsb2NhbC5sb2Muc3RhcnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5zY29wZS5jaGVja0xvY2FsRXhwb3J0KGxvY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgaWYgKGRlY2wudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSA9IGRlY2w7XG4gICAgICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgaWQubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVjbC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBub2RlLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24ocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS5sZWZ0KTtcbiAgICB9XG4gIH1cbiAgY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIGV4cG9ydE5hbWUpIHtcbiAgICBpZiAodGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmhhcyhleHBvcnROYW1lKSkge1xuICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZURlZmF1bHRFeHBvcnQsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRXhwb3J0LCBub2RlLCB7XG4gICAgICAgICAgZXhwb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmFkZChleHBvcnROYW1lKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcnMoaXNJblR5cGVFeHBvcnQpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpc01heWJlVHlwZU9ubHkgPSB0aGlzLmlzQ29udGV4dHVhbCgxMzApO1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUubG9jYWwpO1xuICAgIH0gZWxzZSBpZiAoIW5vZGUuZXhwb3J0ZWQpIHtcbiAgICAgIG5vZGUuZXhwb3J0ZWQgPSBjbG9uZUlkZW50aWZpZXIobm9kZS5sb2NhbCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gIH1cbiAgcGFyc2VNb2R1bGVFeHBvcnROYW1lKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY29uc3Qgc3Vycm9nYXRlID0gbG9uZVN1cnJvZ2F0ZS5leGVjKHJlc3VsdC52YWx1ZSk7XG4gICAgICBpZiAoc3Vycm9nYXRlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUV4cG9ydE5hbWVIYXNMb25lU3Vycm9nYXRlLCByZXN1bHQsIHtcbiAgICAgICAgICBzdXJyb2dhdGVDaGFyQ29kZTogc3Vycm9nYXRlWzBdLmNoYXJDb2RlQXQoMClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gIH1cbiAgaXNKU09OTW9kdWxlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hc3NlcnRpb25zICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBub2RlLmFzc2VydGlvbnMuc29tZSgoe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlXG4gICAgICB9KSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZSA9PT0gXCJqc29uXCIgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lID09PSBcInR5cGVcIiA6IGtleS52YWx1ZSA9PT0gXCJ0eXBlXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBjb25zdCBzaW5nbGVCaW5kaW5nVHlwZSA9IHNwZWNpZmllcnMubGVuZ3RoID09PSAxID8gc3BlY2lmaWVyc1swXS50eXBlIDogbnVsbDtcbiAgICBpZiAobm9kZS5waGFzZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Tb3VyY2VQaGFzZUltcG9ydFJlcXVpcmVzRGVmYXVsdCwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5waGFzZSA9PT0gXCJkZWZlclwiKSB7XG4gICAgICBpZiAoc2luZ2xlQmluZGluZ1R5cGUgIT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVmZXJJbXBvcnRSZXF1aXJlc05hbWVzcGFjZSwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5tb2R1bGUpIHtcbiAgICAgIHZhciBfbm9kZSRhc3NlcnRpb25zO1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRSZWZsZWN0aW9uTm90QmluZGluZywgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCgoX25vZGUkYXNzZXJ0aW9ucyA9IG5vZGUuYXNzZXJ0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGFzc2VydGlvbnMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0Fzc2VydGlvbiwgc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSkge1xuICAgIGlmICh0aGlzLmlzSlNPTk1vZHVsZUltcG9ydChub2RlKSAmJiBub2RlLnR5cGUgIT09IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzcGVjaWZpZXJzXG4gICAgICB9ID0gbm9kZTtcbiAgICAgIGlmIChzcGVjaWZpZXJzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgbm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyID0gc3BlY2lmaWVycy5maW5kKHNwZWNpZmllciA9PiB7XG4gICAgICAgICAgbGV0IGltcG9ydGVkO1xuICAgICAgICAgIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gXCJFeHBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgaW1wb3J0ZWQgPSBzcGVjaWZpZXIubG9jYWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWZpZXIudHlwZSA9PT0gXCJJbXBvcnRTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgaW1wb3J0ZWQgPSBzcGVjaWZpZXIuaW1wb3J0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbXBvcnRlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0ZWQudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBpbXBvcnRlZC5uYW1lICE9PSBcImRlZmF1bHRcIiA6IGltcG9ydGVkLnZhbHVlICE9PSBcImRlZmF1bHRcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9uRGVmYXVsdE5hbWVkU3BlY2lmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQsIG5vbkRlZmF1bHROYW1lZFNwZWNpZmllci5sb2Muc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoaXNFeHBvcnQpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA1KSB8fCB0aGlzLmlzQ29udGV4dHVhbCg5NykgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwaGFzZSA9PT0gXCJtb2R1bGVcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJpbXBvcnRSZWZsZWN0aW9uXCIsIGxvYyk7XG4gICAgICBub2RlLm1vZHVsZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1BsdWdpbihcImltcG9ydFJlZmxlY3Rpb25cIikpIHtcbiAgICAgIG5vZGUubW9kdWxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwaGFzZSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJzb3VyY2VQaGFzZUltcG9ydHNcIiwgbG9jKTtcbiAgICAgIG5vZGUucGhhc2UgPSBcInNvdXJjZVwiO1xuICAgIH0gZWxzZSBpZiAocGhhc2UgPT09IFwiZGVmZXJcIikge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJkZWZlcnJlZEltcG9ydEV2YWx1YXRpb25cIiwgbG9jKTtcbiAgICAgIG5vZGUucGhhc2UgPSBcImRlZmVyXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1BsdWdpbihcInNvdXJjZVBoYXNlSW1wb3J0c1wiKSkge1xuICAgICAgbm9kZS5waGFzZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCkge1xuICAgIGlmICghdGhpcy5pc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSkge1xuICAgICAgdGhpcy5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwaGFzZUlkZW50aWZpZXIgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgaXNJbXBvcnRQaGFzZSA9IHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpID8gdHlwZSAhPT0gOTggfHwgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSAxMDIgOiB0eXBlICE9PSAxMjtcbiAgICBpZiAoaXNJbXBvcnRQaGFzZSkge1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzSWRlbnRpZmllckxlYWRpbmdDb21tZW50cyhwaGFzZUlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZUlkZW50aWZpZXIubmFtZSwgcGhhc2VJZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBudWxsKTtcbiAgICAgIHJldHVybiBwaGFzZUlkZW50aWZpZXI7XG4gICAgfVxuICB9XG4gIGlzUHJlY2VkaW5nSWRJbXBvcnRQaGFzZShwaGFzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyc0FuZEFmdGVyKG5vZGUsIHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIGZhbHNlKSk7XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHBhcnNlTmV4dCA9ICFoYXNEZWZhdWx0IHx8IHRoaXMuZWF0KDEyKTtcbiAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VOZXh0ICYmIHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgaWYgKHBhcnNlTmV4dCAmJiAhaGFzU3RhcikgdGhpcy5wYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKTtcbiAgfVxuICBwYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHZhciBfbm9kZSRzcGVjaWZpZXJzMjtcbiAgICAoX25vZGUkc3BlY2lmaWVyczIgPSBub2RlLnNwZWNpZmllcnMpICE9IG51bGwgPyBfbm9kZSRzcGVjaWZpZXJzMiA6IG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgIHRoaXMubWF5YmVQYXJzZUltcG9ydEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgdGhpcy5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHlwZSwgYmluZGluZ1R5cGUgPSA4MjAxKSB7XG4gICAgdGhpcy5jaGVja0xWYWwoc3BlY2lmaWVyLmxvY2FsLCB7XG4gICAgICB0eXBlXG4gICAgfSwgYmluZGluZ1R5cGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCB0eXBlKTtcbiAgfVxuICBwYXJzZUltcG9ydEF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICBjb25zdCBhdHRyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgaWYgKHRoaXMubWF0Y2goOCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGF0dHJOYW1lcy5oYXMoa2V5TmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAga2V5OiBrZXlOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXR0ck5hbWVzLmFkZChrZXlOYW1lKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbChrZXlOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgYXR0cnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIHBhcnNlTW9kdWxlQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgaWYgKG5vZGUua2V5Lm5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZURpZmZlcmVudEZyb21UeXBlLCBub2RlLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXMobm9kZS5rZXkubmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCBub2RlLmtleSwge1xuICAgICAgICAgIGtleTogbm9kZS5rZXkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMuYWRkKG5vZGUua2V5Lm5hbWUpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGF0dHJzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0QXR0cmlidXRlXCIpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIHJldHVybiBhdHRycztcbiAgfVxuICBtYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXM7XG4gICAge1xuICAgICAgdmFyIHVzZVdpdGggPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNzYpKSB7XG4gICAgICBpZiAodGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwibW9kdWxlQXR0cmlidXRlc1wiKSkge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZU1vZHVsZUF0dHJpYnV0ZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSW1wb3J0QXR0cmlidXRlcygpO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICB1c2VXaXRoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDk0KSAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRcIikgJiYgIXRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRBdHRyaWJ1dGVzVXNlQXNzZXJ0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJkZXByZWNhdGVkQXNzZXJ0U3ludGF4XCIsIHRydWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cmlidXRlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAoIXVzZVdpdGggJiYgdGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICBub2RlLmFzc2VydGlvbnMgPSBhdHRyaWJ1dGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgIH1cbiAgfVxuICBtYXliZVBhcnNlRGVmYXVsdEltcG9ydFNwZWNpZmllcihub2RlLCBtYXliZURlZmF1bHRJZGVudGlmaWVyKSB7XG4gICAgaWYgKG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXROb2RlKG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgICAgc3BlY2lmaWVyLmxvY2FsID0gbWF5YmVEZWZhdWx0SWRlbnRpZmllcjtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHRoaXMuc3RhcnROb2RlKCksIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDU1KSkge1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDkzKTtcbiAgICAgIHRoaXMucGFyc2VJbXBvcnRTcGVjaWZpZXJMb2NhbChub2RlLCBzcGVjaWZpZXIsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKSB7XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KDgpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmVhdCgxNCkpIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5EZXN0cnVjdHVyZU5hbWVkSW1wb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgY29uc3QgaW1wb3J0ZWRJc1N0cmluZyA9IHRoaXMubWF0Y2goMTM0KTtcbiAgICAgIGNvbnN0IGlzTWF5YmVUeXBlT25seSA9IHRoaXMuaXNDb250ZXh0dWFsKDEzMCk7XG4gICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgY29uc3QgaW1wb3J0U3BlY2lmaWVyID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiLCBpc01heWJlVHlwZU9ubHksIHVuZGVmaW5lZCk7XG4gICAgICBub2RlLnNwZWNpZmllcnMucHVzaChpbXBvcnRTcGVjaWZpZXIpO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllcihzcGVjaWZpZXIsIGltcG9ydGVkSXNTdHJpbmcsIGlzSW5UeXBlT25seUltcG9ydCwgaXNNYXliZVR5cGVPbmx5LCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGltcG9ydGVkXG4gICAgICB9ID0gc3BlY2lmaWVyO1xuICAgICAgaWYgKGltcG9ydGVkSXNTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICBpbXBvcnROYW1lOiBpbXBvcnRlZC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tSZXNlcnZlZFdvcmQoaW1wb3J0ZWQubmFtZSwgc3BlY2lmaWVyLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoIXNwZWNpZmllci5sb2NhbCkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSBjbG9uZUlkZW50aWZpZXIoaW1wb3J0ZWQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiLCBiaW5kaW5nVHlwZSk7XG4gIH1cbiAgaXNUaGlzUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ubmFtZSA9PT0gXCJ0aGlzXCI7XG4gIH1cbn1cbmNsYXNzIFBhcnNlciBleHRlbmRzIFN0YXRlbWVudFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlucHV0LCBwbHVnaW5zTWFwKSB7XG4gICAgb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgc3VwZXIob3B0aW9ucywgaW5wdXQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pbml0aWFsaXplU2NvcGVzKCk7XG4gICAgdGhpcy5wbHVnaW5zID0gcGx1Z2luc01hcDtcbiAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5zb3VyY2VGaWxlbmFtZTtcbiAgICB0aGlzLnN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBTY29wZUhhbmRsZXI7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgdGhpcy5lbnRlckluaXRpYWxTY29wZXMoKTtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIGZpbGUuZXJyb3JzID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgZmlsZS5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICBmaWxlLmNvbW1lbnRzLmxlbmd0aCA9IHRoaXMuc3RhdGUuY29tbWVudHNMZW47XG4gICAgcmV0dXJuIGZpbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlKGlucHV0LCBvcHRpb25zKSB7XG4gIHZhciBfb3B0aW9ucztcbiAgaWYgKCgoX29wdGlvbnMgPSBvcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX29wdGlvbnMuc291cmNlVHlwZSkgPT09IFwidW5hbWJpZ3VvdXNcIikge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJtb2R1bGVcIjtcbiAgICAgIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG4gICAgICBjb25zdCBhc3QgPSBwYXJzZXIucGFyc2UoKTtcbiAgICAgIGlmIChwYXJzZXIuc2F3VW5hbWJpZ3VvdXNFU00pIHtcbiAgICAgICAgcmV0dXJuIGFzdDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZXIuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7fVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXN0LnByb2dyYW0uc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXN0O1xuICAgIH0gY2F0Y2ggKG1vZHVsZUVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvcHRpb25zLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VyKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZDIpIHt9XG4gICAgICB0aHJvdyBtb2R1bGVFcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGlucHV0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhcnNlciA9IGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCk7XG4gIGlmIChwYXJzZXIub3B0aW9ucy5zdHJpY3RNb2RlKSB7XG4gICAgcGFyc2VyLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHBhcnNlci5nZXRFeHByZXNzaW9uKCk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUV4cG9ydGVkVG9rZW5UeXBlcyhpbnRlcm5hbFRva2VuVHlwZXMpIHtcbiAgY29uc3QgdG9rZW5UeXBlcyA9IHt9O1xuICBmb3IgKGNvbnN0IHR5cGVOYW1lIG9mIE9iamVjdC5rZXlzKGludGVybmFsVG9rZW5UeXBlcykpIHtcbiAgICB0b2tlblR5cGVzW3R5cGVOYW1lXSA9IGdldEV4cG9ydGVkVG9rZW4oaW50ZXJuYWxUb2tlblR5cGVzW3R5cGVOYW1lXSk7XG4gIH1cbiAgcmV0dXJuIHRva2VuVHlwZXM7XG59XG5jb25zdCB0b2tUeXBlcyA9IGdlbmVyYXRlRXhwb3J0ZWRUb2tlblR5cGVzKHR0KTtcbmZ1bmN0aW9uIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkge1xuICBsZXQgY2xzID0gUGFyc2VyO1xuICBjb25zdCBwbHVnaW5zTWFwID0gbmV3IE1hcCgpO1xuICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucGx1Z2lucykge1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIG9wdGlvbnMucGx1Z2lucykge1xuICAgICAgbGV0IG5hbWUsIG9wdHM7XG4gICAgICBpZiAodHlwZW9mIHBsdWdpbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lID0gcGx1Z2luO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgW25hbWUsIG9wdHNdID0gcGx1Z2luO1xuICAgICAgfVxuICAgICAgaWYgKCFwbHVnaW5zTWFwLmhhcyhuYW1lKSkge1xuICAgICAgICBwbHVnaW5zTWFwLnNldChuYW1lLCBvcHRzIHx8IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnNNYXApO1xuICAgIGNscyA9IGdldFBhcnNlckNsYXNzKHBsdWdpbnNNYXApO1xuICB9XG4gIHJldHVybiBuZXcgY2xzKG9wdGlvbnMsIGlucHV0LCBwbHVnaW5zTWFwKTtcbn1cbmNvbnN0IHBhcnNlckNsYXNzQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zTWFwKSB7XG4gIGNvbnN0IHBsdWdpbkxpc3QgPSBbXTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIG1peGluUGx1Z2luTmFtZXMpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMobmFtZSkpIHtcbiAgICAgIHBsdWdpbkxpc3QucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2V5ID0gcGx1Z2luTGlzdC5qb2luKFwifFwiKTtcbiAgbGV0IGNscyA9IHBhcnNlckNsYXNzQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICghY2xzKSB7XG4gICAgY2xzID0gUGFyc2VyO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbkxpc3QpIHtcbiAgICAgIGNscyA9IG1peGluUGx1Z2luc1twbHVnaW5dKGNscyk7XG4gICAgfVxuICAgIHBhcnNlckNsYXNzQ2FjaGUuc2V0KGtleSwgY2xzKTtcbiAgfVxuICByZXR1cm4gY2xzO1xufVxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb247XG5leHBvcnRzLnRva1R5cGVzID0gdG9rVHlwZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22172\n')},74466:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = createTemplateBuilder;\nvar _options = __webpack_require__(19815);\nvar _string = __webpack_require__(95252);\nvar _literal = __webpack_require__(53438);\nconst NO_PLACEHOLDER = (0, _options.validate)({\n  placeholderPattern: false\n});\nfunction createTemplateBuilder(formatter, defaultOpts) {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || (0, _options.validate)(null);\n  return Object.assign((tpl, ...args) => {\n    if (typeof tpl === "string") {\n      if (args.length > 1) throw new Error("Unexpected extra params.");\n      return extendedTrace((0, _string.default)(formatter, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));\n    } else if (Array.isArray(tpl)) {\n      let builder = templateFnCache.get(tpl);\n      if (!builder) {\n        builder = (0, _literal.default)(formatter, tpl, cachedOpts);\n        templateFnCache.set(tpl, builder);\n      }\n      return extendedTrace(builder(args));\n    } else if (typeof tpl === "object" && tpl) {\n      if (args.length > 0) throw new Error("Unexpected extra params.");\n      return createTemplateBuilder(formatter, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));\n    }\n    throw new Error(`Unexpected template param ${typeof tpl}`);\n  }, {\n    ast: (tpl, ...args) => {\n      if (typeof tpl === "string") {\n        if (args.length > 1) throw new Error("Unexpected extra params.");\n        return (0, _string.default)(formatter, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();\n      } else if (Array.isArray(tpl)) {\n        let builder = templateAstCache.get(tpl);\n        if (!builder) {\n          builder = (0, _literal.default)(formatter, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));\n          templateAstCache.set(tpl, builder);\n        }\n        return builder(args)();\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }\n  });\n}\nfunction extendedTrace(fn) {\n  let rootStack = "";\n  try {\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      rootStack = error.stack.split("\\n").slice(3).join("\\n");\n    }\n  }\n  return arg => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n\n//# sourceMappingURL=builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ0NjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsS0FBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxXQUFXO0FBQzlEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvYnVpbGRlci5qcz9kYmIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVGVtcGxhdGVCdWlsZGVyO1xudmFyIF9vcHRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbnZhciBfc3RyaW5nID0gcmVxdWlyZShcIi4vc3RyaW5nLmpzXCIpO1xudmFyIF9saXRlcmFsID0gcmVxdWlyZShcIi4vbGl0ZXJhbC5qc1wiKTtcbmNvbnN0IE5PX1BMQUNFSE9MREVSID0gKDAsIF9vcHRpb25zLnZhbGlkYXRlKSh7XG4gIHBsYWNlaG9sZGVyUGF0dGVybjogZmFsc2Vcbn0pO1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGVCdWlsZGVyKGZvcm1hdHRlciwgZGVmYXVsdE9wdHMpIHtcbiAgY29uc3QgdGVtcGxhdGVGbkNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgY29uc3QgdGVtcGxhdGVBc3RDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gIGNvbnN0IGNhY2hlZE9wdHMgPSBkZWZhdWx0T3B0cyB8fCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKG51bGwpO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbigodHBsLCAuLi5hcmdzKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0cGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgZXh0cmEgcGFyYW1zLlwiKTtcbiAgICAgIHJldHVybiBleHRlbmRlZFRyYWNlKCgwLCBfc3RyaW5nLmRlZmF1bHQpKGZvcm1hdHRlciwgdHBsLCAoMCwgX29wdGlvbnMubWVyZ2UpKGNhY2hlZE9wdHMsICgwLCBfb3B0aW9ucy52YWxpZGF0ZSkoYXJnc1swXSkpKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRwbCkpIHtcbiAgICAgIGxldCBidWlsZGVyID0gdGVtcGxhdGVGbkNhY2hlLmdldCh0cGwpO1xuICAgICAgaWYgKCFidWlsZGVyKSB7XG4gICAgICAgIGJ1aWxkZXIgPSAoMCwgX2xpdGVyYWwuZGVmYXVsdCkoZm9ybWF0dGVyLCB0cGwsIGNhY2hlZE9wdHMpO1xuICAgICAgICB0ZW1wbGF0ZUZuQ2FjaGUuc2V0KHRwbCwgYnVpbGRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXh0ZW5kZWRUcmFjZShidWlsZGVyKGFyZ3MpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cGwgPT09IFwib2JqZWN0XCIgJiYgdHBsKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGV4dHJhIHBhcmFtcy5cIik7XG4gICAgICByZXR1cm4gY3JlYXRlVGVtcGxhdGVCdWlsZGVyKGZvcm1hdHRlciwgKDAsIF9vcHRpb25zLm1lcmdlKShjYWNoZWRPcHRzLCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKHRwbCkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRlbXBsYXRlIHBhcmFtICR7dHlwZW9mIHRwbH1gKTtcbiAgfSwge1xuICAgIGFzdDogKHRwbCwgLi4uYXJncykgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0cGwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMSkgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBleHRyYSBwYXJhbXMuXCIpO1xuICAgICAgICByZXR1cm4gKDAsIF9zdHJpbmcuZGVmYXVsdCkoZm9ybWF0dGVyLCB0cGwsICgwLCBfb3B0aW9ucy5tZXJnZSkoKDAsIF9vcHRpb25zLm1lcmdlKShjYWNoZWRPcHRzLCAoMCwgX29wdGlvbnMudmFsaWRhdGUpKGFyZ3NbMF0pKSwgTk9fUExBQ0VIT0xERVIpKSgpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRwbCkpIHtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSB0ZW1wbGF0ZUFzdENhY2hlLmdldCh0cGwpO1xuICAgICAgICBpZiAoIWJ1aWxkZXIpIHtcbiAgICAgICAgICBidWlsZGVyID0gKDAsIF9saXRlcmFsLmRlZmF1bHQpKGZvcm1hdHRlciwgdHBsLCAoMCwgX29wdGlvbnMubWVyZ2UpKGNhY2hlZE9wdHMsIE5PX1BMQUNFSE9MREVSKSk7XG4gICAgICAgICAgdGVtcGxhdGVBc3RDYWNoZS5zZXQodHBsLCBidWlsZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlcihhcmdzKSgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHRlbXBsYXRlIHBhcmFtICR7dHlwZW9mIHRwbH1gKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZXh0ZW5kZWRUcmFjZShmbikge1xuICBsZXQgcm9vdFN0YWNrID0gXCJcIjtcbiAgdHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgIHJvb3RTdGFjayA9IGVycm9yLnN0YWNrLnNwbGl0KFwiXFxuXCIpLnNsaWNlKDMpLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmcgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGVyci5zdGFjayArPSBgXFxuICAgID09PT09PT09PT09PT1cXG4ke3Jvb3RTdGFja31gO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74466\n')},60826:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = void 0;\nvar _t = __webpack_require__(2352);\nconst {\n  assertExpressionStatement\n} = _t;\nfunction makeStatementFormatter(fn) {\n  return {\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: ast => {\n      return fn(ast.program.body.slice(1));\n    }\n  };\n}\nconst smart = exports.smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\nconst statements = exports.statements = makeStatementFormatter(body => body);\nconst statement = exports.statement = makeStatementFormatter(body => {\n  if (body.length === 0) {\n    throw new Error("Found nothing to return.");\n  }\n  if (body.length > 1) {\n    throw new Error("Found multiple statements but wanted one");\n  }\n  return body[0];\n});\nconst expression = exports.expression = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error("Found multiple statements but wanted one");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error("Parse result included parens.");\n    }\n  },\n  unwrap: ({\n    program\n  }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  }\n};\nconst program = exports.program = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program\n};\n\n//# sourceMappingURL=formatters.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA4MjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxrQkFBa0I7QUFDN0YsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0Esd0NBQXdDLElBQUksSUFBSTtBQUNoRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGtCQUFrQjtBQUNyQyxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixrQkFBa0I7QUFDckMscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9mb3JtYXR0ZXJzLmpzPzc5NjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0YXRlbWVudHMgPSBleHBvcnRzLnN0YXRlbWVudCA9IGV4cG9ydHMuc21hcnQgPSBleHBvcnRzLnByb2dyYW0gPSBleHBvcnRzLmV4cHJlc3Npb24gPSB2b2lkIDA7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBhc3NlcnRFeHByZXNzaW9uU3RhdGVtZW50XG59ID0gX3Q7XG5mdW5jdGlvbiBtYWtlU3RhdGVtZW50Rm9ybWF0dGVyKGZuKSB7XG4gIHJldHVybiB7XG4gICAgY29kZTogc3RyID0+IGAvKiBAYmFiZWwvdGVtcGxhdGUgKi87XFxuJHtzdHJ9YCxcbiAgICB2YWxpZGF0ZTogKCkgPT4ge30sXG4gICAgdW53cmFwOiBhc3QgPT4ge1xuICAgICAgcmV0dXJuIGZuKGFzdC5wcm9ncmFtLmJvZHkuc2xpY2UoMSkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IHNtYXJ0ID0gZXhwb3J0cy5zbWFydCA9IG1ha2VTdGF0ZW1lbnRGb3JtYXR0ZXIoYm9keSA9PiB7XG4gIGlmIChib2R5Lmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYm9keVswXTtcbiAgfVxufSk7XG5jb25zdCBzdGF0ZW1lbnRzID0gZXhwb3J0cy5zdGF0ZW1lbnRzID0gbWFrZVN0YXRlbWVudEZvcm1hdHRlcihib2R5ID0+IGJvZHkpO1xuY29uc3Qgc3RhdGVtZW50ID0gZXhwb3J0cy5zdGF0ZW1lbnQgPSBtYWtlU3RhdGVtZW50Rm9ybWF0dGVyKGJvZHkgPT4ge1xuICBpZiAoYm9keS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBub3RoaW5nIHRvIHJldHVybi5cIik7XG4gIH1cbiAgaWYgKGJvZHkubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZvdW5kIG11bHRpcGxlIHN0YXRlbWVudHMgYnV0IHdhbnRlZCBvbmVcIik7XG4gIH1cbiAgcmV0dXJuIGJvZHlbMF07XG59KTtcbmNvbnN0IGV4cHJlc3Npb24gPSBleHBvcnRzLmV4cHJlc3Npb24gPSB7XG4gIGNvZGU6IHN0ciA9PiBgKFxcbiR7c3RyfVxcbilgLFxuICB2YWxpZGF0ZTogYXN0ID0+IHtcbiAgICBpZiAoYXN0LnByb2dyYW0uYm9keS5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGb3VuZCBtdWx0aXBsZSBzdGF0ZW1lbnRzIGJ1dCB3YW50ZWQgb25lXCIpO1xuICAgIH1cbiAgICBpZiAoZXhwcmVzc2lvbi51bndyYXAoYXN0KS5zdGFydCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyc2UgcmVzdWx0IGluY2x1ZGVkIHBhcmVucy5cIik7XG4gICAgfVxuICB9LFxuICB1bndyYXA6ICh7XG4gICAgcHJvZ3JhbVxuICB9KSA9PiB7XG4gICAgY29uc3QgW3N0bXRdID0gcHJvZ3JhbS5ib2R5O1xuICAgIGFzc2VydEV4cHJlc3Npb25TdGF0ZW1lbnQoc3RtdCk7XG4gICAgcmV0dXJuIHN0bXQuZXhwcmVzc2lvbjtcbiAgfVxufTtcbmNvbnN0IHByb2dyYW0gPSBleHBvcnRzLnByb2dyYW0gPSB7XG4gIGNvZGU6IHN0ciA9PiBzdHIsXG4gIHZhbGlkYXRlOiAoKSA9PiB7fSxcbiAgdW53cmFwOiBhc3QgPT4gYXN0LnByb2dyYW1cbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHRlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60826\n')},32485:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.statements = exports.statement = exports.smart = exports.program = exports.expression = exports["default"] = void 0;\nvar formatters = __webpack_require__(60826);\nvar _builder = __webpack_require__(74466);\nconst smart = exports.smart = (0, _builder.default)(formatters.smart);\nconst statement = exports.statement = (0, _builder.default)(formatters.statement);\nconst statements = exports.statements = (0, _builder.default)(formatters.statements);\nconst expression = exports.expression = (0, _builder.default)(formatters.expression);\nconst program = exports.program = (0, _builder.default)(formatters.program);\nvar _default = exports["default"] = Object.assign(smart.bind(undefined), {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast\n});\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI0ODUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxrQkFBa0IsR0FBRyxrQkFBZTtBQUMvRyxpQkFBaUIsbUJBQU8sQ0FBQyxLQUFpQjtBQUMxQyxlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQyxjQUFjLGFBQWE7QUFDM0Isa0JBQWtCLGlCQUFpQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLG1CQUFtQixrQkFBa0I7QUFDckMsZ0JBQWdCLGVBQWU7QUFDL0IsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL2luZGV4LmpzPzY1NWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLnN0YXRlbWVudHMgPSBleHBvcnRzLnN0YXRlbWVudCA9IGV4cG9ydHMuc21hcnQgPSBleHBvcnRzLnByb2dyYW0gPSBleHBvcnRzLmV4cHJlc3Npb24gPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRlcnMuanNcIik7XG52YXIgX2J1aWxkZXIgPSByZXF1aXJlKFwiLi9idWlsZGVyLmpzXCIpO1xuY29uc3Qgc21hcnQgPSBleHBvcnRzLnNtYXJ0ID0gKDAsIF9idWlsZGVyLmRlZmF1bHQpKGZvcm1hdHRlcnMuc21hcnQpO1xuY29uc3Qgc3RhdGVtZW50ID0gZXhwb3J0cy5zdGF0ZW1lbnQgPSAoMCwgX2J1aWxkZXIuZGVmYXVsdCkoZm9ybWF0dGVycy5zdGF0ZW1lbnQpO1xuY29uc3Qgc3RhdGVtZW50cyA9IGV4cG9ydHMuc3RhdGVtZW50cyA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLnN0YXRlbWVudHMpO1xuY29uc3QgZXhwcmVzc2lvbiA9IGV4cG9ydHMuZXhwcmVzc2lvbiA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLmV4cHJlc3Npb24pO1xuY29uc3QgcHJvZ3JhbSA9IGV4cG9ydHMucHJvZ3JhbSA9ICgwLCBfYnVpbGRlci5kZWZhdWx0KShmb3JtYXR0ZXJzLnByb2dyYW0pO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gT2JqZWN0LmFzc2lnbihzbWFydC5iaW5kKHVuZGVmaW5lZCksIHtcbiAgc21hcnQsXG4gIHN0YXRlbWVudCxcbiAgc3RhdGVtZW50cyxcbiAgZXhwcmVzc2lvbixcbiAgcHJvZ3JhbSxcbiAgYXN0OiBzbWFydC5hc3Rcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32485\n')},53438:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = literalTemplate;\nvar _options = __webpack_require__(19815);\nvar _parse = __webpack_require__(24858);\nvar _populate = __webpack_require__(97427);\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error("Unexpected replacement overlap.");\n          }\n        });\n      }\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\nfunction buildLiteralData(formatter, tpl, opts) {\n  let prefix = "BABEL_TPL$";\n  const raw = tpl.join("");\n  do {\n    prefix = "$$" + prefix;\n  } while (raw.includes(prefix));\n  const {\n    names,\n    code\n  } = buildTemplateCode(tpl, prefix);\n  const metadata = (0, _parse.default)(formatter, formatter.code(code), {\n    parser: opts.parser,\n    placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders\n  });\n  return {\n    metadata,\n    names\n  };\n}\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n  return {\n    names,\n    code\n  };\n}\n\n//# sourceMappingURL=literal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM0MzguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQyxhQUFhLG1CQUFPLENBQUMsS0FBWTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEMscUJBQXFCLE9BQU8sRUFBRSxNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvbGl0ZXJhbC5qcz9jMzAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gbGl0ZXJhbFRlbXBsYXRlO1xudmFyIF9vcHRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZS5qc1wiKTtcbnZhciBfcG9wdWxhdGUgPSByZXF1aXJlKFwiLi9wb3B1bGF0ZS5qc1wiKTtcbmZ1bmN0aW9uIGxpdGVyYWxUZW1wbGF0ZShmb3JtYXR0ZXIsIHRwbCwgb3B0cykge1xuICBjb25zdCB7XG4gICAgbWV0YWRhdGEsXG4gICAgbmFtZXNcbiAgfSA9IGJ1aWxkTGl0ZXJhbERhdGEoZm9ybWF0dGVyLCB0cGwsIG9wdHMpO1xuICByZXR1cm4gYXJnID0+IHtcbiAgICBjb25zdCBkZWZhdWx0UmVwbGFjZW1lbnRzID0ge307XG4gICAgYXJnLmZvckVhY2goKHJlcGxhY2VtZW50LCBpKSA9PiB7XG4gICAgICBkZWZhdWx0UmVwbGFjZW1lbnRzW25hbWVzW2ldXSA9IHJlcGxhY2VtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBhcmcgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnRzID0gKDAsIF9vcHRpb25zLm5vcm1hbGl6ZVJlcGxhY2VtZW50cykoYXJnKTtcbiAgICAgIGlmIChyZXBsYWNlbWVudHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMocmVwbGFjZW1lbnRzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZGVmYXVsdFJlcGxhY2VtZW50cywga2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCByZXBsYWNlbWVudCBvdmVybGFwLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvcm1hdHRlci51bndyYXAoKDAsIF9wb3B1bGF0ZS5kZWZhdWx0KShtZXRhZGF0YSwgcmVwbGFjZW1lbnRzID8gT2JqZWN0LmFzc2lnbihyZXBsYWNlbWVudHMsIGRlZmF1bHRSZXBsYWNlbWVudHMpIDogZGVmYXVsdFJlcGxhY2VtZW50cykpO1xuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZExpdGVyYWxEYXRhKGZvcm1hdHRlciwgdHBsLCBvcHRzKSB7XG4gIGxldCBwcmVmaXggPSBcIkJBQkVMX1RQTCRcIjtcbiAgY29uc3QgcmF3ID0gdHBsLmpvaW4oXCJcIik7XG4gIGRvIHtcbiAgICBwcmVmaXggPSBcIiQkXCIgKyBwcmVmaXg7XG4gIH0gd2hpbGUgKHJhdy5pbmNsdWRlcyhwcmVmaXgpKTtcbiAgY29uc3Qge1xuICAgIG5hbWVzLFxuICAgIGNvZGVcbiAgfSA9IGJ1aWxkVGVtcGxhdGVDb2RlKHRwbCwgcHJlZml4KTtcbiAgY29uc3QgbWV0YWRhdGEgPSAoMCwgX3BhcnNlLmRlZmF1bHQpKGZvcm1hdHRlciwgZm9ybWF0dGVyLmNvZGUoY29kZSksIHtcbiAgICBwYXJzZXI6IG9wdHMucGFyc2VyLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0OiBuZXcgU2V0KG5hbWVzLmNvbmNhdChvcHRzLnBsYWNlaG9sZGVyV2hpdGVsaXN0ID8gQXJyYXkuZnJvbShvcHRzLnBsYWNlaG9sZGVyV2hpdGVsaXN0KSA6IFtdKSksXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuOiBvcHRzLnBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzOiBvcHRzLnByZXNlcnZlQ29tbWVudHMsXG4gICAgc3ludGFjdGljUGxhY2Vob2xkZXJzOiBvcHRzLnN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBtZXRhZGF0YSxcbiAgICBuYW1lc1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRUZW1wbGF0ZUNvZGUodHBsLCBwcmVmaXgpIHtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgbGV0IGNvZGUgPSB0cGxbMF07XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdHBsLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBgJHtwcmVmaXh9JHtpIC0gMX1gO1xuICAgIG5hbWVzLnB1c2godmFsdWUpO1xuICAgIGNvZGUgKz0gdmFsdWUgKyB0cGxbaV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lcyxcbiAgICBjb2RlXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdGVyYWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53438\n')},19815:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.merge = merge;\nexports.normalizeReplacements = normalizeReplacements;\nexports.validate = validate;\nconst _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.includes(n)) continue; t[n] = r[n]; } return t; }\nfunction merge(a, b) {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders\n  } = b;\n  return {\n    parser: Object.assign({}, a.parser, b.parser),\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  };\n}\nfunction validate(opts) {\n  if (opts != null && typeof opts !== "object") {\n    throw new Error("Unknown template options.");\n  }\n  const _ref = opts || {},\n    {\n      placeholderWhitelist,\n      placeholderPattern,\n      preserveComments,\n      syntacticPlaceholders\n    } = _ref,\n    parser = _objectWithoutPropertiesLoose(_ref, _excluded);\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error("\'.placeholderWhitelist\' must be a Set, null, or undefined");\n  }\n  if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {\n    throw new Error("\'.placeholderPattern\' must be a RegExp, false, null, or undefined");\n  }\n  if (preserveComments != null && typeof preserveComments !== "boolean") {\n    throw new Error("\'.preserveComments\' must be a boolean, null, or undefined");\n  }\n  if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {\n    throw new Error("\'.syntacticPlaceholders\' must be a boolean, null, or undefined");\n  }\n  if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {\n    throw new Error("\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible" + " with \'.syntacticPlaceholders: true\'");\n  }\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders\n  };\n}\nfunction normalizeReplacements(replacements) {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc["$" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === "object" || replacements == null) {\n    return replacements || undefined;\n  }\n  throw new Error("Template replacements must be an array, object, null, or undefined");\n}\n\n//# sourceMappingURL=options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4MTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLDZCQUE2QjtBQUM3QixnQkFBZ0I7QUFDaEI7QUFDQSwrQ0FBK0MsMEJBQTBCLFlBQVksdUJBQXVCLDhCQUE4Qiw2QkFBNkIsZUFBZTtBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL29wdGlvbnMuanM/ZDk1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMubm9ybWFsaXplUmVwbGFjZW1lbnRzID0gbm9ybWFsaXplUmVwbGFjZW1lbnRzO1xuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wicGxhY2Vob2xkZXJXaGl0ZWxpc3RcIiwgXCJwbGFjZWhvbGRlclBhdHRlcm5cIiwgXCJwcmVzZXJ2ZUNvbW1lbnRzXCIsIFwic3ludGFjdGljUGxhY2Vob2xkZXJzXCJdO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkgeyBpZiAobnVsbCA9PSByKSByZXR1cm4ge307IHZhciB0ID0ge307IGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHsgaWYgKGUuaW5jbHVkZXMobikpIGNvbnRpbnVlOyB0W25dID0gcltuXTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICBjb25zdCB7XG4gICAgcGxhY2Vob2xkZXJXaGl0ZWxpc3QgPSBhLnBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybiA9IGEucGxhY2Vob2xkZXJQYXR0ZXJuLFxuICAgIHByZXNlcnZlQ29tbWVudHMgPSBhLnByZXNlcnZlQ29tbWVudHMsXG4gICAgc3ludGFjdGljUGxhY2Vob2xkZXJzID0gYS5zeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgfSA9IGI7XG4gIHJldHVybiB7XG4gICAgcGFyc2VyOiBPYmplY3QuYXNzaWduKHt9LCBhLnBhcnNlciwgYi5wYXJzZXIpLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0LFxuICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGUob3B0cykge1xuICBpZiAob3B0cyAhPSBudWxsICYmIHR5cGVvZiBvcHRzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZW1wbGF0ZSBvcHRpb25zLlwiKTtcbiAgfVxuICBjb25zdCBfcmVmID0gb3B0cyB8fCB7fSxcbiAgICB7XG4gICAgICBwbGFjZWhvbGRlcldoaXRlbGlzdCxcbiAgICAgIHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICAgIHByZXNlcnZlQ29tbWVudHMsXG4gICAgICBzeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgICB9ID0gX3JlZixcbiAgICBwYXJzZXIgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmLCBfZXhjbHVkZWQpO1xuICBpZiAocGxhY2Vob2xkZXJXaGl0ZWxpc3QgIT0gbnVsbCAmJiAhKHBsYWNlaG9sZGVyV2hpdGVsaXN0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucGxhY2Vob2xkZXJXaGl0ZWxpc3QnIG11c3QgYmUgYSBTZXQsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAocGxhY2Vob2xkZXJQYXR0ZXJuICE9IG51bGwgJiYgIShwbGFjZWhvbGRlclBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHApICYmIHBsYWNlaG9sZGVyUGF0dGVybiAhPT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInLnBsYWNlaG9sZGVyUGF0dGVybicgbXVzdCBiZSBhIFJlZ0V4cCwgZmFsc2UsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAocHJlc2VydmVDb21tZW50cyAhPSBudWxsICYmIHR5cGVvZiBwcmVzZXJ2ZUNvbW1lbnRzICE9PSBcImJvb2xlYW5cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucHJlc2VydmVDb21tZW50cycgbXVzdCBiZSBhIGJvb2xlYW4sIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoc3ludGFjdGljUGxhY2Vob2xkZXJzICE9IG51bGwgJiYgdHlwZW9mIHN5bnRhY3RpY1BsYWNlaG9sZGVycyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInLnN5bnRhY3RpY1BsYWNlaG9sZGVycycgbXVzdCBiZSBhIGJvb2xlYW4sIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAoc3ludGFjdGljUGxhY2Vob2xkZXJzID09PSB0cnVlICYmIChwbGFjZWhvbGRlcldoaXRlbGlzdCAhPSBudWxsIHx8IHBsYWNlaG9sZGVyUGF0dGVybiAhPSBudWxsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIicucGxhY2Vob2xkZXJXaGl0ZWxpc3QnIGFuZCAnLnBsYWNlaG9sZGVyUGF0dGVybicgYXJlbid0IGNvbXBhdGlibGVcIiArIFwiIHdpdGggJy5zeW50YWN0aWNQbGFjZWhvbGRlcnM6IHRydWUnXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcGFyc2VyLFxuICAgIHBsYWNlaG9sZGVyV2hpdGVsaXN0OiBwbGFjZWhvbGRlcldoaXRlbGlzdCB8fCB1bmRlZmluZWQsXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuOiBwbGFjZWhvbGRlclBhdHRlcm4gPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHBsYWNlaG9sZGVyUGF0dGVybixcbiAgICBwcmVzZXJ2ZUNvbW1lbnRzOiBwcmVzZXJ2ZUNvbW1lbnRzID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmVzZXJ2ZUNvbW1lbnRzLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyczogc3ludGFjdGljUGxhY2Vob2xkZXJzID09IG51bGwgPyB1bmRlZmluZWQgOiBzeW50YWN0aWNQbGFjZWhvbGRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlcGxhY2VtZW50cyhyZXBsYWNlbWVudHMpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnRzKSkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHMucmVkdWNlKChhY2MsIHJlcGxhY2VtZW50LCBpKSA9PiB7XG4gICAgICBhY2NbXCIkXCIgKyBpXSA9IHJlcGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlcGxhY2VtZW50cyA9PT0gXCJvYmplY3RcIiB8fCByZXBsYWNlbWVudHMgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXBsYWNlbWVudHMgfHwgdW5kZWZpbmVkO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlRlbXBsYXRlIHJlcGxhY2VtZW50cyBtdXN0IGJlIGFuIGFycmF5LCBvYmplY3QsIG51bGwsIG9yIHVuZGVmaW5lZFwiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3B0aW9ucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19815\n')},24858:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = parseAndBuildMetadata;\nvar _t = __webpack_require__(2352);\nvar _parser = __webpack_require__(22172);\nvar _codeFrame = __webpack_require__(62882);\nconst {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse\n} = _t;\nconst PATTERN = /^[_$A-Z0-9]+$/;\nfunction parseAndBuildMetadata(formatter, code, opts) {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders\n  } = opts;\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n  removePropertiesDeep(ast, {\n    preserveComments\n  });\n  formatter.validate(ast);\n  const state = {\n    syntactic: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    legacy: {\n      placeholders: [],\n      placeholderNames: new Set()\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders\n  };\n  traverse(ast, placeholderVisitorHandler, state);\n  return Object.assign({\n    ast\n  }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);\n}\nfunction placeholderVisitorHandler(node, ancestors, state) {\n  var _state$placeholderWhi;\n  let name;\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error("%%foo%%-style placeholders can\'t be used when " + "\'.syntacticPlaceholders\' is false.");\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n  if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {\n    throw new Error("\'.placeholderWhitelist\' and \'.placeholderPattern\' aren\'t compatible" + " with \'.syntacticPlaceholders: true\'");\n  }\n  if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {\n    return;\n  }\n  ancestors = ancestors.slice();\n  const {\n    node: parent,\n    key\n  } = ancestors[ancestors.length - 1];\n  let type;\n  if (isStringLiteral(node) || isPlaceholder(node, {\n    expectedNode: "StringLiteral"\n  })) {\n    type = "string";\n  } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction(parent) && key === "params") {\n    type = "param";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = "statement";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = "statement";\n  } else {\n    type = "other";\n  }\n  const {\n    placeholders,\n    placeholderNames\n  } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name)\n  });\n  placeholderNames.add(name);\n}\nfunction resolveAncestors(ast, ancestors) {\n  let parent = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const {\n      key,\n      index\n    } = ancestors[i];\n    if (index === undefined) {\n      parent = parent[key];\n    } else {\n      parent = parent[key][index];\n    }\n  }\n  const {\n    key,\n    index\n  } = ancestors[ancestors.length - 1];\n  return {\n    parent,\n    key,\n    index\n  };\n}\nfunction parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push("placeholders");\n  }\n  parserOpts = Object.assign({\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: "module"\n  }, parserOpts, {\n    plugins\n  });\n  try {\n    return (0, _parser.parse)(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += "\\n" + (0, _codeFrame.codeFrameColumns)(code, {\n        start: loc\n      });\n      err.code = "BABEL_TEMPLATE_PARSE_ERROR";\n    }\n    throw err;\n  }\n}\n\n//# sourceMappingURL=parse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ4NTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixjQUFjLG1CQUFPLENBQUMsS0FBZTtBQUNyQyxpQkFBaUIsbUJBQU8sQ0FBQyxLQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90ZW1wbGF0ZS9saWIvcGFyc2UuanM/NGE5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlQW5kQnVpbGRNZXRhZGF0YTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX3BhcnNlciA9IHJlcXVpcmUoXCJAYmFiZWwvcGFyc2VyXCIpO1xudmFyIF9jb2RlRnJhbWUgPSByZXF1aXJlKFwiQGJhYmVsL2NvZGUtZnJhbWVcIik7XG5jb25zdCB7XG4gIGlzQ2FsbEV4cHJlc3Npb24sXG4gIGlzRXhwcmVzc2lvblN0YXRlbWVudCxcbiAgaXNGdW5jdGlvbixcbiAgaXNJZGVudGlmaWVyLFxuICBpc0pTWElkZW50aWZpZXIsXG4gIGlzTmV3RXhwcmVzc2lvbixcbiAgaXNQbGFjZWhvbGRlcixcbiAgaXNTdGF0ZW1lbnQsXG4gIGlzU3RyaW5nTGl0ZXJhbCxcbiAgcmVtb3ZlUHJvcGVydGllc0RlZXAsXG4gIHRyYXZlcnNlXG59ID0gX3Q7XG5jb25zdCBQQVRURVJOID0gL15bXyRBLVowLTldKyQvO1xuZnVuY3Rpb24gcGFyc2VBbmRCdWlsZE1ldGFkYXRhKGZvcm1hdHRlciwgY29kZSwgb3B0cykge1xuICBjb25zdCB7XG4gICAgcGxhY2Vob2xkZXJXaGl0ZWxpc3QsXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuLFxuICAgIHByZXNlcnZlQ29tbWVudHMsXG4gICAgc3ludGFjdGljUGxhY2Vob2xkZXJzXG4gIH0gPSBvcHRzO1xuICBjb25zdCBhc3QgPSBwYXJzZVdpdGhDb2RlRnJhbWUoY29kZSwgb3B0cy5wYXJzZXIsIHN5bnRhY3RpY1BsYWNlaG9sZGVycyk7XG4gIHJlbW92ZVByb3BlcnRpZXNEZWVwKGFzdCwge1xuICAgIHByZXNlcnZlQ29tbWVudHNcbiAgfSk7XG4gIGZvcm1hdHRlci52YWxpZGF0ZShhc3QpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBzeW50YWN0aWM6IHtcbiAgICAgIHBsYWNlaG9sZGVyczogW10sXG4gICAgICBwbGFjZWhvbGRlck5hbWVzOiBuZXcgU2V0KClcbiAgICB9LFxuICAgIGxlZ2FjeToge1xuICAgICAgcGxhY2Vob2xkZXJzOiBbXSxcbiAgICAgIHBsYWNlaG9sZGVyTmFtZXM6IG5ldyBTZXQoKVxuICAgIH0sXG4gICAgcGxhY2Vob2xkZXJXaGl0ZWxpc3QsXG4gICAgcGxhY2Vob2xkZXJQYXR0ZXJuLFxuICAgIHN5bnRhY3RpY1BsYWNlaG9sZGVyc1xuICB9O1xuICB0cmF2ZXJzZShhc3QsIHBsYWNlaG9sZGVyVmlzaXRvckhhbmRsZXIsIHN0YXRlKTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgIGFzdFxuICB9LCBzdGF0ZS5zeW50YWN0aWMucGxhY2Vob2xkZXJzLmxlbmd0aCA/IHN0YXRlLnN5bnRhY3RpYyA6IHN0YXRlLmxlZ2FjeSk7XG59XG5mdW5jdGlvbiBwbGFjZWhvbGRlclZpc2l0b3JIYW5kbGVyKG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpIHtcbiAgdmFyIF9zdGF0ZSRwbGFjZWhvbGRlcldoaTtcbiAgbGV0IG5hbWU7XG4gIGxldCBoYXNTeW50YWN0aWNQbGFjZWhvbGRlcnMgPSBzdGF0ZS5zeW50YWN0aWMucGxhY2Vob2xkZXJzLmxlbmd0aCA+IDA7XG4gIGlmIChpc1BsYWNlaG9sZGVyKG5vZGUpKSB7XG4gICAgaWYgKHN0YXRlLnN5bnRhY3RpY1BsYWNlaG9sZGVycyA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiUlZm9vJSUtc3R5bGUgcGxhY2Vob2xkZXJzIGNhbid0IGJlIHVzZWQgd2hlbiBcIiArIFwiJy5zeW50YWN0aWNQbGFjZWhvbGRlcnMnIGlzIGZhbHNlLlwiKTtcbiAgICB9XG4gICAgbmFtZSA9IG5vZGUubmFtZS5uYW1lO1xuICAgIGhhc1N5bnRhY3RpY1BsYWNlaG9sZGVycyA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaGFzU3ludGFjdGljUGxhY2Vob2xkZXJzIHx8IHN0YXRlLnN5bnRhY3RpY1BsYWNlaG9sZGVycykge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpc0lkZW50aWZpZXIobm9kZSkgfHwgaXNKU1hJZGVudGlmaWVyKG5vZGUpKSB7XG4gICAgbmFtZSA9IG5vZGUubmFtZTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZ0xpdGVyYWwobm9kZSkpIHtcbiAgICBuYW1lID0gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGhhc1N5bnRhY3RpY1BsYWNlaG9sZGVycyAmJiAoc3RhdGUucGxhY2Vob2xkZXJQYXR0ZXJuICE9IG51bGwgfHwgc3RhdGUucGxhY2Vob2xkZXJXaGl0ZWxpc3QgIT0gbnVsbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCInLnBsYWNlaG9sZGVyV2hpdGVsaXN0JyBhbmQgJy5wbGFjZWhvbGRlclBhdHRlcm4nIGFyZW4ndCBjb21wYXRpYmxlXCIgKyBcIiB3aXRoICcuc3ludGFjdGljUGxhY2Vob2xkZXJzOiB0cnVlJ1wiKTtcbiAgfVxuICBpZiAoIWhhc1N5bnRhY3RpY1BsYWNlaG9sZGVycyAmJiAoc3RhdGUucGxhY2Vob2xkZXJQYXR0ZXJuID09PSBmYWxzZSB8fCAhKHN0YXRlLnBsYWNlaG9sZGVyUGF0dGVybiB8fCBQQVRURVJOKS50ZXN0KG5hbWUpKSAmJiAhKChfc3RhdGUkcGxhY2Vob2xkZXJXaGkgPSBzdGF0ZS5wbGFjZWhvbGRlcldoaXRlbGlzdCkgIT0gbnVsbCAmJiBfc3RhdGUkcGxhY2Vob2xkZXJXaGkuaGFzKG5hbWUpKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuc2xpY2UoKTtcbiAgY29uc3Qge1xuICAgIG5vZGU6IHBhcmVudCxcbiAgICBrZXlcbiAgfSA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gIGxldCB0eXBlO1xuICBpZiAoaXNTdHJpbmdMaXRlcmFsKG5vZGUpIHx8IGlzUGxhY2Vob2xkZXIobm9kZSwge1xuICAgIGV4cGVjdGVkTm9kZTogXCJTdHJpbmdMaXRlcmFsXCJcbiAgfSkpIHtcbiAgICB0eXBlID0gXCJzdHJpbmdcIjtcbiAgfSBlbHNlIGlmIChpc05ld0V4cHJlc3Npb24ocGFyZW50KSAmJiBrZXkgPT09IFwiYXJndW1lbnRzXCIgfHwgaXNDYWxsRXhwcmVzc2lvbihwYXJlbnQpICYmIGtleSA9PT0gXCJhcmd1bWVudHNcIiB8fCBpc0Z1bmN0aW9uKHBhcmVudCkgJiYga2V5ID09PSBcInBhcmFtc1wiKSB7XG4gICAgdHlwZSA9IFwicGFyYW1cIjtcbiAgfSBlbHNlIGlmIChpc0V4cHJlc3Npb25TdGF0ZW1lbnQocGFyZW50KSAmJiAhaXNQbGFjZWhvbGRlcihub2RlKSkge1xuICAgIHR5cGUgPSBcInN0YXRlbWVudFwiO1xuICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5zbGljZSgwLCAtMSk7XG4gIH0gZWxzZSBpZiAoaXNTdGF0ZW1lbnQobm9kZSkgJiYgaXNQbGFjZWhvbGRlcihub2RlKSkge1xuICAgIHR5cGUgPSBcInN0YXRlbWVudFwiO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBcIm90aGVyXCI7XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVycyxcbiAgICBwbGFjZWhvbGRlck5hbWVzXG4gIH0gPSAhaGFzU3ludGFjdGljUGxhY2Vob2xkZXJzID8gc3RhdGUubGVnYWN5IDogc3RhdGUuc3ludGFjdGljO1xuICBwbGFjZWhvbGRlcnMucHVzaCh7XG4gICAgbmFtZSxcbiAgICB0eXBlLFxuICAgIHJlc29sdmU6IGFzdCA9PiByZXNvbHZlQW5jZXN0b3JzKGFzdCwgYW5jZXN0b3JzKSxcbiAgICBpc0R1cGxpY2F0ZTogcGxhY2Vob2xkZXJOYW1lcy5oYXMobmFtZSlcbiAgfSk7XG4gIHBsYWNlaG9sZGVyTmFtZXMuYWRkKG5hbWUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9ycyhhc3QsIGFuY2VzdG9ycykge1xuICBsZXQgcGFyZW50ID0gYXN0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBpbmRleFxuICAgIH0gPSBhbmNlc3RvcnNbaV07XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRba2V5XVtpbmRleF07XG4gICAgfVxuICB9XG4gIGNvbnN0IHtcbiAgICBrZXksXG4gICAgaW5kZXhcbiAgfSA9IGFuY2VzdG9yc1thbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gIHJldHVybiB7XG4gICAgcGFyZW50LFxuICAgIGtleSxcbiAgICBpbmRleFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VXaXRoQ29kZUZyYW1lKGNvZGUsIHBhcnNlck9wdHMsIHN5bnRhY3RpY1BsYWNlaG9sZGVycykge1xuICBjb25zdCBwbHVnaW5zID0gKHBhcnNlck9wdHMucGx1Z2lucyB8fCBbXSkuc2xpY2UoKTtcbiAgaWYgKHN5bnRhY3RpY1BsYWNlaG9sZGVycyAhPT0gZmFsc2UpIHtcbiAgICBwbHVnaW5zLnB1c2goXCJwbGFjZWhvbGRlcnNcIik7XG4gIH1cbiAgcGFyc2VyT3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiB0cnVlLFxuICAgIGFsbG93U3VwZXJPdXRzaWRlTWV0aG9kOiB0cnVlLFxuICAgIHNvdXJjZVR5cGU6IFwibW9kdWxlXCJcbiAgfSwgcGFyc2VyT3B0cywge1xuICAgIHBsdWdpbnNcbiAgfSk7XG4gIHRyeSB7XG4gICAgcmV0dXJuICgwLCBfcGFyc2VyLnBhcnNlKShjb2RlLCBwYXJzZXJPcHRzKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgbG9jID0gZXJyLmxvYztcbiAgICBpZiAobG9jKSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIlxcblwiICsgKDAsIF9jb2RlRnJhbWUuY29kZUZyYW1lQ29sdW1ucykoY29kZSwge1xuICAgICAgICBzdGFydDogbG9jXG4gICAgICB9KTtcbiAgICAgIGVyci5jb2RlID0gXCJCQUJFTF9URU1QTEFURV9QQVJTRV9FUlJPUlwiO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24858\n')},97427:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = populatePlaceholders;\nvar _t = __webpack_require__(2352);\nconst {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate\n} = _t;\nfunction populatePlaceholders(metadata, replacements) {\n  const ast = cloneNode(metadata.ast);\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!hasOwnProperty.call(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n        throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set([\'${placeholderName}\'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`);\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution "${key}" given`);\n      }\n    });\n  }\n  metadata.placeholders.slice().reverse().forEach(placeholder => {\n    try {\n      applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);\n    } catch (e) {\n      e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;\n      throw e;\n    }\n  });\n  return ast;\n}\nfunction applyReplacement(placeholder, ast, replacement) {\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === "object") {\n      replacement = cloneNode(replacement);\n    }\n  }\n  const {\n    parent,\n    key,\n    index\n  } = placeholder.resolve(ast);\n  if (placeholder.type === "string") {\n    if (typeof replacement === "string") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error("Expected string substitution");\n    }\n  } else if (placeholder.type === "statement") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === "string") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === "string") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === "param") {\n    if (typeof replacement === "string") {\n      replacement = identifier(replacement);\n    }\n    if (index === undefined) throw new Error("Assertion failure.");\n  } else {\n    if (typeof replacement === "string") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error("Cannot replace single expression with an array.");\n    }\n  }\n  function set(parent, key, value) {\n    const node = parent[key];\n    parent[key] = value;\n    if (node.type === "Identifier" || node.type === "Placeholder") {\n      if (node.typeAnnotation) {\n        value.typeAnnotation = node.typeAnnotation;\n      }\n      if (node.optional) {\n        value.optional = node.optional;\n      }\n      if (node.decorators) {\n        value.decorators = node.decorators;\n      }\n    }\n  }\n  if (index === undefined) {\n    validate(parent, key, replacement);\n    set(parent, key, replacement);\n  } else {\n    const items = parent[key].slice();\n    if (placeholder.type === "statement" || placeholder.type === "param") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        set(items, index, replacement);\n      }\n    } else {\n      set(items, index, replacement);\n    }\n    validate(parent, key, items);\n    parent[key] = items;\n  }\n}\n\n//# sourceMappingURL=populate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc0MjcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsZ0JBQWdCO0FBQzdFO0FBQ0EsZ0JBQWdCLDZEQUE2RCxnQkFBZ0I7QUFDN0YsZ0JBQWdCLHdCQUF3QixnQkFBZ0IsSUFBSTtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlELElBQUk7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0RBQWtELGlCQUFpQixLQUFLLFVBQVU7QUFDbEY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdGVtcGxhdGUvbGliL3BvcHVsYXRlLmpzPzYzZjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwb3B1bGF0ZVBsYWNlaG9sZGVycztcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGJsb2NrU3RhdGVtZW50LFxuICBjbG9uZU5vZGUsXG4gIGVtcHR5U3RhdGVtZW50LFxuICBleHByZXNzaW9uU3RhdGVtZW50LFxuICBpZGVudGlmaWVyLFxuICBpc1N0YXRlbWVudCxcbiAgaXNTdHJpbmdMaXRlcmFsLFxuICBzdHJpbmdMaXRlcmFsLFxuICB2YWxpZGF0ZVxufSA9IF90O1xuZnVuY3Rpb24gcG9wdWxhdGVQbGFjZWhvbGRlcnMobWV0YWRhdGEsIHJlcGxhY2VtZW50cykge1xuICBjb25zdCBhc3QgPSBjbG9uZU5vZGUobWV0YWRhdGEuYXN0KTtcbiAgaWYgKHJlcGxhY2VtZW50cykge1xuICAgIG1ldGFkYXRhLnBsYWNlaG9sZGVycy5mb3JFYWNoKHBsYWNlaG9sZGVyID0+IHtcbiAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZXBsYWNlbWVudHMsIHBsYWNlaG9sZGVyLm5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyTmFtZSA9IHBsYWNlaG9sZGVyLm5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3I6IE5vIHN1YnN0aXR1dGlvbiBnaXZlbiBmb3IgXCIke3BsYWNlaG9sZGVyTmFtZX1cIi4gSWYgdGhpcyBpcyBub3QgbWVhbnQgdG8gYmUgYVxuICAgICAgICAgICAgcGxhY2Vob2xkZXIgeW91IG1heSB3YW50IHRvIGNvbnNpZGVyIHBhc3Npbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyB0byBAYmFiZWwvdGVtcGxhdGU6XG4gICAgICAgICAgICAtIHsgcGxhY2Vob2xkZXJQYXR0ZXJuOiBmYWxzZSwgcGxhY2Vob2xkZXJXaGl0ZWxpc3Q6IG5ldyBTZXQoWycke3BsYWNlaG9sZGVyTmFtZX0nXSl9XG4gICAgICAgICAgICAtIHsgcGxhY2Vob2xkZXJQYXR0ZXJuOiAvXiR7cGxhY2Vob2xkZXJOYW1lfSQvIH1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhyZXBsYWNlbWVudHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmICghbWV0YWRhdGEucGxhY2Vob2xkZXJOYW1lcy5oYXMoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3Vic3RpdHV0aW9uIFwiJHtrZXl9XCIgZ2l2ZW5gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtZXRhZGF0YS5wbGFjZWhvbGRlcnMuc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaChwbGFjZWhvbGRlciA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGFwcGx5UmVwbGFjZW1lbnQocGxhY2Vob2xkZXIsIGFzdCwgcmVwbGFjZW1lbnRzICYmIHJlcGxhY2VtZW50c1twbGFjZWhvbGRlci5uYW1lXSB8fCBudWxsKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgQGJhYmVsL3RlbXBsYXRlIHBsYWNlaG9sZGVyIFwiJHtwbGFjZWhvbGRlci5uYW1lfVwiOiAke2UubWVzc2FnZX1gO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYXN0O1xufVxuZnVuY3Rpb24gYXBwbHlSZXBsYWNlbWVudChwbGFjZWhvbGRlciwgYXN0LCByZXBsYWNlbWVudCkge1xuICBpZiAocGxhY2Vob2xkZXIuaXNEdXBsaWNhdGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gcmVwbGFjZW1lbnQubWFwKG5vZGUgPT4gY2xvbmVOb2RlKG5vZGUpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXBsYWNlbWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgcmVwbGFjZW1lbnQgPSBjbG9uZU5vZGUocmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB7XG4gICAgcGFyZW50LFxuICAgIGtleSxcbiAgICBpbmRleFxuICB9ID0gcGxhY2Vob2xkZXIucmVzb2x2ZShhc3QpO1xuICBpZiAocGxhY2Vob2xkZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gc3RyaW5nTGl0ZXJhbChyZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGlmICghcmVwbGFjZW1lbnQgfHwgIWlzU3RyaW5nTGl0ZXJhbChyZXBsYWNlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHN0cmluZyBzdWJzdGl0dXRpb25cIik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBsYWNlaG9sZGVyLnR5cGUgPT09IFwic3RhdGVtZW50XCIpIHtcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgICAgICByZXBsYWNlbWVudCA9IGVtcHR5U3RhdGVtZW50KCk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gYmxvY2tTdGF0ZW1lbnQocmVwbGFjZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBleHByZXNzaW9uU3RhdGVtZW50KGlkZW50aWZpZXIocmVwbGFjZW1lbnQpKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzU3RhdGVtZW50KHJlcGxhY2VtZW50KSkge1xuICAgICAgICByZXBsYWNlbWVudCA9IGV4cHJlc3Npb25TdGF0ZW1lbnQocmVwbGFjZW1lbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVwbGFjZW1lbnQgJiYgIUFycmF5LmlzQXJyYXkocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXBsYWNlbWVudCA9IGlkZW50aWZpZXIocmVwbGFjZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTdGF0ZW1lbnQocmVwbGFjZW1lbnQpKSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBleHByZXNzaW9uU3RhdGVtZW50KHJlcGxhY2VtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwbGFjZWhvbGRlci50eXBlID09PSBcInBhcmFtXCIpIHtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXBsYWNlbWVudCA9IGlkZW50aWZpZXIocmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWx1cmUuXCIpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gaWRlbnRpZmllcihyZXBsYWNlbWVudCk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlcGxhY2Ugc2luZ2xlIGV4cHJlc3Npb24gd2l0aCBhbiBhcnJheS5cIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldChwYXJlbnQsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBub2RlID0gcGFyZW50W2tleV07XG4gICAgcGFyZW50W2tleV0gPSB2YWx1ZTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgICAgaWYgKG5vZGUudHlwZUFubm90YXRpb24pIHtcbiAgICAgICAgdmFsdWUudHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICAgICAgdmFsdWUub3B0aW9uYWwgPSBub2RlLm9wdGlvbmFsO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZGVjb3JhdG9ycykge1xuICAgICAgICB2YWx1ZS5kZWNvcmF0b3JzID0gbm9kZS5kZWNvcmF0b3JzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRlKHBhcmVudCwga2V5LCByZXBsYWNlbWVudCk7XG4gICAgc2V0KHBhcmVudCwga2V5LCByZXBsYWNlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaXRlbXMgPSBwYXJlbnRba2V5XS5zbGljZSgpO1xuICAgIGlmIChwbGFjZWhvbGRlci50eXBlID09PSBcInN0YXRlbWVudFwiIHx8IHBsYWNlaG9sZGVyLnR5cGUgPT09IFwicGFyYW1cIikge1xuICAgICAgaWYgKHJlcGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlbWVudCkpIHtcbiAgICAgICAgaXRlbXMuc3BsaWNlKGluZGV4LCAxLCAuLi5yZXBsYWNlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXQoaXRlbXMsIGluZGV4LCByZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldChpdGVtcywgaW5kZXgsIHJlcGxhY2VtZW50KTtcbiAgICB9XG4gICAgdmFsaWRhdGUocGFyZW50LCBrZXksIGl0ZW1zKTtcbiAgICBwYXJlbnRba2V5XSA9IGl0ZW1zO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvcHVsYXRlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///97427\n')},95252:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = stringTemplate;\nvar _options = __webpack_require__(19815);\nvar _parse = __webpack_require__(24858);\nvar _populate = __webpack_require__(97427);\nfunction stringTemplate(formatter, code, opts) {\n  code = formatter.code(code);\n  let metadata;\n  return arg => {\n    const replacements = (0, _options.normalizeReplacements)(arg);\n    if (!metadata) metadata = (0, _parse.default)(formatter, code, opts);\n    return formatter.unwrap((0, _populate.default)(metadata, replacements));\n  };\n}\n\n//# sourceMappingURL=string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUyNTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQyxhQUFhLG1CQUFPLENBQUMsS0FBWTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RlbXBsYXRlL2xpYi9zdHJpbmcuanM/MTAxYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHN0cmluZ1RlbXBsYXRlO1xudmFyIF9vcHRpb25zID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbnZhciBfcGFyc2UgPSByZXF1aXJlKFwiLi9wYXJzZS5qc1wiKTtcbnZhciBfcG9wdWxhdGUgPSByZXF1aXJlKFwiLi9wb3B1bGF0ZS5qc1wiKTtcbmZ1bmN0aW9uIHN0cmluZ1RlbXBsYXRlKGZvcm1hdHRlciwgY29kZSwgb3B0cykge1xuICBjb2RlID0gZm9ybWF0dGVyLmNvZGUoY29kZSk7XG4gIGxldCBtZXRhZGF0YTtcbiAgcmV0dXJuIGFyZyA9PiB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnRzID0gKDAsIF9vcHRpb25zLm5vcm1hbGl6ZVJlcGxhY2VtZW50cykoYXJnKTtcbiAgICBpZiAoIW1ldGFkYXRhKSBtZXRhZGF0YSA9ICgwLCBfcGFyc2UuZGVmYXVsdCkoZm9ybWF0dGVyLCBjb2RlLCBvcHRzKTtcbiAgICByZXR1cm4gZm9ybWF0dGVyLnVud3JhcCgoMCwgX3BvcHVsYXRlLmRlZmF1bHQpKG1ldGFkYXRhLCByZXBsYWNlbWVudHMpKTtcbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///95252\n')},37411:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.getCachedPaths = getCachedPaths;\nexports.getOrCreateCachedPaths = getOrCreateCachedPaths;\nexports.scope = exports.path = void 0;\nlet pathsCache = exports.path = new WeakMap();\nlet scope = exports.scope = new WeakMap();\nfunction clear() {\n  clearPath();\n  clearScope();\n}\nfunction clearPath() {\n  exports.path = pathsCache = new WeakMap();\n}\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}\nconst nullHub = Object.freeze({});\nfunction getCachedPaths(hub, parent) {\n  var _pathsCache$get, _hub;\n  {\n    hub = null;\n  }\n  return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);\n}\nfunction getOrCreateCachedPaths(hub, parent) {\n  var _hub2, _hub3;\n  {\n    hub = null;\n  }\n  let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);\n  if (!parents) pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = new WeakMap());\n  let paths = parents.get(parent);\n  if (!paths) parents.set(parent, paths = new Map());\n  return paths;\n}\n\n//# sourceMappingURL=cache.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc0MTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsc0JBQXNCO0FBQ3RCLDhCQUE4QjtBQUM5QixhQUFhLEdBQUcsWUFBWTtBQUM1QixpQkFBaUIsWUFBWTtBQUM3QixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsWUFBWTtBQUNkO0FBQ0E7QUFDQSxFQUFFLGFBQWE7QUFDZjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvY2FjaGUuanM/ZTc1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2xlYXIgPSBjbGVhcjtcbmV4cG9ydHMuY2xlYXJQYXRoID0gY2xlYXJQYXRoO1xuZXhwb3J0cy5jbGVhclNjb3BlID0gY2xlYXJTY29wZTtcbmV4cG9ydHMuZ2V0Q2FjaGVkUGF0aHMgPSBnZXRDYWNoZWRQYXRocztcbmV4cG9ydHMuZ2V0T3JDcmVhdGVDYWNoZWRQYXRocyA9IGdldE9yQ3JlYXRlQ2FjaGVkUGF0aHM7XG5leHBvcnRzLnNjb3BlID0gZXhwb3J0cy5wYXRoID0gdm9pZCAwO1xubGV0IHBhdGhzQ2FjaGUgPSBleHBvcnRzLnBhdGggPSBuZXcgV2Vha01hcCgpO1xubGV0IHNjb3BlID0gZXhwb3J0cy5zY29wZSA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgY2xlYXJQYXRoKCk7XG4gIGNsZWFyU2NvcGUoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyUGF0aCgpIHtcbiAgZXhwb3J0cy5wYXRoID0gcGF0aHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG59XG5mdW5jdGlvbiBjbGVhclNjb3BlKCkge1xuICBleHBvcnRzLnNjb3BlID0gc2NvcGUgPSBuZXcgV2Vha01hcCgpO1xufVxuY29uc3QgbnVsbEh1YiA9IE9iamVjdC5mcmVlemUoe30pO1xuZnVuY3Rpb24gZ2V0Q2FjaGVkUGF0aHMoaHViLCBwYXJlbnQpIHtcbiAgdmFyIF9wYXRoc0NhY2hlJGdldCwgX2h1YjtcbiAge1xuICAgIGh1YiA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIChfcGF0aHNDYWNoZSRnZXQgPSBwYXRoc0NhY2hlLmdldCgoX2h1YiA9IGh1YikgIT0gbnVsbCA/IF9odWIgOiBudWxsSHViKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXRoc0NhY2hlJGdldC5nZXQocGFyZW50KTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlQ2FjaGVkUGF0aHMoaHViLCBwYXJlbnQpIHtcbiAgdmFyIF9odWIyLCBfaHViMztcbiAge1xuICAgIGh1YiA9IG51bGw7XG4gIH1cbiAgbGV0IHBhcmVudHMgPSBwYXRoc0NhY2hlLmdldCgoX2h1YjIgPSBodWIpICE9IG51bGwgPyBfaHViMiA6IG51bGxIdWIpO1xuICBpZiAoIXBhcmVudHMpIHBhdGhzQ2FjaGUuc2V0KChfaHViMyA9IGh1YikgIT0gbnVsbCA/IF9odWIzIDogbnVsbEh1YiwgcGFyZW50cyA9IG5ldyBXZWFrTWFwKCkpO1xuICBsZXQgcGF0aHMgPSBwYXJlbnRzLmdldChwYXJlbnQpO1xuICBpZiAoIXBhdGhzKSBwYXJlbnRzLnNldChwYXJlbnQsIHBhdGhzID0gbmV3IE1hcCgpKTtcbiAgcmV0dXJuIHBhdGhzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37411\n')},1602:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _index = __webpack_require__(29709);\nvar _t = __webpack_require__(2352);\nvar _context = __webpack_require__(79578);\nconst {\n  VISITOR_KEYS\n} = _t;\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n    for (const key of keys) {\n      if (node[key]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  create(node, container, key, listKey) {\n    return _index.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container,\n      key: key,\n      listKey\n    });\n  }\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n    return this.visitQueue(queue);\n  }\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n    let visitIndex = 0;\n    for (; visitIndex < queue.length;) {\n      const path = queue[visitIndex];\n      visitIndex++;\n      _context.resync.call(path);\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        _context.pushContext.call(path, this);\n      }\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n    for (let i = 0; i < visitIndex; i++) {\n      _context.popContext.call(queue[i]);\n    }\n    this.queue = null;\n    return stop;\n  }\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n}\nexports["default"] = TraversalContext;\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxLQUFpQjtBQUN0QyxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsS0FBbUI7QUFDMUM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTs7QUFFZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9jb250ZXh0LmpzPzU3MWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vcGF0aC9pbmRleC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9wYXRoL2NvbnRleHQuanNcIik7XG5jb25zdCB7XG4gIFZJU0lUT1JfS0VZU1xufSA9IF90O1xuY2xhc3MgVHJhdmVyc2FsQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHNjb3BlLCBvcHRzLCBzdGF0ZSwgcGFyZW50UGF0aCkge1xuICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgIHRoaXMucHJpb3JpdHlRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnRQYXRoID0gcGFyZW50UGF0aDtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gIH1cbiAgc2hvdWxkVmlzaXQobm9kZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdHM7XG4gICAgaWYgKG9wdHMuZW50ZXIgfHwgb3B0cy5leGl0KSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAob3B0c1tub2RlLnR5cGVdKSByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBrZXlzID0gVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gICAgaWYgKCEoa2V5cyAhPSBudWxsICYmIGtleXMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgIGlmIChub2RlW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjcmVhdGUobm9kZSwgY29udGFpbmVyLCBrZXksIGxpc3RLZXkpIHtcbiAgICByZXR1cm4gX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICAgIHBhcmVudFBhdGg6IHRoaXMucGFyZW50UGF0aCxcbiAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGtleToga2V5LFxuICAgICAgbGlzdEtleVxuICAgIH0pO1xuICB9XG4gIG1heWJlUXVldWUocGF0aCwgbm90UHJpb3JpdHkpIHtcbiAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgaWYgKG5vdFByaW9yaXR5KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHJpb3JpdHlRdWV1ZS5wdXNoKHBhdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB2aXNpdE11bHRpcGxlKGNvbnRhaW5lciwgcGFyZW50LCBsaXN0S2V5KSB7XG4gICAgaWYgKGNvbnRhaW5lci5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IGNvbnRhaW5lci5sZW5ndGg7IGtleSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gY29udGFpbmVyW2tleV07XG4gICAgICBpZiAobm9kZSAmJiB0aGlzLnNob3VsZFZpc2l0KG5vZGUpKSB7XG4gICAgICAgIHF1ZXVlLnB1c2godGhpcy5jcmVhdGUocGFyZW50LCBjb250YWluZXIsIGtleSwgbGlzdEtleSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy52aXNpdFF1ZXVlKHF1ZXVlKTtcbiAgfVxuICB2aXNpdFNpbmdsZShub2RlLCBrZXkpIHtcbiAgICBpZiAodGhpcy5zaG91bGRWaXNpdChub2RlW2tleV0pKSB7XG4gICAgICByZXR1cm4gdGhpcy52aXNpdFF1ZXVlKFt0aGlzLmNyZWF0ZShub2RlLCBub2RlLCBrZXkpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdmlzaXRRdWV1ZShxdWV1ZSkge1xuICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICB0aGlzLnByaW9yaXR5UXVldWUgPSBbXTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFdlYWtTZXQoKTtcbiAgICBsZXQgc3RvcCA9IGZhbHNlO1xuICAgIGxldCB2aXNpdEluZGV4ID0gMDtcbiAgICBmb3IgKDsgdmlzaXRJbmRleCA8IHF1ZXVlLmxlbmd0aDspIHtcbiAgICAgIGNvbnN0IHBhdGggPSBxdWV1ZVt2aXNpdEluZGV4XTtcbiAgICAgIHZpc2l0SW5kZXgrKztcbiAgICAgIF9jb250ZXh0LnJlc3luYy5jYWxsKHBhdGgpO1xuICAgICAgaWYgKHBhdGguY29udGV4dHMubGVuZ3RoID09PSAwIHx8IHBhdGguY29udGV4dHNbcGF0aC5jb250ZXh0cy5sZW5ndGggLSAxXSAhPT0gdGhpcykge1xuICAgICAgICBfY29udGV4dC5wdXNoQ29udGV4dC5jYWxsKHBhdGgsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKHBhdGgua2V5ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbm9kZVxuICAgICAgfSA9IHBhdGg7XG4gICAgICBpZiAodmlzaXRlZC5oYXMobm9kZSkpIGNvbnRpbnVlO1xuICAgICAgaWYgKG5vZGUpIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgaWYgKHBhdGgudmlzaXQoKSkge1xuICAgICAgICBzdG9wID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wcmlvcml0eVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBzdG9wID0gdGhpcy52aXNpdFF1ZXVlKHRoaXMucHJpb3JpdHlRdWV1ZSk7XG4gICAgICAgIHRoaXMucHJpb3JpdHlRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgICAgIGlmIChzdG9wKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2aXNpdEluZGV4OyBpKyspIHtcbiAgICAgIF9jb250ZXh0LnBvcENvbnRleHQuY2FsbChxdWV1ZVtpXSk7XG4gICAgfVxuICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgIHJldHVybiBzdG9wO1xuICB9XG4gIHZpc2l0KG5vZGUsIGtleSkge1xuICAgIGNvbnN0IG5vZGVzID0gbm9kZVtrZXldO1xuICAgIGlmICghbm9kZXMpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0TXVsdGlwbGUobm9kZXMsIG5vZGUsIGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0U2luZ2xlKG5vZGUsIGtleSk7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBUcmF2ZXJzYWxDb250ZXh0O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1602\n')},17878:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nclass Hub {\n  getCode() {}\n  getScope() {}\n  addHelper() {\n    throw new Error("Helpers are not supported by the default hub.");\n  }\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n}\nexports["default"] = Hub;\n\n//# sourceMappingURL=hub.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4NzguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL2h1Yi5qcz8zYTUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuY2xhc3MgSHViIHtcbiAgZ2V0Q29kZSgpIHt9XG4gIGdldFNjb3BlKCkge31cbiAgYWRkSGVscGVyKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkhlbHBlcnMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGRlZmF1bHQgaHViLlwiKTtcbiAgfVxuICBidWlsZEVycm9yKG5vZGUsIG1zZywgRXJyb3IgPSBUeXBlRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKG1zZyk7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEh1YjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHViLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///17878\n')},25781:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "Hub", ({\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n}));\nObject.defineProperty(exports, "NodePath", ({\n  enumerable: true,\n  get: function () {\n    return _index.default;\n  }\n}));\nObject.defineProperty(exports, "Scope", ({\n  enumerable: true,\n  get: function () {\n    return _index2.default;\n  }\n}));\nexports.visitors = exports["default"] = void 0;\n__webpack_require__(79578);\nvar visitors = __webpack_require__(34950);\nexports.visitors = visitors;\nvar _t = __webpack_require__(2352);\nvar cache = __webpack_require__(37411);\nvar _traverseNode = __webpack_require__(22264);\nvar _index = __webpack_require__(29709);\nvar _index2 = __webpack_require__(86814);\nvar _hub = __webpack_require__(17878);\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\nfunction traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {\n  if (!parent) return;\n  if (!opts.noScope && !scope) {\n    if (parent.type !== "Program" && parent.type !== "File") {\n      throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + `Instead of that you tried to traverse a ${parent.type} node without ` + "passing scope and parentPath.");\n    }\n  }\n  if (!parentPath && visitSelf) {\n    throw new Error("visitSelf can only be used when providing a NodePath.");\n  }\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n  visitors.explode(opts);\n  (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);\n}\nvar _default = exports["default"] = traverse;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\ntraverse.cheap = function (node, enter) {\n  traverseFast(node, enter);\n  return;\n};\ntraverse.node = function (node, opts, scope, state, path, skipKeys) {\n  (0, _traverseNode.traverseNode)(node, opts, scope, state, path, skipKeys);\n};\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n};\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\ntraverse.cache = cache;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjU3ODEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUNBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCLEdBQUcsa0JBQWU7QUFDbEMsbUJBQU8sQ0FBQyxLQUFtQjtBQUMzQixlQUFlLG1CQUFPLENBQUMsS0FBZTtBQUN0QyxnQkFBZ0I7QUFDaEIsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLEtBQVk7QUFDaEMsb0JBQW9CLG1CQUFPLENBQUMsS0FBb0I7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLEtBQWlCO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxLQUFrQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsS0FBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsNklBQTZJLGFBQWE7QUFDMUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL2luZGV4LmpzPzVhYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIdWJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2h1Yi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vZGVQYXRoXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNjb3BlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleDIuZGVmYXVsdDtcbiAgfVxufSk7XG5leHBvcnRzLnZpc2l0b3JzID0gZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xucmVxdWlyZShcIi4vcGF0aC9jb250ZXh0LmpzXCIpO1xudmFyIHZpc2l0b3JzID0gcmVxdWlyZShcIi4vdmlzaXRvcnMuanNcIik7XG5leHBvcnRzLnZpc2l0b3JzID0gdmlzaXRvcnM7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIGNhY2hlID0gcmVxdWlyZShcIi4vY2FjaGUuanNcIik7XG52YXIgX3RyYXZlcnNlTm9kZSA9IHJlcXVpcmUoXCIuL3RyYXZlcnNlLW5vZGUuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vcGF0aC9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vc2NvcGUvaW5kZXguanNcIik7XG52YXIgX2h1YiA9IHJlcXVpcmUoXCIuL2h1Yi5qc1wiKTtcbmNvbnN0IHtcbiAgVklTSVRPUl9LRVlTLFxuICByZW1vdmVQcm9wZXJ0aWVzLFxuICB0cmF2ZXJzZUZhc3Rcbn0gPSBfdDtcbmZ1bmN0aW9uIHRyYXZlcnNlKHBhcmVudCwgb3B0cyA9IHt9LCBzY29wZSwgc3RhdGUsIHBhcmVudFBhdGgsIHZpc2l0U2VsZikge1xuICBpZiAoIXBhcmVudCkgcmV0dXJuO1xuICBpZiAoIW9wdHMubm9TY29wZSAmJiAhc2NvcGUpIHtcbiAgICBpZiAocGFyZW50LnR5cGUgIT09IFwiUHJvZ3JhbVwiICYmIHBhcmVudC50eXBlICE9PSBcIkZpbGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhIHNjb3BlIGFuZCBwYXJlbnRQYXRoIHVubGVzcyB0cmF2ZXJzaW5nIGEgUHJvZ3JhbS9GaWxlLiBcIiArIGBJbnN0ZWFkIG9mIHRoYXQgeW91IHRyaWVkIHRvIHRyYXZlcnNlIGEgJHtwYXJlbnQudHlwZX0gbm9kZSB3aXRob3V0IGAgKyBcInBhc3Npbmcgc2NvcGUgYW5kIHBhcmVudFBhdGguXCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIXBhcmVudFBhdGggJiYgdmlzaXRTZWxmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidmlzaXRTZWxmIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBwcm92aWRpbmcgYSBOb2RlUGF0aC5cIik7XG4gIH1cbiAgaWYgKCFWSVNJVE9SX0tFWVNbcGFyZW50LnR5cGVdKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZpc2l0b3JzLmV4cGxvZGUob3B0cyk7XG4gICgwLCBfdHJhdmVyc2VOb2RlLnRyYXZlcnNlTm9kZSkocGFyZW50LCBvcHRzLCBzY29wZSwgc3RhdGUsIHBhcmVudFBhdGgsIG51bGwsIHZpc2l0U2VsZik7XG59XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSB0cmF2ZXJzZTtcbnRyYXZlcnNlLnZpc2l0b3JzID0gdmlzaXRvcnM7XG50cmF2ZXJzZS52ZXJpZnkgPSB2aXNpdG9ycy52ZXJpZnk7XG50cmF2ZXJzZS5leHBsb2RlID0gdmlzaXRvcnMuZXhwbG9kZTtcbnRyYXZlcnNlLmNoZWFwID0gZnVuY3Rpb24gKG5vZGUsIGVudGVyKSB7XG4gIHRyYXZlcnNlRmFzdChub2RlLCBlbnRlcik7XG4gIHJldHVybjtcbn07XG50cmF2ZXJzZS5ub2RlID0gZnVuY3Rpb24gKG5vZGUsIG9wdHMsIHNjb3BlLCBzdGF0ZSwgcGF0aCwgc2tpcEtleXMpIHtcbiAgKDAsIF90cmF2ZXJzZU5vZGUudHJhdmVyc2VOb2RlKShub2RlLCBvcHRzLCBzY29wZSwgc3RhdGUsIHBhdGgsIHNraXBLZXlzKTtcbn07XG50cmF2ZXJzZS5jbGVhck5vZGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0cykge1xuICByZW1vdmVQcm9wZXJ0aWVzKG5vZGUsIG9wdHMpO1xufTtcbnRyYXZlcnNlLnJlbW92ZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHJlZSwgb3B0cykge1xuICB0cmF2ZXJzZUZhc3QodHJlZSwgdHJhdmVyc2UuY2xlYXJOb2RlLCBvcHRzKTtcbiAgcmV0dXJuIHRyZWU7XG59O1xuZnVuY3Rpb24gaGFzRGVueWxpc3RlZFR5cGUocGF0aCwgc3RhdGUpIHtcbiAgaWYgKHBhdGgubm9kZS50eXBlID09PSBzdGF0ZS50eXBlKSB7XG4gICAgc3RhdGUuaGFzID0gdHJ1ZTtcbiAgICBwYXRoLnN0b3AoKTtcbiAgfVxufVxudHJhdmVyc2UuaGFzVHlwZSA9IGZ1bmN0aW9uICh0cmVlLCB0eXBlLCBkZW55bGlzdFR5cGVzKSB7XG4gIGlmIChkZW55bGlzdFR5cGVzICE9IG51bGwgJiYgZGVueWxpc3RUeXBlcy5pbmNsdWRlcyh0cmVlLnR5cGUpKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0cmVlLnR5cGUgPT09IHR5cGUpIHJldHVybiB0cnVlO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBoYXM6IGZhbHNlLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbiAgdHJhdmVyc2UodHJlZSwge1xuICAgIG5vU2NvcGU6IHRydWUsXG4gICAgZGVueWxpc3Q6IGRlbnlsaXN0VHlwZXMsXG4gICAgZW50ZXI6IGhhc0RlbnlsaXN0ZWRUeXBlXG4gIH0sIG51bGwsIHN0YXRlKTtcbiAgcmV0dXJuIHN0YXRlLmhhcztcbn07XG50cmF2ZXJzZS5jYWNoZSA9IGNhY2hlO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25781\n')},60940:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.find = find;\nexports.findParent = findParent;\nexports.getAncestry = getAncestry;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.inType = inType;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nvar _t = __webpack_require__(2352);\nconst {\n  VISITOR_KEYS\n} = _t;\nfunction findParent(callback) {\n  let path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\nfunction find(callback) {\n  let path = this;\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n  return null;\n}\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\nfunction getStatementParent() {\n  let path = this;\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error("File/Program node, we can\'t possibly find a statement parent to this");\n  }\n  return path;\n}\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n    return earliest;\n  });\n}\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n  if (paths.length === 1) {\n    return paths[0];\n  }\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n    return ancestry;\n  });\n  const first = ancestries[0];\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error("Couldn\'t find intersection");\n  }\n}\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\nfunction inType(...candidateTypes) {\n  let path = this;\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n  return false;\n}\n\n//# sourceMappingURL=ancestry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5NDAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsWUFBWTtBQUNaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyx5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2FuY2VzdHJ5LmpzP2FhOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuZXhwb3J0cy5maW5kUGFyZW50ID0gZmluZFBhcmVudDtcbmV4cG9ydHMuZ2V0QW5jZXN0cnkgPSBnZXRBbmNlc3RyeTtcbmV4cG9ydHMuZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbSA9IGdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb207XG5leHBvcnRzLmdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tID0gZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb207XG5leHBvcnRzLmdldEZ1bmN0aW9uUGFyZW50ID0gZ2V0RnVuY3Rpb25QYXJlbnQ7XG5leHBvcnRzLmdldFN0YXRlbWVudFBhcmVudCA9IGdldFN0YXRlbWVudFBhcmVudDtcbmV4cG9ydHMuaW5UeXBlID0gaW5UeXBlO1xuZXhwb3J0cy5pc0FuY2VzdG9yID0gaXNBbmNlc3RvcjtcbmV4cG9ydHMuaXNEZXNjZW5kYW50ID0gaXNEZXNjZW5kYW50O1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgVklTSVRPUl9LRVlTXG59ID0gX3Q7XG5mdW5jdGlvbiBmaW5kUGFyZW50KGNhbGxiYWNrKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgd2hpbGUgKHBhdGggPSBwYXRoLnBhcmVudFBhdGgpIHtcbiAgICBpZiAoY2FsbGJhY2socGF0aCkpIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZChjYWxsYmFjaykge1xuICBsZXQgcGF0aCA9IHRoaXM7XG4gIGRvIHtcbiAgICBpZiAoY2FsbGJhY2socGF0aCkpIHJldHVybiBwYXRoO1xuICB9IHdoaWxlIChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvblBhcmVudCgpIHtcbiAgcmV0dXJuIHRoaXMuZmluZFBhcmVudChwID0+IHAuaXNGdW5jdGlvbigpKTtcbn1cbmZ1bmN0aW9uIGdldFN0YXRlbWVudFBhcmVudCgpIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBkbyB7XG4gICAgaWYgKCFwYXRoLnBhcmVudFBhdGggfHwgQXJyYXkuaXNBcnJheShwYXRoLmNvbnRhaW5lcikgJiYgcGF0aC5pc1N0YXRlbWVudCgpKSB7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICB9XG4gIH0gd2hpbGUgKHBhdGgpO1xuICBpZiAocGF0aCAmJiAocGF0aC5pc1Byb2dyYW0oKSB8fCBwYXRoLmlzRmlsZSgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGUvUHJvZ3JhbSBub2RlLCB3ZSBjYW4ndCBwb3NzaWJseSBmaW5kIGEgc3RhdGVtZW50IHBhcmVudCB0byB0aGlzXCIpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZnVuY3Rpb24gZ2V0RWFybGllc3RDb21tb25BbmNlc3RvckZyb20ocGF0aHMpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbShwYXRocywgZnVuY3Rpb24gKGRlZXBlc3QsIGksIGFuY2VzdHJpZXMpIHtcbiAgICBsZXQgZWFybGllc3Q7XG4gICAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tkZWVwZXN0LnR5cGVdO1xuICAgIGZvciAoY29uc3QgYW5jZXN0cnkgb2YgYW5jZXN0cmllcykge1xuICAgICAgY29uc3QgcGF0aCA9IGFuY2VzdHJ5W2kgKyAxXTtcbiAgICAgIGlmICghZWFybGllc3QpIHtcbiAgICAgICAgZWFybGllc3QgPSBwYXRoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoLmxpc3RLZXkgJiYgZWFybGllc3QubGlzdEtleSA9PT0gcGF0aC5saXN0S2V5KSB7XG4gICAgICAgIGlmIChwYXRoLmtleSA8IGVhcmxpZXN0LmtleSkge1xuICAgICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZWFybGllc3RLZXlJbmRleCA9IGtleXMuaW5kZXhPZihlYXJsaWVzdC5wYXJlbnRLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEtleUluZGV4ID0ga2V5cy5pbmRleE9mKHBhdGgucGFyZW50S2V5KTtcbiAgICAgIGlmIChlYXJsaWVzdEtleUluZGV4ID4gY3VycmVudEtleUluZGV4KSB7XG4gICAgICAgIGVhcmxpZXN0ID0gcGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVhcmxpZXN0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldERlZXBlc3RDb21tb25BbmNlc3RvckZyb20ocGF0aHMsIGZpbHRlcikge1xuICBpZiAoIXBhdGhzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gcGF0aHNbMF07XG4gIH1cbiAgbGV0IG1pbkRlcHRoID0gSW5maW5pdHk7XG4gIGxldCBsYXN0Q29tbW9uSW5kZXgsIGxhc3RDb21tb247XG4gIGNvbnN0IGFuY2VzdHJpZXMgPSBwYXRocy5tYXAocGF0aCA9PiB7XG4gICAgY29uc3QgYW5jZXN0cnkgPSBbXTtcbiAgICBkbyB7XG4gICAgICBhbmNlc3RyeS51bnNoaWZ0KHBhdGgpO1xuICAgIH0gd2hpbGUgKChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKSAmJiBwYXRoICE9PSB0aGlzKTtcbiAgICBpZiAoYW5jZXN0cnkubGVuZ3RoIDwgbWluRGVwdGgpIHtcbiAgICAgIG1pbkRlcHRoID0gYW5jZXN0cnkubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0cnk7XG4gIH0pO1xuICBjb25zdCBmaXJzdCA9IGFuY2VzdHJpZXNbMF07XG4gIGRlcHRoTG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCBtaW5EZXB0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2hvdWxkTWF0Y2ggPSBmaXJzdFtpXTtcbiAgICBmb3IgKGNvbnN0IGFuY2VzdHJ5IG9mIGFuY2VzdHJpZXMpIHtcbiAgICAgIGlmIChhbmNlc3RyeVtpXSAhPT0gc2hvdWxkTWF0Y2gpIHtcbiAgICAgICAgYnJlYWsgZGVwdGhMb29wO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0Q29tbW9uSW5kZXggPSBpO1xuICAgIGxhc3RDb21tb24gPSBzaG91bGRNYXRjaDtcbiAgfVxuICBpZiAobGFzdENvbW1vbikge1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIHJldHVybiBmaWx0ZXIobGFzdENvbW1vbiwgbGFzdENvbW1vbkluZGV4LCBhbmNlc3RyaWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxhc3RDb21tb247XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgaW50ZXJzZWN0aW9uXCIpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RyeSgpIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBjb25zdCBwYXRocyA9IFtdO1xuICBkbyB7XG4gICAgcGF0aHMucHVzaChwYXRoKTtcbiAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG4gIHJldHVybiBwYXRocztcbn1cbmZ1bmN0aW9uIGlzQW5jZXN0b3IobWF5YmVEZXNjZW5kYW50KSB7XG4gIHJldHVybiBtYXliZURlc2NlbmRhbnQuaXNEZXNjZW5kYW50KHRoaXMpO1xufVxuZnVuY3Rpb24gaXNEZXNjZW5kYW50KG1heWJlQW5jZXN0b3IpIHtcbiAgcmV0dXJuICEhdGhpcy5maW5kUGFyZW50KHBhcmVudCA9PiBwYXJlbnQgPT09IG1heWJlQW5jZXN0b3IpO1xufVxuZnVuY3Rpb24gaW5UeXBlKC4uLmNhbmRpZGF0ZVR5cGVzKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgd2hpbGUgKHBhdGgpIHtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgY2FuZGlkYXRlVHlwZXMpIHtcbiAgICAgIGlmIChwYXRoLm5vZGUudHlwZSA9PT0gdHlwZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhdGggPSBwYXRoLnBhcmVudFBhdGg7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmNlc3RyeS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60940\n')},83383:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.addComment = addComment;\nexports.addComments = addComments;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nvar _t = __webpack_require__(2352);\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === "string") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n  if (hasPrev) {\n    if (leading) {\n      prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));\n    }\n    if (trailing && !hasNext) prev.addComments("trailing", trailing);\n  }\n  if (hasNext) {\n    if (trailing) {\n      next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));\n    }\n    if (leading && !hasPrev) next.addComments("leading", leading);\n  }\n}\nfunction removeIfExisting(list, toRemove) {\n  if (!(toRemove != null && toRemove.length)) return list;\n  const set = new Set(toRemove);\n  return list.filter(el => {\n    return !set.has(el);\n  });\n}\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}\n\n//# sourceMappingURL=comments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMzODMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9jb21tZW50cy5qcz85MzJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRDb21tZW50ID0gYWRkQ29tbWVudDtcbmV4cG9ydHMuYWRkQ29tbWVudHMgPSBhZGRDb21tZW50cztcbmV4cG9ydHMuc2hhcmVDb21tZW50c1dpdGhTaWJsaW5ncyA9IHNoYXJlQ29tbWVudHNXaXRoU2libGluZ3M7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBhZGRDb21tZW50OiBfYWRkQ29tbWVudCxcbiAgYWRkQ29tbWVudHM6IF9hZGRDb21tZW50c1xufSA9IF90O1xuZnVuY3Rpb24gc2hhcmVDb21tZW50c1dpdGhTaWJsaW5ncygpIHtcbiAgaWYgKHR5cGVvZiB0aGlzLmtleSA9PT0gXCJzdHJpbmdcIikgcmV0dXJuO1xuICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3QgdHJhaWxpbmcgPSBub2RlLnRyYWlsaW5nQ29tbWVudHM7XG4gIGNvbnN0IGxlYWRpbmcgPSBub2RlLmxlYWRpbmdDb21tZW50cztcbiAgaWYgKCF0cmFpbGluZyAmJiAhbGVhZGluZykgcmV0dXJuO1xuICBjb25zdCBwcmV2ID0gdGhpcy5nZXRTaWJsaW5nKHRoaXMua2V5IC0gMSk7XG4gIGNvbnN0IG5leHQgPSB0aGlzLmdldFNpYmxpbmcodGhpcy5rZXkgKyAxKTtcbiAgY29uc3QgaGFzUHJldiA9IEJvb2xlYW4ocHJldi5ub2RlKTtcbiAgY29uc3QgaGFzTmV4dCA9IEJvb2xlYW4obmV4dC5ub2RlKTtcbiAgaWYgKGhhc1ByZXYpIHtcbiAgICBpZiAobGVhZGluZykge1xuICAgICAgcHJldi5hZGRDb21tZW50cyhcInRyYWlsaW5nXCIsIHJlbW92ZUlmRXhpc3RpbmcobGVhZGluZywgcHJldi5ub2RlLnRyYWlsaW5nQ29tbWVudHMpKTtcbiAgICB9XG4gICAgaWYgKHRyYWlsaW5nICYmICFoYXNOZXh0KSBwcmV2LmFkZENvbW1lbnRzKFwidHJhaWxpbmdcIiwgdHJhaWxpbmcpO1xuICB9XG4gIGlmIChoYXNOZXh0KSB7XG4gICAgaWYgKHRyYWlsaW5nKSB7XG4gICAgICBuZXh0LmFkZENvbW1lbnRzKFwibGVhZGluZ1wiLCByZW1vdmVJZkV4aXN0aW5nKHRyYWlsaW5nLCBuZXh0Lm5vZGUubGVhZGluZ0NvbW1lbnRzKSk7XG4gICAgfVxuICAgIGlmIChsZWFkaW5nICYmICFoYXNQcmV2KSBuZXh0LmFkZENvbW1lbnRzKFwibGVhZGluZ1wiLCBsZWFkaW5nKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSWZFeGlzdGluZyhsaXN0LCB0b1JlbW92ZSkge1xuICBpZiAoISh0b1JlbW92ZSAhPSBudWxsICYmIHRvUmVtb3ZlLmxlbmd0aCkpIHJldHVybiBsaXN0O1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KHRvUmVtb3ZlKTtcbiAgcmV0dXJuIGxpc3QuZmlsdGVyKGVsID0+IHtcbiAgICByZXR1cm4gIXNldC5oYXMoZWwpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnQodHlwZSwgY29udGVudCwgbGluZSkge1xuICBfYWRkQ29tbWVudCh0aGlzLm5vZGUsIHR5cGUsIGNvbnRlbnQsIGxpbmUpO1xufVxuZnVuY3Rpb24gYWRkQ29tbWVudHModHlwZSwgY29tbWVudHMpIHtcbiAgX2FkZENvbW1lbnRzKHRoaXMubm9kZSwgdHlwZSwgY29tbWVudHMpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tZW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///83383\n')},79578:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._call = _call;\nexports._getQueueContexts = _getQueueContexts;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncParent = _resyncParent;\nexports._resyncRemoved = _resyncRemoved;\nexports.call = call;\nexports.isDenylisted = isDenylisted;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.requeue = requeue;\nexports.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;\nexports.resync = resync;\nexports.setContext = setContext;\nexports.setKey = setKey;\nexports.setScope = setScope;\nexports.setup = setup;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.visit = visit;\nvar _traverseNode = __webpack_require__(22264);\nvar _index = __webpack_require__(29709);\nvar _removal = __webpack_require__(53097);\nvar t = __webpack_require__(2352);\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n  if (this.node) {\n    if (_call.call(this, opts[key])) return true;\n  }\n  if (this.node) {\n    var _opts$this$node$type;\n    return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);\n  }\n  return false;\n}\nfunction _call(fns) {\n  if (!fns) return false;\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n    if (ret && typeof ret === "object" && typeof ret.then === "function") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you\'re using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n  return false;\n}\nfunction isDenylisted() {\n  var _this$opts$denylist;\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist == null ? void 0 : denylist.includes(this.node.type);\n}\n{\n  exports.isBlacklisted = isDenylisted;\n}\nfunction restoreContext(path, context) {\n  if (path.context !== context) {\n    path.context = context;\n    path.state = context.state;\n    path.opts = context.opts;\n  }\n}\nfunction visit() {\n  var _this$opts$shouldSkip, _this$opts;\n  if (!this.node) {\n    return false;\n  }\n  if (this.isDenylisted()) {\n    return false;\n  }\n  if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {\n    return false;\n  }\n  const currentContext = this.context;\n  if (this.shouldSkip || call.call(this, "enter")) {\n    this.debug("Skip...");\n    return this.shouldStop;\n  }\n  restoreContext(this, currentContext);\n  this.debug("Recursing into...");\n  this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n  restoreContext(this, currentContext);\n  call.call(this, "exit");\n  return this.shouldStop;\n}\nfunction skip() {\n  this.shouldSkip = true;\n}\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n  this.skipKeys[key] = true;\n}\nfunction stop() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;\n}\nfunction setScope() {\n  var _this$opts2, _this$scope;\n  if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;\n  let path = this.parentPath;\n  if ((this.key === "key" || this.listKey === "decorators") && path.isMethod() || this.key === "discriminant" && path.isSwitchStatement()) {\n    path = path.parentPath;\n  }\n  let target;\n  while (path && !target) {\n    var _path$opts;\n    if ((_path$opts = path.opts) != null && _path$opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n  this.scope = this.getScope(target);\n  (_this$scope = this.scope) == null || _this$scope.init();\n}\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n  this._traverseFlags = 0;\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n  setScope.call(this);\n  return this;\n}\nfunction resync() {\n  if (this.removed) return;\n  _resyncParent.call(this);\n  _resyncList.call(this);\n  _resyncKey.call(this);\n}\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) {\n    return;\n  }\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        setKey.call(this, i);\n        return;\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        setKey.call(this, key);\n        return;\n      }\n    }\n  }\n  this.key = null;\n}\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    _removal._markRemoved.call(this);\n  }\n}\nfunction popContext() {\n  this.contexts.pop();\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  setKey.call(this, key);\n}\nfunction setKey(key) {\n  var _this$node;\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\nfunction requeueComputedKeyAndDecorators() {\n  const {\n    context,\n    node\n  } = this;\n  if (!t.isPrivate(node) && node.computed) {\n    context.maybeQueue(this.get("key"));\n  }\n  if (node.decorators) {\n    for (const decorator of this.get("decorators")) {\n      context.maybeQueue(decorator);\n    }\n  }\n}\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n  return contexts;\n}\n\n//# sourceMappingURL=context.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk1NzguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsWUFBWTtBQUNaLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZix1Q0FBdUM7QUFDdkMsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixZQUFZO0FBQ1osZUFBZTtBQUNmLFlBQVk7QUFDWixhQUFhO0FBQ2Isb0JBQW9CLG1CQUFPLENBQUMsS0FBcUI7QUFDakQsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckMsUUFBUSxtQkFBTyxDQUFDLElBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxHQUFHO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUscUJBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9jb250ZXh0LmpzPzZlMzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9jYWxsID0gX2NhbGw7XG5leHBvcnRzLl9nZXRRdWV1ZUNvbnRleHRzID0gX2dldFF1ZXVlQ29udGV4dHM7XG5leHBvcnRzLl9yZXN5bmNLZXkgPSBfcmVzeW5jS2V5O1xuZXhwb3J0cy5fcmVzeW5jTGlzdCA9IF9yZXN5bmNMaXN0O1xuZXhwb3J0cy5fcmVzeW5jUGFyZW50ID0gX3Jlc3luY1BhcmVudDtcbmV4cG9ydHMuX3Jlc3luY1JlbW92ZWQgPSBfcmVzeW5jUmVtb3ZlZDtcbmV4cG9ydHMuY2FsbCA9IGNhbGw7XG5leHBvcnRzLmlzRGVueWxpc3RlZCA9IGlzRGVueWxpc3RlZDtcbmV4cG9ydHMucG9wQ29udGV4dCA9IHBvcENvbnRleHQ7XG5leHBvcnRzLnB1c2hDb250ZXh0ID0gcHVzaENvbnRleHQ7XG5leHBvcnRzLnJlcXVldWUgPSByZXF1ZXVlO1xuZXhwb3J0cy5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzID0gcmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycztcbmV4cG9ydHMucmVzeW5jID0gcmVzeW5jO1xuZXhwb3J0cy5zZXRDb250ZXh0ID0gc2V0Q29udGV4dDtcbmV4cG9ydHMuc2V0S2V5ID0gc2V0S2V5O1xuZXhwb3J0cy5zZXRTY29wZSA9IHNldFNjb3BlO1xuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuZXhwb3J0cy5za2lwID0gc2tpcDtcbmV4cG9ydHMuc2tpcEtleSA9IHNraXBLZXk7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy52aXNpdCA9IHZpc2l0O1xudmFyIF90cmF2ZXJzZU5vZGUgPSByZXF1aXJlKFwiLi4vdHJhdmVyc2Utbm9kZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBfcmVtb3ZhbCA9IHJlcXVpcmUoXCIuL3JlbW92YWwuanNcIik7XG52YXIgdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5mdW5jdGlvbiBjYWxsKGtleSkge1xuICBjb25zdCBvcHRzID0gdGhpcy5vcHRzO1xuICB0aGlzLmRlYnVnKGtleSk7XG4gIGlmICh0aGlzLm5vZGUpIHtcbiAgICBpZiAoX2NhbGwuY2FsbCh0aGlzLCBvcHRzW2tleV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodGhpcy5ub2RlKSB7XG4gICAgdmFyIF9vcHRzJHRoaXMkbm9kZSR0eXBlO1xuICAgIHJldHVybiBfY2FsbC5jYWxsKHRoaXMsIChfb3B0cyR0aGlzJG5vZGUkdHlwZSA9IG9wdHNbdGhpcy5ub2RlLnR5cGVdKSA9PSBudWxsID8gdm9pZCAwIDogX29wdHMkdGhpcyRub2RlJHR5cGVba2V5XSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gX2NhbGwoZm5zKSB7XG4gIGlmICghZm5zKSByZXR1cm4gZmFsc2U7XG4gIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgaWYgKCFmbikgY29udGludWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgICBpZiAoIW5vZGUpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHJldCA9IGZuLmNhbGwodGhpcy5zdGF0ZSwgdGhpcywgdGhpcy5zdGF0ZSk7XG4gICAgaWYgKHJldCAmJiB0eXBlb2YgcmV0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZXQudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBhcHBlYXIgdG8gYmUgdXNpbmcgYSBwbHVnaW4gd2l0aCBhbiBhc3luYyB0cmF2ZXJzYWwgdmlzaXRvciwgYCArIGB3aGljaCB5b3VyIGN1cnJlbnQgdmVyc2lvbiBvZiBCYWJlbCBkb2VzIG5vdCBzdXBwb3J0LiBgICsgYElmIHlvdSdyZSB1c2luZyBhIHB1Ymxpc2hlZCBwbHVnaW4sIHlvdSBtYXkgbmVlZCB0byB1cGdyYWRlIGAgKyBgeW91ciBAYmFiZWwvY29yZSB2ZXJzaW9uLmApO1xuICAgIH1cbiAgICBpZiAocmV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgcmV0dXJuIHZhbHVlIGZyb20gdmlzaXRvciBtZXRob2QgJHtmbn1gKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubm9kZSAhPT0gbm9kZSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuX3RyYXZlcnNlRmxhZ3MgPiAwKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0RlbnlsaXN0ZWQoKSB7XG4gIHZhciBfdGhpcyRvcHRzJGRlbnlsaXN0O1xuICBjb25zdCBkZW55bGlzdCA9IChfdGhpcyRvcHRzJGRlbnlsaXN0ID0gdGhpcy5vcHRzLmRlbnlsaXN0KSAhPSBudWxsID8gX3RoaXMkb3B0cyRkZW55bGlzdCA6IHRoaXMub3B0cy5ibGFja2xpc3Q7XG4gIHJldHVybiBkZW55bGlzdCA9PSBudWxsID8gdm9pZCAwIDogZGVueWxpc3QuaW5jbHVkZXModGhpcy5ub2RlLnR5cGUpO1xufVxue1xuICBleHBvcnRzLmlzQmxhY2tsaXN0ZWQgPSBpc0RlbnlsaXN0ZWQ7XG59XG5mdW5jdGlvbiByZXN0b3JlQ29udGV4dChwYXRoLCBjb250ZXh0KSB7XG4gIGlmIChwYXRoLmNvbnRleHQgIT09IGNvbnRleHQpIHtcbiAgICBwYXRoLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHBhdGguc3RhdGUgPSBjb250ZXh0LnN0YXRlO1xuICAgIHBhdGgub3B0cyA9IGNvbnRleHQub3B0cztcbiAgfVxufVxuZnVuY3Rpb24gdmlzaXQoKSB7XG4gIHZhciBfdGhpcyRvcHRzJHNob3VsZFNraXAsIF90aGlzJG9wdHM7XG4gIGlmICghdGhpcy5ub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmlzRGVueWxpc3RlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgoX3RoaXMkb3B0cyRzaG91bGRTa2lwID0gKF90aGlzJG9wdHMgPSB0aGlzLm9wdHMpLnNob3VsZFNraXApICE9IG51bGwgJiYgX3RoaXMkb3B0cyRzaG91bGRTa2lwLmNhbGwoX3RoaXMkb3B0cywgdGhpcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY3VycmVudENvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gIGlmICh0aGlzLnNob3VsZFNraXAgfHwgY2FsbC5jYWxsKHRoaXMsIFwiZW50ZXJcIikpIHtcbiAgICB0aGlzLmRlYnVnKFwiU2tpcC4uLlwiKTtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xuICB9XG4gIHJlc3RvcmVDb250ZXh0KHRoaXMsIGN1cnJlbnRDb250ZXh0KTtcbiAgdGhpcy5kZWJ1ZyhcIlJlY3Vyc2luZyBpbnRvLi4uXCIpO1xuICB0aGlzLnNob3VsZFN0b3AgPSAoMCwgX3RyYXZlcnNlTm9kZS50cmF2ZXJzZU5vZGUpKHRoaXMubm9kZSwgdGhpcy5vcHRzLCB0aGlzLnNjb3BlLCB0aGlzLnN0YXRlLCB0aGlzLCB0aGlzLnNraXBLZXlzKTtcbiAgcmVzdG9yZUNvbnRleHQodGhpcywgY3VycmVudENvbnRleHQpO1xuICBjYWxsLmNhbGwodGhpcywgXCJleGl0XCIpO1xuICByZXR1cm4gdGhpcy5zaG91bGRTdG9wO1xufVxuZnVuY3Rpb24gc2tpcCgpIHtcbiAgdGhpcy5zaG91bGRTa2lwID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHNraXBLZXkoa2V5KSB7XG4gIGlmICh0aGlzLnNraXBLZXlzID09IG51bGwpIHtcbiAgICB0aGlzLnNraXBLZXlzID0ge307XG4gIH1cbiAgdGhpcy5za2lwS2V5c1trZXldID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHN0b3AoKSB7XG4gIHRoaXMuX3RyYXZlcnNlRmxhZ3MgfD0gX2luZGV4LlNIT1VMRF9TS0lQIHwgX2luZGV4LlNIT1VMRF9TVE9QO1xufVxuZnVuY3Rpb24gc2V0U2NvcGUoKSB7XG4gIHZhciBfdGhpcyRvcHRzMiwgX3RoaXMkc2NvcGU7XG4gIGlmICgoX3RoaXMkb3B0czIgPSB0aGlzLm9wdHMpICE9IG51bGwgJiYgX3RoaXMkb3B0czIubm9TY29wZSkgcmV0dXJuO1xuICBsZXQgcGF0aCA9IHRoaXMucGFyZW50UGF0aDtcbiAgaWYgKCh0aGlzLmtleSA9PT0gXCJrZXlcIiB8fCB0aGlzLmxpc3RLZXkgPT09IFwiZGVjb3JhdG9yc1wiKSAmJiBwYXRoLmlzTWV0aG9kKCkgfHwgdGhpcy5rZXkgPT09IFwiZGlzY3JpbWluYW50XCIgJiYgcGF0aC5pc1N3aXRjaFN0YXRlbWVudCgpKSB7XG4gICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgfVxuICBsZXQgdGFyZ2V0O1xuICB3aGlsZSAocGF0aCAmJiAhdGFyZ2V0KSB7XG4gICAgdmFyIF9wYXRoJG9wdHM7XG4gICAgaWYgKChfcGF0aCRvcHRzID0gcGF0aC5vcHRzKSAhPSBudWxsICYmIF9wYXRoJG9wdHMubm9TY29wZSkgcmV0dXJuO1xuICAgIHRhcmdldCA9IHBhdGguc2NvcGU7XG4gICAgcGF0aCA9IHBhdGgucGFyZW50UGF0aDtcbiAgfVxuICB0aGlzLnNjb3BlID0gdGhpcy5nZXRTY29wZSh0YXJnZXQpO1xuICAoX3RoaXMkc2NvcGUgPSB0aGlzLnNjb3BlKSA9PSBudWxsIHx8IF90aGlzJHNjb3BlLmluaXQoKTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoY29udGV4dCkge1xuICBpZiAodGhpcy5za2lwS2V5cyAhPSBudWxsKSB7XG4gICAgdGhpcy5za2lwS2V5cyA9IHt9O1xuICB9XG4gIHRoaXMuX3RyYXZlcnNlRmxhZ3MgPSAwO1xuICBpZiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZSA9IGNvbnRleHQuc3RhdGU7XG4gICAgdGhpcy5vcHRzID0gY29udGV4dC5vcHRzO1xuICB9XG4gIHNldFNjb3BlLmNhbGwodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gcmVzeW5jKCkge1xuICBpZiAodGhpcy5yZW1vdmVkKSByZXR1cm47XG4gIF9yZXN5bmNQYXJlbnQuY2FsbCh0aGlzKTtcbiAgX3Jlc3luY0xpc3QuY2FsbCh0aGlzKTtcbiAgX3Jlc3luY0tleS5jYWxsKHRoaXMpO1xufVxuZnVuY3Rpb24gX3Jlc3luY1BhcmVudCgpIHtcbiAgaWYgKHRoaXMucGFyZW50UGF0aCkge1xuICAgIHRoaXMucGFyZW50ID0gdGhpcy5wYXJlbnRQYXRoLm5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXN5bmNLZXkoKSB7XG4gIGlmICghdGhpcy5jb250YWluZXIpIHJldHVybjtcbiAgaWYgKHRoaXMubm9kZSA9PT0gdGhpcy5jb250YWluZXJbdGhpcy5rZXldKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGFpbmVyKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250YWluZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lcltpXSA9PT0gdGhpcy5ub2RlKSB7XG4gICAgICAgIHNldEtleS5jYWxsKHRoaXMsIGkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuY29udGFpbmVyKSkge1xuICAgICAgaWYgKHRoaXMuY29udGFpbmVyW2tleV0gPT09IHRoaXMubm9kZSkge1xuICAgICAgICBzZXRLZXkuY2FsbCh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMua2V5ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIF9yZXN5bmNMaXN0KCkge1xuICBpZiAoIXRoaXMucGFyZW50IHx8ICF0aGlzLmluTGlzdCkgcmV0dXJuO1xuICBjb25zdCBuZXdDb250YWluZXIgPSB0aGlzLnBhcmVudFt0aGlzLmxpc3RLZXldO1xuICBpZiAodGhpcy5jb250YWluZXIgPT09IG5ld0NvbnRhaW5lcikgcmV0dXJuO1xuICB0aGlzLmNvbnRhaW5lciA9IG5ld0NvbnRhaW5lciB8fCBudWxsO1xufVxuZnVuY3Rpb24gX3Jlc3luY1JlbW92ZWQoKSB7XG4gIGlmICh0aGlzLmtleSA9PSBudWxsIHx8ICF0aGlzLmNvbnRhaW5lciB8fCB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0gIT09IHRoaXMubm9kZSkge1xuICAgIF9yZW1vdmFsLl9tYXJrUmVtb3ZlZC5jYWxsKHRoaXMpO1xuICB9XG59XG5mdW5jdGlvbiBwb3BDb250ZXh0KCkge1xuICB0aGlzLmNvbnRleHRzLnBvcCgpO1xuICBpZiAodGhpcy5jb250ZXh0cy5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5zZXRDb250ZXh0KHRoaXMuY29udGV4dHNbdGhpcy5jb250ZXh0cy5sZW5ndGggLSAxXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZXRDb250ZXh0KHVuZGVmaW5lZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hDb250ZXh0KGNvbnRleHQpIHtcbiAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB0aGlzLnNldENvbnRleHQoY29udGV4dCk7XG59XG5mdW5jdGlvbiBzZXR1cChwYXJlbnRQYXRoLCBjb250YWluZXIsIGxpc3RLZXksIGtleSkge1xuICB0aGlzLmxpc3RLZXkgPSBsaXN0S2V5O1xuICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgdGhpcy5wYXJlbnRQYXRoID0gcGFyZW50UGF0aCB8fCB0aGlzLnBhcmVudFBhdGg7XG4gIHNldEtleS5jYWxsKHRoaXMsIGtleSk7XG59XG5mdW5jdGlvbiBzZXRLZXkoa2V5KSB7XG4gIHZhciBfdGhpcyRub2RlO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5ub2RlID0gdGhpcy5jb250YWluZXJbdGhpcy5rZXldO1xuICB0aGlzLnR5cGUgPSAoX3RoaXMkbm9kZSA9IHRoaXMubm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG5vZGUudHlwZTtcbn1cbmZ1bmN0aW9uIHJlcXVldWUocGF0aFRvUXVldWUgPSB0aGlzKSB7XG4gIGlmIChwYXRoVG9RdWV1ZS5yZW1vdmVkKSByZXR1cm47XG4gIDtcbiAgY29uc3QgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICBmb3IgKGNvbnN0IGNvbnRleHQgb2YgY29udGV4dHMpIHtcbiAgICBjb250ZXh0Lm1heWJlUXVldWUocGF0aFRvUXVldWUpO1xuICB9XG59XG5mdW5jdGlvbiByZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKCkge1xuICBjb25zdCB7XG4gICAgY29udGV4dCxcbiAgICBub2RlXG4gIH0gPSB0aGlzO1xuICBpZiAoIXQuaXNQcml2YXRlKG5vZGUpICYmIG5vZGUuY29tcHV0ZWQpIHtcbiAgICBjb250ZXh0Lm1heWJlUXVldWUodGhpcy5nZXQoXCJrZXlcIikpO1xuICB9XG4gIGlmIChub2RlLmRlY29yYXRvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGRlY29yYXRvciBvZiB0aGlzLmdldChcImRlY29yYXRvcnNcIikpIHtcbiAgICAgIGNvbnRleHQubWF5YmVRdWV1ZShkZWNvcmF0b3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2dldFF1ZXVlQ29udGV4dHMoKSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgbGV0IGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgd2hpbGUgKCFjb250ZXh0cy5sZW5ndGgpIHtcbiAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgIGlmICghcGF0aCkgYnJlYWs7XG4gICAgY29udGV4dHMgPSBwYXRoLmNvbnRleHRzO1xuICB9XG4gIHJldHVybiBjb250ZXh0cztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///79578\n')},92257:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.ensureBlock = ensureBlock;\nexports.ensureFunctionName = ensureFunctionName;\nexports.splitExportDeclaration = splitExportDeclaration;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nvar _t = __webpack_require__(2352);\nvar _template = __webpack_require__(32485);\nvar _visitors = __webpack_require__(34950);\nvar _context = __webpack_require__(79578);\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression,\n  toBindingIdentifierName,\n  isFunction,\n  isAssignmentPattern,\n  isRestElement,\n  getFunctionName,\n  cloneNode,\n  variableDeclaration,\n  variableDeclarator,\n  exportNamedDeclaration,\n  exportSpecifier,\n  inherits\n} = _t;\nfunction toComputedKey() {\n  let key;\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError("todo");\n  }\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n  return key;\n}\nfunction ensureBlock() {\n  const body = this.get("body");\n  const bodyNode = body.node;\n  if (Array.isArray(body)) {\n    throw new Error("Can\'t convert array path to a block statement");\n  }\n  if (!bodyNode) {\n    throw new Error("Can\'t convert node without a body");\n  }\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n  const statements = [];\n  let stringPath = "body";\n  let key;\n  let listKey;\n  if (body.isStatement()) {\n    listKey = "body";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += ".body.0";\n    if (this.isFunction()) {\n      key = "argument";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = "expression";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n{\n  exports.arrowFunctionToShadowed = function () {\n    if (!this.isArrowFunctionExpression()) return;\n    this.arrowFunctionToExpression();\n  };\n}\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");\n  }\n  hoistFunctionEnvironment(this);\n}\nfunction setType(path, type) {\n  path.node.type = type;\n}\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  allowInsertArrowWithRest = allowInsertArrow,\n  noNewArrows = !(_arguments$ => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");\n  }\n  let self = this;\n  if (!noNewArrows) {\n    var _self$ensureFunctionN;\n    self = (_self$ensureFunctionN = self.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self;\n  }\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);\n  fn.ensureBlock();\n  setType(fn, "FunctionExpression");\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n    fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get("callee.object");\n  }\n  return fn;\n}\nconst getSuperCallsVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get("callee").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n});\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: "constructor"\n  });\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get("callee");\n      fnPath = thisEnvFn.get("body");\n    } else {\n      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");\n    }\n  }\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError("When using \'@babel/plugin-transform-arrow-functions\', " + "it\'s not possible to compile `super()` in an arrow function without compiling classes.\\n" + "Please add \'@babel/plugin-transform-classes\' to your Babel configuration.");\n    }\n    if (!allowInsertArrowWithRest) {\n      throw superCalls[0].buildCodeFrameError("When using \'@babel/plugin-transform-parameters\', " + "it\'s not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\\n" + "Please add \'@babel/plugin-transform-classes\' to your Babel configuration.");\n    }\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get("callee").replaceWith(callee);\n    });\n  }\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {\n      const args = () => identifier("arguments");\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError("When using \'@babel/plugin-transform-arrow-functions\', " + "it\'s not possible to compile `super.prop` in an arrow function without compiling classes.\\n" + "Please add \'@babel/plugin-transform-classes\' to your Babel configuration.");\n    }\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? "" : superProp.get("property").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({\n        tag: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n      if (superProp.node.computed) {\n        args.push(superProp.get("property").node);\n      }\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n      const call = callExpression(identifier(superBinding), args);\n      if (isCall) {\n        superParentPath.unshiftContainer("arguments", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier("call")));\n        thisPaths.push(superParentPath.get("arguments.0"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else if (isTaggedTemplate) {\n        superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));\n        thisPaths.push(superProp.get("arguments.0"));\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n  let thisBinding;\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n  return {\n    thisBinding,\n    fnPath\n  };\n}\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));\n      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get("left").replaceWith(memberExpression(object, property));\n      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));\n    }\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = "=";\n    }\n    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;\n    const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get("expressions.0.right");\n    const right = updateExpr.get("expressions.1.left");\n    return [left, right];\n  }\n  return [superProp];\n  function rightExpression(op, left, right) {\n    if (op === "=") {\n      return assignmentExpression("=", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\nconst assignSuperThisVisitor = (0, _visitors.environmentVisitor)({\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get("callee").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);\n  }\n});\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, "this", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, "supercall", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? "set" : "get";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {\n    const argsList = [];\n    let fnBody;\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier("prop");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));\n    }\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = "binding:" + key;\n  let data = thisEnvFn.getData(cacheKey);\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n  return data;\n}\nconst getScopeInformationVisitor = (0, _visitors.environmentVisitor)({\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== "this") return;\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n    thisPaths.push(child);\n  },\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get("callee").isSuper()) superCalls.push(child);\n  },\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get("object").isSuper()) superProps.push(child);\n  },\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: "arguments"\n    })) return;\n    let curr = child.scope;\n    do {\n      if (curr.hasOwnBinding("arguments")) {\n        curr.rename("arguments");\n        return;\n      }\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n    argumentsPaths.push(child);\n  },\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get("meta").isIdentifier({\n      name: "new"\n    })) return;\n    if (!child.get("property").isIdentifier({\n      name: "target"\n    })) return;\n    newTargetPaths.push(child);\n  }\n});\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}\nfunction splitExportDeclaration() {\n  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {\n    throw new Error("Only default and named export declarations can be split.");\n  }\n  if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {\n    throw new Error("It doesn\'t make sense to split exported specifiers.");\n  }\n  const declaration = this.get("declaration");\n  if (this.isExportDefaultDeclaration()) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier("default");\n      if (standaloneDeclaration || exportExpr) {\n        declaration.node.id = cloneNode(id);\n      }\n    } else if (exportExpr && scope.hasBinding(id.name)) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(id.name);\n    }\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);\n    this.insertAfter(updatedExportDeclaration);\n    this.replaceWith(updatedDeclaration);\n    if (needBindingRegistration) {\n      scope.registerDeclaration(this);\n    }\n    return this;\n  } else if (this.get("specifiers").length > 0) {\n    throw new Error("It doesn\'t make sense to split exported specifiers.");\n  }\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  this.insertAfter(aliasDeclar);\n  this.replaceWith(declaration.node);\n  return this;\n}\nconst refersOuterBindingVisitor = {\n  "ReferencedIdentifier|BindingIdentifier"(path, state) {\n    if (path.node.name !== state.name) return;\n    state.needsRename = true;\n    path.stop();\n  },\n  Scope(path, state) {\n    if (path.scope.hasOwnBinding(state.name)) {\n      path.skip();\n    }\n  }\n};\nfunction ensureFunctionName(supportUnicodeId) {\n  if (this.node.id) return this;\n  const res = getFunctionName(this.node, this.parent);\n  if (res == null) return this;\n  let {\n    name\n  } = res;\n  if (!supportUnicodeId && /[\\uD800-\\uDFFF]/.test(name)) {\n    return null;\n  }\n  if (name.startsWith("get ") || name.startsWith("set ")) {\n    return null;\n  }\n  name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));\n  const id = identifier(name);\n  inherits(id, res.originalNode);\n  const state = {\n    needsRename: false,\n    name\n  };\n  const {\n    scope\n  } = this;\n  const binding = scope.getOwnBinding(name);\n  if (binding) {\n    if (binding.kind === "param") {\n      state.needsRename = true;\n    } else {}\n  } else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {\n    this.traverse(refersOuterBindingVisitor, state);\n  }\n  if (!state.needsRename) {\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n    scope.rename(id.name);\n    this.node.id = id;\n    scope.getProgramParent().references[id.name] = true;\n    return this;\n  }\n  if (!isFunction(this.node)) return null;\n  const key = scope.generateUidIdentifier(id.name);\n  const params = [];\n  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {\n    params.push(scope.generateUidIdentifier("x"));\n  }\n  const call = _template.default.expression.ast`\n    (function (${key}) {\n      function ${id}(${params}) {\n        return ${cloneNode(key)}.apply(this, arguments);\n      }\n\n      ${cloneNode(id)}.toString = function () {\n        return ${cloneNode(key)}.toString();\n      }\n\n      return ${cloneNode(id)};\n    })(${toExpression(this.node)})\n  `;\n  return this.replaceWith(call)[0].get("arguments.0");\n}\nfunction getFunctionArity(node) {\n  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));\n  return count === -1 ? node.params.length : count;\n}\n\n//# sourceMappingURL=conversion.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIyNTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUNBQWlDO0FBQ2pDLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQixpQ0FBaUM7QUFDakMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsS0FBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsS0FBZ0I7QUFDeEMsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwrQkFBK0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRyxHQUFHLGVBQWU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCLGlCQUFpQixHQUFHLEdBQUcsT0FBTztBQUM5QixpQkFBaUIsZUFBZTtBQUNoQzs7QUFFQSxRQUFRLGNBQWM7QUFDdEIsaUJBQWlCLGVBQWU7QUFDaEM7O0FBRUEsZUFBZTtBQUNmLEtBQUssSUFBSSx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9jb252ZXJzaW9uLmpzPzYyYTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFycm93RnVuY3Rpb25Ub0V4cHJlc3Npb24gPSBhcnJvd0Z1bmN0aW9uVG9FeHByZXNzaW9uO1xuZXhwb3J0cy5lbnN1cmVCbG9jayA9IGVuc3VyZUJsb2NrO1xuZXhwb3J0cy5lbnN1cmVGdW5jdGlvbk5hbWUgPSBlbnN1cmVGdW5jdGlvbk5hbWU7XG5leHBvcnRzLnNwbGl0RXhwb3J0RGVjbGFyYXRpb24gPSBzcGxpdEV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy50b0NvbXB1dGVkS2V5ID0gdG9Db21wdXRlZEtleTtcbmV4cG9ydHMudW53cmFwRnVuY3Rpb25FbnZpcm9ubWVudCA9IHVud3JhcEZ1bmN0aW9uRW52aXJvbm1lbnQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF90ZW1wbGF0ZSA9IHJlcXVpcmUoXCJAYmFiZWwvdGVtcGxhdGVcIik7XG52YXIgX3Zpc2l0b3JzID0gcmVxdWlyZShcIi4uL3Zpc2l0b3JzLmpzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbmNvbnN0IHtcbiAgYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gIGFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICBiaW5hcnlFeHByZXNzaW9uLFxuICBibG9ja1N0YXRlbWVudCxcbiAgY2FsbEV4cHJlc3Npb24sXG4gIGNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgaWRlbnRpZmllcixcbiAgaXNJZGVudGlmaWVyLFxuICBqc3hJZGVudGlmaWVyLFxuICBsb2dpY2FsRXhwcmVzc2lvbixcbiAgTE9HSUNBTF9PUEVSQVRPUlMsXG4gIG1lbWJlckV4cHJlc3Npb24sXG4gIG1ldGFQcm9wZXJ0eSxcbiAgbnVtZXJpY0xpdGVyYWwsXG4gIG9iamVjdEV4cHJlc3Npb24sXG4gIHJlc3RFbGVtZW50LFxuICByZXR1cm5TdGF0ZW1lbnQsXG4gIHNlcXVlbmNlRXhwcmVzc2lvbixcbiAgc3ByZWFkRWxlbWVudCxcbiAgc3RyaW5nTGl0ZXJhbCxcbiAgc3VwZXI6IF9zdXBlcixcbiAgdGhpc0V4cHJlc3Npb24sXG4gIHRvRXhwcmVzc2lvbixcbiAgdW5hcnlFeHByZXNzaW9uLFxuICB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZSxcbiAgaXNGdW5jdGlvbixcbiAgaXNBc3NpZ25tZW50UGF0dGVybixcbiAgaXNSZXN0RWxlbWVudCxcbiAgZ2V0RnVuY3Rpb25OYW1lLFxuICBjbG9uZU5vZGUsXG4gIHZhcmlhYmxlRGVjbGFyYXRpb24sXG4gIHZhcmlhYmxlRGVjbGFyYXRvcixcbiAgZXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgZXhwb3J0U3BlY2lmaWVyLFxuICBpbmhlcml0c1xufSA9IF90O1xuZnVuY3Rpb24gdG9Db21wdXRlZEtleSgpIHtcbiAgbGV0IGtleTtcbiAgaWYgKHRoaXMuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICBrZXkgPSB0aGlzLm5vZGUucHJvcGVydHk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1Byb3BlcnR5KCkgfHwgdGhpcy5pc01ldGhvZCgpKSB7XG4gICAga2V5ID0gdGhpcy5ub2RlLmtleTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0b2RvXCIpO1xuICB9XG4gIGlmICghdGhpcy5ub2RlLmNvbXB1dGVkKSB7XG4gICAgaWYgKGlzSWRlbnRpZmllcihrZXkpKSBrZXkgPSBzdHJpbmdMaXRlcmFsKGtleS5uYW1lKTtcbiAgfVxuICByZXR1cm4ga2V5O1xufVxuZnVuY3Rpb24gZW5zdXJlQmxvY2soKSB7XG4gIGNvbnN0IGJvZHkgPSB0aGlzLmdldChcImJvZHlcIik7XG4gIGNvbnN0IGJvZHlOb2RlID0gYm9keS5ub2RlO1xuICBpZiAoQXJyYXkuaXNBcnJheShib2R5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbnZlcnQgYXJyYXkgcGF0aCB0byBhIGJsb2NrIHN0YXRlbWVudFwiKTtcbiAgfVxuICBpZiAoIWJvZHlOb2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCBub2RlIHdpdGhvdXQgYSBib2R5XCIpO1xuICB9XG4gIGlmIChib2R5LmlzQmxvY2tTdGF0ZW1lbnQoKSkge1xuICAgIHJldHVybiBib2R5Tm9kZTtcbiAgfVxuICBjb25zdCBzdGF0ZW1lbnRzID0gW107XG4gIGxldCBzdHJpbmdQYXRoID0gXCJib2R5XCI7XG4gIGxldCBrZXk7XG4gIGxldCBsaXN0S2V5O1xuICBpZiAoYm9keS5pc1N0YXRlbWVudCgpKSB7XG4gICAgbGlzdEtleSA9IFwiYm9keVwiO1xuICAgIGtleSA9IDA7XG4gICAgc3RhdGVtZW50cy5wdXNoKGJvZHkubm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RyaW5nUGF0aCArPSBcIi5ib2R5LjBcIjtcbiAgICBpZiAodGhpcy5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIGtleSA9IFwiYXJndW1lbnRcIjtcbiAgICAgIHN0YXRlbWVudHMucHVzaChyZXR1cm5TdGF0ZW1lbnQoYm9keS5ub2RlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IFwiZXhwcmVzc2lvblwiO1xuICAgICAgc3RhdGVtZW50cy5wdXNoKGV4cHJlc3Npb25TdGF0ZW1lbnQoYm9keS5ub2RlKSk7XG4gICAgfVxuICB9XG4gIHRoaXMubm9kZS5ib2R5ID0gYmxvY2tTdGF0ZW1lbnQoc3RhdGVtZW50cyk7XG4gIGNvbnN0IHBhcmVudFBhdGggPSB0aGlzLmdldChzdHJpbmdQYXRoKTtcbiAgX2NvbnRleHQuc2V0dXAuY2FsbChib2R5LCBwYXJlbnRQYXRoLCBsaXN0S2V5ID8gcGFyZW50UGF0aC5ub2RlW2xpc3RLZXldIDogcGFyZW50UGF0aC5ub2RlLCBsaXN0S2V5LCBrZXkpO1xuICByZXR1cm4gdGhpcy5ub2RlO1xufVxue1xuICBleHBvcnRzLmFycm93RnVuY3Rpb25Ub1NoYWRvd2VkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkpIHJldHVybjtcbiAgICB0aGlzLmFycm93RnVuY3Rpb25Ub0V4cHJlc3Npb24oKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVud3JhcEZ1bmN0aW9uRW52aXJvbm1lbnQoKSB7XG4gIGlmICghdGhpcy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkgJiYgIXRoaXMuaXNGdW5jdGlvbkV4cHJlc3Npb24oKSAmJiAhdGhpcy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgIHRocm93IHRoaXMuYnVpbGRDb2RlRnJhbWVFcnJvcihcIkNhbiBvbmx5IHVud3JhcCB0aGUgZW52aXJvbm1lbnQgb2YgYSBmdW5jdGlvbi5cIik7XG4gIH1cbiAgaG9pc3RGdW5jdGlvbkVudmlyb25tZW50KHRoaXMpO1xufVxuZnVuY3Rpb24gc2V0VHlwZShwYXRoLCB0eXBlKSB7XG4gIHBhdGgubm9kZS50eXBlID0gdHlwZTtcbn1cbmZ1bmN0aW9uIGFycm93RnVuY3Rpb25Ub0V4cHJlc3Npb24oe1xuICBhbGxvd0luc2VydEFycm93ID0gdHJ1ZSxcbiAgYWxsb3dJbnNlcnRBcnJvd1dpdGhSZXN0ID0gYWxsb3dJbnNlcnRBcnJvdyxcbiAgbm9OZXdBcnJvd3MgPSAhKF9hcmd1bWVudHMkID0+IChfYXJndW1lbnRzJCA9IGFyZ3VtZW50c1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hcmd1bWVudHMkLnNwZWNDb21wbGlhbnQpKClcbn0gPSB7fSkge1xuICBpZiAoIXRoaXMuaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgdGhyb3cgdGhpcy5idWlsZENvZGVGcmFtZUVycm9yKFwiQ2Fubm90IGNvbnZlcnQgbm9uLWFycm93IGZ1bmN0aW9uIHRvIGEgZnVuY3Rpb24gZXhwcmVzc2lvbi5cIik7XG4gIH1cbiAgbGV0IHNlbGYgPSB0aGlzO1xuICBpZiAoIW5vTmV3QXJyb3dzKSB7XG4gICAgdmFyIF9zZWxmJGVuc3VyZUZ1bmN0aW9uTjtcbiAgICBzZWxmID0gKF9zZWxmJGVuc3VyZUZ1bmN0aW9uTiA9IHNlbGYuZW5zdXJlRnVuY3Rpb25OYW1lKGZhbHNlKSkgIT0gbnVsbCA/IF9zZWxmJGVuc3VyZUZ1bmN0aW9uTiA6IHNlbGY7XG4gIH1cbiAgY29uc3Qge1xuICAgIHRoaXNCaW5kaW5nLFxuICAgIGZuUGF0aDogZm5cbiAgfSA9IGhvaXN0RnVuY3Rpb25FbnZpcm9ubWVudChzZWxmLCBub05ld0Fycm93cywgYWxsb3dJbnNlcnRBcnJvdywgYWxsb3dJbnNlcnRBcnJvd1dpdGhSZXN0KTtcbiAgZm4uZW5zdXJlQmxvY2soKTtcbiAgc2V0VHlwZShmbiwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gIGlmICghbm9OZXdBcnJvd3MpIHtcbiAgICBjb25zdCBjaGVja0JpbmRpbmcgPSB0aGlzQmluZGluZyA/IG51bGwgOiBmbi5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJhcnJvd0NoZWNrSWRcIik7XG4gICAgaWYgKGNoZWNrQmluZGluZykge1xuICAgICAgZm4ucGFyZW50UGF0aC5zY29wZS5wdXNoKHtcbiAgICAgICAgaWQ6IGNoZWNrQmluZGluZyxcbiAgICAgICAgaW5pdDogb2JqZWN0RXhwcmVzc2lvbihbXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmbi5nZXQoXCJib2R5XCIpLnVuc2hpZnRDb250YWluZXIoXCJib2R5XCIsIGV4cHJlc3Npb25TdGF0ZW1lbnQoY2FsbEV4cHJlc3Npb24odGhpcy5odWIuYWRkSGVscGVyKFwibmV3QXJyb3dDaGVja1wiKSwgW3RoaXNFeHByZXNzaW9uKCksIGNoZWNrQmluZGluZyA/IGlkZW50aWZpZXIoY2hlY2tCaW5kaW5nLm5hbWUpIDogaWRlbnRpZmllcih0aGlzQmluZGluZyldKSkpO1xuICAgIGZuLnJlcGxhY2VXaXRoKGNhbGxFeHByZXNzaW9uKG1lbWJlckV4cHJlc3Npb24oZm4ubm9kZSwgaWRlbnRpZmllcihcImJpbmRcIikpLCBbY2hlY2tCaW5kaW5nID8gaWRlbnRpZmllcihjaGVja0JpbmRpbmcubmFtZSkgOiB0aGlzRXhwcmVzc2lvbigpXSkpO1xuICAgIHJldHVybiBmbi5nZXQoXCJjYWxsZWUub2JqZWN0XCIpO1xuICB9XG4gIHJldHVybiBmbjtcbn1cbmNvbnN0IGdldFN1cGVyQ2FsbHNWaXNpdG9yID0gKDAsIF92aXNpdG9ycy5lbnZpcm9ubWVudFZpc2l0b3IpKHtcbiAgQ2FsbEV4cHJlc3Npb24oY2hpbGQsIHtcbiAgICBhbGxTdXBlckNhbGxzXG4gIH0pIHtcbiAgICBpZiAoIWNoaWxkLmdldChcImNhbGxlZVwiKS5pc1N1cGVyKCkpIHJldHVybjtcbiAgICBhbGxTdXBlckNhbGxzLnB1c2goY2hpbGQpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGhvaXN0RnVuY3Rpb25FbnZpcm9ubWVudChmblBhdGgsIG5vTmV3QXJyb3dzID0gdHJ1ZSwgYWxsb3dJbnNlcnRBcnJvdyA9IHRydWUsIGFsbG93SW5zZXJ0QXJyb3dXaXRoUmVzdCA9IHRydWUpIHtcbiAgbGV0IGFycm93UGFyZW50O1xuICBsZXQgdGhpc0VudkZuID0gZm5QYXRoLmZpbmRQYXJlbnQocCA9PiB7XG4gICAgaWYgKHAuaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICB2YXIgX2Fycm93UGFyZW50O1xuICAgICAgKF9hcnJvd1BhcmVudCA9IGFycm93UGFyZW50KSAhPSBudWxsID8gX2Fycm93UGFyZW50IDogYXJyb3dQYXJlbnQgPSBwO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcC5pc0Z1bmN0aW9uKCkgfHwgcC5pc1Byb2dyYW0oKSB8fCBwLmlzQ2xhc3NQcm9wZXJ0eSh7XG4gICAgICBzdGF0aWM6IGZhbHNlXG4gICAgfSkgfHwgcC5pc0NsYXNzUHJpdmF0ZVByb3BlcnR5KHtcbiAgICAgIHN0YXRpYzogZmFsc2VcbiAgICB9KTtcbiAgfSk7XG4gIGNvbnN0IGluQ29uc3RydWN0b3IgPSB0aGlzRW52Rm4uaXNDbGFzc01ldGhvZCh7XG4gICAga2luZDogXCJjb25zdHJ1Y3RvclwiXG4gIH0pO1xuICBpZiAodGhpc0VudkZuLmlzQ2xhc3NQcm9wZXJ0eSgpIHx8IHRoaXNFbnZGbi5pc0NsYXNzUHJpdmF0ZVByb3BlcnR5KCkpIHtcbiAgICBpZiAoYXJyb3dQYXJlbnQpIHtcbiAgICAgIHRoaXNFbnZGbiA9IGFycm93UGFyZW50O1xuICAgIH0gZWxzZSBpZiAoYWxsb3dJbnNlcnRBcnJvdykge1xuICAgICAgZm5QYXRoLnJlcGxhY2VXaXRoKGNhbGxFeHByZXNzaW9uKGFycm93RnVuY3Rpb25FeHByZXNzaW9uKFtdLCB0b0V4cHJlc3Npb24oZm5QYXRoLm5vZGUpKSwgW10pKTtcbiAgICAgIHRoaXNFbnZGbiA9IGZuUGF0aC5nZXQoXCJjYWxsZWVcIik7XG4gICAgICBmblBhdGggPSB0aGlzRW52Rm4uZ2V0KFwiYm9keVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZm5QYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXCJVbmFibGUgdG8gdHJhbnNmb3JtIGFycm93IGluc2lkZSBjbGFzcyBwcm9wZXJ0eVwiKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qge1xuICAgIHRoaXNQYXRocyxcbiAgICBhcmd1bWVudHNQYXRocyxcbiAgICBuZXdUYXJnZXRQYXRocyxcbiAgICBzdXBlclByb3BzLFxuICAgIHN1cGVyQ2FsbHNcbiAgfSA9IGdldFNjb3BlSW5mb3JtYXRpb24oZm5QYXRoKTtcbiAgaWYgKGluQ29uc3RydWN0b3IgJiYgc3VwZXJDYWxscy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCFhbGxvd0luc2VydEFycm93KSB7XG4gICAgICB0aHJvdyBzdXBlckNhbGxzWzBdLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXCJXaGVuIHVzaW5nICdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1hcnJvdy1mdW5jdGlvbnMnLCBcIiArIFwiaXQncyBub3QgcG9zc2libGUgdG8gY29tcGlsZSBgc3VwZXIoKWAgaW4gYW4gYXJyb3cgZnVuY3Rpb24gd2l0aG91dCBjb21waWxpbmcgY2xhc3Nlcy5cXG5cIiArIFwiUGxlYXNlIGFkZCAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tY2xhc3NlcycgdG8geW91ciBCYWJlbCBjb25maWd1cmF0aW9uLlwiKTtcbiAgICB9XG4gICAgaWYgKCFhbGxvd0luc2VydEFycm93V2l0aFJlc3QpIHtcbiAgICAgIHRocm93IHN1cGVyQ2FsbHNbMF0uYnVpbGRDb2RlRnJhbWVFcnJvcihcIldoZW4gdXNpbmcgJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXBhcmFtZXRlcnMnLCBcIiArIFwiaXQncyBub3QgcG9zc2libGUgdG8gY29tcGlsZSBgc3VwZXIoKWAgaW4gYW4gYXJyb3cgZnVuY3Rpb24gd2l0aCBkZWZhdWx0IG9yIHJlc3QgcGFyYW1ldGVycyB3aXRob3V0IGNvbXBpbGluZyBjbGFzc2VzLlxcblwiICsgXCJQbGVhc2UgYWRkICdAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1jbGFzc2VzJyB0byB5b3VyIEJhYmVsIGNvbmZpZ3VyYXRpb24uXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbGxTdXBlckNhbGxzID0gW107XG4gICAgdGhpc0VudkZuLnRyYXZlcnNlKGdldFN1cGVyQ2FsbHNWaXNpdG9yLCB7XG4gICAgICBhbGxTdXBlckNhbGxzXG4gICAgfSk7XG4gICAgY29uc3Qgc3VwZXJCaW5kaW5nID0gZ2V0U3VwZXJCaW5kaW5nKHRoaXNFbnZGbik7XG4gICAgYWxsU3VwZXJDYWxscy5mb3JFYWNoKHN1cGVyQ2FsbCA9PiB7XG4gICAgICBjb25zdCBjYWxsZWUgPSBpZGVudGlmaWVyKHN1cGVyQmluZGluZyk7XG4gICAgICBjYWxsZWUubG9jID0gc3VwZXJDYWxsLm5vZGUuY2FsbGVlLmxvYztcbiAgICAgIHN1cGVyQ2FsbC5nZXQoXCJjYWxsZWVcIikucmVwbGFjZVdpdGgoY2FsbGVlKTtcbiAgICB9KTtcbiAgfVxuICBpZiAoYXJndW1lbnRzUGF0aHMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGFyZ3VtZW50c0JpbmRpbmcgPSBnZXRCaW5kaW5nKHRoaXNFbnZGbiwgXCJhcmd1bWVudHNcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgYXJncyA9ICgpID0+IGlkZW50aWZpZXIoXCJhcmd1bWVudHNcIik7XG4gICAgICBpZiAodGhpc0VudkZuLnNjb3BlLnBhdGguaXNQcm9ncmFtKCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbmFsRXhwcmVzc2lvbihiaW5hcnlFeHByZXNzaW9uKFwiPT09XCIsIHVuYXJ5RXhwcmVzc2lvbihcInR5cGVvZlwiLCBhcmdzKCkpLCBzdHJpbmdMaXRlcmFsKFwidW5kZWZpbmVkXCIpKSwgdGhpc0VudkZuLnNjb3BlLmJ1aWxkVW5kZWZpbmVkTm9kZSgpLCBhcmdzKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBhcmd1bWVudHNQYXRocy5mb3JFYWNoKGFyZ3VtZW50c0NoaWxkID0+IHtcbiAgICAgIGNvbnN0IGFyZ3NSZWYgPSBpZGVudGlmaWVyKGFyZ3VtZW50c0JpbmRpbmcpO1xuICAgICAgYXJnc1JlZi5sb2MgPSBhcmd1bWVudHNDaGlsZC5ub2RlLmxvYztcbiAgICAgIGFyZ3VtZW50c0NoaWxkLnJlcGxhY2VXaXRoKGFyZ3NSZWYpO1xuICAgIH0pO1xuICB9XG4gIGlmIChuZXdUYXJnZXRQYXRocy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbmV3VGFyZ2V0QmluZGluZyA9IGdldEJpbmRpbmcodGhpc0VudkZuLCBcIm5ld3RhcmdldFwiLCAoKSA9PiBtZXRhUHJvcGVydHkoaWRlbnRpZmllcihcIm5ld1wiKSwgaWRlbnRpZmllcihcInRhcmdldFwiKSkpO1xuICAgIG5ld1RhcmdldFBhdGhzLmZvckVhY2godGFyZ2V0Q2hpbGQgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0UmVmID0gaWRlbnRpZmllcihuZXdUYXJnZXRCaW5kaW5nKTtcbiAgICAgIHRhcmdldFJlZi5sb2MgPSB0YXJnZXRDaGlsZC5ub2RlLmxvYztcbiAgICAgIHRhcmdldENoaWxkLnJlcGxhY2VXaXRoKHRhcmdldFJlZik7XG4gICAgfSk7XG4gIH1cbiAgaWYgKHN1cGVyUHJvcHMubGVuZ3RoID4gMCkge1xuICAgIGlmICghYWxsb3dJbnNlcnRBcnJvdykge1xuICAgICAgdGhyb3cgc3VwZXJQcm9wc1swXS5idWlsZENvZGVGcmFtZUVycm9yKFwiV2hlbiB1c2luZyAnQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tYXJyb3ctZnVuY3Rpb25zJywgXCIgKyBcIml0J3Mgbm90IHBvc3NpYmxlIHRvIGNvbXBpbGUgYHN1cGVyLnByb3BgIGluIGFuIGFycm93IGZ1bmN0aW9uIHdpdGhvdXQgY29tcGlsaW5nIGNsYXNzZXMuXFxuXCIgKyBcIlBsZWFzZSBhZGQgJ0BiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLWNsYXNzZXMnIHRvIHlvdXIgQmFiZWwgY29uZmlndXJhdGlvbi5cIik7XG4gICAgfVxuICAgIGNvbnN0IGZsYXRTdXBlclByb3BzID0gc3VwZXJQcm9wcy5yZWR1Y2UoKGFjYywgc3VwZXJQcm9wKSA9PiBhY2MuY29uY2F0KHN0YW5kYXJkaXplU3VwZXJQcm9wZXJ0eShzdXBlclByb3ApKSwgW10pO1xuICAgIGZsYXRTdXBlclByb3BzLmZvckVhY2goc3VwZXJQcm9wID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHN1cGVyUHJvcC5ub2RlLmNvbXB1dGVkID8gXCJcIiA6IHN1cGVyUHJvcC5nZXQoXCJwcm9wZXJ0eVwiKS5ub2RlLm5hbWU7XG4gICAgICBjb25zdCBzdXBlclBhcmVudFBhdGggPSBzdXBlclByb3AucGFyZW50UGF0aDtcbiAgICAgIGNvbnN0IGlzQXNzaWdubWVudCA9IHN1cGVyUGFyZW50UGF0aC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKHtcbiAgICAgICAgbGVmdDogc3VwZXJQcm9wLm5vZGVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgaXNDYWxsID0gc3VwZXJQYXJlbnRQYXRoLmlzQ2FsbEV4cHJlc3Npb24oe1xuICAgICAgICBjYWxsZWU6IHN1cGVyUHJvcC5ub2RlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGlzVGFnZ2VkVGVtcGxhdGUgPSBzdXBlclBhcmVudFBhdGguaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oe1xuICAgICAgICB0YWc6IHN1cGVyUHJvcC5ub2RlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHN1cGVyQmluZGluZyA9IGdldFN1cGVyUHJvcEJpbmRpbmcodGhpc0VudkZuLCBpc0Fzc2lnbm1lbnQsIGtleSk7XG4gICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICBpZiAoc3VwZXJQcm9wLm5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgYXJncy5wdXNoKHN1cGVyUHJvcC5nZXQoXCJwcm9wZXJ0eVwiKS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0Fzc2lnbm1lbnQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdXBlclBhcmVudFBhdGgubm9kZS5yaWdodDtcbiAgICAgICAgYXJncy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNhbGwgPSBjYWxsRXhwcmVzc2lvbihpZGVudGlmaWVyKHN1cGVyQmluZGluZyksIGFyZ3MpO1xuICAgICAgaWYgKGlzQ2FsbCkge1xuICAgICAgICBzdXBlclBhcmVudFBhdGgudW5zaGlmdENvbnRhaW5lcihcImFyZ3VtZW50c1wiLCB0aGlzRXhwcmVzc2lvbigpKTtcbiAgICAgICAgc3VwZXJQcm9wLnJlcGxhY2VXaXRoKG1lbWJlckV4cHJlc3Npb24oY2FsbCwgaWRlbnRpZmllcihcImNhbGxcIikpKTtcbiAgICAgICAgdGhpc1BhdGhzLnB1c2goc3VwZXJQYXJlbnRQYXRoLmdldChcImFyZ3VtZW50cy4wXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNBc3NpZ25tZW50KSB7XG4gICAgICAgIHN1cGVyUGFyZW50UGF0aC5yZXBsYWNlV2l0aChjYWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNUYWdnZWRUZW1wbGF0ZSkge1xuICAgICAgICBzdXBlclByb3AucmVwbGFjZVdpdGgoY2FsbEV4cHJlc3Npb24obWVtYmVyRXhwcmVzc2lvbihjYWxsLCBpZGVudGlmaWVyKFwiYmluZFwiKSwgZmFsc2UpLCBbdGhpc0V4cHJlc3Npb24oKV0pKTtcbiAgICAgICAgdGhpc1BhdGhzLnB1c2goc3VwZXJQcm9wLmdldChcImFyZ3VtZW50cy4wXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyUHJvcC5yZXBsYWNlV2l0aChjYWxsKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBsZXQgdGhpc0JpbmRpbmc7XG4gIGlmICh0aGlzUGF0aHMubGVuZ3RoID4gMCB8fCAhbm9OZXdBcnJvd3MpIHtcbiAgICB0aGlzQmluZGluZyA9IGdldFRoaXNCaW5kaW5nKHRoaXNFbnZGbiwgaW5Db25zdHJ1Y3Rvcik7XG4gICAgaWYgKG5vTmV3QXJyb3dzIHx8IGluQ29uc3RydWN0b3IgJiYgaGFzU3VwZXJDbGFzcyh0aGlzRW52Rm4pKSB7XG4gICAgICB0aGlzUGF0aHMuZm9yRWFjaCh0aGlzQ2hpbGQgPT4ge1xuICAgICAgICBjb25zdCB0aGlzUmVmID0gdGhpc0NoaWxkLmlzSlNYKCkgPyBqc3hJZGVudGlmaWVyKHRoaXNCaW5kaW5nKSA6IGlkZW50aWZpZXIodGhpc0JpbmRpbmcpO1xuICAgICAgICB0aGlzUmVmLmxvYyA9IHRoaXNDaGlsZC5ub2RlLmxvYztcbiAgICAgICAgdGhpc0NoaWxkLnJlcGxhY2VXaXRoKHRoaXNSZWYpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIW5vTmV3QXJyb3dzKSB0aGlzQmluZGluZyA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgdGhpc0JpbmRpbmcsXG4gICAgZm5QYXRoXG4gIH07XG59XG5mdW5jdGlvbiBpc0xvZ2ljYWxPcChvcCkge1xuICByZXR1cm4gTE9HSUNBTF9PUEVSQVRPUlMuaW5jbHVkZXMob3ApO1xufVxuZnVuY3Rpb24gc3RhbmRhcmRpemVTdXBlclByb3BlcnR5KHN1cGVyUHJvcCkge1xuICBpZiAoc3VwZXJQcm9wLnBhcmVudFBhdGguaXNBc3NpZ25tZW50RXhwcmVzc2lvbigpICYmIHN1cGVyUHJvcC5wYXJlbnRQYXRoLm5vZGUub3BlcmF0b3IgIT09IFwiPVwiKSB7XG4gICAgY29uc3QgYXNzaWdubWVudFBhdGggPSBzdXBlclByb3AucGFyZW50UGF0aDtcbiAgICBjb25zdCBvcCA9IGFzc2lnbm1lbnRQYXRoLm5vZGUub3BlcmF0b3Iuc2xpY2UoMCwgLTEpO1xuICAgIGNvbnN0IHZhbHVlID0gYXNzaWdubWVudFBhdGgubm9kZS5yaWdodDtcbiAgICBjb25zdCBpc0xvZ2ljYWxBc3NpZ25tZW50ID0gaXNMb2dpY2FsT3Aob3ApO1xuICAgIGlmIChzdXBlclByb3Aubm9kZS5jb21wdXRlZCkge1xuICAgICAgY29uc3QgdG1wID0gc3VwZXJQcm9wLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKFwidG1wXCIpO1xuICAgICAgY29uc3Qgb2JqZWN0ID0gc3VwZXJQcm9wLm5vZGUub2JqZWN0O1xuICAgICAgY29uc3QgcHJvcGVydHkgPSBzdXBlclByb3Aubm9kZS5wcm9wZXJ0eTtcbiAgICAgIGFzc2lnbm1lbnRQYXRoLmdldChcImxlZnRcIikucmVwbGFjZVdpdGgobWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCB0bXAsIHByb3BlcnR5KSwgdHJ1ZSkpO1xuICAgICAgYXNzaWdubWVudFBhdGguZ2V0KFwicmlnaHRcIikucmVwbGFjZVdpdGgocmlnaHRFeHByZXNzaW9uKGlzTG9naWNhbEFzc2lnbm1lbnQgPyBcIj1cIiA6IG9wLCBtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgaWRlbnRpZmllcih0bXAubmFtZSksIHRydWUpLCB2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvYmplY3QgPSBzdXBlclByb3Aubm9kZS5vYmplY3Q7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5O1xuICAgICAgYXNzaWdubWVudFBhdGguZ2V0KFwibGVmdFwiKS5yZXBsYWNlV2l0aChtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHkpKTtcbiAgICAgIGFzc2lnbm1lbnRQYXRoLmdldChcInJpZ2h0XCIpLnJlcGxhY2VXaXRoKHJpZ2h0RXhwcmVzc2lvbihpc0xvZ2ljYWxBc3NpZ25tZW50ID8gXCI9XCIgOiBvcCwgbWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIGlkZW50aWZpZXIocHJvcGVydHkubmFtZSkpLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAoaXNMb2dpY2FsQXNzaWdubWVudCkge1xuICAgICAgYXNzaWdubWVudFBhdGgucmVwbGFjZVdpdGgobG9naWNhbEV4cHJlc3Npb24ob3AsIGFzc2lnbm1lbnRQYXRoLm5vZGUubGVmdCwgYXNzaWdubWVudFBhdGgubm9kZS5yaWdodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25tZW50UGF0aC5ub2RlLm9wZXJhdG9yID0gXCI9XCI7XG4gICAgfVxuICAgIHJldHVybiBbYXNzaWdubWVudFBhdGguZ2V0KFwibGVmdFwiKSwgYXNzaWdubWVudFBhdGguZ2V0KFwicmlnaHRcIikuZ2V0KFwibGVmdFwiKV07XG4gIH0gZWxzZSBpZiAoc3VwZXJQcm9wLnBhcmVudFBhdGguaXNVcGRhdGVFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCB1cGRhdGVFeHByID0gc3VwZXJQcm9wLnBhcmVudFBhdGg7XG4gICAgY29uc3QgdG1wID0gc3VwZXJQcm9wLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKFwidG1wXCIpO1xuICAgIGNvbnN0IGNvbXB1dGVkS2V5ID0gc3VwZXJQcm9wLm5vZGUuY29tcHV0ZWQgPyBzdXBlclByb3Auc2NvcGUuZ2VuZXJhdGVEZWNsYXJlZFVpZElkZW50aWZpZXIoXCJwcm9wXCIpIDogbnVsbDtcbiAgICBjb25zdCBwYXJ0cyA9IFthc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgdG1wLCBtZW1iZXJFeHByZXNzaW9uKHN1cGVyUHJvcC5ub2RlLm9iamVjdCwgY29tcHV0ZWRLZXkgPyBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgY29tcHV0ZWRLZXksIHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5KSA6IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5LCBzdXBlclByb3Aubm9kZS5jb21wdXRlZCkpLCBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgbWVtYmVyRXhwcmVzc2lvbihzdXBlclByb3Aubm9kZS5vYmplY3QsIGNvbXB1dGVkS2V5ID8gaWRlbnRpZmllcihjb21wdXRlZEtleS5uYW1lKSA6IHN1cGVyUHJvcC5ub2RlLnByb3BlcnR5LCBzdXBlclByb3Aubm9kZS5jb21wdXRlZCksIGJpbmFyeUV4cHJlc3Npb24oc3VwZXJQcm9wLnBhcmVudFBhdGgubm9kZS5vcGVyYXRvclswXSwgaWRlbnRpZmllcih0bXAubmFtZSksIG51bWVyaWNMaXRlcmFsKDEpKSldO1xuICAgIGlmICghc3VwZXJQcm9wLnBhcmVudFBhdGgubm9kZS5wcmVmaXgpIHtcbiAgICAgIHBhcnRzLnB1c2goaWRlbnRpZmllcih0bXAubmFtZSkpO1xuICAgIH1cbiAgICB1cGRhdGVFeHByLnJlcGxhY2VXaXRoKHNlcXVlbmNlRXhwcmVzc2lvbihwYXJ0cykpO1xuICAgIGNvbnN0IGxlZnQgPSB1cGRhdGVFeHByLmdldChcImV4cHJlc3Npb25zLjAucmlnaHRcIik7XG4gICAgY29uc3QgcmlnaHQgPSB1cGRhdGVFeHByLmdldChcImV4cHJlc3Npb25zLjEubGVmdFwiKTtcbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgfVxuICByZXR1cm4gW3N1cGVyUHJvcF07XG4gIGZ1bmN0aW9uIHJpZ2h0RXhwcmVzc2lvbihvcCwgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAob3AgPT09IFwiPVwiKSB7XG4gICAgICByZXR1cm4gYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGxlZnQsIHJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJpbmFyeUV4cHJlc3Npb24ob3AsIGxlZnQsIHJpZ2h0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc1N1cGVyQ2xhc3ModGhpc0VudkZuKSB7XG4gIHJldHVybiB0aGlzRW52Rm4uaXNDbGFzc01ldGhvZCgpICYmICEhdGhpc0VudkZuLnBhcmVudFBhdGgucGFyZW50UGF0aC5ub2RlLnN1cGVyQ2xhc3M7XG59XG5jb25zdCBhc3NpZ25TdXBlclRoaXNWaXNpdG9yID0gKDAsIF92aXNpdG9ycy5lbnZpcm9ubWVudFZpc2l0b3IpKHtcbiAgQ2FsbEV4cHJlc3Npb24oY2hpbGQsIHtcbiAgICBzdXBlcnMsXG4gICAgdGhpc0JpbmRpbmdcbiAgfSkge1xuICAgIGlmICghY2hpbGQuZ2V0KFwiY2FsbGVlXCIpLmlzU3VwZXIoKSkgcmV0dXJuO1xuICAgIGlmIChzdXBlcnMuaGFzKGNoaWxkLm5vZGUpKSByZXR1cm47XG4gICAgc3VwZXJzLmFkZChjaGlsZC5ub2RlKTtcbiAgICBjaGlsZC5yZXBsYWNlV2l0aE11bHRpcGxlKFtjaGlsZC5ub2RlLCBhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgaWRlbnRpZmllcih0aGlzQmluZGluZyksIGlkZW50aWZpZXIoXCJ0aGlzXCIpKV0pO1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFRoaXNCaW5kaW5nKHRoaXNFbnZGbiwgaW5Db25zdHJ1Y3Rvcikge1xuICByZXR1cm4gZ2V0QmluZGluZyh0aGlzRW52Rm4sIFwidGhpc1wiLCB0aGlzQmluZGluZyA9PiB7XG4gICAgaWYgKCFpbkNvbnN0cnVjdG9yIHx8ICFoYXNTdXBlckNsYXNzKHRoaXNFbnZGbikpIHJldHVybiB0aGlzRXhwcmVzc2lvbigpO1xuICAgIHRoaXNFbnZGbi50cmF2ZXJzZShhc3NpZ25TdXBlclRoaXNWaXNpdG9yLCB7XG4gICAgICBzdXBlcnM6IG5ldyBXZWFrU2V0KCksXG4gICAgICB0aGlzQmluZGluZ1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN1cGVyQmluZGluZyh0aGlzRW52Rm4pIHtcbiAgcmV0dXJuIGdldEJpbmRpbmcodGhpc0VudkZuLCBcInN1cGVyY2FsbFwiLCAoKSA9PiB7XG4gICAgY29uc3QgYXJnc0JpbmRpbmcgPSB0aGlzRW52Rm4uc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKFwiYXJnc1wiKTtcbiAgICByZXR1cm4gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oW3Jlc3RFbGVtZW50KGFyZ3NCaW5kaW5nKV0sIGNhbGxFeHByZXNzaW9uKF9zdXBlcigpLCBbc3ByZWFkRWxlbWVudChpZGVudGlmaWVyKGFyZ3NCaW5kaW5nLm5hbWUpKV0pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdXBlclByb3BCaW5kaW5nKHRoaXNFbnZGbiwgaXNBc3NpZ25tZW50LCBwcm9wTmFtZSkge1xuICBjb25zdCBvcCA9IGlzQXNzaWdubWVudCA/IFwic2V0XCIgOiBcImdldFwiO1xuICByZXR1cm4gZ2V0QmluZGluZyh0aGlzRW52Rm4sIGBzdXBlcnByb3BfJHtvcH06JHtwcm9wTmFtZSB8fCBcIlwifWAsICgpID0+IHtcbiAgICBjb25zdCBhcmdzTGlzdCA9IFtdO1xuICAgIGxldCBmbkJvZHk7XG4gICAgaWYgKHByb3BOYW1lKSB7XG4gICAgICBmbkJvZHkgPSBtZW1iZXJFeHByZXNzaW9uKF9zdXBlcigpLCBpZGVudGlmaWVyKHByb3BOYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXNFbnZGbi5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJwcm9wXCIpO1xuICAgICAgYXJnc0xpc3QudW5zaGlmdChtZXRob2QpO1xuICAgICAgZm5Cb2R5ID0gbWVtYmVyRXhwcmVzc2lvbihfc3VwZXIoKSwgaWRlbnRpZmllcihtZXRob2QubmFtZSksIHRydWUpO1xuICAgIH1cbiAgICBpZiAoaXNBc3NpZ25tZW50KSB7XG4gICAgICBjb25zdCB2YWx1ZUlkZW50ID0gdGhpc0VudkZuLnNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihcInZhbHVlXCIpO1xuICAgICAgYXJnc0xpc3QucHVzaCh2YWx1ZUlkZW50KTtcbiAgICAgIGZuQm9keSA9IGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBmbkJvZHksIGlkZW50aWZpZXIodmFsdWVJZGVudC5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihhcmdzTGlzdCwgZm5Cb2R5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nKHRoaXNFbnZGbiwga2V5LCBpbml0KSB7XG4gIGNvbnN0IGNhY2hlS2V5ID0gXCJiaW5kaW5nOlwiICsga2V5O1xuICBsZXQgZGF0YSA9IHRoaXNFbnZGbi5nZXREYXRhKGNhY2hlS2V5KTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzRW52Rm4uc2NvcGUuZ2VuZXJhdGVVaWRJZGVudGlmaWVyKGtleSk7XG4gICAgZGF0YSA9IGlkLm5hbWU7XG4gICAgdGhpc0VudkZuLnNldERhdGEoY2FjaGVLZXksIGRhdGEpO1xuICAgIHRoaXNFbnZGbi5zY29wZS5wdXNoKHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGluaXQ6IGluaXQoZGF0YSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cbmNvbnN0IGdldFNjb3BlSW5mb3JtYXRpb25WaXNpdG9yID0gKDAsIF92aXNpdG9ycy5lbnZpcm9ubWVudFZpc2l0b3IpKHtcbiAgVGhpc0V4cHJlc3Npb24oY2hpbGQsIHtcbiAgICB0aGlzUGF0aHNcbiAgfSkge1xuICAgIHRoaXNQYXRocy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgSlNYSWRlbnRpZmllcihjaGlsZCwge1xuICAgIHRoaXNQYXRoc1xuICB9KSB7XG4gICAgaWYgKGNoaWxkLm5vZGUubmFtZSAhPT0gXCJ0aGlzXCIpIHJldHVybjtcbiAgICBpZiAoIWNoaWxkLnBhcmVudFBhdGguaXNKU1hNZW1iZXJFeHByZXNzaW9uKHtcbiAgICAgIG9iamVjdDogY2hpbGQubm9kZVxuICAgIH0pICYmICFjaGlsZC5wYXJlbnRQYXRoLmlzSlNYT3BlbmluZ0VsZW1lbnQoe1xuICAgICAgbmFtZTogY2hpbGQubm9kZVxuICAgIH0pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXNQYXRocy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgQ2FsbEV4cHJlc3Npb24oY2hpbGQsIHtcbiAgICBzdXBlckNhbGxzXG4gIH0pIHtcbiAgICBpZiAoY2hpbGQuZ2V0KFwiY2FsbGVlXCIpLmlzU3VwZXIoKSkgc3VwZXJDYWxscy5wdXNoKGNoaWxkKTtcbiAgfSxcbiAgTWVtYmVyRXhwcmVzc2lvbihjaGlsZCwge1xuICAgIHN1cGVyUHJvcHNcbiAgfSkge1xuICAgIGlmIChjaGlsZC5nZXQoXCJvYmplY3RcIikuaXNTdXBlcigpKSBzdXBlclByb3BzLnB1c2goY2hpbGQpO1xuICB9LFxuICBJZGVudGlmaWVyKGNoaWxkLCB7XG4gICAgYXJndW1lbnRzUGF0aHNcbiAgfSkge1xuICAgIGlmICghY2hpbGQuaXNSZWZlcmVuY2VkSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiBcImFyZ3VtZW50c1wiXG4gICAgfSkpIHJldHVybjtcbiAgICBsZXQgY3VyciA9IGNoaWxkLnNjb3BlO1xuICAgIGRvIHtcbiAgICAgIGlmIChjdXJyLmhhc093bkJpbmRpbmcoXCJhcmd1bWVudHNcIikpIHtcbiAgICAgICAgY3Vyci5yZW5hbWUoXCJhcmd1bWVudHNcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyLnBhdGguaXNGdW5jdGlvbigpICYmICFjdXJyLnBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGN1cnIgPSBjdXJyLnBhcmVudCk7XG4gICAgYXJndW1lbnRzUGF0aHMucHVzaChjaGlsZCk7XG4gIH0sXG4gIE1ldGFQcm9wZXJ0eShjaGlsZCwge1xuICAgIG5ld1RhcmdldFBhdGhzXG4gIH0pIHtcbiAgICBpZiAoIWNoaWxkLmdldChcIm1ldGFcIikuaXNJZGVudGlmaWVyKHtcbiAgICAgIG5hbWU6IFwibmV3XCJcbiAgICB9KSkgcmV0dXJuO1xuICAgIGlmICghY2hpbGQuZ2V0KFwicHJvcGVydHlcIikuaXNJZGVudGlmaWVyKHtcbiAgICAgIG5hbWU6IFwidGFyZ2V0XCJcbiAgICB9KSkgcmV0dXJuO1xuICAgIG5ld1RhcmdldFBhdGhzLnB1c2goY2hpbGQpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldFNjb3BlSW5mb3JtYXRpb24oZm5QYXRoKSB7XG4gIGNvbnN0IHRoaXNQYXRocyA9IFtdO1xuICBjb25zdCBhcmd1bWVudHNQYXRocyA9IFtdO1xuICBjb25zdCBuZXdUYXJnZXRQYXRocyA9IFtdO1xuICBjb25zdCBzdXBlclByb3BzID0gW107XG4gIGNvbnN0IHN1cGVyQ2FsbHMgPSBbXTtcbiAgZm5QYXRoLnRyYXZlcnNlKGdldFNjb3BlSW5mb3JtYXRpb25WaXNpdG9yLCB7XG4gICAgdGhpc1BhdGhzLFxuICAgIGFyZ3VtZW50c1BhdGhzLFxuICAgIG5ld1RhcmdldFBhdGhzLFxuICAgIHN1cGVyUHJvcHMsXG4gICAgc3VwZXJDYWxsc1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0aGlzUGF0aHMsXG4gICAgYXJndW1lbnRzUGF0aHMsXG4gICAgbmV3VGFyZ2V0UGF0aHMsXG4gICAgc3VwZXJQcm9wcyxcbiAgICBzdXBlckNhbGxzXG4gIH07XG59XG5mdW5jdGlvbiBzcGxpdEV4cG9ydERlY2xhcmF0aW9uKCkge1xuICBpZiAoIXRoaXMuaXNFeHBvcnREZWNsYXJhdGlvbigpIHx8IHRoaXMuaXNFeHBvcnRBbGxEZWNsYXJhdGlvbigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBkZWZhdWx0IGFuZCBuYW1lZCBleHBvcnQgZGVjbGFyYXRpb25zIGNhbiBiZSBzcGxpdC5cIik7XG4gIH1cbiAgaWYgKHRoaXMuaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKCkgJiYgdGhpcy5nZXQoXCJzcGVjaWZpZXJzXCIpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgZXhwb3J0ZWQgc3BlY2lmaWVycy5cIik7XG4gIH1cbiAgY29uc3QgZGVjbGFyYXRpb24gPSB0aGlzLmdldChcImRlY2xhcmF0aW9uXCIpO1xuICBpZiAodGhpcy5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpKSB7XG4gICAgY29uc3Qgc3RhbmRhbG9uZURlY2xhcmF0aW9uID0gZGVjbGFyYXRpb24uaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkgfHwgZGVjbGFyYXRpb24uaXNDbGFzc0RlY2xhcmF0aW9uKCk7XG4gICAgY29uc3QgZXhwb3J0RXhwciA9IGRlY2xhcmF0aW9uLmlzRnVuY3Rpb25FeHByZXNzaW9uKCkgfHwgZGVjbGFyYXRpb24uaXNDbGFzc0V4cHJlc3Npb24oKTtcbiAgICBjb25zdCBzY29wZSA9IGRlY2xhcmF0aW9uLmlzU2NvcGUoKSA/IGRlY2xhcmF0aW9uLnNjb3BlLnBhcmVudCA6IGRlY2xhcmF0aW9uLnNjb3BlO1xuICAgIGxldCBpZCA9IGRlY2xhcmF0aW9uLm5vZGUuaWQ7XG4gICAgbGV0IG5lZWRCaW5kaW5nUmVnaXN0cmF0aW9uID0gZmFsc2U7XG4gICAgaWYgKCFpZCkge1xuICAgICAgbmVlZEJpbmRpbmdSZWdpc3RyYXRpb24gPSB0cnVlO1xuICAgICAgaWQgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJkZWZhdWx0XCIpO1xuICAgICAgaWYgKHN0YW5kYWxvbmVEZWNsYXJhdGlvbiB8fCBleHBvcnRFeHByKSB7XG4gICAgICAgIGRlY2xhcmF0aW9uLm5vZGUuaWQgPSBjbG9uZU5vZGUoaWQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwb3J0RXhwciAmJiBzY29wZS5oYXNCaW5kaW5nKGlkLm5hbWUpKSB7XG4gICAgICBuZWVkQmluZGluZ1JlZ2lzdHJhdGlvbiA9IHRydWU7XG4gICAgICBpZCA9IHNjb3BlLmdlbmVyYXRlVWlkSWRlbnRpZmllcihpZC5uYW1lKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZERlY2xhcmF0aW9uID0gc3RhbmRhbG9uZURlY2xhcmF0aW9uID8gZGVjbGFyYXRpb24ubm9kZSA6IHZhcmlhYmxlRGVjbGFyYXRpb24oXCJ2YXJcIiwgW3ZhcmlhYmxlRGVjbGFyYXRvcihjbG9uZU5vZGUoaWQpLCBkZWNsYXJhdGlvbi5ub2RlKV0pO1xuICAgIGNvbnN0IHVwZGF0ZWRFeHBvcnREZWNsYXJhdGlvbiA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgW2V4cG9ydFNwZWNpZmllcihjbG9uZU5vZGUoaWQpLCBpZGVudGlmaWVyKFwiZGVmYXVsdFwiKSldKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKHVwZGF0ZWRFeHBvcnREZWNsYXJhdGlvbik7XG4gICAgdGhpcy5yZXBsYWNlV2l0aCh1cGRhdGVkRGVjbGFyYXRpb24pO1xuICAgIGlmIChuZWVkQmluZGluZ1JlZ2lzdHJhdGlvbikge1xuICAgICAgc2NvcGUucmVnaXN0ZXJEZWNsYXJhdGlvbih0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSBpZiAodGhpcy5nZXQoXCJzcGVjaWZpZXJzXCIpLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gc3BsaXQgZXhwb3J0ZWQgc3BlY2lmaWVycy5cIik7XG4gIH1cbiAgY29uc3QgYmluZGluZ0lkZW50aWZpZXJzID0gZGVjbGFyYXRpb24uZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgY29uc3Qgc3BlY2lmaWVycyA9IE9iamVjdC5rZXlzKGJpbmRpbmdJZGVudGlmaWVycykubWFwKG5hbWUgPT4ge1xuICAgIHJldHVybiBleHBvcnRTcGVjaWZpZXIoaWRlbnRpZmllcihuYW1lKSwgaWRlbnRpZmllcihuYW1lKSk7XG4gIH0pO1xuICBjb25zdCBhbGlhc0RlY2xhciA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb24obnVsbCwgc3BlY2lmaWVycyk7XG4gIHRoaXMuaW5zZXJ0QWZ0ZXIoYWxpYXNEZWNsYXIpO1xuICB0aGlzLnJlcGxhY2VXaXRoKGRlY2xhcmF0aW9uLm5vZGUpO1xuICByZXR1cm4gdGhpcztcbn1cbmNvbnN0IHJlZmVyc091dGVyQmluZGluZ1Zpc2l0b3IgPSB7XG4gIFwiUmVmZXJlbmNlZElkZW50aWZpZXJ8QmluZGluZ0lkZW50aWZpZXJcIihwYXRoLCBzdGF0ZSkge1xuICAgIGlmIChwYXRoLm5vZGUubmFtZSAhPT0gc3RhdGUubmFtZSkgcmV0dXJuO1xuICAgIHN0YXRlLm5lZWRzUmVuYW1lID0gdHJ1ZTtcbiAgICBwYXRoLnN0b3AoKTtcbiAgfSxcbiAgU2NvcGUocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAocGF0aC5zY29wZS5oYXNPd25CaW5kaW5nKHN0YXRlLm5hbWUpKSB7XG4gICAgICBwYXRoLnNraXAoKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBlbnN1cmVGdW5jdGlvbk5hbWUoc3VwcG9ydFVuaWNvZGVJZCkge1xuICBpZiAodGhpcy5ub2RlLmlkKSByZXR1cm4gdGhpcztcbiAgY29uc3QgcmVzID0gZ2V0RnVuY3Rpb25OYW1lKHRoaXMubm9kZSwgdGhpcy5wYXJlbnQpO1xuICBpZiAocmVzID09IG51bGwpIHJldHVybiB0aGlzO1xuICBsZXQge1xuICAgIG5hbWVcbiAgfSA9IHJlcztcbiAgaWYgKCFzdXBwb3J0VW5pY29kZUlkICYmIC9bXFx1RDgwMC1cXHVERkZGXS8udGVzdChuYW1lKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJnZXQgXCIpIHx8IG5hbWUuc3RhcnRzV2l0aChcInNldCBcIikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBuYW1lID0gdG9CaW5kaW5nSWRlbnRpZmllck5hbWUobmFtZS5yZXBsYWNlKC9bLyBdL2csIFwiX1wiKSk7XG4gIGNvbnN0IGlkID0gaWRlbnRpZmllcihuYW1lKTtcbiAgaW5oZXJpdHMoaWQsIHJlcy5vcmlnaW5hbE5vZGUpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICBuZWVkc1JlbmFtZTogZmFsc2UsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCB7XG4gICAgc2NvcGVcbiAgfSA9IHRoaXM7XG4gIGNvbnN0IGJpbmRpbmcgPSBzY29wZS5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICBpZiAoYmluZGluZykge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwicGFyYW1cIikge1xuICAgICAgc3RhdGUubmVlZHNSZW5hbWUgPSB0cnVlO1xuICAgIH0gZWxzZSB7fVxuICB9IGVsc2UgaWYgKHNjb3BlLnBhcmVudC5oYXNCaW5kaW5nKG5hbWUpIHx8IHNjb3BlLmhhc0dsb2JhbChuYW1lKSkge1xuICAgIHRoaXMudHJhdmVyc2UocmVmZXJzT3V0ZXJCaW5kaW5nVmlzaXRvciwgc3RhdGUpO1xuICB9XG4gIGlmICghc3RhdGUubmVlZHNSZW5hbWUpIHtcbiAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tpZC5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHNjb3BlLmhhc0JpbmRpbmcoaWQubmFtZSkgJiYgIXNjb3BlLmhhc0dsb2JhbChpZC5uYW1lKSkge1xuICAgIHNjb3BlLnJlbmFtZShpZC5uYW1lKTtcbiAgICB0aGlzLm5vZGUuaWQgPSBpZDtcbiAgICBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tpZC5uYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKCFpc0Z1bmN0aW9uKHRoaXMubm9kZSkpIHJldHVybiBudWxsO1xuICBjb25zdCBrZXkgPSBzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoaWQubmFtZSk7XG4gIGNvbnN0IHBhcmFtcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZ2V0RnVuY3Rpb25Bcml0eSh0aGlzLm5vZGUpOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwYXJhbXMucHVzaChzY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJ4XCIpKTtcbiAgfVxuICBjb25zdCBjYWxsID0gX3RlbXBsYXRlLmRlZmF1bHQuZXhwcmVzc2lvbi5hc3RgXG4gICAgKGZ1bmN0aW9uICgke2tleX0pIHtcbiAgICAgIGZ1bmN0aW9uICR7aWR9KCR7cGFyYW1zfSkge1xuICAgICAgICByZXR1cm4gJHtjbG9uZU5vZGUoa2V5KX0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgJHtjbG9uZU5vZGUoaWQpfS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICR7Y2xvbmVOb2RlKGtleSl9LnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAke2Nsb25lTm9kZShpZCl9O1xuICAgIH0pKCR7dG9FeHByZXNzaW9uKHRoaXMubm9kZSl9KVxuICBgO1xuICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChjYWxsKVswXS5nZXQoXCJhcmd1bWVudHMuMFwiKTtcbn1cbmZ1bmN0aW9uIGdldEZ1bmN0aW9uQXJpdHkobm9kZSkge1xuICBjb25zdCBjb3VudCA9IG5vZGUucGFyYW1zLmZpbmRJbmRleChwYXJhbSA9PiBpc0Fzc2lnbm1lbnRQYXR0ZXJuKHBhcmFtKSB8fCBpc1Jlc3RFbGVtZW50KHBhcmFtKSk7XG4gIHJldHVybiBjb3VudCA9PT0gLTEgPyBub2RlLnBhcmFtcy5sZW5ndGggOiBjb3VudDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udmVyc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92257\n')},10299:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_OBJECT_CALLEES = ["Number", "String", "Math"];\nconst VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];\nconst INVALID_METHODS = ["random"];\nfunction isValidObjectCallee(val) {\n  return VALID_OBJECT_CALLEES.includes(val);\n}\nfunction isValidIdentifierCallee(val) {\n  return VALID_IDENTIFIER_CALLEES.includes(val);\n}\nfunction isInvalidMethod(val) {\n  return INVALID_METHODS.includes(val);\n}\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\nconst Globals = new Map([["undefined", undefined], ["Infinity", Infinity], ["NaN", NaN]]);\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n    const val = _evaluate(path, state);\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n    return val;\n  }\n}\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n  if (path.isSequenceExpression()) {\n    const exprs = path.get("expressions");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n  if (path.isNullLiteral()) {\n    return null;\n  }\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n  if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {\n    const object = path.get("tag.object");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get("tag.property");\n    if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get("test"), state);\n    if (!state.confident) return;\n    if (testResult) {\n      return evaluateCached(path.get("consequent"), state);\n    } else {\n      return evaluateCached(path.get("alternate"), state);\n    }\n  }\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get("expression"), state);\n  }\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get("property");\n    const object = path.get("object");\n    if (object.isLiteral()) {\n      const value = object.node.value;\n      const type = typeof value;\n      let key = null;\n      if (path.node.computed) {\n        key = evaluateCached(property, state);\n        if (!state.confident) return;\n      } else if (property.isIdentifier()) {\n        key = property.node.name;\n      }\n      if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {\n        return value[key];\n      }\n    }\n  }\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n    if (binding) {\n      if (binding.constantViolations.length > 0 || path.node.start < binding.path.node.end) {\n        deopt(binding.path, state);\n        return;\n      }\n      if (binding.hasValue) {\n        return binding.value;\n      }\n    }\n    const name = path.node.name;\n    if (Globals.has(name)) {\n      if (!binding) {\n        return Globals.get(name);\n      }\n      deopt(binding.path, state);\n      return;\n    }\n    const resolved = path.resolve();\n    if (resolved === path) {\n      deopt(path, state);\n      return;\n    } else {\n      return evaluateCached(resolved, state);\n    }\n  }\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === "void") {\n      return undefined;\n    }\n    const argument = path.get("argument");\n    if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {\n      return "function";\n    }\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case "!":\n        return !arg;\n      case "+":\n        return +arg;\n      case "-":\n        return -arg;\n      case "~":\n        return ~arg;\n      case "typeof":\n        return typeof arg;\n    }\n  }\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get("elements");\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        deopt(elemValue.deopt, state);\n        return;\n      }\n    }\n    return arr;\n  }\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get("properties");\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        deopt(prop, state);\n        return;\n      }\n      const keyPath = prop.get("key");\n      let key;\n      if (prop.node.computed) {\n        key = keyPath.evaluate();\n        if (!key.confident) {\n          deopt(key.deopt, state);\n          return;\n        }\n        key = key.value;\n      } else if (keyPath.isIdentifier()) {\n        key = keyPath.node.name;\n      } else {\n        key = keyPath.node.value;\n      }\n      const valuePath = prop.get("value");\n      let value = valuePath.evaluate();\n      if (!value.confident) {\n        deopt(value.deopt, state);\n        return;\n      }\n      value = value.value;\n      obj[key] = value;\n    }\n    return obj;\n  }\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get("left"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get("right"), state);\n    const rightConfident = state.confident;\n    switch (path.node.operator) {\n      case "||":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n      case "&&":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n      case "??":\n        state.confident = leftConfident && (left != null || rightConfident);\n        if (!state.confident) return;\n        return left != null ? left : right;\n    }\n  }\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get("left"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get("right"), state);\n    if (!state.confident) return;\n    switch (path.node.operator) {\n      case "-":\n        return left - right;\n      case "+":\n        return left + right;\n      case "/":\n        return left / right;\n      case "*":\n        return left * right;\n      case "%":\n        return left % right;\n      case "**":\n        return Math.pow(left, right);\n      case "<":\n        return left < right;\n      case ">":\n        return left > right;\n      case "<=":\n        return left <= right;\n      case ">=":\n        return left >= right;\n      case "==":\n        return left == right;\n      case "!=":\n        return left != right;\n      case "===":\n        return left === right;\n      case "!==":\n        return left !== right;\n      case "|":\n        return left | right;\n      case "&":\n        return left & right;\n      case "^":\n        return left ^ right;\n      case "<<":\n        return left << right;\n      case ">>":\n        return left >> right;\n      case ">>>":\n        return left >>> right;\n    }\n  }\n  if (path.isCallExpression()) {\n    const callee = path.get("callee");\n    let context;\n    let func;\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {\n      func = __webpack_require__.g[callee.node.name];\n    }\n    if (callee.isMemberExpression()) {\n      const object = callee.get("object");\n      const property = callee.get("property");\n      if (object.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object.node.name) && !isInvalidMethod(property.node.name)) {\n        context = __webpack_require__.g[object.node.name];\n        const key = property.node.name;\n        if (hasOwnProperty.call(context, key)) {\n          func = context[key];\n        }\n      }\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n        if (type === "string" || type === "number") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n    if (func) {\n      const args = path.get("arguments").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n  deopt(path, state);\n}\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = "";\n  let i = 0;\n  const exprs = path.isTemplateLiteral() ? path.get("expressions") : path.get("quasi.expressions");\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n  if (!state.confident) return;\n  return str;\n}\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}\n\n//# sourceMappingURL=evaluation.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyOTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0JBQWdCO0FBQ2hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2V2YWx1YXRpb24uanM/MWYxZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZXZhbHVhdGUgPSBldmFsdWF0ZTtcbmV4cG9ydHMuZXZhbHVhdGVUcnV0aHkgPSBldmFsdWF0ZVRydXRoeTtcbmNvbnN0IFZBTElEX09CSkVDVF9DQUxMRUVTID0gW1wiTnVtYmVyXCIsIFwiU3RyaW5nXCIsIFwiTWF0aFwiXTtcbmNvbnN0IFZBTElEX0lERU5USUZJRVJfQ0FMTEVFUyA9IFtcImlzRmluaXRlXCIsIFwiaXNOYU5cIiwgXCJwYXJzZUZsb2F0XCIsIFwicGFyc2VJbnRcIiwgXCJkZWNvZGVVUklcIiwgXCJkZWNvZGVVUklDb21wb25lbnRcIiwgXCJlbmNvZGVVUklcIiwgXCJlbmNvZGVVUklDb21wb25lbnRcIiwgbnVsbCwgbnVsbF07XG5jb25zdCBJTlZBTElEX01FVEhPRFMgPSBbXCJyYW5kb21cIl07XG5mdW5jdGlvbiBpc1ZhbGlkT2JqZWN0Q2FsbGVlKHZhbCkge1xuICByZXR1cm4gVkFMSURfT0JKRUNUX0NBTExFRVMuaW5jbHVkZXModmFsKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyQ2FsbGVlKHZhbCkge1xuICByZXR1cm4gVkFMSURfSURFTlRJRklFUl9DQUxMRUVTLmluY2x1ZGVzKHZhbCk7XG59XG5mdW5jdGlvbiBpc0ludmFsaWRNZXRob2QodmFsKSB7XG4gIHJldHVybiBJTlZBTElEX01FVEhPRFMuaW5jbHVkZXModmFsKTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlVHJ1dGh5KCkge1xuICBjb25zdCByZXMgPSB0aGlzLmV2YWx1YXRlKCk7XG4gIGlmIChyZXMuY29uZmlkZW50KSByZXR1cm4gISFyZXMudmFsdWU7XG59XG5mdW5jdGlvbiBkZW9wdChwYXRoLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICBzdGF0ZS5kZW9wdFBhdGggPSBwYXRoO1xuICBzdGF0ZS5jb25maWRlbnQgPSBmYWxzZTtcbn1cbmNvbnN0IEdsb2JhbHMgPSBuZXcgTWFwKFtbXCJ1bmRlZmluZWRcIiwgdW5kZWZpbmVkXSwgW1wiSW5maW5pdHlcIiwgSW5maW5pdHldLCBbXCJOYU5cIiwgTmFOXV0pO1xuZnVuY3Rpb24gZXZhbHVhdGVDYWNoZWQocGF0aCwgc3RhdGUpIHtcbiAgY29uc3Qge1xuICAgIG5vZGVcbiAgfSA9IHBhdGg7XG4gIGNvbnN0IHtcbiAgICBzZWVuXG4gIH0gPSBzdGF0ZTtcbiAgaWYgKHNlZW4uaGFzKG5vZGUpKSB7XG4gICAgY29uc3QgZXhpc3RpbmcgPSBzZWVuLmdldChub2RlKTtcbiAgICBpZiAoZXhpc3RpbmcucmVzb2x2ZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVvcHQocGF0aCwgc3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBzZWVuLnNldChub2RlLCBpdGVtKTtcbiAgICBjb25zdCB2YWwgPSBfZXZhbHVhdGUocGF0aCwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5jb25maWRlbnQpIHtcbiAgICAgIGl0ZW0ucmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgaXRlbS52YWx1ZSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gX2V2YWx1YXRlKHBhdGgsIHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gIGlmIChwYXRoLmlzU2VxdWVuY2VFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBleHBycyA9IHBhdGguZ2V0KFwiZXhwcmVzc2lvbnNcIik7XG4gICAgcmV0dXJuIGV2YWx1YXRlQ2FjaGVkKGV4cHJzW2V4cHJzLmxlbmd0aCAtIDFdLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKHBhdGguaXNTdHJpbmdMaXRlcmFsKCkgfHwgcGF0aC5pc051bWVyaWNMaXRlcmFsKCkgfHwgcGF0aC5pc0Jvb2xlYW5MaXRlcmFsKCkpIHtcbiAgICByZXR1cm4gcGF0aC5ub2RlLnZhbHVlO1xuICB9XG4gIGlmIChwYXRoLmlzTnVsbExpdGVyYWwoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChwYXRoLmlzVGVtcGxhdGVMaXRlcmFsKCkpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVRdWFzaXMocGF0aCwgcGF0aC5ub2RlLnF1YXNpcywgc3RhdGUpO1xuICB9XG4gIGlmIChwYXRoLmlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKCkgJiYgcGF0aC5nZXQoXCJ0YWdcIikuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBvYmplY3QgPSBwYXRoLmdldChcInRhZy5vYmplY3RcIik7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZToge1xuICAgICAgICBuYW1lXG4gICAgICB9XG4gICAgfSA9IG9iamVjdDtcbiAgICBjb25zdCBwcm9wZXJ0eSA9IHBhdGguZ2V0KFwidGFnLnByb3BlcnR5XCIpO1xuICAgIGlmIChvYmplY3QuaXNJZGVudGlmaWVyKCkgJiYgbmFtZSA9PT0gXCJTdHJpbmdcIiAmJiAhcGF0aC5zY29wZS5nZXRCaW5kaW5nKG5hbWUpICYmIHByb3BlcnR5LmlzSWRlbnRpZmllcigpICYmIHByb3BlcnR5Lm5vZGUubmFtZSA9PT0gXCJyYXdcIikge1xuICAgICAgcmV0dXJuIGV2YWx1YXRlUXVhc2lzKHBhdGgsIHBhdGgubm9kZS5xdWFzaS5xdWFzaXMsIHN0YXRlLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBhdGguaXNDb25kaXRpb25hbEV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcInRlc3RcIiksIHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgIGlmICh0ZXN0UmVzdWx0KSB7XG4gICAgICByZXR1cm4gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJjb25zZXF1ZW50XCIpLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcImFsdGVybmF0ZVwiKSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBpZiAocGF0aC5pc0V4cHJlc3Npb25XcmFwcGVyKCkpIHtcbiAgICByZXR1cm4gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJleHByZXNzaW9uXCIpLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKHBhdGguaXNNZW1iZXJFeHByZXNzaW9uKCkgJiYgIXBhdGgucGFyZW50UGF0aC5pc0NhbGxFeHByZXNzaW9uKHtcbiAgICBjYWxsZWU6IHBhdGgubm9kZVxuICB9KSkge1xuICAgIGNvbnN0IHByb3BlcnR5ID0gcGF0aC5nZXQoXCJwcm9wZXJ0eVwiKTtcbiAgICBjb25zdCBvYmplY3QgPSBwYXRoLmdldChcIm9iamVjdFwiKTtcbiAgICBpZiAob2JqZWN0LmlzTGl0ZXJhbCgpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdC5ub2RlLnZhbHVlO1xuICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgaWYgKHBhdGgubm9kZS5jb21wdXRlZCkge1xuICAgICAgICBrZXkgPSBldmFsdWF0ZUNhY2hlZChwcm9wZXJ0eSwgc3RhdGUpO1xuICAgICAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eS5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICBrZXkgPSBwcm9wZXJ0eS5ub2RlLm5hbWU7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikgJiYga2V5ICE9IG51bGwgJiYgKHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSBwYXRoLnNjb3BlLmdldEJpbmRpbmcocGF0aC5ub2RlLm5hbWUpO1xuICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICBpZiAoYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMubGVuZ3RoID4gMCB8fCBwYXRoLm5vZGUuc3RhcnQgPCBiaW5kaW5nLnBhdGgubm9kZS5lbmQpIHtcbiAgICAgICAgZGVvcHQoYmluZGluZy5wYXRoLCBzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nLmhhc1ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiaW5kaW5nLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuYW1lID0gcGF0aC5ub2RlLm5hbWU7XG4gICAgaWYgKEdsb2JhbHMuaGFzKG5hbWUpKSB7XG4gICAgICBpZiAoIWJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIEdsb2JhbHMuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgICAgZGVvcHQoYmluZGluZy5wYXRoLCBzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkID0gcGF0aC5yZXNvbHZlKCk7XG4gICAgaWYgKHJlc29sdmVkID09PSBwYXRoKSB7XG4gICAgICBkZW9wdChwYXRoLCBzdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBldmFsdWF0ZUNhY2hlZChyZXNvbHZlZCwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICBpZiAocGF0aC5pc1VuYXJ5RXhwcmVzc2lvbih7XG4gICAgcHJlZml4OiB0cnVlXG4gIH0pKSB7XG4gICAgaWYgKHBhdGgubm9kZS5vcGVyYXRvciA9PT0gXCJ2b2lkXCIpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IGFyZ3VtZW50ID0gcGF0aC5nZXQoXCJhcmd1bWVudFwiKTtcbiAgICBpZiAocGF0aC5ub2RlLm9wZXJhdG9yID09PSBcInR5cGVvZlwiICYmIChhcmd1bWVudC5pc0Z1bmN0aW9uKCkgfHwgYXJndW1lbnQuaXNDbGFzcygpKSkge1xuICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICB9XG4gICAgY29uc3QgYXJnID0gZXZhbHVhdGVDYWNoZWQoYXJndW1lbnQsIHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgIHN3aXRjaCAocGF0aC5ub2RlLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiIVwiOlxuICAgICAgICByZXR1cm4gIWFyZztcbiAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgIHJldHVybiArYXJnO1xuICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgcmV0dXJuIC1hcmc7XG4gICAgICBjYXNlIFwiflwiOlxuICAgICAgICByZXR1cm4gfmFyZztcbiAgICAgIGNhc2UgXCJ0eXBlb2ZcIjpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmc7XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmlzQXJyYXlFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBjb25zdCBlbGVtcyA9IHBhdGguZ2V0KFwiZWxlbWVudHNcIik7XG4gICAgZm9yIChjb25zdCBlbGVtIG9mIGVsZW1zKSB7XG4gICAgICBjb25zdCBlbGVtVmFsdWUgPSBlbGVtLmV2YWx1YXRlKCk7XG4gICAgICBpZiAoZWxlbVZhbHVlLmNvbmZpZGVudCkge1xuICAgICAgICBhcnIucHVzaChlbGVtVmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVvcHQoZWxlbVZhbHVlLmRlb3B0LCBzdGF0ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuICBpZiAocGF0aC5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGNvbnN0IHByb3BzID0gcGF0aC5nZXQoXCJwcm9wZXJ0aWVzXCIpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgaWYgKHByb3AuaXNPYmplY3RNZXRob2QoKSB8fCBwcm9wLmlzU3ByZWFkRWxlbWVudCgpKSB7XG4gICAgICAgIGRlb3B0KHByb3AsIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qga2V5UGF0aCA9IHByb3AuZ2V0KFwia2V5XCIpO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGlmIChwcm9wLm5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAga2V5ID0ga2V5UGF0aC5ldmFsdWF0ZSgpO1xuICAgICAgICBpZiAoIWtleS5jb25maWRlbnQpIHtcbiAgICAgICAgICBkZW9wdChrZXkuZGVvcHQsIHN0YXRlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0ga2V5LnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChrZXlQYXRoLmlzSWRlbnRpZmllcigpKSB7XG4gICAgICAgIGtleSA9IGtleVBhdGgubm9kZS5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0ga2V5UGF0aC5ub2RlLnZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWVQYXRoID0gcHJvcC5nZXQoXCJ2YWx1ZVwiKTtcbiAgICAgIGxldCB2YWx1ZSA9IHZhbHVlUGF0aC5ldmFsdWF0ZSgpO1xuICAgICAgaWYgKCF2YWx1ZS5jb25maWRlbnQpIHtcbiAgICAgICAgZGVvcHQodmFsdWUuZGVvcHQsIHN0YXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZTtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKHBhdGguaXNMb2dpY2FsRXhwcmVzc2lvbigpKSB7XG4gICAgY29uc3Qgd2FzQ29uZmlkZW50ID0gc3RhdGUuY29uZmlkZW50O1xuICAgIGNvbnN0IGxlZnQgPSBldmFsdWF0ZUNhY2hlZChwYXRoLmdldChcImxlZnRcIiksIHN0YXRlKTtcbiAgICBjb25zdCBsZWZ0Q29uZmlkZW50ID0gc3RhdGUuY29uZmlkZW50O1xuICAgIHN0YXRlLmNvbmZpZGVudCA9IHdhc0NvbmZpZGVudDtcbiAgICBjb25zdCByaWdodCA9IGV2YWx1YXRlQ2FjaGVkKHBhdGguZ2V0KFwicmlnaHRcIiksIHN0YXRlKTtcbiAgICBjb25zdCByaWdodENvbmZpZGVudCA9IHN0YXRlLmNvbmZpZGVudDtcbiAgICBzd2l0Y2ggKHBhdGgubm9kZS5vcGVyYXRvcikge1xuICAgICAgY2FzZSBcInx8XCI6XG4gICAgICAgIHN0YXRlLmNvbmZpZGVudCA9IGxlZnRDb25maWRlbnQgJiYgKCEhbGVmdCB8fCByaWdodENvbmZpZGVudCk7XG4gICAgICAgIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gICAgICAgIHJldHVybiBsZWZ0IHx8IHJpZ2h0O1xuICAgICAgY2FzZSBcIiYmXCI6XG4gICAgICAgIHN0YXRlLmNvbmZpZGVudCA9IGxlZnRDb25maWRlbnQgJiYgKCFsZWZ0IHx8IHJpZ2h0Q29uZmlkZW50KTtcbiAgICAgICAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGxlZnQgJiYgcmlnaHQ7XG4gICAgICBjYXNlIFwiPz9cIjpcbiAgICAgICAgc3RhdGUuY29uZmlkZW50ID0gbGVmdENvbmZpZGVudCAmJiAobGVmdCAhPSBudWxsIHx8IHJpZ2h0Q29uZmlkZW50KTtcbiAgICAgICAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGxlZnQgIT0gbnVsbCA/IGxlZnQgOiByaWdodDtcbiAgICB9XG4gIH1cbiAgaWYgKHBhdGguaXNCaW5hcnlFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCBsZWZ0ID0gZXZhbHVhdGVDYWNoZWQocGF0aC5nZXQoXCJsZWZ0XCIpLCBzdGF0ZSk7XG4gICAgaWYgKCFzdGF0ZS5jb25maWRlbnQpIHJldHVybjtcbiAgICBjb25zdCByaWdodCA9IGV2YWx1YXRlQ2FjaGVkKHBhdGguZ2V0KFwicmlnaHRcIiksIHN0YXRlKTtcbiAgICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgcmV0dXJuO1xuICAgIHN3aXRjaCAocGF0aC5ub2RlLm9wZXJhdG9yKSB7XG4gICAgICBjYXNlIFwiLVwiOlxuICAgICAgICByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgKyByaWdodDtcbiAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgIHJldHVybiBsZWZ0IC8gcmlnaHQ7XG4gICAgICBjYXNlIFwiKlwiOlxuICAgICAgICByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgJSByaWdodDtcbiAgICAgIGNhc2UgXCIqKlwiOlxuICAgICAgICByZXR1cm4gTWF0aC5wb3cobGVmdCwgcmlnaHQpO1xuICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgPCByaWdodDtcbiAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ID4gcmlnaHQ7XG4gICAgICBjYXNlIFwiPD1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgPD0gcmlnaHQ7XG4gICAgICBjYXNlIFwiPj1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgPj0gcmlnaHQ7XG4gICAgICBjYXNlIFwiPT1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG4gICAgICBjYXNlIFwiIT1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgIT0gcmlnaHQ7XG4gICAgICBjYXNlIFwiPT09XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodDtcbiAgICAgIGNhc2UgXCIhPT1cIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0O1xuICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgcmV0dXJuIGxlZnQgfCByaWdodDtcbiAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgIHJldHVybiBsZWZ0ICYgcmlnaHQ7XG4gICAgICBjYXNlIFwiXlwiOlxuICAgICAgICByZXR1cm4gbGVmdCBeIHJpZ2h0O1xuICAgICAgY2FzZSBcIjw8XCI6XG4gICAgICAgIHJldHVybiBsZWZ0IDw8IHJpZ2h0O1xuICAgICAgY2FzZSBcIj4+XCI6XG4gICAgICAgIHJldHVybiBsZWZ0ID4+IHJpZ2h0O1xuICAgICAgY2FzZSBcIj4+PlwiOlxuICAgICAgICByZXR1cm4gbGVmdCA+Pj4gcmlnaHQ7XG4gICAgfVxuICB9XG4gIGlmIChwYXRoLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IGNhbGxlZSA9IHBhdGguZ2V0KFwiY2FsbGVlXCIpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGxldCBmdW5jO1xuICAgIGlmIChjYWxsZWUuaXNJZGVudGlmaWVyKCkgJiYgIXBhdGguc2NvcGUuZ2V0QmluZGluZyhjYWxsZWUubm9kZS5uYW1lKSAmJiAoaXNWYWxpZE9iamVjdENhbGxlZShjYWxsZWUubm9kZS5uYW1lKSB8fCBpc1ZhbGlkSWRlbnRpZmllckNhbGxlZShjYWxsZWUubm9kZS5uYW1lKSkpIHtcbiAgICAgIGZ1bmMgPSBnbG9iYWxbY2FsbGVlLm5vZGUubmFtZV07XG4gICAgfVxuICAgIGlmIChjYWxsZWUuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IGNhbGxlZS5nZXQoXCJvYmplY3RcIik7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IGNhbGxlZS5nZXQoXCJwcm9wZXJ0eVwiKTtcbiAgICAgIGlmIChvYmplY3QuaXNJZGVudGlmaWVyKCkgJiYgcHJvcGVydHkuaXNJZGVudGlmaWVyKCkgJiYgaXNWYWxpZE9iamVjdENhbGxlZShvYmplY3Qubm9kZS5uYW1lKSAmJiAhaXNJbnZhbGlkTWV0aG9kKHByb3BlcnR5Lm5vZGUubmFtZSkpIHtcbiAgICAgICAgY29udGV4dCA9IGdsb2JhbFtvYmplY3Qubm9kZS5uYW1lXTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcGVydHkubm9kZS5uYW1lO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb250ZXh0LCBrZXkpKSB7XG4gICAgICAgICAgZnVuYyA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iamVjdC5pc0xpdGVyYWwoKSAmJiBwcm9wZXJ0eS5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdC5ub2RlLnZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY29udGV4dCA9IG9iamVjdC5ub2RlLnZhbHVlO1xuICAgICAgICAgIGZ1bmMgPSBjb250ZXh0W3Byb3BlcnR5Lm5vZGUubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZ1bmMpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBwYXRoLmdldChcImFyZ3VtZW50c1wiKS5tYXAoYXJnID0+IGV2YWx1YXRlQ2FjaGVkKGFyZywgc3RhdGUpKTtcbiAgICAgIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gIH1cbiAgZGVvcHQocGF0aCwgc3RhdGUpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGVRdWFzaXMocGF0aCwgcXVhc2lzLCBzdGF0ZSwgcmF3ID0gZmFsc2UpIHtcbiAgbGV0IHN0ciA9IFwiXCI7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgZXhwcnMgPSBwYXRoLmlzVGVtcGxhdGVMaXRlcmFsKCkgPyBwYXRoLmdldChcImV4cHJlc3Npb25zXCIpIDogcGF0aC5nZXQoXCJxdWFzaS5leHByZXNzaW9uc1wiKTtcbiAgZm9yIChjb25zdCBlbGVtIG9mIHF1YXNpcykge1xuICAgIGlmICghc3RhdGUuY29uZmlkZW50KSBicmVhaztcbiAgICBzdHIgKz0gcmF3ID8gZWxlbS52YWx1ZS5yYXcgOiBlbGVtLnZhbHVlLmNvb2tlZDtcbiAgICBjb25zdCBleHByID0gZXhwcnNbaSsrXTtcbiAgICBpZiAoZXhwcikgc3RyICs9IFN0cmluZyhldmFsdWF0ZUNhY2hlZChleHByLCBzdGF0ZSkpO1xuICB9XG4gIGlmICghc3RhdGUuY29uZmlkZW50KSByZXR1cm47XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSB7XG4gICAgY29uZmlkZW50OiB0cnVlLFxuICAgIGRlb3B0UGF0aDogbnVsbCxcbiAgICBzZWVuOiBuZXcgTWFwKClcbiAgfTtcbiAgbGV0IHZhbHVlID0gZXZhbHVhdGVDYWNoZWQodGhpcywgc3RhdGUpO1xuICBpZiAoIXN0YXRlLmNvbmZpZGVudCkgdmFsdWUgPSB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgY29uZmlkZW50OiBzdGF0ZS5jb25maWRlbnQsXG4gICAgZGVvcHQ6IHN0YXRlLmRlb3B0UGF0aCxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXZhbHVhdGlvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10299\n')},16109:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.get = get;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.getAssignmentIdentifiers = getAssignmentIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getNextSibling = getNextSibling;\nexports.getOpposite = getOpposite;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getPrevSibling = getPrevSibling;\nexports.getSibling = getSibling;\nvar _index = __webpack_require__(29709);\nvar _t = __webpack_require__(2352);\nconst {\n  getAssignmentIdentifiers: _getAssignmentIdentifiers,\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\nfunction getOpposite() {\n  if (this.key === "left") {\n    return this.getSibling("right");\n  } else if (this.key === "right") {\n    return this.getSibling("left");\n  }\n  return null;\n}\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n  return records;\n}\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n    const caseCompletions = _getCompletionRecords(casePath, context);\n    const normalCompletions = [];\n    const breakCompletions = [];\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n    records.push(...breakCompletions);\n  }\n  records.push(...lastNormalCompletions);\n  return records;\n}\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression("void", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n      const statementCompletions = _getCompletionRecords(path, newContext);\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n        break;\n      }\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n  return completions;\n}\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get("consequent"), records, context);\n    records = addCompletionRecords(path.get("alternate"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get("body"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get("body"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get("body"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get("block"), records, context);\n    records = addCompletionRecords(path.get("handler"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get("body"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get("cases"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get("consequent"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n  return records;\n}\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n  return records.map(r => r.path);\n}\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n  return siblings;\n}\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n  return siblings;\n}\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(".");\n  if (parts.length === 1) {\n    return _getKey.call(this, key, context);\n  } else {\n    return _getPattern.call(this, parts, context);\n  }\n}\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\nfunction _getPattern(parts, context) {\n  let path = this;\n  for (const part of parts) {\n    if (part === ".") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\nfunction getAssignmentIdentifiers() {\n  return _getAssignmentIdentifiers(this.node);\n}\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n      continue;\n    }\n    if (id.isExportDeclaration()) {\n      const declaration = id.get("declaration");\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n      continue;\n    }\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get("id"));\n        continue;\n      }\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n  return ids;\n}\nfunction getOuterBindingIdentifierPaths(duplicates = false) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}\n\n//# sourceMappingURL=family.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxMDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZUFBZTtBQUNmLG1CQUFtQjtBQUNuQixXQUFXO0FBQ1gsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixzQ0FBc0M7QUFDdEMsa0NBQWtDO0FBQ2xDLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQ0FBbUMsUUFBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9mYW1pbHkuanM/YzkxMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX2dldEtleSA9IF9nZXRLZXk7XG5leHBvcnRzLl9nZXRQYXR0ZXJuID0gX2dldFBhdHRlcm47XG5leHBvcnRzLmdldCA9IGdldDtcbmV4cG9ydHMuZ2V0QWxsTmV4dFNpYmxpbmdzID0gZ2V0QWxsTmV4dFNpYmxpbmdzO1xuZXhwb3J0cy5nZXRBbGxQcmV2U2libGluZ3MgPSBnZXRBbGxQcmV2U2libGluZ3M7XG5leHBvcnRzLmdldEFzc2lnbm1lbnRJZGVudGlmaWVycyA9IGdldEFzc2lnbm1lbnRJZGVudGlmaWVycztcbmV4cG9ydHMuZ2V0QmluZGluZ0lkZW50aWZpZXJQYXRocyA9IGdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHM7XG5leHBvcnRzLmdldEJpbmRpbmdJZGVudGlmaWVycyA9IGdldEJpbmRpbmdJZGVudGlmaWVycztcbmV4cG9ydHMuZ2V0Q29tcGxldGlvblJlY29yZHMgPSBnZXRDb21wbGV0aW9uUmVjb3JkcztcbmV4cG9ydHMuZ2V0TmV4dFNpYmxpbmcgPSBnZXROZXh0U2libGluZztcbmV4cG9ydHMuZ2V0T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZTtcbmV4cG9ydHMuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzID0gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzO1xuZXhwb3J0cy5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycyA9IGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzO1xuZXhwb3J0cy5nZXRQcmV2U2libGluZyA9IGdldFByZXZTaWJsaW5nO1xuZXhwb3J0cy5nZXRTaWJsaW5nID0gZ2V0U2libGluZztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGdldEFzc2lnbm1lbnRJZGVudGlmaWVyczogX2dldEFzc2lnbm1lbnRJZGVudGlmaWVycyxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiBfZ2V0QmluZGluZ0lkZW50aWZpZXJzLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLFxuICBudW1lcmljTGl0ZXJhbCxcbiAgdW5hcnlFeHByZXNzaW9uXG59ID0gX3Q7XG5jb25zdCBOT1JNQUxfQ09NUExFVElPTiA9IDA7XG5jb25zdCBCUkVBS19DT01QTEVUSU9OID0gMTtcbmZ1bmN0aW9uIE5vcm1hbENvbXBsZXRpb24ocGF0aCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IE5PUk1BTF9DT01QTEVUSU9OLFxuICAgIHBhdGhcbiAgfTtcbn1cbmZ1bmN0aW9uIEJyZWFrQ29tcGxldGlvbihwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQlJFQUtfQ09NUExFVElPTixcbiAgICBwYXRoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZSgpIHtcbiAgaWYgKHRoaXMua2V5ID09PSBcImxlZnRcIikge1xuICAgIHJldHVybiB0aGlzLmdldFNpYmxpbmcoXCJyaWdodFwiKTtcbiAgfSBlbHNlIGlmICh0aGlzLmtleSA9PT0gXCJyaWdodFwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2libGluZyhcImxlZnRcIik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhZGRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLCByZWNvcmRzLCBjb250ZXh0KSB7XG4gIGlmIChwYXRoKSB7XG4gICAgcmVjb3Jkcy5wdXNoKC4uLl9nZXRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLCBjb250ZXh0KSk7XG4gIH1cbiAgcmV0dXJuIHJlY29yZHM7XG59XG5mdW5jdGlvbiBjb21wbGV0aW9uUmVjb3JkRm9yU3dpdGNoKGNhc2VzLCByZWNvcmRzLCBjb250ZXh0KSB7XG4gIGxldCBsYXN0Tm9ybWFsQ29tcGxldGlvbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXNlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNhc2VQYXRoID0gY2FzZXNbaV07XG4gICAgY29uc3QgY2FzZUNvbXBsZXRpb25zID0gX2dldENvbXBsZXRpb25SZWNvcmRzKGNhc2VQYXRoLCBjb250ZXh0KTtcbiAgICBjb25zdCBub3JtYWxDb21wbGV0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGJyZWFrQ29tcGxldGlvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY2FzZUNvbXBsZXRpb25zKSB7XG4gICAgICBpZiAoYy50eXBlID09PSBOT1JNQUxfQ09NUExFVElPTikge1xuICAgICAgICBub3JtYWxDb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgfVxuICAgICAgaWYgKGMudHlwZSA9PT0gQlJFQUtfQ09NUExFVElPTikge1xuICAgICAgICBicmVha0NvbXBsZXRpb25zLnB1c2goYyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3JtYWxDb21wbGV0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGxhc3ROb3JtYWxDb21wbGV0aW9ucyA9IG5vcm1hbENvbXBsZXRpb25zO1xuICAgIH1cbiAgICByZWNvcmRzLnB1c2goLi4uYnJlYWtDb21wbGV0aW9ucyk7XG4gIH1cbiAgcmVjb3Jkcy5wdXNoKC4uLmxhc3ROb3JtYWxDb21wbGV0aW9ucyk7XG4gIHJldHVybiByZWNvcmRzO1xufVxuZnVuY3Rpb24gbm9ybWFsQ29tcGxldGlvblRvQnJlYWsoY29tcGxldGlvbnMpIHtcbiAgY29tcGxldGlvbnMuZm9yRWFjaChjID0+IHtcbiAgICBjLnR5cGUgPSBCUkVBS19DT01QTEVUSU9OO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKGNvbXBsZXRpb25zLCByZWFjaGFibGUpIHtcbiAgY29tcGxldGlvbnMuZm9yRWFjaChjID0+IHtcbiAgICBpZiAoYy5wYXRoLmlzQnJlYWtTdGF0ZW1lbnQoe1xuICAgICAgbGFiZWw6IG51bGxcbiAgICB9KSkge1xuICAgICAgaWYgKHJlYWNoYWJsZSkge1xuICAgICAgICBjLnBhdGgucmVwbGFjZVdpdGgodW5hcnlFeHByZXNzaW9uKFwidm9pZFwiLCBudW1lcmljTGl0ZXJhbCgwKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy5wYXRoLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRTdGF0ZW1lbnRMaXN0Q29tcGxldGlvbihwYXRocywgY29udGV4dCkge1xuICBjb25zdCBjb21wbGV0aW9ucyA9IFtdO1xuICBpZiAoY29udGV4dC5jYW5IYXZlQnJlYWspIHtcbiAgICBsZXQgbGFzdE5vcm1hbENvbXBsZXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgY29uc3QgbmV3Q29udGV4dCA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQsIHtcbiAgICAgICAgaW5DYXNlQ2xhdXNlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBpZiAocGF0aC5pc0Jsb2NrU3RhdGVtZW50KCkgJiYgKGNvbnRleHQuaW5DYXNlQ2xhdXNlIHx8IGNvbnRleHQuc2hvdWxkUG9wdWxhdGVCcmVhaykpIHtcbiAgICAgICAgbmV3Q29udGV4dC5zaG91bGRQb3B1bGF0ZUJyZWFrID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0NvbnRleHQuc2hvdWxkUG9wdWxhdGVCcmVhayA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdGVtZW50Q29tcGxldGlvbnMgPSBfZ2V0Q29tcGxldGlvblJlY29yZHMocGF0aCwgbmV3Q29udGV4dCk7XG4gICAgICBpZiAoc3RhdGVtZW50Q29tcGxldGlvbnMubGVuZ3RoID4gMCAmJiBzdGF0ZW1lbnRDb21wbGV0aW9ucy5ldmVyeShjID0+IGMudHlwZSA9PT0gQlJFQUtfQ09NUExFVElPTikpIHtcbiAgICAgICAgaWYgKGxhc3ROb3JtYWxDb21wbGV0aW9ucy5sZW5ndGggPiAwICYmIHN0YXRlbWVudENvbXBsZXRpb25zLmV2ZXJ5KGMgPT4gYy5wYXRoLmlzQnJlYWtTdGF0ZW1lbnQoe1xuICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgIH0pKSkge1xuICAgICAgICAgIG5vcm1hbENvbXBsZXRpb25Ub0JyZWFrKGxhc3ROb3JtYWxDb21wbGV0aW9ucyk7XG4gICAgICAgICAgY29tcGxldGlvbnMucHVzaCguLi5sYXN0Tm9ybWFsQ29tcGxldGlvbnMpO1xuICAgICAgICAgIGlmIChsYXN0Tm9ybWFsQ29tcGxldGlvbnMuc29tZShjID0+IGMucGF0aC5pc0RlY2xhcmF0aW9uKCkpKSB7XG4gICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKC4uLnN0YXRlbWVudENvbXBsZXRpb25zKTtcbiAgICAgICAgICAgIHJlcGxhY2VCcmVha1N0YXRlbWVudEluQnJlYWtDb21wbGV0aW9uKHN0YXRlbWVudENvbXBsZXRpb25zLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUJyZWFrU3RhdGVtZW50SW5CcmVha0NvbXBsZXRpb24oc3RhdGVtZW50Q29tcGxldGlvbnMsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKC4uLnN0YXRlbWVudENvbXBsZXRpb25zKTtcbiAgICAgICAgICBpZiAoIWNvbnRleHQuc2hvdWxkUG9wdWxhdGVCcmVhaykge1xuICAgICAgICAgICAgcmVwbGFjZUJyZWFrU3RhdGVtZW50SW5CcmVha0NvbXBsZXRpb24oc3RhdGVtZW50Q29tcGxldGlvbnMsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpID09PSBwYXRocy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbXBsZXRpb25zLnB1c2goLi4uc3RhdGVtZW50Q29tcGxldGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdE5vcm1hbENvbXBsZXRpb25zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50Q29tcGxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjID0gc3RhdGVtZW50Q29tcGxldGlvbnNbaV07XG4gICAgICAgICAgaWYgKGMudHlwZSA9PT0gQlJFQUtfQ09NUExFVElPTikge1xuICAgICAgICAgICAgY29tcGxldGlvbnMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGMudHlwZSA9PT0gTk9STUFMX0NPTVBMRVRJT04pIHtcbiAgICAgICAgICAgIGxhc3ROb3JtYWxDb21wbGV0aW9ucy5wdXNoKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXRocy5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHBhdGhDb21wbGV0aW9ucyA9IF9nZXRDb21wbGV0aW9uUmVjb3JkcyhwYXRoc1tpXSwgY29udGV4dCk7XG4gICAgICBpZiAocGF0aENvbXBsZXRpb25zLmxlbmd0aCA+IDEgfHwgcGF0aENvbXBsZXRpb25zLmxlbmd0aCA9PT0gMSAmJiAhcGF0aENvbXBsZXRpb25zWzBdLnBhdGguaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgY29tcGxldGlvbnMucHVzaCguLi5wYXRoQ29tcGxldGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBsZXRpb25zO1xufVxuZnVuY3Rpb24gX2dldENvbXBsZXRpb25SZWNvcmRzKHBhdGgsIGNvbnRleHQpIHtcbiAgbGV0IHJlY29yZHMgPSBbXTtcbiAgaWYgKHBhdGguaXNJZlN0YXRlbWVudCgpKSB7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiY29uc2VxdWVudFwiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYWx0ZXJuYXRlXCIpLCByZWNvcmRzLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChwYXRoLmlzRG9FeHByZXNzaW9uKCkgfHwgcGF0aC5pc0ZvcigpIHx8IHBhdGguaXNXaGlsZSgpIHx8IHBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkpIHtcbiAgICByZXR1cm4gYWRkQ29tcGxldGlvblJlY29yZHMocGF0aC5nZXQoXCJib2R5XCIpLCByZWNvcmRzLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChwYXRoLmlzUHJvZ3JhbSgpIHx8IHBhdGguaXNCbG9ja1N0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIGdldFN0YXRlbWVudExpc3RDb21wbGV0aW9uKHBhdGguZ2V0KFwiYm9keVwiKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICByZXR1cm4gX2dldENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYm9keVwiKSwgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1RyeVN0YXRlbWVudCgpKSB7XG4gICAgcmVjb3JkcyA9IGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYmxvY2tcIiksIHJlY29yZHMsIGNvbnRleHQpO1xuICAgIHJlY29yZHMgPSBhZGRDb21wbGV0aW9uUmVjb3JkcyhwYXRoLmdldChcImhhbmRsZXJcIiksIHJlY29yZHMsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKHBhdGguaXNDYXRjaENsYXVzZSgpKSB7XG4gICAgcmV0dXJuIGFkZENvbXBsZXRpb25SZWNvcmRzKHBhdGguZ2V0KFwiYm9keVwiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1N3aXRjaFN0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIGNvbXBsZXRpb25SZWNvcmRGb3JTd2l0Y2gocGF0aC5nZXQoXCJjYXNlc1wiKSwgcmVjb3JkcywgY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc1N3aXRjaENhc2UoKSkge1xuICAgIHJldHVybiBnZXRTdGF0ZW1lbnRMaXN0Q29tcGxldGlvbihwYXRoLmdldChcImNvbnNlcXVlbnRcIiksIHtcbiAgICAgIGNhbkhhdmVCcmVhazogdHJ1ZSxcbiAgICAgIHNob3VsZFBvcHVsYXRlQnJlYWs6IGZhbHNlLFxuICAgICAgaW5DYXNlQ2xhdXNlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocGF0aC5pc0JyZWFrU3RhdGVtZW50KCkpIHtcbiAgICByZWNvcmRzLnB1c2goQnJlYWtDb21wbGV0aW9uKHBhdGgpKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvcmRzLnB1c2goTm9ybWFsQ29tcGxldGlvbihwYXRoKSk7XG4gIH1cbiAgcmV0dXJuIHJlY29yZHM7XG59XG5mdW5jdGlvbiBnZXRDb21wbGV0aW9uUmVjb3JkcygpIHtcbiAgY29uc3QgcmVjb3JkcyA9IF9nZXRDb21wbGV0aW9uUmVjb3Jkcyh0aGlzLCB7XG4gICAgY2FuSGF2ZUJyZWFrOiBmYWxzZSxcbiAgICBzaG91bGRQb3B1bGF0ZUJyZWFrOiBmYWxzZSxcbiAgICBpbkNhc2VDbGF1c2U6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gcmVjb3Jkcy5tYXAociA9PiByLnBhdGgpO1xufVxuZnVuY3Rpb24gZ2V0U2libGluZyhrZXkpIHtcbiAgcmV0dXJuIF9pbmRleC5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcy5wYXJlbnRQYXRoLFxuICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICBsaXN0S2V5OiB0aGlzLmxpc3RLZXksXG4gICAga2V5OiBrZXlcbiAgfSkuc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UHJldlNpYmxpbmcoKSB7XG4gIHJldHVybiB0aGlzLmdldFNpYmxpbmcodGhpcy5rZXkgLSAxKTtcbn1cbmZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKCkge1xuICByZXR1cm4gdGhpcy5nZXRTaWJsaW5nKHRoaXMua2V5ICsgMSk7XG59XG5mdW5jdGlvbiBnZXRBbGxOZXh0U2libGluZ3MoKSB7XG4gIGxldCBfa2V5ID0gdGhpcy5rZXk7XG4gIGxldCBzaWJsaW5nID0gdGhpcy5nZXRTaWJsaW5nKCsrX2tleSk7XG4gIGNvbnN0IHNpYmxpbmdzID0gW107XG4gIHdoaWxlIChzaWJsaW5nLm5vZGUpIHtcbiAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoKytfa2V5KTtcbiAgfVxuICByZXR1cm4gc2libGluZ3M7XG59XG5mdW5jdGlvbiBnZXRBbGxQcmV2U2libGluZ3MoKSB7XG4gIGxldCBfa2V5ID0gdGhpcy5rZXk7XG4gIGxldCBzaWJsaW5nID0gdGhpcy5nZXRTaWJsaW5nKC0tX2tleSk7XG4gIGNvbnN0IHNpYmxpbmdzID0gW107XG4gIHdoaWxlIChzaWJsaW5nLm5vZGUpIHtcbiAgICBzaWJsaW5ncy5wdXNoKHNpYmxpbmcpO1xuICAgIHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmcoLS1fa2V5KTtcbiAgfVxuICByZXR1cm4gc2libGluZ3M7XG59XG5mdW5jdGlvbiBnZXQoa2V5LCBjb250ZXh0ID0gdHJ1ZSkge1xuICBpZiAoY29udGV4dCA9PT0gdHJ1ZSkgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoXCIuXCIpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIF9nZXRLZXkuY2FsbCh0aGlzLCBrZXksIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBfZ2V0UGF0dGVybi5jYWxsKHRoaXMsIHBhcnRzLCBjb250ZXh0KTtcbiAgfVxufVxuZnVuY3Rpb24gX2dldEtleShrZXksIGNvbnRleHQpIHtcbiAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZTtcbiAgY29uc3QgY29udGFpbmVyID0gbm9kZVtrZXldO1xuICBpZiAoQXJyYXkuaXNBcnJheShjb250YWluZXIpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5tYXAoKF8sIGkpID0+IHtcbiAgICAgIHJldHVybiBfaW5kZXguZGVmYXVsdC5nZXQoe1xuICAgICAgICBsaXN0S2V5OiBrZXksXG4gICAgICAgIHBhcmVudFBhdGg6IHRoaXMsXG4gICAgICAgIHBhcmVudDogbm9kZSxcbiAgICAgICAgY29udGFpbmVyOiBjb250YWluZXIsXG4gICAgICAgIGtleTogaVxuICAgICAgfSkuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gX2luZGV4LmRlZmF1bHQuZ2V0KHtcbiAgICAgIHBhcmVudFBhdGg6IHRoaXMsXG4gICAgICBwYXJlbnQ6IG5vZGUsXG4gICAgICBjb250YWluZXI6IG5vZGUsXG4gICAgICBrZXk6IGtleVxuICAgIH0pLnNldENvbnRleHQoY29udGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9nZXRQYXR0ZXJuKHBhcnRzLCBjb250ZXh0KSB7XG4gIGxldCBwYXRoID0gdGhpcztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgaWYgKHBhcnQgPT09IFwiLlwiKSB7XG4gICAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgICAgICBwYXRoID0gcGF0aFtwYXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBwYXRoLmdldChwYXJ0LCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnMoKSB7XG4gIHJldHVybiBfZ2V0QXNzaWdubWVudElkZW50aWZpZXJzKHRoaXMubm9kZSk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nSWRlbnRpZmllcnMoZHVwbGljYXRlcykge1xuICByZXR1cm4gX2dldEJpbmRpbmdJZGVudGlmaWVycyh0aGlzLm5vZGUsIGR1cGxpY2F0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoZHVwbGljYXRlcykge1xuICByZXR1cm4gX2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzKHRoaXMubm9kZSwgZHVwbGljYXRlcyk7XG59XG5mdW5jdGlvbiBnZXRCaW5kaW5nSWRlbnRpZmllclBhdGhzKGR1cGxpY2F0ZXMgPSBmYWxzZSwgb3V0ZXJPbmx5ID0gZmFsc2UpIHtcbiAgY29uc3QgcGF0aCA9IHRoaXM7XG4gIGNvbnN0IHNlYXJjaCA9IFtwYXRoXTtcbiAgY29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgd2hpbGUgKHNlYXJjaC5sZW5ndGgpIHtcbiAgICBjb25zdCBpZCA9IHNlYXJjaC5zaGlmdCgpO1xuICAgIGlmICghaWQpIGNvbnRpbnVlO1xuICAgIGlmICghaWQubm9kZSkgY29udGludWU7XG4gICAgY29uc3Qga2V5cyA9IF9nZXRCaW5kaW5nSWRlbnRpZmllcnMua2V5c1tpZC5ub2RlLnR5cGVdO1xuICAgIGlmIChpZC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgaWYgKGR1cGxpY2F0ZXMpIHtcbiAgICAgICAgY29uc3QgX2lkcyA9IGlkc1tpZC5ub2RlLm5hbWVdID0gaWRzW2lkLm5vZGUubmFtZV0gfHwgW107XG4gICAgICAgIF9pZHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHNbaWQubm9kZS5uYW1lXSA9IGlkO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChpZC5pc0V4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gaWQuZ2V0KFwiZGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoZGVjbGFyYXRpb24uaXNEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGRlY2xhcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAob3V0ZXJPbmx5KSB7XG4gICAgICBpZiAoaWQuaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgc2VhcmNoLnB1c2goaWQuZ2V0KFwiaWRcIikpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpZC5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGNvbnN0IGNoaWxkID0gaWQuZ2V0KGtleSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICAgIHNlYXJjaC5wdXNoKC4uLmNoaWxkKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZC5ub2RlKSB7XG4gICAgICAgICAgc2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHM7XG59XG5mdW5jdGlvbiBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyUGF0aHMoZHVwbGljYXRlcyA9IGZhbHNlKSB7XG4gIHJldHVybiB0aGlzLmdldEJpbmRpbmdJZGVudGlmaWVyUGF0aHMoZHVwbGljYXRlcywgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhbWlseS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16109\n')},29709:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = exports.SHOULD_STOP = exports.SHOULD_SKIP = exports.REMOVED = void 0;\nvar virtualTypes = __webpack_require__(75562);\nvar _debug = __webpack_require__(17833);\nvar _index = __webpack_require__(25781);\nvar _index2 = __webpack_require__(86814);\nvar _t = __webpack_require__(2352);\nvar t = _t;\nvar cache = __webpack_require__(37411);\nvar _generator = __webpack_require__(78992);\nvar NodePath_ancestry = __webpack_require__(60940);\nvar NodePath_inference = __webpack_require__(47317);\nvar NodePath_replacement = __webpack_require__(22037);\nvar NodePath_evaluation = __webpack_require__(10299);\nvar NodePath_conversion = __webpack_require__(92257);\nvar NodePath_introspection = __webpack_require__(40854);\nvar _context = __webpack_require__(79578);\nvar NodePath_context = _context;\nvar NodePath_removal = __webpack_require__(53097);\nvar NodePath_modification = __webpack_require__(58345);\nvar NodePath_family = __webpack_require__(16109);\nvar NodePath_comments = __webpack_require__(83383);\nvar NodePath_virtual_types_validator = __webpack_require__(57973);\nconst {\n  validate\n} = _t;\nconst debug = _debug("babel");\nconst REMOVED = exports.REMOVED = 1 << 0;\nconst SHOULD_STOP = exports.SHOULD_STOP = 1 << 1;\nconst SHOULD_SKIP = exports.SHOULD_SKIP = 1 << 2;\nconst NodePath_Final = exports["default"] = class NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n  get removed() {\n    return (this._traverseFlags & 1) > 0;\n  }\n  set removed(v) {\n    if (v) this._traverseFlags |= 1;else this._traverseFlags &= -2;\n  }\n  get shouldStop() {\n    return (this._traverseFlags & 2) > 0;\n  }\n  set shouldStop(v) {\n    if (v) this._traverseFlags |= 2;else this._traverseFlags &= -3;\n  }\n  get shouldSkip() {\n    return (this._traverseFlags & 4) > 0;\n  }\n  set shouldSkip(v) {\n    if (v) this._traverseFlags |= 4;else this._traverseFlags &= -5;\n  }\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n    if (!parent) {\n      throw new Error("To get a node path the parent needs to exist");\n    }\n    const targetNode = container[key];\n    const paths = cache.getOrCreateCachedPaths(hub, parent);\n    let path = paths.get(targetNode);\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n    _context.setup.call(path, parentPath, container, listKey, key);\n    return path;\n  }\n  getScope(scope) {\n    return this.isScope() ? new _index2.default(this) : scope;\n  }\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    return this.data[key] = val;\n  }\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n  hasNode() {\n    return this.node != null;\n  }\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n    return parts.join(".");\n  }\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n  get inList() {\n    return !!this.listKey;\n  }\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n};\nconst methods = {\n  findParent: NodePath_ancestry.findParent,\n  find: NodePath_ancestry.find,\n  getFunctionParent: NodePath_ancestry.getFunctionParent,\n  getStatementParent: NodePath_ancestry.getStatementParent,\n  getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,\n  getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,\n  getAncestry: NodePath_ancestry.getAncestry,\n  isAncestor: NodePath_ancestry.isAncestor,\n  isDescendant: NodePath_ancestry.isDescendant,\n  inType: NodePath_ancestry.inType,\n  getTypeAnnotation: NodePath_inference.getTypeAnnotation,\n  isBaseType: NodePath_inference.isBaseType,\n  couldBeBaseType: NodePath_inference.couldBeBaseType,\n  baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,\n  isGenericType: NodePath_inference.isGenericType,\n  replaceWithMultiple: NodePath_replacement.replaceWithMultiple,\n  replaceWithSourceString: NodePath_replacement.replaceWithSourceString,\n  replaceWith: NodePath_replacement.replaceWith,\n  replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,\n  replaceInline: NodePath_replacement.replaceInline,\n  evaluateTruthy: NodePath_evaluation.evaluateTruthy,\n  evaluate: NodePath_evaluation.evaluate,\n  toComputedKey: NodePath_conversion.toComputedKey,\n  ensureBlock: NodePath_conversion.ensureBlock,\n  unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,\n  arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,\n  splitExportDeclaration: NodePath_conversion.splitExportDeclaration,\n  ensureFunctionName: NodePath_conversion.ensureFunctionName,\n  matchesPattern: NodePath_introspection.matchesPattern,\n  isStatic: NodePath_introspection.isStatic,\n  isNodeType: NodePath_introspection.isNodeType,\n  canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,\n  canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,\n  isCompletionRecord: NodePath_introspection.isCompletionRecord,\n  isStatementOrBlock: NodePath_introspection.isStatementOrBlock,\n  referencesImport: NodePath_introspection.referencesImport,\n  getSource: NodePath_introspection.getSource,\n  willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,\n  _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,\n  resolve: NodePath_introspection.resolve,\n  isConstantExpression: NodePath_introspection.isConstantExpression,\n  isInStrictMode: NodePath_introspection.isInStrictMode,\n  isDenylisted: NodePath_context.isDenylisted,\n  visit: NodePath_context.visit,\n  skip: NodePath_context.skip,\n  skipKey: NodePath_context.skipKey,\n  stop: NodePath_context.stop,\n  setContext: NodePath_context.setContext,\n  requeue: NodePath_context.requeue,\n  requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,\n  remove: NodePath_removal.remove,\n  insertBefore: NodePath_modification.insertBefore,\n  insertAfter: NodePath_modification.insertAfter,\n  unshiftContainer: NodePath_modification.unshiftContainer,\n  pushContainer: NodePath_modification.pushContainer,\n  getOpposite: NodePath_family.getOpposite,\n  getCompletionRecords: NodePath_family.getCompletionRecords,\n  getSibling: NodePath_family.getSibling,\n  getPrevSibling: NodePath_family.getPrevSibling,\n  getNextSibling: NodePath_family.getNextSibling,\n  getAllNextSiblings: NodePath_family.getAllNextSiblings,\n  getAllPrevSiblings: NodePath_family.getAllPrevSiblings,\n  get: NodePath_family.get,\n  getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,\n  getBindingIdentifiers: NodePath_family.getBindingIdentifiers,\n  getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,\n  getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,\n  getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,\n  shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,\n  addComment: NodePath_comments.addComment,\n  addComments: NodePath_comments.addComments\n};\nObject.assign(NodePath_Final.prototype, methods);\n{\n  NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];\n  Object.assign(NodePath_Final.prototype, {\n    has: NodePath_introspection[String("has")],\n    is: NodePath_introspection[String("is")],\n    isnt: NodePath_introspection[String("isnt")],\n    equals: NodePath_introspection[String("equals")],\n    hoist: NodePath_modification[String("hoist")],\n    updateSiblingKeys: NodePath_modification.updateSiblingKeys,\n    call: NodePath_context.call,\n    isBlacklisted: NodePath_context[String("isBlacklisted")],\n    setScope: NodePath_context.setScope,\n    resync: NodePath_context.resync,\n    popContext: NodePath_context.popContext,\n    pushContext: NodePath_context.pushContext,\n    setup: NodePath_context.setup,\n    setKey: NodePath_context.setKey\n  });\n}\n{\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\n  NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;\n  Object.assign(NodePath_Final.prototype, {\n    _getTypeAnnotation: NodePath_inference._getTypeAnnotation,\n    _replaceWith: NodePath_replacement._replaceWith,\n    _resolve: NodePath_introspection._resolve,\n    _call: NodePath_context._call,\n    _resyncParent: NodePath_context._resyncParent,\n    _resyncKey: NodePath_context._resyncKey,\n    _resyncList: NodePath_context._resyncList,\n    _resyncRemoved: NodePath_context._resyncRemoved,\n    _getQueueContexts: NodePath_context._getQueueContexts,\n    _removeFromScope: NodePath_removal._removeFromScope,\n    _callRemovalHooks: NodePath_removal._callRemovalHooks,\n    _remove: NodePath_removal._remove,\n    _markRemoved: NodePath_removal._markRemoved,\n    _assertUnremoved: NodePath_removal._assertUnremoved,\n    _containerInsert: NodePath_modification._containerInsert,\n    _containerInsertBefore: NodePath_modification._containerInsertBefore,\n    _containerInsertAfter: NodePath_modification._containerInsertAfter,\n    _verifyNodeList: NodePath_modification._verifyNodeList,\n    _getKey: NodePath_family._getKey,\n    _getPattern: NodePath_family._getPattern\n  });\n}\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n  NodePath_Final.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n  NodePath_Final.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\nObject.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === "_") continue;\n  if (!t.TYPES.includes(type)) t.TYPES.push(type);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjk3MDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWUsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlO0FBQzdFLG1CQUFtQixtQkFBTyxDQUFDLEtBQXdCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyxLQUFPO0FBQzVCLGFBQWEsbUJBQU8sQ0FBQyxLQUFhO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyxLQUFtQjtBQUN6QyxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQjtBQUNBLFlBQVksbUJBQU8sQ0FBQyxLQUFhO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLEtBQWtCO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLEtBQWU7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsS0FBc0I7QUFDdkQsMkJBQTJCLG1CQUFPLENBQUMsS0FBa0I7QUFDckQsMEJBQTBCLG1CQUFPLENBQUMsS0FBaUI7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsS0FBaUI7QUFDbkQsNkJBQTZCLG1CQUFPLENBQUMsS0FBb0I7QUFDekQsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxLQUFjO0FBQzdDLDRCQUE0QixtQkFBTyxDQUFDLEtBQW1CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLEtBQWE7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMsS0FBZTtBQUMvQyx1Q0FBdUMsbUJBQU8sQ0FBQyxLQUFrQztBQUNqRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0Isb0JBQW9CLG1CQUFtQjtBQUN2QyxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHVCQUF1QixrQkFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYSxHQUFHLElBQUk7QUFDcEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QixFQUFFLFVBQVUsSUFBSSxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvaW5kZXguanM/ZWVmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuU0hPVUxEX1NUT1AgPSBleHBvcnRzLlNIT1VMRF9TS0lQID0gZXhwb3J0cy5SRU1PVkVEID0gdm9pZCAwO1xudmFyIHZpcnR1YWxUeXBlcyA9IHJlcXVpcmUoXCIuL2xpYi92aXJ0dWFsLXR5cGVzLmpzXCIpO1xudmFyIF9kZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9zY29wZS9pbmRleC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgdCA9IF90O1xudmFyIGNhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xudmFyIF9nZW5lcmF0b3IgPSByZXF1aXJlKFwiQGJhYmVsL2dlbmVyYXRvclwiKTtcbnZhciBOb2RlUGF0aF9hbmNlc3RyeSA9IHJlcXVpcmUoXCIuL2FuY2VzdHJ5LmpzXCIpO1xudmFyIE5vZGVQYXRoX2luZmVyZW5jZSA9IHJlcXVpcmUoXCIuL2luZmVyZW5jZS9pbmRleC5qc1wiKTtcbnZhciBOb2RlUGF0aF9yZXBsYWNlbWVudCA9IHJlcXVpcmUoXCIuL3JlcGxhY2VtZW50LmpzXCIpO1xudmFyIE5vZGVQYXRoX2V2YWx1YXRpb24gPSByZXF1aXJlKFwiLi9ldmFsdWF0aW9uLmpzXCIpO1xudmFyIE5vZGVQYXRoX2NvbnZlcnNpb24gPSByZXF1aXJlKFwiLi9jb252ZXJzaW9uLmpzXCIpO1xudmFyIE5vZGVQYXRoX2ludHJvc3BlY3Rpb24gPSByZXF1aXJlKFwiLi9pbnRyb3NwZWN0aW9uLmpzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbnZhciBOb2RlUGF0aF9jb250ZXh0ID0gX2NvbnRleHQ7XG52YXIgTm9kZVBhdGhfcmVtb3ZhbCA9IHJlcXVpcmUoXCIuL3JlbW92YWwuanNcIik7XG52YXIgTm9kZVBhdGhfbW9kaWZpY2F0aW9uID0gcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9uLmpzXCIpO1xudmFyIE5vZGVQYXRoX2ZhbWlseSA9IHJlcXVpcmUoXCIuL2ZhbWlseS5qc1wiKTtcbnZhciBOb2RlUGF0aF9jb21tZW50cyA9IHJlcXVpcmUoXCIuL2NvbW1lbnRzLmpzXCIpO1xudmFyIE5vZGVQYXRoX3ZpcnR1YWxfdHlwZXNfdmFsaWRhdG9yID0gcmVxdWlyZShcIi4vbGliL3ZpcnR1YWwtdHlwZXMtdmFsaWRhdG9yLmpzXCIpO1xuY29uc3Qge1xuICB2YWxpZGF0ZVxufSA9IF90O1xuY29uc3QgZGVidWcgPSBfZGVidWcoXCJiYWJlbFwiKTtcbmNvbnN0IFJFTU9WRUQgPSBleHBvcnRzLlJFTU9WRUQgPSAxIDw8IDA7XG5jb25zdCBTSE9VTERfU1RPUCA9IGV4cG9ydHMuU0hPVUxEX1NUT1AgPSAxIDw8IDE7XG5jb25zdCBTSE9VTERfU0tJUCA9IGV4cG9ydHMuU0hPVUxEX1NLSVAgPSAxIDw8IDI7XG5jb25zdCBOb2RlUGF0aF9GaW5hbCA9IGV4cG9ydHMuZGVmYXVsdCA9IGNsYXNzIE5vZGVQYXRoIHtcbiAgY29uc3RydWN0b3IoaHViLCBwYXJlbnQpIHtcbiAgICB0aGlzLmNvbnRleHRzID0gW107XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5vcHRzID0gbnVsbDtcbiAgICB0aGlzLl90cmF2ZXJzZUZsYWdzID0gMDtcbiAgICB0aGlzLnNraXBLZXlzID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudFBhdGggPSBudWxsO1xuICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB0aGlzLmxpc3RLZXkgPSBudWxsO1xuICAgIHRoaXMua2V5ID0gbnVsbDtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgIHRoaXMudHlwZSA9IG51bGw7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5odWIgPSBodWI7XG4gICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICB9XG4gIGdldCByZW1vdmVkKCkge1xuICAgIHJldHVybiAodGhpcy5fdHJhdmVyc2VGbGFncyAmIDEpID4gMDtcbiAgfVxuICBzZXQgcmVtb3ZlZCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuX3RyYXZlcnNlRmxhZ3MgfD0gMTtlbHNlIHRoaXMuX3RyYXZlcnNlRmxhZ3MgJj0gLTI7XG4gIH1cbiAgZ2V0IHNob3VsZFN0b3AoKSB7XG4gICAgcmV0dXJuICh0aGlzLl90cmF2ZXJzZUZsYWdzICYgMikgPiAwO1xuICB9XG4gIHNldCBzaG91bGRTdG9wKHYpIHtcbiAgICBpZiAodikgdGhpcy5fdHJhdmVyc2VGbGFncyB8PSAyO2Vsc2UgdGhpcy5fdHJhdmVyc2VGbGFncyAmPSAtMztcbiAgfVxuICBnZXQgc2hvdWxkU2tpcCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3RyYXZlcnNlRmxhZ3MgJiA0KSA+IDA7XG4gIH1cbiAgc2V0IHNob3VsZFNraXAodikge1xuICAgIGlmICh2KSB0aGlzLl90cmF2ZXJzZUZsYWdzIHw9IDQ7ZWxzZSB0aGlzLl90cmF2ZXJzZUZsYWdzICY9IC01O1xuICB9XG4gIHN0YXRpYyBnZXQoe1xuICAgIGh1YixcbiAgICBwYXJlbnRQYXRoLFxuICAgIHBhcmVudCxcbiAgICBjb250YWluZXIsXG4gICAgbGlzdEtleSxcbiAgICBrZXlcbiAgfSkge1xuICAgIGlmICghaHViICYmIHBhcmVudFBhdGgpIHtcbiAgICAgIGh1YiA9IHBhcmVudFBhdGguaHViO1xuICAgIH1cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gZ2V0IGEgbm9kZSBwYXRoIHRoZSBwYXJlbnQgbmVlZHMgdG8gZXhpc3RcIik7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldE5vZGUgPSBjb250YWluZXJba2V5XTtcbiAgICBjb25zdCBwYXRocyA9IGNhY2hlLmdldE9yQ3JlYXRlQ2FjaGVkUGF0aHMoaHViLCBwYXJlbnQpO1xuICAgIGxldCBwYXRoID0gcGF0aHMuZ2V0KHRhcmdldE5vZGUpO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgcGF0aCA9IG5ldyBOb2RlUGF0aChodWIsIHBhcmVudCk7XG4gICAgICBpZiAodGFyZ2V0Tm9kZSkgcGF0aHMuc2V0KHRhcmdldE5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBfY29udGV4dC5zZXR1cC5jYWxsKHBhdGgsIHBhcmVudFBhdGgsIGNvbnRhaW5lciwgbGlzdEtleSwga2V5KTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICBnZXRTY29wZShzY29wZSkge1xuICAgIHJldHVybiB0aGlzLmlzU2NvcGUoKSA/IG5ldyBfaW5kZXgyLmRlZmF1bHQodGhpcykgOiBzY29wZTtcbiAgfVxuICBzZXREYXRhKGtleSwgdmFsKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV0gPSB2YWw7XG4gIH1cbiAgZ2V0RGF0YShrZXksIGRlZikge1xuICAgIGlmICh0aGlzLmRhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5kYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgbGV0IHZhbCA9IHRoaXMuZGF0YVtrZXldO1xuICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCAmJiBkZWYgIT09IHVuZGVmaW5lZCkgdmFsID0gdGhpcy5kYXRhW2tleV0gPSBkZWY7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBoYXNOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUgIT0gbnVsbDtcbiAgfVxuICBidWlsZENvZGVGcmFtZUVycm9yKG1zZywgRXJyb3IgPSBTeW50YXhFcnJvcikge1xuICAgIHJldHVybiB0aGlzLmh1Yi5idWlsZEVycm9yKHRoaXMubm9kZSwgbXNnLCBFcnJvcik7XG4gIH1cbiAgdHJhdmVyc2UodmlzaXRvciwgc3RhdGUpIHtcbiAgICAoMCwgX2luZGV4LmRlZmF1bHQpKHRoaXMubm9kZSwgdmlzaXRvciwgdGhpcy5zY29wZSwgc3RhdGUsIHRoaXMpO1xuICB9XG4gIHNldChrZXksIG5vZGUpIHtcbiAgICB2YWxpZGF0ZSh0aGlzLm5vZGUsIGtleSwgbm9kZSk7XG4gICAgdGhpcy5ub2RlW2tleV0gPSBub2RlO1xuICB9XG4gIGdldFBhdGhMb2NhdGlvbigpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGxldCBwYXRoID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBsZXQga2V5ID0gcGF0aC5rZXk7XG4gICAgICBpZiAocGF0aC5pbkxpc3QpIGtleSA9IGAke3BhdGgubGlzdEtleX1bJHtrZXl9XWA7XG4gICAgICBwYXJ0cy51bnNoaWZ0KGtleSk7XG4gICAgfSB3aGlsZSAocGF0aCA9IHBhdGgucGFyZW50UGF0aCk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCIuXCIpO1xuICB9XG4gIGRlYnVnKG1lc3NhZ2UpIHtcbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcbiAgICBkZWJ1ZyhgJHt0aGlzLmdldFBhdGhMb2NhdGlvbigpfSAke3RoaXMudHlwZX06ICR7bWVzc2FnZX1gKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gKDAsIF9nZW5lcmF0b3IuZGVmYXVsdCkodGhpcy5ub2RlKS5jb2RlO1xuICB9XG4gIGdldCBpbkxpc3QoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5saXN0S2V5O1xuICB9XG4gIHNldCBpbkxpc3QoaW5MaXN0KSB7XG4gICAgaWYgKCFpbkxpc3QpIHtcbiAgICAgIHRoaXMubGlzdEtleSA9IG51bGw7XG4gICAgfVxuICB9XG4gIGdldCBwYXJlbnRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdEtleSB8fCB0aGlzLmtleTtcbiAgfVxufTtcbmNvbnN0IG1ldGhvZHMgPSB7XG4gIGZpbmRQYXJlbnQ6IE5vZGVQYXRoX2FuY2VzdHJ5LmZpbmRQYXJlbnQsXG4gIGZpbmQ6IE5vZGVQYXRoX2FuY2VzdHJ5LmZpbmQsXG4gIGdldEZ1bmN0aW9uUGFyZW50OiBOb2RlUGF0aF9hbmNlc3RyeS5nZXRGdW5jdGlvblBhcmVudCxcbiAgZ2V0U3RhdGVtZW50UGFyZW50OiBOb2RlUGF0aF9hbmNlc3RyeS5nZXRTdGF0ZW1lbnRQYXJlbnQsXG4gIGdldEVhcmxpZXN0Q29tbW9uQW5jZXN0b3JGcm9tOiBOb2RlUGF0aF9hbmNlc3RyeS5nZXRFYXJsaWVzdENvbW1vbkFuY2VzdG9yRnJvbSxcbiAgZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbTogTm9kZVBhdGhfYW5jZXN0cnkuZ2V0RGVlcGVzdENvbW1vbkFuY2VzdG9yRnJvbSxcbiAgZ2V0QW5jZXN0cnk6IE5vZGVQYXRoX2FuY2VzdHJ5LmdldEFuY2VzdHJ5LFxuICBpc0FuY2VzdG9yOiBOb2RlUGF0aF9hbmNlc3RyeS5pc0FuY2VzdG9yLFxuICBpc0Rlc2NlbmRhbnQ6IE5vZGVQYXRoX2FuY2VzdHJ5LmlzRGVzY2VuZGFudCxcbiAgaW5UeXBlOiBOb2RlUGF0aF9hbmNlc3RyeS5pblR5cGUsXG4gIGdldFR5cGVBbm5vdGF0aW9uOiBOb2RlUGF0aF9pbmZlcmVuY2UuZ2V0VHlwZUFubm90YXRpb24sXG4gIGlzQmFzZVR5cGU6IE5vZGVQYXRoX2luZmVyZW5jZS5pc0Jhc2VUeXBlLFxuICBjb3VsZEJlQmFzZVR5cGU6IE5vZGVQYXRoX2luZmVyZW5jZS5jb3VsZEJlQmFzZVR5cGUsXG4gIGJhc2VUeXBlU3RyaWN0bHlNYXRjaGVzOiBOb2RlUGF0aF9pbmZlcmVuY2UuYmFzZVR5cGVTdHJpY3RseU1hdGNoZXMsXG4gIGlzR2VuZXJpY1R5cGU6IE5vZGVQYXRoX2luZmVyZW5jZS5pc0dlbmVyaWNUeXBlLFxuICByZXBsYWNlV2l0aE11bHRpcGxlOiBOb2RlUGF0aF9yZXBsYWNlbWVudC5yZXBsYWNlV2l0aE11bHRpcGxlLFxuICByZXBsYWNlV2l0aFNvdXJjZVN0cmluZzogTm9kZVBhdGhfcmVwbGFjZW1lbnQucmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcsXG4gIHJlcGxhY2VXaXRoOiBOb2RlUGF0aF9yZXBsYWNlbWVudC5yZXBsYWNlV2l0aCxcbiAgcmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50czogTm9kZVBhdGhfcmVwbGFjZW1lbnQucmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cyxcbiAgcmVwbGFjZUlubGluZTogTm9kZVBhdGhfcmVwbGFjZW1lbnQucmVwbGFjZUlubGluZSxcbiAgZXZhbHVhdGVUcnV0aHk6IE5vZGVQYXRoX2V2YWx1YXRpb24uZXZhbHVhdGVUcnV0aHksXG4gIGV2YWx1YXRlOiBOb2RlUGF0aF9ldmFsdWF0aW9uLmV2YWx1YXRlLFxuICB0b0NvbXB1dGVkS2V5OiBOb2RlUGF0aF9jb252ZXJzaW9uLnRvQ29tcHV0ZWRLZXksXG4gIGVuc3VyZUJsb2NrOiBOb2RlUGF0aF9jb252ZXJzaW9uLmVuc3VyZUJsb2NrLFxuICB1bndyYXBGdW5jdGlvbkVudmlyb25tZW50OiBOb2RlUGF0aF9jb252ZXJzaW9uLnVud3JhcEZ1bmN0aW9uRW52aXJvbm1lbnQsXG4gIGFycm93RnVuY3Rpb25Ub0V4cHJlc3Npb246IE5vZGVQYXRoX2NvbnZlcnNpb24uYXJyb3dGdW5jdGlvblRvRXhwcmVzc2lvbixcbiAgc3BsaXRFeHBvcnREZWNsYXJhdGlvbjogTm9kZVBhdGhfY29udmVyc2lvbi5zcGxpdEV4cG9ydERlY2xhcmF0aW9uLFxuICBlbnN1cmVGdW5jdGlvbk5hbWU6IE5vZGVQYXRoX2NvbnZlcnNpb24uZW5zdXJlRnVuY3Rpb25OYW1lLFxuICBtYXRjaGVzUGF0dGVybjogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5tYXRjaGVzUGF0dGVybixcbiAgaXNTdGF0aWM6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uaXNTdGF0aWMsXG4gIGlzTm9kZVR5cGU6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uaXNOb2RlVHlwZSxcbiAgY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb246IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb24sXG4gIGNhblN3YXBCZXR3ZWVuRXhwcmVzc2lvbkFuZFN0YXRlbWVudDogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5jYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQsXG4gIGlzQ29tcGxldGlvblJlY29yZDogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc0NvbXBsZXRpb25SZWNvcmQsXG4gIGlzU3RhdGVtZW50T3JCbG9jazogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc1N0YXRlbWVudE9yQmxvY2ssXG4gIHJlZmVyZW5jZXNJbXBvcnQ6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24ucmVmZXJlbmNlc0ltcG9ydCxcbiAgZ2V0U291cmNlOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLmdldFNvdXJjZSxcbiAgd2lsbElNYXliZUV4ZWN1dGVCZWZvcmU6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24ud2lsbElNYXliZUV4ZWN1dGVCZWZvcmUsXG4gIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG86IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbyxcbiAgcmVzb2x2ZTogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5yZXNvbHZlLFxuICBpc0NvbnN0YW50RXhwcmVzc2lvbjogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5pc0NvbnN0YW50RXhwcmVzc2lvbixcbiAgaXNJblN0cmljdE1vZGU6IE5vZGVQYXRoX2ludHJvc3BlY3Rpb24uaXNJblN0cmljdE1vZGUsXG4gIGlzRGVueWxpc3RlZDogTm9kZVBhdGhfY29udGV4dC5pc0RlbnlsaXN0ZWQsXG4gIHZpc2l0OiBOb2RlUGF0aF9jb250ZXh0LnZpc2l0LFxuICBza2lwOiBOb2RlUGF0aF9jb250ZXh0LnNraXAsXG4gIHNraXBLZXk6IE5vZGVQYXRoX2NvbnRleHQuc2tpcEtleSxcbiAgc3RvcDogTm9kZVBhdGhfY29udGV4dC5zdG9wLFxuICBzZXRDb250ZXh0OiBOb2RlUGF0aF9jb250ZXh0LnNldENvbnRleHQsXG4gIHJlcXVldWU6IE5vZGVQYXRoX2NvbnRleHQucmVxdWV1ZSxcbiAgcmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9yczogTm9kZVBhdGhfY29udGV4dC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzLFxuICByZW1vdmU6IE5vZGVQYXRoX3JlbW92YWwucmVtb3ZlLFxuICBpbnNlcnRCZWZvcmU6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi5pbnNlcnRCZWZvcmUsXG4gIGluc2VydEFmdGVyOiBOb2RlUGF0aF9tb2RpZmljYXRpb24uaW5zZXJ0QWZ0ZXIsXG4gIHVuc2hpZnRDb250YWluZXI6IE5vZGVQYXRoX21vZGlmaWNhdGlvbi51bnNoaWZ0Q29udGFpbmVyLFxuICBwdXNoQ29udGFpbmVyOiBOb2RlUGF0aF9tb2RpZmljYXRpb24ucHVzaENvbnRhaW5lcixcbiAgZ2V0T3Bwb3NpdGU6IE5vZGVQYXRoX2ZhbWlseS5nZXRPcHBvc2l0ZSxcbiAgZ2V0Q29tcGxldGlvblJlY29yZHM6IE5vZGVQYXRoX2ZhbWlseS5nZXRDb21wbGV0aW9uUmVjb3JkcyxcbiAgZ2V0U2libGluZzogTm9kZVBhdGhfZmFtaWx5LmdldFNpYmxpbmcsXG4gIGdldFByZXZTaWJsaW5nOiBOb2RlUGF0aF9mYW1pbHkuZ2V0UHJldlNpYmxpbmcsXG4gIGdldE5leHRTaWJsaW5nOiBOb2RlUGF0aF9mYW1pbHkuZ2V0TmV4dFNpYmxpbmcsXG4gIGdldEFsbE5leHRTaWJsaW5nczogTm9kZVBhdGhfZmFtaWx5LmdldEFsbE5leHRTaWJsaW5ncyxcbiAgZ2V0QWxsUHJldlNpYmxpbmdzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0QWxsUHJldlNpYmxpbmdzLFxuICBnZXQ6IE5vZGVQYXRoX2ZhbWlseS5nZXQsXG4gIGdldEFzc2lnbm1lbnRJZGVudGlmaWVyczogTm9kZVBhdGhfZmFtaWx5LmdldEFzc2lnbm1lbnRJZGVudGlmaWVycyxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0QmluZGluZ0lkZW50aWZpZXJzLFxuICBnZXRPdXRlckJpbmRpbmdJZGVudGlmaWVyczogTm9kZVBhdGhfZmFtaWx5LmdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLFxuICBnZXRCaW5kaW5nSWRlbnRpZmllclBhdGhzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0QmluZGluZ0lkZW50aWZpZXJQYXRocyxcbiAgZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzOiBOb2RlUGF0aF9mYW1pbHkuZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllclBhdGhzLFxuICBzaGFyZUNvbW1lbnRzV2l0aFNpYmxpbmdzOiBOb2RlUGF0aF9jb21tZW50cy5zaGFyZUNvbW1lbnRzV2l0aFNpYmxpbmdzLFxuICBhZGRDb21tZW50OiBOb2RlUGF0aF9jb21tZW50cy5hZGRDb21tZW50LFxuICBhZGRDb21tZW50czogTm9kZVBhdGhfY29tbWVudHMuYWRkQ29tbWVudHNcbn07XG5PYmplY3QuYXNzaWduKE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZSwgbWV0aG9kcyk7XG57XG4gIE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZS5hcnJvd0Z1bmN0aW9uVG9TaGFkb3dlZCA9IE5vZGVQYXRoX2NvbnZlcnNpb25bU3RyaW5nKFwiYXJyb3dGdW5jdGlvblRvU2hhZG93ZWRcIildO1xuICBPYmplY3QuYXNzaWduKE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZSwge1xuICAgIGhhczogTm9kZVBhdGhfaW50cm9zcGVjdGlvbltTdHJpbmcoXCJoYXNcIildLFxuICAgIGlzOiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uW1N0cmluZyhcImlzXCIpXSxcbiAgICBpc250OiBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uW1N0cmluZyhcImlzbnRcIildLFxuICAgIGVxdWFsczogTm9kZVBhdGhfaW50cm9zcGVjdGlvbltTdHJpbmcoXCJlcXVhbHNcIildLFxuICAgIGhvaXN0OiBOb2RlUGF0aF9tb2RpZmljYXRpb25bU3RyaW5nKFwiaG9pc3RcIildLFxuICAgIHVwZGF0ZVNpYmxpbmdLZXlzOiBOb2RlUGF0aF9tb2RpZmljYXRpb24udXBkYXRlU2libGluZ0tleXMsXG4gICAgY2FsbDogTm9kZVBhdGhfY29udGV4dC5jYWxsLFxuICAgIGlzQmxhY2tsaXN0ZWQ6IE5vZGVQYXRoX2NvbnRleHRbU3RyaW5nKFwiaXNCbGFja2xpc3RlZFwiKV0sXG4gICAgc2V0U2NvcGU6IE5vZGVQYXRoX2NvbnRleHQuc2V0U2NvcGUsXG4gICAgcmVzeW5jOiBOb2RlUGF0aF9jb250ZXh0LnJlc3luYyxcbiAgICBwb3BDb250ZXh0OiBOb2RlUGF0aF9jb250ZXh0LnBvcENvbnRleHQsXG4gICAgcHVzaENvbnRleHQ6IE5vZGVQYXRoX2NvbnRleHQucHVzaENvbnRleHQsXG4gICAgc2V0dXA6IE5vZGVQYXRoX2NvbnRleHQuc2V0dXAsXG4gICAgc2V0S2V5OiBOb2RlUGF0aF9jb250ZXh0LnNldEtleVxuICB9KTtcbn1cbntcbiAgTm9kZVBhdGhfRmluYWwucHJvdG90eXBlLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnMgPSBOb2RlUGF0aF9pbnRyb3NwZWN0aW9uLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG87XG4gIE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZS5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvRGlmZmVyZW50RnVuY3Rpb25zID0gTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5fZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvO1xuICBPYmplY3QuYXNzaWduKE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZSwge1xuICAgIF9nZXRUeXBlQW5ub3RhdGlvbjogTm9kZVBhdGhfaW5mZXJlbmNlLl9nZXRUeXBlQW5ub3RhdGlvbixcbiAgICBfcmVwbGFjZVdpdGg6IE5vZGVQYXRoX3JlcGxhY2VtZW50Ll9yZXBsYWNlV2l0aCxcbiAgICBfcmVzb2x2ZTogTm9kZVBhdGhfaW50cm9zcGVjdGlvbi5fcmVzb2x2ZSxcbiAgICBfY2FsbDogTm9kZVBhdGhfY29udGV4dC5fY2FsbCxcbiAgICBfcmVzeW5jUGFyZW50OiBOb2RlUGF0aF9jb250ZXh0Ll9yZXN5bmNQYXJlbnQsXG4gICAgX3Jlc3luY0tleTogTm9kZVBhdGhfY29udGV4dC5fcmVzeW5jS2V5LFxuICAgIF9yZXN5bmNMaXN0OiBOb2RlUGF0aF9jb250ZXh0Ll9yZXN5bmNMaXN0LFxuICAgIF9yZXN5bmNSZW1vdmVkOiBOb2RlUGF0aF9jb250ZXh0Ll9yZXN5bmNSZW1vdmVkLFxuICAgIF9nZXRRdWV1ZUNvbnRleHRzOiBOb2RlUGF0aF9jb250ZXh0Ll9nZXRRdWV1ZUNvbnRleHRzLFxuICAgIF9yZW1vdmVGcm9tU2NvcGU6IE5vZGVQYXRoX3JlbW92YWwuX3JlbW92ZUZyb21TY29wZSxcbiAgICBfY2FsbFJlbW92YWxIb29rczogTm9kZVBhdGhfcmVtb3ZhbC5fY2FsbFJlbW92YWxIb29rcyxcbiAgICBfcmVtb3ZlOiBOb2RlUGF0aF9yZW1vdmFsLl9yZW1vdmUsXG4gICAgX21hcmtSZW1vdmVkOiBOb2RlUGF0aF9yZW1vdmFsLl9tYXJrUmVtb3ZlZCxcbiAgICBfYXNzZXJ0VW5yZW1vdmVkOiBOb2RlUGF0aF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQsXG4gICAgX2NvbnRhaW5lckluc2VydDogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLl9jb250YWluZXJJbnNlcnQsXG4gICAgX2NvbnRhaW5lckluc2VydEJlZm9yZTogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLl9jb250YWluZXJJbnNlcnRCZWZvcmUsXG4gICAgX2NvbnRhaW5lckluc2VydEFmdGVyOiBOb2RlUGF0aF9tb2RpZmljYXRpb24uX2NvbnRhaW5lckluc2VydEFmdGVyLFxuICAgIF92ZXJpZnlOb2RlTGlzdDogTm9kZVBhdGhfbW9kaWZpY2F0aW9uLl92ZXJpZnlOb2RlTGlzdCxcbiAgICBfZ2V0S2V5OiBOb2RlUGF0aF9mYW1pbHkuX2dldEtleSxcbiAgICBfZ2V0UGF0dGVybjogTm9kZVBhdGhfZmFtaWx5Ll9nZXRQYXR0ZXJuXG4gIH0pO1xufVxuZm9yIChjb25zdCB0eXBlIG9mIHQuVFlQRVMpIHtcbiAgY29uc3QgdHlwZUtleSA9IGBpcyR7dHlwZX1gO1xuICBjb25zdCBmbiA9IHRbdHlwZUtleV07XG4gIE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZVt0eXBlS2V5XSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgcmV0dXJuIGZuKHRoaXMubm9kZSwgb3B0cyk7XG4gIH07XG4gIE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZVtgYXNzZXJ0JHt0eXBlfWBdID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBpZiAoIWZuKHRoaXMubm9kZSwgb3B0cykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIG5vZGUgcGF0aCBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG4gIH07XG59XG5PYmplY3QuYXNzaWduKE5vZGVQYXRoX0ZpbmFsLnByb3RvdHlwZSwgTm9kZVBhdGhfdmlydHVhbF90eXBlc192YWxpZGF0b3IpO1xuZm9yIChjb25zdCB0eXBlIG9mIE9iamVjdC5rZXlzKHZpcnR1YWxUeXBlcykpIHtcbiAgaWYgKHR5cGVbMF0gPT09IFwiX1wiKSBjb250aW51ZTtcbiAgaWYgKCF0LlRZUEVTLmluY2x1ZGVzKHR5cGUpKSB0LlRZUEVTLnB1c2godHlwZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29709\n')},47317:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\nvar inferers = __webpack_require__(39937);\nvar _t = __webpack_require__(2352);\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction getTypeAnnotation() {\n  let type = this.getData("typeAnnotation");\n  if (type != null) {\n    return type;\n  }\n  type = _getTypeAnnotation.call(this) || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData("typeAnnotation", type);\n  return type;\n}\nconst typeAnnotationInferringNodes = new WeakSet();\nfunction _getTypeAnnotation() {\n  const node = this.node;\n  if (!node) {\n    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n      if (declar.key === "left" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n      if (declar.key === "left" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n  try {\n    var _inferer;\n    let inferer = inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n    inferer = inferers[this.parentPath.type];\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === "string") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === "number") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === "boolean") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === "any") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === "mixed") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === "empty") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === "void") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  if (genericName === "Array") {\n    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {\n      return true;\n    }\n  }\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  }) || isTSTypeReference(type) && isIdentifier(type.typeName, {\n    name: genericName\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDczMTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQixxQkFBcUI7QUFDckIsZUFBZSxtQkFBTyxDQUFDLEtBQWU7QUFDdEMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvaW5mZXJlbmNlL2luZGV4LmpzPzRmMjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9nZXRUeXBlQW5ub3RhdGlvbiA9IF9nZXRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYmFzZVR5cGVTdHJpY3RseU1hdGNoZXMgPSBiYXNlVHlwZVN0cmljdGx5TWF0Y2hlcztcbmV4cG9ydHMuY291bGRCZUJhc2VUeXBlID0gY291bGRCZUJhc2VUeXBlO1xuZXhwb3J0cy5nZXRUeXBlQW5ub3RhdGlvbiA9IGdldFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Jhc2VUeXBlID0gaXNCYXNlVHlwZTtcbmV4cG9ydHMuaXNHZW5lcmljVHlwZSA9IGlzR2VuZXJpY1R5cGU7XG52YXIgaW5mZXJlcnMgPSByZXF1aXJlKFwiLi9pbmZlcmVycy5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGFueVR5cGVBbm5vdGF0aW9uLFxuICBpc0FueVR5cGVBbm5vdGF0aW9uLFxuICBpc0FycmF5VHlwZUFubm90YXRpb24sXG4gIGlzQm9vbGVhblR5cGVBbm5vdGF0aW9uLFxuICBpc0VtcHR5VHlwZUFubm90YXRpb24sXG4gIGlzRmxvd0Jhc2VBbm5vdGF0aW9uLFxuICBpc0dlbmVyaWNUeXBlQW5ub3RhdGlvbixcbiAgaXNJZGVudGlmaWVyLFxuICBpc01peGVkVHlwZUFubm90YXRpb24sXG4gIGlzTnVtYmVyVHlwZUFubm90YXRpb24sXG4gIGlzU3RyaW5nVHlwZUFubm90YXRpb24sXG4gIGlzVFNBcnJheVR5cGUsXG4gIGlzVFNUeXBlQW5ub3RhdGlvbixcbiAgaXNUU1R5cGVSZWZlcmVuY2UsXG4gIGlzVHVwbGVUeXBlQW5ub3RhdGlvbixcbiAgaXNUeXBlQW5ub3RhdGlvbixcbiAgaXNVbmlvblR5cGVBbm5vdGF0aW9uLFxuICBpc1ZvaWRUeXBlQW5ub3RhdGlvbixcbiAgc3RyaW5nVHlwZUFubm90YXRpb24sXG4gIHZvaWRUeXBlQW5ub3RhdGlvblxufSA9IF90O1xuZnVuY3Rpb24gZ2V0VHlwZUFubm90YXRpb24oKSB7XG4gIGxldCB0eXBlID0gdGhpcy5nZXREYXRhKFwidHlwZUFubm90YXRpb25cIik7XG4gIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0eXBlID0gX2dldFR5cGVBbm5vdGF0aW9uLmNhbGwodGhpcykgfHwgYW55VHlwZUFubm90YXRpb24oKTtcbiAgaWYgKGlzVHlwZUFubm90YXRpb24odHlwZSkgfHwgaXNUU1R5cGVBbm5vdGF0aW9uKHR5cGUpKSB7XG4gICAgdHlwZSA9IHR5cGUudHlwZUFubm90YXRpb247XG4gIH1cbiAgdGhpcy5zZXREYXRhKFwidHlwZUFubm90YXRpb25cIiwgdHlwZSk7XG4gIHJldHVybiB0eXBlO1xufVxuY29uc3QgdHlwZUFubm90YXRpb25JbmZlcnJpbmdOb2RlcyA9IG5ldyBXZWFrU2V0KCk7XG5mdW5jdGlvbiBfZ2V0VHlwZUFubm90YXRpb24oKSB7XG4gIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG4gIGlmICghbm9kZSkge1xuICAgIGlmICh0aGlzLmtleSA9PT0gXCJpbml0XCIgJiYgdGhpcy5wYXJlbnRQYXRoLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IHRoaXMucGFyZW50UGF0aC5wYXJlbnRQYXRoO1xuICAgICAgY29uc3QgZGVjbGFyUGFyZW50ID0gZGVjbGFyLnBhcmVudFBhdGg7XG4gICAgICBpZiAoZGVjbGFyLmtleSA9PT0gXCJsZWZ0XCIgJiYgZGVjbGFyUGFyZW50LmlzRm9ySW5TdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWNsYXIua2V5ID09PSBcImxlZnRcIiAmJiBkZWNsYXJQYXJlbnQuaXNGb3JPZlN0YXRlbWVudCgpKSB7XG4gICAgICAgIHJldHVybiBhbnlUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWRUeXBlQW5ub3RhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZUFubm90YXRpb247XG4gIH1cbiAgaWYgKHR5cGVBbm5vdGF0aW9uSW5mZXJyaW5nTm9kZXMuaGFzKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHR5cGVBbm5vdGF0aW9uSW5mZXJyaW5nTm9kZXMuYWRkKG5vZGUpO1xuICB0cnkge1xuICAgIHZhciBfaW5mZXJlcjtcbiAgICBsZXQgaW5mZXJlciA9IGluZmVyZXJzW25vZGUudHlwZV07XG4gICAgaWYgKGluZmVyZXIpIHtcbiAgICAgIHJldHVybiBpbmZlcmVyLmNhbGwodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIGluZmVyZXIgPSBpbmZlcmVyc1t0aGlzLnBhcmVudFBhdGgudHlwZV07XG4gICAgaWYgKChfaW5mZXJlciA9IGluZmVyZXIpICE9IG51bGwgJiYgX2luZmVyZXIudmFsaWRQYXJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudFBhdGguZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHlwZUFubm90YXRpb25JbmZlcnJpbmdOb2Rlcy5kZWxldGUobm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzQmFzZVR5cGUoYmFzZU5hbWUsIHNvZnQpIHtcbiAgcmV0dXJuIF9pc0Jhc2VUeXBlKGJhc2VOYW1lLCB0aGlzLmdldFR5cGVBbm5vdGF0aW9uKCksIHNvZnQpO1xufVxuZnVuY3Rpb24gX2lzQmFzZVR5cGUoYmFzZU5hbWUsIHR5cGUsIHNvZnQpIHtcbiAgaWYgKGJhc2VOYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gaXNOdW1iZXJUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gaXNCb29sZWFuVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSBpZiAoYmFzZU5hbWUgPT09IFwiYW55XCIpIHtcbiAgICByZXR1cm4gaXNBbnlUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJtaXhlZFwiKSB7XG4gICAgcmV0dXJuIGlzTWl4ZWRUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJlbXB0eVwiKSB7XG4gICAgcmV0dXJuIGlzRW1wdHlUeXBlQW5ub3RhdGlvbih0eXBlKTtcbiAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJ2b2lkXCIpIHtcbiAgICByZXR1cm4gaXNWb2lkVHlwZUFubm90YXRpb24odHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvZnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGJhc2UgdHlwZSAke2Jhc2VOYW1lfWApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY291bGRCZUJhc2VUeXBlKG5hbWUpIHtcbiAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZUFubm90YXRpb24oKTtcbiAgaWYgKGlzQW55VHlwZUFubm90YXRpb24odHlwZSkpIHJldHVybiB0cnVlO1xuICBpZiAoaXNVbmlvblR5cGVBbm5vdGF0aW9uKHR5cGUpKSB7XG4gICAgZm9yIChjb25zdCB0eXBlMiBvZiB0eXBlLnR5cGVzKSB7XG4gICAgICBpZiAoaXNBbnlUeXBlQW5ub3RhdGlvbih0eXBlMikgfHwgX2lzQmFzZVR5cGUobmFtZSwgdHlwZTIsIHRydWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9pc0Jhc2VUeXBlKG5hbWUsIHR5cGUsIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBiYXNlVHlwZVN0cmljdGx5TWF0Y2hlcyhyaWdodEFyZykge1xuICBjb25zdCBsZWZ0ID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICBjb25zdCByaWdodCA9IHJpZ2h0QXJnLmdldFR5cGVBbm5vdGF0aW9uKCk7XG4gIGlmICghaXNBbnlUeXBlQW5ub3RhdGlvbihsZWZ0KSAmJiBpc0Zsb3dCYXNlQW5ub3RhdGlvbihsZWZ0KSkge1xuICAgIHJldHVybiByaWdodC50eXBlID09PSBsZWZ0LnR5cGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNHZW5lcmljVHlwZShnZW5lcmljTmFtZSkge1xuICBjb25zdCB0eXBlID0gdGhpcy5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICBpZiAoZ2VuZXJpY05hbWUgPT09IFwiQXJyYXlcIikge1xuICAgIGlmIChpc1RTQXJyYXlUeXBlKHR5cGUpIHx8IGlzQXJyYXlUeXBlQW5ub3RhdGlvbih0eXBlKSB8fCBpc1R1cGxlVHlwZUFubm90YXRpb24odHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNHZW5lcmljVHlwZUFubm90YXRpb24odHlwZSkgJiYgaXNJZGVudGlmaWVyKHR5cGUuaWQsIHtcbiAgICBuYW1lOiBnZW5lcmljTmFtZVxuICB9KSB8fCBpc1RTVHlwZVJlZmVyZW5jZSh0eXBlKSAmJiBpc0lkZW50aWZpZXIodHlwZS50eXBlTmFtZSwge1xuICAgIG5hbWU6IGdlbmVyaWNOYW1lXG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47317\n')},70354:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = _default;\nvar _t = __webpack_require__(2352);\nvar _util = __webpack_require__(3141);\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n  if (node.name === "undefined") {\n    return voidTypeAnnotation();\n  } else if (node.name === "NaN" || node.name === "Infinity") {\n    return numberTypeAnnotation();\n  } else if (node.name === "arguments") {}\n}\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => !testConstantViolations.includes(path));\n    types.push(testType.typeAnnotation);\n  }\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n  if (!types.length) {\n    return;\n  }\n  return (0, _util.createUnionType)(types);\n}\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n    const status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === "unknown") functions.push(violation);\n    return status === "before";\n  });\n}\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get("right").resolve();\n  const left = path.get("left").resolve();\n  let target;\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === "===") {\n      return target.getTypeAnnotation();\n    }\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {\n      return numberTypeAnnotation();\n    }\n    return;\n  }\n  if (operator !== "===" && operator !== "==") return;\n  let typeofPath;\n  let typePath;\n  if (left.isUnaryExpression({\n    operator: "typeof"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: "typeof"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typeofPath) return;\n  if (!typeofPath.get("argument").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== "string") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === "test") {\n        return;\n      }\n      return parentPath;\n    }\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n    path = parentPath;\n  }\n}\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get("test");\n  const paths = [test];\n  const types = [];\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === "&&") {\n        paths.push(path.get("left"));\n        paths.push(path.get("right"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n  return getConditionalAnnotation(binding, ifStatement, name);\n}\n\n//# sourceMappingURL=inferer-reference.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzNTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixZQUFZLG1CQUFPLENBQUMsSUFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS9pbmZlcmVyLXJlZmVyZW5jZS5qcz8xZDU0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbmNvbnN0IHtcbiAgQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyxcbiAgY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mLFxuICBudW1iZXJUeXBlQW5ub3RhdGlvbixcbiAgdm9pZFR5cGVBbm5vdGF0aW9uXG59ID0gX3Q7XG5mdW5jdGlvbiBfZGVmYXVsdChub2RlKSB7XG4gIGlmICghdGhpcy5pc1JlZmVyZW5jZWQoKSkgcmV0dXJuO1xuICBjb25zdCBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKG5vZGUubmFtZSk7XG4gIGlmIChiaW5kaW5nKSB7XG4gICAgaWYgKGJpbmRpbmcuaWRlbnRpZmllci50eXBlQW5ub3RhdGlvbikge1xuICAgICAgcmV0dXJuIGJpbmRpbmcuaWRlbnRpZmllci50eXBlQW5ub3RhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFR5cGVBbm5vdGF0aW9uQmluZGluZ0NvbnN0YW50VmlvbGF0aW9ucyhiaW5kaW5nLCB0aGlzLCBub2RlLm5hbWUpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWRUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJOYU5cIiB8fCBub2RlLm5hbWUgPT09IFwiSW5maW5pdHlcIikge1xuICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKG5vZGUubmFtZSA9PT0gXCJhcmd1bWVudHNcIikge31cbn1cbmZ1bmN0aW9uIGdldFR5cGVBbm5vdGF0aW9uQmluZGluZ0NvbnN0YW50VmlvbGF0aW9ucyhiaW5kaW5nLCBwYXRoLCBuYW1lKSB7XG4gIGNvbnN0IHR5cGVzID0gW107XG4gIGNvbnN0IGZ1bmN0aW9uQ29uc3RhbnRWaW9sYXRpb25zID0gW107XG4gIGxldCBjb25zdGFudFZpb2xhdGlvbnMgPSBnZXRDb25zdGFudFZpb2xhdGlvbnNCZWZvcmUoYmluZGluZywgcGF0aCwgZnVuY3Rpb25Db25zdGFudFZpb2xhdGlvbnMpO1xuICBjb25zdCB0ZXN0VHlwZSA9IGdldENvbmRpdGlvbmFsQW5ub3RhdGlvbihiaW5kaW5nLCBwYXRoLCBuYW1lKTtcbiAgaWYgKHRlc3RUeXBlKSB7XG4gICAgY29uc3QgdGVzdENvbnN0YW50VmlvbGF0aW9ucyA9IGdldENvbnN0YW50VmlvbGF0aW9uc0JlZm9yZShiaW5kaW5nLCB0ZXN0VHlwZS5pZlN0YXRlbWVudCk7XG4gICAgY29uc3RhbnRWaW9sYXRpb25zID0gY29uc3RhbnRWaW9sYXRpb25zLmZpbHRlcihwYXRoID0+ICF0ZXN0Q29uc3RhbnRWaW9sYXRpb25zLmluY2x1ZGVzKHBhdGgpKTtcbiAgICB0eXBlcy5wdXNoKHRlc3RUeXBlLnR5cGVBbm5vdGF0aW9uKTtcbiAgfVxuICBpZiAoY29uc3RhbnRWaW9sYXRpb25zLmxlbmd0aCkge1xuICAgIGNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKC4uLmZ1bmN0aW9uQ29uc3RhbnRWaW9sYXRpb25zKTtcbiAgICBmb3IgKGNvbnN0IHZpb2xhdGlvbiBvZiBjb25zdGFudFZpb2xhdGlvbnMpIHtcbiAgICAgIHR5cGVzLnB1c2godmlvbGF0aW9uLmdldFR5cGVBbm5vdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuICBpZiAoIXR5cGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZVVuaW9uVHlwZSkodHlwZXMpO1xufVxuZnVuY3Rpb24gZ2V0Q29uc3RhbnRWaW9sYXRpb25zQmVmb3JlKGJpbmRpbmcsIHBhdGgsIGZ1bmN0aW9ucykge1xuICBjb25zdCB2aW9sYXRpb25zID0gYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMuc2xpY2UoKTtcbiAgdmlvbGF0aW9ucy51bnNoaWZ0KGJpbmRpbmcucGF0aCk7XG4gIHJldHVybiB2aW9sYXRpb25zLmZpbHRlcih2aW9sYXRpb24gPT4ge1xuICAgIHZpb2xhdGlvbiA9IHZpb2xhdGlvbi5yZXNvbHZlKCk7XG4gICAgY29uc3Qgc3RhdHVzID0gdmlvbGF0aW9uLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8ocGF0aCk7XG4gICAgaWYgKGZ1bmN0aW9ucyAmJiBzdGF0dXMgPT09IFwidW5rbm93blwiKSBmdW5jdGlvbnMucHVzaCh2aW9sYXRpb24pO1xuICAgIHJldHVybiBzdGF0dXMgPT09IFwiYmVmb3JlXCI7XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5mZXJBbm5vdGF0aW9uRnJvbUJpbmFyeUV4cHJlc3Npb24obmFtZSwgcGF0aCkge1xuICBjb25zdCBvcGVyYXRvciA9IHBhdGgubm9kZS5vcGVyYXRvcjtcbiAgY29uc3QgcmlnaHQgPSBwYXRoLmdldChcInJpZ2h0XCIpLnJlc29sdmUoKTtcbiAgY29uc3QgbGVmdCA9IHBhdGguZ2V0KFwibGVmdFwiKS5yZXNvbHZlKCk7XG4gIGxldCB0YXJnZXQ7XG4gIGlmIChsZWZ0LmlzSWRlbnRpZmllcih7XG4gICAgbmFtZVxuICB9KSkge1xuICAgIHRhcmdldCA9IHJpZ2h0O1xuICB9IGVsc2UgaWYgKHJpZ2h0LmlzSWRlbnRpZmllcih7XG4gICAgbmFtZVxuICB9KSkge1xuICAgIHRhcmdldCA9IGxlZnQ7XG4gIH1cbiAgaWYgKHRhcmdldCkge1xuICAgIGlmIChvcGVyYXRvciA9PT0gXCI9PT1cIikge1xuICAgICAgcmV0dXJuIHRhcmdldC5nZXRUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICAgIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wZXJhdG9yICE9PSBcIj09PVwiICYmIG9wZXJhdG9yICE9PSBcIj09XCIpIHJldHVybjtcbiAgbGV0IHR5cGVvZlBhdGg7XG4gIGxldCB0eXBlUGF0aDtcbiAgaWYgKGxlZnQuaXNVbmFyeUV4cHJlc3Npb24oe1xuICAgIG9wZXJhdG9yOiBcInR5cGVvZlwiXG4gIH0pKSB7XG4gICAgdHlwZW9mUGF0aCA9IGxlZnQ7XG4gICAgdHlwZVBhdGggPSByaWdodDtcbiAgfSBlbHNlIGlmIChyaWdodC5pc1VuYXJ5RXhwcmVzc2lvbih7XG4gICAgb3BlcmF0b3I6IFwidHlwZW9mXCJcbiAgfSkpIHtcbiAgICB0eXBlb2ZQYXRoID0gcmlnaHQ7XG4gICAgdHlwZVBhdGggPSBsZWZ0O1xuICB9XG4gIGlmICghdHlwZW9mUGF0aCkgcmV0dXJuO1xuICBpZiAoIXR5cGVvZlBhdGguZ2V0KFwiYXJndW1lbnRcIikuaXNJZGVudGlmaWVyKHtcbiAgICBuYW1lXG4gIH0pKSByZXR1cm47XG4gIHR5cGVQYXRoID0gdHlwZVBhdGgucmVzb2x2ZSgpO1xuICBpZiAoIXR5cGVQYXRoLmlzTGl0ZXJhbCgpKSByZXR1cm47XG4gIGNvbnN0IHR5cGVWYWx1ZSA9IHR5cGVQYXRoLm5vZGUudmFsdWU7XG4gIGlmICh0eXBlb2YgdHlwZVZhbHVlICE9PSBcInN0cmluZ1wiKSByZXR1cm47XG4gIHJldHVybiBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YodHlwZVZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudENvbmRpdGlvbmFsUGF0aChiaW5kaW5nLCBwYXRoLCBuYW1lKSB7XG4gIGxldCBwYXJlbnRQYXRoO1xuICB3aGlsZSAocGFyZW50UGF0aCA9IHBhdGgucGFyZW50UGF0aCkge1xuICAgIGlmIChwYXJlbnRQYXRoLmlzSWZTdGF0ZW1lbnQoKSB8fCBwYXJlbnRQYXRoLmlzQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpIHtcbiAgICAgIGlmIChwYXRoLmtleSA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFBhdGg7XG4gICAgfVxuICAgIGlmIChwYXJlbnRQYXRoLmlzRnVuY3Rpb24oKSkge1xuICAgICAgaWYgKHBhcmVudFBhdGgucGFyZW50UGF0aC5zY29wZS5nZXRCaW5kaW5nKG5hbWUpICE9PSBiaW5kaW5nKSByZXR1cm47XG4gICAgfVxuICAgIHBhdGggPSBwYXJlbnRQYXRoO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDb25kaXRpb25hbEFubm90YXRpb24oYmluZGluZywgcGF0aCwgbmFtZSkge1xuICBjb25zdCBpZlN0YXRlbWVudCA9IGdldFBhcmVudENvbmRpdGlvbmFsUGF0aChiaW5kaW5nLCBwYXRoLCBuYW1lKTtcbiAgaWYgKCFpZlN0YXRlbWVudCkgcmV0dXJuO1xuICBjb25zdCB0ZXN0ID0gaWZTdGF0ZW1lbnQuZ2V0KFwidGVzdFwiKTtcbiAgY29uc3QgcGF0aHMgPSBbdGVzdF07XG4gIGNvbnN0IHR5cGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHNbaV07XG4gICAgaWYgKHBhdGguaXNMb2dpY2FsRXhwcmVzc2lvbigpKSB7XG4gICAgICBpZiAocGF0aC5ub2RlLm9wZXJhdG9yID09PSBcIiYmXCIpIHtcbiAgICAgICAgcGF0aHMucHVzaChwYXRoLmdldChcImxlZnRcIikpO1xuICAgICAgICBwYXRocy5wdXNoKHBhdGguZ2V0KFwicmlnaHRcIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0JpbmFyeUV4cHJlc3Npb24oKSkge1xuICAgICAgY29uc3QgdHlwZSA9IGluZmVyQW5ub3RhdGlvbkZyb21CaW5hcnlFeHByZXNzaW9uKG5hbWUsIHBhdGgpO1xuICAgICAgaWYgKHR5cGUpIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbC5jcmVhdGVVbmlvblR5cGUpKHR5cGVzKSxcbiAgICAgIGlmU3RhdGVtZW50XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZ2V0Q29uZGl0aW9uYWxBbm5vdGF0aW9uKGJpbmRpbmcsIGlmU3RhdGVtZW50LCBuYW1lKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mZXJlci1yZWZlcmVuY2UuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70354\n')},39937:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, "Identifier", ({\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n}));\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TSAsExpression = TSAsExpression;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\nvar _t = __webpack_require__(2352);\nvar _infererReference = __webpack_require__(70354);\nvar _util = __webpack_require__(3141);\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier\n} = _t;\nfunction VariableDeclarator() {\n  if (!this.get("id").isIdentifier()) return;\n  return this.get("init").getTypeAnnotation();\n}\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\nTypeCastExpression.validParent = true;\nfunction TSAsExpression(node) {\n  return node.typeAnnotation;\n}\nTSAsExpression.validParent = true;\nfunction TSNonNullExpression() {\n  return this.get("expression").getTypeAnnotation();\n}\nfunction NewExpression(node) {\n  if (node.callee.type === "Identifier") {\n    return genericTypeAnnotation(node.callee);\n  }\n}\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n  if (operator === "void") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.includes(operator)) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  }\n}\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n  if (NUMBER_BINARY_OPERATORS.includes(operator)) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {\n    return booleanTypeAnnotation();\n  } else if (operator === "+") {\n    const right = this.get("right");\n    const left = this.get("left");\n    if (left.isBaseType("number") && right.isBaseType("number")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType("string") || right.isBaseType("string")) {\n      return stringTypeAnnotation();\n    }\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\nfunction LogicalExpression() {\n  const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\nfunction SequenceExpression() {\n  return this.get("expressions").pop().getTypeAnnotation();\n}\nfunction ParenthesizedExpression() {\n  return this.get("expression").getTypeAnnotation();\n}\nfunction AssignmentExpression() {\n  return this.get("right").getTypeAnnotation();\n}\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n  if (operator === "++" || operator === "--") {\n    return numberTypeAnnotation();\n  }\n}\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier("RegExp"));\n}\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier("Object"));\n}\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier("Array"));\n}\nfunction RestElement() {\n  return ArrayExpression();\n}\nRestElement.validParent = true;\nfunction Func() {\n  return genericTypeAnnotation(identifier("Function"));\n}\nconst isArrayFrom = buildMatchMemberExpression("Array.from");\nconst isObjectKeys = buildMatchMemberExpression("Object.keys");\nconst isObjectValues = buildMatchMemberExpression("Object.values");\nconst isObjectEntries = buildMatchMemberExpression("Object.entries");\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {\n    name: "Array"\n  })) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n  return resolveCall(this.get("callee"));\n}\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get("tag"));\n}\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n  if (callee.isFunction()) {\n    const {\n      node\n    } = callee;\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier("AsyncIterator"));\n      } else {\n        return genericTypeAnnotation(identifier("Promise"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier("Iterator"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}\n\n//# sourceMappingURL=inferers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk5MzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0Isd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCLEdBQUcsMEJBQTBCO0FBQy9JLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsMkJBQTJCO0FBQzNCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLEtBQXdCO0FBQ3hELFlBQVksbUJBQU8sQ0FBQyxJQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9pbmZlcmVuY2UvaW5mZXJlcnMuanM/OTA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQXJyYXlFeHByZXNzaW9uID0gQXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5Bc3NpZ25tZW50RXhwcmVzc2lvbiA9IEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5CaW5hcnlFeHByZXNzaW9uID0gQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuQm9vbGVhbkxpdGVyYWwgPSBCb29sZWFuTGl0ZXJhbDtcbmV4cG9ydHMuQ2FsbEV4cHJlc3Npb24gPSBDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuQ29uZGl0aW9uYWxFeHByZXNzaW9uID0gQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5DbGFzc0RlY2xhcmF0aW9uID0gZXhwb3J0cy5DbGFzc0V4cHJlc3Npb24gPSBleHBvcnRzLkZ1bmN0aW9uRGVjbGFyYXRpb24gPSBleHBvcnRzLkFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gZXhwb3J0cy5GdW5jdGlvbkV4cHJlc3Npb24gPSBGdW5jO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5mZXJlclJlZmVyZW5jZS5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMuTG9naWNhbEV4cHJlc3Npb24gPSBMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuTmV3RXhwcmVzc2lvbiA9IE5ld0V4cHJlc3Npb247XG5leHBvcnRzLk51bGxMaXRlcmFsID0gTnVsbExpdGVyYWw7XG5leHBvcnRzLk51bWVyaWNMaXRlcmFsID0gTnVtZXJpY0xpdGVyYWw7XG5leHBvcnRzLk9iamVjdEV4cHJlc3Npb24gPSBPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5SZWdFeHBMaXRlcmFsID0gUmVnRXhwTGl0ZXJhbDtcbmV4cG9ydHMuUmVzdEVsZW1lbnQgPSBSZXN0RWxlbWVudDtcbmV4cG9ydHMuU2VxdWVuY2VFeHByZXNzaW9uID0gU2VxdWVuY2VFeHByZXNzaW9uO1xuZXhwb3J0cy5TdHJpbmdMaXRlcmFsID0gU3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuVFNBc0V4cHJlc3Npb24gPSBUU0FzRXhwcmVzc2lvbjtcbmV4cG9ydHMuVFNOb25OdWxsRXhwcmVzc2lvbiA9IFRTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbiA9IFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuVGVtcGxhdGVMaXRlcmFsID0gVGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5UeXBlQ2FzdEV4cHJlc3Npb24gPSBUeXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLlVuYXJ5RXhwcmVzc2lvbiA9IFVuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLlZhcmlhYmxlRGVjbGFyYXRvciA9IFZhcmlhYmxlRGVjbGFyYXRvcjtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2luZmVyZXJSZWZlcmVuY2UgPSByZXF1aXJlKFwiLi9pbmZlcmVyLXJlZmVyZW5jZS5qc1wiKTtcbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwuanNcIik7XG5jb25zdCB7XG4gIEJPT0xFQU5fQklOQVJZX09QRVJBVE9SUyxcbiAgQk9PTEVBTl9VTkFSWV9PUEVSQVRPUlMsXG4gIE5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLFxuICBOVU1CRVJfVU5BUllfT1BFUkFUT1JTLFxuICBTVFJJTkdfVU5BUllfT1BFUkFUT1JTLFxuICBhbnlUeXBlQW5ub3RhdGlvbixcbiAgYXJyYXlUeXBlQW5ub3RhdGlvbixcbiAgYm9vbGVhblR5cGVBbm5vdGF0aW9uLFxuICBidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbixcbiAgZ2VuZXJpY1R5cGVBbm5vdGF0aW9uLFxuICBpZGVudGlmaWVyLFxuICBudWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uLFxuICBudW1iZXJUeXBlQW5ub3RhdGlvbixcbiAgc3RyaW5nVHlwZUFubm90YXRpb24sXG4gIHR1cGxlVHlwZUFubm90YXRpb24sXG4gIHVuaW9uVHlwZUFubm90YXRpb24sXG4gIHZvaWRUeXBlQW5ub3RhdGlvbixcbiAgaXNJZGVudGlmaWVyXG59ID0gX3Q7XG5mdW5jdGlvbiBWYXJpYWJsZURlY2xhcmF0b3IoKSB7XG4gIGlmICghdGhpcy5nZXQoXCJpZFwiKS5pc0lkZW50aWZpZXIoKSkgcmV0dXJuO1xuICByZXR1cm4gdGhpcy5nZXQoXCJpbml0XCIpLmdldFR5cGVBbm5vdGF0aW9uKCk7XG59XG5mdW5jdGlvbiBUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSkge1xuICByZXR1cm4gbm9kZS50eXBlQW5ub3RhdGlvbjtcbn1cblR5cGVDYXN0RXhwcmVzc2lvbi52YWxpZFBhcmVudCA9IHRydWU7XG5mdW5jdGlvbiBUU0FzRXhwcmVzc2lvbihub2RlKSB7XG4gIHJldHVybiBub2RlLnR5cGVBbm5vdGF0aW9uO1xufVxuVFNBc0V4cHJlc3Npb24udmFsaWRQYXJlbnQgPSB0cnVlO1xuZnVuY3Rpb24gVFNOb25OdWxsRXhwcmVzc2lvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0KFwiZXhwcmVzc2lvblwiKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gTmV3RXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLmNhbGxlZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24obm9kZS5jYWxsZWUpO1xuICB9XG59XG5mdW5jdGlvbiBUZW1wbGF0ZUxpdGVyYWwoKSB7XG4gIHJldHVybiBzdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gVW5hcnlFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuICBpZiAob3BlcmF0b3IgPT09IFwidm9pZFwiKSB7XG4gICAgcmV0dXJuIHZvaWRUeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKE5VTUJFUl9VTkFSWV9PUEVSQVRPUlMuaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgcmV0dXJuIG51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAoU1RSSU5HX1VOQVJZX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICByZXR1cm4gc3RyaW5nVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmIChCT09MRUFOX1VOQVJZX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICByZXR1cm4gYm9vbGVhblR5cGVBbm5vdGF0aW9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJpbmFyeUV4cHJlc3Npb24obm9kZSkge1xuICBjb25zdCBvcGVyYXRvciA9IG5vZGUub3BlcmF0b3I7XG4gIGlmIChOVU1CRVJfQklOQVJZX09QRVJBVE9SUy5pbmNsdWRlcyhvcGVyYXRvcikpIHtcbiAgICByZXR1cm4gbnVtYmVyVHlwZUFubm90YXRpb24oKTtcbiAgfSBlbHNlIGlmIChCT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMuaW5jbHVkZXMob3BlcmF0b3IpKSB7XG4gICAgcmV0dXJuIGJvb2xlYW5UeXBlQW5ub3RhdGlvbigpO1xuICB9IGVsc2UgaWYgKG9wZXJhdG9yID09PSBcIitcIikge1xuICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5nZXQoXCJyaWdodFwiKTtcbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5nZXQoXCJsZWZ0XCIpO1xuICAgIGlmIChsZWZ0LmlzQmFzZVR5cGUoXCJudW1iZXJcIikgJiYgcmlnaHQuaXNCYXNlVHlwZShcIm51bWJlclwiKSkge1xuICAgICAgcmV0dXJuIG51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmIChsZWZ0LmlzQmFzZVR5cGUoXCJzdHJpbmdcIikgfHwgcmlnaHQuaXNCYXNlVHlwZShcInN0cmluZ1wiKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ1R5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmlvblR5cGVBbm5vdGF0aW9uKFtzdHJpbmdUeXBlQW5ub3RhdGlvbigpLCBudW1iZXJUeXBlQW5ub3RhdGlvbigpXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIExvZ2ljYWxFeHByZXNzaW9uKCkge1xuICBjb25zdCBhcmd1bWVudFR5cGVzID0gW3RoaXMuZ2V0KFwibGVmdFwiKS5nZXRUeXBlQW5ub3RhdGlvbigpLCB0aGlzLmdldChcInJpZ2h0XCIpLmdldFR5cGVBbm5vdGF0aW9uKCldO1xuICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZVVuaW9uVHlwZSkoYXJndW1lbnRUeXBlcyk7XG59XG5mdW5jdGlvbiBDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gIGNvbnN0IGFyZ3VtZW50VHlwZXMgPSBbdGhpcy5nZXQoXCJjb25zZXF1ZW50XCIpLmdldFR5cGVBbm5vdGF0aW9uKCksIHRoaXMuZ2V0KFwiYWx0ZXJuYXRlXCIpLmdldFR5cGVBbm5vdGF0aW9uKCldO1xuICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZVVuaW9uVHlwZSkoYXJndW1lbnRUeXBlcyk7XG59XG5mdW5jdGlvbiBTZXF1ZW5jZUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25zXCIpLnBvcCgpLmdldFR5cGVBbm5vdGF0aW9uKCk7XG59XG5mdW5jdGlvbiBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbigpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0KFwiZXhwcmVzc2lvblwiKS5nZXRUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gQXNzaWdubWVudEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB0aGlzLmdldChcInJpZ2h0XCIpLmdldFR5cGVBbm5vdGF0aW9uKCk7XG59XG5mdW5jdGlvbiBVcGRhdGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgY29uc3Qgb3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuICBpZiAob3BlcmF0b3IgPT09IFwiKytcIiB8fCBvcGVyYXRvciA9PT0gXCItLVwiKSB7XG4gICAgcmV0dXJuIG51bWJlclR5cGVBbm5vdGF0aW9uKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFN0cmluZ0xpdGVyYWwoKSB7XG4gIHJldHVybiBzdHJpbmdUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gTnVtZXJpY0xpdGVyYWwoKSB7XG4gIHJldHVybiBudW1iZXJUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gQm9vbGVhbkxpdGVyYWwoKSB7XG4gIHJldHVybiBib29sZWFuVHlwZUFubm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIE51bGxMaXRlcmFsKCkge1xuICByZXR1cm4gbnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbigpO1xufVxuZnVuY3Rpb24gUmVnRXhwTGl0ZXJhbCgpIHtcbiAgcmV0dXJuIGdlbmVyaWNUeXBlQW5ub3RhdGlvbihpZGVudGlmaWVyKFwiUmVnRXhwXCIpKTtcbn1cbmZ1bmN0aW9uIE9iamVjdEV4cHJlc3Npb24oKSB7XG4gIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24oaWRlbnRpZmllcihcIk9iamVjdFwiKSk7XG59XG5mdW5jdGlvbiBBcnJheUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24oaWRlbnRpZmllcihcIkFycmF5XCIpKTtcbn1cbmZ1bmN0aW9uIFJlc3RFbGVtZW50KCkge1xuICByZXR1cm4gQXJyYXlFeHByZXNzaW9uKCk7XG59XG5SZXN0RWxlbWVudC52YWxpZFBhcmVudCA9IHRydWU7XG5mdW5jdGlvbiBGdW5jKCkge1xuICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkZW50aWZpZXIoXCJGdW5jdGlvblwiKSk7XG59XG5jb25zdCBpc0FycmF5RnJvbSA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiQXJyYXkuZnJvbVwiKTtcbmNvbnN0IGlzT2JqZWN0S2V5cyA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiT2JqZWN0LmtleXNcIik7XG5jb25zdCBpc09iamVjdFZhbHVlcyA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiT2JqZWN0LnZhbHVlc1wiKTtcbmNvbnN0IGlzT2JqZWN0RW50cmllcyA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uKFwiT2JqZWN0LmVudHJpZXNcIik7XG5mdW5jdGlvbiBDYWxsRXhwcmVzc2lvbigpIHtcbiAgY29uc3Qge1xuICAgIGNhbGxlZVxuICB9ID0gdGhpcy5ub2RlO1xuICBpZiAoaXNPYmplY3RLZXlzKGNhbGxlZSkpIHtcbiAgICByZXR1cm4gYXJyYXlUeXBlQW5ub3RhdGlvbihzdHJpbmdUeXBlQW5ub3RhdGlvbigpKTtcbiAgfSBlbHNlIGlmIChpc0FycmF5RnJvbShjYWxsZWUpIHx8IGlzT2JqZWN0VmFsdWVzKGNhbGxlZSkgfHwgaXNJZGVudGlmaWVyKGNhbGxlZSwge1xuICAgIG5hbWU6IFwiQXJyYXlcIlxuICB9KSkge1xuICAgIHJldHVybiBhcnJheVR5cGVBbm5vdGF0aW9uKGFueVR5cGVBbm5vdGF0aW9uKCkpO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0RW50cmllcyhjYWxsZWUpKSB7XG4gICAgcmV0dXJuIGFycmF5VHlwZUFubm90YXRpb24odHVwbGVUeXBlQW5ub3RhdGlvbihbc3RyaW5nVHlwZUFubm90YXRpb24oKSwgYW55VHlwZUFubm90YXRpb24oKV0pKTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZUNhbGwodGhpcy5nZXQoXCJjYWxsZWVcIikpO1xufVxuZnVuY3Rpb24gVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKCkge1xuICByZXR1cm4gcmVzb2x2ZUNhbGwodGhpcy5nZXQoXCJ0YWdcIikpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNhbGwoY2FsbGVlKSB7XG4gIGNhbGxlZSA9IGNhbGxlZS5yZXNvbHZlKCk7XG4gIGlmIChjYWxsZWUuaXNGdW5jdGlvbigpKSB7XG4gICAgY29uc3Qge1xuICAgICAgbm9kZVxuICAgIH0gPSBjYWxsZWU7XG4gICAgaWYgKG5vZGUuYXN5bmMpIHtcbiAgICAgIGlmIChub2RlLmdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKGlkZW50aWZpZXIoXCJBc3luY0l0ZXJhdG9yXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW5lcmljVHlwZUFubm90YXRpb24oaWRlbnRpZmllcihcIlByb21pc2VcIikpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5nZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyaWNUeXBlQW5ub3RhdGlvbihpZGVudGlmaWVyKFwiSXRlcmF0b3JcIikpO1xuICAgICAgfSBlbHNlIGlmIChjYWxsZWUubm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBjYWxsZWUubm9kZS5yZXR1cm5UeXBlO1xuICAgICAgfSBlbHNlIHt9XG4gICAgfVxuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZmVyZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///39937\n')},3141:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.createUnionType = createUnionType;\nvar _t = __webpack_require__(2352);\nconst {\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  isFlowType,\n  isTSType\n} = _t;\nfunction createUnionType(types) {\n  {\n    if (types.every(v => isFlowType(v))) {\n      if (createFlowUnionType) {\n        return createFlowUnionType(types);\n      }\n      return createUnionTypeAnnotation(types);\n    } else if (types.every(v => isTSType(v))) {\n      if (createTSUnionType) {\n        return createTSUnionType(types);\n      }\n    }\n  }\n}\n\n//# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix1QkFBdUI7QUFDdkIsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2luZmVyZW5jZS91dGlsLmpzP2RiNzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmNyZWF0ZVVuaW9uVHlwZSA9IGNyZWF0ZVVuaW9uVHlwZTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGNyZWF0ZUZsb3dVbmlvblR5cGUsXG4gIGNyZWF0ZVRTVW5pb25UeXBlLFxuICBjcmVhdGVVbmlvblR5cGVBbm5vdGF0aW9uLFxuICBpc0Zsb3dUeXBlLFxuICBpc1RTVHlwZVxufSA9IF90O1xuZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlKHR5cGVzKSB7XG4gIHtcbiAgICBpZiAodHlwZXMuZXZlcnkodiA9PiBpc0Zsb3dUeXBlKHYpKSkge1xuICAgICAgaWYgKGNyZWF0ZUZsb3dVbmlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZsb3dVbmlvblR5cGUodHlwZXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb24odHlwZXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZXMuZXZlcnkodiA9PiBpc1RTVHlwZSh2KSkpIHtcbiAgICAgIGlmIChjcmVhdGVUU1VuaW9uVHlwZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlVFNVbmlvblR5cGUodHlwZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3141\n')},40854:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._resolve = _resolve;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.getSource = getSource;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.isNodeType = isNodeType;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.isStatic = isStatic;\nexports.matchesPattern = matchesPattern;\nexports.referencesImport = referencesImport;\nexports.resolve = resolve;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nvar _t = __webpack_require__(2352);\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n{\n  exports.has = function has(key) {\n    var _this$node;\n    const val = (_this$node = this.node) == null ? void 0 : _this$node[key];\n    if (val && Array.isArray(val)) {\n      return !!val.length;\n    } else {\n      return !!val;\n    }\n  };\n}\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n{\n  exports.is = exports.has;\n  exports.isnt = function isnt(key) {\n    return !this.has(key);\n  };\n  exports.equals = function equals(key, value) {\n    return this.node[key] === value;\n  };\n}\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();\n}\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n  return false;\n}\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n  do {\n    const {\n      type,\n      container\n    } = path;\n    if (!first && (path.isFunction() || type === "StaticBlock")) {\n      return !!allowInsideFunction;\n    }\n    first = false;\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram() && !path.isDoExpression());\n  return true;\n}\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get("object");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");\n    }\n    return false;\n  }\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== "module") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n  if (path.isImportDefaultSpecifier() && importName === "default") {\n    return true;\n  }\n  if (path.isImportNamespaceSpecifier() && importName === "*") {\n    return true;\n  }\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n  return false;\n}\nfunction getSource() {\n  const node = this.node;\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n  return "";\n}\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== "after";\n}\nfunction getOuterFunction(path) {\n  return path.isProgram() ? path : (path.parentPath.scope.getFunctionParent() || path.parentPath.scope.getProgramParent()).path;\n}\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case "LogicalExpression":\n      return key === "right";\n    case "ConditionalExpression":\n    case "IfStatement":\n      return key === "consequent" || key === "alternate";\n    case "WhileStatement":\n    case "DoWhileStatement":\n    case "ForInStatement":\n    case "ForOfStatement":\n      return key === "body";\n    case "ForStatement":\n      return key === "body" || key === "update";\n    case "SwitchStatement":\n      return key === "cases";\n    case "TryStatement":\n      return key === "handler";\n    case "AssignmentPattern":\n      return key === "right";\n    case "OptionalMemberExpression":\n      return key === "property";\n    case "OptionalCallExpression":\n      return key === "arguments";\n    default:\n      return false;\n  }\n}\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n  return false;\n}\nconst SYMBOL_CHECKING = Symbol();\nfunction _guessExecutionStatusRelativeTo(target) {\n  return _guessExecutionStatusRelativeToCached(this, target, new Map());\n}\nfunction _guessExecutionStatusRelativeToCached(base, target, cache) {\n  const funcParent = {\n    this: getOuterFunction(base),\n    target: getOuterFunction(target)\n  };\n  if (funcParent.target.node !== funcParent.this.node) {\n    return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache);\n  }\n  const paths = {\n    target: target.getAncestry(),\n    this: base.getAncestry()\n  };\n  if (paths.target.includes(base)) return "after";\n  if (paths.this.includes(target)) return "before";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n  if (!commonPath) {\n    throw new Error("Internal Babel error - The two compared nodes" + " don\'t appear to belong to the same program.");\n  }\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return "unknown";\n  }\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? "before" : "after";\n  }\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? "before" : "after";\n}\nfunction _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache) {\n  if (!target.isFunctionDeclaration()) {\n    if (_guessExecutionStatusRelativeToCached(base, target, cache) === "before") {\n      return "before";\n    }\n    return "unknown";\n  } else if (target.parentPath.isExportDeclaration()) {\n    return "unknown";\n  }\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return "before";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n    if (path.key !== "callee" || !path.parentPath.isCallExpression()) {\n      return "unknown";\n    }\n    const status = _guessExecutionStatusRelativeToCached(base, path, cache);\n    if (allStatus && allStatus !== status) {\n      return "unknown";\n    } else {\n      allStatus = status;\n    }\n  }\n  return allStatus;\n}\nfunction _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache) {\n  let nodeMap = cache.get(base.node);\n  let cached;\n  if (!nodeMap) {\n    cache.set(base.node, nodeMap = new Map());\n  } else if (cached = nodeMap.get(target.node)) {\n    if (cached === SYMBOL_CHECKING) {\n      return "unknown";\n    }\n    return cached;\n  }\n  nodeMap.set(target.node, SYMBOL_CHECKING);\n  const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache);\n  nodeMap.set(target.node, result);\n  return result;\n}\nfunction resolve(dangerous, resolved) {\n  return _resolve.call(this, dangerous, resolved) || this;\n}\nfunction _resolve(dangerous, resolved) {\n  var _resolved;\n  if ((_resolved = resolved) != null && _resolved.includes(this)) return;\n  resolved = resolved || [];\n  resolved.push(this);\n  if (this.isVariableDeclarator()) {\n    if (this.get("id").isIdentifier()) {\n      return this.get("init").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === "module") return;\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get("expression").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get("object").resolve(dangerous, resolved);\n    if (target.isObjectExpression()) {\n      const props = target.get("properties");\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get("key");\n        let match = prop.isnt("computed") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get("value").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get("elements");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n    if (this.isTemplateLiteral()) {\n      return this.get("expressions").every(expression => expression.isConstantExpression());\n    }\n    return true;\n  }\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== "void") {\n      return false;\n    }\n    return this.get("argument").isConstantExpression();\n  }\n  if (this.isBinaryExpression()) {\n    const {\n      operator\n    } = this.node;\n    return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();\n  }\n  if (this.isMemberExpression()) {\n    return !this.node.computed && this.get("object").isIdentifier({\n      name: "Symbol"\n    }) && !this.scope.hasBinding("Symbol", {\n      noGlobals: true\n    });\n  }\n  if (this.isCallExpression()) {\n    return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {\n      noGlobals: true\n    }) && this.get("arguments")[0].isStringLiteral();\n  }\n  return false;\n}\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: "module"\n    })) return true;\n    if (path.isClass()) return true;\n    if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {\n      return false;\n    }\n    let body;\n    if (path.isFunction()) {\n      body = path.node.body;\n    } else if (path.isProgram()) {\n      body = path.node;\n    } else {\n      return false;\n    }\n    for (const directive of body.directives) {\n      if (directive.value.value === "use strict") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}\n\n//# sourceMappingURL=introspection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4NTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdUNBQXVDO0FBQ3ZDLGdCQUFnQjtBQUNoQiw4Q0FBOEM7QUFDOUMsNENBQTRDO0FBQzVDLGlCQUFpQjtBQUNqQiwwQkFBMEI7QUFDMUIsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLGVBQWU7QUFDZiwrQkFBK0I7QUFDL0IsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLFdBQVc7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxVQUFVO0FBQ1osRUFBRSxZQUFZO0FBQ2Q7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9pbnRyb3NwZWN0aW9uLmpzPzU4MjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLl9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8gPSBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvO1xuZXhwb3J0cy5fcmVzb2x2ZSA9IF9yZXNvbHZlO1xuZXhwb3J0cy5jYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbiA9IGNhbkhhdmVWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uO1xuZXhwb3J0cy5jYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQgPSBjYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQ7XG5leHBvcnRzLmdldFNvdXJjZSA9IGdldFNvdXJjZTtcbmV4cG9ydHMuaXNDb21wbGV0aW9uUmVjb3JkID0gaXNDb21wbGV0aW9uUmVjb3JkO1xuZXhwb3J0cy5pc0NvbnN0YW50RXhwcmVzc2lvbiA9IGlzQ29uc3RhbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0luU3RyaWN0TW9kZSA9IGlzSW5TdHJpY3RNb2RlO1xuZXhwb3J0cy5pc05vZGVUeXBlID0gaXNOb2RlVHlwZTtcbmV4cG9ydHMuaXNTdGF0ZW1lbnRPckJsb2NrID0gaXNTdGF0ZW1lbnRPckJsb2NrO1xuZXhwb3J0cy5pc1N0YXRpYyA9IGlzU3RhdGljO1xuZXhwb3J0cy5tYXRjaGVzUGF0dGVybiA9IG1hdGNoZXNQYXR0ZXJuO1xuZXhwb3J0cy5yZWZlcmVuY2VzSW1wb3J0ID0gcmVmZXJlbmNlc0ltcG9ydDtcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLndpbGxJTWF5YmVFeGVjdXRlQmVmb3JlID0gd2lsbElNYXliZUV4ZWN1dGVCZWZvcmU7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xuY29uc3Qge1xuICBTVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyxcbiAgVklTSVRPUl9LRVlTLFxuICBpc0Jsb2NrU3RhdGVtZW50LFxuICBpc0V4cHJlc3Npb24sXG4gIGlzSWRlbnRpZmllcixcbiAgaXNMaXRlcmFsLFxuICBpc1N0cmluZ0xpdGVyYWwsXG4gIGlzVHlwZSxcbiAgbWF0Y2hlc1BhdHRlcm46IF9tYXRjaGVzUGF0dGVyblxufSA9IF90O1xuZnVuY3Rpb24gbWF0Y2hlc1BhdHRlcm4ocGF0dGVybiwgYWxsb3dQYXJ0aWFsKSB7XG4gIHJldHVybiBfbWF0Y2hlc1BhdHRlcm4odGhpcy5ub2RlLCBwYXR0ZXJuLCBhbGxvd1BhcnRpYWwpO1xufVxue1xuICBleHBvcnRzLmhhcyA9IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICB2YXIgX3RoaXMkbm9kZTtcbiAgICBjb25zdCB2YWwgPSAoX3RoaXMkbm9kZSA9IHRoaXMubm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJG5vZGVba2V5XTtcbiAgICBpZiAodmFsICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgcmV0dXJuICEhdmFsLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICEhdmFsO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljKCkge1xuICByZXR1cm4gdGhpcy5zY29wZS5pc1N0YXRpYyh0aGlzLm5vZGUpO1xufVxue1xuICBleHBvcnRzLmlzID0gZXhwb3J0cy5oYXM7XG4gIGV4cG9ydHMuaXNudCA9IGZ1bmN0aW9uIGlzbnQoa2V5KSB7XG4gICAgcmV0dXJuICF0aGlzLmhhcyhrZXkpO1xuICB9O1xuICBleHBvcnRzLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyhrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVtrZXldID09PSB2YWx1ZTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTm9kZVR5cGUodHlwZSkge1xuICByZXR1cm4gaXNUeXBlKHRoaXMudHlwZSwgdHlwZSk7XG59XG5mdW5jdGlvbiBjYW5IYXZlVmFyaWFibGVEZWNsYXJhdGlvbk9yRXhwcmVzc2lvbigpIHtcbiAgcmV0dXJuICh0aGlzLmtleSA9PT0gXCJpbml0XCIgfHwgdGhpcy5rZXkgPT09IFwibGVmdFwiKSAmJiB0aGlzLnBhcmVudFBhdGguaXNGb3IoKTtcbn1cbmZ1bmN0aW9uIGNhblN3YXBCZXR3ZWVuRXhwcmVzc2lvbkFuZFN0YXRlbWVudChyZXBsYWNlbWVudCkge1xuICBpZiAodGhpcy5rZXkgIT09IFwiYm9keVwiIHx8ICF0aGlzLnBhcmVudFBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLmlzRXhwcmVzc2lvbigpKSB7XG4gICAgcmV0dXJuIGlzQmxvY2tTdGF0ZW1lbnQocmVwbGFjZW1lbnQpO1xuICB9IGVsc2UgaWYgKHRoaXMuaXNCbG9ja1N0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIGlzRXhwcmVzc2lvbihyZXBsYWNlbWVudCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uUmVjb3JkKGFsbG93SW5zaWRlRnVuY3Rpb24pIHtcbiAgbGV0IHBhdGggPSB0aGlzO1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBkbyB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSBwYXRoO1xuICAgIGlmICghZmlyc3QgJiYgKHBhdGguaXNGdW5jdGlvbigpIHx8IHR5cGUgPT09IFwiU3RhdGljQmxvY2tcIikpIHtcbiAgICAgIHJldHVybiAhIWFsbG93SW5zaWRlRnVuY3Rpb247XG4gICAgfVxuICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGFpbmVyKSAmJiBwYXRoLmtleSAhPT0gY29udGFpbmVyLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gd2hpbGUgKChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKSAmJiAhcGF0aC5pc1Byb2dyYW0oKSAmJiAhcGF0aC5pc0RvRXhwcmVzc2lvbigpKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc1N0YXRlbWVudE9yQmxvY2soKSB7XG4gIGlmICh0aGlzLnBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgaXNCbG9ja1N0YXRlbWVudCh0aGlzLmNvbnRhaW5lcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFNUQVRFTUVOVF9PUl9CTE9DS19LRVlTLmluY2x1ZGVzKHRoaXMua2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gcmVmZXJlbmNlc0ltcG9ydChtb2R1bGVTb3VyY2UsIGltcG9ydE5hbWUpIHtcbiAgaWYgKCF0aGlzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIGlmICh0aGlzLmlzSlNYTWVtYmVyRXhwcmVzc2lvbigpICYmIHRoaXMubm9kZS5wcm9wZXJ0eS5uYW1lID09PSBpbXBvcnROYW1lIHx8ICh0aGlzLmlzTWVtYmVyRXhwcmVzc2lvbigpIHx8IHRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oKSkgJiYgKHRoaXMubm9kZS5jb21wdXRlZCA/IGlzU3RyaW5nTGl0ZXJhbCh0aGlzLm5vZGUucHJvcGVydHksIHtcbiAgICAgIHZhbHVlOiBpbXBvcnROYW1lXG4gICAgfSkgOiB0aGlzLm5vZGUucHJvcGVydHkubmFtZSA9PT0gaW1wb3J0TmFtZSkpIHtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZ2V0KFwib2JqZWN0XCIpO1xuICAgICAgcmV0dXJuIG9iamVjdC5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKCkgJiYgb2JqZWN0LnJlZmVyZW5jZXNJbXBvcnQobW9kdWxlU291cmNlLCBcIipcIik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKHRoaXMubm9kZS5uYW1lKTtcbiAgaWYgKCFiaW5kaW5nIHx8IGJpbmRpbmcua2luZCAhPT0gXCJtb2R1bGVcIikgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBwYXRoID0gYmluZGluZy5wYXRoO1xuICBjb25zdCBwYXJlbnQgPSBwYXRoLnBhcmVudFBhdGg7XG4gIGlmICghcGFyZW50LmlzSW1wb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAocGFyZW50Lm5vZGUuc291cmNlLnZhbHVlID09PSBtb2R1bGVTb3VyY2UpIHtcbiAgICBpZiAoIWltcG9ydE5hbWUpIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGF0aC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIoKSAmJiBpbXBvcnROYW1lID09PSBcImRlZmF1bHRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChwYXRoLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKCkgJiYgaW1wb3J0TmFtZSA9PT0gXCIqXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAocGF0aC5pc0ltcG9ydFNwZWNpZmllcigpICYmIGlzSWRlbnRpZmllcihwYXRoLm5vZGUuaW1wb3J0ZWQsIHtcbiAgICBuYW1lOiBpbXBvcnROYW1lXG4gIH0pKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U291cmNlKCkge1xuICBjb25zdCBub2RlID0gdGhpcy5ub2RlO1xuICBpZiAobm9kZS5lbmQpIHtcbiAgICBjb25zdCBjb2RlID0gdGhpcy5odWIuZ2V0Q29kZSgpO1xuICAgIGlmIChjb2RlKSByZXR1cm4gY29kZS5zbGljZShub2RlLnN0YXJ0LCBub2RlLmVuZCk7XG4gIH1cbiAgcmV0dXJuIFwiXCI7XG59XG5mdW5jdGlvbiB3aWxsSU1heWJlRXhlY3V0ZUJlZm9yZSh0YXJnZXQpIHtcbiAgcmV0dXJuIHRoaXMuX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUbyh0YXJnZXQpICE9PSBcImFmdGVyXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRlckZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguaXNQcm9ncmFtKCkgPyBwYXRoIDogKHBhdGgucGFyZW50UGF0aC5zY29wZS5nZXRGdW5jdGlvblBhcmVudCgpIHx8IHBhdGgucGFyZW50UGF0aC5zY29wZS5nZXRQcm9ncmFtUGFyZW50KCkpLnBhdGg7XG59XG5mdW5jdGlvbiBpc0V4ZWN1dGlvblVuY2VydGFpbih0eXBlLCBrZXkpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcInJpZ2h0XCI7XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJjb25zZXF1ZW50XCIgfHwga2V5ID09PSBcImFsdGVybmF0ZVwiO1xuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcImJvZHlcIjtcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4ga2V5ID09PSBcImJvZHlcIiB8fCBrZXkgPT09IFwidXBkYXRlXCI7XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJjYXNlc1wiO1xuICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICAgIHJldHVybiBrZXkgPT09IFwiaGFuZGxlclwiO1xuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJyaWdodFwiO1xuICAgIGNhc2UgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBrZXkgPT09IFwicHJvcGVydHlcIjtcbiAgICBjYXNlIFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGtleSA9PT0gXCJhcmd1bWVudHNcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc0V4ZWN1dGlvblVuY2VydGFpbkluTGlzdChwYXRocywgbWF4SW5kZXgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhJbmRleDsgaSsrKSB7XG4gICAgY29uc3QgcGF0aCA9IHBhdGhzW2ldO1xuICAgIGlmIChpc0V4ZWN1dGlvblVuY2VydGFpbihwYXRoLnBhcmVudC50eXBlLCBwYXRoLnBhcmVudEtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBTWU1CT0xfQ0hFQ0tJTkcgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG8odGFyZ2V0KSB7XG4gIHJldHVybiBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKHRoaXMsIHRhcmdldCwgbmV3IE1hcCgpKTtcbn1cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9DYWNoZWQoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBjb25zdCBmdW5jUGFyZW50ID0ge1xuICAgIHRoaXM6IGdldE91dGVyRnVuY3Rpb24oYmFzZSksXG4gICAgdGFyZ2V0OiBnZXRPdXRlckZ1bmN0aW9uKHRhcmdldClcbiAgfTtcbiAgaWYgKGZ1bmNQYXJlbnQudGFyZ2V0Lm5vZGUgIT09IGZ1bmNQYXJlbnQudGhpcy5ub2RlKSB7XG4gICAgcmV0dXJuIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnNDYWNoZWQoYmFzZSwgZnVuY1BhcmVudC50YXJnZXQsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBwYXRocyA9IHtcbiAgICB0YXJnZXQ6IHRhcmdldC5nZXRBbmNlc3RyeSgpLFxuICAgIHRoaXM6IGJhc2UuZ2V0QW5jZXN0cnkoKVxuICB9O1xuICBpZiAocGF0aHMudGFyZ2V0LmluY2x1ZGVzKGJhc2UpKSByZXR1cm4gXCJhZnRlclwiO1xuICBpZiAocGF0aHMudGhpcy5pbmNsdWRlcyh0YXJnZXQpKSByZXR1cm4gXCJiZWZvcmVcIjtcbiAgbGV0IGNvbW1vblBhdGg7XG4gIGNvbnN0IGNvbW1vbkluZGV4ID0ge1xuICAgIHRhcmdldDogMCxcbiAgICB0aGlzOiAwXG4gIH07XG4gIHdoaWxlICghY29tbW9uUGF0aCAmJiBjb21tb25JbmRleC50aGlzIDwgcGF0aHMudGhpcy5sZW5ndGgpIHtcbiAgICBjb25zdCBwYXRoID0gcGF0aHMudGhpc1tjb21tb25JbmRleC50aGlzXTtcbiAgICBjb21tb25JbmRleC50YXJnZXQgPSBwYXRocy50YXJnZXQuaW5kZXhPZihwYXRoKTtcbiAgICBpZiAoY29tbW9uSW5kZXgudGFyZ2V0ID49IDApIHtcbiAgICAgIGNvbW1vblBhdGggPSBwYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21tb25JbmRleC50aGlzKys7XG4gICAgfVxuICB9XG4gIGlmICghY29tbW9uUGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEJhYmVsIGVycm9yIC0gVGhlIHR3byBjb21wYXJlZCBub2Rlc1wiICsgXCIgZG9uJ3QgYXBwZWFyIHRvIGJlbG9uZyB0byB0aGUgc2FtZSBwcm9ncmFtLlwiKTtcbiAgfVxuICBpZiAoaXNFeGVjdXRpb25VbmNlcnRhaW5Jbkxpc3QocGF0aHMudGhpcywgY29tbW9uSW5kZXgudGhpcyAtIDEpIHx8IGlzRXhlY3V0aW9uVW5jZXJ0YWluSW5MaXN0KHBhdGhzLnRhcmdldCwgY29tbW9uSW5kZXgudGFyZ2V0IC0gMSkpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gIH1cbiAgY29uc3QgZGl2ZXJnZW5jZSA9IHtcbiAgICB0aGlzOiBwYXRocy50aGlzW2NvbW1vbkluZGV4LnRoaXMgLSAxXSxcbiAgICB0YXJnZXQ6IHBhdGhzLnRhcmdldFtjb21tb25JbmRleC50YXJnZXQgLSAxXVxuICB9O1xuICBpZiAoZGl2ZXJnZW5jZS50YXJnZXQubGlzdEtleSAmJiBkaXZlcmdlbmNlLnRoaXMubGlzdEtleSAmJiBkaXZlcmdlbmNlLnRhcmdldC5jb250YWluZXIgPT09IGRpdmVyZ2VuY2UudGhpcy5jb250YWluZXIpIHtcbiAgICByZXR1cm4gZGl2ZXJnZW5jZS50YXJnZXQua2V5ID4gZGl2ZXJnZW5jZS50aGlzLmtleSA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG4gIH1cbiAgY29uc3Qga2V5cyA9IFZJU0lUT1JfS0VZU1tjb21tb25QYXRoLnR5cGVdO1xuICBjb25zdCBrZXlQb3NpdGlvbiA9IHtcbiAgICB0aGlzOiBrZXlzLmluZGV4T2YoZGl2ZXJnZW5jZS50aGlzLnBhcmVudEtleSksXG4gICAgdGFyZ2V0OiBrZXlzLmluZGV4T2YoZGl2ZXJnZW5jZS50YXJnZXQucGFyZW50S2V5KVxuICB9O1xuICByZXR1cm4ga2V5UG9zaXRpb24udGFyZ2V0ID4ga2V5UG9zaXRpb24udGhpcyA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCI7XG59XG5mdW5jdGlvbiBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvRGlmZmVyZW50RnVuY3Rpb25zSW50ZXJuYWwoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBpZiAoIXRhcmdldC5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSkge1xuICAgIGlmIChfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKGJhc2UsIHRhcmdldCwgY2FjaGUpID09PSBcImJlZm9yZVwiKSB7XG4gICAgICByZXR1cm4gXCJiZWZvcmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xuICB9IGVsc2UgaWYgKHRhcmdldC5wYXJlbnRQYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkge1xuICAgIHJldHVybiBcInVua25vd25cIjtcbiAgfVxuICBjb25zdCBiaW5kaW5nID0gdGFyZ2V0LnNjb3BlLmdldEJpbmRpbmcodGFyZ2V0Lm5vZGUuaWQubmFtZSk7XG4gIGlmICghYmluZGluZy5yZWZlcmVuY2VzKSByZXR1cm4gXCJiZWZvcmVcIjtcbiAgY29uc3QgcmVmZXJlbmNlUGF0aHMgPSBiaW5kaW5nLnJlZmVyZW5jZVBhdGhzO1xuICBsZXQgYWxsU3RhdHVzO1xuICBmb3IgKGNvbnN0IHBhdGggb2YgcmVmZXJlbmNlUGF0aHMpIHtcbiAgICBjb25zdCBjaGlsZE9mRnVuY3Rpb24gPSAhIXBhdGguZmluZChwYXRoID0+IHBhdGgubm9kZSA9PT0gdGFyZ2V0Lm5vZGUpO1xuICAgIGlmIChjaGlsZE9mRnVuY3Rpb24pIGNvbnRpbnVlO1xuICAgIGlmIChwYXRoLmtleSAhPT0gXCJjYWxsZWVcIiB8fCAhcGF0aC5wYXJlbnRQYXRoLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICAgcmV0dXJuIFwidW5rbm93blwiO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBfZ3Vlc3NFeGVjdXRpb25TdGF0dXNSZWxhdGl2ZVRvQ2FjaGVkKGJhc2UsIHBhdGgsIGNhY2hlKTtcbiAgICBpZiAoYWxsU3RhdHVzICYmIGFsbFN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgICByZXR1cm4gXCJ1bmtub3duXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsbFN0YXR1cyA9IHN0YXR1cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsbFN0YXR1cztcbn1cbmZ1bmN0aW9uIF9ndWVzc0V4ZWN1dGlvblN0YXR1c1JlbGF0aXZlVG9EaWZmZXJlbnRGdW5jdGlvbnNDYWNoZWQoYmFzZSwgdGFyZ2V0LCBjYWNoZSkge1xuICBsZXQgbm9kZU1hcCA9IGNhY2hlLmdldChiYXNlLm5vZGUpO1xuICBsZXQgY2FjaGVkO1xuICBpZiAoIW5vZGVNYXApIHtcbiAgICBjYWNoZS5zZXQoYmFzZS5ub2RlLCBub2RlTWFwID0gbmV3IE1hcCgpKTtcbiAgfSBlbHNlIGlmIChjYWNoZWQgPSBub2RlTWFwLmdldCh0YXJnZXQubm9kZSkpIHtcbiAgICBpZiAoY2FjaGVkID09PSBTWU1CT0xfQ0hFQ0tJTkcpIHtcbiAgICAgIHJldHVybiBcInVua25vd25cIjtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbiAgfVxuICBub2RlTWFwLnNldCh0YXJnZXQubm9kZSwgU1lNQk9MX0NIRUNLSU5HKTtcbiAgY29uc3QgcmVzdWx0ID0gX2d1ZXNzRXhlY3V0aW9uU3RhdHVzUmVsYXRpdmVUb0RpZmZlcmVudEZ1bmN0aW9uc0ludGVybmFsKGJhc2UsIHRhcmdldCwgY2FjaGUpO1xuICBub2RlTWFwLnNldCh0YXJnZXQubm9kZSwgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkge1xuICByZXR1cm4gX3Jlc29sdmUuY2FsbCh0aGlzLCBkYW5nZXJvdXMsIHJlc29sdmVkKSB8fCB0aGlzO1xufVxuZnVuY3Rpb24gX3Jlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCkge1xuICB2YXIgX3Jlc29sdmVkO1xuICBpZiAoKF9yZXNvbHZlZCA9IHJlc29sdmVkKSAhPSBudWxsICYmIF9yZXNvbHZlZC5pbmNsdWRlcyh0aGlzKSkgcmV0dXJuO1xuICByZXNvbHZlZCA9IHJlc29sdmVkIHx8IFtdO1xuICByZXNvbHZlZC5wdXNoKHRoaXMpO1xuICBpZiAodGhpcy5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpKSB7XG4gICAgaWYgKHRoaXMuZ2V0KFwiaWRcIikuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImluaXRcIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICB9IGVsc2Uge31cbiAgfSBlbHNlIGlmICh0aGlzLmlzUmVmZXJlbmNlZElkZW50aWZpZXIoKSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLnNjb3BlLmdldEJpbmRpbmcodGhpcy5ub2RlLm5hbWUpO1xuICAgIGlmICghYmluZGluZykgcmV0dXJuO1xuICAgIGlmICghYmluZGluZy5jb25zdGFudCkgcmV0dXJuO1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IFwibW9kdWxlXCIpIHJldHVybjtcbiAgICBpZiAoYmluZGluZy5wYXRoICE9PSB0aGlzKSB7XG4gICAgICBjb25zdCByZXQgPSBiaW5kaW5nLnBhdGgucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICAgIGlmICh0aGlzLmZpbmQocGFyZW50ID0+IHBhcmVudC5ub2RlID09PSByZXQubm9kZSkpIHJldHVybjtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMuaXNUeXBlQ2FzdEV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25cIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgfSBlbHNlIGlmIChkYW5nZXJvdXMgJiYgdGhpcy5pc01lbWJlckV4cHJlc3Npb24oKSkge1xuICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMudG9Db21wdXRlZEtleSgpO1xuICAgIGlmICghaXNMaXRlcmFsKHRhcmdldEtleSkpIHJldHVybjtcbiAgICBjb25zdCB0YXJnZXROYW1lID0gdGFyZ2V0S2V5LnZhbHVlO1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0KFwib2JqZWN0XCIpLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG4gICAgaWYgKHRhcmdldC5pc09iamVjdEV4cHJlc3Npb24oKSkge1xuICAgICAgY29uc3QgcHJvcHMgPSB0YXJnZXQuZ2V0KFwicHJvcGVydGllc1wiKTtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgICBpZiAoIXByb3AuaXNQcm9wZXJ0eSgpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJvcC5nZXQoXCJrZXlcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IHByb3AuaXNudChcImNvbXB1dGVkXCIpICYmIGtleS5pc0lkZW50aWZpZXIoe1xuICAgICAgICAgIG5hbWU6IHRhcmdldE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hdGNoID0gbWF0Y2ggfHwga2V5LmlzTGl0ZXJhbCh7XG4gICAgICAgICAgdmFsdWU6IHRhcmdldE5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXRjaCkgcmV0dXJuIHByb3AuZ2V0KFwidmFsdWVcIikucmVzb2x2ZShkYW5nZXJvdXMsIHJlc29sdmVkKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhcmdldC5pc0FycmF5RXhwcmVzc2lvbigpICYmICFpc05hTigrdGFyZ2V0TmFtZSkpIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGFyZ2V0LmdldChcImVsZW1lbnRzXCIpO1xuICAgICAgY29uc3QgZWxlbSA9IGVsZW1zW3RhcmdldE5hbWVdO1xuICAgICAgaWYgKGVsZW0pIHJldHVybiBlbGVtLnJlc29sdmUoZGFuZ2Vyb3VzLCByZXNvbHZlZCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpc0NvbnN0YW50RXhwcmVzc2lvbigpIHtcbiAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKCkpIHtcbiAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5zY29wZS5nZXRCaW5kaW5nKHRoaXMubm9kZS5uYW1lKTtcbiAgICBpZiAoIWJpbmRpbmcpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gYmluZGluZy5jb25zdGFudDtcbiAgfVxuICBpZiAodGhpcy5pc0xpdGVyYWwoKSkge1xuICAgIGlmICh0aGlzLmlzUmVnRXhwTGl0ZXJhbCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzVGVtcGxhdGVMaXRlcmFsKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImV4cHJlc3Npb25zXCIpLmV2ZXJ5KGV4cHJlc3Npb24gPT4gZXhwcmVzc2lvbi5pc0NvbnN0YW50RXhwcmVzc2lvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNVbmFyeUV4cHJlc3Npb24oKSkge1xuICAgIGlmICh0aGlzLm5vZGUub3BlcmF0b3IgIT09IFwidm9pZFwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldChcImFyZ3VtZW50XCIpLmlzQ29uc3RhbnRFeHByZXNzaW9uKCk7XG4gIH1cbiAgaWYgKHRoaXMuaXNCaW5hcnlFeHByZXNzaW9uKCkpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcGVyYXRvclxuICAgIH0gPSB0aGlzLm5vZGU7XG4gICAgcmV0dXJuIG9wZXJhdG9yICE9PSBcImluXCIgJiYgb3BlcmF0b3IgIT09IFwiaW5zdGFuY2VvZlwiICYmIHRoaXMuZ2V0KFwibGVmdFwiKS5pc0NvbnN0YW50RXhwcmVzc2lvbigpICYmIHRoaXMuZ2V0KFwicmlnaHRcIikuaXNDb25zdGFudEV4cHJlc3Npb24oKTtcbiAgfVxuICBpZiAodGhpcy5pc01lbWJlckV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiAhdGhpcy5ub2RlLmNvbXB1dGVkICYmIHRoaXMuZ2V0KFwib2JqZWN0XCIpLmlzSWRlbnRpZmllcih7XG4gICAgICBuYW1lOiBcIlN5bWJvbFwiXG4gICAgfSkgJiYgIXRoaXMuc2NvcGUuaGFzQmluZGluZyhcIlN5bWJvbFwiLCB7XG4gICAgICBub0dsb2JhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpZiAodGhpcy5pc0NhbGxFeHByZXNzaW9uKCkpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlLmFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdGhpcy5nZXQoXCJjYWxsZWVcIikubWF0Y2hlc1BhdHRlcm4oXCJTeW1ib2wuZm9yXCIpICYmICF0aGlzLnNjb3BlLmhhc0JpbmRpbmcoXCJTeW1ib2xcIiwge1xuICAgICAgbm9HbG9iYWxzOiB0cnVlXG4gICAgfSkgJiYgdGhpcy5nZXQoXCJhcmd1bWVudHNcIilbMF0uaXNTdHJpbmdMaXRlcmFsKCk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJblN0cmljdE1vZGUoKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdGhpcy5pc1Byb2dyYW0oKSA/IHRoaXMgOiB0aGlzLnBhcmVudFBhdGg7XG4gIGNvbnN0IHN0cmljdFBhcmVudCA9IHN0YXJ0LmZpbmQocGF0aCA9PiB7XG4gICAgaWYgKHBhdGguaXNQcm9ncmFtKHtcbiAgICAgIHNvdXJjZVR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHBhdGguaXNDbGFzcygpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocGF0aC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKCkgJiYgIXBhdGguZ2V0KFwiYm9keVwiKS5pc0Jsb2NrU3RhdGVtZW50KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGJvZHk7XG4gICAgaWYgKHBhdGguaXNGdW5jdGlvbigpKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgfSBlbHNlIGlmIChwYXRoLmlzUHJvZ3JhbSgpKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGlyZWN0aXZlIG9mIGJvZHkuZGlyZWN0aXZlcykge1xuICAgICAgaWYgKGRpcmVjdGl2ZS52YWx1ZS52YWx1ZSA9PT0gXCJ1c2Ugc3RyaWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuICEhc3RyaWN0UGFyZW50O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRyb3NwZWN0aW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40854\n')},27145:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _t = __webpack_require__(2352);\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n    if (path.node.name === "this") {\n      let scope = path.scope;\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n};\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n      if (this.breakOnScopePaths.includes(scope.path)) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n    if (!path) return;\n    let targetScope = path.scope;\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n        if (binding.kind === "param" || binding.path.parentKey === "params") {\n          continue;\n        }\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n    return path;\n  }\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get("body").get("body");\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === "param" && binding.constant) return true;\n    }\n    return false;\n  }\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier("ref");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);\n    const parent = this.path.parentPath;\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");\n  }\n}\nexports["default"] = PathHoister;\n\n//# sourceMappingURL=hoister.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcxNDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlOztBQUVmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvbGliL2hvaXN0ZXIuanM/NDc5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX3QyID0gX3Q7XG5jb25zdCB7XG4gIHJlYWN0XG59ID0gX3Q7XG5jb25zdCB7XG4gIGNsb25lTm9kZSxcbiAganN4RXhwcmVzc2lvbkNvbnRhaW5lcixcbiAgdmFyaWFibGVEZWNsYXJhdGlvbixcbiAgdmFyaWFibGVEZWNsYXJhdG9yXG59ID0gX3QyO1xuY29uc3QgcmVmZXJlbmNlVmlzaXRvciA9IHtcbiAgUmVmZXJlbmNlZElkZW50aWZpZXIocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAocGF0aC5pc0pTWElkZW50aWZpZXIoKSAmJiByZWFjdC5pc0NvbXBhdFRhZyhwYXRoLm5vZGUubmFtZSkgJiYgIXBhdGgucGFyZW50UGF0aC5pc0pTWE1lbWJlckV4cHJlc3Npb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGF0aC5ub2RlLm5hbWUgPT09IFwidGhpc1wiKSB7XG4gICAgICBsZXQgc2NvcGUgPSBwYXRoLnNjb3BlO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkgJiYgIXNjb3BlLnBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICAgIGlmIChzY29wZSkgc3RhdGUuYnJlYWtPblNjb3BlUGF0aHMucHVzaChzY29wZS5wYXRoKTtcbiAgICB9XG4gICAgY29uc3QgYmluZGluZyA9IHBhdGguc2NvcGUuZ2V0QmluZGluZyhwYXRoLm5vZGUubmFtZSk7XG4gICAgaWYgKCFiaW5kaW5nKSByZXR1cm47XG4gICAgZm9yIChjb25zdCB2aW9sYXRpb24gb2YgYmluZGluZy5jb25zdGFudFZpb2xhdGlvbnMpIHtcbiAgICAgIGlmICh2aW9sYXRpb24uc2NvcGUgIT09IGJpbmRpbmcucGF0aC5zY29wZSkge1xuICAgICAgICBzdGF0ZS5tdXRhYmxlQmluZGluZyA9IHRydWU7XG4gICAgICAgIHBhdGguc3RvcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5kaW5nICE9PSBzdGF0ZS5zY29wZS5nZXRCaW5kaW5nKHBhdGgubm9kZS5uYW1lKSkgcmV0dXJuO1xuICAgIHN0YXRlLmJpbmRpbmdzW3BhdGgubm9kZS5uYW1lXSA9IGJpbmRpbmc7XG4gIH1cbn07XG5jbGFzcyBQYXRoSG9pc3RlciB7XG4gIGNvbnN0cnVjdG9yKHBhdGgsIHNjb3BlKSB7XG4gICAgdGhpcy5icmVha09uU2NvcGVQYXRocyA9IHZvaWQgMDtcbiAgICB0aGlzLmJpbmRpbmdzID0gdm9pZCAwO1xuICAgIHRoaXMubXV0YWJsZUJpbmRpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5hdHRhY2hBZnRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmJyZWFrT25TY29wZVBhdGhzID0gW107XG4gICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIHRoaXMubXV0YWJsZUJpbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjb3BlcyA9IFtdO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIHRoaXMuYXR0YWNoQWZ0ZXIgPSBmYWxzZTtcbiAgfVxuICBpc0NvbXBhdGlibGVTY29wZShzY29wZSkge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1trZXldO1xuICAgICAgaWYgKCFzY29wZS5iaW5kaW5nSWRlbnRpZmllckVxdWFscyhrZXksIGJpbmRpbmcuaWRlbnRpZmllcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRDb21wYXRpYmxlU2NvcGVzKCkge1xuICAgIGxldCBzY29wZSA9IHRoaXMucGF0aC5zY29wZTtcbiAgICBkbyB7XG4gICAgICBpZiAodGhpcy5pc0NvbXBhdGlibGVTY29wZShzY29wZSkpIHtcbiAgICAgICAgdGhpcy5zY29wZXMucHVzaChzY29wZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJyZWFrT25TY29wZVBhdGhzLmluY2x1ZGVzKHNjb3BlLnBhdGgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBnZXRBdHRhY2htZW50UGF0aCgpIHtcbiAgICBsZXQgcGF0aCA9IHRoaXMuX2dldEF0dGFjaG1lbnRQYXRoKCk7XG4gICAgaWYgKCFwYXRoKSByZXR1cm47XG4gICAgbGV0IHRhcmdldFNjb3BlID0gcGF0aC5zY29wZTtcbiAgICBpZiAodGFyZ2V0U2NvcGUucGF0aCA9PT0gcGF0aCkge1xuICAgICAgdGFyZ2V0U2NvcGUgPSBwYXRoLnNjb3BlLnBhcmVudDtcbiAgICB9XG4gICAgaWYgKHRhcmdldFNjb3BlLnBhdGguaXNQcm9ncmFtKCkgfHwgdGFyZ2V0U2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgICBpZiAoIXRhcmdldFNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgICAgICAgaWYgKGJpbmRpbmcua2luZCA9PT0gXCJwYXJhbVwiIHx8IGJpbmRpbmcucGF0aC5wYXJlbnRLZXkgPT09IFwicGFyYW1zXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiaW5kaW5nUGFyZW50UGF0aCA9IHRoaXMuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgoYmluZGluZy5wYXRoKTtcbiAgICAgICAgaWYgKGJpbmRpbmdQYXJlbnRQYXRoLmtleSA+PSBwYXRoLmtleSkge1xuICAgICAgICAgIHRoaXMuYXR0YWNoQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgIHBhdGggPSBiaW5kaW5nLnBhdGg7XG4gICAgICAgICAgZm9yIChjb25zdCB2aW9sYXRpb25QYXRoIG9mIGJpbmRpbmcuY29uc3RhbnRWaW9sYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRhY2htZW50UGFyZW50Rm9yUGF0aCh2aW9sYXRpb25QYXRoKS5rZXkgPiBwYXRoLmtleSkge1xuICAgICAgICAgICAgICBwYXRoID0gdmlvbGF0aW9uUGF0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgX2dldEF0dGFjaG1lbnRQYXRoKCkge1xuICAgIGNvbnN0IHNjb3BlcyA9IHRoaXMuc2NvcGVzO1xuICAgIGNvbnN0IHNjb3BlID0gc2NvcGVzLnBvcCgpO1xuICAgIGlmICghc2NvcGUpIHJldHVybjtcbiAgICBpZiAoc2NvcGUucGF0aC5pc0Z1bmN0aW9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmhhc093blBhcmFtQmluZGluZ3Moc2NvcGUpKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlID09PSBzY29wZSkgcmV0dXJuO1xuICAgICAgICBjb25zdCBib2RpZXMgPSBzY29wZS5wYXRoLmdldChcImJvZHlcIikuZ2V0KFwiYm9keVwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYm9kaWVzW2ldLm5vZGUuX2Jsb2NrSG9pc3QpIGNvbnRpbnVlO1xuICAgICAgICAgIHJldHVybiBib2RpZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE5leHRTY29wZUF0dGFjaG1lbnRQYXJlbnQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlLnBhdGguaXNQcm9ncmFtKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE5leHRTY29wZUF0dGFjaG1lbnRQYXJlbnQoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TmV4dFNjb3BlQXR0YWNobWVudFBhcmVudCgpIHtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVzLnBvcCgpO1xuICAgIGlmIChzY29wZSkgcmV0dXJuIHRoaXMuZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgoc2NvcGUucGF0aCk7XG4gIH1cbiAgZ2V0QXR0YWNobWVudFBhcmVudEZvclBhdGgocGF0aCkge1xuICAgIGRvIHtcbiAgICAgIGlmICghcGF0aC5wYXJlbnRQYXRoIHx8IEFycmF5LmlzQXJyYXkocGF0aC5jb250YWluZXIpICYmIHBhdGguaXNTdGF0ZW1lbnQoKSkge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwYXRoID0gcGF0aC5wYXJlbnRQYXRoKTtcbiAgfVxuICBoYXNPd25QYXJhbUJpbmRpbmdzKHNjb3BlKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuYmluZGluZ3MpKSB7XG4gICAgICBpZiAoIXNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICBpZiAoYmluZGluZy5raW5kID09PSBcInBhcmFtXCIgJiYgYmluZGluZy5jb25zdGFudCkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBydW4oKSB7XG4gICAgdGhpcy5wYXRoLnRyYXZlcnNlKHJlZmVyZW5jZVZpc2l0b3IsIHRoaXMpO1xuICAgIGlmICh0aGlzLm11dGFibGVCaW5kaW5nKSByZXR1cm47XG4gICAgdGhpcy5nZXRDb21wYXRpYmxlU2NvcGVzKCk7XG4gICAgY29uc3QgYXR0YWNoVG8gPSB0aGlzLmdldEF0dGFjaG1lbnRQYXRoKCk7XG4gICAgaWYgKCFhdHRhY2hUbykgcmV0dXJuO1xuICAgIGlmIChhdHRhY2hUby5nZXRGdW5jdGlvblBhcmVudCgpID09PSB0aGlzLnBhdGguZ2V0RnVuY3Rpb25QYXJlbnQoKSkgcmV0dXJuO1xuICAgIGxldCB1aWQgPSBhdHRhY2hUby5zY29wZS5nZW5lcmF0ZVVpZElkZW50aWZpZXIoXCJyZWZcIik7XG4gICAgY29uc3QgZGVjbGFyYXRvciA9IHZhcmlhYmxlRGVjbGFyYXRvcih1aWQsIHRoaXMucGF0aC5ub2RlKTtcbiAgICBjb25zdCBpbnNlcnRGbiA9IHRoaXMuYXR0YWNoQWZ0ZXIgPyBcImluc2VydEFmdGVyXCIgOiBcImluc2VydEJlZm9yZVwiO1xuICAgIGNvbnN0IFthdHRhY2hlZF0gPSBhdHRhY2hUb1tpbnNlcnRGbl0oW2F0dGFjaFRvLmlzVmFyaWFibGVEZWNsYXJhdG9yKCkgPyBkZWNsYXJhdG9yIDogdmFyaWFibGVEZWNsYXJhdGlvbihcInZhclwiLCBbZGVjbGFyYXRvcl0pXSk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXRoLnBhcmVudFBhdGg7XG4gICAgaWYgKHBhcmVudC5pc0pTWEVsZW1lbnQoKSAmJiB0aGlzLnBhdGguY29udGFpbmVyID09PSBwYXJlbnQubm9kZS5jaGlsZHJlbikge1xuICAgICAgdWlkID0ganN4RXhwcmVzc2lvbkNvbnRhaW5lcih1aWQpO1xuICAgIH1cbiAgICB0aGlzLnBhdGgucmVwbGFjZVdpdGgoY2xvbmVOb2RlKHVpZCkpO1xuICAgIHJldHVybiBhdHRhY2hUby5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpID8gYXR0YWNoZWQuZ2V0KFwiaW5pdFwiKSA6IGF0dGFjaGVkLmdldChcImRlY2xhcmF0aW9ucy4wLmluaXRcIik7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBhdGhIb2lzdGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2lzdGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27145\n')},77860:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.hooks = void 0;\nconst hooks = exports.hooks = [function (self, parent) {\n  const removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === "left") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && self.key === "consequent" || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: "BlockStatement",\n      body: []\n    });\n    return true;\n  }\n}];\n\n//# sourceMappingURL=removal-hooks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc4NjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi9yZW1vdmFsLWhvb2tzLmpzP2E1NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmhvb2tzID0gdm9pZCAwO1xuY29uc3QgaG9va3MgPSBleHBvcnRzLmhvb2tzID0gW2Z1bmN0aW9uIChzZWxmLCBwYXJlbnQpIHtcbiAgY29uc3QgcmVtb3ZlUGFyZW50ID0gc2VsZi5rZXkgPT09IFwidGVzdFwiICYmIChwYXJlbnQuaXNXaGlsZSgpIHx8IHBhcmVudC5pc1N3aXRjaENhc2UoKSkgfHwgc2VsZi5rZXkgPT09IFwiZGVjbGFyYXRpb25cIiAmJiBwYXJlbnQuaXNFeHBvcnREZWNsYXJhdGlvbigpIHx8IHNlbGYua2V5ID09PSBcImJvZHlcIiAmJiBwYXJlbnQuaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgc2VsZi5saXN0S2V5ID09PSBcImRlY2xhcmF0aW9uc1wiICYmIHBhcmVudC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oKSAmJiBwYXJlbnQubm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxIHx8IHNlbGYua2V5ID09PSBcImV4cHJlc3Npb25cIiAmJiBwYXJlbnQuaXNFeHByZXNzaW9uU3RhdGVtZW50KCk7XG4gIGlmIChyZW1vdmVQYXJlbnQpIHtcbiAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sIGZ1bmN0aW9uIChzZWxmLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5pc1NlcXVlbmNlRXhwcmVzc2lvbigpICYmIHBhcmVudC5ub2RlLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcmVudC5yZXBsYWNlV2l0aChwYXJlbnQubm9kZS5leHByZXNzaW9uc1swXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sIGZ1bmN0aW9uIChzZWxmLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudC5pc0JpbmFyeSgpKSB7XG4gICAgaWYgKHNlbGYua2V5ID09PSBcImxlZnRcIikge1xuICAgICAgcGFyZW50LnJlcGxhY2VXaXRoKHBhcmVudC5ub2RlLnJpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LnJlcGxhY2VXaXRoKHBhcmVudC5ub2RlLmxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSwgZnVuY3Rpb24gKHNlbGYsIHBhcmVudCkge1xuICBpZiAocGFyZW50LmlzSWZTdGF0ZW1lbnQoKSAmJiBzZWxmLmtleSA9PT0gXCJjb25zZXF1ZW50XCIgfHwgc2VsZi5rZXkgPT09IFwiYm9keVwiICYmIChwYXJlbnQuaXNMb29wKCkgfHwgcGFyZW50LmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkpIHtcbiAgICBzZWxmLnJlcGxhY2VXaXRoKHtcbiAgICAgIHR5cGU6IFwiQmxvY2tTdGF0ZW1lbnRcIixcbiAgICAgIGJvZHk6IFtdXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1dO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmFsLWhvb2tzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///77860\n')},57973:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isBindingIdentifier = isBindingIdentifier;\nexports.isBlockScoped = isBlockScoped;\nexports.isExpression = isExpression;\nexports.isFlow = isFlow;\nexports.isForAwaitStatement = isForAwaitStatement;\nexports.isGenerated = isGenerated;\nexports.isPure = isPure;\nexports.isReferenced = isReferenced;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isReferencedMemberExpression = isReferencedMemberExpression;\nexports.isRestProperty = isRestProperty;\nexports.isScope = isScope;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStatement = isStatement;\nexports.isUser = isUser;\nexports.isVar = isVar;\nvar _t = __webpack_require__(2352);\nconst {\n  isBinding,\n  isBlockScoped: nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression: nodeIsExpression,\n  isFlow: nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement: nodeIsRestElement,\n  isReferenced: nodeIsReferenced,\n  isScope: nodeIsScope,\n  isStatement: nodeIsStatement,\n  isVar: nodeIsVar,\n  isVariableDeclaration,\n  react,\n  isForOfStatement\n} = _t;\nconst {\n  isCompatTag\n} = react;\nfunction isReferencedIdentifier(opts) {\n  const {\n    node,\n    parent\n  } = this;\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      return false;\n    }\n  }\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\nfunction isReferencedMemberExpression() {\n  const {\n    node,\n    parent\n  } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\nfunction isBindingIdentifier() {\n  const {\n    node,\n    parent\n  } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\nfunction isStatement() {\n  const {\n    node,\n    parent\n  } = this;\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, {\n        left: node\n      })) return false;\n      if (isForStatement(parent, {\n        init: node\n      })) return false;\n    }\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction isExpression() {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\nfunction isScope() {\n  return nodeIsScope(this.node, this.parent);\n}\nfunction isReferenced() {\n  return nodeIsReferenced(this.node, this.parent);\n}\nfunction isBlockScoped() {\n  return nodeIsBlockScoped(this.node);\n}\nfunction isVar() {\n  return nodeIsVar(this.node);\n}\nfunction isUser() {\n  return this.node && !!this.node.loc;\n}\nfunction isGenerated() {\n  return !this.isUser();\n}\nfunction isPure(constantsOnly) {\n  return this.scope.isPure(this.node, constantsOnly);\n}\nfunction isFlow() {\n  const {\n    node\n  } = this;\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === "type" || node.importKind === "typeof";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === "type";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === "type" || node.importKind === "typeof";\n  } else {\n    return false;\n  }\n}\nfunction isRestProperty() {\n  var _this$parentPath;\n  return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());\n}\nfunction isSpreadProperty() {\n  var _this$parentPath2;\n  return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());\n}\nfunction isForAwaitStatement() {\n  return isForOfStatement(this.node, {\n    await: true\n  });\n}\n{\n  exports.isExistentialTypeParam = function isExistentialTypeParam() {\n    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");\n  };\n  exports.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {\n    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");\n  };\n}\n\n//# sourceMappingURL=virtual-types-validator.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc5NzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkJBQTJCO0FBQzNCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsY0FBYztBQUNkLG9CQUFvQjtBQUNwQiw4QkFBOEI7QUFDOUIsb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QixlQUFlO0FBQ2Ysd0JBQXdCO0FBQ3hCLG1CQUFtQjtBQUNuQixjQUFjO0FBQ2QsYUFBYTtBQUNiLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFLDhCQUE4QjtBQUNoQztBQUNBO0FBQ0EsRUFBRSxzQ0FBc0M7QUFDeEM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvbGliL3ZpcnR1YWwtdHlwZXMtdmFsaWRhdG9yLmpzPzliZmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzQmluZGluZ0lkZW50aWZpZXIgPSBpc0JpbmRpbmdJZGVudGlmaWVyO1xuZXhwb3J0cy5pc0Jsb2NrU2NvcGVkID0gaXNCbG9ja1Njb3BlZDtcbmV4cG9ydHMuaXNFeHByZXNzaW9uID0gaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0Zsb3cgPSBpc0Zsb3c7XG5leHBvcnRzLmlzRm9yQXdhaXRTdGF0ZW1lbnQgPSBpc0ZvckF3YWl0U3RhdGVtZW50O1xuZXhwb3J0cy5pc0dlbmVyYXRlZCA9IGlzR2VuZXJhdGVkO1xuZXhwb3J0cy5pc1B1cmUgPSBpc1B1cmU7XG5leHBvcnRzLmlzUmVmZXJlbmNlZCA9IGlzUmVmZXJlbmNlZDtcbmV4cG9ydHMuaXNSZWZlcmVuY2VkSWRlbnRpZmllciA9IGlzUmVmZXJlbmNlZElkZW50aWZpZXI7XG5leHBvcnRzLmlzUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBpc1JlZmVyZW5jZWRNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1Jlc3RQcm9wZXJ0eSA9IGlzUmVzdFByb3BlcnR5O1xuZXhwb3J0cy5pc1Njb3BlID0gaXNTY29wZTtcbmV4cG9ydHMuaXNTcHJlYWRQcm9wZXJ0eSA9IGlzU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmlzU3RhdGVtZW50ID0gaXNTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzVXNlciA9IGlzVXNlcjtcbmV4cG9ydHMuaXNWYXIgPSBpc1ZhcjtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGlzQmluZGluZyxcbiAgaXNCbG9ja1Njb3BlZDogbm9kZUlzQmxvY2tTY29wZWQsXG4gIGlzRXhwb3J0RGVjbGFyYXRpb24sXG4gIGlzRXhwcmVzc2lvbjogbm9kZUlzRXhwcmVzc2lvbixcbiAgaXNGbG93OiBub2RlSXNGbG93LFxuICBpc0ZvclN0YXRlbWVudCxcbiAgaXNGb3JYU3RhdGVtZW50LFxuICBpc0lkZW50aWZpZXIsXG4gIGlzSW1wb3J0RGVjbGFyYXRpb24sXG4gIGlzSW1wb3J0U3BlY2lmaWVyLFxuICBpc0pTWElkZW50aWZpZXIsXG4gIGlzSlNYTWVtYmVyRXhwcmVzc2lvbixcbiAgaXNNZW1iZXJFeHByZXNzaW9uLFxuICBpc1Jlc3RFbGVtZW50OiBub2RlSXNSZXN0RWxlbWVudCxcbiAgaXNSZWZlcmVuY2VkOiBub2RlSXNSZWZlcmVuY2VkLFxuICBpc1Njb3BlOiBub2RlSXNTY29wZSxcbiAgaXNTdGF0ZW1lbnQ6IG5vZGVJc1N0YXRlbWVudCxcbiAgaXNWYXI6IG5vZGVJc1ZhcixcbiAgaXNWYXJpYWJsZURlY2xhcmF0aW9uLFxuICByZWFjdCxcbiAgaXNGb3JPZlN0YXRlbWVudFxufSA9IF90O1xuY29uc3Qge1xuICBpc0NvbXBhdFRhZ1xufSA9IHJlYWN0O1xuZnVuY3Rpb24gaXNSZWZlcmVuY2VkSWRlbnRpZmllcihvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlLFxuICAgIHBhcmVudFxuICB9ID0gdGhpcztcbiAgaWYgKCFpc0lkZW50aWZpZXIobm9kZSwgb3B0cykgJiYgIWlzSlNYTWVtYmVyRXhwcmVzc2lvbihwYXJlbnQsIG9wdHMpKSB7XG4gICAgaWYgKGlzSlNYSWRlbnRpZmllcihub2RlLCBvcHRzKSkge1xuICAgICAgaWYgKGlzQ29tcGF0VGFnKG5vZGUubmFtZSkpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZUlzUmVmZXJlbmNlZChub2RlLCBwYXJlbnQsIHRoaXMucGFyZW50UGF0aC5wYXJlbnQpO1xufVxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkTWVtYmVyRXhwcmVzc2lvbigpIHtcbiAgY29uc3Qge1xuICAgIG5vZGUsXG4gICAgcGFyZW50XG4gIH0gPSB0aGlzO1xuICByZXR1cm4gaXNNZW1iZXJFeHByZXNzaW9uKG5vZGUpICYmIG5vZGVJc1JlZmVyZW5jZWQobm9kZSwgcGFyZW50KTtcbn1cbmZ1bmN0aW9uIGlzQmluZGluZ0lkZW50aWZpZXIoKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlLFxuICAgIHBhcmVudFxuICB9ID0gdGhpcztcbiAgY29uc3QgZ3JhbmRwYXJlbnQgPSB0aGlzLnBhcmVudFBhdGgucGFyZW50O1xuICByZXR1cm4gaXNJZGVudGlmaWVyKG5vZGUpICYmIGlzQmluZGluZyhub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVtZW50KCkge1xuICBjb25zdCB7XG4gICAgbm9kZSxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIGlmIChub2RlSXNTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICBpZiAoaXNGb3JYU3RhdGVtZW50KHBhcmVudCwge1xuICAgICAgICBsZWZ0OiBub2RlXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGlzRm9yU3RhdGVtZW50KHBhcmVudCwge1xuICAgICAgICBpbml0OiBub2RlXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbigpIHtcbiAgaWYgKHRoaXMuaXNJZGVudGlmaWVyKCkpIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlZmVyZW5jZWRJZGVudGlmaWVyKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGVJc0V4cHJlc3Npb24odGhpcy5ub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTY29wZSgpIHtcbiAgcmV0dXJuIG5vZGVJc1Njb3BlKHRoaXMubm9kZSwgdGhpcy5wYXJlbnQpO1xufVxuZnVuY3Rpb24gaXNSZWZlcmVuY2VkKCkge1xuICByZXR1cm4gbm9kZUlzUmVmZXJlbmNlZCh0aGlzLm5vZGUsIHRoaXMucGFyZW50KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tTY29wZWQoKSB7XG4gIHJldHVybiBub2RlSXNCbG9ja1Njb3BlZCh0aGlzLm5vZGUpO1xufVxuZnVuY3Rpb24gaXNWYXIoKSB7XG4gIHJldHVybiBub2RlSXNWYXIodGhpcy5ub2RlKTtcbn1cbmZ1bmN0aW9uIGlzVXNlcigpIHtcbiAgcmV0dXJuIHRoaXMubm9kZSAmJiAhIXRoaXMubm9kZS5sb2M7XG59XG5mdW5jdGlvbiBpc0dlbmVyYXRlZCgpIHtcbiAgcmV0dXJuICF0aGlzLmlzVXNlcigpO1xufVxuZnVuY3Rpb24gaXNQdXJlKGNvbnN0YW50c09ubHkpIHtcbiAgcmV0dXJuIHRoaXMuc2NvcGUuaXNQdXJlKHRoaXMubm9kZSwgY29uc3RhbnRzT25seSk7XG59XG5mdW5jdGlvbiBpc0Zsb3coKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlXG4gIH0gPSB0aGlzO1xuICBpZiAobm9kZUlzRmxvdyhub2RlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCI7XG4gIH0gZWxzZSBpZiAoaXNFeHBvcnREZWNsYXJhdGlvbihub2RlKSkge1xuICAgIHJldHVybiBub2RlLmV4cG9ydEtpbmQgPT09IFwidHlwZVwiO1xuICB9IGVsc2UgaWYgKGlzSW1wb3J0U3BlY2lmaWVyKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNSZXN0UHJvcGVydHkoKSB7XG4gIHZhciBfdGhpcyRwYXJlbnRQYXRoO1xuICByZXR1cm4gbm9kZUlzUmVzdEVsZW1lbnQodGhpcy5ub2RlKSAmJiAoKF90aGlzJHBhcmVudFBhdGggPSB0aGlzLnBhcmVudFBhdGgpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRwYXJlbnRQYXRoLmlzT2JqZWN0UGF0dGVybigpKTtcbn1cbmZ1bmN0aW9uIGlzU3ByZWFkUHJvcGVydHkoKSB7XG4gIHZhciBfdGhpcyRwYXJlbnRQYXRoMjtcbiAgcmV0dXJuIG5vZGVJc1Jlc3RFbGVtZW50KHRoaXMubm9kZSkgJiYgKChfdGhpcyRwYXJlbnRQYXRoMiA9IHRoaXMucGFyZW50UGF0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHBhcmVudFBhdGgyLmlzT2JqZWN0RXhwcmVzc2lvbigpKTtcbn1cbmZ1bmN0aW9uIGlzRm9yQXdhaXRTdGF0ZW1lbnQoKSB7XG4gIHJldHVybiBpc0Zvck9mU3RhdGVtZW50KHRoaXMubm9kZSwge1xuICAgIGF3YWl0OiB0cnVlXG4gIH0pO1xufVxue1xuICBleHBvcnRzLmlzRXhpc3RlbnRpYWxUeXBlUGFyYW0gPSBmdW5jdGlvbiBpc0V4aXN0ZW50aWFsVHlwZVBhcmFtKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImBwYXRoLmlzRXhpc3RlbnRpYWxUeXBlUGFyYW1gIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHBhdGguaXNFeGlzdHNUeXBlQW5ub3RhdGlvbigpYCBpbiBCYWJlbCA3LlwiKTtcbiAgfTtcbiAgZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24gPSBmdW5jdGlvbiBpc051bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb24oKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYHBhdGguaXNOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKClgIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHBhdGguaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb24oKWAgaW4gQmFiZWwgNy5cIik7XG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcnR1YWwtdHlwZXMtdmFsaWRhdG9yLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///57973\n')},75562:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\nconst ReferencedIdentifier = exports.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];\nconst ReferencedMemberExpression = exports.ReferencedMemberExpression = ["MemberExpression"];\nconst BindingIdentifier = exports.BindingIdentifier = ["Identifier"];\nconst Statement = exports.Statement = ["Statement"];\nconst Expression = exports.Expression = ["Expression"];\nconst Scope = exports.Scope = ["Scopable", "Pattern"];\nconst Referenced = exports.Referenced = null;\nconst BlockScoped = exports.BlockScoped = null;\nconst Var = exports.Var = ["VariableDeclaration"];\nconst User = exports.User = null;\nconst Generated = exports.Generated = null;\nconst Pure = exports.Pure = null;\nconst Flow = exports.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];\nconst RestProperty = exports.RestProperty = ["RestElement"];\nconst SpreadProperty = exports.SpreadProperty = ["RestElement"];\nconst ExistentialTypeParam = exports.ExistentialTypeParam = ["ExistsTypeAnnotation"];\nconst NumericLiteralTypeAnnotation = exports.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];\nconst ForAwaitStatement = exports.ForAwaitStatement = ["ForOfStatement"];\n\n//# sourceMappingURL=virtual-types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU1NjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsV0FBVyxHQUFHLFlBQVksR0FBRyxpQkFBaUIsR0FBRyxzQkFBc0IsR0FBRyxhQUFhLEdBQUcsb0JBQW9CLEdBQUcsa0NBQWtDLEdBQUcsNEJBQTRCLEdBQUcsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLG9DQUFvQyxHQUFHLGlCQUFpQixHQUFHLHlCQUF5QixHQUFHLFlBQVksR0FBRyxrQkFBa0IsR0FBRyw0QkFBNEIsR0FBRyxtQkFBbUIsR0FBRyx5QkFBeUI7QUFDbGEsNkJBQTZCLDRCQUE0QjtBQUN6RCxtQ0FBbUMsa0NBQWtDO0FBQ3JFLDBCQUEwQix5QkFBeUI7QUFDbkQsa0JBQWtCLGlCQUFpQjtBQUNuQyxtQkFBbUIsa0JBQWtCO0FBQ3JDLGNBQWMsYUFBYTtBQUMzQixtQkFBbUIsa0JBQWtCO0FBQ3JDLG9CQUFvQixtQkFBbUI7QUFDdkMsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsWUFBWTtBQUN6QixrQkFBa0IsaUJBQWlCO0FBQ25DLGFBQWEsWUFBWTtBQUN6QixhQUFhLFlBQVk7QUFDekIscUJBQXFCLG9CQUFvQjtBQUN6Qyx1QkFBdUIsc0JBQXNCO0FBQzdDLDZCQUE2Qiw0QkFBNEI7QUFDekQscUNBQXFDLG9DQUFvQztBQUN6RSwwQkFBMEIseUJBQXlCOztBQUVuRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9wYXRoL2xpYi92aXJ0dWFsLXR5cGVzLmpzPzA2ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlZhciA9IGV4cG9ydHMuVXNlciA9IGV4cG9ydHMuU3RhdGVtZW50ID0gZXhwb3J0cy5TcHJlYWRQcm9wZXJ0eSA9IGV4cG9ydHMuU2NvcGUgPSBleHBvcnRzLlJlc3RQcm9wZXJ0eSA9IGV4cG9ydHMuUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0gZXhwb3J0cy5SZWZlcmVuY2VkID0gZXhwb3J0cy5QdXJlID0gZXhwb3J0cy5OdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5HZW5lcmF0ZWQgPSBleHBvcnRzLkZvckF3YWl0U3RhdGVtZW50ID0gZXhwb3J0cy5GbG93ID0gZXhwb3J0cy5FeHByZXNzaW9uID0gZXhwb3J0cy5FeGlzdGVudGlhbFR5cGVQYXJhbSA9IGV4cG9ydHMuQmxvY2tTY29wZWQgPSBleHBvcnRzLkJpbmRpbmdJZGVudGlmaWVyID0gdm9pZCAwO1xuY29uc3QgUmVmZXJlbmNlZElkZW50aWZpZXIgPSBleHBvcnRzLlJlZmVyZW5jZWRJZGVudGlmaWVyID0gW1wiSWRlbnRpZmllclwiLCBcIkpTWElkZW50aWZpZXJcIl07XG5jb25zdCBSZWZlcmVuY2VkTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuUmVmZXJlbmNlZE1lbWJlckV4cHJlc3Npb24gPSBbXCJNZW1iZXJFeHByZXNzaW9uXCJdO1xuY29uc3QgQmluZGluZ0lkZW50aWZpZXIgPSBleHBvcnRzLkJpbmRpbmdJZGVudGlmaWVyID0gW1wiSWRlbnRpZmllclwiXTtcbmNvbnN0IFN0YXRlbWVudCA9IGV4cG9ydHMuU3RhdGVtZW50ID0gW1wiU3RhdGVtZW50XCJdO1xuY29uc3QgRXhwcmVzc2lvbiA9IGV4cG9ydHMuRXhwcmVzc2lvbiA9IFtcIkV4cHJlc3Npb25cIl07XG5jb25zdCBTY29wZSA9IGV4cG9ydHMuU2NvcGUgPSBbXCJTY29wYWJsZVwiLCBcIlBhdHRlcm5cIl07XG5jb25zdCBSZWZlcmVuY2VkID0gZXhwb3J0cy5SZWZlcmVuY2VkID0gbnVsbDtcbmNvbnN0IEJsb2NrU2NvcGVkID0gZXhwb3J0cy5CbG9ja1Njb3BlZCA9IG51bGw7XG5jb25zdCBWYXIgPSBleHBvcnRzLlZhciA9IFtcIlZhcmlhYmxlRGVjbGFyYXRpb25cIl07XG5jb25zdCBVc2VyID0gZXhwb3J0cy5Vc2VyID0gbnVsbDtcbmNvbnN0IEdlbmVyYXRlZCA9IGV4cG9ydHMuR2VuZXJhdGVkID0gbnVsbDtcbmNvbnN0IFB1cmUgPSBleHBvcnRzLlB1cmUgPSBudWxsO1xuY29uc3QgRmxvdyA9IGV4cG9ydHMuRmxvdyA9IFtcIkZsb3dcIiwgXCJJbXBvcnREZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCIsIFwiSW1wb3J0U3BlY2lmaWVyXCJdO1xuY29uc3QgUmVzdFByb3BlcnR5ID0gZXhwb3J0cy5SZXN0UHJvcGVydHkgPSBbXCJSZXN0RWxlbWVudFwiXTtcbmNvbnN0IFNwcmVhZFByb3BlcnR5ID0gZXhwb3J0cy5TcHJlYWRQcm9wZXJ0eSA9IFtcIlJlc3RFbGVtZW50XCJdO1xuY29uc3QgRXhpc3RlbnRpYWxUeXBlUGFyYW0gPSBleHBvcnRzLkV4aXN0ZW50aWFsVHlwZVBhcmFtID0gW1wiRXhpc3RzVHlwZUFubm90YXRpb25cIl07XG5jb25zdCBOdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gZXhwb3J0cy5OdW1lcmljTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gW1wiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCJdO1xuY29uc3QgRm9yQXdhaXRTdGF0ZW1lbnQgPSBleHBvcnRzLkZvckF3YWl0U3RhdGVtZW50ID0gW1wiRm9yT2ZTdGF0ZW1lbnRcIl07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcnR1YWwtdHlwZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///75562\n')},58345:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\nvar _cache = __webpack_require__(37411);\nvar _hoister = __webpack_require__(27145);\nvar _index = __webpack_require__(29709);\nvar _context = __webpack_require__(79578);\nvar _removal = __webpack_require__(53097);\nvar _t = __webpack_require__(2352);\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\nfunction insertBefore(nodes_) {\n  _removal._assertUnremoved.call(this);\n  const nodes = _verifyNodeList.call(this, nodes_);\n  const {\n    parentPath,\n    parent\n  } = this;\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertBefore.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer("body", nodes);\n  } else {\n    throw new Error("We don\'t know what to do with this node type. " + "We were previously a Statement but we can\'t fit in here?");\n  }\n}\nfunction _containerInsert(from, nodes) {\n  updateSiblingKeys.call(this, from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    var _this$context;\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n    if ((_this$context = this.context) != null && _this$context.queue) {\n      _context.pushContext.call(path, this.context);\n    }\n  }\n  const contexts = _context._getQueueContexts.call(this);\n  for (const path of paths) {\n    _context.setScope.call(path);\n    path.debug("Inserted.");\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n  return paths;\n}\nfunction _containerInsertBefore(nodes) {\n  return _containerInsert.call(this, this.key, nodes);\n}\nfunction _containerInsertAfter(nodes) {\n  return _containerInsert.call(this, this.key + 1, nodes);\n}\nconst last = arr => arr[arr.length - 1];\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\nfunction insertAfter(nodes_) {\n  _removal._assertUnremoved.call(this);\n  if (this.isSequenceExpression()) {\n    return last(this.get("expressions")).insertAfter(nodes_);\n  }\n  const nodes = _verifyNodeList.call(this, nodes_);\n  const {\n    parentPath,\n    parent\n  } = this;\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {\n    const self = this;\n    if (self.node) {\n      const node = self.node;\n      let {\n        scope\n      } = this;\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        self.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        self.get("callee.body").insertAfter(nodes);\n        return [self];\n      }\n      if (isHiddenInSequenceExpression(self)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertAfter.call(this, nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer("body", nodes);\n  } else {\n    throw new Error("We don\'t know what to do with this node type. " + "We were previously a Statement but we can\'t fit in here?");\n  }\n}\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n  const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];\n  for (const [, path] of paths) {\n    if (typeof path.key === "number" && path.container === this.container && path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n    if (!node) {\n      msg = "has falsy node";\n    } else if (typeof node !== "object") {\n      msg = "contains a non-object node";\n    } else if (!node.type) {\n      msg = "without a type";\n    } else if (node instanceof _index.default) {\n      msg = "has a NodePath when it expected a raw object";\n    }\n    if (msg) {\n      const type = Array.isArray(node) ? "array" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n  return nodes;\n}\nfunction unshiftContainer(listKey, nodes) {\n  _removal._assertUnremoved.call(this);\n  nodes = _verifyNodeList.call(this, nodes);\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n  return _containerInsertBefore.call(path, nodes);\n}\nfunction pushContainer(listKey, nodes) {\n  _removal._assertUnremoved.call(this);\n  const verifiedNodes = _verifyNodeList.call(this, nodes);\n  const container = this.node[listKey];\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n  return path.replaceWithMultiple(verifiedNodes);\n}\n{\n  exports.hoist = function hoist(scope = this.scope) {\n    const hoister = new _hoister.default(this, scope);\n    return hoister.run();\n  };\n}\n\n//# sourceMappingURL=modification.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTgzNDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsYUFBYSxtQkFBTyxDQUFDLEtBQWE7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLEtBQWtCO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyxLQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxLQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxLQUFjO0FBQ3JDLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLG9CQUFvQixHQUFHLGNBQWMsS0FBSztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRSxhQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9tb2RpZmljYXRpb24uanM/MGZmMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuX2NvbnRhaW5lckluc2VydCA9IF9jb250YWluZXJJbnNlcnQ7XG5leHBvcnRzLl9jb250YWluZXJJbnNlcnRBZnRlciA9IF9jb250YWluZXJJbnNlcnRBZnRlcjtcbmV4cG9ydHMuX2NvbnRhaW5lckluc2VydEJlZm9yZSA9IF9jb250YWluZXJJbnNlcnRCZWZvcmU7XG5leHBvcnRzLl92ZXJpZnlOb2RlTGlzdCA9IF92ZXJpZnlOb2RlTGlzdDtcbmV4cG9ydHMuaW5zZXJ0QWZ0ZXIgPSBpbnNlcnRBZnRlcjtcbmV4cG9ydHMuaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlO1xuZXhwb3J0cy5wdXNoQ29udGFpbmVyID0gcHVzaENvbnRhaW5lcjtcbmV4cG9ydHMudW5zaGlmdENvbnRhaW5lciA9IHVuc2hpZnRDb250YWluZXI7XG5leHBvcnRzLnVwZGF0ZVNpYmxpbmdLZXlzID0gdXBkYXRlU2libGluZ0tleXM7XG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xudmFyIF9ob2lzdGVyID0gcmVxdWlyZShcIi4vbGliL2hvaXN0ZXIuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vaW5kZXguanNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xudmFyIF9yZW1vdmFsID0gcmVxdWlyZShcIi4vcmVtb3ZhbC5qc1wiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG5jb25zdCB7XG4gIGFycm93RnVuY3Rpb25FeHByZXNzaW9uLFxuICBhc3NlcnRFeHByZXNzaW9uLFxuICBhc3NpZ25tZW50RXhwcmVzc2lvbixcbiAgYmxvY2tTdGF0ZW1lbnQsXG4gIGNhbGxFeHByZXNzaW9uLFxuICBjbG9uZU5vZGUsXG4gIGV4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIGlzQXNzaWdubWVudEV4cHJlc3Npb24sXG4gIGlzQ2FsbEV4cHJlc3Npb24sXG4gIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgaXNFeHByZXNzaW9uLFxuICBpc0lkZW50aWZpZXIsXG4gIGlzU2VxdWVuY2VFeHByZXNzaW9uLFxuICBpc1N1cGVyLFxuICB0aGlzRXhwcmVzc2lvblxufSA9IF90O1xuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKG5vZGVzXykge1xuICBfcmVtb3ZhbC5fYXNzZXJ0VW5yZW1vdmVkLmNhbGwodGhpcyk7XG4gIGNvbnN0IG5vZGVzID0gX3ZlcmlmeU5vZGVMaXN0LmNhbGwodGhpcywgbm9kZXNfKTtcbiAgY29uc3Qge1xuICAgIHBhcmVudFBhdGgsXG4gICAgcGFyZW50XG4gIH0gPSB0aGlzO1xuICBpZiAocGFyZW50UGF0aC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSB8fCBwYXJlbnRQYXRoLmlzTGFiZWxlZFN0YXRlbWVudCgpIHx8IGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihwYXJlbnQpIHx8IHBhcmVudFBhdGguaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24oKSAmJiB0aGlzLmlzRGVjbGFyYXRpb24oKSkge1xuICAgIHJldHVybiBwYXJlbnRQYXRoLmluc2VydEJlZm9yZShub2Rlcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc05vZGVUeXBlKFwiRXhwcmVzc2lvblwiKSAmJiAhdGhpcy5pc0pTWEVsZW1lbnQoKSB8fCBwYXJlbnRQYXRoLmlzRm9yU3RhdGVtZW50KCkgJiYgdGhpcy5rZXkgPT09IFwiaW5pdFwiKSB7XG4gICAgaWYgKHRoaXMubm9kZSkgbm9kZXMucHVzaCh0aGlzLm5vZGUpO1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VFeHByZXNzaW9uV2l0aFN0YXRlbWVudHMobm9kZXMpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgcmV0dXJuIF9jb250YWluZXJJbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBub2Rlcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlbWVudE9yQmxvY2soKSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0Q3VycmVudE5vZGUgPSBub2RlICYmICghdGhpcy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSB8fCBub2RlLmV4cHJlc3Npb24gIT0gbnVsbCk7XG4gICAgdGhpcy5yZXBsYWNlV2l0aChibG9ja1N0YXRlbWVudChzaG91bGRJbnNlcnRDdXJyZW50Tm9kZSA/IFtub2RlXSA6IFtdKSk7XG4gICAgcmV0dXJuIHRoaXMudW5zaGlmdENvbnRhaW5lcihcImJvZHlcIiwgbm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldlIGRvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIHRoaXMgbm9kZSB0eXBlLiBcIiArIFwiV2Ugd2VyZSBwcmV2aW91c2x5IGEgU3RhdGVtZW50IGJ1dCB3ZSBjYW4ndCBmaXQgaW4gaGVyZT9cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jb250YWluZXJJbnNlcnQoZnJvbSwgbm9kZXMpIHtcbiAgdXBkYXRlU2libGluZ0tleXMuY2FsbCh0aGlzLCBmcm9tLCBub2Rlcy5sZW5ndGgpO1xuICBjb25zdCBwYXRocyA9IFtdO1xuICB0aGlzLmNvbnRhaW5lci5zcGxpY2UoZnJvbSwgMCwgLi4ubm9kZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF90aGlzJGNvbnRleHQ7XG4gICAgY29uc3QgdG8gPSBmcm9tICsgaTtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5nZXRTaWJsaW5nKHRvKTtcbiAgICBwYXRocy5wdXNoKHBhdGgpO1xuICAgIGlmICgoX3RoaXMkY29udGV4dCA9IHRoaXMuY29udGV4dCkgIT0gbnVsbCAmJiBfdGhpcyRjb250ZXh0LnF1ZXVlKSB7XG4gICAgICBfY29udGV4dC5wdXNoQ29udGV4dC5jYWxsKHBhdGgsIHRoaXMuY29udGV4dCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnRleHRzID0gX2NvbnRleHQuX2dldFF1ZXVlQ29udGV4dHMuY2FsbCh0aGlzKTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgX2NvbnRleHQuc2V0U2NvcGUuY2FsbChwYXRoKTtcbiAgICBwYXRoLmRlYnVnKFwiSW5zZXJ0ZWQuXCIpO1xuICAgIGZvciAoY29uc3QgY29udGV4dCBvZiBjb250ZXh0cykge1xuICAgICAgY29udGV4dC5tYXliZVF1ZXVlKHBhdGgsIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGF0aHM7XG59XG5mdW5jdGlvbiBfY29udGFpbmVySW5zZXJ0QmVmb3JlKG5vZGVzKSB7XG4gIHJldHVybiBfY29udGFpbmVySW5zZXJ0LmNhbGwodGhpcywgdGhpcy5rZXksIG5vZGVzKTtcbn1cbmZ1bmN0aW9uIF9jb250YWluZXJJbnNlcnRBZnRlcihub2Rlcykge1xuICByZXR1cm4gX2NvbnRhaW5lckluc2VydC5jYWxsKHRoaXMsIHRoaXMua2V5ICsgMSwgbm9kZXMpO1xufVxuY29uc3QgbGFzdCA9IGFyciA9PiBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuZnVuY3Rpb24gaXNIaWRkZW5JblNlcXVlbmNlRXhwcmVzc2lvbihwYXRoKSB7XG4gIHJldHVybiBpc1NlcXVlbmNlRXhwcmVzc2lvbihwYXRoLnBhcmVudCkgJiYgKGxhc3QocGF0aC5wYXJlbnQuZXhwcmVzc2lvbnMpICE9PSBwYXRoLm5vZGUgfHwgaXNIaWRkZW5JblNlcXVlbmNlRXhwcmVzc2lvbihwYXRoLnBhcmVudFBhdGgpKTtcbn1cbmZ1bmN0aW9uIGlzQWxtb3N0Q29uc3RhbnRBc3NpZ25tZW50KG5vZGUsIHNjb3BlKSB7XG4gIGlmICghaXNBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB8fCAhaXNJZGVudGlmaWVyKG5vZGUubGVmdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmxvY2tTY29wZSA9IHNjb3BlLmdldEJsb2NrUGFyZW50KCk7XG4gIHJldHVybiBibG9ja1Njb3BlLmhhc093bkJpbmRpbmcobm9kZS5sZWZ0Lm5hbWUpICYmIGJsb2NrU2NvcGUuZ2V0T3duQmluZGluZyhub2RlLmxlZnQubmFtZSkuY29uc3RhbnRWaW9sYXRpb25zLmxlbmd0aCA8PSAxO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobm9kZXNfKSB7XG4gIF9yZW1vdmFsLl9hc3NlcnRVbnJlbW92ZWQuY2FsbCh0aGlzKTtcbiAgaWYgKHRoaXMuaXNTZXF1ZW5jZUV4cHJlc3Npb24oKSkge1xuICAgIHJldHVybiBsYXN0KHRoaXMuZ2V0KFwiZXhwcmVzc2lvbnNcIikpLmluc2VydEFmdGVyKG5vZGVzXyk7XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBfdmVyaWZ5Tm9kZUxpc3QuY2FsbCh0aGlzLCBub2Rlc18pO1xuICBjb25zdCB7XG4gICAgcGFyZW50UGF0aCxcbiAgICBwYXJlbnRcbiAgfSA9IHRoaXM7XG4gIGlmIChwYXJlbnRQYXRoLmlzRXhwcmVzc2lvblN0YXRlbWVudCgpIHx8IHBhcmVudFBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkgfHwgaXNFeHBvcnROYW1lZERlY2xhcmF0aW9uKHBhcmVudCkgfHwgcGFyZW50UGF0aC5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbigpICYmIHRoaXMuaXNEZWNsYXJhdGlvbigpKSB7XG4gICAgcmV0dXJuIHBhcmVudFBhdGguaW5zZXJ0QWZ0ZXIobm9kZXMubWFwKG5vZGUgPT4ge1xuICAgICAgcmV0dXJuIGlzRXhwcmVzc2lvbihub2RlKSA/IGV4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSkgOiBub2RlO1xuICAgIH0pKTtcbiAgfSBlbHNlIGlmICh0aGlzLmlzTm9kZVR5cGUoXCJFeHByZXNzaW9uXCIpICYmICF0aGlzLmlzSlNYRWxlbWVudCgpICYmICFwYXJlbnRQYXRoLmlzSlNYRWxlbWVudCgpIHx8IHBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoKSAmJiB0aGlzLmtleSA9PT0gXCJpbml0XCIpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5ub2RlKSB7XG4gICAgICBjb25zdCBub2RlID0gc2VsZi5ub2RlO1xuICAgICAgbGV0IHtcbiAgICAgICAgc2NvcGVcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgaWYgKHNjb3BlLnBhdGguaXNQYXR0ZXJuKCkpIHtcbiAgICAgICAgYXNzZXJ0RXhwcmVzc2lvbihub2RlKTtcbiAgICAgICAgc2VsZi5yZXBsYWNlV2l0aChjYWxsRXhwcmVzc2lvbihhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihbXSwgbm9kZSksIFtdKSk7XG4gICAgICAgIHNlbGYuZ2V0KFwiY2FsbGVlLmJvZHlcIikuaW5zZXJ0QWZ0ZXIobm9kZXMpO1xuICAgICAgICByZXR1cm4gW3NlbGZdO1xuICAgICAgfVxuICAgICAgaWYgKGlzSGlkZGVuSW5TZXF1ZW5jZUV4cHJlc3Npb24oc2VsZikpIHtcbiAgICAgICAgbm9kZXMudW5zaGlmdChub2RlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDYWxsRXhwcmVzc2lvbihub2RlKSAmJiBpc1N1cGVyKG5vZGUuY2FsbGVlKSkge1xuICAgICAgICBub2Rlcy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICBub2Rlcy5wdXNoKHRoaXNFeHByZXNzaW9uKCkpO1xuICAgICAgfSBlbHNlIGlmIChpc0FsbW9zdENvbnN0YW50QXNzaWdubWVudChub2RlLCBzY29wZSkpIHtcbiAgICAgICAgbm9kZXMudW5zaGlmdChub2RlKTtcbiAgICAgICAgbm9kZXMucHVzaChjbG9uZU5vZGUobm9kZS5sZWZ0KSk7XG4gICAgICB9IGVsc2UgaWYgKHNjb3BlLmlzUHVyZShub2RlLCB0cnVlKSkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmVudFBhdGguaXNNZXRob2Qoe1xuICAgICAgICAgIGNvbXB1dGVkOiB0cnVlLFxuICAgICAgICAgIGtleTogbm9kZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXAgPSBzY29wZS5nZW5lcmF0ZURlY2xhcmVkVWlkSWRlbnRpZmllcigpO1xuICAgICAgICBub2Rlcy51bnNoaWZ0KGV4cHJlc3Npb25TdGF0ZW1lbnQoYXNzaWdubWVudEV4cHJlc3Npb24oXCI9XCIsIGNsb25lTm9kZSh0ZW1wKSwgbm9kZSkpKTtcbiAgICAgICAgbm9kZXMucHVzaChleHByZXNzaW9uU3RhdGVtZW50KGNsb25lTm9kZSh0ZW1wKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKG5vZGVzKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29udGFpbmVyKSkge1xuICAgIHJldHVybiBfY29udGFpbmVySW5zZXJ0QWZ0ZXIuY2FsbCh0aGlzLCBub2Rlcyk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRlbWVudE9yQmxvY2soKSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgY29uc3Qgc2hvdWxkSW5zZXJ0Q3VycmVudE5vZGUgPSBub2RlICYmICghdGhpcy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSB8fCBub2RlLmV4cHJlc3Npb24gIT0gbnVsbCk7XG4gICAgdGhpcy5yZXBsYWNlV2l0aChibG9ja1N0YXRlbWVudChzaG91bGRJbnNlcnRDdXJyZW50Tm9kZSA/IFtub2RlXSA6IFtdKSk7XG4gICAgcmV0dXJuIHRoaXMucHVzaENvbnRhaW5lcihcImJvZHlcIiwgbm9kZXMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldlIGRvbid0IGtub3cgd2hhdCB0byBkbyB3aXRoIHRoaXMgbm9kZSB0eXBlLiBcIiArIFwiV2Ugd2VyZSBwcmV2aW91c2x5IGEgU3RhdGVtZW50IGJ1dCB3ZSBjYW4ndCBmaXQgaW4gaGVyZT9cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVNpYmxpbmdLZXlzKGZyb21JbmRleCwgaW5jcmVtZW50QnkpIHtcbiAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuO1xuICBjb25zdCBwYXRocyA9ICgwLCBfY2FjaGUuZ2V0Q2FjaGVkUGF0aHMpKHRoaXMuaHViLCB0aGlzLnBhcmVudCkgfHwgW107XG4gIGZvciAoY29uc3QgWywgcGF0aF0gb2YgcGF0aHMpIHtcbiAgICBpZiAodHlwZW9mIHBhdGgua2V5ID09PSBcIm51bWJlclwiICYmIHBhdGguY29udGFpbmVyID09PSB0aGlzLmNvbnRhaW5lciAmJiBwYXRoLmtleSA+PSBmcm9tSW5kZXgpIHtcbiAgICAgIHBhdGgua2V5ICs9IGluY3JlbWVudEJ5O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3ZlcmlmeU5vZGVMaXN0KG5vZGVzKSB7XG4gIGlmICghbm9kZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgIG5vZGVzID0gW25vZGVzXTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGxldCBtc2c7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICBtc2cgPSBcImhhcyBmYWxzeSBub2RlXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgbXNnID0gXCJjb250YWlucyBhIG5vbi1vYmplY3Qgbm9kZVwiO1xuICAgIH0gZWxzZSBpZiAoIW5vZGUudHlwZSkge1xuICAgICAgbXNnID0gXCJ3aXRob3V0IGEgdHlwZVwiO1xuICAgIH0gZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIF9pbmRleC5kZWZhdWx0KSB7XG4gICAgICBtc2cgPSBcImhhcyBhIE5vZGVQYXRoIHdoZW4gaXQgZXhwZWN0ZWQgYSByYXcgb2JqZWN0XCI7XG4gICAgfVxuICAgIGlmIChtc2cpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBBcnJheS5pc0FycmF5KG5vZGUpID8gXCJhcnJheVwiIDogdHlwZW9mIG5vZGU7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgbGlzdCAke21zZ30gd2l0aCB0aGUgaW5kZXggb2YgJHtpfSBhbmQgdHlwZSBvZiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIHVuc2hpZnRDb250YWluZXIobGlzdEtleSwgbm9kZXMpIHtcbiAgX3JlbW92YWwuX2Fzc2VydFVucmVtb3ZlZC5jYWxsKHRoaXMpO1xuICBub2RlcyA9IF92ZXJpZnlOb2RlTGlzdC5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgY29uc3QgcGF0aCA9IF9pbmRleC5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICBwYXJlbnQ6IHRoaXMubm9kZSxcbiAgICBjb250YWluZXI6IHRoaXMubm9kZVtsaXN0S2V5XSxcbiAgICBsaXN0S2V5LFxuICAgIGtleTogMFxuICB9KS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIHJldHVybiBfY29udGFpbmVySW5zZXJ0QmVmb3JlLmNhbGwocGF0aCwgbm9kZXMpO1xufVxuZnVuY3Rpb24gcHVzaENvbnRhaW5lcihsaXN0S2V5LCBub2Rlcykge1xuICBfcmVtb3ZhbC5fYXNzZXJ0VW5yZW1vdmVkLmNhbGwodGhpcyk7XG4gIGNvbnN0IHZlcmlmaWVkTm9kZXMgPSBfdmVyaWZ5Tm9kZUxpc3QuY2FsbCh0aGlzLCBub2Rlcyk7XG4gIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMubm9kZVtsaXN0S2V5XTtcbiAgY29uc3QgcGF0aCA9IF9pbmRleC5kZWZhdWx0LmdldCh7XG4gICAgcGFyZW50UGF0aDogdGhpcyxcbiAgICBwYXJlbnQ6IHRoaXMubm9kZSxcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBsaXN0S2V5LFxuICAgIGtleTogY29udGFpbmVyLmxlbmd0aFxuICB9KS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gIHJldHVybiBwYXRoLnJlcGxhY2VXaXRoTXVsdGlwbGUodmVyaWZpZWROb2Rlcyk7XG59XG57XG4gIGV4cG9ydHMuaG9pc3QgPSBmdW5jdGlvbiBob2lzdChzY29wZSA9IHRoaXMuc2NvcGUpIHtcbiAgICBjb25zdCBob2lzdGVyID0gbmV3IF9ob2lzdGVyLmRlZmF1bHQodGhpcywgc2NvcGUpO1xuICAgIHJldHVybiBob2lzdGVyLnJ1bigpO1xuICB9O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RpZmljYXRpb24uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58345\n')},53097:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._assertUnremoved = _assertUnremoved;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._markRemoved = _markRemoved;\nexports._remove = _remove;\nexports._removeFromScope = _removeFromScope;\nexports.remove = remove;\nvar _removalHooks = __webpack_require__(77860);\nvar _cache = __webpack_require__(37411);\nvar _replacement = __webpack_require__(22037);\nvar _index = __webpack_require__(29709);\nvar _t = __webpack_require__(2352);\nvar _modification = __webpack_require__(58345);\nvar _context = __webpack_require__(79578);\nconst {\n  getBindingIdentifiers\n} = _t;\nfunction remove() {\n  var _this$opts;\n  _assertUnremoved.call(this);\n  _context.resync.call(this);\n  if (_callRemovalHooks.call(this)) {\n    _markRemoved.call(this);\n    return;\n  }\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    _removeFromScope.call(this);\n  }\n  this.shareCommentsWithSiblings();\n  _remove.call(this);\n  _markRemoved.call(this);\n}\nfunction _removeFromScope() {\n  const bindings = getBindingIdentifiers(this.node, false, false, true);\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\nfunction _callRemovalHooks() {\n  if (this.parentPath) {\n    for (const fn of _removalHooks.hooks) {\n      if (fn(this, this.parentPath)) return true;\n    }\n  }\n}\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    _modification.updateSiblingKeys.call(this, this.key, -1);\n  } else {\n    _replacement._replaceWith.call(this, null);\n  }\n}\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) {\n    (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);\n  }\n  this.node = null;\n}\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError("NodePath has been removed so is read-only.");\n  }\n}\n\n//# sourceMappingURL=removal.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMwOTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2Qsb0JBQW9CLG1CQUFPLENBQUMsS0FBd0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLEtBQWE7QUFDbEMsbUJBQW1CLG1CQUFPLENBQUMsS0FBa0I7QUFDN0MsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0Isb0JBQW9CLG1CQUFPLENBQUMsS0FBbUI7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3BhdGgvcmVtb3ZhbC5qcz8zODBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fYXNzZXJ0VW5yZW1vdmVkID0gX2Fzc2VydFVucmVtb3ZlZDtcbmV4cG9ydHMuX2NhbGxSZW1vdmFsSG9va3MgPSBfY2FsbFJlbW92YWxIb29rcztcbmV4cG9ydHMuX21hcmtSZW1vdmVkID0gX21hcmtSZW1vdmVkO1xuZXhwb3J0cy5fcmVtb3ZlID0gX3JlbW92ZTtcbmV4cG9ydHMuX3JlbW92ZUZyb21TY29wZSA9IF9yZW1vdmVGcm9tU2NvcGU7XG5leHBvcnRzLnJlbW92ZSA9IHJlbW92ZTtcbnZhciBfcmVtb3ZhbEhvb2tzID0gcmVxdWlyZShcIi4vbGliL3JlbW92YWwtaG9va3MuanNcIik7XG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xudmFyIF9yZXBsYWNlbWVudCA9IHJlcXVpcmUoXCIuL3JlcGxhY2VtZW50LmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfbW9kaWZpY2F0aW9uID0gcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9uLmpzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vY29udGV4dC5qc1wiKTtcbmNvbnN0IHtcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzXG59ID0gX3Q7XG5mdW5jdGlvbiByZW1vdmUoKSB7XG4gIHZhciBfdGhpcyRvcHRzO1xuICBfYXNzZXJ0VW5yZW1vdmVkLmNhbGwodGhpcyk7XG4gIF9jb250ZXh0LnJlc3luYy5jYWxsKHRoaXMpO1xuICBpZiAoX2NhbGxSZW1vdmFsSG9va3MuY2FsbCh0aGlzKSkge1xuICAgIF9tYXJrUmVtb3ZlZC5jYWxsKHRoaXMpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgoX3RoaXMkb3B0cyA9IHRoaXMub3B0cykgIT0gbnVsbCAmJiBfdGhpcyRvcHRzLm5vU2NvcGUpKSB7XG4gICAgX3JlbW92ZUZyb21TY29wZS5jYWxsKHRoaXMpO1xuICB9XG4gIHRoaXMuc2hhcmVDb21tZW50c1dpdGhTaWJsaW5ncygpO1xuICBfcmVtb3ZlLmNhbGwodGhpcyk7XG4gIF9tYXJrUmVtb3ZlZC5jYWxsKHRoaXMpO1xufVxuZnVuY3Rpb24gX3JlbW92ZUZyb21TY29wZSgpIHtcbiAgY29uc3QgYmluZGluZ3MgPSBnZXRCaW5kaW5nSWRlbnRpZmllcnModGhpcy5ub2RlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICBPYmplY3Qua2V5cyhiaW5kaW5ncykuZm9yRWFjaChuYW1lID0+IHRoaXMuc2NvcGUucmVtb3ZlQmluZGluZyhuYW1lKSk7XG59XG5mdW5jdGlvbiBfY2FsbFJlbW92YWxIb29rcygpIHtcbiAgaWYgKHRoaXMucGFyZW50UGF0aCkge1xuICAgIGZvciAoY29uc3QgZm4gb2YgX3JlbW92YWxIb29rcy5ob29rcykge1xuICAgICAgaWYgKGZuKHRoaXMsIHRoaXMucGFyZW50UGF0aCkpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3JlbW92ZSgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgdGhpcy5jb250YWluZXIuc3BsaWNlKHRoaXMua2V5LCAxKTtcbiAgICBfbW9kaWZpY2F0aW9uLnVwZGF0ZVNpYmxpbmdLZXlzLmNhbGwodGhpcywgdGhpcy5rZXksIC0xKTtcbiAgfSBlbHNlIHtcbiAgICBfcmVwbGFjZW1lbnQuX3JlcGxhY2VXaXRoLmNhbGwodGhpcywgbnVsbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9tYXJrUmVtb3ZlZCgpIHtcbiAgdGhpcy5fdHJhdmVyc2VGbGFncyB8PSBfaW5kZXguU0hPVUxEX1NLSVAgfCBfaW5kZXguUkVNT1ZFRDtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgKDAsIF9jYWNoZS5nZXRDYWNoZWRQYXRocykodGhpcy5odWIsIHRoaXMucGFyZW50KS5kZWxldGUodGhpcy5ub2RlKTtcbiAgfVxuICB0aGlzLm5vZGUgPSBudWxsO1xufVxuZnVuY3Rpb24gX2Fzc2VydFVucmVtb3ZlZCgpIHtcbiAgaWYgKHRoaXMucmVtb3ZlZCkge1xuICAgIHRocm93IHRoaXMuYnVpbGRDb2RlRnJhbWVFcnJvcihcIk5vZGVQYXRoIGhhcyBiZWVuIHJlbW92ZWQgc28gaXMgcmVhZC1vbmx5LlwiKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmFsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53097\n')},22037:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nvar _codeFrame = __webpack_require__(62882);\nvar _index = __webpack_require__(25781);\nvar _index2 = __webpack_require__(29709);\nvar _cache = __webpack_require__(37411);\nvar _modification = __webpack_require__(58345);\nvar _parser = __webpack_require__(22172);\nvar _t = __webpack_require__(2352);\nvar _context = __webpack_require__(79578);\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  buildUndefinedNode,\n  callExpression,\n  cloneNode,\n  conditionalExpression,\n  expressionStatement,\n  getBindingIdentifiers,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isBlockStatement,\n  isEmptyStatement,\n  isExpression,\n  isExpressionStatement,\n  isIfStatement,\n  isProgram,\n  isStatement,\n  isVariableDeclaration,\n  removeComments,\n  returnStatement,\n  sequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\nfunction replaceWithMultiple(nodes) {\n  var _getCachedPaths;\n  _context.resync.call(this);\n  nodes = _modification._verifyNodeList.call(this, nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n  return paths;\n}\nfunction replaceWithSourceString(replacement) {\n  _context.resync.call(this);\n  let ast;\n  try {\n    replacement = `(${replacement})`;\n    ast = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += " - make sure this is an expression.\\n" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = "BABEL_REPLACE_SOURCE_ERROR";\n    }\n    throw err;\n  }\n  const expressionAST = ast.program.body[0].expression;\n  _index.default.removeProperties(expressionAST);\n  return this.replaceWith(expressionAST);\n}\nfunction replaceWith(replacementPath) {\n  _context.resync.call(this);\n  if (this.removed) {\n    throw new Error("You can\'t replace this node, we\'ve already removed it");\n  }\n  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;\n  if (!replacement) {\n    throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");\n  }\n  if (this.node === replacement) {\n    return [this];\n  }\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error("You can only replace a Program root node with another Program node");\n  }\n  if (Array.isArray(replacement)) {\n    throw new Error("Don\'t use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");\n  }\n  if (typeof replacement === "string") {\n    throw new Error("Don\'t use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");\n  }\n  let nodePath = "";\n  if (this.isNodeType("Statement") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = "expression";\n    }\n  }\n  if (this.isNodeType("Expression") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n  const oldNode = this.node;\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n  _replaceWith.call(this, replacement);\n  this.type = replacement.type;\n  _context.setScope.call(this);\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\nfunction _replaceWith(node) {\n  var _getCachedPaths2;\n  if (!this.container) {\n    throw new ReferenceError("Container is falsy");\n  }\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\nfunction replaceExpressionWithStatements(nodes) {\n  _context.resync.call(this);\n  const declars = [];\n  const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);\n  if (nodesAsSingleExpression) {\n    for (const id of declars) this.scope.push({\n      id\n    });\n    return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");\n  }\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get("callee");\n  callee.get("body").scope.hoistVariables(id => this.scope.push({\n    id\n  }));\n  const completionRecords = callee.getCompletionRecords();\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n    if (loop) {\n      let uid = loop.getData("expressionReplacementReturnUid");\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier("ret");\n        callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));\n        loop.setData("expressionReplacementReturnUid", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n      path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);\n  if (needToAwaitFunction) {\n    newCallee.set("async", true);\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n  if (needToYieldFunction) {\n    newCallee.set("generator", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n  return newCallee.get("body.body");\n}\nfunction gatherSequenceExpressions(nodes, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!isEmptyStatement(node)) {\n      ensureLastUndefined = false;\n    }\n    if (isExpression(node)) {\n      exprs.push(node);\n    } else if (isExpressionStatement(node)) {\n      exprs.push(node.expression);\n    } else if (isVariableDeclaration(node)) {\n      if (node.kind !== "var") return;\n      for (const declar of node.declarations) {\n        const bindings = getBindingIdentifiers(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push(cloneNode(bindings[key]));\n        }\n        if (declar.init) {\n          exprs.push(assignmentExpression("=", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if (isIfStatement(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : buildUndefinedNode();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : buildUndefinedNode();\n      if (!consequent || !alternate) return;\n      exprs.push(conditionalExpression(node.test, consequent, alternate));\n    } else if (isBlockStatement(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if (isEmptyStatement(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) exprs.push(buildUndefinedNode());\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return sequenceExpression(exprs);\n  }\n}\nfunction replaceInline(nodes) {\n  _context.resync.call(this);\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = _modification._verifyNodeList.call(this, nodes);\n      const paths = _modification._containerInsertAfter.call(this, nodes);\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}\n\n//# sourceMappingURL=replacement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIwMzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLHVDQUF1QztBQUN2QyxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsS0FBbUI7QUFDNUMsYUFBYSxtQkFBTyxDQUFDLEtBQWE7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLEtBQVk7QUFDbEMsYUFBYSxtQkFBTyxDQUFDLEtBQWE7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsS0FBbUI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLEtBQWU7QUFDckMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvcGF0aC9yZXBsYWNlbWVudC5qcz81YWUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5fcmVwbGFjZVdpdGggPSBfcmVwbGFjZVdpdGg7XG5leHBvcnRzLnJlcGxhY2VFeHByZXNzaW9uV2l0aFN0YXRlbWVudHMgPSByZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzO1xuZXhwb3J0cy5yZXBsYWNlSW5saW5lID0gcmVwbGFjZUlubGluZTtcbmV4cG9ydHMucmVwbGFjZVdpdGggPSByZXBsYWNlV2l0aDtcbmV4cG9ydHMucmVwbGFjZVdpdGhNdWx0aXBsZSA9IHJlcGxhY2VXaXRoTXVsdGlwbGU7XG5leHBvcnRzLnJlcGxhY2VXaXRoU291cmNlU3RyaW5nID0gcmVwbGFjZVdpdGhTb3VyY2VTdHJpbmc7XG52YXIgX2NvZGVGcmFtZSA9IHJlcXVpcmUoXCJAYmFiZWwvY29kZS1mcmFtZVwiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuL2luZGV4LmpzXCIpO1xudmFyIF9jYWNoZSA9IHJlcXVpcmUoXCIuLi9jYWNoZS5qc1wiKTtcbnZhciBfbW9kaWZpY2F0aW9uID0gcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9uLmpzXCIpO1xudmFyIF9wYXJzZXIgPSByZXF1aXJlKFwiQGJhYmVsL3BhcnNlclwiKTtcbnZhciBfdCA9IHJlcXVpcmUoXCJAYmFiZWwvdHlwZXNcIik7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xuY29uc3Qge1xuICBGVU5DVElPTl9UWVBFUyxcbiAgYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24sXG4gIGFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICBhd2FpdEV4cHJlc3Npb24sXG4gIGJsb2NrU3RhdGVtZW50LFxuICBidWlsZFVuZGVmaW5lZE5vZGUsXG4gIGNhbGxFeHByZXNzaW9uLFxuICBjbG9uZU5vZGUsXG4gIGNvbmRpdGlvbmFsRXhwcmVzc2lvbixcbiAgZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgZ2V0QmluZGluZ0lkZW50aWZpZXJzLFxuICBpZGVudGlmaWVyLFxuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzLFxuICBpbmhlcml0VHJhaWxpbmdDb21tZW50cyxcbiAgaW5oZXJpdHNDb21tZW50cyxcbiAgaXNCbG9ja1N0YXRlbWVudCxcbiAgaXNFbXB0eVN0YXRlbWVudCxcbiAgaXNFeHByZXNzaW9uLFxuICBpc0V4cHJlc3Npb25TdGF0ZW1lbnQsXG4gIGlzSWZTdGF0ZW1lbnQsXG4gIGlzUHJvZ3JhbSxcbiAgaXNTdGF0ZW1lbnQsXG4gIGlzVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgcmVtb3ZlQ29tbWVudHMsXG4gIHJldHVyblN0YXRlbWVudCxcbiAgc2VxdWVuY2VFeHByZXNzaW9uLFxuICB2YWxpZGF0ZSxcbiAgeWllbGRFeHByZXNzaW9uXG59ID0gX3Q7XG5mdW5jdGlvbiByZXBsYWNlV2l0aE11bHRpcGxlKG5vZGVzKSB7XG4gIHZhciBfZ2V0Q2FjaGVkUGF0aHM7XG4gIF9jb250ZXh0LnJlc3luYy5jYWxsKHRoaXMpO1xuICBub2RlcyA9IF9tb2RpZmljYXRpb24uX3ZlcmlmeU5vZGVMaXN0LmNhbGwodGhpcywgbm9kZXMpO1xuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzKG5vZGVzWzBdLCB0aGlzLm5vZGUpO1xuICBpbmhlcml0VHJhaWxpbmdDb21tZW50cyhub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSwgdGhpcy5ub2RlKTtcbiAgKF9nZXRDYWNoZWRQYXRocyA9ICgwLCBfY2FjaGUuZ2V0Q2FjaGVkUGF0aHMpKHRoaXMuaHViLCB0aGlzLnBhcmVudCkpID09IG51bGwgfHwgX2dldENhY2hlZFBhdGhzLmRlbGV0ZSh0aGlzLm5vZGUpO1xuICB0aGlzLm5vZGUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0gPSBudWxsO1xuICBjb25zdCBwYXRocyA9IHRoaXMuaW5zZXJ0QWZ0ZXIobm9kZXMpO1xuICBpZiAodGhpcy5ub2RlKSB7XG4gICAgdGhpcy5yZXF1ZXVlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgfVxuICByZXR1cm4gcGF0aHM7XG59XG5mdW5jdGlvbiByZXBsYWNlV2l0aFNvdXJjZVN0cmluZyhyZXBsYWNlbWVudCkge1xuICBfY29udGV4dC5yZXN5bmMuY2FsbCh0aGlzKTtcbiAgbGV0IGFzdDtcbiAgdHJ5IHtcbiAgICByZXBsYWNlbWVudCA9IGAoJHtyZXBsYWNlbWVudH0pYDtcbiAgICBhc3QgPSAoMCwgX3BhcnNlci5wYXJzZSkocmVwbGFjZW1lbnQpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zdCBsb2MgPSBlcnIubG9jO1xuICAgIGlmIChsb2MpIHtcbiAgICAgIGVyci5tZXNzYWdlICs9IFwiIC0gbWFrZSBzdXJlIHRoaXMgaXMgYW4gZXhwcmVzc2lvbi5cXG5cIiArICgwLCBfY29kZUZyYW1lLmNvZGVGcmFtZUNvbHVtbnMpKHJlcGxhY2VtZW50LCB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgbGluZTogbG9jLmxpbmUsXG4gICAgICAgICAgY29sdW1uOiBsb2MuY29sdW1uICsgMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGVyci5jb2RlID0gXCJCQUJFTF9SRVBMQUNFX1NPVVJDRV9FUlJPUlwiO1xuICAgIH1cbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgY29uc3QgZXhwcmVzc2lvbkFTVCA9IGFzdC5wcm9ncmFtLmJvZHlbMF0uZXhwcmVzc2lvbjtcbiAgX2luZGV4LmRlZmF1bHQucmVtb3ZlUHJvcGVydGllcyhleHByZXNzaW9uQVNUKTtcbiAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgoZXhwcmVzc2lvbkFTVCk7XG59XG5mdW5jdGlvbiByZXBsYWNlV2l0aChyZXBsYWNlbWVudFBhdGgpIHtcbiAgX2NvbnRleHQucmVzeW5jLmNhbGwodGhpcyk7XG4gIGlmICh0aGlzLnJlbW92ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgY2FuJ3QgcmVwbGFjZSB0aGlzIG5vZGUsIHdlJ3ZlIGFscmVhZHkgcmVtb3ZlZCBpdFwiKTtcbiAgfVxuICBsZXQgcmVwbGFjZW1lbnQgPSByZXBsYWNlbWVudFBhdGggaW5zdGFuY2VvZiBfaW5kZXgyLmRlZmF1bHQgPyByZXBsYWNlbWVudFBhdGgubm9kZSA6IHJlcGxhY2VtZW50UGF0aDtcbiAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBwYXNzZWQgYHBhdGgucmVwbGFjZVdpdGgoKWAgYSBmYWxzeSBub2RlLCB1c2UgYHBhdGgucmVtb3ZlKClgIGluc3RlYWRcIik7XG4gIH1cbiAgaWYgKHRoaXMubm9kZSA9PT0gcmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gW3RoaXNdO1xuICB9XG4gIGlmICh0aGlzLmlzUHJvZ3JhbSgpICYmICFpc1Byb2dyYW0ocmVwbGFjZW1lbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbiBvbmx5IHJlcGxhY2UgYSBQcm9ncmFtIHJvb3Qgbm9kZSB3aXRoIGFub3RoZXIgUHJvZ3JhbSBub2RlXCIpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VtZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkRvbid0IHVzZSBgcGF0aC5yZXBsYWNlV2l0aCgpYCB3aXRoIGFuIGFycmF5IG9mIG5vZGVzLCB1c2UgYHBhdGgucmVwbGFjZVdpdGhNdWx0aXBsZSgpYFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIHJlcGxhY2VtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRG9uJ3QgdXNlIGBwYXRoLnJlcGxhY2VXaXRoKClgIHdpdGggYSBzb3VyY2Ugc3RyaW5nLCB1c2UgYHBhdGgucmVwbGFjZVdpdGhTb3VyY2VTdHJpbmcoKWBcIik7XG4gIH1cbiAgbGV0IG5vZGVQYXRoID0gXCJcIjtcbiAgaWYgKHRoaXMuaXNOb2RlVHlwZShcIlN0YXRlbWVudFwiKSAmJiBpc0V4cHJlc3Npb24ocmVwbGFjZW1lbnQpKSB7XG4gICAgaWYgKCF0aGlzLmNhbkhhdmVWYXJpYWJsZURlY2xhcmF0aW9uT3JFeHByZXNzaW9uKCkgJiYgIXRoaXMuY2FuU3dhcEJldHdlZW5FeHByZXNzaW9uQW5kU3RhdGVtZW50KHJlcGxhY2VtZW50KSAmJiAhdGhpcy5wYXJlbnRQYXRoLmlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHJlcGxhY2VtZW50ID0gZXhwcmVzc2lvblN0YXRlbWVudChyZXBsYWNlbWVudCk7XG4gICAgICBub2RlUGF0aCA9IFwiZXhwcmVzc2lvblwiO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5pc05vZGVUeXBlKFwiRXhwcmVzc2lvblwiKSAmJiBpc1N0YXRlbWVudChyZXBsYWNlbWVudCkpIHtcbiAgICBpZiAoIXRoaXMuY2FuSGF2ZVZhcmlhYmxlRGVjbGFyYXRpb25PckV4cHJlc3Npb24oKSAmJiAhdGhpcy5jYW5Td2FwQmV0d2VlbkV4cHJlc3Npb25BbmRTdGF0ZW1lbnQocmVwbGFjZW1lbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlRXhwcmVzc2lvbldpdGhTdGF0ZW1lbnRzKFtyZXBsYWNlbWVudF0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBvbGROb2RlID0gdGhpcy5ub2RlO1xuICBpZiAob2xkTm9kZSkge1xuICAgIGluaGVyaXRzQ29tbWVudHMocmVwbGFjZW1lbnQsIG9sZE5vZGUpO1xuICAgIHJlbW92ZUNvbW1lbnRzKG9sZE5vZGUpO1xuICB9XG4gIF9yZXBsYWNlV2l0aC5jYWxsKHRoaXMsIHJlcGxhY2VtZW50KTtcbiAgdGhpcy50eXBlID0gcmVwbGFjZW1lbnQudHlwZTtcbiAgX2NvbnRleHQuc2V0U2NvcGUuY2FsbCh0aGlzKTtcbiAgdGhpcy5yZXF1ZXVlKCk7XG4gIHJldHVybiBbbm9kZVBhdGggPyB0aGlzLmdldChub2RlUGF0aCkgOiB0aGlzXTtcbn1cbmZ1bmN0aW9uIF9yZXBsYWNlV2l0aChub2RlKSB7XG4gIHZhciBfZ2V0Q2FjaGVkUGF0aHMyO1xuICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiQ29udGFpbmVyIGlzIGZhbHN5XCIpO1xuICB9XG4gIGlmICh0aGlzLmluTGlzdCkge1xuICAgIHZhbGlkYXRlKHRoaXMucGFyZW50LCB0aGlzLmtleSwgW25vZGVdKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZSh0aGlzLnBhcmVudCwgdGhpcy5rZXksIG5vZGUpO1xuICB9XG4gIHRoaXMuZGVidWcoYFJlcGxhY2Ugd2l0aCAke25vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudHlwZX1gKTtcbiAgKF9nZXRDYWNoZWRQYXRoczIgPSAoMCwgX2NhY2hlLmdldENhY2hlZFBhdGhzKSh0aGlzLmh1YiwgdGhpcy5wYXJlbnQpKSA9PSBudWxsIHx8IF9nZXRDYWNoZWRQYXRoczIuc2V0KG5vZGUsIHRoaXMpLmRlbGV0ZSh0aGlzLm5vZGUpO1xuICB0aGlzLm5vZGUgPSB0aGlzLmNvbnRhaW5lclt0aGlzLmtleV0gPSBub2RlO1xufVxuZnVuY3Rpb24gcmVwbGFjZUV4cHJlc3Npb25XaXRoU3RhdGVtZW50cyhub2Rlcykge1xuICBfY29udGV4dC5yZXN5bmMuY2FsbCh0aGlzKTtcbiAgY29uc3QgZGVjbGFycyA9IFtdO1xuICBjb25zdCBub2Rlc0FzU2luZ2xlRXhwcmVzc2lvbiA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZXMsIGRlY2xhcnMpO1xuICBpZiAobm9kZXNBc1NpbmdsZUV4cHJlc3Npb24pIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGRlY2xhcnMpIHRoaXMuc2NvcGUucHVzaCh7XG4gICAgICBpZFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKG5vZGVzQXNTaW5nbGVFeHByZXNzaW9uKVswXS5nZXQoXCJleHByZXNzaW9uc1wiKTtcbiAgfVxuICBjb25zdCBmdW5jdGlvblBhcmVudCA9IHRoaXMuZ2V0RnVuY3Rpb25QYXJlbnQoKTtcbiAgY29uc3QgaXNQYXJlbnRBc3luYyA9IGZ1bmN0aW9uUGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBmdW5jdGlvblBhcmVudC5ub2RlLmFzeW5jO1xuICBjb25zdCBpc1BhcmVudEdlbmVyYXRvciA9IGZ1bmN0aW9uUGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBmdW5jdGlvblBhcmVudC5ub2RlLmdlbmVyYXRvcjtcbiAgY29uc3QgY29udGFpbmVyID0gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oW10sIGJsb2NrU3RhdGVtZW50KG5vZGVzKSk7XG4gIHRoaXMucmVwbGFjZVdpdGgoY2FsbEV4cHJlc3Npb24oY29udGFpbmVyLCBbXSkpO1xuICBjb25zdCBjYWxsZWUgPSB0aGlzLmdldChcImNhbGxlZVwiKTtcbiAgY2FsbGVlLmdldChcImJvZHlcIikuc2NvcGUuaG9pc3RWYXJpYWJsZXMoaWQgPT4gdGhpcy5zY29wZS5wdXNoKHtcbiAgICBpZFxuICB9KSk7XG4gIGNvbnN0IGNvbXBsZXRpb25SZWNvcmRzID0gY2FsbGVlLmdldENvbXBsZXRpb25SZWNvcmRzKCk7XG4gIGZvciAoY29uc3QgcGF0aCBvZiBjb21wbGV0aW9uUmVjb3Jkcykge1xuICAgIGlmICghcGF0aC5pc0V4cHJlc3Npb25TdGF0ZW1lbnQoKSkgY29udGludWU7XG4gICAgY29uc3QgbG9vcCA9IHBhdGguZmluZFBhcmVudChwYXRoID0+IHBhdGguaXNMb29wKCkpO1xuICAgIGlmIChsb29wKSB7XG4gICAgICBsZXQgdWlkID0gbG9vcC5nZXREYXRhKFwiZXhwcmVzc2lvblJlcGxhY2VtZW50UmV0dXJuVWlkXCIpO1xuICAgICAgaWYgKCF1aWQpIHtcbiAgICAgICAgdWlkID0gY2FsbGVlLnNjb3BlLmdlbmVyYXRlRGVjbGFyZWRVaWRJZGVudGlmaWVyKFwicmV0XCIpO1xuICAgICAgICBjYWxsZWUuZ2V0KFwiYm9keVwiKS5wdXNoQ29udGFpbmVyKFwiYm9keVwiLCByZXR1cm5TdGF0ZW1lbnQoY2xvbmVOb2RlKHVpZCkpKTtcbiAgICAgICAgbG9vcC5zZXREYXRhKFwiZXhwcmVzc2lvblJlcGxhY2VtZW50UmV0dXJuVWlkXCIsIHVpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1aWQgPSBpZGVudGlmaWVyKHVpZC5uYW1lKTtcbiAgICAgIH1cbiAgICAgIHBhdGguZ2V0KFwiZXhwcmVzc2lvblwiKS5yZXBsYWNlV2l0aChhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgY2xvbmVOb2RlKHVpZCksIHBhdGgubm9kZS5leHByZXNzaW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGgucmVwbGFjZVdpdGgocmV0dXJuU3RhdGVtZW50KHBhdGgubm9kZS5leHByZXNzaW9uKSk7XG4gICAgfVxuICB9XG4gIGNhbGxlZS5hcnJvd0Z1bmN0aW9uVG9FeHByZXNzaW9uKCk7XG4gIGNvbnN0IG5ld0NhbGxlZSA9IGNhbGxlZTtcbiAgY29uc3QgbmVlZFRvQXdhaXRGdW5jdGlvbiA9IGlzUGFyZW50QXN5bmMgJiYgX2luZGV4LmRlZmF1bHQuaGFzVHlwZSh0aGlzLmdldChcImNhbGxlZS5ib2R5XCIpLm5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIsIEZVTkNUSU9OX1RZUEVTKTtcbiAgY29uc3QgbmVlZFRvWWllbGRGdW5jdGlvbiA9IGlzUGFyZW50R2VuZXJhdG9yICYmIF9pbmRleC5kZWZhdWx0Lmhhc1R5cGUodGhpcy5nZXQoXCJjYWxsZWUuYm9keVwiKS5ub2RlLCBcIllpZWxkRXhwcmVzc2lvblwiLCBGVU5DVElPTl9UWVBFUyk7XG4gIGlmIChuZWVkVG9Bd2FpdEZ1bmN0aW9uKSB7XG4gICAgbmV3Q2FsbGVlLnNldChcImFzeW5jXCIsIHRydWUpO1xuICAgIGlmICghbmVlZFRvWWllbGRGdW5jdGlvbikge1xuICAgICAgdGhpcy5yZXBsYWNlV2l0aChhd2FpdEV4cHJlc3Npb24odGhpcy5ub2RlKSk7XG4gICAgfVxuICB9XG4gIGlmIChuZWVkVG9ZaWVsZEZ1bmN0aW9uKSB7XG4gICAgbmV3Q2FsbGVlLnNldChcImdlbmVyYXRvclwiLCB0cnVlKTtcbiAgICB0aGlzLnJlcGxhY2VXaXRoKHlpZWxkRXhwcmVzc2lvbih0aGlzLm5vZGUsIHRydWUpKTtcbiAgfVxuICByZXR1cm4gbmV3Q2FsbGVlLmdldChcImJvZHkuYm9keVwiKTtcbn1cbmZ1bmN0aW9uIGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZXMsIGRlY2xhcnMpIHtcbiAgY29uc3QgZXhwcnMgPSBbXTtcbiAgbGV0IGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBpZiAoIWlzRW1wdHlTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlKTtcbiAgICB9IGVsc2UgaWYgKGlzRXhwcmVzc2lvblN0YXRlbWVudChub2RlKSkge1xuICAgICAgZXhwcnMucHVzaChub2RlLmV4cHJlc3Npb24pO1xuICAgIH0gZWxzZSBpZiAoaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZS5raW5kICE9PSBcInZhclwiKSByZXR1cm47XG4gICAgICBmb3IgKGNvbnN0IGRlY2xhciBvZiBub2RlLmRlY2xhcmF0aW9ucykge1xuICAgICAgICBjb25zdCBiaW5kaW5ncyA9IGdldEJpbmRpbmdJZGVudGlmaWVycyhkZWNsYXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhiaW5kaW5ncykpIHtcbiAgICAgICAgICBkZWNsYXJzLnB1c2goY2xvbmVOb2RlKGJpbmRpbmdzW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjbGFyLmluaXQpIHtcbiAgICAgICAgICBleHBycy5wdXNoKGFzc2lnbm1lbnRFeHByZXNzaW9uKFwiPVwiLCBkZWNsYXIuaWQsIGRlY2xhci5pbml0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNJZlN0YXRlbWVudChub2RlKSkge1xuICAgICAgY29uc3QgY29uc2VxdWVudCA9IG5vZGUuY29uc2VxdWVudCA/IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMoW25vZGUuY29uc2VxdWVudF0sIGRlY2xhcnMpIDogYnVpbGRVbmRlZmluZWROb2RlKCk7XG4gICAgICBjb25zdCBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZSA/IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMoW25vZGUuYWx0ZXJuYXRlXSwgZGVjbGFycykgOiBidWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgICAgIGlmICghY29uc2VxdWVudCB8fCAhYWx0ZXJuYXRlKSByZXR1cm47XG4gICAgICBleHBycy5wdXNoKGNvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLnRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9ja1N0YXRlbWVudChub2RlKSkge1xuICAgICAgY29uc3QgYm9keSA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZS5ib2R5LCBkZWNsYXJzKTtcbiAgICAgIGlmICghYm9keSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaChib2R5KTtcbiAgICB9IGVsc2UgaWYgKGlzRW1wdHlTdGF0ZW1lbnQobm9kZSkpIHtcbiAgICAgIGlmIChub2Rlcy5pbmRleE9mKG5vZGUpID09PSAwKSB7XG4gICAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChlbnN1cmVMYXN0VW5kZWZpbmVkKSBleHBycy5wdXNoKGJ1aWxkVW5kZWZpbmVkTm9kZSgpKTtcbiAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBleHByc1swXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2VxdWVuY2VFeHByZXNzaW9uKGV4cHJzKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVwbGFjZUlubGluZShub2Rlcykge1xuICBfY29udGV4dC5yZXN5bmMuY2FsbCh0aGlzKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb250YWluZXIpKSB7XG4gICAgICBub2RlcyA9IF9tb2RpZmljYXRpb24uX3ZlcmlmeU5vZGVMaXN0LmNhbGwodGhpcywgbm9kZXMpO1xuICAgICAgY29uc3QgcGF0aHMgPSBfbW9kaWZpY2F0aW9uLl9jb250YWluZXJJbnNlcnRBZnRlci5jYWxsKHRoaXMsIG5vZGVzKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gcGF0aHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoTXVsdGlwbGUobm9kZXMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlV2l0aChub2Rlcyk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwbGFjZW1lbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22037\n')},33599:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path)) {\n      this.reassign(path);\n    }\n    this.clearValue();\n  }\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n  reassign(path) {\n    this.constant = false;\n    if (this.constantViolations.includes(path)) {\n      return;\n    }\n    this.constantViolations.push(path);\n  }\n  reference(path) {\n    if (this.referencePaths.includes(path)) {\n      return;\n    }\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n}\nexports["default"] = Binding;\nfunction isDeclaredInLoop(path) {\n  for (let {\n    parentPath,\n    key\n  } = path; parentPath; ({\n    parentPath,\n    key\n  } = parentPath)) {\n    if (parentPath.isFunctionParent()) return false;\n    if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {\n      return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=binding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM1OTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxRQUFRLFlBQVk7QUFDeEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS9iaW5kaW5nLmpzPzk3Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5jbGFzcyBCaW5kaW5nIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGlkZW50aWZpZXIsXG4gICAgc2NvcGUsXG4gICAgcGF0aCxcbiAgICBraW5kXG4gIH0pIHtcbiAgICB0aGlzLmlkZW50aWZpZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5raW5kID0gdm9pZCAwO1xuICAgIHRoaXMuY29uc3RhbnRWaW9sYXRpb25zID0gW107XG4gICAgdGhpcy5jb25zdGFudCA9IHRydWU7XG4gICAgdGhpcy5yZWZlcmVuY2VQYXRocyA9IFtdO1xuICAgIHRoaXMucmVmZXJlbmNlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVmZXJlbmNlcyA9IDA7XG4gICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgIGlmICgoa2luZCA9PT0gXCJ2YXJcIiB8fCBraW5kID09PSBcImhvaXN0ZWRcIikgJiYgaXNEZWNsYXJlZEluTG9vcChwYXRoKSkge1xuICAgICAgdGhpcy5yZWFzc2lnbihwYXRoKTtcbiAgICB9XG4gICAgdGhpcy5jbGVhclZhbHVlKCk7XG4gIH1cbiAgZGVvcHRWYWx1ZSgpIHtcbiAgICB0aGlzLmNsZWFyVmFsdWUoKTtcbiAgICB0aGlzLmhhc0Rlb3B0ZWRWYWx1ZSA9IHRydWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNEZW9wdGVkVmFsdWUpIHJldHVybjtcbiAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgY2xlYXJWYWx1ZSgpIHtcbiAgICB0aGlzLmhhc0Rlb3B0ZWRWYWx1ZSA9IGZhbHNlO1xuICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxuICByZWFzc2lnbihwYXRoKSB7XG4gICAgdGhpcy5jb25zdGFudCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmNvbnN0YW50VmlvbGF0aW9ucy5pbmNsdWRlcyhwYXRoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGgpO1xuICB9XG4gIHJlZmVyZW5jZShwYXRoKSB7XG4gICAgaWYgKHRoaXMucmVmZXJlbmNlUGF0aHMuaW5jbHVkZXMocGF0aCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWZlcmVuY2VkID0gdHJ1ZTtcbiAgICB0aGlzLnJlZmVyZW5jZXMrKztcbiAgICB0aGlzLnJlZmVyZW5jZVBhdGhzLnB1c2gocGF0aCk7XG4gIH1cbiAgZGVyZWZlcmVuY2UoKSB7XG4gICAgdGhpcy5yZWZlcmVuY2VzLS07XG4gICAgdGhpcy5yZWZlcmVuY2VkID0gISF0aGlzLnJlZmVyZW5jZXM7XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEJpbmRpbmc7XG5mdW5jdGlvbiBpc0RlY2xhcmVkSW5Mb29wKHBhdGgpIHtcbiAgZm9yIChsZXQge1xuICAgIHBhcmVudFBhdGgsXG4gICAga2V5XG4gIH0gPSBwYXRoOyBwYXJlbnRQYXRoOyAoe1xuICAgIHBhcmVudFBhdGgsXG4gICAga2V5XG4gIH0gPSBwYXJlbnRQYXRoKSkge1xuICAgIGlmIChwYXJlbnRQYXRoLmlzRnVuY3Rpb25QYXJlbnQoKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChwYXJlbnRQYXRoLmlzV2hpbGUoKSB8fCBwYXJlbnRQYXRoLmlzRm9yWFN0YXRlbWVudCgpIHx8IHBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoKSAmJiBrZXkgPT09IFwiYm9keVwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5kaW5nLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33599\n')},86814:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _renamer = __webpack_require__(23874);\nvar _index = __webpack_require__(25781);\nvar _binding = __webpack_require__(33599);\nvar _globals = __webpack_require__(97627);\nvar _t = __webpack_require__(2352);\nvar t = _t;\nvar _cache = __webpack_require__(37411);\nvar _visitors = __webpack_require__(34950);\nconst {\n  NOT_LOCAL_BINDING,\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isCallExpression,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMemberExpression,\n  isMethod,\n  isModuleSpecifier,\n  isNullLiteral,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isRegExpLiteral,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  expressionStatement,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  variableDeclaration,\n  variableDeclarator,\n  isRecordExpression,\n  isTupleExpression,\n  isObjectProperty,\n  isTopicReference,\n  isMetaProperty,\n  isPrivateName,\n  isExportDeclaration,\n  buildUndefinedNode,\n  sequenceExpression\n} = _t;\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isImportDeclaration(node) || isExportDeclaration(node)) {\n        var _node$specifiers;\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && (_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node) && !isNullLiteral(node) && !isRegExpLiteral(node) && !isTemplateLiteral(node)) {\n        parts.push(node.value);\n      }\n      break;\n    case "MemberExpression":\n    case "OptionalMemberExpression":\n    case "JSXMemberExpression":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case "Identifier":\n    case "JSXIdentifier":\n      parts.push(node.name);\n      break;\n    case "CallExpression":\n    case "OptionalCallExpression":\n    case "NewExpression":\n      gatherNodeParts(node.callee, parts);\n      break;\n    case "ObjectExpression":\n    case "ObjectPattern":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n      break;\n    case "SpreadElement":\n    case "RestElement":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case "ObjectProperty":\n    case "ObjectMethod":\n    case "ClassProperty":\n    case "ClassMethod":\n    case "ClassPrivateProperty":\n    case "ClassPrivateMethod":\n      gatherNodeParts(node.key, parts);\n      break;\n    case "ThisExpression":\n      parts.push("this");\n      break;\n    case "Super":\n      parts.push("super");\n      break;\n    case "Import":\n      parts.push("import");\n      break;\n    case "DoExpression":\n      parts.push("do");\n      break;\n    case "YieldExpression":\n      parts.push("yield");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case "AwaitExpression":\n      parts.push("await");\n      gatherNodeParts(node.argument, parts);\n      break;\n    case "AssignmentExpression":\n      gatherNodeParts(node.left, parts);\n      break;\n    case "VariableDeclarator":\n      gatherNodeParts(node.id, parts);\n      break;\n    case "FunctionExpression":\n    case "FunctionDeclaration":\n    case "ClassExpression":\n    case "ClassDeclaration":\n      gatherNodeParts(node.id, parts);\n      break;\n    case "PrivateName":\n      gatherNodeParts(node.id, parts);\n      break;\n    case "ParenthesizedExpression":\n      gatherNodeParts(node.expression, parts);\n      break;\n    case "UnaryExpression":\n    case "UpdateExpression":\n      gatherNodeParts(node.argument, parts);\n      break;\n    case "MetaProperty":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n    case "JSXElement":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n    case "JSXOpeningElement":\n      gatherNodeParts(node.name, parts);\n      break;\n    case "JSXFragment":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n    case "JSXOpeningFragment":\n      parts.push("Fragment");\n      break;\n    case "JSXNamespacedName":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get("init");\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding("var", declar);\n    }\n  },\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n  ForXStatement(path, state) {\n    const left = path.get("left");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding("var", left);\n    }\n  },\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null || binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null || binding.reference(path);\n          }\n        }\n      }\n    }\n  },\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n  UnaryExpression(path, state) {\n    if (path.node.operator === "delete") {\n      state.constantViolations.push(path);\n    }\n  },\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n  CatchClause(path) {\n    path.scope.registerBinding("let", path);\n  },\n  Function(path) {\n    const params = path.get("params");\n    for (const param of params) {\n      path.scope.registerBinding("param", param);\n    }\n    if (path.isFunctionExpression() && path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding("local", path.get("id"), path);\n    }\n  },\n  ClassExpression(path) {\n    if (path.node.id && !path.node.id[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding("local", path.get("id"), path);\n    }\n  },\n  TSTypeAnnotation(path) {\n    path.skip();\n  }\n};\nlet uid = 0;\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.inited = void 0;\n    this.labels = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n    const cached = _cache.scope.get(node);\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n    _cache.scope.set(node, this);\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n  get parent() {\n    var _parent;\n    let parent,\n      path = this.path;\n    do {\n      var _path;\n      const shouldSkip = path.key === "key" || path.listKey === "decorators";\n      path = path.parentPath;\n      if (shouldSkip && path.isMethod()) path = path.parentPath;\n      if ((_path = path) != null && _path.isScope()) parent = path;\n    } while (path && !parent);\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n  generateUid(name = "temp") {\n    name = toIdentifier(name).replace(/^_+/, "").replace(/\\d+$/g, "");\n    let uid;\n    let i = 1;\n    do {\n      uid = `_${name}`;\n      if (i > 1) uid += i;\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join("$");\n    id = id.replace(/^_/, "") || defaultName || "ref";\n    return this.generateUid(id.slice(0, 20));\n  }\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node) || isTopicReference(node)) {\n      return true;\n    }\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n    return false;\n  }\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n      return id;\n    }\n  }\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === "param") return;\n    if (local.kind === "local") return;\n    const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";\n    if (duplicate) {\n      throw this.path.hub.buildError(id, `Duplicate declaration "${name}"`, TypeError);\n    }\n  }\n  rename(oldName, newName) {\n    const binding = this.getBinding(oldName);\n    if (binding) {\n      newName || (newName = this.generateUidIdentifier(oldName).name);\n      const renamer = new _renamer.default(binding, oldName, newName);\n      {\n        renamer.rename(arguments[2]);\n      }\n    }\n  }\n  dump() {\n    const sep = "-".repeat(60);\n    console.log(sep);\n    let scope = this;\n    do {\n      console.log("#", scope.block.type);\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(" -", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n    console.log(sep);\n  }\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding("hoisted", path.get("id"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get("declarations");\n      const {\n        kind\n      } = path.node;\n      for (const declar of declarations) {\n        this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding("let", path);\n    } else if (path.isImportDeclaration()) {\n      const isTypeDeclaration = path.node.importKind === "type" || path.node.importKind === "typeof";\n      const specifiers = path.get("specifiers");\n      for (const specifier of specifiers) {\n        const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");\n        this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get("declaration");\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding("unknown", path);\n    }\n  }\n  buildUndefinedNode() {\n    return buildUndefinedNode();\n  }\n  registerConstantViolation(path) {\n    const ids = path.getAssignmentIdentifiers();\n    for (const name of Object.keys(ids)) {\n      var _this$getBinding;\n      (_this$getBinding = this.getBinding(name)) == null || _this$getBinding.reassign(path);\n    }\n  }\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError("no `kind`");\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get("declarations");\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n      return;\n    }\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n        if (local) {\n          local.reassign(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n  hasUid(name) {\n    let scope = this;\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n    return false;\n  }\n  hasGlobal(name) {\n    let scope = this;\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n    return false;\n  }\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isThisExpression(node) || isMetaProperty(node) || isTopicReference(node) || isPrivateName(node)) {\n      return true;\n    } else if (isClass(node)) {\n      var _node$decorators;\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n      if (((_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length) > 0) {\n        return false;\n      }\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node) || isTupleExpression(node)) {\n      for (const elem of node.elements) {\n        if (elem !== null && !this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isObjectExpression(node) || isRecordExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isMethod(node)) {\n      var _node$decorators2;\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (((_node$decorators2 = node.decorators) == null ? void 0 : _node$decorators2.length) > 0) {\n        return false;\n      }\n      return true;\n    } else if (isProperty(node)) {\n      var _node$decorators3;\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (((_node$decorators3 = node.decorators) == null ? void 0 : _node$decorators3.length) > 0) {\n        return false;\n      }\n      if (isObjectProperty(node) || node.static) {\n        if (node.value !== null && !this.isPure(node.value, constantsOnly)) {\n          return false;\n        }\n      }\n      return true;\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n      return true;\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, "String.raw") && !this.hasBinding("String", {\n        noGlobals: true\n      }) && this.isPure(node.quasi, constantsOnly);\n    } else if (isMemberExpression(node)) {\n      return !node.computed && isIdentifier(node.object) && node.object.name === "Symbol" && isIdentifier(node.property) && node.property.name !== "for" && !this.hasBinding("Symbol", {\n        noGlobals: true\n      });\n    } else if (isCallExpression(node)) {\n      return matchesPattern(node.callee, "Symbol.for") && !this.hasBinding("Symbol", {\n        noGlobals: true\n      }) && node.arguments.length === 1 && t.isStringLiteral(node.arguments[0]);\n    } else {\n      return isPureish(node);\n    }\n  }\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n  getData(key) {\n    let scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n  removeData(key) {\n    let scope = this;\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n    if (path.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {\n      for (const visit of collectorVisitor.enter) {\n        visit.call(state, path, state);\n      }\n      const typeVisitors = collectorVisitor[path.type];\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit.call(state, path, state);\n        }\n      }\n    }\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n    for (const path of state.assignments) {\n      const ids = path.getAssignmentIdentifiers();\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n      path.scope.registerConstantViolation(path);\n    }\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n  push(opts) {\n    let path = this.path;\n    if (path.isPattern()) {\n      path = this.getPatternParent().path;\n    } else if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n    const {\n      init,\n      unique,\n      kind = "var",\n      id\n    } = opts;\n    if (!init && !unique && (kind === "var" || kind === "let") && path.isFunction() && !path.node.name && isCallExpression(path.parent, {\n      callee: path.node\n    }) && path.parent.arguments.length <= path.node.params.length && isIdentifier(id)) {\n      path.pushContainer("params", id);\n      path.scope.registerBinding("param", path.get("params")[path.node.params.length - 1]);\n      return;\n    }\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get("body");\n    }\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer("body", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n    const declarator = variableDeclarator(id, init);\n    const len = declarPath.node.declarations.push(declarator);\n    path.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);\n  }\n  getProgramParent() {\n    let scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error("Couldn\'t find a Program");\n  }\n  getFunctionParent() {\n    let scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    return null;\n  }\n  getBlockParent() {\n    let scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error("We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...");\n  }\n  getPatternParent() {\n    let scope = this;\n    do {\n      if (!scope.path.isPattern()) {\n        return scope.getBlockParent();\n      }\n    } while (scope = scope.parent.parent);\n    throw new Error("We couldn\'t find a BlockStatement, For, Switch, Function, Loop or Program...");\n  }\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n      scope = scope.parent;\n    } while (scope);\n    return ids;\n  }\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n    do {\n      const binding = scope.getOwnBinding(name);\n      if (binding) {\n        var _previousPath;\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {} else {\n          return binding;\n        }\n      } else if (!binding && name === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n  getBindingIdentifier(name) {\n    var _this$getBinding2;\n    return (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.identifier;\n  }\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n  hasBinding(name, opts) {\n    if (!name) return false;\n    let scope = this;\n    do {\n      if (scope.hasOwnBinding(name)) {\n        return true;\n      }\n    } while (scope = scope.parent);\n    let noGlobals;\n    let noUids;\n    if (typeof opts === "object") {\n      noGlobals = opts.noGlobals;\n      noUids = opts.noUids;\n    } else if (typeof opts === "boolean") {\n      noGlobals = opts;\n    }\n    if (!noUids && this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n  parentHasBinding(name, opts) {\n    var _this$parent;\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, opts);\n  }\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n  removeBinding(name) {\n    var _this$getBinding3;\n    (_this$getBinding3 = this.getBinding(name)) == null || _this$getBinding3.scope.removeOwnBinding(name);\n    let scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n  hoistVariables(emit = id => this.push({\n    id\n  })) {\n    this.crawl();\n    const seen = new Set();\n    for (const name of Object.keys(this.bindings)) {\n      const binding = this.bindings[name];\n      if (!binding) continue;\n      const {\n        path\n      } = binding;\n      if (!path.isVariableDeclarator()) continue;\n      const {\n        parent,\n        parentPath\n      } = path;\n      if (parent.kind !== "var" || seen.has(parent)) continue;\n      seen.add(path.parent);\n      let firstId;\n      const init = [];\n      for (const decl of parent.declarations) {\n        var _firstId;\n        (_firstId = firstId) != null ? _firstId : firstId = decl.id;\n        if (decl.init) {\n          init.push(assignmentExpression("=", decl.id, decl.init));\n        }\n        const ids = Object.keys(getBindingIdentifiers(decl, false, true, true));\n        for (const name of ids) {\n          emit(identifier(name), decl.init != null);\n        }\n      }\n      if (parentPath.parentPath.isFor({\n        left: parent\n      })) {\n        parentPath.replaceWith(firstId);\n      } else if (init.length === 0) {\n        parentPath.remove();\n      } else {\n        const expr = init.length === 1 ? init[0] : sequenceExpression(init);\n        if (parentPath.parentPath.isForStatement({\n          init: parent\n        })) {\n          parentPath.replaceWith(expr);\n        } else {\n          parentPath.replaceWith(expressionStatement(expr));\n        }\n      }\n    }\n  }\n}\nexports["default"] = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];\n{\n  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  };\n  Scope.prototype.traverse = function (node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  };\n  Scope.prototype._generateUid = function _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  };\n  Scope.prototype.toArray = function toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (binding != null && binding.constant && binding.path.isGenericType("Array")) {\n        return node;\n      }\n    }\n    if (isArrayExpression(node)) {\n      return node;\n    }\n    if (isIdentifier(node, {\n      name: "arguments"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);\n    }\n    let helperName;\n    const args = [node];\n    if (i === true) {\n      helperName = "toConsumableArray";\n    } else if (typeof i === "number") {\n      args.push(numericLiteral(i));\n      helperName = "slicedToArray";\n    } else {\n      helperName = "toArray";\n    }\n    if (arrayLikeIsIterable) {\n      args.unshift(this.path.hub.addHelper(helperName));\n      helperName = "maybeArrayLike";\n    }\n    return callExpression(this.path.hub.addHelper(helperName), args);\n  };\n  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n    for (const kind of kinds) {\n      let scope = this;\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n    return ids;\n  };\n  Object.defineProperties(Scope.prototype, {\n    parentBlock: {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return this.path.parent;\n      }\n    },\n    hub: {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return this.path.hub;\n      }\n    }\n  });\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY4MTQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBa0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLEtBQWE7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLEtBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLEtBQVM7QUFDaEMsU0FBUyxtQkFBTyxDQUFDLElBQWM7QUFDL0I7QUFDQSxhQUFhLG1CQUFPLENBQUMsS0FBYTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLEtBQUs7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLLEdBQUcsV0FBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SUFBNEk7QUFDNUk7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3RyYXZlcnNlL2xpYi9zY29wZS9pbmRleC5qcz9jNWNlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9yZW5hbWVyID0gcmVxdWlyZShcIi4vbGliL3JlbmFtZXIuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2luZGV4LmpzXCIpO1xudmFyIF9iaW5kaW5nID0gcmVxdWlyZShcIi4vYmluZGluZy5qc1wiKTtcbnZhciBfZ2xvYmFscyA9IHJlcXVpcmUoXCJnbG9iYWxzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciB0ID0gX3Q7XG52YXIgX2NhY2hlID0gcmVxdWlyZShcIi4uL2NhY2hlLmpzXCIpO1xudmFyIF92aXNpdG9ycyA9IHJlcXVpcmUoXCIuLi92aXNpdG9ycy5qc1wiKTtcbmNvbnN0IHtcbiAgTk9UX0xPQ0FMX0JJTkRJTkcsXG4gIGFzc2lnbm1lbnRFeHByZXNzaW9uLFxuICBjYWxsRXhwcmVzc2lvbixcbiAgY2xvbmVOb2RlLFxuICBnZXRCaW5kaW5nSWRlbnRpZmllcnMsXG4gIGlkZW50aWZpZXIsXG4gIGlzQXJyYXlFeHByZXNzaW9uLFxuICBpc0JpbmFyeSxcbiAgaXNDYWxsRXhwcmVzc2lvbixcbiAgaXNDbGFzcyxcbiAgaXNDbGFzc0JvZHksXG4gIGlzQ2xhc3NEZWNsYXJhdGlvbixcbiAgaXNFeHBvcnRBbGxEZWNsYXJhdGlvbixcbiAgaXNFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24sXG4gIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbixcbiAgaXNGdW5jdGlvbkRlY2xhcmF0aW9uLFxuICBpc0lkZW50aWZpZXIsXG4gIGlzSW1wb3J0RGVjbGFyYXRpb24sXG4gIGlzTGl0ZXJhbCxcbiAgaXNNZW1iZXJFeHByZXNzaW9uLFxuICBpc01ldGhvZCxcbiAgaXNNb2R1bGVTcGVjaWZpZXIsXG4gIGlzTnVsbExpdGVyYWwsXG4gIGlzT2JqZWN0RXhwcmVzc2lvbixcbiAgaXNQcm9wZXJ0eSxcbiAgaXNQdXJlaXNoLFxuICBpc1JlZ0V4cExpdGVyYWwsXG4gIGlzU3VwZXIsXG4gIGlzVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uLFxuICBpc1RlbXBsYXRlTGl0ZXJhbCxcbiAgaXNUaGlzRXhwcmVzc2lvbixcbiAgaXNVbmFyeUV4cHJlc3Npb24sXG4gIGlzVmFyaWFibGVEZWNsYXJhdGlvbixcbiAgZXhwcmVzc2lvblN0YXRlbWVudCxcbiAgbWF0Y2hlc1BhdHRlcm4sXG4gIG1lbWJlckV4cHJlc3Npb24sXG4gIG51bWVyaWNMaXRlcmFsLFxuICB0b0lkZW50aWZpZXIsXG4gIHZhcmlhYmxlRGVjbGFyYXRpb24sXG4gIHZhcmlhYmxlRGVjbGFyYXRvcixcbiAgaXNSZWNvcmRFeHByZXNzaW9uLFxuICBpc1R1cGxlRXhwcmVzc2lvbixcbiAgaXNPYmplY3RQcm9wZXJ0eSxcbiAgaXNUb3BpY1JlZmVyZW5jZSxcbiAgaXNNZXRhUHJvcGVydHksXG4gIGlzUHJpdmF0ZU5hbWUsXG4gIGlzRXhwb3J0RGVjbGFyYXRpb24sXG4gIGJ1aWxkVW5kZWZpbmVkTm9kZSxcbiAgc2VxdWVuY2VFeHByZXNzaW9uXG59ID0gX3Q7XG5mdW5jdGlvbiBnYXRoZXJOb2RlUGFydHMobm9kZSwgcGFydHMpIHtcbiAgc3dpdGNoIChub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpIHtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSkgfHwgaXNFeHBvcnREZWNsYXJhdGlvbihub2RlKSkge1xuICAgICAgICB2YXIgX25vZGUkc3BlY2lmaWVycztcbiAgICAgICAgaWYgKChpc0V4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUpIHx8IGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlKSB8fCBpc0ltcG9ydERlY2xhcmF0aW9uKG5vZGUpKSAmJiBub2RlLnNvdXJjZSkge1xuICAgICAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLnNvdXJjZSwgcGFydHMpO1xuICAgICAgICB9IGVsc2UgaWYgKChpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSkgfHwgaXNJbXBvcnREZWNsYXJhdGlvbihub2RlKSkgJiYgKF9ub2RlJHNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMpICE9IG51bGwgJiYgX25vZGUkc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygbm9kZS5zcGVjaWZpZXJzKSBnYXRoZXJOb2RlUGFydHMoZSwgcGFydHMpO1xuICAgICAgICB9IGVsc2UgaWYgKChpc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbihub2RlKSB8fCBpc0V4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSkpICYmIG5vZGUuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5kZWNsYXJhdGlvbiwgcGFydHMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzTW9kdWxlU3BlY2lmaWVyKG5vZGUpKSB7XG4gICAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLmxvY2FsLCBwYXJ0cyk7XG4gICAgICB9IGVsc2UgaWYgKGlzTGl0ZXJhbChub2RlKSAmJiAhaXNOdWxsTGl0ZXJhbChub2RlKSAmJiAhaXNSZWdFeHBMaXRlcmFsKG5vZGUpICYmICFpc1RlbXBsYXRlTGl0ZXJhbChub2RlKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKG5vZGUudmFsdWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm9iamVjdCwgcGFydHMpO1xuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUucHJvcGVydHksIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgY2FzZSBcIkpTWElkZW50aWZpZXJcIjpcbiAgICAgIHBhcnRzLnB1c2gobm9kZS5uYW1lKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk5ld0V4cHJlc3Npb25cIjpcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLmNhbGxlZSwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgZm9yIChjb25zdCBlIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICBnYXRoZXJOb2RlUGFydHMoZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLmFyZ3VtZW50LCBwYXJ0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5rZXksIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgICAgcGFydHMucHVzaChcInRoaXNcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiU3VwZXJcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJzdXBlclwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJJbXBvcnRcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJpbXBvcnRcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiRG9FeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwiZG9cIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwieWllbGRcIik7XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5hcmd1bWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkF3YWl0RXhwcmVzc2lvblwiOlxuICAgICAgcGFydHMucHVzaChcImF3YWl0XCIpO1xuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuYXJndW1lbnQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUubGVmdCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuaWQsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUuZXhwcmVzc2lvbiwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5hcmd1bWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUubWV0YSwgcGFydHMpO1xuICAgICAgZ2F0aGVyTm9kZVBhcnRzKG5vZGUucHJvcGVydHksIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5vcGVuaW5nRWxlbWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdFbGVtZW50XCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5uYW1lLCBwYXJ0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjpcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm9wZW5pbmdGcmFnbWVudCwgcGFydHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiOlxuICAgICAgcGFydHMucHVzaChcIkZyYWdtZW50XCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkpTWE5hbWVzcGFjZWROYW1lXCI6XG4gICAgICBnYXRoZXJOb2RlUGFydHMobm9kZS5uYW1lc3BhY2UsIHBhcnRzKTtcbiAgICAgIGdhdGhlck5vZGVQYXJ0cyhub2RlLm5hbWUsIHBhcnRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5jb25zdCBjb2xsZWN0b3JWaXNpdG9yID0ge1xuICBGb3JTdGF0ZW1lbnQocGF0aCkge1xuICAgIGNvbnN0IGRlY2xhciA9IHBhdGguZ2V0KFwiaW5pdFwiKTtcbiAgICBpZiAoZGVjbGFyLmlzVmFyKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2NvcGVcbiAgICAgIH0gPSBwYXRoO1xuICAgICAgY29uc3QgcGFyZW50U2NvcGUgPSBzY29wZS5nZXRGdW5jdGlvblBhcmVudCgpIHx8IHNjb3BlLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICAgIHBhcmVudFNjb3BlLnJlZ2lzdGVyQmluZGluZyhcInZhclwiLCBkZWNsYXIpO1xuICAgIH1cbiAgfSxcbiAgRGVjbGFyYXRpb24ocGF0aCkge1xuICAgIGlmIChwYXRoLmlzQmxvY2tTY29wZWQoKSkgcmV0dXJuO1xuICAgIGlmIChwYXRoLmlzSW1wb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGlmIChwYXRoLmlzRXhwb3J0RGVjbGFyYXRpb24oKSkgcmV0dXJuO1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKSB8fCBwYXRoLnNjb3BlLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgfSxcbiAgSW1wb3J0RGVjbGFyYXRpb24ocGF0aCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGguc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgfSxcbiAgUmVmZXJlbmNlZElkZW50aWZpZXIocGF0aCwgc3RhdGUpIHtcbiAgICBzdGF0ZS5yZWZlcmVuY2VzLnB1c2gocGF0aCk7XG4gIH0sXG4gIEZvclhTdGF0ZW1lbnQocGF0aCwgc3RhdGUpIHtcbiAgICBjb25zdCBsZWZ0ID0gcGF0aC5nZXQoXCJsZWZ0XCIpO1xuICAgIGlmIChsZWZ0LmlzUGF0dGVybigpIHx8IGxlZnQuaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgIHN0YXRlLmNvbnN0YW50VmlvbGF0aW9ucy5wdXNoKHBhdGgpO1xuICAgIH0gZWxzZSBpZiAobGVmdC5pc1ZhcigpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNjb3BlXG4gICAgICB9ID0gcGF0aDtcbiAgICAgIGNvbnN0IHBhcmVudFNjb3BlID0gc2NvcGUuZ2V0RnVuY3Rpb25QYXJlbnQoKSB8fCBzY29wZS5nZXRQcm9ncmFtUGFyZW50KCk7XG4gICAgICBwYXJlbnRTY29wZS5yZWdpc3RlckJpbmRpbmcoXCJ2YXJcIiwgbGVmdCk7XG4gICAgfVxuICB9LFxuICBFeHBvcnREZWNsYXJhdGlvbjoge1xuICAgIGV4aXQocGF0aCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBub2RlLFxuICAgICAgICBzY29wZVxuICAgICAgfSA9IHBhdGg7XG4gICAgICBpZiAoaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlKSkgcmV0dXJuO1xuICAgICAgY29uc3QgZGVjbGFyID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgIGlmIChpc0NsYXNzRGVjbGFyYXRpb24oZGVjbGFyKSB8fCBpc0Z1bmN0aW9uRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgICBjb25zdCBpZCA9IGRlY2xhci5pZDtcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZyhpZC5uYW1lKTtcbiAgICAgICAgYmluZGluZyA9PSBudWxsIHx8IGJpbmRpbmcucmVmZXJlbmNlKHBhdGgpO1xuICAgICAgfSBlbHNlIGlmIChpc1ZhcmlhYmxlRGVjbGFyYXRpb24oZGVjbGFyKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRlY2wgb2YgZGVjbGFyLmRlY2xhcmF0aW9ucykge1xuICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhnZXRCaW5kaW5nSWRlbnRpZmllcnMoZGVjbCkpKSB7XG4gICAgICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuZ2V0QmluZGluZyhuYW1lKTtcbiAgICAgICAgICAgIGJpbmRpbmcgPT0gbnVsbCB8fCBiaW5kaW5nLnJlZmVyZW5jZShwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIExhYmVsZWRTdGF0ZW1lbnQocGF0aCkge1xuICAgIHBhdGguc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKS5yZWdpc3RlckRlY2xhcmF0aW9uKHBhdGgpO1xuICB9LFxuICBBc3NpZ25tZW50RXhwcmVzc2lvbihwYXRoLCBzdGF0ZSkge1xuICAgIHN0YXRlLmFzc2lnbm1lbnRzLnB1c2gocGF0aCk7XG4gIH0sXG4gIFVwZGF0ZUV4cHJlc3Npb24ocGF0aCwgc3RhdGUpIHtcbiAgICBzdGF0ZS5jb25zdGFudFZpb2xhdGlvbnMucHVzaChwYXRoKTtcbiAgfSxcbiAgVW5hcnlFeHByZXNzaW9uKHBhdGgsIHN0YXRlKSB7XG4gICAgaWYgKHBhdGgubm9kZS5vcGVyYXRvciA9PT0gXCJkZWxldGVcIikge1xuICAgICAgc3RhdGUuY29uc3RhbnRWaW9sYXRpb25zLnB1c2gocGF0aCk7XG4gICAgfVxuICB9LFxuICBCbG9ja1Njb3BlZChwYXRoKSB7XG4gICAgbGV0IHNjb3BlID0gcGF0aC5zY29wZTtcbiAgICBpZiAoc2NvcGUucGF0aCA9PT0gcGF0aCkgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgY29uc3QgcGFyZW50ID0gc2NvcGUuZ2V0QmxvY2tQYXJlbnQoKTtcbiAgICBwYXJlbnQucmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKTtcbiAgICBpZiAocGF0aC5pc0NsYXNzRGVjbGFyYXRpb24oKSAmJiBwYXRoLm5vZGUuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gcGF0aC5ub2RlLmlkO1xuICAgICAgY29uc3QgbmFtZSA9IGlkLm5hbWU7XG4gICAgICBwYXRoLnNjb3BlLmJpbmRpbmdzW25hbWVdID0gcGF0aC5zY29wZS5wYXJlbnQuZ2V0QmluZGluZyhuYW1lKTtcbiAgICB9XG4gIH0sXG4gIENhdGNoQ2xhdXNlKHBhdGgpIHtcbiAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcImxldFwiLCBwYXRoKTtcbiAgfSxcbiAgRnVuY3Rpb24ocGF0aCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHBhdGguZ2V0KFwicGFyYW1zXCIpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgcGFyYW1zKSB7XG4gICAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgaWYgKHBhdGguaXNGdW5jdGlvbkV4cHJlc3Npb24oKSAmJiBwYXRoLm5vZGUuaWQgJiYgIXBhdGgubm9kZS5pZFtOT1RfTE9DQUxfQklORElOR10pIHtcbiAgICAgIHBhdGguc2NvcGUucmVnaXN0ZXJCaW5kaW5nKFwibG9jYWxcIiwgcGF0aC5nZXQoXCJpZFwiKSwgcGF0aCk7XG4gICAgfVxuICB9LFxuICBDbGFzc0V4cHJlc3Npb24ocGF0aCkge1xuICAgIGlmIChwYXRoLm5vZGUuaWQgJiYgIXBhdGgubm9kZS5pZFtOT1RfTE9DQUxfQklORElOR10pIHtcbiAgICAgIHBhdGguc2NvcGUucmVnaXN0ZXJCaW5kaW5nKFwibG9jYWxcIiwgcGF0aC5nZXQoXCJpZFwiKSwgcGF0aCk7XG4gICAgfVxuICB9LFxuICBUU1R5cGVBbm5vdGF0aW9uKHBhdGgpIHtcbiAgICBwYXRoLnNraXAoKTtcbiAgfVxufTtcbmxldCB1aWQgPSAwO1xuY2xhc3MgU2NvcGUge1xuICBjb25zdHJ1Y3RvcihwYXRoKSB7XG4gICAgdGhpcy51aWQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYmxvY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5pbml0ZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5sYWJlbHMgPSB2b2lkIDA7XG4gICAgdGhpcy5iaW5kaW5ncyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5nbG9iYWxzID0gdm9pZCAwO1xuICAgIHRoaXMudWlkcyA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5jcmF3bGluZyA9IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBub2RlXG4gICAgfSA9IHBhdGg7XG4gICAgY29uc3QgY2FjaGVkID0gX2NhY2hlLnNjb3BlLmdldChub2RlKTtcbiAgICBpZiAoKGNhY2hlZCA9PSBudWxsID8gdm9pZCAwIDogY2FjaGVkLnBhdGgpID09PSBwYXRoKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBfY2FjaGUuc2NvcGUuc2V0KG5vZGUsIHRoaXMpO1xuICAgIHRoaXMudWlkID0gdWlkKys7XG4gICAgdGhpcy5ibG9jayA9IG5vZGU7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICB0aGlzLmxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmluaXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgdmFyIF9wYXJlbnQ7XG4gICAgbGV0IHBhcmVudCxcbiAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgZG8ge1xuICAgICAgdmFyIF9wYXRoO1xuICAgICAgY29uc3Qgc2hvdWxkU2tpcCA9IHBhdGgua2V5ID09PSBcImtleVwiIHx8IHBhdGgubGlzdEtleSA9PT0gXCJkZWNvcmF0b3JzXCI7XG4gICAgICBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgICAgaWYgKHNob3VsZFNraXAgJiYgcGF0aC5pc01ldGhvZCgpKSBwYXRoID0gcGF0aC5wYXJlbnRQYXRoO1xuICAgICAgaWYgKChfcGF0aCA9IHBhdGgpICE9IG51bGwgJiYgX3BhdGguaXNTY29wZSgpKSBwYXJlbnQgPSBwYXRoO1xuICAgIH0gd2hpbGUgKHBhdGggJiYgIXBhcmVudCk7XG4gICAgcmV0dXJuIChfcGFyZW50ID0gcGFyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudC5zY29wZTtcbiAgfVxuICBnZW5lcmF0ZURlY2xhcmVkVWlkSWRlbnRpZmllcihuYW1lKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmdlbmVyYXRlVWlkSWRlbnRpZmllcihuYW1lKTtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgaWRcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVOb2RlKGlkKTtcbiAgfVxuICBnZW5lcmF0ZVVpZElkZW50aWZpZXIobmFtZSkge1xuICAgIHJldHVybiBpZGVudGlmaWVyKHRoaXMuZ2VuZXJhdGVVaWQobmFtZSkpO1xuICB9XG4gIGdlbmVyYXRlVWlkKG5hbWUgPSBcInRlbXBcIikge1xuICAgIG5hbWUgPSB0b0lkZW50aWZpZXIobmFtZSkucmVwbGFjZSgvXl8rLywgXCJcIikucmVwbGFjZSgvXFxkKyQvZywgXCJcIik7XG4gICAgbGV0IHVpZDtcbiAgICBsZXQgaSA9IDE7XG4gICAgZG8ge1xuICAgICAgdWlkID0gYF8ke25hbWV9YDtcbiAgICAgIGlmIChpID4gMSkgdWlkICs9IGk7XG4gICAgICBpKys7XG4gICAgfSB3aGlsZSAodGhpcy5oYXNMYWJlbCh1aWQpIHx8IHRoaXMuaGFzQmluZGluZyh1aWQpIHx8IHRoaXMuaGFzR2xvYmFsKHVpZCkgfHwgdGhpcy5oYXNSZWZlcmVuY2UodWlkKSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuZ2V0UHJvZ3JhbVBhcmVudCgpO1xuICAgIHByb2dyYW0ucmVmZXJlbmNlc1t1aWRdID0gdHJ1ZTtcbiAgICBwcm9ncmFtLnVpZHNbdWlkXSA9IHRydWU7XG4gICAgcmV0dXJuIHVpZDtcbiAgfVxuICBnZW5lcmF0ZVVpZEJhc2VkT25Ob2RlKG5vZGUsIGRlZmF1bHROYW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBnYXRoZXJOb2RlUGFydHMobm9kZSwgcGFydHMpO1xuICAgIGxldCBpZCA9IHBhcnRzLmpvaW4oXCIkXCIpO1xuICAgIGlkID0gaWQucmVwbGFjZSgvXl8vLCBcIlwiKSB8fCBkZWZhdWx0TmFtZSB8fCBcInJlZlwiO1xuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlVWlkKGlkLnNsaWNlKDAsIDIwKSk7XG4gIH1cbiAgZ2VuZXJhdGVVaWRJZGVudGlmaWVyQmFzZWRPbk5vZGUobm9kZSwgZGVmYXVsdE5hbWUpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcih0aGlzLmdlbmVyYXRlVWlkQmFzZWRPbk5vZGUobm9kZSwgZGVmYXVsdE5hbWUpKTtcbiAgfVxuICBpc1N0YXRpYyhub2RlKSB7XG4gICAgaWYgKGlzVGhpc0V4cHJlc3Npb24obm9kZSkgfHwgaXNTdXBlcihub2RlKSB8fCBpc1RvcGljUmVmZXJlbmNlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSWRlbnRpZmllcihub2RlKSkge1xuICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhub2RlLm5hbWUpO1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIGJpbmRpbmcuY29uc3RhbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNCaW5kaW5nKG5vZGUubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZUdlbmVyYXRlTWVtb2lzZWQobm9kZSwgZG9udFB1c2gpIHtcbiAgICBpZiAodGhpcy5pc1N0YXRpYyhub2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5nZW5lcmF0ZVVpZElkZW50aWZpZXJCYXNlZE9uTm9kZShub2RlKTtcbiAgICAgIGlmICghZG9udFB1c2gpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICBpZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNsb25lTm9kZShpZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICB9XG4gIGNoZWNrQmxvY2tTY29wZWRDb2xsaXNpb25zKGxvY2FsLCBraW5kLCBuYW1lLCBpZCkge1xuICAgIGlmIChraW5kID09PSBcInBhcmFtXCIpIHJldHVybjtcbiAgICBpZiAobG9jYWwua2luZCA9PT0gXCJsb2NhbFwiKSByZXR1cm47XG4gICAgY29uc3QgZHVwbGljYXRlID0ga2luZCA9PT0gXCJsZXRcIiB8fCBsb2NhbC5raW5kID09PSBcImxldFwiIHx8IGxvY2FsLmtpbmQgPT09IFwiY29uc3RcIiB8fCBsb2NhbC5raW5kID09PSBcIm1vZHVsZVwiIHx8IGxvY2FsLmtpbmQgPT09IFwicGFyYW1cIiAmJiBraW5kID09PSBcImNvbnN0XCI7XG4gICAgaWYgKGR1cGxpY2F0ZSkge1xuICAgICAgdGhyb3cgdGhpcy5wYXRoLmh1Yi5idWlsZEVycm9yKGlkLCBgRHVwbGljYXRlIGRlY2xhcmF0aW9uIFwiJHtuYW1lfVwiYCwgVHlwZUVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmVuYW1lKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG9sZE5hbWUpO1xuICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICBuZXdOYW1lIHx8IChuZXdOYW1lID0gdGhpcy5nZW5lcmF0ZVVpZElkZW50aWZpZXIob2xkTmFtZSkubmFtZSk7XG4gICAgICBjb25zdCByZW5hbWVyID0gbmV3IF9yZW5hbWVyLmRlZmF1bHQoYmluZGluZywgb2xkTmFtZSwgbmV3TmFtZSk7XG4gICAgICB7XG4gICAgICAgIHJlbmFtZXIucmVuYW1lKGFyZ3VtZW50c1syXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGR1bXAoKSB7XG4gICAgY29uc3Qgc2VwID0gXCItXCIucmVwZWF0KDYwKTtcbiAgICBjb25zb2xlLmxvZyhzZXApO1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgY29uc29sZS5sb2coXCIjXCIsIHNjb3BlLmJsb2NrLnR5cGUpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKHNjb3BlLmJpbmRpbmdzKSkge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gc2NvcGUuYmluZGluZ3NbbmFtZV07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiIC1cIiwgbmFtZSwge1xuICAgICAgICAgIGNvbnN0YW50OiBiaW5kaW5nLmNvbnN0YW50LFxuICAgICAgICAgIHJlZmVyZW5jZXM6IGJpbmRpbmcucmVmZXJlbmNlcyxcbiAgICAgICAgICB2aW9sYXRpb25zOiBiaW5kaW5nLmNvbnN0YW50VmlvbGF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAga2luZDogYmluZGluZy5raW5kXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICBjb25zb2xlLmxvZyhzZXApO1xuICB9XG4gIGhhc0xhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gISF0aGlzLmdldExhYmVsKG5hbWUpO1xuICB9XG4gIGdldExhYmVsKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5sYWJlbHMuZ2V0KG5hbWUpO1xuICB9XG4gIHJlZ2lzdGVyTGFiZWwocGF0aCkge1xuICAgIHRoaXMubGFiZWxzLnNldChwYXRoLm5vZGUubGFiZWwubmFtZSwgcGF0aCk7XG4gIH1cbiAgcmVnaXN0ZXJEZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgaWYgKHBhdGguaXNMYWJlbGVkU3RhdGVtZW50KCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYWJlbChwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNGdW5jdGlvbkRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwiaG9pc3RlZFwiLCBwYXRoLmdldChcImlkXCIpLCBwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9ucyA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25zXCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBraW5kXG4gICAgICB9ID0gcGF0aC5ub2RlO1xuICAgICAgZm9yIChjb25zdCBkZWNsYXIgb2YgZGVjbGFyYXRpb25zKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIgPyBcImNvbnN0XCIgOiBraW5kLCBkZWNsYXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0NsYXNzRGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHBhdGgubm9kZS5kZWNsYXJlKSByZXR1cm47XG4gICAgICB0aGlzLnJlZ2lzdGVyQmluZGluZyhcImxldFwiLCBwYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGguaXNJbXBvcnREZWNsYXJhdGlvbigpKSB7XG4gICAgICBjb25zdCBpc1R5cGVEZWNsYXJhdGlvbiA9IHBhdGgubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBwYXRoLm5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbiAgICAgIGNvbnN0IHNwZWNpZmllcnMgPSBwYXRoLmdldChcInNwZWNpZmllcnNcIik7XG4gICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBzcGVjaWZpZXJzKSB7XG4gICAgICAgIGNvbnN0IGlzVHlwZVNwZWNpZmllciA9IGlzVHlwZURlY2xhcmF0aW9uIHx8IHNwZWNpZmllci5pc0ltcG9ydFNwZWNpZmllcigpICYmIChzcGVjaWZpZXIubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBzcGVjaWZpZXIubm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckJpbmRpbmcoaXNUeXBlU3BlY2lmaWVyID8gXCJ1bmtub3duXCIgOiBcIm1vZHVsZVwiLCBzcGVjaWZpZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF0aC5pc0V4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IGRlY2xhciA9IHBhdGguZ2V0KFwiZGVjbGFyYXRpb25cIik7XG4gICAgICBpZiAoZGVjbGFyLmlzQ2xhc3NEZWNsYXJhdGlvbigpIHx8IGRlY2xhci5pc0Z1bmN0aW9uRGVjbGFyYXRpb24oKSB8fCBkZWNsYXIuaXNWYXJpYWJsZURlY2xhcmF0aW9uKCkpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckRlY2xhcmF0aW9uKGRlY2xhcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKFwidW5rbm93blwiLCBwYXRoKTtcbiAgICB9XG4gIH1cbiAgYnVpbGRVbmRlZmluZWROb2RlKCkge1xuICAgIHJldHVybiBidWlsZFVuZGVmaW5lZE5vZGUoKTtcbiAgfVxuICByZWdpc3RlckNvbnN0YW50VmlvbGF0aW9uKHBhdGgpIHtcbiAgICBjb25zdCBpZHMgPSBwYXRoLmdldEFzc2lnbm1lbnRJZGVudGlmaWVycygpO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpZHMpKSB7XG4gICAgICB2YXIgX3RoaXMkZ2V0QmluZGluZztcbiAgICAgIChfdGhpcyRnZXRCaW5kaW5nID0gdGhpcy5nZXRCaW5kaW5nKG5hbWUpKSA9PSBudWxsIHx8IF90aGlzJGdldEJpbmRpbmcucmVhc3NpZ24ocGF0aCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyQmluZGluZyhraW5kLCBwYXRoLCBiaW5kaW5nUGF0aCA9IHBhdGgpIHtcbiAgICBpZiAoIWtpbmQpIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIm5vIGBraW5kYFwiKTtcbiAgICBpZiAocGF0aC5pc1ZhcmlhYmxlRGVjbGFyYXRpb24oKSkge1xuICAgICAgY29uc3QgZGVjbGFyYXRvcnMgPSBwYXRoLmdldChcImRlY2xhcmF0aW9uc1wiKTtcbiAgICAgIGZvciAoY29uc3QgZGVjbGFyIG9mIGRlY2xhcmF0b3JzKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJCaW5kaW5nKGtpbmQsIGRlY2xhcik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UHJvZ3JhbVBhcmVudCgpO1xuICAgIGNvbnN0IGlkcyA9IHBhdGguZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnModHJ1ZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGlkcykpIHtcbiAgICAgIHBhcmVudC5yZWZlcmVuY2VzW25hbWVdID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzW25hbWVdKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICBpZiAobG9jYWwuaWRlbnRpZmllciA9PT0gaWQpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tCbG9ja1Njb3BlZENvbGxpc2lvbnMobG9jYWwsIGtpbmQsIG5hbWUsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICBsb2NhbC5yZWFzc2lnbihiaW5kaW5nUGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tuYW1lXSA9IG5ldyBfYmluZGluZy5kZWZhdWx0KHtcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkLFxuICAgICAgICAgICAgc2NvcGU6IHRoaXMsXG4gICAgICAgICAgICBwYXRoOiBiaW5kaW5nUGF0aCxcbiAgICAgICAgICAgIGtpbmQ6IGtpbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZGRHbG9iYWwobm9kZSkge1xuICAgIHRoaXMuZ2xvYmFsc1tub2RlLm5hbWVdID0gbm9kZTtcbiAgfVxuICBoYXNVaWQobmFtZSkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnVpZHNbbmFtZV0pIHJldHVybiB0cnVlO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzR2xvYmFsKG5hbWUpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGlmIChzY29wZS5nbG9iYWxzW25hbWVdKSByZXR1cm4gdHJ1ZTtcbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGhhc1JlZmVyZW5jZShuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRQcm9ncmFtUGFyZW50KCkucmVmZXJlbmNlc1tuYW1lXTtcbiAgfVxuICBpc1B1cmUobm9kZSwgY29uc3RhbnRzT25seSkge1xuICAgIGlmIChpc0lkZW50aWZpZXIobm9kZSkpIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmdldEJpbmRpbmcobm9kZS5uYW1lKTtcbiAgICAgIGlmICghYmluZGluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKGNvbnN0YW50c09ubHkpIHJldHVybiBiaW5kaW5nLmNvbnN0YW50O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RoaXNFeHByZXNzaW9uKG5vZGUpIHx8IGlzTWV0YVByb3BlcnR5KG5vZGUpIHx8IGlzVG9waWNSZWZlcmVuY2Uobm9kZSkgfHwgaXNQcml2YXRlTmFtZShub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0NsYXNzKG5vZGUpKSB7XG4gICAgICB2YXIgX25vZGUkZGVjb3JhdG9ycztcbiAgICAgIGlmIChub2RlLnN1cGVyQ2xhc3MgJiYgIXRoaXMuaXNQdXJlKG5vZGUuc3VwZXJDbGFzcywgY29uc3RhbnRzT25seSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCgoX25vZGUkZGVjb3JhdG9ycyA9IG5vZGUuZGVjb3JhdG9ycykgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGRlY29yYXRvcnMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNQdXJlKG5vZGUuYm9keSwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc0NsYXNzQm9keShub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygbm9kZS5ib2R5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1B1cmUobWV0aG9kLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc0JpbmFyeShub2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNQdXJlKG5vZGUubGVmdCwgY29uc3RhbnRzT25seSkgJiYgdGhpcy5pc1B1cmUobm9kZS5yaWdodCwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5RXhwcmVzc2lvbihub2RlKSB8fCBpc1R1cGxlRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIG5vZGUuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGVsZW0gIT09IG51bGwgJiYgIXRoaXMuaXNQdXJlKGVsZW0sIGNvbnN0YW50c09ubHkpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0RXhwcmVzc2lvbihub2RlKSB8fCBpc1JlY29yZEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBub2RlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHVyZShwcm9wLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc01ldGhvZChub2RlKSkge1xuICAgICAgdmFyIF9ub2RlJGRlY29yYXRvcnMyO1xuICAgICAgaWYgKG5vZGUuY29tcHV0ZWQgJiYgIXRoaXMuaXNQdXJlKG5vZGUua2V5LCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCgoX25vZGUkZGVjb3JhdG9yczIgPSBub2RlLmRlY29yYXRvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRkZWNvcmF0b3JzMi5sZW5ndGgpID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzUHJvcGVydHkobm9kZSkpIHtcbiAgICAgIHZhciBfbm9kZSRkZWNvcmF0b3JzMztcbiAgICAgIGlmIChub2RlLmNvbXB1dGVkICYmICF0aGlzLmlzUHVyZShub2RlLmtleSwgY29uc3RhbnRzT25seSkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICgoKF9ub2RlJGRlY29yYXRvcnMzID0gbm9kZS5kZWNvcmF0b3JzKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkZGVjb3JhdG9yczMubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0UHJvcGVydHkobm9kZSkgfHwgbm9kZS5zdGF0aWMpIHtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgIT09IG51bGwgJiYgIXRoaXMuaXNQdXJlKG5vZGUudmFsdWUsIGNvbnN0YW50c09ubHkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGlzVW5hcnlFeHByZXNzaW9uKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1B1cmUobm9kZS5hcmd1bWVudCwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc1RlbXBsYXRlTGl0ZXJhbChub2RlKSkge1xuICAgICAgZm9yIChjb25zdCBleHByZXNzaW9uIG9mIG5vZGUuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUHVyZShleHByZXNzaW9uLCBjb25zdGFudHNPbmx5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNQYXR0ZXJuKG5vZGUudGFnLCBcIlN0cmluZy5yYXdcIikgJiYgIXRoaXMuaGFzQmluZGluZyhcIlN0cmluZ1wiLCB7XG4gICAgICAgIG5vR2xvYmFsczogdHJ1ZVxuICAgICAgfSkgJiYgdGhpcy5pc1B1cmUobm9kZS5xdWFzaSwgY29uc3RhbnRzT25seSk7XG4gICAgfSBlbHNlIGlmIChpc01lbWJlckV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiAhbm9kZS5jb21wdXRlZCAmJiBpc0lkZW50aWZpZXIobm9kZS5vYmplY3QpICYmIG5vZGUub2JqZWN0Lm5hbWUgPT09IFwiU3ltYm9sXCIgJiYgaXNJZGVudGlmaWVyKG5vZGUucHJvcGVydHkpICYmIG5vZGUucHJvcGVydHkubmFtZSAhPT0gXCJmb3JcIiAmJiAhdGhpcy5oYXNCaW5kaW5nKFwiU3ltYm9sXCIsIHtcbiAgICAgICAgbm9HbG9iYWxzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzQ2FsbEV4cHJlc3Npb24obm9kZSkpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzUGF0dGVybihub2RlLmNhbGxlZSwgXCJTeW1ib2wuZm9yXCIpICYmICF0aGlzLmhhc0JpbmRpbmcoXCJTeW1ib2xcIiwge1xuICAgICAgICBub0dsb2JhbHM6IHRydWVcbiAgICAgIH0pICYmIG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0LmlzU3RyaW5nTGl0ZXJhbChub2RlLmFyZ3VtZW50c1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpc1B1cmVpc2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHNldERhdGEoa2V5LCB2YWwpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhW2tleV0gPSB2YWw7XG4gIH1cbiAgZ2V0RGF0YShrZXkpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSByZXR1cm4gZGF0YTtcbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gIH1cbiAgcmVtb3ZlRGF0YShrZXkpIHtcbiAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBzY29wZS5kYXRhW2tleV07XG4gICAgICBpZiAoZGF0YSAhPSBudWxsKSBzY29wZS5kYXRhW2tleV0gPSBudWxsO1xuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBpbml0KCkge1xuICAgIGlmICghdGhpcy5pbml0ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuY3Jhd2woKTtcbiAgICB9XG4gIH1cbiAgY3Jhd2woKSB7XG4gICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aDtcbiAgICB0aGlzLnJlZmVyZW5jZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYmluZGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuZ2xvYmFscyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy51aWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IHByb2dyYW1QYXJlbnQgPSB0aGlzLmdldFByb2dyYW1QYXJlbnQoKTtcbiAgICBpZiAocHJvZ3JhbVBhcmVudC5jcmF3bGluZykgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgcmVmZXJlbmNlczogW10sXG4gICAgICBjb25zdGFudFZpb2xhdGlvbnM6IFtdLFxuICAgICAgYXNzaWdubWVudHM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmNyYXdsaW5nID0gdHJ1ZTtcbiAgICBpZiAocGF0aC50eXBlICE9PSBcIlByb2dyYW1cIiAmJiAoMCwgX3Zpc2l0b3JzLmlzRXhwbG9kZWRWaXNpdG9yKShjb2xsZWN0b3JWaXNpdG9yKSkge1xuICAgICAgZm9yIChjb25zdCB2aXNpdCBvZiBjb2xsZWN0b3JWaXNpdG9yLmVudGVyKSB7XG4gICAgICAgIHZpc2l0LmNhbGwoc3RhdGUsIHBhdGgsIHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGVWaXNpdG9ycyA9IGNvbGxlY3RvclZpc2l0b3JbcGF0aC50eXBlXTtcbiAgICAgIGlmICh0eXBlVmlzaXRvcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB2aXNpdCBvZiB0eXBlVmlzaXRvcnMuZW50ZXIpIHtcbiAgICAgICAgICB2aXNpdC5jYWxsKHN0YXRlLCBwYXRoLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC50cmF2ZXJzZShjb2xsZWN0b3JWaXNpdG9yLCBzdGF0ZSk7XG4gICAgdGhpcy5jcmF3bGluZyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBzdGF0ZS5hc3NpZ25tZW50cykge1xuICAgICAgY29uc3QgaWRzID0gcGF0aC5nZXRBc3NpZ25tZW50SWRlbnRpZmllcnMoKTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhpZHMpKSB7XG4gICAgICAgIGlmIChwYXRoLnNjb3BlLmdldEJpbmRpbmcobmFtZSkpIGNvbnRpbnVlO1xuICAgICAgICBwcm9ncmFtUGFyZW50LmFkZEdsb2JhbChpZHNbbmFtZV0pO1xuICAgICAgfVxuICAgICAgcGF0aC5zY29wZS5yZWdpc3RlckNvbnN0YW50VmlvbGF0aW9uKHBhdGgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBzdGF0ZS5yZWZlcmVuY2VzKSB7XG4gICAgICBjb25zdCBiaW5kaW5nID0gcmVmLnNjb3BlLmdldEJpbmRpbmcocmVmLm5vZGUubmFtZSk7XG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBiaW5kaW5nLnJlZmVyZW5jZShyZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvZ3JhbVBhcmVudC5hZGRHbG9iYWwocmVmLm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhdGggb2Ygc3RhdGUuY29uc3RhbnRWaW9sYXRpb25zKSB7XG4gICAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQ29uc3RhbnRWaW9sYXRpb24ocGF0aCk7XG4gICAgfVxuICB9XG4gIHB1c2gob3B0cykge1xuICAgIGxldCBwYXRoID0gdGhpcy5wYXRoO1xuICAgIGlmIChwYXRoLmlzUGF0dGVybigpKSB7XG4gICAgICBwYXRoID0gdGhpcy5nZXRQYXR0ZXJuUGFyZW50KCkucGF0aDtcbiAgICB9IGVsc2UgaWYgKCFwYXRoLmlzQmxvY2tTdGF0ZW1lbnQoKSAmJiAhcGF0aC5pc1Byb2dyYW0oKSkge1xuICAgICAgcGF0aCA9IHRoaXMuZ2V0QmxvY2tQYXJlbnQoKS5wYXRoO1xuICAgIH1cbiAgICBpZiAocGF0aC5pc1N3aXRjaFN0YXRlbWVudCgpKSB7XG4gICAgICBwYXRoID0gKHRoaXMuZ2V0RnVuY3Rpb25QYXJlbnQoKSB8fCB0aGlzLmdldFByb2dyYW1QYXJlbnQoKSkucGF0aDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgaW5pdCxcbiAgICAgIHVuaXF1ZSxcbiAgICAgIGtpbmQgPSBcInZhclwiLFxuICAgICAgaWRcbiAgICB9ID0gb3B0cztcbiAgICBpZiAoIWluaXQgJiYgIXVuaXF1ZSAmJiAoa2luZCA9PT0gXCJ2YXJcIiB8fCBraW5kID09PSBcImxldFwiKSAmJiBwYXRoLmlzRnVuY3Rpb24oKSAmJiAhcGF0aC5ub2RlLm5hbWUgJiYgaXNDYWxsRXhwcmVzc2lvbihwYXRoLnBhcmVudCwge1xuICAgICAgY2FsbGVlOiBwYXRoLm5vZGVcbiAgICB9KSAmJiBwYXRoLnBhcmVudC5hcmd1bWVudHMubGVuZ3RoIDw9IHBhdGgubm9kZS5wYXJhbXMubGVuZ3RoICYmIGlzSWRlbnRpZmllcihpZCkpIHtcbiAgICAgIHBhdGgucHVzaENvbnRhaW5lcihcInBhcmFtc1wiLCBpZCk7XG4gICAgICBwYXRoLnNjb3BlLnJlZ2lzdGVyQmluZGluZyhcInBhcmFtXCIsIHBhdGguZ2V0KFwicGFyYW1zXCIpW3BhdGgubm9kZS5wYXJhbXMubGVuZ3RoIC0gMV0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGF0aC5pc0xvb3AoKSB8fCBwYXRoLmlzQ2F0Y2hDbGF1c2UoKSB8fCBwYXRoLmlzRnVuY3Rpb24oKSkge1xuICAgICAgcGF0aC5lbnN1cmVCbG9jaygpO1xuICAgICAgcGF0aCA9IHBhdGguZ2V0KFwiYm9keVwiKTtcbiAgICB9XG4gICAgY29uc3QgYmxvY2tIb2lzdCA9IG9wdHMuX2Jsb2NrSG9pc3QgPT0gbnVsbCA/IDIgOiBvcHRzLl9ibG9ja0hvaXN0O1xuICAgIGNvbnN0IGRhdGFLZXkgPSBgZGVjbGFyYXRpb246JHtraW5kfToke2Jsb2NrSG9pc3R9YDtcbiAgICBsZXQgZGVjbGFyUGF0aCA9ICF1bmlxdWUgJiYgcGF0aC5nZXREYXRhKGRhdGFLZXkpO1xuICAgIGlmICghZGVjbGFyUGF0aCkge1xuICAgICAgY29uc3QgZGVjbGFyID0gdmFyaWFibGVEZWNsYXJhdGlvbihraW5kLCBbXSk7XG4gICAgICBkZWNsYXIuX2Jsb2NrSG9pc3QgPSBibG9ja0hvaXN0O1xuICAgICAgW2RlY2xhclBhdGhdID0gcGF0aC51bnNoaWZ0Q29udGFpbmVyKFwiYm9keVwiLCBbZGVjbGFyXSk7XG4gICAgICBpZiAoIXVuaXF1ZSkgcGF0aC5zZXREYXRhKGRhdGFLZXksIGRlY2xhclBhdGgpO1xuICAgIH1cbiAgICBjb25zdCBkZWNsYXJhdG9yID0gdmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0KTtcbiAgICBjb25zdCBsZW4gPSBkZWNsYXJQYXRoLm5vZGUuZGVjbGFyYXRpb25zLnB1c2goZGVjbGFyYXRvcik7XG4gICAgcGF0aC5zY29wZS5yZWdpc3RlckJpbmRpbmcoa2luZCwgZGVjbGFyUGF0aC5nZXQoXCJkZWNsYXJhdGlvbnNcIilbbGVuIC0gMV0pO1xuICB9XG4gIGdldFByb2dyYW1QYXJlbnQoKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoc2NvcGUucGF0aC5pc1Byb2dyYW0oKSkge1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBQcm9ncmFtXCIpO1xuICB9XG4gIGdldEZ1bmN0aW9uUGFyZW50KCkge1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnBhdGguaXNGdW5jdGlvblBhcmVudCgpKSB7XG4gICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChzY29wZSA9IHNjb3BlLnBhcmVudCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0QmxvY2tQYXJlbnQoKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoc2NvcGUucGF0aC5pc0Jsb2NrUGFyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjb3VsZG4ndCBmaW5kIGEgQmxvY2tTdGF0ZW1lbnQsIEZvciwgU3dpdGNoLCBGdW5jdGlvbiwgTG9vcCBvciBQcm9ncmFtLi4uXCIpO1xuICB9XG4gIGdldFBhdHRlcm5QYXJlbnQoKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBpZiAoIXNjb3BlLnBhdGguaXNQYXR0ZXJuKCkpIHtcbiAgICAgICAgcmV0dXJuIHNjb3BlLmdldEJsb2NrUGFyZW50KCk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQucGFyZW50KTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZSBjb3VsZG4ndCBmaW5kIGEgQmxvY2tTdGF0ZW1lbnQsIEZvciwgU3dpdGNoLCBGdW5jdGlvbiwgTG9vcCBvciBQcm9ncmFtLi4uXCIpO1xuICB9XG4gIGdldEFsbEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBkbyB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZS5iaW5kaW5ncykpIHtcbiAgICAgICAgaWYgKGtleSBpbiBpZHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWRzW2tleV0gPSBzY29wZS5iaW5kaW5nc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzY29wZSA9IHNjb3BlLnBhcmVudDtcbiAgICB9IHdoaWxlIChzY29wZSk7XG4gICAgcmV0dXJuIGlkcztcbiAgfVxuICBiaW5kaW5nSWRlbnRpZmllckVxdWFscyhuYW1lLCBub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QmluZGluZ0lkZW50aWZpZXIobmFtZSkgPT09IG5vZGU7XG4gIH1cbiAgZ2V0QmluZGluZyhuYW1lKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcztcbiAgICBsZXQgcHJldmlvdXNQYXRoO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSBzY29wZS5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICAgICAgaWYgKGJpbmRpbmcpIHtcbiAgICAgICAgdmFyIF9wcmV2aW91c1BhdGg7XG4gICAgICAgIGlmICgoX3ByZXZpb3VzUGF0aCA9IHByZXZpb3VzUGF0aCkgIT0gbnVsbCAmJiBfcHJldmlvdXNQYXRoLmlzUGF0dGVybigpICYmIGJpbmRpbmcua2luZCAhPT0gXCJwYXJhbVwiICYmIGJpbmRpbmcua2luZCAhPT0gXCJsb2NhbFwiKSB7fSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gYmluZGluZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghYmluZGluZyAmJiBuYW1lID09PSBcImFyZ3VtZW50c1wiICYmIHNjb3BlLnBhdGguaXNGdW5jdGlvbigpICYmICFzY29wZS5wYXRoLmlzQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24oKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzUGF0aCA9IHNjb3BlLnBhdGg7XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICB9XG4gIGdldE93bkJpbmRpbmcobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICB9XG4gIGdldEJpbmRpbmdJZGVudGlmaWVyKG5hbWUpIHtcbiAgICB2YXIgX3RoaXMkZ2V0QmluZGluZzI7XG4gICAgcmV0dXJuIChfdGhpcyRnZXRCaW5kaW5nMiA9IHRoaXMuZ2V0QmluZGluZyhuYW1lKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGdldEJpbmRpbmcyLmlkZW50aWZpZXI7XG4gIH1cbiAgZ2V0T3duQmluZGluZ0lkZW50aWZpZXIobmFtZSkge1xuICAgIGNvbnN0IGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW25hbWVdO1xuICAgIHJldHVybiBiaW5kaW5nID09IG51bGwgPyB2b2lkIDAgOiBiaW5kaW5nLmlkZW50aWZpZXI7XG4gIH1cbiAgaGFzT3duQmluZGluZyhuYW1lKSB7XG4gICAgcmV0dXJuICEhdGhpcy5nZXRPd25CaW5kaW5nKG5hbWUpO1xuICB9XG4gIGhhc0JpbmRpbmcobmFtZSwgb3B0cykge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLmhhc093bkJpbmRpbmcobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoc2NvcGUgPSBzY29wZS5wYXJlbnQpO1xuICAgIGxldCBub0dsb2JhbHM7XG4gICAgbGV0IG5vVWlkcztcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIG5vR2xvYmFscyA9IG9wdHMubm9HbG9iYWxzO1xuICAgICAgbm9VaWRzID0gb3B0cy5ub1VpZHM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIG5vR2xvYmFscyA9IG9wdHM7XG4gICAgfVxuICAgIGlmICghbm9VaWRzICYmIHRoaXMuaGFzVWlkKG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIW5vR2xvYmFscyAmJiBTY29wZS5nbG9iYWxzLmluY2x1ZGVzKG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIW5vR2xvYmFscyAmJiBTY29wZS5jb250ZXh0VmFyaWFibGVzLmluY2x1ZGVzKG5hbWUpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGFyZW50SGFzQmluZGluZyhuYW1lLCBvcHRzKSB7XG4gICAgdmFyIF90aGlzJHBhcmVudDtcbiAgICByZXR1cm4gKF90aGlzJHBhcmVudCA9IHRoaXMucGFyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGFyZW50Lmhhc0JpbmRpbmcobmFtZSwgb3B0cyk7XG4gIH1cbiAgbW92ZUJpbmRpbmdUbyhuYW1lLCBzY29wZSkge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEJpbmRpbmcobmFtZSk7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGluZm8uc2NvcGUucmVtb3ZlT3duQmluZGluZyhuYW1lKTtcbiAgICAgIGluZm8uc2NvcGUgPSBzY29wZTtcbiAgICAgIHNjb3BlLmJpbmRpbmdzW25hbWVdID0gaW5mbztcbiAgICB9XG4gIH1cbiAgcmVtb3ZlT3duQmluZGluZyhuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbbmFtZV07XG4gIH1cbiAgcmVtb3ZlQmluZGluZyhuYW1lKSB7XG4gICAgdmFyIF90aGlzJGdldEJpbmRpbmczO1xuICAgIChfdGhpcyRnZXRCaW5kaW5nMyA9IHRoaXMuZ2V0QmluZGluZyhuYW1lKSkgPT0gbnVsbCB8fCBfdGhpcyRnZXRCaW5kaW5nMy5zY29wZS5yZW1vdmVPd25CaW5kaW5nKG5hbWUpO1xuICAgIGxldCBzY29wZSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKHNjb3BlLnVpZHNbbmFtZV0pIHtcbiAgICAgICAgc2NvcGUudWlkc1tuYW1lXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHNjb3BlID0gc2NvcGUucGFyZW50KTtcbiAgfVxuICBob2lzdFZhcmlhYmxlcyhlbWl0ID0gaWQgPT4gdGhpcy5wdXNoKHtcbiAgICBpZFxuICB9KSkge1xuICAgIHRoaXMuY3Jhd2woKTtcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyh0aGlzLmJpbmRpbmdzKSkge1xuICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuYmluZGluZ3NbbmFtZV07XG4gICAgICBpZiAoIWJpbmRpbmcpIGNvbnRpbnVlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwYXRoXG4gICAgICB9ID0gYmluZGluZztcbiAgICAgIGlmICghcGF0aC5pc1ZhcmlhYmxlRGVjbGFyYXRvcigpKSBjb250aW51ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBwYXJlbnRQYXRoXG4gICAgICB9ID0gcGF0aDtcbiAgICAgIGlmIChwYXJlbnQua2luZCAhPT0gXCJ2YXJcIiB8fCBzZWVuLmhhcyhwYXJlbnQpKSBjb250aW51ZTtcbiAgICAgIHNlZW4uYWRkKHBhdGgucGFyZW50KTtcbiAgICAgIGxldCBmaXJzdElkO1xuICAgICAgY29uc3QgaW5pdCA9IFtdO1xuICAgICAgZm9yIChjb25zdCBkZWNsIG9mIHBhcmVudC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIF9maXJzdElkO1xuICAgICAgICAoX2ZpcnN0SWQgPSBmaXJzdElkKSAhPSBudWxsID8gX2ZpcnN0SWQgOiBmaXJzdElkID0gZGVjbC5pZDtcbiAgICAgICAgaWYgKGRlY2wuaW5pdCkge1xuICAgICAgICAgIGluaXQucHVzaChhc3NpZ25tZW50RXhwcmVzc2lvbihcIj1cIiwgZGVjbC5pZCwgZGVjbC5pbml0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWRzID0gT2JqZWN0LmtleXMoZ2V0QmluZGluZ0lkZW50aWZpZXJzKGRlY2wsIGZhbHNlLCB0cnVlLCB0cnVlKSk7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBpZHMpIHtcbiAgICAgICAgICBlbWl0KGlkZW50aWZpZXIobmFtZSksIGRlY2wuaW5pdCAhPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFBhdGgucGFyZW50UGF0aC5pc0Zvcih7XG4gICAgICAgIGxlZnQ6IHBhcmVudFxuICAgICAgfSkpIHtcbiAgICAgICAgcGFyZW50UGF0aC5yZXBsYWNlV2l0aChmaXJzdElkKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5pdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcGFyZW50UGF0aC5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGV4cHIgPSBpbml0Lmxlbmd0aCA9PT0gMSA/IGluaXRbMF0gOiBzZXF1ZW5jZUV4cHJlc3Npb24oaW5pdCk7XG4gICAgICAgIGlmIChwYXJlbnRQYXRoLnBhcmVudFBhdGguaXNGb3JTdGF0ZW1lbnQoe1xuICAgICAgICAgIGluaXQ6IHBhcmVudFxuICAgICAgICB9KSkge1xuICAgICAgICAgIHBhcmVudFBhdGgucmVwbGFjZVdpdGgoZXhwcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50UGF0aC5yZXBsYWNlV2l0aChleHByZXNzaW9uU3RhdGVtZW50KGV4cHIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2NvcGU7XG5TY29wZS5nbG9iYWxzID0gT2JqZWN0LmtleXMoX2dsb2JhbHMuYnVpbHRpbik7XG5TY29wZS5jb250ZXh0VmFyaWFibGVzID0gW1wiYXJndW1lbnRzXCIsIFwidW5kZWZpbmVkXCIsIFwiSW5maW5pdHlcIiwgXCJOYU5cIl07XG57XG4gIFNjb3BlLnByb3RvdHlwZS5fcmVuYW1lRnJvbU1hcCA9IGZ1bmN0aW9uIF9yZW5hbWVGcm9tTWFwKG1hcCwgb2xkTmFtZSwgbmV3TmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobWFwW29sZE5hbWVdKSB7XG4gICAgICBtYXBbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICAgIG1hcFtvbGROYW1lXSA9IG51bGw7XG4gICAgfVxuICB9O1xuICBTY29wZS5wcm90b3R5cGUudHJhdmVyc2UgPSBmdW5jdGlvbiAobm9kZSwgb3B0cywgc3RhdGUpIHtcbiAgICAoMCwgX2luZGV4LmRlZmF1bHQpKG5vZGUsIG9wdHMsIHRoaXMsIHN0YXRlLCB0aGlzLnBhdGgpO1xuICB9O1xuICBTY29wZS5wcm90b3R5cGUuX2dlbmVyYXRlVWlkID0gZnVuY3Rpb24gX2dlbmVyYXRlVWlkKG5hbWUsIGkpIHtcbiAgICBsZXQgaWQgPSBuYW1lO1xuICAgIGlmIChpID4gMSkgaWQgKz0gaTtcbiAgICByZXR1cm4gYF8ke2lkfWA7XG4gIH07XG4gIFNjb3BlLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShub2RlLCBpLCBhcnJheUxpa2VJc0l0ZXJhYmxlKSB7XG4gICAgaWYgKGlzSWRlbnRpZmllcihub2RlKSkge1xuICAgICAgY29uc3QgYmluZGluZyA9IHRoaXMuZ2V0QmluZGluZyhub2RlLm5hbWUpO1xuICAgICAgaWYgKGJpbmRpbmcgIT0gbnVsbCAmJiBiaW5kaW5nLmNvbnN0YW50ICYmIGJpbmRpbmcucGF0aC5pc0dlbmVyaWNUeXBlKFwiQXJyYXlcIikpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0FycmF5RXhwcmVzc2lvbihub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGlmIChpc0lkZW50aWZpZXIobm9kZSwge1xuICAgICAgbmFtZTogXCJhcmd1bWVudHNcIlxuICAgIH0pKSB7XG4gICAgICByZXR1cm4gY2FsbEV4cHJlc3Npb24obWVtYmVyRXhwcmVzc2lvbihtZW1iZXJFeHByZXNzaW9uKG1lbWJlckV4cHJlc3Npb24oaWRlbnRpZmllcihcIkFycmF5XCIpLCBpZGVudGlmaWVyKFwicHJvdG90eXBlXCIpKSwgaWRlbnRpZmllcihcInNsaWNlXCIpKSwgaWRlbnRpZmllcihcImNhbGxcIikpLCBbbm9kZV0pO1xuICAgIH1cbiAgICBsZXQgaGVscGVyTmFtZTtcbiAgICBjb25zdCBhcmdzID0gW25vZGVdO1xuICAgIGlmIChpID09PSB0cnVlKSB7XG4gICAgICBoZWxwZXJOYW1lID0gXCJ0b0NvbnN1bWFibGVBcnJheVwiO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFyZ3MucHVzaChudW1lcmljTGl0ZXJhbChpKSk7XG4gICAgICBoZWxwZXJOYW1lID0gXCJzbGljZWRUb0FycmF5XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlck5hbWUgPSBcInRvQXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKGFycmF5TGlrZUlzSXRlcmFibGUpIHtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLnBhdGguaHViLmFkZEhlbHBlcihoZWxwZXJOYW1lKSk7XG4gICAgICBoZWxwZXJOYW1lID0gXCJtYXliZUFycmF5TGlrZVwiO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbEV4cHJlc3Npb24odGhpcy5wYXRoLmh1Yi5hZGRIZWxwZXIoaGVscGVyTmFtZSksIGFyZ3MpO1xuICB9O1xuICBTY29wZS5wcm90b3R5cGUuZ2V0QWxsQmluZGluZ3NPZktpbmQgPSBmdW5jdGlvbiBnZXRBbGxCaW5kaW5nc09mS2luZCguLi5raW5kcykge1xuICAgIGNvbnN0IGlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChjb25zdCBraW5kIG9mIGtpbmRzKSB7XG4gICAgICBsZXQgc2NvcGUgPSB0aGlzO1xuICAgICAgZG8ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoc2NvcGUuYmluZGluZ3MpKSB7XG4gICAgICAgICAgY29uc3QgYmluZGluZyA9IHNjb3BlLmJpbmRpbmdzW25hbWVdO1xuICAgICAgICAgIGlmIChiaW5kaW5nLmtpbmQgPT09IGtpbmQpIGlkc1tuYW1lXSA9IGJpbmRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChzY29wZSk7XG4gICAgfVxuICAgIHJldHVybiBpZHM7XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNjb3BlLnByb3RvdHlwZSwge1xuICAgIHBhcmVudEJsb2NrOiB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoLnBhcmVudDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGh1Yjoge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aC5odWI7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///86814\n')},23874:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar t = __webpack_require__(2352);\nvar _t = t;\nvar _traverseNode = __webpack_require__(22264);\nvar _visitors = __webpack_require__(34950);\nvar _context = __webpack_require__(79578);\nconst {\n  getAssignmentIdentifiers\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      path.skip();\n      if (path.isMethod()) {\n        if (!path.requeueComputedKeyAndDecorators) {\n          _context.requeueComputedKeyAndDecorators.call(path);\n        } else {\n          path.requeueComputedKeyAndDecorators();\n        }\n      }\n    }\n  },\n  ObjectProperty({\n    node,\n    scope\n  }, state) {\n    const {\n      name\n    } = node.key;\n    if (node.shorthand && (name === state.oldName || name === state.newName) && scope.getBindingIdentifier(name) === state.binding.identifier) {\n      node.shorthand = false;\n      {\n        var _node$extra;\n        if ((_node$extra = node.extra) != null && _node$extra.shorthand) node.extra.shorthand = false;\n      }\n    }\n  },\n  "AssignmentExpression|Declaration|VariableDeclarator"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.isAssignmentExpression() ? getAssignmentIdentifiers(path.node) : path.getOuterBindingIdentifiers();\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n    if (maybeExportDeclar.isExportDefaultDeclaration()) {\n      const {\n        declaration\n      } = maybeExportDeclar.node;\n      if (t.isDeclaration(declaration) && !declaration.id) {\n        return;\n      }\n    }\n    if (maybeExportDeclar.isExportAllDeclaration()) {\n      return;\n    }\n    maybeExportDeclar.splitExportDeclaration();\n  }\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return path;\n  }\n  maybeConvertFromClassFunctionExpression(path) {\n    return path;\n  }\n  rename() {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n    const blockToTraverse = arguments[0] || scope.block;\n    const skipKeys = {\n      discriminant: true\n    };\n    if (t.isMethod(blockToTraverse)) {\n      if (blockToTraverse.computed) {\n        skipKeys.key = true;\n      }\n      if (!t.isObjectMethod(blockToTraverse)) {\n        skipKeys.decorators = true;\n      }\n    }\n    (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);\n    if (!arguments[0]) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(path);\n      this.maybeConvertFromClassFunctionExpression(path);\n    }\n  }\n}\nexports["default"] = Renamer;\n\n//# sourceMappingURL=renamer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4NzQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixRQUFRLG1CQUFPLENBQUMsSUFBYztBQUM5QjtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLEtBQXdCO0FBQ3BELGdCQUFnQixtQkFBTyxDQUFDLEtBQW1CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxLQUF1QjtBQUM5QztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7O0FBRWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvc2NvcGUvbGliL3JlbmFtZXIuanM/ZWZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciB0ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbnZhciBfdCA9IHQ7XG52YXIgX3RyYXZlcnNlTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi90cmF2ZXJzZS1ub2RlLmpzXCIpO1xudmFyIF92aXNpdG9ycyA9IHJlcXVpcmUoXCIuLi8uLi92aXNpdG9ycy5qc1wiKTtcbnZhciBfY29udGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9wYXRoL2NvbnRleHQuanNcIik7XG5jb25zdCB7XG4gIGdldEFzc2lnbm1lbnRJZGVudGlmaWVyc1xufSA9IF90O1xuY29uc3QgcmVuYW1lVmlzaXRvciA9IHtcbiAgUmVmZXJlbmNlZElkZW50aWZpZXIoe1xuICAgIG5vZGVcbiAgfSwgc3RhdGUpIHtcbiAgICBpZiAobm9kZS5uYW1lID09PSBzdGF0ZS5vbGROYW1lKSB7XG4gICAgICBub2RlLm5hbWUgPSBzdGF0ZS5uZXdOYW1lO1xuICAgIH1cbiAgfSxcbiAgU2NvcGUocGF0aCwgc3RhdGUpIHtcbiAgICBpZiAoIXBhdGguc2NvcGUuYmluZGluZ0lkZW50aWZpZXJFcXVhbHMoc3RhdGUub2xkTmFtZSwgc3RhdGUuYmluZGluZy5pZGVudGlmaWVyKSkge1xuICAgICAgcGF0aC5za2lwKCk7XG4gICAgICBpZiAocGF0aC5pc01ldGhvZCgpKSB7XG4gICAgICAgIGlmICghcGF0aC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKSB7XG4gICAgICAgICAgX2NvbnRleHQucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycy5jYWxsKHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGgucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBPYmplY3RQcm9wZXJ0eSh7XG4gICAgbm9kZSxcbiAgICBzY29wZVxuICB9LCBzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gbm9kZS5rZXk7XG4gICAgaWYgKG5vZGUuc2hvcnRoYW5kICYmIChuYW1lID09PSBzdGF0ZS5vbGROYW1lIHx8IG5hbWUgPT09IHN0YXRlLm5ld05hbWUpICYmIHNjb3BlLmdldEJpbmRpbmdJZGVudGlmaWVyKG5hbWUpID09PSBzdGF0ZS5iaW5kaW5nLmlkZW50aWZpZXIpIHtcbiAgICAgIG5vZGUuc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgICB7XG4gICAgICAgIHZhciBfbm9kZSRleHRyYTtcbiAgICAgICAgaWYgKChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEuc2hvcnRoYW5kKSBub2RlLmV4dHJhLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCJBc3NpZ25tZW50RXhwcmVzc2lvbnxEZWNsYXJhdGlvbnxWYXJpYWJsZURlY2xhcmF0b3JcIihwYXRoLCBzdGF0ZSkge1xuICAgIGlmIChwYXRoLmlzVmFyaWFibGVEZWNsYXJhdGlvbigpKSByZXR1cm47XG4gICAgY29uc3QgaWRzID0gcGF0aC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKCkgPyBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnMocGF0aC5ub2RlKSA6IHBhdGguZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMoKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gaWRzKSB7XG4gICAgICBpZiAobmFtZSA9PT0gc3RhdGUub2xkTmFtZSkgaWRzW25hbWVdLm5hbWUgPSBzdGF0ZS5uZXdOYW1lO1xuICAgIH1cbiAgfVxufTtcbmNsYXNzIFJlbmFtZXIge1xuICBjb25zdHJ1Y3RvcihiaW5kaW5nLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgdGhpcy5uZXdOYW1lID0gbmV3TmFtZTtcbiAgICB0aGlzLm9sZE5hbWUgPSBvbGROYW1lO1xuICAgIHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUV4cG9ydERlY2xhcmF0aW9uKHBhcmVudERlY2xhcikge1xuICAgIGNvbnN0IG1heWJlRXhwb3J0RGVjbGFyID0gcGFyZW50RGVjbGFyLnBhcmVudFBhdGg7XG4gICAgaWYgKCFtYXliZUV4cG9ydERlY2xhci5pc0V4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1heWJlRXhwb3J0RGVjbGFyLmlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGVjbGFyYXRpb25cbiAgICAgIH0gPSBtYXliZUV4cG9ydERlY2xhci5ub2RlO1xuICAgICAgaWYgKHQuaXNEZWNsYXJhdGlvbihkZWNsYXJhdGlvbikgJiYgIWRlY2xhcmF0aW9uLmlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1heWJlRXhwb3J0RGVjbGFyLmlzRXhwb3J0QWxsRGVjbGFyYXRpb24oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXliZUV4cG9ydERlY2xhci5zcGxpdEV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUNsYXNzRnVuY3Rpb25EZWNsYXJhdGlvbihwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgbWF5YmVDb252ZXJ0RnJvbUNsYXNzRnVuY3Rpb25FeHByZXNzaW9uKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuICByZW5hbWUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYmluZGluZyxcbiAgICAgIG9sZE5hbWUsXG4gICAgICBuZXdOYW1lXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgc2NvcGUsXG4gICAgICBwYXRoXG4gICAgfSA9IGJpbmRpbmc7XG4gICAgY29uc3QgcGFyZW50RGVjbGFyID0gcGF0aC5maW5kKHBhdGggPT4gcGF0aC5pc0RlY2xhcmF0aW9uKCkgfHwgcGF0aC5pc0Z1bmN0aW9uRXhwcmVzc2lvbigpIHx8IHBhdGguaXNDbGFzc0V4cHJlc3Npb24oKSk7XG4gICAgaWYgKHBhcmVudERlY2xhcikge1xuICAgICAgY29uc3QgYmluZGluZ0lkcyA9IHBhcmVudERlY2xhci5nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycygpO1xuICAgICAgaWYgKGJpbmRpbmdJZHNbb2xkTmFtZV0gPT09IGJpbmRpbmcuaWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLm1heWJlQ29udmVydEZyb21FeHBvcnREZWNsYXJhdGlvbihwYXJlbnREZWNsYXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBibG9ja1RvVHJhdmVyc2UgPSBhcmd1bWVudHNbMF0gfHwgc2NvcGUuYmxvY2s7XG4gICAgY29uc3Qgc2tpcEtleXMgPSB7XG4gICAgICBkaXNjcmltaW5hbnQ6IHRydWVcbiAgICB9O1xuICAgIGlmICh0LmlzTWV0aG9kKGJsb2NrVG9UcmF2ZXJzZSkpIHtcbiAgICAgIGlmIChibG9ja1RvVHJhdmVyc2UuY29tcHV0ZWQpIHtcbiAgICAgICAgc2tpcEtleXMua2V5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdC5pc09iamVjdE1ldGhvZChibG9ja1RvVHJhdmVyc2UpKSB7XG4gICAgICAgIHNraXBLZXlzLmRlY29yYXRvcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAoMCwgX3RyYXZlcnNlTm9kZS50cmF2ZXJzZU5vZGUpKGJsb2NrVG9UcmF2ZXJzZSwgKDAsIF92aXNpdG9ycy5leHBsb2RlKShyZW5hbWVWaXNpdG9yKSwgc2NvcGUsIHRoaXMsIHNjb3BlLnBhdGgsIHNraXBLZXlzKTtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgc2NvcGUucmVtb3ZlT3duQmluZGluZyhvbGROYW1lKTtcbiAgICAgIHNjb3BlLmJpbmRpbmdzW25ld05hbWVdID0gYmluZGluZztcbiAgICAgIHRoaXMuYmluZGluZy5pZGVudGlmaWVyLm5hbWUgPSBuZXdOYW1lO1xuICAgIH1cbiAgICBpZiAocGFyZW50RGVjbGFyKSB7XG4gICAgICB0aGlzLm1heWJlQ29udmVydEZyb21DbGFzc0Z1bmN0aW9uRGVjbGFyYXRpb24ocGF0aCk7XG4gICAgICB0aGlzLm1heWJlQ29udmVydEZyb21DbGFzc0Z1bmN0aW9uRXhwcmVzc2lvbihwYXRoKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJlbmFtZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmFtZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///23874\n')},22264:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.traverseNode = traverseNode;\nvar _context = __webpack_require__(1602);\nvar _t = __webpack_require__(2352);\nconst {\n  VISITOR_KEYS\n} = _t;\nfunction traverseNode(node, opts, scope, state, path, skipKeys, visitSelf) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n  const context = new _context.default(scope, opts, state, path);\n  if (visitSelf) {\n    if (skipKeys != null && skipKeys[path.parentKey]) return false;\n    return context.visitQueue([path]);\n  }\n  for (const key of keys) {\n    if (skipKeys != null && skipKeys[key]) continue;\n    if (context.visit(node, key)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=traverse-node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIyNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CO0FBQ3BCLGVBQWUsbUJBQU8sQ0FBQyxJQUFjO0FBQ3JDLFNBQVMsbUJBQU8sQ0FBQyxJQUFjO0FBQy9CO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90cmF2ZXJzZS9saWIvdHJhdmVyc2Utbm9kZS5qcz9hYTY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy50cmF2ZXJzZU5vZGUgPSB0cmF2ZXJzZU5vZGU7XG52YXIgX2NvbnRleHQgPSByZXF1aXJlKFwiLi9jb250ZXh0LmpzXCIpO1xudmFyIF90ID0gcmVxdWlyZShcIkBiYWJlbC90eXBlc1wiKTtcbmNvbnN0IHtcbiAgVklTSVRPUl9LRVlTXG59ID0gX3Q7XG5mdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgb3B0cywgc2NvcGUsIHN0YXRlLCBwYXRoLCBza2lwS2V5cywgdmlzaXRTZWxmKSB7XG4gIGNvbnN0IGtleXMgPSBWSVNJVE9SX0tFWVNbbm9kZS50eXBlXTtcbiAgaWYgKCFrZXlzKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGNvbnRleHQgPSBuZXcgX2NvbnRleHQuZGVmYXVsdChzY29wZSwgb3B0cywgc3RhdGUsIHBhdGgpO1xuICBpZiAodmlzaXRTZWxmKSB7XG4gICAgaWYgKHNraXBLZXlzICE9IG51bGwgJiYgc2tpcEtleXNbcGF0aC5wYXJlbnRLZXldKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNvbnRleHQudmlzaXRRdWV1ZShbcGF0aF0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBpZiAoc2tpcEtleXMgIT0gbnVsbCAmJiBza2lwS2V5c1trZXldKSBjb250aW51ZTtcbiAgICBpZiAoY29udGV4dC52aXNpdChub2RlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmF2ZXJzZS1ub2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22264\n')},34950:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.environmentVisitor = environmentVisitor;\nexports.explode = explode$1;\nexports.isExplodedVisitor = isExplodedVisitor;\nexports.merge = merge;\nexports.verify = verify$1;\nvar virtualTypes = __webpack_require__(75562);\nvar virtualTypesValidators = __webpack_require__(57973);\nvar _t = __webpack_require__(2352);\nvar _context = __webpack_require__(79578);\nconst {\n  DEPRECATED_KEYS,\n  DEPRECATED_ALIASES,\n  FLIPPED_ALIAS_KEYS,\n  TYPES,\n  __internal__deprecationWarning: deprecationWarning\n} = _t;\nfunction isVirtualType(type) {\n  return type in virtualTypes;\n}\nfunction isExplodedVisitor(visitor) {\n  return visitor == null ? void 0 : visitor._exploded;\n}\nfunction explode$1(visitor) {\n  if (isExplodedVisitor(visitor)) return visitor;\n  visitor._exploded = true;\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split("|");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n  verify$1(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    if (!isVirtualType(nodeType)) continue;\n    const fns = visitor[nodeType];\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(nodeType, fns[type]);\n    }\n    delete visitor[nodeType];\n    const types = virtualTypes[nodeType];\n    if (types !== null) {\n      for (const type of types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    if (nodeType in DEPRECATED_KEYS) {\n      const deprecatedKey = DEPRECATED_KEYS[nodeType];\n      deprecationWarning(nodeType, deprecatedKey, "Visitor ");\n      aliases = [deprecatedKey];\n    } else if (nodeType in DEPRECATED_ALIASES) {\n      const deprecatedAlias = DEPRECATED_ALIASES[nodeType];\n      deprecationWarning(nodeType, deprecatedAlias, "Visitor ");\n      aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];\n    }\n    if (!aliases) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n  return visitor;\n}\nfunction verify$1(visitor) {\n  if (visitor._verified) return;\n  if (typeof visitor === "function") {\n    throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn\'t mean `{ enter: Function }`?");\n  }\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === "enter" || nodeType === "exit") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n    if (shouldIgnoreKey(nodeType)) continue;\n    if (!TYPES.includes(nodeType)) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it\'s not a valid type in @babel/traverse ${"7.25.9"}`);\n    }\n    const visitors = visitor[nodeType];\n    if (typeof visitors === "object") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === "enter" || visitorKey === "exit") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error("You passed `traverse()` a visitor object with the property " + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n  visitor._verified = true;\n}\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n  for (const fn of fns) {\n    if (typeof fn !== "function") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\nfunction merge(visitors, states = [], wrapper) {\n  const mergedVisitor = {\n    _verified: true,\n    _exploded: true\n  };\n  {\n    Object.defineProperty(mergedVisitor, "_exploded", {\n      enumerable: false\n    });\n    Object.defineProperty(mergedVisitor, "_verified", {\n      enumerable: false\n    });\n  }\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = explode$1(visitors[i]);\n    const state = states[i];\n    let topVisitor = visitor;\n    if (state || wrapper) {\n      topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);\n    }\n    mergePair(mergedVisitor, topVisitor);\n    for (const key of Object.keys(visitor)) {\n      if (shouldIgnoreKey(key)) continue;\n      let typeVisitor = visitor[key];\n      if (state || wrapper) {\n        typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);\n      }\n      const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});\n      mergePair(nodeVisitor, typeVisitor);\n    }\n  }\n  return mergedVisitor;\n}\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n  for (const phase of ["enter", "exit"]) {\n    let fns = oldVisitor[phase];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n      if (state) {\n        newFn = function (path) {\n          fn.call(state, path, state);\n        };\n      }\n      if (wrapper) {\n        newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);\n      }\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n      return newFn;\n    });\n    newVisitor[phase] = fns;\n  }\n  return newVisitor;\n}\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n    if (typeof fns === "function") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\nfunction wrapCheck(nodeType, fn) {\n  const fnKey = `is${nodeType}`;\n  const validator = virtualTypesValidators[fnKey];\n  const newFn = function (path) {\n    if (validator.call(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n  newFn.toString = () => fn.toString();\n  return newFn;\n}\nfunction shouldIgnoreKey(key) {\n  if (key[0] === "_") return true;\n  if (key === "enter" || key === "exit" || key === "shouldSkip") return true;\n  if (key === "denylist" || key === "noScope" || key === "skipKeys") {\n    return true;\n  }\n  {\n    if (key === "blacklist") {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergePair(dest, src) {\n  for (const phase of ["enter", "exit"]) {\n    if (!src[phase]) continue;\n    dest[phase] = [].concat(dest[phase] || [], src[phase]);\n  }\n}\nconst _environmentVisitor = {\n  FunctionParent(path) {\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n    if (path.isMethod()) {\n      if (!path.requeueComputedKeyAndDecorators) {\n        _context.requeueComputedKeyAndDecorators.call(path);\n      } else {\n        path.requeueComputedKeyAndDecorators();\n      }\n    }\n  },\n  Property(path) {\n    if (path.isObjectProperty()) return;\n    path.skip();\n    if (!path.requeueComputedKeyAndDecorators) {\n      _context.requeueComputedKeyAndDecorators.call(path);\n    } else {\n      path.requeueComputedKeyAndDecorators();\n    }\n  }\n};\nfunction environmentVisitor(visitor) {\n  return merge([_environmentVisitor, visitor]);\n}\n\n//# sourceMappingURL=visitors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ5NTAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLGVBQWU7QUFDZix5QkFBeUI7QUFDekIsYUFBYTtBQUNiLGNBQWM7QUFDZCxtQkFBbUIsbUJBQU8sQ0FBQyxLQUE2QjtBQUN4RCw2QkFBNkIsbUJBQU8sQ0FBQyxLQUF1QztBQUM1RSxTQUFTLG1CQUFPLENBQUMsSUFBYztBQUMvQixlQUFlLG1CQUFPLENBQUMsS0FBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLGlCQUFpQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVLCtDQUErQyxTQUFTO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsU0FBUyxHQUFHLFdBQVc7QUFDM0QsVUFBVTtBQUNWLDZGQUE2RixVQUFVLGdDQUFnQyxXQUFXO0FBQ2xKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU0sWUFBWSxVQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHJhdmVyc2UvbGliL3Zpc2l0b3JzLmpzPzBmMjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVudmlyb25tZW50VmlzaXRvciA9IGVudmlyb25tZW50VmlzaXRvcjtcbmV4cG9ydHMuZXhwbG9kZSA9IGV4cGxvZGUkMTtcbmV4cG9ydHMuaXNFeHBsb2RlZFZpc2l0b3IgPSBpc0V4cGxvZGVkVmlzaXRvcjtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbmV4cG9ydHMudmVyaWZ5ID0gdmVyaWZ5JDE7XG52YXIgdmlydHVhbFR5cGVzID0gcmVxdWlyZShcIi4vcGF0aC9saWIvdmlydHVhbC10eXBlcy5qc1wiKTtcbnZhciB2aXJ0dWFsVHlwZXNWYWxpZGF0b3JzID0gcmVxdWlyZShcIi4vcGF0aC9saWIvdmlydHVhbC10eXBlcy12YWxpZGF0b3IuanNcIik7XG52YXIgX3QgPSByZXF1aXJlKFwiQGJhYmVsL3R5cGVzXCIpO1xudmFyIF9jb250ZXh0ID0gcmVxdWlyZShcIi4vcGF0aC9jb250ZXh0LmpzXCIpO1xuY29uc3Qge1xuICBERVBSRUNBVEVEX0tFWVMsXG4gIERFUFJFQ0FURURfQUxJQVNFUyxcbiAgRkxJUFBFRF9BTElBU19LRVlTLFxuICBUWVBFUyxcbiAgX19pbnRlcm5hbF9fZGVwcmVjYXRpb25XYXJuaW5nOiBkZXByZWNhdGlvbldhcm5pbmdcbn0gPSBfdDtcbmZ1bmN0aW9uIGlzVmlydHVhbFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZSBpbiB2aXJ0dWFsVHlwZXM7XG59XG5mdW5jdGlvbiBpc0V4cGxvZGVkVmlzaXRvcih2aXNpdG9yKSB7XG4gIHJldHVybiB2aXNpdG9yID09IG51bGwgPyB2b2lkIDAgOiB2aXNpdG9yLl9leHBsb2RlZDtcbn1cbmZ1bmN0aW9uIGV4cGxvZGUkMSh2aXNpdG9yKSB7XG4gIGlmIChpc0V4cGxvZGVkVmlzaXRvcih2aXNpdG9yKSkgcmV0dXJuIHZpc2l0b3I7XG4gIHZpc2l0b3IuX2V4cGxvZGVkID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBjb25zdCBwYXJ0cyA9IG5vZGVUeXBlLnNwbGl0KFwifFwiKTtcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAxKSBjb250aW51ZTtcbiAgICBjb25zdCBmbnMgPSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBkZWxldGUgdmlzaXRvcltub2RlVHlwZV07XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICB2aXNpdG9yW3BhcnRdID0gZm5zO1xuICAgIH1cbiAgfVxuICB2ZXJpZnkkMSh2aXNpdG9yKTtcbiAgZGVsZXRlIHZpc2l0b3IuX19lc01vZHVsZTtcbiAgZW5zdXJlRW50cmFuY2VPYmplY3RzKHZpc2l0b3IpO1xuICBlbnN1cmVDYWxsYmFja0FycmF5cyh2aXNpdG9yKTtcbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBpZiAoIWlzVmlydHVhbFR5cGUobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBjb25zdCBmbnMgPSB2aXNpdG9yW25vZGVUeXBlXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgT2JqZWN0LmtleXMoZm5zKSkge1xuICAgICAgZm5zW3R5cGVdID0gd3JhcENoZWNrKG5vZGVUeXBlLCBmbnNbdHlwZV0pO1xuICAgIH1cbiAgICBkZWxldGUgdmlzaXRvcltub2RlVHlwZV07XG4gICAgY29uc3QgdHlwZXMgPSB2aXJ0dWFsVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmICh0eXBlcyAhPT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICAgIGlmICh2aXNpdG9yW3R5cGVdKSB7XG4gICAgICAgICAgbWVyZ2VQYWlyKHZpc2l0b3JbdHlwZV0sIGZucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmlzaXRvclt0eXBlXSA9IGZucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZVBhaXIodmlzaXRvciwgZm5zKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBub2RlVHlwZSBvZiBPYmplY3Qua2V5cyh2aXNpdG9yKSkge1xuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBsZXQgYWxpYXNlcyA9IEZMSVBQRURfQUxJQVNfS0VZU1tub2RlVHlwZV07XG4gICAgaWYgKG5vZGVUeXBlIGluIERFUFJFQ0FURURfS0VZUykge1xuICAgICAgY29uc3QgZGVwcmVjYXRlZEtleSA9IERFUFJFQ0FURURfS0VZU1tub2RlVHlwZV07XG4gICAgICBkZXByZWNhdGlvbldhcm5pbmcobm9kZVR5cGUsIGRlcHJlY2F0ZWRLZXksIFwiVmlzaXRvciBcIik7XG4gICAgICBhbGlhc2VzID0gW2RlcHJlY2F0ZWRLZXldO1xuICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgaW4gREVQUkVDQVRFRF9BTElBU0VTKSB7XG4gICAgICBjb25zdCBkZXByZWNhdGVkQWxpYXMgPSBERVBSRUNBVEVEX0FMSUFTRVNbbm9kZVR5cGVdO1xuICAgICAgZGVwcmVjYXRpb25XYXJuaW5nKG5vZGVUeXBlLCBkZXByZWNhdGVkQWxpYXMsIFwiVmlzaXRvciBcIik7XG4gICAgICBhbGlhc2VzID0gRkxJUFBFRF9BTElBU19LRVlTW2RlcHJlY2F0ZWRBbGlhc107XG4gICAgfVxuICAgIGlmICghYWxpYXNlcykgY29udGludWU7XG4gICAgY29uc3QgZm5zID0gdmlzaXRvcltub2RlVHlwZV07XG4gICAgZGVsZXRlIHZpc2l0b3Jbbm9kZVR5cGVdO1xuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgY29uc3QgZXhpc3RpbmcgPSB2aXNpdG9yW2FsaWFzXTtcbiAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICBtZXJnZVBhaXIoZXhpc3RpbmcsIGZucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2aXNpdG9yW2FsaWFzXSA9IE9iamVjdC5hc3NpZ24oe30sIGZucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgbm9kZVR5cGUgb2YgT2JqZWN0LmtleXModmlzaXRvcikpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KG5vZGVUeXBlKSkgY29udGludWU7XG4gICAgZW5zdXJlQ2FsbGJhY2tBcnJheXModmlzaXRvcltub2RlVHlwZV0pO1xuICB9XG4gIHJldHVybiB2aXNpdG9yO1xufVxuZnVuY3Rpb24gdmVyaWZ5JDEodmlzaXRvcikge1xuICBpZiAodmlzaXRvci5fdmVyaWZpZWQpIHJldHVybjtcbiAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgcGFzc2VkIGB0cmF2ZXJzZSgpYCBhIGZ1bmN0aW9uIHdoZW4gaXQgZXhwZWN0ZWQgYSB2aXNpdG9yIG9iamVjdCwgXCIgKyBcImFyZSB5b3Ugc3VyZSB5b3UgZGlkbid0IG1lYW4gYHsgZW50ZXI6IEZ1bmN0aW9uIH1gP1wiKTtcbiAgfVxuICBmb3IgKGNvbnN0IG5vZGVUeXBlIG9mIE9iamVjdC5rZXlzKHZpc2l0b3IpKSB7XG4gICAgaWYgKG5vZGVUeXBlID09PSBcImVudGVyXCIgfHwgbm9kZVR5cGUgPT09IFwiZXhpdFwiKSB7XG4gICAgICB2YWxpZGF0ZVZpc2l0b3JNZXRob2RzKG5vZGVUeXBlLCB2aXNpdG9yW25vZGVUeXBlXSk7XG4gICAgfVxuICAgIGlmIChzaG91bGRJZ25vcmVLZXkobm9kZVR5cGUpKSBjb250aW51ZTtcbiAgICBpZiAoIVRZUEVTLmluY2x1ZGVzKG5vZGVUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZ2F2ZSB1cyBhIHZpc2l0b3IgZm9yIHRoZSBub2RlIHR5cGUgJHtub2RlVHlwZX0gYnV0IGl0J3Mgbm90IGEgdmFsaWQgdHlwZSBpbiBAYmFiZWwvdHJhdmVyc2UgJHtcIjcuMjUuOVwifWApO1xuICAgIH1cbiAgICBjb25zdCB2aXNpdG9ycyA9IHZpc2l0b3Jbbm9kZVR5cGVdO1xuICAgIGlmICh0eXBlb2YgdmlzaXRvcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmlzaXRvcktleSBvZiBPYmplY3Qua2V5cyh2aXNpdG9ycykpIHtcbiAgICAgICAgaWYgKHZpc2l0b3JLZXkgPT09IFwiZW50ZXJcIiB8fCB2aXNpdG9yS2V5ID09PSBcImV4aXRcIikge1xuICAgICAgICAgIHZhbGlkYXRlVmlzaXRvck1ldGhvZHMoYCR7bm9kZVR5cGV9LiR7dmlzaXRvcktleX1gLCB2aXNpdG9yc1t2aXNpdG9yS2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IHBhc3NlZCBgdHJhdmVyc2UoKWAgYSB2aXNpdG9yIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0eSBcIiArIGAke25vZGVUeXBlfSB0aGF0IGhhcyB0aGUgaW52YWxpZCBwcm9wZXJ0eSAke3Zpc2l0b3JLZXl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmlzaXRvci5fdmVyaWZpZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVWaXNpdG9yTWV0aG9kcyhwYXRoLCB2YWwpIHtcbiAgY29uc3QgZm5zID0gW10uY29uY2F0KHZhbCk7XG4gIGZvciAoY29uc3QgZm4gb2YgZm5zKSB7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBOb24tZnVuY3Rpb24gZm91bmQgZGVmaW5lZCBpbiAke3BhdGh9IHdpdGggdHlwZSAke3R5cGVvZiBmbn1gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHZpc2l0b3JzLCBzdGF0ZXMgPSBbXSwgd3JhcHBlcikge1xuICBjb25zdCBtZXJnZWRWaXNpdG9yID0ge1xuICAgIF92ZXJpZmllZDogdHJ1ZSxcbiAgICBfZXhwbG9kZWQ6IHRydWVcbiAgfTtcbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRWaXNpdG9yLCBcIl9leHBsb2RlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtZXJnZWRWaXNpdG9yLCBcIl92ZXJpZmllZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2aXNpdG9yID0gZXhwbG9kZSQxKHZpc2l0b3JzW2ldKTtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YXRlc1tpXTtcbiAgICBsZXQgdG9wVmlzaXRvciA9IHZpc2l0b3I7XG4gICAgaWYgKHN0YXRlIHx8IHdyYXBwZXIpIHtcbiAgICAgIHRvcFZpc2l0b3IgPSB3cmFwV2l0aFN0YXRlT3JXcmFwcGVyKHRvcFZpc2l0b3IsIHN0YXRlLCB3cmFwcGVyKTtcbiAgICB9XG4gICAgbWVyZ2VQYWlyKG1lcmdlZFZpc2l0b3IsIHRvcFZpc2l0b3IpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZpc2l0b3IpKSB7XG4gICAgICBpZiAoc2hvdWxkSWdub3JlS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgICAgbGV0IHR5cGVWaXNpdG9yID0gdmlzaXRvcltrZXldO1xuICAgICAgaWYgKHN0YXRlIHx8IHdyYXBwZXIpIHtcbiAgICAgICAgdHlwZVZpc2l0b3IgPSB3cmFwV2l0aFN0YXRlT3JXcmFwcGVyKHR5cGVWaXNpdG9yLCBzdGF0ZSwgd3JhcHBlcik7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlVmlzaXRvciA9IG1lcmdlZFZpc2l0b3Jba2V5XSB8fCAobWVyZ2VkVmlzaXRvcltrZXldID0ge30pO1xuICAgICAgbWVyZ2VQYWlyKG5vZGVWaXNpdG9yLCB0eXBlVmlzaXRvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZXJnZWRWaXNpdG9yO1xufVxuZnVuY3Rpb24gd3JhcFdpdGhTdGF0ZU9yV3JhcHBlcihvbGRWaXNpdG9yLCBzdGF0ZSwgd3JhcHBlcikge1xuICBjb25zdCBuZXdWaXNpdG9yID0ge307XG4gIGZvciAoY29uc3QgcGhhc2Ugb2YgW1wiZW50ZXJcIiwgXCJleGl0XCJdKSB7XG4gICAgbGV0IGZucyA9IG9sZFZpc2l0b3JbcGhhc2VdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShmbnMpKSBjb250aW51ZTtcbiAgICBmbnMgPSBmbnMubWFwKGZ1bmN0aW9uIChmbikge1xuICAgICAgbGV0IG5ld0ZuID0gZm47XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgbmV3Rm4gPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgIGZuLmNhbGwoc3RhdGUsIHBhdGgsIHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIG5ld0ZuID0gd3JhcHBlcihzdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUua2V5LCBwaGFzZSwgbmV3Rm4pO1xuICAgICAgfVxuICAgICAgaWYgKG5ld0ZuICE9PSBmbikge1xuICAgICAgICBuZXdGbi50b1N0cmluZyA9ICgpID0+IGZuLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3Rm47XG4gICAgfSk7XG4gICAgbmV3VmlzaXRvcltwaGFzZV0gPSBmbnM7XG4gIH1cbiAgcmV0dXJuIG5ld1Zpc2l0b3I7XG59XG5mdW5jdGlvbiBlbnN1cmVFbnRyYW5jZU9iamVjdHMob2JqKSB7XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICBpZiAoc2hvdWxkSWdub3JlS2V5KGtleSkpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGZucyA9IG9ialtrZXldO1xuICAgIGlmICh0eXBlb2YgZm5zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIG9ialtrZXldID0ge1xuICAgICAgICBlbnRlcjogZm5zXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlQ2FsbGJhY2tBcnJheXMob2JqKSB7XG4gIGlmIChvYmouZW50ZXIgJiYgIUFycmF5LmlzQXJyYXkob2JqLmVudGVyKSkgb2JqLmVudGVyID0gW29iai5lbnRlcl07XG4gIGlmIChvYmouZXhpdCAmJiAhQXJyYXkuaXNBcnJheShvYmouZXhpdCkpIG9iai5leGl0ID0gW29iai5leGl0XTtcbn1cbmZ1bmN0aW9uIHdyYXBDaGVjayhub2RlVHlwZSwgZm4pIHtcbiAgY29uc3QgZm5LZXkgPSBgaXMke25vZGVUeXBlfWA7XG4gIGNvbnN0IHZhbGlkYXRvciA9IHZpcnR1YWxUeXBlc1ZhbGlkYXRvcnNbZm5LZXldO1xuICBjb25zdCBuZXdGbiA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgaWYgKHZhbGlkYXRvci5jYWxsKHBhdGgpKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH07XG4gIG5ld0ZuLnRvU3RyaW5nID0gKCkgPT4gZm4udG9TdHJpbmcoKTtcbiAgcmV0dXJuIG5ld0ZuO1xufVxuZnVuY3Rpb24gc2hvdWxkSWdub3JlS2V5KGtleSkge1xuICBpZiAoa2V5WzBdID09PSBcIl9cIikgcmV0dXJuIHRydWU7XG4gIGlmIChrZXkgPT09IFwiZW50ZXJcIiB8fCBrZXkgPT09IFwiZXhpdFwiIHx8IGtleSA9PT0gXCJzaG91bGRTa2lwXCIpIHJldHVybiB0cnVlO1xuICBpZiAoa2V5ID09PSBcImRlbnlsaXN0XCIgfHwga2V5ID09PSBcIm5vU2NvcGVcIiB8fCBrZXkgPT09IFwic2tpcEtleXNcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHtcbiAgICBpZiAoa2V5ID09PSBcImJsYWNrbGlzdFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbWVyZ2VQYWlyKGRlc3QsIHNyYykge1xuICBmb3IgKGNvbnN0IHBoYXNlIG9mIFtcImVudGVyXCIsIFwiZXhpdFwiXSkge1xuICAgIGlmICghc3JjW3BoYXNlXSkgY29udGludWU7XG4gICAgZGVzdFtwaGFzZV0gPSBbXS5jb25jYXQoZGVzdFtwaGFzZV0gfHwgW10sIHNyY1twaGFzZV0pO1xuICB9XG59XG5jb25zdCBfZW52aXJvbm1lbnRWaXNpdG9yID0ge1xuICBGdW5jdGlvblBhcmVudChwYXRoKSB7XG4gICAgaWYgKHBhdGguaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbigpKSByZXR1cm47XG4gICAgcGF0aC5za2lwKCk7XG4gICAgaWYgKHBhdGguaXNNZXRob2QoKSkge1xuICAgICAgaWYgKCFwYXRoLnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMpIHtcbiAgICAgICAgX2NvbnRleHQucmVxdWV1ZUNvbXB1dGVkS2V5QW5kRGVjb3JhdG9ycy5jYWxsKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBQcm9wZXJ0eShwYXRoKSB7XG4gICAgaWYgKHBhdGguaXNPYmplY3RQcm9wZXJ0eSgpKSByZXR1cm47XG4gICAgcGF0aC5za2lwKCk7XG4gICAgaWYgKCFwYXRoLnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMpIHtcbiAgICAgIF9jb250ZXh0LnJlcXVldWVDb21wdXRlZEtleUFuZERlY29yYXRvcnMuY2FsbChwYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5yZXF1ZXVlQ29tcHV0ZWRLZXlBbmREZWNvcmF0b3JzKCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gZW52aXJvbm1lbnRWaXNpdG9yKHZpc2l0b3IpIHtcbiAgcmV0dXJuIG1lcmdlKFtfZW52aXJvbm1lbnRWaXNpdG9yLCB2aXNpdG9yXSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpc2l0b3JzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34950\n')},34568:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = assertNode;\nvar _isNode = __webpack_require__(73908);\nfunction assertNode(node) {\n  if (!(0, _isNode.default)(node)) {\n    var _node$type;\n    const type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type "${type}"`);\n  }\n}\n\n//# sourceMappingURL=assertNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ1NjguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixjQUFjLG1CQUFPLENBQUMsS0FBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2Fzc2VydHMvYXNzZXJ0Tm9kZS5qcz9hYjYzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0Tm9kZTtcbnZhciBfaXNOb2RlID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNOb2RlLmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0Tm9kZShub2RlKSB7XG4gIGlmICghKDAsIF9pc05vZGUuZGVmYXVsdCkobm9kZSkpIHtcbiAgICB2YXIgX25vZGUkdHlwZTtcbiAgICBjb25zdCB0eXBlID0gKF9ub2RlJHR5cGUgPSBub2RlID09IG51bGwgPyB2b2lkIDAgOiBub2RlLnR5cGUpICE9IG51bGwgPyBfbm9kZSR0eXBlIDogSlNPTi5zdHJpbmdpZnkobm9kZSk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm90IGEgdmFsaWQgbm9kZSBvZiB0eXBlIFwiJHt0eXBlfVwiYCk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0Tm9kZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34568\n')},72246:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.assertAccessor = assertAccessor;\nexports.assertAnyTypeAnnotation = assertAnyTypeAnnotation;\nexports.assertArgumentPlaceholder = assertArgumentPlaceholder;\nexports.assertArrayExpression = assertArrayExpression;\nexports.assertArrayPattern = assertArrayPattern;\nexports.assertArrayTypeAnnotation = assertArrayTypeAnnotation;\nexports.assertArrowFunctionExpression = assertArrowFunctionExpression;\nexports.assertAssignmentExpression = assertAssignmentExpression;\nexports.assertAssignmentPattern = assertAssignmentPattern;\nexports.assertAwaitExpression = assertAwaitExpression;\nexports.assertBigIntLiteral = assertBigIntLiteral;\nexports.assertBinary = assertBinary;\nexports.assertBinaryExpression = assertBinaryExpression;\nexports.assertBindExpression = assertBindExpression;\nexports.assertBlock = assertBlock;\nexports.assertBlockParent = assertBlockParent;\nexports.assertBlockStatement = assertBlockStatement;\nexports.assertBooleanLiteral = assertBooleanLiteral;\nexports.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;\nexports.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;\nexports.assertBreakStatement = assertBreakStatement;\nexports.assertCallExpression = assertCallExpression;\nexports.assertCatchClause = assertCatchClause;\nexports.assertClass = assertClass;\nexports.assertClassAccessorProperty = assertClassAccessorProperty;\nexports.assertClassBody = assertClassBody;\nexports.assertClassDeclaration = assertClassDeclaration;\nexports.assertClassExpression = assertClassExpression;\nexports.assertClassImplements = assertClassImplements;\nexports.assertClassMethod = assertClassMethod;\nexports.assertClassPrivateMethod = assertClassPrivateMethod;\nexports.assertClassPrivateProperty = assertClassPrivateProperty;\nexports.assertClassProperty = assertClassProperty;\nexports.assertCompletionStatement = assertCompletionStatement;\nexports.assertConditional = assertConditional;\nexports.assertConditionalExpression = assertConditionalExpression;\nexports.assertContinueStatement = assertContinueStatement;\nexports.assertDebuggerStatement = assertDebuggerStatement;\nexports.assertDecimalLiteral = assertDecimalLiteral;\nexports.assertDeclaration = assertDeclaration;\nexports.assertDeclareClass = assertDeclareClass;\nexports.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;\nexports.assertDeclareExportDeclaration = assertDeclareExportDeclaration;\nexports.assertDeclareFunction = assertDeclareFunction;\nexports.assertDeclareInterface = assertDeclareInterface;\nexports.assertDeclareModule = assertDeclareModule;\nexports.assertDeclareModuleExports = assertDeclareModuleExports;\nexports.assertDeclareOpaqueType = assertDeclareOpaqueType;\nexports.assertDeclareTypeAlias = assertDeclareTypeAlias;\nexports.assertDeclareVariable = assertDeclareVariable;\nexports.assertDeclaredPredicate = assertDeclaredPredicate;\nexports.assertDecorator = assertDecorator;\nexports.assertDirective = assertDirective;\nexports.assertDirectiveLiteral = assertDirectiveLiteral;\nexports.assertDoExpression = assertDoExpression;\nexports.assertDoWhileStatement = assertDoWhileStatement;\nexports.assertEmptyStatement = assertEmptyStatement;\nexports.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;\nexports.assertEnumBody = assertEnumBody;\nexports.assertEnumBooleanBody = assertEnumBooleanBody;\nexports.assertEnumBooleanMember = assertEnumBooleanMember;\nexports.assertEnumDeclaration = assertEnumDeclaration;\nexports.assertEnumDefaultedMember = assertEnumDefaultedMember;\nexports.assertEnumMember = assertEnumMember;\nexports.assertEnumNumberBody = assertEnumNumberBody;\nexports.assertEnumNumberMember = assertEnumNumberMember;\nexports.assertEnumStringBody = assertEnumStringBody;\nexports.assertEnumStringMember = assertEnumStringMember;\nexports.assertEnumSymbolBody = assertEnumSymbolBody;\nexports.assertExistsTypeAnnotation = assertExistsTypeAnnotation;\nexports.assertExportAllDeclaration = assertExportAllDeclaration;\nexports.assertExportDeclaration = assertExportDeclaration;\nexports.assertExportDefaultDeclaration = assertExportDefaultDeclaration;\nexports.assertExportDefaultSpecifier = assertExportDefaultSpecifier;\nexports.assertExportNamedDeclaration = assertExportNamedDeclaration;\nexports.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;\nexports.assertExportSpecifier = assertExportSpecifier;\nexports.assertExpression = assertExpression;\nexports.assertExpressionStatement = assertExpressionStatement;\nexports.assertExpressionWrapper = assertExpressionWrapper;\nexports.assertFile = assertFile;\nexports.assertFlow = assertFlow;\nexports.assertFlowBaseAnnotation = assertFlowBaseAnnotation;\nexports.assertFlowDeclaration = assertFlowDeclaration;\nexports.assertFlowPredicate = assertFlowPredicate;\nexports.assertFlowType = assertFlowType;\nexports.assertFor = assertFor;\nexports.assertForInStatement = assertForInStatement;\nexports.assertForOfStatement = assertForOfStatement;\nexports.assertForStatement = assertForStatement;\nexports.assertForXStatement = assertForXStatement;\nexports.assertFunction = assertFunction;\nexports.assertFunctionDeclaration = assertFunctionDeclaration;\nexports.assertFunctionExpression = assertFunctionExpression;\nexports.assertFunctionParent = assertFunctionParent;\nexports.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;\nexports.assertFunctionTypeParam = assertFunctionTypeParam;\nexports.assertGenericTypeAnnotation = assertGenericTypeAnnotation;\nexports.assertIdentifier = assertIdentifier;\nexports.assertIfStatement = assertIfStatement;\nexports.assertImmutable = assertImmutable;\nexports.assertImport = assertImport;\nexports.assertImportAttribute = assertImportAttribute;\nexports.assertImportDeclaration = assertImportDeclaration;\nexports.assertImportDefaultSpecifier = assertImportDefaultSpecifier;\nexports.assertImportExpression = assertImportExpression;\nexports.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;\nexports.assertImportOrExportDeclaration = assertImportOrExportDeclaration;\nexports.assertImportSpecifier = assertImportSpecifier;\nexports.assertIndexedAccessType = assertIndexedAccessType;\nexports.assertInferredPredicate = assertInferredPredicate;\nexports.assertInterfaceDeclaration = assertInterfaceDeclaration;\nexports.assertInterfaceExtends = assertInterfaceExtends;\nexports.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;\nexports.assertInterpreterDirective = assertInterpreterDirective;\nexports.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;\nexports.assertJSX = assertJSX;\nexports.assertJSXAttribute = assertJSXAttribute;\nexports.assertJSXClosingElement = assertJSXClosingElement;\nexports.assertJSXClosingFragment = assertJSXClosingFragment;\nexports.assertJSXElement = assertJSXElement;\nexports.assertJSXEmptyExpression = assertJSXEmptyExpression;\nexports.assertJSXExpressionContainer = assertJSXExpressionContainer;\nexports.assertJSXFragment = assertJSXFragment;\nexports.assertJSXIdentifier = assertJSXIdentifier;\nexports.assertJSXMemberExpression = assertJSXMemberExpression;\nexports.assertJSXNamespacedName = assertJSXNamespacedName;\nexports.assertJSXOpeningElement = assertJSXOpeningElement;\nexports.assertJSXOpeningFragment = assertJSXOpeningFragment;\nexports.assertJSXSpreadAttribute = assertJSXSpreadAttribute;\nexports.assertJSXSpreadChild = assertJSXSpreadChild;\nexports.assertJSXText = assertJSXText;\nexports.assertLVal = assertLVal;\nexports.assertLabeledStatement = assertLabeledStatement;\nexports.assertLiteral = assertLiteral;\nexports.assertLogicalExpression = assertLogicalExpression;\nexports.assertLoop = assertLoop;\nexports.assertMemberExpression = assertMemberExpression;\nexports.assertMetaProperty = assertMetaProperty;\nexports.assertMethod = assertMethod;\nexports.assertMiscellaneous = assertMiscellaneous;\nexports.assertMixedTypeAnnotation = assertMixedTypeAnnotation;\nexports.assertModuleDeclaration = assertModuleDeclaration;\nexports.assertModuleExpression = assertModuleExpression;\nexports.assertModuleSpecifier = assertModuleSpecifier;\nexports.assertNewExpression = assertNewExpression;\nexports.assertNoop = assertNoop;\nexports.assertNullLiteral = assertNullLiteral;\nexports.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;\nexports.assertNullableTypeAnnotation = assertNullableTypeAnnotation;\nexports.assertNumberLiteral = assertNumberLiteral;\nexports.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;\nexports.assertNumberTypeAnnotation = assertNumberTypeAnnotation;\nexports.assertNumericLiteral = assertNumericLiteral;\nexports.assertObjectExpression = assertObjectExpression;\nexports.assertObjectMember = assertObjectMember;\nexports.assertObjectMethod = assertObjectMethod;\nexports.assertObjectPattern = assertObjectPattern;\nexports.assertObjectProperty = assertObjectProperty;\nexports.assertObjectTypeAnnotation = assertObjectTypeAnnotation;\nexports.assertObjectTypeCallProperty = assertObjectTypeCallProperty;\nexports.assertObjectTypeIndexer = assertObjectTypeIndexer;\nexports.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;\nexports.assertObjectTypeProperty = assertObjectTypeProperty;\nexports.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;\nexports.assertOpaqueType = assertOpaqueType;\nexports.assertOptionalCallExpression = assertOptionalCallExpression;\nexports.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;\nexports.assertOptionalMemberExpression = assertOptionalMemberExpression;\nexports.assertParenthesizedExpression = assertParenthesizedExpression;\nexports.assertPattern = assertPattern;\nexports.assertPatternLike = assertPatternLike;\nexports.assertPipelineBareFunction = assertPipelineBareFunction;\nexports.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;\nexports.assertPipelineTopicExpression = assertPipelineTopicExpression;\nexports.assertPlaceholder = assertPlaceholder;\nexports.assertPrivate = assertPrivate;\nexports.assertPrivateName = assertPrivateName;\nexports.assertProgram = assertProgram;\nexports.assertProperty = assertProperty;\nexports.assertPureish = assertPureish;\nexports.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;\nexports.assertRecordExpression = assertRecordExpression;\nexports.assertRegExpLiteral = assertRegExpLiteral;\nexports.assertRegexLiteral = assertRegexLiteral;\nexports.assertRestElement = assertRestElement;\nexports.assertRestProperty = assertRestProperty;\nexports.assertReturnStatement = assertReturnStatement;\nexports.assertScopable = assertScopable;\nexports.assertSequenceExpression = assertSequenceExpression;\nexports.assertSpreadElement = assertSpreadElement;\nexports.assertSpreadProperty = assertSpreadProperty;\nexports.assertStandardized = assertStandardized;\nexports.assertStatement = assertStatement;\nexports.assertStaticBlock = assertStaticBlock;\nexports.assertStringLiteral = assertStringLiteral;\nexports.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;\nexports.assertStringTypeAnnotation = assertStringTypeAnnotation;\nexports.assertSuper = assertSuper;\nexports.assertSwitchCase = assertSwitchCase;\nexports.assertSwitchStatement = assertSwitchStatement;\nexports.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;\nexports.assertTSAnyKeyword = assertTSAnyKeyword;\nexports.assertTSArrayType = assertTSArrayType;\nexports.assertTSAsExpression = assertTSAsExpression;\nexports.assertTSBaseType = assertTSBaseType;\nexports.assertTSBigIntKeyword = assertTSBigIntKeyword;\nexports.assertTSBooleanKeyword = assertTSBooleanKeyword;\nexports.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;\nexports.assertTSConditionalType = assertTSConditionalType;\nexports.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;\nexports.assertTSConstructorType = assertTSConstructorType;\nexports.assertTSDeclareFunction = assertTSDeclareFunction;\nexports.assertTSDeclareMethod = assertTSDeclareMethod;\nexports.assertTSEntityName = assertTSEntityName;\nexports.assertTSEnumDeclaration = assertTSEnumDeclaration;\nexports.assertTSEnumMember = assertTSEnumMember;\nexports.assertTSExportAssignment = assertTSExportAssignment;\nexports.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;\nexports.assertTSExternalModuleReference = assertTSExternalModuleReference;\nexports.assertTSFunctionType = assertTSFunctionType;\nexports.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;\nexports.assertTSImportType = assertTSImportType;\nexports.assertTSIndexSignature = assertTSIndexSignature;\nexports.assertTSIndexedAccessType = assertTSIndexedAccessType;\nexports.assertTSInferType = assertTSInferType;\nexports.assertTSInstantiationExpression = assertTSInstantiationExpression;\nexports.assertTSInterfaceBody = assertTSInterfaceBody;\nexports.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;\nexports.assertTSIntersectionType = assertTSIntersectionType;\nexports.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;\nexports.assertTSLiteralType = assertTSLiteralType;\nexports.assertTSMappedType = assertTSMappedType;\nexports.assertTSMethodSignature = assertTSMethodSignature;\nexports.assertTSModuleBlock = assertTSModuleBlock;\nexports.assertTSModuleDeclaration = assertTSModuleDeclaration;\nexports.assertTSNamedTupleMember = assertTSNamedTupleMember;\nexports.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;\nexports.assertTSNeverKeyword = assertTSNeverKeyword;\nexports.assertTSNonNullExpression = assertTSNonNullExpression;\nexports.assertTSNullKeyword = assertTSNullKeyword;\nexports.assertTSNumberKeyword = assertTSNumberKeyword;\nexports.assertTSObjectKeyword = assertTSObjectKeyword;\nexports.assertTSOptionalType = assertTSOptionalType;\nexports.assertTSParameterProperty = assertTSParameterProperty;\nexports.assertTSParenthesizedType = assertTSParenthesizedType;\nexports.assertTSPropertySignature = assertTSPropertySignature;\nexports.assertTSQualifiedName = assertTSQualifiedName;\nexports.assertTSRestType = assertTSRestType;\nexports.assertTSSatisfiesExpression = assertTSSatisfiesExpression;\nexports.assertTSStringKeyword = assertTSStringKeyword;\nexports.assertTSSymbolKeyword = assertTSSymbolKeyword;\nexports.assertTSThisType = assertTSThisType;\nexports.assertTSTupleType = assertTSTupleType;\nexports.assertTSType = assertTSType;\nexports.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;\nexports.assertTSTypeAnnotation = assertTSTypeAnnotation;\nexports.assertTSTypeAssertion = assertTSTypeAssertion;\nexports.assertTSTypeElement = assertTSTypeElement;\nexports.assertTSTypeLiteral = assertTSTypeLiteral;\nexports.assertTSTypeOperator = assertTSTypeOperator;\nexports.assertTSTypeParameter = assertTSTypeParameter;\nexports.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;\nexports.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;\nexports.assertTSTypePredicate = assertTSTypePredicate;\nexports.assertTSTypeQuery = assertTSTypeQuery;\nexports.assertTSTypeReference = assertTSTypeReference;\nexports.assertTSUndefinedKeyword = assertTSUndefinedKeyword;\nexports.assertTSUnionType = assertTSUnionType;\nexports.assertTSUnknownKeyword = assertTSUnknownKeyword;\nexports.assertTSVoidKeyword = assertTSVoidKeyword;\nexports.assertTaggedTemplateExpression = assertTaggedTemplateExpression;\nexports.assertTemplateElement = assertTemplateElement;\nexports.assertTemplateLiteral = assertTemplateLiteral;\nexports.assertTerminatorless = assertTerminatorless;\nexports.assertThisExpression = assertThisExpression;\nexports.assertThisTypeAnnotation = assertThisTypeAnnotation;\nexports.assertThrowStatement = assertThrowStatement;\nexports.assertTopicReference = assertTopicReference;\nexports.assertTryStatement = assertTryStatement;\nexports.assertTupleExpression = assertTupleExpression;\nexports.assertTupleTypeAnnotation = assertTupleTypeAnnotation;\nexports.assertTypeAlias = assertTypeAlias;\nexports.assertTypeAnnotation = assertTypeAnnotation;\nexports.assertTypeCastExpression = assertTypeCastExpression;\nexports.assertTypeParameter = assertTypeParameter;\nexports.assertTypeParameterDeclaration = assertTypeParameterDeclaration;\nexports.assertTypeParameterInstantiation = assertTypeParameterInstantiation;\nexports.assertTypeScript = assertTypeScript;\nexports.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;\nexports.assertUnaryExpression = assertUnaryExpression;\nexports.assertUnaryLike = assertUnaryLike;\nexports.assertUnionTypeAnnotation = assertUnionTypeAnnotation;\nexports.assertUpdateExpression = assertUpdateExpression;\nexports.assertUserWhitespacable = assertUserWhitespacable;\nexports.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;\nexports.assertVariableDeclaration = assertVariableDeclaration;\nexports.assertVariableDeclarator = assertVariableDeclarator;\nexports.assertVariance = assertVariance;\nexports.assertVoidTypeAnnotation = assertVoidTypeAnnotation;\nexports.assertWhile = assertWhile;\nexports.assertWhileStatement = assertWhileStatement;\nexports.assertWithStatement = assertWithStatement;\nexports.assertYieldExpression = assertYieldExpression;\nvar _is = __webpack_require__(93828);\nvar _deprecationWarning = __webpack_require__(63762);\nfunction assert(type, node, opts) {\n  if (!(0, _is.default)(type, node, opts)) {\n    throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, ` + `but instead got "${node.type}".`);\n  }\n}\nfunction assertArrayExpression(node, opts) {\n  assert("ArrayExpression", node, opts);\n}\nfunction assertAssignmentExpression(node, opts) {\n  assert("AssignmentExpression", node, opts);\n}\nfunction assertBinaryExpression(node, opts) {\n  assert("BinaryExpression", node, opts);\n}\nfunction assertInterpreterDirective(node, opts) {\n  assert("InterpreterDirective", node, opts);\n}\nfunction assertDirective(node, opts) {\n  assert("Directive", node, opts);\n}\nfunction assertDirectiveLiteral(node, opts) {\n  assert("DirectiveLiteral", node, opts);\n}\nfunction assertBlockStatement(node, opts) {\n  assert("BlockStatement", node, opts);\n}\nfunction assertBreakStatement(node, opts) {\n  assert("BreakStatement", node, opts);\n}\nfunction assertCallExpression(node, opts) {\n  assert("CallExpression", node, opts);\n}\nfunction assertCatchClause(node, opts) {\n  assert("CatchClause", node, opts);\n}\nfunction assertConditionalExpression(node, opts) {\n  assert("ConditionalExpression", node, opts);\n}\nfunction assertContinueStatement(node, opts) {\n  assert("ContinueStatement", node, opts);\n}\nfunction assertDebuggerStatement(node, opts) {\n  assert("DebuggerStatement", node, opts);\n}\nfunction assertDoWhileStatement(node, opts) {\n  assert("DoWhileStatement", node, opts);\n}\nfunction assertEmptyStatement(node, opts) {\n  assert("EmptyStatement", node, opts);\n}\nfunction assertExpressionStatement(node, opts) {\n  assert("ExpressionStatement", node, opts);\n}\nfunction assertFile(node, opts) {\n  assert("File", node, opts);\n}\nfunction assertForInStatement(node, opts) {\n  assert("ForInStatement", node, opts);\n}\nfunction assertForStatement(node, opts) {\n  assert("ForStatement", node, opts);\n}\nfunction assertFunctionDeclaration(node, opts) {\n  assert("FunctionDeclaration", node, opts);\n}\nfunction assertFunctionExpression(node, opts) {\n  assert("FunctionExpression", node, opts);\n}\nfunction assertIdentifier(node, opts) {\n  assert("Identifier", node, opts);\n}\nfunction assertIfStatement(node, opts) {\n  assert("IfStatement", node, opts);\n}\nfunction assertLabeledStatement(node, opts) {\n  assert("LabeledStatement", node, opts);\n}\nfunction assertStringLiteral(node, opts) {\n  assert("StringLiteral", node, opts);\n}\nfunction assertNumericLiteral(node, opts) {\n  assert("NumericLiteral", node, opts);\n}\nfunction assertNullLiteral(node, opts) {\n  assert("NullLiteral", node, opts);\n}\nfunction assertBooleanLiteral(node, opts) {\n  assert("BooleanLiteral", node, opts);\n}\nfunction assertRegExpLiteral(node, opts) {\n  assert("RegExpLiteral", node, opts);\n}\nfunction assertLogicalExpression(node, opts) {\n  assert("LogicalExpression", node, opts);\n}\nfunction assertMemberExpression(node, opts) {\n  assert("MemberExpression", node, opts);\n}\nfunction assertNewExpression(node, opts) {\n  assert("NewExpression", node, opts);\n}\nfunction assertProgram(node, opts) {\n  assert("Program", node, opts);\n}\nfunction assertObjectExpression(node, opts) {\n  assert("ObjectExpression", node, opts);\n}\nfunction assertObjectMethod(node, opts) {\n  assert("ObjectMethod", node, opts);\n}\nfunction assertObjectProperty(node, opts) {\n  assert("ObjectProperty", node, opts);\n}\nfunction assertRestElement(node, opts) {\n  assert("RestElement", node, opts);\n}\nfunction assertReturnStatement(node, opts) {\n  assert("ReturnStatement", node, opts);\n}\nfunction assertSequenceExpression(node, opts) {\n  assert("SequenceExpression", node, opts);\n}\nfunction assertParenthesizedExpression(node, opts) {\n  assert("ParenthesizedExpression", node, opts);\n}\nfunction assertSwitchCase(node, opts) {\n  assert("SwitchCase", node, opts);\n}\nfunction assertSwitchStatement(node, opts) {\n  assert("SwitchStatement", node, opts);\n}\nfunction assertThisExpression(node, opts) {\n  assert("ThisExpression", node, opts);\n}\nfunction assertThrowStatement(node, opts) {\n  assert("ThrowStatement", node, opts);\n}\nfunction assertTryStatement(node, opts) {\n  assert("TryStatement", node, opts);\n}\nfunction assertUnaryExpression(node, opts) {\n  assert("UnaryExpression", node, opts);\n}\nfunction assertUpdateExpression(node, opts) {\n  assert("UpdateExpression", node, opts);\n}\nfunction assertVariableDeclaration(node, opts) {\n  assert("VariableDeclaration", node, opts);\n}\nfunction assertVariableDeclarator(node, opts) {\n  assert("VariableDeclarator", node, opts);\n}\nfunction assertWhileStatement(node, opts) {\n  assert("WhileStatement", node, opts);\n}\nfunction assertWithStatement(node, opts) {\n  assert("WithStatement", node, opts);\n}\nfunction assertAssignmentPattern(node, opts) {\n  assert("AssignmentPattern", node, opts);\n}\nfunction assertArrayPattern(node, opts) {\n  assert("ArrayPattern", node, opts);\n}\nfunction assertArrowFunctionExpression(node, opts) {\n  assert("ArrowFunctionExpression", node, opts);\n}\nfunction assertClassBody(node, opts) {\n  assert("ClassBody", node, opts);\n}\nfunction assertClassExpression(node, opts) {\n  assert("ClassExpression", node, opts);\n}\nfunction assertClassDeclaration(node, opts) {\n  assert("ClassDeclaration", node, opts);\n}\nfunction assertExportAllDeclaration(node, opts) {\n  assert("ExportAllDeclaration", node, opts);\n}\nfunction assertExportDefaultDeclaration(node, opts) {\n  assert("ExportDefaultDeclaration", node, opts);\n}\nfunction assertExportNamedDeclaration(node, opts) {\n  assert("ExportNamedDeclaration", node, opts);\n}\nfunction assertExportSpecifier(node, opts) {\n  assert("ExportSpecifier", node, opts);\n}\nfunction assertForOfStatement(node, opts) {\n  assert("ForOfStatement", node, opts);\n}\nfunction assertImportDeclaration(node, opts) {\n  assert("ImportDeclaration", node, opts);\n}\nfunction assertImportDefaultSpecifier(node, opts) {\n  assert("ImportDefaultSpecifier", node, opts);\n}\nfunction assertImportNamespaceSpecifier(node, opts) {\n  assert("ImportNamespaceSpecifier", node, opts);\n}\nfunction assertImportSpecifier(node, opts) {\n  assert("ImportSpecifier", node, opts);\n}\nfunction assertImportExpression(node, opts) {\n  assert("ImportExpression", node, opts);\n}\nfunction assertMetaProperty(node, opts) {\n  assert("MetaProperty", node, opts);\n}\nfunction assertClassMethod(node, opts) {\n  assert("ClassMethod", node, opts);\n}\nfunction assertObjectPattern(node, opts) {\n  assert("ObjectPattern", node, opts);\n}\nfunction assertSpreadElement(node, opts) {\n  assert("SpreadElement", node, opts);\n}\nfunction assertSuper(node, opts) {\n  assert("Super", node, opts);\n}\nfunction assertTaggedTemplateExpression(node, opts) {\n  assert("TaggedTemplateExpression", node, opts);\n}\nfunction assertTemplateElement(node, opts) {\n  assert("TemplateElement", node, opts);\n}\nfunction assertTemplateLiteral(node, opts) {\n  assert("TemplateLiteral", node, opts);\n}\nfunction assertYieldExpression(node, opts) {\n  assert("YieldExpression", node, opts);\n}\nfunction assertAwaitExpression(node, opts) {\n  assert("AwaitExpression", node, opts);\n}\nfunction assertImport(node, opts) {\n  assert("Import", node, opts);\n}\nfunction assertBigIntLiteral(node, opts) {\n  assert("BigIntLiteral", node, opts);\n}\nfunction assertExportNamespaceSpecifier(node, opts) {\n  assert("ExportNamespaceSpecifier", node, opts);\n}\nfunction assertOptionalMemberExpression(node, opts) {\n  assert("OptionalMemberExpression", node, opts);\n}\nfunction assertOptionalCallExpression(node, opts) {\n  assert("OptionalCallExpression", node, opts);\n}\nfunction assertClassProperty(node, opts) {\n  assert("ClassProperty", node, opts);\n}\nfunction assertClassAccessorProperty(node, opts) {\n  assert("ClassAccessorProperty", node, opts);\n}\nfunction assertClassPrivateProperty(node, opts) {\n  assert("ClassPrivateProperty", node, opts);\n}\nfunction assertClassPrivateMethod(node, opts) {\n  assert("ClassPrivateMethod", node, opts);\n}\nfunction assertPrivateName(node, opts) {\n  assert("PrivateName", node, opts);\n}\nfunction assertStaticBlock(node, opts) {\n  assert("StaticBlock", node, opts);\n}\nfunction assertAnyTypeAnnotation(node, opts) {\n  assert("AnyTypeAnnotation", node, opts);\n}\nfunction assertArrayTypeAnnotation(node, opts) {\n  assert("ArrayTypeAnnotation", node, opts);\n}\nfunction assertBooleanTypeAnnotation(node, opts) {\n  assert("BooleanTypeAnnotation", node, opts);\n}\nfunction assertBooleanLiteralTypeAnnotation(node, opts) {\n  assert("BooleanLiteralTypeAnnotation", node, opts);\n}\nfunction assertNullLiteralTypeAnnotation(node, opts) {\n  assert("NullLiteralTypeAnnotation", node, opts);\n}\nfunction assertClassImplements(node, opts) {\n  assert("ClassImplements", node, opts);\n}\nfunction assertDeclareClass(node, opts) {\n  assert("DeclareClass", node, opts);\n}\nfunction assertDeclareFunction(node, opts) {\n  assert("DeclareFunction", node, opts);\n}\nfunction assertDeclareInterface(node, opts) {\n  assert("DeclareInterface", node, opts);\n}\nfunction assertDeclareModule(node, opts) {\n  assert("DeclareModule", node, opts);\n}\nfunction assertDeclareModuleExports(node, opts) {\n  assert("DeclareModuleExports", node, opts);\n}\nfunction assertDeclareTypeAlias(node, opts) {\n  assert("DeclareTypeAlias", node, opts);\n}\nfunction assertDeclareOpaqueType(node, opts) {\n  assert("DeclareOpaqueType", node, opts);\n}\nfunction assertDeclareVariable(node, opts) {\n  assert("DeclareVariable", node, opts);\n}\nfunction assertDeclareExportDeclaration(node, opts) {\n  assert("DeclareExportDeclaration", node, opts);\n}\nfunction assertDeclareExportAllDeclaration(node, opts) {\n  assert("DeclareExportAllDeclaration", node, opts);\n}\nfunction assertDeclaredPredicate(node, opts) {\n  assert("DeclaredPredicate", node, opts);\n}\nfunction assertExistsTypeAnnotation(node, opts) {\n  assert("ExistsTypeAnnotation", node, opts);\n}\nfunction assertFunctionTypeAnnotation(node, opts) {\n  assert("FunctionTypeAnnotation", node, opts);\n}\nfunction assertFunctionTypeParam(node, opts) {\n  assert("FunctionTypeParam", node, opts);\n}\nfunction assertGenericTypeAnnotation(node, opts) {\n  assert("GenericTypeAnnotation", node, opts);\n}\nfunction assertInferredPredicate(node, opts) {\n  assert("InferredPredicate", node, opts);\n}\nfunction assertInterfaceExtends(node, opts) {\n  assert("InterfaceExtends", node, opts);\n}\nfunction assertInterfaceDeclaration(node, opts) {\n  assert("InterfaceDeclaration", node, opts);\n}\nfunction assertInterfaceTypeAnnotation(node, opts) {\n  assert("InterfaceTypeAnnotation", node, opts);\n}\nfunction assertIntersectionTypeAnnotation(node, opts) {\n  assert("IntersectionTypeAnnotation", node, opts);\n}\nfunction assertMixedTypeAnnotation(node, opts) {\n  assert("MixedTypeAnnotation", node, opts);\n}\nfunction assertEmptyTypeAnnotation(node, opts) {\n  assert("EmptyTypeAnnotation", node, opts);\n}\nfunction assertNullableTypeAnnotation(node, opts) {\n  assert("NullableTypeAnnotation", node, opts);\n}\nfunction assertNumberLiteralTypeAnnotation(node, opts) {\n  assert("NumberLiteralTypeAnnotation", node, opts);\n}\nfunction assertNumberTypeAnnotation(node, opts) {\n  assert("NumberTypeAnnotation", node, opts);\n}\nfunction assertObjectTypeAnnotation(node, opts) {\n  assert("ObjectTypeAnnotation", node, opts);\n}\nfunction assertObjectTypeInternalSlot(node, opts) {\n  assert("ObjectTypeInternalSlot", node, opts);\n}\nfunction assertObjectTypeCallProperty(node, opts) {\n  assert("ObjectTypeCallProperty", node, opts);\n}\nfunction assertObjectTypeIndexer(node, opts) {\n  assert("ObjectTypeIndexer", node, opts);\n}\nfunction assertObjectTypeProperty(node, opts) {\n  assert("ObjectTypeProperty", node, opts);\n}\nfunction assertObjectTypeSpreadProperty(node, opts) {\n  assert("ObjectTypeSpreadProperty", node, opts);\n}\nfunction assertOpaqueType(node, opts) {\n  assert("OpaqueType", node, opts);\n}\nfunction assertQualifiedTypeIdentifier(node, opts) {\n  assert("QualifiedTypeIdentifier", node, opts);\n}\nfunction assertStringLiteralTypeAnnotation(node, opts) {\n  assert("StringLiteralTypeAnnotation", node, opts);\n}\nfunction assertStringTypeAnnotation(node, opts) {\n  assert("StringTypeAnnotation", node, opts);\n}\nfunction assertSymbolTypeAnnotation(node, opts) {\n  assert("SymbolTypeAnnotation", node, opts);\n}\nfunction assertThisTypeAnnotation(node, opts) {\n  assert("ThisTypeAnnotation", node, opts);\n}\nfunction assertTupleTypeAnnotation(node, opts) {\n  assert("TupleTypeAnnotation", node, opts);\n}\nfunction assertTypeofTypeAnnotation(node, opts) {\n  assert("TypeofTypeAnnotation", node, opts);\n}\nfunction assertTypeAlias(node, opts) {\n  assert("TypeAlias", node, opts);\n}\nfunction assertTypeAnnotation(node, opts) {\n  assert("TypeAnnotation", node, opts);\n}\nfunction assertTypeCastExpression(node, opts) {\n  assert("TypeCastExpression", node, opts);\n}\nfunction assertTypeParameter(node, opts) {\n  assert("TypeParameter", node, opts);\n}\nfunction assertTypeParameterDeclaration(node, opts) {\n  assert("TypeParameterDeclaration", node, opts);\n}\nfunction assertTypeParameterInstantiation(node, opts) {\n  assert("TypeParameterInstantiation", node, opts);\n}\nfunction assertUnionTypeAnnotation(node, opts) {\n  assert("UnionTypeAnnotation", node, opts);\n}\nfunction assertVariance(node, opts) {\n  assert("Variance", node, opts);\n}\nfunction assertVoidTypeAnnotation(node, opts) {\n  assert("VoidTypeAnnotation", node, opts);\n}\nfunction assertEnumDeclaration(node, opts) {\n  assert("EnumDeclaration", node, opts);\n}\nfunction assertEnumBooleanBody(node, opts) {\n  assert("EnumBooleanBody", node, opts);\n}\nfunction assertEnumNumberBody(node, opts) {\n  assert("EnumNumberBody", node, opts);\n}\nfunction assertEnumStringBody(node, opts) {\n  assert("EnumStringBody", node, opts);\n}\nfunction assertEnumSymbolBody(node, opts) {\n  assert("EnumSymbolBody", node, opts);\n}\nfunction assertEnumBooleanMember(node, opts) {\n  assert("EnumBooleanMember", node, opts);\n}\nfunction assertEnumNumberMember(node, opts) {\n  assert("EnumNumberMember", node, opts);\n}\nfunction assertEnumStringMember(node, opts) {\n  assert("EnumStringMember", node, opts);\n}\nfunction assertEnumDefaultedMember(node, opts) {\n  assert("EnumDefaultedMember", node, opts);\n}\nfunction assertIndexedAccessType(node, opts) {\n  assert("IndexedAccessType", node, opts);\n}\nfunction assertOptionalIndexedAccessType(node, opts) {\n  assert("OptionalIndexedAccessType", node, opts);\n}\nfunction assertJSXAttribute(node, opts) {\n  assert("JSXAttribute", node, opts);\n}\nfunction assertJSXClosingElement(node, opts) {\n  assert("JSXClosingElement", node, opts);\n}\nfunction assertJSXElement(node, opts) {\n  assert("JSXElement", node, opts);\n}\nfunction assertJSXEmptyExpression(node, opts) {\n  assert("JSXEmptyExpression", node, opts);\n}\nfunction assertJSXExpressionContainer(node, opts) {\n  assert("JSXExpressionContainer", node, opts);\n}\nfunction assertJSXSpreadChild(node, opts) {\n  assert("JSXSpreadChild", node, opts);\n}\nfunction assertJSXIdentifier(node, opts) {\n  assert("JSXIdentifier", node, opts);\n}\nfunction assertJSXMemberExpression(node, opts) {\n  assert("JSXMemberExpression", node, opts);\n}\nfunction assertJSXNamespacedName(node, opts) {\n  assert("JSXNamespacedName", node, opts);\n}\nfunction assertJSXOpeningElement(node, opts) {\n  assert("JSXOpeningElement", node, opts);\n}\nfunction assertJSXSpreadAttribute(node, opts) {\n  assert("JSXSpreadAttribute", node, opts);\n}\nfunction assertJSXText(node, opts) {\n  assert("JSXText", node, opts);\n}\nfunction assertJSXFragment(node, opts) {\n  assert("JSXFragment", node, opts);\n}\nfunction assertJSXOpeningFragment(node, opts) {\n  assert("JSXOpeningFragment", node, opts);\n}\nfunction assertJSXClosingFragment(node, opts) {\n  assert("JSXClosingFragment", node, opts);\n}\nfunction assertNoop(node, opts) {\n  assert("Noop", node, opts);\n}\nfunction assertPlaceholder(node, opts) {\n  assert("Placeholder", node, opts);\n}\nfunction assertV8IntrinsicIdentifier(node, opts) {\n  assert("V8IntrinsicIdentifier", node, opts);\n}\nfunction assertArgumentPlaceholder(node, opts) {\n  assert("ArgumentPlaceholder", node, opts);\n}\nfunction assertBindExpression(node, opts) {\n  assert("BindExpression", node, opts);\n}\nfunction assertImportAttribute(node, opts) {\n  assert("ImportAttribute", node, opts);\n}\nfunction assertDecorator(node, opts) {\n  assert("Decorator", node, opts);\n}\nfunction assertDoExpression(node, opts) {\n  assert("DoExpression", node, opts);\n}\nfunction assertExportDefaultSpecifier(node, opts) {\n  assert("ExportDefaultSpecifier", node, opts);\n}\nfunction assertRecordExpression(node, opts) {\n  assert("RecordExpression", node, opts);\n}\nfunction assertTupleExpression(node, opts) {\n  assert("TupleExpression", node, opts);\n}\nfunction assertDecimalLiteral(node, opts) {\n  assert("DecimalLiteral", node, opts);\n}\nfunction assertModuleExpression(node, opts) {\n  assert("ModuleExpression", node, opts);\n}\nfunction assertTopicReference(node, opts) {\n  assert("TopicReference", node, opts);\n}\nfunction assertPipelineTopicExpression(node, opts) {\n  assert("PipelineTopicExpression", node, opts);\n}\nfunction assertPipelineBareFunction(node, opts) {\n  assert("PipelineBareFunction", node, opts);\n}\nfunction assertPipelinePrimaryTopicReference(node, opts) {\n  assert("PipelinePrimaryTopicReference", node, opts);\n}\nfunction assertTSParameterProperty(node, opts) {\n  assert("TSParameterProperty", node, opts);\n}\nfunction assertTSDeclareFunction(node, opts) {\n  assert("TSDeclareFunction", node, opts);\n}\nfunction assertTSDeclareMethod(node, opts) {\n  assert("TSDeclareMethod", node, opts);\n}\nfunction assertTSQualifiedName(node, opts) {\n  assert("TSQualifiedName", node, opts);\n}\nfunction assertTSCallSignatureDeclaration(node, opts) {\n  assert("TSCallSignatureDeclaration", node, opts);\n}\nfunction assertTSConstructSignatureDeclaration(node, opts) {\n  assert("TSConstructSignatureDeclaration", node, opts);\n}\nfunction assertTSPropertySignature(node, opts) {\n  assert("TSPropertySignature", node, opts);\n}\nfunction assertTSMethodSignature(node, opts) {\n  assert("TSMethodSignature", node, opts);\n}\nfunction assertTSIndexSignature(node, opts) {\n  assert("TSIndexSignature", node, opts);\n}\nfunction assertTSAnyKeyword(node, opts) {\n  assert("TSAnyKeyword", node, opts);\n}\nfunction assertTSBooleanKeyword(node, opts) {\n  assert("TSBooleanKeyword", node, opts);\n}\nfunction assertTSBigIntKeyword(node, opts) {\n  assert("TSBigIntKeyword", node, opts);\n}\nfunction assertTSIntrinsicKeyword(node, opts) {\n  assert("TSIntrinsicKeyword", node, opts);\n}\nfunction assertTSNeverKeyword(node, opts) {\n  assert("TSNeverKeyword", node, opts);\n}\nfunction assertTSNullKeyword(node, opts) {\n  assert("TSNullKeyword", node, opts);\n}\nfunction assertTSNumberKeyword(node, opts) {\n  assert("TSNumberKeyword", node, opts);\n}\nfunction assertTSObjectKeyword(node, opts) {\n  assert("TSObjectKeyword", node, opts);\n}\nfunction assertTSStringKeyword(node, opts) {\n  assert("TSStringKeyword", node, opts);\n}\nfunction assertTSSymbolKeyword(node, opts) {\n  assert("TSSymbolKeyword", node, opts);\n}\nfunction assertTSUndefinedKeyword(node, opts) {\n  assert("TSUndefinedKeyword", node, opts);\n}\nfunction assertTSUnknownKeyword(node, opts) {\n  assert("TSUnknownKeyword", node, opts);\n}\nfunction assertTSVoidKeyword(node, opts) {\n  assert("TSVoidKeyword", node, opts);\n}\nfunction assertTSThisType(node, opts) {\n  assert("TSThisType", node, opts);\n}\nfunction assertTSFunctionType(node, opts) {\n  assert("TSFunctionType", node, opts);\n}\nfunction assertTSConstructorType(node, opts) {\n  assert("TSConstructorType", node, opts);\n}\nfunction assertTSTypeReference(node, opts) {\n  assert("TSTypeReference", node, opts);\n}\nfunction assertTSTypePredicate(node, opts) {\n  assert("TSTypePredicate", node, opts);\n}\nfunction assertTSTypeQuery(node, opts) {\n  assert("TSTypeQuery", node, opts);\n}\nfunction assertTSTypeLiteral(node, opts) {\n  assert("TSTypeLiteral", node, opts);\n}\nfunction assertTSArrayType(node, opts) {\n  assert("TSArrayType", node, opts);\n}\nfunction assertTSTupleType(node, opts) {\n  assert("TSTupleType", node, opts);\n}\nfunction assertTSOptionalType(node, opts) {\n  assert("TSOptionalType", node, opts);\n}\nfunction assertTSRestType(node, opts) {\n  assert("TSRestType", node, opts);\n}\nfunction assertTSNamedTupleMember(node, opts) {\n  assert("TSNamedTupleMember", node, opts);\n}\nfunction assertTSUnionType(node, opts) {\n  assert("TSUnionType", node, opts);\n}\nfunction assertTSIntersectionType(node, opts) {\n  assert("TSIntersectionType", node, opts);\n}\nfunction assertTSConditionalType(node, opts) {\n  assert("TSConditionalType", node, opts);\n}\nfunction assertTSInferType(node, opts) {\n  assert("TSInferType", node, opts);\n}\nfunction assertTSParenthesizedType(node, opts) {\n  assert("TSParenthesizedType", node, opts);\n}\nfunction assertTSTypeOperator(node, opts) {\n  assert("TSTypeOperator", node, opts);\n}\nfunction assertTSIndexedAccessType(node, opts) {\n  assert("TSIndexedAccessType", node, opts);\n}\nfunction assertTSMappedType(node, opts) {\n  assert("TSMappedType", node, opts);\n}\nfunction assertTSLiteralType(node, opts) {\n  assert("TSLiteralType", node, opts);\n}\nfunction assertTSExpressionWithTypeArguments(node, opts) {\n  assert("TSExpressionWithTypeArguments", node, opts);\n}\nfunction assertTSInterfaceDeclaration(node, opts) {\n  assert("TSInterfaceDeclaration", node, opts);\n}\nfunction assertTSInterfaceBody(node, opts) {\n  assert("TSInterfaceBody", node, opts);\n}\nfunction assertTSTypeAliasDeclaration(node, opts) {\n  assert("TSTypeAliasDeclaration", node, opts);\n}\nfunction assertTSInstantiationExpression(node, opts) {\n  assert("TSInstantiationExpression", node, opts);\n}\nfunction assertTSAsExpression(node, opts) {\n  assert("TSAsExpression", node, opts);\n}\nfunction assertTSSatisfiesExpression(node, opts) {\n  assert("TSSatisfiesExpression", node, opts);\n}\nfunction assertTSTypeAssertion(node, opts) {\n  assert("TSTypeAssertion", node, opts);\n}\nfunction assertTSEnumDeclaration(node, opts) {\n  assert("TSEnumDeclaration", node, opts);\n}\nfunction assertTSEnumMember(node, opts) {\n  assert("TSEnumMember", node, opts);\n}\nfunction assertTSModuleDeclaration(node, opts) {\n  assert("TSModuleDeclaration", node, opts);\n}\nfunction assertTSModuleBlock(node, opts) {\n  assert("TSModuleBlock", node, opts);\n}\nfunction assertTSImportType(node, opts) {\n  assert("TSImportType", node, opts);\n}\nfunction assertTSImportEqualsDeclaration(node, opts) {\n  assert("TSImportEqualsDeclaration", node, opts);\n}\nfunction assertTSExternalModuleReference(node, opts) {\n  assert("TSExternalModuleReference", node, opts);\n}\nfunction assertTSNonNullExpression(node, opts) {\n  assert("TSNonNullExpression", node, opts);\n}\nfunction assertTSExportAssignment(node, opts) {\n  assert("TSExportAssignment", node, opts);\n}\nfunction assertTSNamespaceExportDeclaration(node, opts) {\n  assert("TSNamespaceExportDeclaration", node, opts);\n}\nfunction assertTSTypeAnnotation(node, opts) {\n  assert("TSTypeAnnotation", node, opts);\n}\nfunction assertTSTypeParameterInstantiation(node, opts) {\n  assert("TSTypeParameterInstantiation", node, opts);\n}\nfunction assertTSTypeParameterDeclaration(node, opts) {\n  assert("TSTypeParameterDeclaration", node, opts);\n}\nfunction assertTSTypeParameter(node, opts) {\n  assert("TSTypeParameter", node, opts);\n}\nfunction assertStandardized(node, opts) {\n  assert("Standardized", node, opts);\n}\nfunction assertExpression(node, opts) {\n  assert("Expression", node, opts);\n}\nfunction assertBinary(node, opts) {\n  assert("Binary", node, opts);\n}\nfunction assertScopable(node, opts) {\n  assert("Scopable", node, opts);\n}\nfunction assertBlockParent(node, opts) {\n  assert("BlockParent", node, opts);\n}\nfunction assertBlock(node, opts) {\n  assert("Block", node, opts);\n}\nfunction assertStatement(node, opts) {\n  assert("Statement", node, opts);\n}\nfunction assertTerminatorless(node, opts) {\n  assert("Terminatorless", node, opts);\n}\nfunction assertCompletionStatement(node, opts) {\n  assert("CompletionStatement", node, opts);\n}\nfunction assertConditional(node, opts) {\n  assert("Conditional", node, opts);\n}\nfunction assertLoop(node, opts) {\n  assert("Loop", node, opts);\n}\nfunction assertWhile(node, opts) {\n  assert("While", node, opts);\n}\nfunction assertExpressionWrapper(node, opts) {\n  assert("ExpressionWrapper", node, opts);\n}\nfunction assertFor(node, opts) {\n  assert("For", node, opts);\n}\nfunction assertForXStatement(node, opts) {\n  assert("ForXStatement", node, opts);\n}\nfunction assertFunction(node, opts) {\n  assert("Function", node, opts);\n}\nfunction assertFunctionParent(node, opts) {\n  assert("FunctionParent", node, opts);\n}\nfunction assertPureish(node, opts) {\n  assert("Pureish", node, opts);\n}\nfunction assertDeclaration(node, opts) {\n  assert("Declaration", node, opts);\n}\nfunction assertPatternLike(node, opts) {\n  assert("PatternLike", node, opts);\n}\nfunction assertLVal(node, opts) {\n  assert("LVal", node, opts);\n}\nfunction assertTSEntityName(node, opts) {\n  assert("TSEntityName", node, opts);\n}\nfunction assertLiteral(node, opts) {\n  assert("Literal", node, opts);\n}\nfunction assertImmutable(node, opts) {\n  assert("Immutable", node, opts);\n}\nfunction assertUserWhitespacable(node, opts) {\n  assert("UserWhitespacable", node, opts);\n}\nfunction assertMethod(node, opts) {\n  assert("Method", node, opts);\n}\nfunction assertObjectMember(node, opts) {\n  assert("ObjectMember", node, opts);\n}\nfunction assertProperty(node, opts) {\n  assert("Property", node, opts);\n}\nfunction assertUnaryLike(node, opts) {\n  assert("UnaryLike", node, opts);\n}\nfunction assertPattern(node, opts) {\n  assert("Pattern", node, opts);\n}\nfunction assertClass(node, opts) {\n  assert("Class", node, opts);\n}\nfunction assertImportOrExportDeclaration(node, opts) {\n  assert("ImportOrExportDeclaration", node, opts);\n}\nfunction assertExportDeclaration(node, opts) {\n  assert("ExportDeclaration", node, opts);\n}\nfunction assertModuleSpecifier(node, opts) {\n  assert("ModuleSpecifier", node, opts);\n}\nfunction assertAccessor(node, opts) {\n  assert("Accessor", node, opts);\n}\nfunction assertPrivate(node, opts) {\n  assert("Private", node, opts);\n}\nfunction assertFlow(node, opts) {\n  assert("Flow", node, opts);\n}\nfunction assertFlowType(node, opts) {\n  assert("FlowType", node, opts);\n}\nfunction assertFlowBaseAnnotation(node, opts) {\n  assert("FlowBaseAnnotation", node, opts);\n}\nfunction assertFlowDeclaration(node, opts) {\n  assert("FlowDeclaration", node, opts);\n}\nfunction assertFlowPredicate(node, opts) {\n  assert("FlowPredicate", node, opts);\n}\nfunction assertEnumBody(node, opts) {\n  assert("EnumBody", node, opts);\n}\nfunction assertEnumMember(node, opts) {\n  assert("EnumMember", node, opts);\n}\nfunction assertJSX(node, opts) {\n  assert("JSX", node, opts);\n}\nfunction assertMiscellaneous(node, opts) {\n  assert("Miscellaneous", node, opts);\n}\nfunction assertTypeScript(node, opts) {\n  assert("TypeScript", node, opts);\n}\nfunction assertTSTypeElement(node, opts) {\n  assert("TSTypeElement", node, opts);\n}\nfunction assertTSType(node, opts) {\n  assert("TSType", node, opts);\n}\nfunction assertTSBaseType(node, opts) {\n  assert("TSBaseType", node, opts);\n}\nfunction assertNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");\n  assert("NumberLiteral", node, opts);\n}\nfunction assertRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");\n  assert("RegexLiteral", node, opts);\n}\nfunction assertRestProperty(node, opts) {\n  (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");\n  assert("RestProperty", node, opts);\n}\nfunction assertSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");\n  assert("SpreadProperty", node, opts);\n}\nfunction assertModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");\n  assert("ModuleDeclaration", node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIyNDYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0JBQXNCO0FBQ3RCLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMscUNBQXFDO0FBQ3JDLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIsOEJBQThCO0FBQzlCLDRCQUE0QjtBQUM1QixtQkFBbUI7QUFDbkIseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QixtQkFBbUI7QUFDbkIsbUNBQW1DO0FBQ25DLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQywyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLHlCQUF5QjtBQUN6QixtQ0FBbUM7QUFDbkMsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLDBCQUEwQjtBQUMxQix5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3QiwrQkFBK0I7QUFDL0IsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUIsaUNBQWlDO0FBQ2pDLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsK0JBQStCO0FBQy9CLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQywrQkFBK0I7QUFDL0Isc0NBQXNDO0FBQ3RDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGdDQUFnQztBQUNoQyw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0QixpQkFBaUI7QUFDakIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLHNCQUFzQjtBQUN0QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixvQ0FBb0M7QUFDcEMsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsOEJBQThCO0FBQzlCLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsNkJBQTZCO0FBQzdCLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLHdDQUF3QztBQUN4QyxpQkFBaUI7QUFDakIsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsd0JBQXdCO0FBQ3hCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixxQkFBcUI7QUFDckIsK0JBQStCO0FBQy9CLGtCQUFrQjtBQUNsQiw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixrQkFBa0I7QUFDbEIseUJBQXlCO0FBQ3pCLHVDQUF1QztBQUN2QyxvQ0FBb0M7QUFDcEMsMkJBQTJCO0FBQzNCLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLG9DQUFvQztBQUNwQywrQkFBK0I7QUFDL0Isb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxzQ0FBc0M7QUFDdEMsd0JBQXdCO0FBQ3hCLG9DQUFvQztBQUNwQyx1Q0FBdUM7QUFDdkMsc0NBQXNDO0FBQ3RDLHFDQUFxQztBQUNyQyxxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLGtDQUFrQztBQUNsQywyQ0FBMkM7QUFDM0MscUNBQXFDO0FBQ3JDLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsZ0NBQWdDO0FBQ2hDLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEMsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0Isa0NBQWtDO0FBQ2xDLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsOEJBQThCO0FBQzlCLHdDQUF3QztBQUN4QywrQkFBK0I7QUFDL0IsNkNBQTZDO0FBQzdDLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsMEJBQTBCO0FBQzFCLGdDQUFnQztBQUNoQywyQ0FBMkM7QUFDM0MsdUNBQXVDO0FBQ3ZDLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkMsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMseUJBQXlCO0FBQ3pCLHVDQUF1QztBQUN2Qyw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLDBCQUEwQjtBQUMxQiwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsMENBQTBDO0FBQzFDLDRCQUE0QjtBQUM1QixpQ0FBaUM7QUFDakMsMkJBQTJCO0FBQzNCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3Qix3QkFBd0I7QUFDeEIsbUNBQW1DO0FBQ25DLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0Isd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsb0NBQW9DO0FBQ3BDLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUMsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLHlCQUF5QjtBQUN6Qiw4QkFBOEI7QUFDOUIsMkJBQTJCO0FBQzNCLHNDQUFzQztBQUN0Qyw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QixpQ0FBaUM7QUFDakMsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLHNDQUFzQztBQUN0Qyx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQyw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLGlDQUFpQztBQUNqQyw4QkFBOEI7QUFDOUIsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLHNCQUFzQjtBQUN0QixnQ0FBZ0M7QUFDaEMsbUJBQW1CO0FBQ25CLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsNkJBQTZCO0FBQzdCLFVBQVUsbUJBQU8sQ0FBQyxLQUF3QjtBQUMxQywwQkFBMEIsbUJBQU8sQ0FBQyxLQUFtQztBQUNyRTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssZ0JBQWdCLHFCQUFxQiwwQkFBMEIsVUFBVTtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9hc3NlcnRzL2dlbmVyYXRlZC9pbmRleC5qcz80MTVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hc3NlcnRBY2Nlc3NvciA9IGFzc2VydEFjY2Vzc29yO1xuZXhwb3J0cy5hc3NlcnRBbnlUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEFueVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRBcmd1bWVudFBsYWNlaG9sZGVyID0gYXNzZXJ0QXJndW1lbnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuYXNzZXJ0QXJyYXlFeHByZXNzaW9uID0gYXNzZXJ0QXJyYXlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBcnJheVBhdHRlcm4gPSBhc3NlcnRBcnJheVBhdHRlcm47XG5leHBvcnRzLmFzc2VydEFycmF5VHlwZUFubm90YXRpb24gPSBhc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbiA9IGFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGFzc2VydEFzc2lnbm1lbnRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRBc3NpZ25tZW50UGF0dGVybiA9IGFzc2VydEFzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRBd2FpdEV4cHJlc3Npb24gPSBhc3NlcnRBd2FpdEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydEJpZ0ludExpdGVyYWwgPSBhc3NlcnRCaWdJbnRMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRCaW5hcnkgPSBhc3NlcnRCaW5hcnk7XG5leHBvcnRzLmFzc2VydEJpbmFyeUV4cHJlc3Npb24gPSBhc3NlcnRCaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCaW5kRXhwcmVzc2lvbiA9IGFzc2VydEJpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRCbG9jayA9IGFzc2VydEJsb2NrO1xuZXhwb3J0cy5hc3NlcnRCbG9ja1BhcmVudCA9IGFzc2VydEJsb2NrUGFyZW50O1xuZXhwb3J0cy5hc3NlcnRCbG9ja1N0YXRlbWVudCA9IGFzc2VydEJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRCb29sZWFuTGl0ZXJhbCA9IGFzc2VydEJvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0Qm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRCcmVha1N0YXRlbWVudCA9IGFzc2VydEJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRDYWxsRXhwcmVzc2lvbiA9IGFzc2VydENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDYXRjaENsYXVzZSA9IGFzc2VydENhdGNoQ2xhdXNlO1xuZXhwb3J0cy5hc3NlcnRDbGFzcyA9IGFzc2VydENsYXNzO1xuZXhwb3J0cy5hc3NlcnRDbGFzc0FjY2Vzc29yUHJvcGVydHkgPSBhc3NlcnRDbGFzc0FjY2Vzc29yUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydENsYXNzQm9keSA9IGFzc2VydENsYXNzQm9keTtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NEZWNsYXJhdGlvbiA9IGFzc2VydENsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydENsYXNzRXhwcmVzc2lvbiA9IGFzc2VydENsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0Q2xhc3NJbXBsZW1lbnRzID0gYXNzZXJ0Q2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5hc3NlcnRDbGFzc01ldGhvZCA9IGFzc2VydENsYXNzTWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRDbGFzc1ByaXZhdGVNZXRob2QgPSBhc3NlcnRDbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5ID0gYXNzZXJ0Q2xhc3NQcml2YXRlUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydENsYXNzUHJvcGVydHkgPSBhc3NlcnRDbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRDb21wbGV0aW9uU3RhdGVtZW50ID0gYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Q29uZGl0aW9uYWwgPSBhc3NlcnRDb25kaXRpb25hbDtcbmV4cG9ydHMuYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uID0gYXNzZXJ0Q29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRDb250aW51ZVN0YXRlbWVudCA9IGFzc2VydENvbnRpbnVlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREZWJ1Z2dlclN0YXRlbWVudCA9IGFzc2VydERlYnVnZ2VyU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnREZWNpbWFsTGl0ZXJhbCA9IGFzc2VydERlY2ltYWxMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJhdGlvbiA9IGFzc2VydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlQ2xhc3MgPSBhc3NlcnREZWNsYXJlQ2xhc3M7XG5leHBvcnRzLmFzc2VydERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGFzc2VydERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0RGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlRnVuY3Rpb24gPSBhc3NlcnREZWNsYXJlRnVuY3Rpb247XG5leHBvcnRzLmFzc2VydERlY2xhcmVJbnRlcmZhY2UgPSBhc3NlcnREZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5hc3NlcnREZWNsYXJlTW9kdWxlID0gYXNzZXJ0RGVjbGFyZU1vZHVsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBhc3NlcnREZWNsYXJlTW9kdWxlRXhwb3J0cztcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGUgPSBhc3NlcnREZWNsYXJlT3BhcXVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZVR5cGVBbGlhcyA9IGFzc2VydERlY2xhcmVUeXBlQWxpYXM7XG5leHBvcnRzLmFzc2VydERlY2xhcmVWYXJpYWJsZSA9IGFzc2VydERlY2xhcmVWYXJpYWJsZTtcbmV4cG9ydHMuYXNzZXJ0RGVjbGFyZWRQcmVkaWNhdGUgPSBhc3NlcnREZWNsYXJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuYXNzZXJ0RGVjb3JhdG9yID0gYXNzZXJ0RGVjb3JhdG9yO1xuZXhwb3J0cy5hc3NlcnREaXJlY3RpdmUgPSBhc3NlcnREaXJlY3RpdmU7XG5leHBvcnRzLmFzc2VydERpcmVjdGl2ZUxpdGVyYWwgPSBhc3NlcnREaXJlY3RpdmVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnREb0V4cHJlc3Npb24gPSBhc3NlcnREb0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydERvV2hpbGVTdGF0ZW1lbnQgPSBhc3NlcnREb1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRFbXB0eVN0YXRlbWVudCA9IGFzc2VydEVtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRFbXB0eVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0RW1wdHlUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvZHkgPSBhc3NlcnRFbnVtQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bUJvb2xlYW5Cb2R5ID0gYXNzZXJ0RW51bUJvb2xlYW5Cb2R5O1xuZXhwb3J0cy5hc3NlcnRFbnVtQm9vbGVhbk1lbWJlciA9IGFzc2VydEVudW1Cb29sZWFuTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtRGVjbGFyYXRpb24gPSBhc3NlcnRFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEVudW1EZWZhdWx0ZWRNZW1iZXIgPSBhc3NlcnRFbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtTWVtYmVyID0gYXNzZXJ0RW51bU1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlckJvZHkgPSBhc3NlcnRFbnVtTnVtYmVyQm9keTtcbmV4cG9ydHMuYXNzZXJ0RW51bU51bWJlck1lbWJlciA9IGFzc2VydEVudW1OdW1iZXJNZW1iZXI7XG5leHBvcnRzLmFzc2VydEVudW1TdHJpbmdCb2R5ID0gYXNzZXJ0RW51bVN0cmluZ0JvZHk7XG5leHBvcnRzLmFzc2VydEVudW1TdHJpbmdNZW1iZXIgPSBhc3NlcnRFbnVtU3RyaW5nTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRFbnVtU3ltYm9sQm9keSA9IGFzc2VydEVudW1TeW1ib2xCb2R5O1xuZXhwb3J0cy5hc3NlcnRFeGlzdHNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEV4aXN0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWNsYXJhdGlvbiA9IGFzc2VydEV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24gPSBhc3NlcnRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEV4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBhc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnROYW1lZERlY2xhcmF0aW9uID0gYXNzZXJ0RXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRFeHBvcnRTcGVjaWZpZXIgPSBhc3NlcnRFeHBvcnRTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydEV4cHJlc3Npb24gPSBhc3NlcnRFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRFeHByZXNzaW9uU3RhdGVtZW50ID0gYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXIgPSBhc3NlcnRFeHByZXNzaW9uV3JhcHBlcjtcbmV4cG9ydHMuYXNzZXJ0RmlsZSA9IGFzc2VydEZpbGU7XG5leHBvcnRzLmFzc2VydEZsb3cgPSBhc3NlcnRGbG93O1xuZXhwb3J0cy5hc3NlcnRGbG93QmFzZUFubm90YXRpb24gPSBhc3NlcnRGbG93QmFzZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEZsb3dEZWNsYXJhdGlvbiA9IGFzc2VydEZsb3dEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0Rmxvd1ByZWRpY2F0ZSA9IGFzc2VydEZsb3dQcmVkaWNhdGU7XG5leHBvcnRzLmFzc2VydEZsb3dUeXBlID0gYXNzZXJ0Rmxvd1R5cGU7XG5leHBvcnRzLmFzc2VydEZvciA9IGFzc2VydEZvcjtcbmV4cG9ydHMuYXNzZXJ0Rm9ySW5TdGF0ZW1lbnQgPSBhc3NlcnRGb3JJblN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Rm9yT2ZTdGF0ZW1lbnQgPSBhc3NlcnRGb3JPZlN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0Rm9yU3RhdGVtZW50ID0gYXNzZXJ0Rm9yU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRGb3JYU3RhdGVtZW50ID0gYXNzZXJ0Rm9yWFN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb24gPSBhc3NlcnRGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25EZWNsYXJhdGlvbiA9IGFzc2VydEZ1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbiA9IGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25QYXJlbnQgPSBhc3NlcnRGdW5jdGlvblBhcmVudDtcbmV4cG9ydHMuYXNzZXJ0RnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGFzc2VydEZ1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydEZ1bmN0aW9uVHlwZVBhcmFtID0gYXNzZXJ0RnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLmFzc2VydEdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGFzc2VydEdlbmVyaWNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SWRlbnRpZmllciA9IGFzc2VydElkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydElmU3RhdGVtZW50ID0gYXNzZXJ0SWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydEltbXV0YWJsZSA9IGFzc2VydEltbXV0YWJsZTtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0ID0gYXNzZXJ0SW1wb3J0O1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRBdHRyaWJ1dGUgPSBhc3NlcnRJbXBvcnRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydEltcG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0SW1wb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydEltcG9ydERlZmF1bHRTcGVjaWZpZXIgPSBhc3NlcnRJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRFeHByZXNzaW9uID0gYXNzZXJ0SW1wb3J0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0SW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW1wb3J0U3BlY2lmaWVyID0gYXNzZXJ0SW1wb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5hc3NlcnRJbmRleGVkQWNjZXNzVHlwZSA9IGFzc2VydEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5hc3NlcnRJbmZlcnJlZFByZWRpY2F0ZSA9IGFzc2VydEluZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VEZWNsYXJhdGlvbiA9IGFzc2VydEludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRJbnRlcmZhY2VFeHRlbmRzID0gYXNzZXJ0SW50ZXJmYWNlRXh0ZW5kcztcbmV4cG9ydHMuYXNzZXJ0SW50ZXJmYWNlVHlwZUFubm90YXRpb24gPSBhc3NlcnRJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmUgPSBhc3NlcnRJbnRlcnByZXRlckRpcmVjdGl2ZTtcbmV4cG9ydHMuYXNzZXJ0SW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBhc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0SlNYID0gYXNzZXJ0SlNYO1xuZXhwb3J0cy5hc3NlcnRKU1hBdHRyaWJ1dGUgPSBhc3NlcnRKU1hBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydEpTWENsb3NpbmdFbGVtZW50ID0gYXNzZXJ0SlNYQ2xvc2luZ0VsZW1lbnQ7XG5leHBvcnRzLmFzc2VydEpTWENsb3NpbmdGcmFnbWVudCA9IGFzc2VydEpTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYRWxlbWVudCA9IGFzc2VydEpTWEVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydEpTWEVtcHR5RXhwcmVzc2lvbiA9IGFzc2VydEpTWEVtcHR5RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SlNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGFzc2VydEpTWEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmFzc2VydEpTWEZyYWdtZW50ID0gYXNzZXJ0SlNYRnJhZ21lbnQ7XG5leHBvcnRzLmFzc2VydEpTWElkZW50aWZpZXIgPSBhc3NlcnRKU1hJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRKU1hNZW1iZXJFeHByZXNzaW9uID0gYXNzZXJ0SlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0SlNYTmFtZXNwYWNlZE5hbWUgPSBhc3NlcnRKU1hOYW1lc3BhY2VkTmFtZTtcbmV4cG9ydHMuYXNzZXJ0SlNYT3BlbmluZ0VsZW1lbnQgPSBhc3NlcnRKU1hPcGVuaW5nRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50ID0gYXNzZXJ0SlNYT3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5hc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGUgPSBhc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGU7XG5leHBvcnRzLmFzc2VydEpTWFNwcmVhZENoaWxkID0gYXNzZXJ0SlNYU3ByZWFkQ2hpbGQ7XG5leHBvcnRzLmFzc2VydEpTWFRleHQgPSBhc3NlcnRKU1hUZXh0O1xuZXhwb3J0cy5hc3NlcnRMVmFsID0gYXNzZXJ0TFZhbDtcbmV4cG9ydHMuYXNzZXJ0TGFiZWxlZFN0YXRlbWVudCA9IGFzc2VydExhYmVsZWRTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydExpdGVyYWwgPSBhc3NlcnRMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRMb2dpY2FsRXhwcmVzc2lvbiA9IGFzc2VydExvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRMb29wID0gYXNzZXJ0TG9vcDtcbmV4cG9ydHMuYXNzZXJ0TWVtYmVyRXhwcmVzc2lvbiA9IGFzc2VydE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydE1ldGFQcm9wZXJ0eSA9IGFzc2VydE1ldGFQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0TWV0aG9kID0gYXNzZXJ0TWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRNaXNjZWxsYW5lb3VzID0gYXNzZXJ0TWlzY2VsbGFuZW91cztcbmV4cG9ydHMuYXNzZXJ0TWl4ZWRUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE1peGVkVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE1vZHVsZURlY2xhcmF0aW9uID0gYXNzZXJ0TW9kdWxlRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydE1vZHVsZUV4cHJlc3Npb24gPSBhc3NlcnRNb2R1bGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRNb2R1bGVTcGVjaWZpZXIgPSBhc3NlcnRNb2R1bGVTcGVjaWZpZXI7XG5leHBvcnRzLmFzc2VydE5ld0V4cHJlc3Npb24gPSBhc3NlcnROZXdFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnROb29wID0gYXNzZXJ0Tm9vcDtcbmV4cG9ydHMuYXNzZXJ0TnVsbExpdGVyYWwgPSBhc3NlcnROdWxsTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0TnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydE51bGxhYmxlVHlwZUFubm90YXRpb24gPSBhc3NlcnROdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJMaXRlcmFsID0gYXNzZXJ0TnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0TnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0TnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1iZXJUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE51bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnROdW1lcmljTGl0ZXJhbCA9IGFzc2VydE51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RFeHByZXNzaW9uID0gYXNzZXJ0T2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0TWVtYmVyID0gYXNzZXJ0T2JqZWN0TWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RNZXRob2QgPSBhc3NlcnRPYmplY3RNZXRob2Q7XG5leHBvcnRzLmFzc2VydE9iamVjdFBhdHRlcm4gPSBhc3NlcnRPYmplY3RQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlQW5ub3RhdGlvbiA9IGFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXIgPSBhc3NlcnRPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZUludGVybmFsU2xvdCA9IGFzc2VydE9iamVjdFR5cGVJbnRlcm5hbFNsb3Q7XG5leHBvcnRzLmFzc2VydE9iamVjdFR5cGVQcm9wZXJ0eSA9IGFzc2VydE9iamVjdFR5cGVQcm9wZXJ0eTtcbmV4cG9ydHMuYXNzZXJ0T2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5ID0gYXNzZXJ0T2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRPcGFxdWVUeXBlID0gYXNzZXJ0T3BhcXVlVHlwZTtcbmV4cG9ydHMuYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGFzc2VydE9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUgPSBhc3NlcnRPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5hc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb24gPSBhc3NlcnRPcHRpb25hbE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gYXNzZXJ0UGFyZW50aGVzaXplZEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFBhdHRlcm4gPSBhc3NlcnRQYXR0ZXJuO1xuZXhwb3J0cy5hc3NlcnRQYXR0ZXJuTGlrZSA9IGFzc2VydFBhdHRlcm5MaWtlO1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbiA9IGFzc2VydFBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IGFzc2VydFBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5hc3NlcnRQaXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IGFzc2VydFBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRQbGFjZWhvbGRlciA9IGFzc2VydFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5hc3NlcnRQcml2YXRlID0gYXNzZXJ0UHJpdmF0ZTtcbmV4cG9ydHMuYXNzZXJ0UHJpdmF0ZU5hbWUgPSBhc3NlcnRQcml2YXRlTmFtZTtcbmV4cG9ydHMuYXNzZXJ0UHJvZ3JhbSA9IGFzc2VydFByb2dyYW07XG5leHBvcnRzLmFzc2VydFByb3BlcnR5ID0gYXNzZXJ0UHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFB1cmVpc2ggPSBhc3NlcnRQdXJlaXNoO1xuZXhwb3J0cy5hc3NlcnRRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGFzc2VydFF1YWxpZmllZFR5cGVJZGVudGlmaWVyO1xuZXhwb3J0cy5hc3NlcnRSZWNvcmRFeHByZXNzaW9uID0gYXNzZXJ0UmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0UmVnRXhwTGl0ZXJhbCA9IGFzc2VydFJlZ0V4cExpdGVyYWw7XG5leHBvcnRzLmFzc2VydFJlZ2V4TGl0ZXJhbCA9IGFzc2VydFJlZ2V4TGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0UmVzdEVsZW1lbnQgPSBhc3NlcnRSZXN0RWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0UmVzdFByb3BlcnR5ID0gYXNzZXJ0UmVzdFByb3BlcnR5O1xuZXhwb3J0cy5hc3NlcnRSZXR1cm5TdGF0ZW1lbnQgPSBhc3NlcnRSZXR1cm5TdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFNjb3BhYmxlID0gYXNzZXJ0U2NvcGFibGU7XG5leHBvcnRzLmFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbiA9IGFzc2VydFNlcXVlbmNlRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0U3ByZWFkRWxlbWVudCA9IGFzc2VydFNwcmVhZEVsZW1lbnQ7XG5leHBvcnRzLmFzc2VydFNwcmVhZFByb3BlcnR5ID0gYXNzZXJ0U3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFN0YW5kYXJkaXplZCA9IGFzc2VydFN0YW5kYXJkaXplZDtcbmV4cG9ydHMuYXNzZXJ0U3RhdGVtZW50ID0gYXNzZXJ0U3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTdGF0aWNCbG9jayA9IGFzc2VydFN0YXRpY0Jsb2NrO1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdMaXRlcmFsID0gYXNzZXJ0U3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0U3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0U3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRTdHJpbmdUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRTdXBlciA9IGFzc2VydFN1cGVyO1xuZXhwb3J0cy5hc3NlcnRTd2l0Y2hDYXNlID0gYXNzZXJ0U3dpdGNoQ2FzZTtcbmV4cG9ydHMuYXNzZXJ0U3dpdGNoU3RhdGVtZW50ID0gYXNzZXJ0U3dpdGNoU3RhdGVtZW50O1xuZXhwb3J0cy5hc3NlcnRTeW1ib2xUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFN5bWJvbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0FueUtleXdvcmQgPSBhc3NlcnRUU0FueUtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTQXJyYXlUeXBlID0gYXNzZXJ0VFNBcnJheVR5cGU7XG5leHBvcnRzLmFzc2VydFRTQXNFeHByZXNzaW9uID0gYXNzZXJ0VFNBc0V4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRTQmFzZVR5cGUgPSBhc3NlcnRUU0Jhc2VUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0JpZ0ludEtleXdvcmQgPSBhc3NlcnRUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTQm9vbGVhbktleXdvcmQgPSBhc3NlcnRUU0Jvb2xlYW5LZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU0NvbmRpdGlvbmFsVHlwZSA9IGFzc2VydFRTQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUgPSBhc3NlcnRUU0NvbnN0cnVjdG9yVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb24gPSBhc3NlcnRUU0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNEZWNsYXJlTWV0aG9kID0gYXNzZXJ0VFNEZWNsYXJlTWV0aG9kO1xuZXhwb3J0cy5hc3NlcnRUU0VudGl0eU5hbWUgPSBhc3NlcnRUU0VudGl0eU5hbWU7XG5leHBvcnRzLmFzc2VydFRTRW51bURlY2xhcmF0aW9uID0gYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTRW51bU1lbWJlciA9IGFzc2VydFRTRW51bU1lbWJlcjtcbmV4cG9ydHMuYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50ID0gYXNzZXJ0VFNFeHBvcnRBc3NpZ25tZW50O1xuZXhwb3J0cy5hc3NlcnRUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyA9IGFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy5hc3NlcnRUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlID0gYXNzZXJ0VFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbmV4cG9ydHMuYXNzZXJ0VFNGdW5jdGlvblR5cGUgPSBhc3NlcnRUU0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGFzc2VydFRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTSW1wb3J0VHlwZSA9IGFzc2VydFRTSW1wb3J0VHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNJbmRleFNpZ25hdHVyZSA9IGFzc2VydFRTSW5kZXhTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTSW5kZXhlZEFjY2Vzc1R5cGUgPSBhc3NlcnRUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0luZmVyVHlwZSA9IGFzc2VydFRTSW5mZXJUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gYXNzZXJ0VFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuYXNzZXJ0VFNJbnRlcmZhY2VCb2R5ID0gYXNzZXJ0VFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5hc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlID0gYXNzZXJ0VFNJbnRlcnNlY3Rpb25UeXBlO1xuZXhwb3J0cy5hc3NlcnRUU0ludHJpbnNpY0tleXdvcmQgPSBhc3NlcnRUU0ludHJpbnNpY0tleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTTGl0ZXJhbFR5cGUgPSBhc3NlcnRUU0xpdGVyYWxUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU01hcHBlZFR5cGUgPSBhc3NlcnRUU01hcHBlZFR5cGU7XG5leHBvcnRzLmFzc2VydFRTTWV0aG9kU2lnbmF0dXJlID0gYXNzZXJ0VFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLmFzc2VydFRTTW9kdWxlQmxvY2sgPSBhc3NlcnRUU01vZHVsZUJsb2NrO1xuZXhwb3J0cy5hc3NlcnRUU01vZHVsZURlY2xhcmF0aW9uID0gYXNzZXJ0VFNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyID0gYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy5hc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uID0gYXNzZXJ0VFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNOZXZlcktleXdvcmQgPSBhc3NlcnRUU05ldmVyS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbiA9IGFzc2VydFRTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRTTnVsbEtleXdvcmQgPSBhc3NlcnRUU051bGxLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUU051bWJlcktleXdvcmQgPSBhc3NlcnRUU051bWJlcktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTT2JqZWN0S2V5d29yZCA9IGFzc2VydFRTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNPcHRpb25hbFR5cGUgPSBhc3NlcnRUU09wdGlvbmFsVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGFzc2VydFRTUGFyYW1ldGVyUHJvcGVydHk7XG5leHBvcnRzLmFzc2VydFRTUGFyZW50aGVzaXplZFR5cGUgPSBhc3NlcnRUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5hc3NlcnRUU1Byb3BlcnR5U2lnbmF0dXJlID0gYXNzZXJ0VFNQcm9wZXJ0eVNpZ25hdHVyZTtcbmV4cG9ydHMuYXNzZXJ0VFNRdWFsaWZpZWROYW1lID0gYXNzZXJ0VFNRdWFsaWZpZWROYW1lO1xuZXhwb3J0cy5hc3NlcnRUU1Jlc3RUeXBlID0gYXNzZXJ0VFNSZXN0VHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNTYXRpc2ZpZXNFeHByZXNzaW9uID0gYXNzZXJ0VFNTYXRpc2ZpZXNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUU1N0cmluZ0tleXdvcmQgPSBhc3NlcnRUU1N0cmluZ0tleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTU3ltYm9sS2V5d29yZCA9IGFzc2VydFRTU3ltYm9sS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNUaGlzVHlwZSA9IGFzc2VydFRTVGhpc1R5cGU7XG5leHBvcnRzLmFzc2VydFRTVHVwbGVUeXBlID0gYXNzZXJ0VFNUdXBsZVR5cGU7XG5leHBvcnRzLmFzc2VydFRTVHlwZSA9IGFzc2VydFRTVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZUFubm90YXRpb24gPSBhc3NlcnRUU1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVBc3NlcnRpb24gPSBhc3NlcnRUU1R5cGVBc3NlcnRpb247XG5leHBvcnRzLmFzc2VydFRTVHlwZUVsZW1lbnQgPSBhc3NlcnRUU1R5cGVFbGVtZW50O1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVMaXRlcmFsID0gYXNzZXJ0VFNUeXBlTGl0ZXJhbDtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlT3BlcmF0b3IgPSBhc3NlcnRUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUGFyYW1ldGVyID0gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGFzc2VydFRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VFNUeXBlUHJlZGljYXRlID0gYXNzZXJ0VFNUeXBlUHJlZGljYXRlO1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVRdWVyeSA9IGFzc2VydFRTVHlwZVF1ZXJ5O1xuZXhwb3J0cy5hc3NlcnRUU1R5cGVSZWZlcmVuY2UgPSBhc3NlcnRUU1R5cGVSZWZlcmVuY2U7XG5leHBvcnRzLmFzc2VydFRTVW5kZWZpbmVkS2V5d29yZCA9IGFzc2VydFRTVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMuYXNzZXJ0VFNVbmlvblR5cGUgPSBhc3NlcnRUU1VuaW9uVHlwZTtcbmV4cG9ydHMuYXNzZXJ0VFNVbmtub3duS2V5d29yZCA9IGFzc2VydFRTVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLmFzc2VydFRTVm9pZEtleXdvcmQgPSBhc3NlcnRUU1ZvaWRLZXl3b3JkO1xuZXhwb3J0cy5hc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBhc3NlcnRUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFRlbXBsYXRlRWxlbWVudCA9IGFzc2VydFRlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VGVtcGxhdGVMaXRlcmFsID0gYXNzZXJ0VGVtcGxhdGVMaXRlcmFsO1xuZXhwb3J0cy5hc3NlcnRUZXJtaW5hdG9ybGVzcyA9IGFzc2VydFRlcm1pbmF0b3JsZXNzO1xuZXhwb3J0cy5hc3NlcnRUaGlzRXhwcmVzc2lvbiA9IGFzc2VydFRoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUaGlzVHlwZUFubm90YXRpb24gPSBhc3NlcnRUaGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFRocm93U3RhdGVtZW50ID0gYXNzZXJ0VGhyb3dTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFRvcGljUmVmZXJlbmNlID0gYXNzZXJ0VG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLmFzc2VydFRyeVN0YXRlbWVudCA9IGFzc2VydFRyeVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0VHVwbGVFeHByZXNzaW9uID0gYXNzZXJ0VHVwbGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRUdXBsZVR5cGVBbm5vdGF0aW9uID0gYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0VHlwZUFsaWFzID0gYXNzZXJ0VHlwZUFsaWFzO1xuZXhwb3J0cy5hc3NlcnRUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRUeXBlQ2FzdEV4cHJlc3Npb24gPSBhc3NlcnRUeXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFR5cGVQYXJhbWV0ZXIgPSBhc3NlcnRUeXBlUGFyYW1ldGVyO1xuZXhwb3J0cy5hc3NlcnRUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBhc3NlcnRUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gYXNzZXJ0VHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmFzc2VydFR5cGVTY3JpcHQgPSBhc3NlcnRUeXBlU2NyaXB0O1xuZXhwb3J0cy5hc3NlcnRUeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFR5cGVvZlR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5hc3NlcnRVbmFyeUV4cHJlc3Npb24gPSBhc3NlcnRVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmFzc2VydFVuYXJ5TGlrZSA9IGFzc2VydFVuYXJ5TGlrZTtcbmV4cG9ydHMuYXNzZXJ0VW5pb25UeXBlQW5ub3RhdGlvbiA9IGFzc2VydFVuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmFzc2VydFVwZGF0ZUV4cHJlc3Npb24gPSBhc3NlcnRVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5hc3NlcnRVc2VyV2hpdGVzcGFjYWJsZSA9IGFzc2VydFVzZXJXaGl0ZXNwYWNhYmxlO1xuZXhwb3J0cy5hc3NlcnRWOEludHJpbnNpY0lkZW50aWZpZXIgPSBhc3NlcnRWOEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLmFzc2VydFZhcmlhYmxlRGVjbGFyYXRpb24gPSBhc3NlcnRWYXJpYWJsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5hc3NlcnRWYXJpYWJsZURlY2xhcmF0b3IgPSBhc3NlcnRWYXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLmFzc2VydFZhcmlhbmNlID0gYXNzZXJ0VmFyaWFuY2U7XG5leHBvcnRzLmFzc2VydFZvaWRUeXBlQW5ub3RhdGlvbiA9IGFzc2VydFZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYXNzZXJ0V2hpbGUgPSBhc3NlcnRXaGlsZTtcbmV4cG9ydHMuYXNzZXJ0V2hpbGVTdGF0ZW1lbnQgPSBhc3NlcnRXaGlsZVN0YXRlbWVudDtcbmV4cG9ydHMuYXNzZXJ0V2l0aFN0YXRlbWVudCA9IGFzc2VydFdpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLmFzc2VydFlpZWxkRXhwcmVzc2lvbiA9IGFzc2VydFlpZWxkRXhwcmVzc2lvbjtcbnZhciBfaXMgPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9pcy5qc1wiKTtcbnZhciBfZGVwcmVjYXRpb25XYXJuaW5nID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlcHJlY2F0aW9uV2FybmluZy5qc1wiKTtcbmZ1bmN0aW9uIGFzc2VydCh0eXBlLCBub2RlLCBvcHRzKSB7XG4gIGlmICghKDAsIF9pcy5kZWZhdWx0KSh0eXBlLCBub2RlLCBvcHRzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdHlwZSBcIiR7dHlwZX1cIiB3aXRoIG9wdGlvbiAke0pTT04uc3RyaW5naWZ5KG9wdHMpfSwgYCArIGBidXQgaW5zdGVhZCBnb3QgXCIke25vZGUudHlwZX1cIi5gKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0QXJyYXlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXJyYXlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXNzaWdubWVudEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJpbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCaW5hcnlFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJwcmV0ZXJEaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERpcmVjdGl2ZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRpcmVjdGl2ZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERpcmVjdGl2ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEaXJlY3RpdmVMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QmxvY2tTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCbG9ja1N0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJyZWFrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQnJlYWtTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNhbGxFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q2F0Y2hDbGF1c2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDYXRjaENsYXVzZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENvbmRpdGlvbmFsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENvbnRpbnVlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ29udGludWVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWJ1Z2dlclN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RG9XaGlsZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRvV2hpbGVTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbXB0eVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVtcHR5U3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGaWxlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmlsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZvckluU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRm9ySW5TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGb3JTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGb3JTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvbkRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJZGVudGlmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SWZTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJZlN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydExhYmVsZWRTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJMYWJlbGVkU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RyaW5nTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN0cmluZ0xpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnROdW1lcmljTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk51bWVyaWNMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVsbExpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOdWxsTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5MaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQm9vbGVhbkxpdGVyYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRSZWdFeHBMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUmVnRXhwTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydExvZ2ljYWxFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTG9naWNhbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTWVtYmVyRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE5ld0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOZXdFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UHJvZ3JhbShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlByb2dyYW1cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdE1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdE1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0UHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRSZXN0RWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlJlc3RFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmV0dXJuU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUmV0dXJuU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2VxdWVuY2VFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN3aXRjaENhc2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTd2l0Y2hDYXNlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3dpdGNoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3dpdGNoU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VGhpc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUaGlzRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRocm93U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVGhyb3dTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUcnlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUcnlTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRVbmFyeUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJVbmFyeUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRVcGRhdGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVXBkYXRlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhcmlhYmxlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFibGVEZWNsYXJhdG9yKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0V2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJXaGlsZVN0YXRlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFdpdGhTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJXaXRoU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXNzaWdubWVudFBhdHRlcm4obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJBc3NpZ25tZW50UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFycmF5UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkFycmF5UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc0JvZHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDbGFzc0JvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDbGFzc0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydEFsbERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnROYW1lZERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEV4cG9ydFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZvck9mU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRm9yT2ZTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltcG9ydERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnRTcGVjaWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW1wb3J0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGFQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk1ldGFQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsYXNzTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0UGF0dGVyblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFNwcmVhZEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTcHJlYWRFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3VwZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTdXBlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRlbXBsYXRlRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRlbXBsYXRlRWxlbWVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRlbXBsYXRlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRlbXBsYXRlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFlpZWxkRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIllpZWxkRXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEF3YWl0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkF3YWl0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEltcG9ydChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltcG9ydFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJpZ0ludExpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCaWdJbnRMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc1Byb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydENsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc1ByaXZhdGVNZXRob2Qobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQcml2YXRlTmFtZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlByaXZhdGVOYW1lXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhdGljQmxvY2sobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTdGF0aWNCbG9ja1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEFueVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQW55VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcnJheVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzc0ltcGxlbWVudHMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJDbGFzc0ltcGxlbWVudHNcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlQ2xhc3Mobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlQ2xhc3NcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlRnVuY3Rpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNsYXJlSW50ZXJmYWNlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZUludGVyZmFjZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVNb2R1bGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlTW9kdWxlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVUeXBlQWxpYXMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlVHlwZUFsaWFzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjbGFyZU9wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNsYXJlT3BhcXVlVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVWYXJpYWJsZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmVWYXJpYWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeGlzdHNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGdW5jdGlvblR5cGVQYXJhbShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0R2VuZXJpY1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW5mZXJyZWRQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbmZlcnJlZFByZWRpY2F0ZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZUV4dGVuZHMobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VFeHRlbmRzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEludGVyZmFjZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TWl4ZWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk1peGVkVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbXB0eVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bGxhYmxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlSW50ZXJuYWxTbG90KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVDYWxsUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZUluZGV4ZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RUeXBlSW5kZXhlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE9wYXF1ZVR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPcGFxdWVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UXVhbGlmaWVkVHlwZUlkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3RyaW5nVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTeW1ib2xUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VGhpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHVwbGVUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR1cGxlVHlwZUFubm90YXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUeXBlb2ZUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHlwZUFsaWFzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVDYXN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlR5cGVDYXN0RXhwcmVzc2lvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVQYXJhbWV0ZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlUGFyYW1ldGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFVuaW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VmFyaWFuY2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJWYXJpYW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZvaWRUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1EZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1Cb29sZWFuQm9keShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1Cb29sZWFuQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1OdW1iZXJCb2R5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bU51bWJlckJvZHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtU3RyaW5nQm9keShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1TdHJpbmdCb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bVN5bWJvbEJvZHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtU3ltYm9sQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1Cb29sZWFuTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bUJvb2xlYW5NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtTnVtYmVyTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRW51bU51bWJlck1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVudW1TdHJpbmdNZW1iZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bURlZmF1bHRlZE1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbmRleGVkQWNjZXNzVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkluZGV4ZWRBY2Nlc3NUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0T3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hDbG9zaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWENsb3NpbmdFbGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkpTWEVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hFbXB0eUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hFbXB0eUV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWFNwcmVhZENoaWxkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYU3ByZWFkQ2hpbGRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYSWRlbnRpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWE1lbWJlckV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SlNYTmFtZXNwYWNlZE5hbWUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWE9wZW5pbmdFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYT3BlbmluZ0VsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hTcHJlYWRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hUZXh0KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYVGV4dFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEpTWEZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiSlNYRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hPcGVuaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1hDbG9zaW5nRnJhZ21lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnROb29wKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTm9vcFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGxhY2Vob2xkZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRWOEludHJpbnNpY0lkZW50aWZpZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRBcmd1bWVudFBsYWNlaG9sZGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQXJndW1lbnRQbGFjZWhvbGRlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJpbmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmluZEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJbXBvcnRBdHRyaWJ1dGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJJbXBvcnRBdHRyaWJ1dGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREZWNvcmF0b3Iobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNvcmF0b3JcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnREb0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEb0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFJlY29yZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJSZWNvcmRFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VHVwbGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVHVwbGVFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RGVjaW1hbExpdGVyYWwobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJEZWNpbWFsTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1vZHVsZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNb2R1bGVFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VG9waWNSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUb3BpY1JlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFBpcGVsaW5lVG9waWNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQaXBlbGluZUJhcmVGdW5jdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTUGFyYW1ldGVyUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNEZWNsYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0RlY2xhcmVGdW5jdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRGVjbGFyZU1ldGhvZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTRGVjbGFyZU1ldGhvZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTUXVhbGlmaWVkTmFtZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTUXVhbGlmaWVkTmFtZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTUHJvcGVydHlTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNNZXRob2RTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU01ldGhvZFNpZ25hdHVyZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW5kZXhTaWduYXR1cmUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0luZGV4U2lnbmF0dXJlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNBbnlLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNBbnlLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNCb29sZWFuS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTQm9vbGVhbktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0JpZ0ludEtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0JpZ0ludEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0ludHJpbnNpY0tleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0ludHJpbnNpY0tleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU05ldmVyS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTmV2ZXJLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNOdWxsS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTnVsbEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU051bWJlcktleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU051bWJlcktleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU09iamVjdEtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU09iamVjdEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1N0cmluZ0tleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1N0cmluZ0tleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1N5bWJvbEtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1N5bWJvbEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1VuZGVmaW5lZEtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1VuZGVmaW5lZEtleXdvcmRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1Vua25vd25LZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNVbmtub3duS2V5d29yZFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVm9pZEtleXdvcmQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1ZvaWRLZXl3b3JkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUaGlzVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVGhpc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0Z1bmN0aW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTRnVuY3Rpb25UeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNDb25zdHJ1Y3RvclR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVJlZmVyZW5jZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVJlZmVyZW5jZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVByZWRpY2F0ZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZVF1ZXJ5KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUXVlcnlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQXJyYXlUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNBcnJheVR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R1cGxlVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHVwbGVUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNPcHRpb25hbFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU09wdGlvbmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTUmVzdFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1Jlc3RUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNOYW1lZFR1cGxlTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNVbmlvblR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1VuaW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJzZWN0aW9uVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTQ29uZGl0aW9uYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNDb25kaXRpb25hbFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0luZmVyVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW5mZXJUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNQYXJlbnRoZXNpemVkVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVPcGVyYXRvcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZU9wZXJhdG9yXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbmRleGVkQWNjZXNzVHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU01hcHBlZFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU01hcHBlZFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0xpdGVyYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNMaXRlcmFsVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTSW50ZXJmYWNlQm9keShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW50ZXJmYWNlQm9keVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0FzRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTQXNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNTYXRpc2ZpZXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlQXNzZXJ0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlQXNzZXJ0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNFbnVtRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0VudW1EZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRW51bU1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTRW51bU1lbWJlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTTW9kdWxlRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU01vZHVsZURlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNNb2R1bGVCbG9jayhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTW9kdWxlQmxvY2tcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0ltcG9ydFR5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0ltcG9ydFR5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNOb25OdWxsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0V4cG9ydEFzc2lnbm1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFRTVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlUGFyYW1ldGVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNUeXBlUGFyYW1ldGVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhbmRhcmRpemVkKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiU3RhbmRhcmRpemVkXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cHJlc3Npb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRCaW5hcnkobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCaW5hcnlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTY29wYWJsZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlNjb3BhYmxlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QmxvY2tQYXJlbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJCbG9ja1BhcmVudFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEJsb2NrKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiQmxvY2tcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJTdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUZXJtaW5hdG9ybGVzcyhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRlcm1pbmF0b3JsZXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29tcGxldGlvblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDb25kaXRpb25hbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNvbmRpdGlvbmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TG9vcChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkxvb3BcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRXaGlsZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIldoaWxlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXhwcmVzc2lvbldyYXBwZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJFeHByZXNzaW9uV3JhcHBlclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZvcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZvclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZvclhTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGb3JYU3RhdGVtZW50XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJGdW5jdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEZ1bmN0aW9uUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRnVuY3Rpb25QYXJlbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQdXJlaXNoKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiUHVyZWlzaFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQYXR0ZXJuTGlrZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlBhdHRlcm5MaWtlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TFZhbChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkxWYWxcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0VudGl0eU5hbWUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU0VudGl0eU5hbWVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydEltbXV0YWJsZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltbXV0YWJsZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFVzZXJXaGl0ZXNwYWNhYmxlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVXNlcldoaXRlc3BhY2FibGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNZXRob2Qobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJNZXRob2RcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRPYmplY3RNZW1iZXIobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJPYmplY3RNZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VW5hcnlMaWtlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVW5hcnlMaWtlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlBhdHRlcm5cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRDbGFzcyhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkNsYXNzXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb25cIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkV4cG9ydERlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TW9kdWxlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTW9kdWxlU3BlY2lmaWVyXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QWNjZXNzb3Iobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJBY2Nlc3NvclwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFByaXZhdGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJQcml2YXRlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Rmxvdyhub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZsb3dcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRGbG93VHlwZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZsb3dUeXBlXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0Jhc2VBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Rmxvd0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiRmxvd0RlY2xhcmF0aW9uXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Rmxvd1ByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkZsb3dQcmVkaWNhdGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRFbnVtQm9keShub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1Cb2R5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW51bU1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIkVudW1NZW1iZXJcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRKU1gobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJKU1hcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNaXNjZWxsYW5lb3VzKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiTWlzY2VsbGFuZW91c1wiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVTY3JpcHQobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUeXBlU2NyaXB0XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0VFNUeXBlRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGFzc2VydChcIlRTVHlwZUVsZW1lbnRcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU1R5cGUobm9kZSwgb3B0cykge1xuICBhc3NlcnQoXCJUU1R5cGVcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRUU0Jhc2VUeXBlKG5vZGUsIG9wdHMpIHtcbiAgYXNzZXJ0KFwiVFNCYXNlVHlwZVwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydE51bWJlckxpdGVyYWwobm9kZSwgb3B0cykge1xuICAoMCwgX2RlcHJlY2F0aW9uV2FybmluZy5kZWZhdWx0KShcImFzc2VydE51bWJlckxpdGVyYWxcIiwgXCJhc3NlcnROdW1lcmljTGl0ZXJhbFwiKTtcbiAgYXNzZXJ0KFwiTnVtYmVyTGl0ZXJhbFwiLCBub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFJlZ2V4TGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiYXNzZXJ0UmVnZXhMaXRlcmFsXCIsIFwiYXNzZXJ0UmVnRXhwTGl0ZXJhbFwiKTtcbiAgYXNzZXJ0KFwiUmVnZXhMaXRlcmFsXCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UmVzdFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJhc3NlcnRSZXN0UHJvcGVydHlcIiwgXCJhc3NlcnRSZXN0RWxlbWVudFwiKTtcbiAgYXNzZXJ0KFwiUmVzdFByb3BlcnR5XCIsIG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICAoMCwgX2RlcHJlY2F0aW9uV2FybmluZy5kZWZhdWx0KShcImFzc2VydFNwcmVhZFByb3BlcnR5XCIsIFwiYXNzZXJ0U3ByZWFkRWxlbWVudFwiKTtcbiAgYXNzZXJ0KFwiU3ByZWFkUHJvcGVydHlcIiwgbm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBhc3NlcnRNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiYXNzZXJ0TW9kdWxlRGVjbGFyYXRpb25cIiwgXCJhc3NlcnRJbXBvcnRPckV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICBhc3NlcnQoXCJNb2R1bGVEZWNsYXJhdGlvblwiLCBub2RlLCBvcHRzKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72246\n')},31009:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = createFlowUnionType;\nvar _index = __webpack_require__(48079);\nvar _removeTypeDuplicates = __webpack_require__(95237);\nfunction createFlowUnionType(types) {\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.unionTypeAnnotation)(flattened);\n  }\n}\n\n//# sourceMappingURL=createFlowUnionType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEwMDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUMsNEJBQTRCLG1CQUFPLENBQUMsS0FBa0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2Zsb3cvY3JlYXRlRmxvd1VuaW9uVHlwZS5qcz8xMjgzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlRmxvd1VuaW9uVHlwZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9yZW1vdmVUeXBlRHVwbGljYXRlcyA9IHJlcXVpcmUoXCIuLi8uLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanNcIik7XG5mdW5jdGlvbiBjcmVhdGVGbG93VW5pb25UeXBlKHR5cGVzKSB7XG4gIGNvbnN0IGZsYXR0ZW5lZCA9ICgwLCBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuZGVmYXVsdCkodHlwZXMpO1xuICBpZiAoZmxhdHRlbmVkLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmbGF0dGVuZWRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgudW5pb25UeXBlQW5ub3RhdGlvbikoZmxhdHRlbmVkKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVGbG93VW5pb25UeXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31009\n')},95958:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _index = __webpack_require__(48079);\nvar _default = exports["default"] = createTypeAnnotationBasedOnTypeof;\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  switch (type) {\n    case "string":\n      return (0, _index.stringTypeAnnotation)();\n    case "number":\n      return (0, _index.numberTypeAnnotation)();\n    case "undefined":\n      return (0, _index.voidTypeAnnotation)();\n    case "boolean":\n      return (0, _index.booleanTypeAnnotation)();\n    case "function":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));\n    case "object":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));\n    case "symbol":\n      return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));\n    case "bigint":\n      return (0, _index.anyTypeAnnotation)();\n  }\n  throw new Error("Invalid typeof value: " + type);\n}\n\n//# sourceMappingURL=createTypeAnnotationBasedOnTypeof.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTU5NTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUMsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvYnVpbGRlcnMvZmxvdy9jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YuanM/OTAyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mO1xuZnVuY3Rpb24gY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuICgwLCBfaW5kZXguc3RyaW5nVHlwZUFubm90YXRpb24pKCk7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuICgwLCBfaW5kZXgubnVtYmVyVHlwZUFubm90YXRpb24pKCk7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuICgwLCBfaW5kZXgudm9pZFR5cGVBbm5vdGF0aW9uKSgpO1xuICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5ib29sZWFuVHlwZUFubm90YXRpb24pKCk7XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfaW5kZXguaWRlbnRpZmllcikoXCJGdW5jdGlvblwiKSk7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuICgwLCBfaW5kZXguZ2VuZXJpY1R5cGVBbm5vdGF0aW9uKSgoMCwgX2luZGV4LmlkZW50aWZpZXIpKFwiT2JqZWN0XCIpKTtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gKDAsIF9pbmRleC5nZW5lcmljVHlwZUFubm90YXRpb24pKCgwLCBfaW5kZXguaWRlbnRpZmllcikoXCJTeW1ib2xcIikpO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiAoMCwgX2luZGV4LmFueVR5cGVBbm5vdGF0aW9uKSgpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHlwZW9mIHZhbHVlOiBcIiArIHR5cGUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95958\n')},48079:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.anyTypeAnnotation = anyTypeAnnotation;\nexports.argumentPlaceholder = argumentPlaceholder;\nexports.arrayExpression = arrayExpression;\nexports.arrayPattern = arrayPattern;\nexports.arrayTypeAnnotation = arrayTypeAnnotation;\nexports.arrowFunctionExpression = arrowFunctionExpression;\nexports.assignmentExpression = assignmentExpression;\nexports.assignmentPattern = assignmentPattern;\nexports.awaitExpression = awaitExpression;\nexports.bigIntLiteral = bigIntLiteral;\nexports.binaryExpression = binaryExpression;\nexports.bindExpression = bindExpression;\nexports.blockStatement = blockStatement;\nexports.booleanLiteral = booleanLiteral;\nexports.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;\nexports.booleanTypeAnnotation = booleanTypeAnnotation;\nexports.breakStatement = breakStatement;\nexports.callExpression = callExpression;\nexports.catchClause = catchClause;\nexports.classAccessorProperty = classAccessorProperty;\nexports.classBody = classBody;\nexports.classDeclaration = classDeclaration;\nexports.classExpression = classExpression;\nexports.classImplements = classImplements;\nexports.classMethod = classMethod;\nexports.classPrivateMethod = classPrivateMethod;\nexports.classPrivateProperty = classPrivateProperty;\nexports.classProperty = classProperty;\nexports.conditionalExpression = conditionalExpression;\nexports.continueStatement = continueStatement;\nexports.debuggerStatement = debuggerStatement;\nexports.decimalLiteral = decimalLiteral;\nexports.declareClass = declareClass;\nexports.declareExportAllDeclaration = declareExportAllDeclaration;\nexports.declareExportDeclaration = declareExportDeclaration;\nexports.declareFunction = declareFunction;\nexports.declareInterface = declareInterface;\nexports.declareModule = declareModule;\nexports.declareModuleExports = declareModuleExports;\nexports.declareOpaqueType = declareOpaqueType;\nexports.declareTypeAlias = declareTypeAlias;\nexports.declareVariable = declareVariable;\nexports.declaredPredicate = declaredPredicate;\nexports.decorator = decorator;\nexports.directive = directive;\nexports.directiveLiteral = directiveLiteral;\nexports.doExpression = doExpression;\nexports.doWhileStatement = doWhileStatement;\nexports.emptyStatement = emptyStatement;\nexports.emptyTypeAnnotation = emptyTypeAnnotation;\nexports.enumBooleanBody = enumBooleanBody;\nexports.enumBooleanMember = enumBooleanMember;\nexports.enumDeclaration = enumDeclaration;\nexports.enumDefaultedMember = enumDefaultedMember;\nexports.enumNumberBody = enumNumberBody;\nexports.enumNumberMember = enumNumberMember;\nexports.enumStringBody = enumStringBody;\nexports.enumStringMember = enumStringMember;\nexports.enumSymbolBody = enumSymbolBody;\nexports.existsTypeAnnotation = existsTypeAnnotation;\nexports.exportAllDeclaration = exportAllDeclaration;\nexports.exportDefaultDeclaration = exportDefaultDeclaration;\nexports.exportDefaultSpecifier = exportDefaultSpecifier;\nexports.exportNamedDeclaration = exportNamedDeclaration;\nexports.exportNamespaceSpecifier = exportNamespaceSpecifier;\nexports.exportSpecifier = exportSpecifier;\nexports.expressionStatement = expressionStatement;\nexports.file = file;\nexports.forInStatement = forInStatement;\nexports.forOfStatement = forOfStatement;\nexports.forStatement = forStatement;\nexports.functionDeclaration = functionDeclaration;\nexports.functionExpression = functionExpression;\nexports.functionTypeAnnotation = functionTypeAnnotation;\nexports.functionTypeParam = functionTypeParam;\nexports.genericTypeAnnotation = genericTypeAnnotation;\nexports.identifier = identifier;\nexports.ifStatement = ifStatement;\nexports["import"] = _import;\nexports.importAttribute = importAttribute;\nexports.importDeclaration = importDeclaration;\nexports.importDefaultSpecifier = importDefaultSpecifier;\nexports.importExpression = importExpression;\nexports.importNamespaceSpecifier = importNamespaceSpecifier;\nexports.importSpecifier = importSpecifier;\nexports.indexedAccessType = indexedAccessType;\nexports.inferredPredicate = inferredPredicate;\nexports.interfaceDeclaration = interfaceDeclaration;\nexports.interfaceExtends = interfaceExtends;\nexports.interfaceTypeAnnotation = interfaceTypeAnnotation;\nexports.interpreterDirective = interpreterDirective;\nexports.intersectionTypeAnnotation = intersectionTypeAnnotation;\nexports.jSXAttribute = exports.jsxAttribute = jsxAttribute;\nexports.jSXClosingElement = exports.jsxClosingElement = jsxClosingElement;\nexports.jSXClosingFragment = exports.jsxClosingFragment = jsxClosingFragment;\nexports.jSXElement = exports.jsxElement = jsxElement;\nexports.jSXEmptyExpression = exports.jsxEmptyExpression = jsxEmptyExpression;\nexports.jSXExpressionContainer = exports.jsxExpressionContainer = jsxExpressionContainer;\nexports.jSXFragment = exports.jsxFragment = jsxFragment;\nexports.jSXIdentifier = exports.jsxIdentifier = jsxIdentifier;\nexports.jSXMemberExpression = exports.jsxMemberExpression = jsxMemberExpression;\nexports.jSXNamespacedName = exports.jsxNamespacedName = jsxNamespacedName;\nexports.jSXOpeningElement = exports.jsxOpeningElement = jsxOpeningElement;\nexports.jSXOpeningFragment = exports.jsxOpeningFragment = jsxOpeningFragment;\nexports.jSXSpreadAttribute = exports.jsxSpreadAttribute = jsxSpreadAttribute;\nexports.jSXSpreadChild = exports.jsxSpreadChild = jsxSpreadChild;\nexports.jSXText = exports.jsxText = jsxText;\nexports.labeledStatement = labeledStatement;\nexports.logicalExpression = logicalExpression;\nexports.memberExpression = memberExpression;\nexports.metaProperty = metaProperty;\nexports.mixedTypeAnnotation = mixedTypeAnnotation;\nexports.moduleExpression = moduleExpression;\nexports.newExpression = newExpression;\nexports.noop = noop;\nexports.nullLiteral = nullLiteral;\nexports.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;\nexports.nullableTypeAnnotation = nullableTypeAnnotation;\nexports.numberLiteral = NumberLiteral;\nexports.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;\nexports.numberTypeAnnotation = numberTypeAnnotation;\nexports.numericLiteral = numericLiteral;\nexports.objectExpression = objectExpression;\nexports.objectMethod = objectMethod;\nexports.objectPattern = objectPattern;\nexports.objectProperty = objectProperty;\nexports.objectTypeAnnotation = objectTypeAnnotation;\nexports.objectTypeCallProperty = objectTypeCallProperty;\nexports.objectTypeIndexer = objectTypeIndexer;\nexports.objectTypeInternalSlot = objectTypeInternalSlot;\nexports.objectTypeProperty = objectTypeProperty;\nexports.objectTypeSpreadProperty = objectTypeSpreadProperty;\nexports.opaqueType = opaqueType;\nexports.optionalCallExpression = optionalCallExpression;\nexports.optionalIndexedAccessType = optionalIndexedAccessType;\nexports.optionalMemberExpression = optionalMemberExpression;\nexports.parenthesizedExpression = parenthesizedExpression;\nexports.pipelineBareFunction = pipelineBareFunction;\nexports.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;\nexports.pipelineTopicExpression = pipelineTopicExpression;\nexports.placeholder = placeholder;\nexports.privateName = privateName;\nexports.program = program;\nexports.qualifiedTypeIdentifier = qualifiedTypeIdentifier;\nexports.recordExpression = recordExpression;\nexports.regExpLiteral = regExpLiteral;\nexports.regexLiteral = RegexLiteral;\nexports.restElement = restElement;\nexports.restProperty = RestProperty;\nexports.returnStatement = returnStatement;\nexports.sequenceExpression = sequenceExpression;\nexports.spreadElement = spreadElement;\nexports.spreadProperty = SpreadProperty;\nexports.staticBlock = staticBlock;\nexports.stringLiteral = stringLiteral;\nexports.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;\nexports.stringTypeAnnotation = stringTypeAnnotation;\nexports["super"] = _super;\nexports.switchCase = switchCase;\nexports.switchStatement = switchStatement;\nexports.symbolTypeAnnotation = symbolTypeAnnotation;\nexports.taggedTemplateExpression = taggedTemplateExpression;\nexports.templateElement = templateElement;\nexports.templateLiteral = templateLiteral;\nexports.thisExpression = thisExpression;\nexports.thisTypeAnnotation = thisTypeAnnotation;\nexports.throwStatement = throwStatement;\nexports.topicReference = topicReference;\nexports.tryStatement = tryStatement;\nexports.tSAnyKeyword = exports.tsAnyKeyword = tsAnyKeyword;\nexports.tSArrayType = exports.tsArrayType = tsArrayType;\nexports.tSAsExpression = exports.tsAsExpression = tsAsExpression;\nexports.tSBigIntKeyword = exports.tsBigIntKeyword = tsBigIntKeyword;\nexports.tSBooleanKeyword = exports.tsBooleanKeyword = tsBooleanKeyword;\nexports.tSCallSignatureDeclaration = exports.tsCallSignatureDeclaration = tsCallSignatureDeclaration;\nexports.tSConditionalType = exports.tsConditionalType = tsConditionalType;\nexports.tSConstructSignatureDeclaration = exports.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;\nexports.tSConstructorType = exports.tsConstructorType = tsConstructorType;\nexports.tSDeclareFunction = exports.tsDeclareFunction = tsDeclareFunction;\nexports.tSDeclareMethod = exports.tsDeclareMethod = tsDeclareMethod;\nexports.tSEnumDeclaration = exports.tsEnumDeclaration = tsEnumDeclaration;\nexports.tSEnumMember = exports.tsEnumMember = tsEnumMember;\nexports.tSExportAssignment = exports.tsExportAssignment = tsExportAssignment;\nexports.tSExpressionWithTypeArguments = exports.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;\nexports.tSExternalModuleReference = exports.tsExternalModuleReference = tsExternalModuleReference;\nexports.tSFunctionType = exports.tsFunctionType = tsFunctionType;\nexports.tSImportEqualsDeclaration = exports.tsImportEqualsDeclaration = tsImportEqualsDeclaration;\nexports.tSImportType = exports.tsImportType = tsImportType;\nexports.tSIndexSignature = exports.tsIndexSignature = tsIndexSignature;\nexports.tSIndexedAccessType = exports.tsIndexedAccessType = tsIndexedAccessType;\nexports.tSInferType = exports.tsInferType = tsInferType;\nexports.tSInstantiationExpression = exports.tsInstantiationExpression = tsInstantiationExpression;\nexports.tSInterfaceBody = exports.tsInterfaceBody = tsInterfaceBody;\nexports.tSInterfaceDeclaration = exports.tsInterfaceDeclaration = tsInterfaceDeclaration;\nexports.tSIntersectionType = exports.tsIntersectionType = tsIntersectionType;\nexports.tSIntrinsicKeyword = exports.tsIntrinsicKeyword = tsIntrinsicKeyword;\nexports.tSLiteralType = exports.tsLiteralType = tsLiteralType;\nexports.tSMappedType = exports.tsMappedType = tsMappedType;\nexports.tSMethodSignature = exports.tsMethodSignature = tsMethodSignature;\nexports.tSModuleBlock = exports.tsModuleBlock = tsModuleBlock;\nexports.tSModuleDeclaration = exports.tsModuleDeclaration = tsModuleDeclaration;\nexports.tSNamedTupleMember = exports.tsNamedTupleMember = tsNamedTupleMember;\nexports.tSNamespaceExportDeclaration = exports.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;\nexports.tSNeverKeyword = exports.tsNeverKeyword = tsNeverKeyword;\nexports.tSNonNullExpression = exports.tsNonNullExpression = tsNonNullExpression;\nexports.tSNullKeyword = exports.tsNullKeyword = tsNullKeyword;\nexports.tSNumberKeyword = exports.tsNumberKeyword = tsNumberKeyword;\nexports.tSObjectKeyword = exports.tsObjectKeyword = tsObjectKeyword;\nexports.tSOptionalType = exports.tsOptionalType = tsOptionalType;\nexports.tSParameterProperty = exports.tsParameterProperty = tsParameterProperty;\nexports.tSParenthesizedType = exports.tsParenthesizedType = tsParenthesizedType;\nexports.tSPropertySignature = exports.tsPropertySignature = tsPropertySignature;\nexports.tSQualifiedName = exports.tsQualifiedName = tsQualifiedName;\nexports.tSRestType = exports.tsRestType = tsRestType;\nexports.tSSatisfiesExpression = exports.tsSatisfiesExpression = tsSatisfiesExpression;\nexports.tSStringKeyword = exports.tsStringKeyword = tsStringKeyword;\nexports.tSSymbolKeyword = exports.tsSymbolKeyword = tsSymbolKeyword;\nexports.tSThisType = exports.tsThisType = tsThisType;\nexports.tSTupleType = exports.tsTupleType = tsTupleType;\nexports.tSTypeAliasDeclaration = exports.tsTypeAliasDeclaration = tsTypeAliasDeclaration;\nexports.tSTypeAnnotation = exports.tsTypeAnnotation = tsTypeAnnotation;\nexports.tSTypeAssertion = exports.tsTypeAssertion = tsTypeAssertion;\nexports.tSTypeLiteral = exports.tsTypeLiteral = tsTypeLiteral;\nexports.tSTypeOperator = exports.tsTypeOperator = tsTypeOperator;\nexports.tSTypeParameter = exports.tsTypeParameter = tsTypeParameter;\nexports.tSTypeParameterDeclaration = exports.tsTypeParameterDeclaration = tsTypeParameterDeclaration;\nexports.tSTypeParameterInstantiation = exports.tsTypeParameterInstantiation = tsTypeParameterInstantiation;\nexports.tSTypePredicate = exports.tsTypePredicate = tsTypePredicate;\nexports.tSTypeQuery = exports.tsTypeQuery = tsTypeQuery;\nexports.tSTypeReference = exports.tsTypeReference = tsTypeReference;\nexports.tSUndefinedKeyword = exports.tsUndefinedKeyword = tsUndefinedKeyword;\nexports.tSUnionType = exports.tsUnionType = tsUnionType;\nexports.tSUnknownKeyword = exports.tsUnknownKeyword = tsUnknownKeyword;\nexports.tSVoidKeyword = exports.tsVoidKeyword = tsVoidKeyword;\nexports.tupleExpression = tupleExpression;\nexports.tupleTypeAnnotation = tupleTypeAnnotation;\nexports.typeAlias = typeAlias;\nexports.typeAnnotation = typeAnnotation;\nexports.typeCastExpression = typeCastExpression;\nexports.typeParameter = typeParameter;\nexports.typeParameterDeclaration = typeParameterDeclaration;\nexports.typeParameterInstantiation = typeParameterInstantiation;\nexports.typeofTypeAnnotation = typeofTypeAnnotation;\nexports.unaryExpression = unaryExpression;\nexports.unionTypeAnnotation = unionTypeAnnotation;\nexports.updateExpression = updateExpression;\nexports.v8IntrinsicIdentifier = v8IntrinsicIdentifier;\nexports.variableDeclaration = variableDeclaration;\nexports.variableDeclarator = variableDeclarator;\nexports.variance = variance;\nexports.voidTypeAnnotation = voidTypeAnnotation;\nexports.whileStatement = whileStatement;\nexports.withStatement = withStatement;\nexports.yieldExpression = yieldExpression;\nvar _validate = __webpack_require__(57446);\nvar _deprecationWarning = __webpack_require__(63762);\nvar utils = __webpack_require__(77596);\nconst {\n  validateInternal: validate\n} = _validate;\nconst {\n  NODE_FIELDS\n} = utils;\nfunction arrayExpression(elements = []) {\n  const node = {\n    type: "ArrayExpression",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, "elements", elements, 1);\n  return node;\n}\nfunction assignmentExpression(operator, left, right) {\n  const node = {\n    type: "AssignmentExpression",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, "operator", operator);\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction binaryExpression(operator, left, right) {\n  const node = {\n    type: "BinaryExpression",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, "operator", operator);\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction interpreterDirective(value) {\n  const node = {\n    type: "InterpreterDirective",\n    value\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction directive(value) {\n  const node = {\n    type: "Directive",\n    value\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, "value", value, 1);\n  return node;\n}\nfunction directiveLiteral(value) {\n  const node = {\n    type: "DirectiveLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction blockStatement(body, directives = []) {\n  const node = {\n    type: "BlockStatement",\n    body,\n    directives\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.directives, node, "directives", directives, 1);\n  return node;\n}\nfunction breakStatement(label = null) {\n  const node = {\n    type: "BreakStatement",\n    label\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, "label", label, 1);\n  return node;\n}\nfunction callExpression(callee, _arguments) {\n  const node = {\n    type: "CallExpression",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, "callee", callee, 1);\n  validate(defs.arguments, node, "arguments", _arguments, 1);\n  return node;\n}\nfunction catchClause(param = null, body) {\n  const node = {\n    type: "CatchClause",\n    param,\n    body\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, "param", param, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction conditionalExpression(test, consequent, alternate) {\n  const node = {\n    type: "ConditionalExpression",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.consequent, node, "consequent", consequent, 1);\n  validate(defs.alternate, node, "alternate", alternate, 1);\n  return node;\n}\nfunction continueStatement(label = null) {\n  const node = {\n    type: "ContinueStatement",\n    label\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, "label", label, 1);\n  return node;\n}\nfunction debuggerStatement() {\n  return {\n    type: "DebuggerStatement"\n  };\n}\nfunction doWhileStatement(test, body) {\n  const node = {\n    type: "DoWhileStatement",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction emptyStatement() {\n  return {\n    type: "EmptyStatement"\n  };\n}\nfunction expressionStatement(expression) {\n  const node = {\n    type: "ExpressionStatement",\n    expression\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction file(program, comments = null, tokens = null) {\n  const node = {\n    type: "File",\n    program,\n    comments,\n    tokens\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, "program", program, 1);\n  validate(defs.comments, node, "comments", comments, 1);\n  validate(defs.tokens, node, "tokens", tokens);\n  return node;\n}\nfunction forInStatement(left, right, body) {\n  const node = {\n    type: "ForInStatement",\n    left,\n    right,\n    body\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction forStatement(init = null, test = null, update = null, body) {\n  const node = {\n    type: "ForStatement",\n    init,\n    test,\n    update,\n    body\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, "init", init, 1);\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.update, node, "update", update, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction functionDeclaration(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: "FunctionDeclaration",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.generator, node, "generator", generator);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction functionExpression(id = null, params, body, generator = false, async = false) {\n  const node = {\n    type: "FunctionExpression",\n    id,\n    params,\n    body,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.generator, node, "generator", generator);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction identifier(name) {\n  const node = {\n    type: "Identifier",\n    name\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, "name", name);\n  return node;\n}\nfunction ifStatement(test, consequent, alternate = null) {\n  const node = {\n    type: "IfStatement",\n    test,\n    consequent,\n    alternate\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.consequent, node, "consequent", consequent, 1);\n  validate(defs.alternate, node, "alternate", alternate, 1);\n  return node;\n}\nfunction labeledStatement(label, body) {\n  const node = {\n    type: "LabeledStatement",\n    label,\n    body\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, "label", label, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction stringLiteral(value) {\n  const node = {\n    type: "StringLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction numericLiteral(value) {\n  const node = {\n    type: "NumericLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction nullLiteral() {\n  return {\n    type: "NullLiteral"\n  };\n}\nfunction booleanLiteral(value) {\n  const node = {\n    type: "BooleanLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction regExpLiteral(pattern, flags = "") {\n  const node = {\n    type: "RegExpLiteral",\n    pattern,\n    flags\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, "pattern", pattern);\n  validate(defs.flags, node, "flags", flags);\n  return node;\n}\nfunction logicalExpression(operator, left, right) {\n  const node = {\n    type: "LogicalExpression",\n    operator,\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, "operator", operator);\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction memberExpression(object, property, computed = false, optional = null) {\n  const node = {\n    type: "MemberExpression",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, "object", object, 1);\n  validate(defs.property, node, "property", property, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.optional, node, "optional", optional);\n  return node;\n}\nfunction newExpression(callee, _arguments) {\n  const node = {\n    type: "NewExpression",\n    callee,\n    arguments: _arguments\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, "callee", callee, 1);\n  validate(defs.arguments, node, "arguments", _arguments, 1);\n  return node;\n}\nfunction program(body, directives = [], sourceType = "script", interpreter = null) {\n  const node = {\n    type: "Program",\n    body,\n    directives,\n    sourceType,\n    interpreter\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.directives, node, "directives", directives, 1);\n  validate(defs.sourceType, node, "sourceType", sourceType);\n  validate(defs.interpreter, node, "interpreter", interpreter, 1);\n  return node;\n}\nfunction objectExpression(properties) {\n  const node = {\n    type: "ObjectExpression",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, "properties", properties, 1);\n  return node;\n}\nfunction objectMethod(kind = "method", key, params, body, computed = false, generator = false, async = false) {\n  const node = {\n    type: "ObjectMethod",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, "kind", kind);\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.generator, node, "generator", generator);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction objectProperty(key, value, computed = false, shorthand = false, decorators = null) {\n  const node = {\n    type: "ObjectProperty",\n    key,\n    value,\n    computed,\n    shorthand,\n    decorators\n  };\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.shorthand, node, "shorthand", shorthand);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  return node;\n}\nfunction restElement(argument) {\n  const node = {\n    type: "RestElement",\n    argument\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction returnStatement(argument = null) {\n  const node = {\n    type: "ReturnStatement",\n    argument\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction sequenceExpression(expressions) {\n  const node = {\n    type: "SequenceExpression",\n    expressions\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, "expressions", expressions, 1);\n  return node;\n}\nfunction parenthesizedExpression(expression) {\n  const node = {\n    type: "ParenthesizedExpression",\n    expression\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction switchCase(test = null, consequent) {\n  const node = {\n    type: "SwitchCase",\n    test,\n    consequent\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.consequent, node, "consequent", consequent, 1);\n  return node;\n}\nfunction switchStatement(discriminant, cases) {\n  const node = {\n    type: "SwitchStatement",\n    discriminant,\n    cases\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, "discriminant", discriminant, 1);\n  validate(defs.cases, node, "cases", cases, 1);\n  return node;\n}\nfunction thisExpression() {\n  return {\n    type: "ThisExpression"\n  };\n}\nfunction throwStatement(argument) {\n  const node = {\n    type: "ThrowStatement",\n    argument\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction tryStatement(block, handler = null, finalizer = null) {\n  const node = {\n    type: "TryStatement",\n    block,\n    handler,\n    finalizer\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, "block", block, 1);\n  validate(defs.handler, node, "handler", handler, 1);\n  validate(defs.finalizer, node, "finalizer", finalizer, 1);\n  return node;\n}\nfunction unaryExpression(operator, argument, prefix = true) {\n  const node = {\n    type: "UnaryExpression",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, "operator", operator);\n  validate(defs.argument, node, "argument", argument, 1);\n  validate(defs.prefix, node, "prefix", prefix);\n  return node;\n}\nfunction updateExpression(operator, argument, prefix = false) {\n  const node = {\n    type: "UpdateExpression",\n    operator,\n    argument,\n    prefix\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, "operator", operator);\n  validate(defs.argument, node, "argument", argument, 1);\n  validate(defs.prefix, node, "prefix", prefix);\n  return node;\n}\nfunction variableDeclaration(kind, declarations) {\n  const node = {\n    type: "VariableDeclaration",\n    kind,\n    declarations\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, "kind", kind);\n  validate(defs.declarations, node, "declarations", declarations, 1);\n  return node;\n}\nfunction variableDeclarator(id, init = null) {\n  const node = {\n    type: "VariableDeclarator",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.init, node, "init", init, 1);\n  return node;\n}\nfunction whileStatement(test, body) {\n  const node = {\n    type: "WhileStatement",\n    test,\n    body\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, "test", test, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction withStatement(object, body) {\n  const node = {\n    type: "WithStatement",\n    object,\n    body\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, "object", object, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction assignmentPattern(left, right) {\n  const node = {\n    type: "AssignmentPattern",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction arrayPattern(elements) {\n  const node = {\n    type: "ArrayPattern",\n    elements\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, "elements", elements, 1);\n  return node;\n}\nfunction arrowFunctionExpression(params, body, async = false) {\n  const node = {\n    type: "ArrowFunctionExpression",\n    params,\n    body,\n    async,\n    expression: null\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction classBody(body) {\n  const node = {\n    type: "ClassBody",\n    body\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction classExpression(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: "ClassExpression",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.superClass, node, "superClass", superClass, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  return node;\n}\nfunction classDeclaration(id = null, superClass = null, body, decorators = null) {\n  const node = {\n    type: "ClassDeclaration",\n    id,\n    superClass,\n    body,\n    decorators\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.superClass, node, "superClass", superClass, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  return node;\n}\nfunction exportAllDeclaration(source) {\n  const node = {\n    type: "ExportAllDeclaration",\n    source\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, "source", source, 1);\n  return node;\n}\nfunction exportDefaultDeclaration(declaration) {\n  const node = {\n    type: "ExportDefaultDeclaration",\n    declaration\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, "declaration", declaration, 1);\n  return node;\n}\nfunction exportNamedDeclaration(declaration = null, specifiers = [], source = null) {\n  const node = {\n    type: "ExportNamedDeclaration",\n    declaration,\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, "declaration", declaration, 1);\n  validate(defs.specifiers, node, "specifiers", specifiers, 1);\n  validate(defs.source, node, "source", source, 1);\n  return node;\n}\nfunction exportSpecifier(local, exported) {\n  const node = {\n    type: "ExportSpecifier",\n    local,\n    exported\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, "local", local, 1);\n  validate(defs.exported, node, "exported", exported, 1);\n  return node;\n}\nfunction forOfStatement(left, right, body, _await = false) {\n  const node = {\n    type: "ForOfStatement",\n    left,\n    right,\n    body,\n    await: _await\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.await, node, "await", _await);\n  return node;\n}\nfunction importDeclaration(specifiers, source) {\n  const node = {\n    type: "ImportDeclaration",\n    specifiers,\n    source\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, "specifiers", specifiers, 1);\n  validate(defs.source, node, "source", source, 1);\n  return node;\n}\nfunction importDefaultSpecifier(local) {\n  const node = {\n    type: "ImportDefaultSpecifier",\n    local\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, "local", local, 1);\n  return node;\n}\nfunction importNamespaceSpecifier(local) {\n  const node = {\n    type: "ImportNamespaceSpecifier",\n    local\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, "local", local, 1);\n  return node;\n}\nfunction importSpecifier(local, imported) {\n  const node = {\n    type: "ImportSpecifier",\n    local,\n    imported\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, "local", local, 1);\n  validate(defs.imported, node, "imported", imported, 1);\n  return node;\n}\nfunction importExpression(source, options = null) {\n  const node = {\n    type: "ImportExpression",\n    source,\n    options\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, "source", source, 1);\n  validate(defs.options, node, "options", options, 1);\n  return node;\n}\nfunction metaProperty(meta, property) {\n  const node = {\n    type: "MetaProperty",\n    meta,\n    property\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, "meta", meta, 1);\n  validate(defs.property, node, "property", property, 1);\n  return node;\n}\nfunction classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async = false) {\n  const node = {\n    type: "ClassMethod",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async\n  };\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, "kind", kind);\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.static, node, "static", _static);\n  validate(defs.generator, node, "generator", generator);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction objectPattern(properties) {\n  const node = {\n    type: "ObjectPattern",\n    properties\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, "properties", properties, 1);\n  return node;\n}\nfunction spreadElement(argument) {\n  const node = {\n    type: "SpreadElement",\n    argument\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction _super() {\n  return {\n    type: "Super"\n  };\n}\nfunction taggedTemplateExpression(tag, quasi) {\n  const node = {\n    type: "TaggedTemplateExpression",\n    tag,\n    quasi\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, "tag", tag, 1);\n  validate(defs.quasi, node, "quasi", quasi, 1);\n  return node;\n}\nfunction templateElement(value, tail = false) {\n  const node = {\n    type: "TemplateElement",\n    value,\n    tail\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, "value", value);\n  validate(defs.tail, node, "tail", tail);\n  return node;\n}\nfunction templateLiteral(quasis, expressions) {\n  const node = {\n    type: "TemplateLiteral",\n    quasis,\n    expressions\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, "quasis", quasis, 1);\n  validate(defs.expressions, node, "expressions", expressions, 1);\n  return node;\n}\nfunction yieldExpression(argument = null, delegate = false) {\n  const node = {\n    type: "YieldExpression",\n    argument,\n    delegate\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, "argument", argument, 1);\n  validate(defs.delegate, node, "delegate", delegate);\n  return node;\n}\nfunction awaitExpression(argument) {\n  const node = {\n    type: "AwaitExpression",\n    argument\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction _import() {\n  return {\n    type: "Import"\n  };\n}\nfunction bigIntLiteral(value) {\n  const node = {\n    type: "BigIntLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction exportNamespaceSpecifier(exported) {\n  const node = {\n    type: "ExportNamespaceSpecifier",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, "exported", exported, 1);\n  return node;\n}\nfunction optionalMemberExpression(object, property, computed = false, optional) {\n  const node = {\n    type: "OptionalMemberExpression",\n    object,\n    property,\n    computed,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, "object", object, 1);\n  validate(defs.property, node, "property", property, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.optional, node, "optional", optional);\n  return node;\n}\nfunction optionalCallExpression(callee, _arguments, optional) {\n  const node = {\n    type: "OptionalCallExpression",\n    callee,\n    arguments: _arguments,\n    optional\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, "callee", callee, 1);\n  validate(defs.arguments, node, "arguments", _arguments, 1);\n  validate(defs.optional, node, "optional", optional);\n  return node;\n}\nfunction classProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: "ClassProperty",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.static, node, "static", _static);\n  return node;\n}\nfunction classAccessorProperty(key, value = null, typeAnnotation = null, decorators = null, computed = false, _static = false) {\n  const node = {\n    type: "ClassAccessorProperty",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  validate(defs.computed, node, "computed", computed);\n  validate(defs.static, node, "static", _static);\n  return node;\n}\nfunction classPrivateProperty(key, value = null, decorators = null, _static = false) {\n  const node = {\n    type: "ClassPrivateProperty",\n    key,\n    value,\n    decorators,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  validate(defs.static, node, "static", _static);\n  return node;\n}\nfunction classPrivateMethod(kind = "method", key, params, body, _static = false) {\n  const node = {\n    type: "ClassPrivateMethod",\n    kind,\n    key,\n    params,\n    body,\n    static: _static\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, "kind", kind);\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.static, node, "static", _static);\n  return node;\n}\nfunction privateName(id) {\n  const node = {\n    type: "PrivateName",\n    id\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction staticBlock(body) {\n  const node = {\n    type: "StaticBlock",\n    body\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction anyTypeAnnotation() {\n  return {\n    type: "AnyTypeAnnotation"\n  };\n}\nfunction arrayTypeAnnotation(elementType) {\n  const node = {\n    type: "ArrayTypeAnnotation",\n    elementType\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, "elementType", elementType, 1);\n  return node;\n}\nfunction booleanTypeAnnotation() {\n  return {\n    type: "BooleanTypeAnnotation"\n  };\n}\nfunction booleanLiteralTypeAnnotation(value) {\n  const node = {\n    type: "BooleanLiteralTypeAnnotation",\n    value\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction nullLiteralTypeAnnotation() {\n  return {\n    type: "NullLiteralTypeAnnotation"\n  };\n}\nfunction classImplements(id, typeParameters = null) {\n  const node = {\n    type: "ClassImplements",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction declareClass(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: "DeclareClass",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.extends, node, "extends", _extends, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction declareFunction(id) {\n  const node = {\n    type: "DeclareFunction",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction declareInterface(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: "DeclareInterface",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.extends, node, "extends", _extends, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction declareModule(id, body, kind = null) {\n  const node = {\n    type: "DeclareModule",\n    id,\n    body,\n    kind\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.kind, node, "kind", kind);\n  return node;\n}\nfunction declareModuleExports(typeAnnotation) {\n  const node = {\n    type: "DeclareModuleExports",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction declareTypeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: "DeclareTypeAlias",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction declareOpaqueType(id, typeParameters = null, supertype = null) {\n  const node = {\n    type: "DeclareOpaqueType",\n    id,\n    typeParameters,\n    supertype\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.supertype, node, "supertype", supertype, 1);\n  return node;\n}\nfunction declareVariable(id) {\n  const node = {\n    type: "DeclareVariable",\n    id\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {\n  const node = {\n    type: "DeclareExportDeclaration",\n    declaration,\n    specifiers,\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, "declaration", declaration, 1);\n  validate(defs.specifiers, node, "specifiers", specifiers, 1);\n  validate(defs.source, node, "source", source, 1);\n  validate(defs.attributes, node, "attributes", attributes, 1);\n  return node;\n}\nfunction declareExportAllDeclaration(source, attributes = null) {\n  const node = {\n    type: "DeclareExportAllDeclaration",\n    source,\n    attributes\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, "source", source, 1);\n  validate(defs.attributes, node, "attributes", attributes, 1);\n  return node;\n}\nfunction declaredPredicate(value) {\n  const node = {\n    type: "DeclaredPredicate",\n    value\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, "value", value, 1);\n  return node;\n}\nfunction existsTypeAnnotation() {\n  return {\n    type: "ExistsTypeAnnotation"\n  };\n}\nfunction functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {\n  const node = {\n    type: "FunctionTypeAnnotation",\n    typeParameters,\n    params,\n    rest,\n    returnType\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.rest, node, "rest", rest, 1);\n  validate(defs.returnType, node, "returnType", returnType, 1);\n  return node;\n}\nfunction functionTypeParam(name = null, typeAnnotation) {\n  const node = {\n    type: "FunctionTypeParam",\n    name,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, "name", name, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction genericTypeAnnotation(id, typeParameters = null) {\n  const node = {\n    type: "GenericTypeAnnotation",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction inferredPredicate() {\n  return {\n    type: "InferredPredicate"\n  };\n}\nfunction interfaceExtends(id, typeParameters = null) {\n  const node = {\n    type: "InterfaceExtends",\n    id,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction interfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: "InterfaceDeclaration",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.extends, node, "extends", _extends, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction interfaceTypeAnnotation(_extends = null, body) {\n  const node = {\n    type: "InterfaceTypeAnnotation",\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, "extends", _extends, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction intersectionTypeAnnotation(types) {\n  const node = {\n    type: "IntersectionTypeAnnotation",\n    types\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, "types", types, 1);\n  return node;\n}\nfunction mixedTypeAnnotation() {\n  return {\n    type: "MixedTypeAnnotation"\n  };\n}\nfunction emptyTypeAnnotation() {\n  return {\n    type: "EmptyTypeAnnotation"\n  };\n}\nfunction nullableTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: "NullableTypeAnnotation",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction numberLiteralTypeAnnotation(value) {\n  const node = {\n    type: "NumberLiteralTypeAnnotation",\n    value\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction numberTypeAnnotation() {\n  return {\n    type: "NumberTypeAnnotation"\n  };\n}\nfunction objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {\n  const node = {\n    type: "ObjectTypeAnnotation",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, "properties", properties, 1);\n  validate(defs.indexers, node, "indexers", indexers, 1);\n  validate(defs.callProperties, node, "callProperties", callProperties, 1);\n  validate(defs.internalSlots, node, "internalSlots", internalSlots, 1);\n  validate(defs.exact, node, "exact", exact);\n  return node;\n}\nfunction objectTypeInternalSlot(id, value, optional, _static, method) {\n  const node = {\n    type: "ObjectTypeInternalSlot",\n    id,\n    value,\n    optional,\n    static: _static,\n    method\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.optional, node, "optional", optional);\n  validate(defs.static, node, "static", _static);\n  validate(defs.method, node, "method", method);\n  return node;\n}\nfunction objectTypeCallProperty(value) {\n  const node = {\n    type: "ObjectTypeCallProperty",\n    value,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, "value", value, 1);\n  return node;\n}\nfunction objectTypeIndexer(id = null, key, value, variance = null) {\n  const node = {\n    type: "ObjectTypeIndexer",\n    id,\n    key,\n    value,\n    variance,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.variance, node, "variance", variance, 1);\n  return node;\n}\nfunction objectTypeProperty(key, value, variance = null) {\n  const node = {\n    type: "ObjectTypeProperty",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  validate(defs.variance, node, "variance", variance, 1);\n  return node;\n}\nfunction objectTypeSpreadProperty(argument) {\n  const node = {\n    type: "ObjectTypeSpreadProperty",\n    argument\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction opaqueType(id, typeParameters = null, supertype = null, impltype) {\n  const node = {\n    type: "OpaqueType",\n    id,\n    typeParameters,\n    supertype,\n    impltype\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.supertype, node, "supertype", supertype, 1);\n  validate(defs.impltype, node, "impltype", impltype, 1);\n  return node;\n}\nfunction qualifiedTypeIdentifier(id, qualification) {\n  const node = {\n    type: "QualifiedTypeIdentifier",\n    id,\n    qualification\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.qualification, node, "qualification", qualification, 1);\n  return node;\n}\nfunction stringLiteralTypeAnnotation(value) {\n  const node = {\n    type: "StringLiteralTypeAnnotation",\n    value\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction stringTypeAnnotation() {\n  return {\n    type: "StringTypeAnnotation"\n  };\n}\nfunction symbolTypeAnnotation() {\n  return {\n    type: "SymbolTypeAnnotation"\n  };\n}\nfunction thisTypeAnnotation() {\n  return {\n    type: "ThisTypeAnnotation"\n  };\n}\nfunction tupleTypeAnnotation(types) {\n  const node = {\n    type: "TupleTypeAnnotation",\n    types\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, "types", types, 1);\n  return node;\n}\nfunction typeofTypeAnnotation(argument) {\n  const node = {\n    type: "TypeofTypeAnnotation",\n    argument\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction typeAlias(id, typeParameters = null, right) {\n  const node = {\n    type: "TypeAlias",\n    id,\n    typeParameters,\n    right\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction typeAnnotation(typeAnnotation) {\n  const node = {\n    type: "TypeAnnotation",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction typeCastExpression(expression, typeAnnotation) {\n  const node = {\n    type: "TypeCastExpression",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction typeParameter(bound = null, _default = null, variance = null) {\n  const node = {\n    type: "TypeParameter",\n    bound,\n    default: _default,\n    variance,\n    name: null\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.bound, node, "bound", bound, 1);\n  validate(defs.default, node, "default", _default, 1);\n  validate(defs.variance, node, "variance", variance, 1);\n  return node;\n}\nfunction typeParameterDeclaration(params) {\n  const node = {\n    type: "TypeParameterDeclaration",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, "params", params, 1);\n  return node;\n}\nfunction typeParameterInstantiation(params) {\n  const node = {\n    type: "TypeParameterInstantiation",\n    params\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, "params", params, 1);\n  return node;\n}\nfunction unionTypeAnnotation(types) {\n  const node = {\n    type: "UnionTypeAnnotation",\n    types\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, "types", types, 1);\n  return node;\n}\nfunction variance(kind) {\n  const node = {\n    type: "Variance",\n    kind\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, "kind", kind);\n  return node;\n}\nfunction voidTypeAnnotation() {\n  return {\n    type: "VoidTypeAnnotation"\n  };\n}\nfunction enumDeclaration(id, body) {\n  const node = {\n    type: "EnumDeclaration",\n    id,\n    body\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction enumBooleanBody(members) {\n  const node = {\n    type: "EnumBooleanBody",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction enumNumberBody(members) {\n  const node = {\n    type: "EnumNumberBody",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction enumStringBody(members) {\n  const node = {\n    type: "EnumStringBody",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction enumSymbolBody(members) {\n  const node = {\n    type: "EnumSymbolBody",\n    members,\n    hasUnknownMembers: null\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction enumBooleanMember(id) {\n  const node = {\n    type: "EnumBooleanMember",\n    id,\n    init: null\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction enumNumberMember(id, init) {\n  const node = {\n    type: "EnumNumberMember",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.init, node, "init", init, 1);\n  return node;\n}\nfunction enumStringMember(id, init) {\n  const node = {\n    type: "EnumStringMember",\n    id,\n    init\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.init, node, "init", init, 1);\n  return node;\n}\nfunction enumDefaultedMember(id) {\n  const node = {\n    type: "EnumDefaultedMember",\n    id\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction indexedAccessType(objectType, indexType) {\n  const node = {\n    type: "IndexedAccessType",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, "objectType", objectType, 1);\n  validate(defs.indexType, node, "indexType", indexType, 1);\n  return node;\n}\nfunction optionalIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: "OptionalIndexedAccessType",\n    objectType,\n    indexType,\n    optional: null\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, "objectType", objectType, 1);\n  validate(defs.indexType, node, "indexType", indexType, 1);\n  return node;\n}\nfunction jsxAttribute(name, value = null) {\n  const node = {\n    type: "JSXAttribute",\n    name,\n    value\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, "name", name, 1);\n  validate(defs.value, node, "value", value, 1);\n  return node;\n}\nfunction jsxClosingElement(name) {\n  const node = {\n    type: "JSXClosingElement",\n    name\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, "name", name, 1);\n  return node;\n}\nfunction jsxElement(openingElement, closingElement = null, children, selfClosing = null) {\n  const node = {\n    type: "JSXElement",\n    openingElement,\n    closingElement,\n    children,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, "openingElement", openingElement, 1);\n  validate(defs.closingElement, node, "closingElement", closingElement, 1);\n  validate(defs.children, node, "children", children, 1);\n  validate(defs.selfClosing, node, "selfClosing", selfClosing);\n  return node;\n}\nfunction jsxEmptyExpression() {\n  return {\n    type: "JSXEmptyExpression"\n  };\n}\nfunction jsxExpressionContainer(expression) {\n  const node = {\n    type: "JSXExpressionContainer",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction jsxSpreadChild(expression) {\n  const node = {\n    type: "JSXSpreadChild",\n    expression\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction jsxIdentifier(name) {\n  const node = {\n    type: "JSXIdentifier",\n    name\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, "name", name);\n  return node;\n}\nfunction jsxMemberExpression(object, property) {\n  const node = {\n    type: "JSXMemberExpression",\n    object,\n    property\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, "object", object, 1);\n  validate(defs.property, node, "property", property, 1);\n  return node;\n}\nfunction jsxNamespacedName(namespace, name) {\n  const node = {\n    type: "JSXNamespacedName",\n    namespace,\n    name\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, "namespace", namespace, 1);\n  validate(defs.name, node, "name", name, 1);\n  return node;\n}\nfunction jsxOpeningElement(name, attributes, selfClosing = false) {\n  const node = {\n    type: "JSXOpeningElement",\n    name,\n    attributes,\n    selfClosing\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, "name", name, 1);\n  validate(defs.attributes, node, "attributes", attributes, 1);\n  validate(defs.selfClosing, node, "selfClosing", selfClosing);\n  return node;\n}\nfunction jsxSpreadAttribute(argument) {\n  const node = {\n    type: "JSXSpreadAttribute",\n    argument\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, "argument", argument, 1);\n  return node;\n}\nfunction jsxText(value) {\n  const node = {\n    type: "JSXText",\n    value\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction jsxFragment(openingFragment, closingFragment, children) {\n  const node = {\n    type: "JSXFragment",\n    openingFragment,\n    closingFragment,\n    children\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, "openingFragment", openingFragment, 1);\n  validate(defs.closingFragment, node, "closingFragment", closingFragment, 1);\n  validate(defs.children, node, "children", children, 1);\n  return node;\n}\nfunction jsxOpeningFragment() {\n  return {\n    type: "JSXOpeningFragment"\n  };\n}\nfunction jsxClosingFragment() {\n  return {\n    type: "JSXClosingFragment"\n  };\n}\nfunction noop() {\n  return {\n    type: "Noop"\n  };\n}\nfunction placeholder(expectedNode, name) {\n  const node = {\n    type: "Placeholder",\n    expectedNode,\n    name\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, "expectedNode", expectedNode);\n  validate(defs.name, node, "name", name, 1);\n  return node;\n}\nfunction v8IntrinsicIdentifier(name) {\n  const node = {\n    type: "V8IntrinsicIdentifier",\n    name\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, "name", name);\n  return node;\n}\nfunction argumentPlaceholder() {\n  return {\n    type: "ArgumentPlaceholder"\n  };\n}\nfunction bindExpression(object, callee) {\n  const node = {\n    type: "BindExpression",\n    object,\n    callee\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, "object", object, 1);\n  validate(defs.callee, node, "callee", callee, 1);\n  return node;\n}\nfunction importAttribute(key, value) {\n  const node = {\n    type: "ImportAttribute",\n    key,\n    value\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.value, node, "value", value, 1);\n  return node;\n}\nfunction decorator(expression) {\n  const node = {\n    type: "Decorator",\n    expression\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction doExpression(body, async = false) {\n  const node = {\n    type: "DoExpression",\n    body,\n    async\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, "body", body, 1);\n  validate(defs.async, node, "async", async);\n  return node;\n}\nfunction exportDefaultSpecifier(exported) {\n  const node = {\n    type: "ExportDefaultSpecifier",\n    exported\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, "exported", exported, 1);\n  return node;\n}\nfunction recordExpression(properties) {\n  const node = {\n    type: "RecordExpression",\n    properties\n  };\n  const defs = NODE_FIELDS.RecordExpression;\n  validate(defs.properties, node, "properties", properties, 1);\n  return node;\n}\nfunction tupleExpression(elements = []) {\n  const node = {\n    type: "TupleExpression",\n    elements\n  };\n  const defs = NODE_FIELDS.TupleExpression;\n  validate(defs.elements, node, "elements", elements, 1);\n  return node;\n}\nfunction decimalLiteral(value) {\n  const node = {\n    type: "DecimalLiteral",\n    value\n  };\n  const defs = NODE_FIELDS.DecimalLiteral;\n  validate(defs.value, node, "value", value);\n  return node;\n}\nfunction moduleExpression(body) {\n  const node = {\n    type: "ModuleExpression",\n    body\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction topicReference() {\n  return {\n    type: "TopicReference"\n  };\n}\nfunction pipelineTopicExpression(expression) {\n  const node = {\n    type: "PipelineTopicExpression",\n    expression\n  };\n  const defs = NODE_FIELDS.PipelineTopicExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction pipelineBareFunction(callee) {\n  const node = {\n    type: "PipelineBareFunction",\n    callee\n  };\n  const defs = NODE_FIELDS.PipelineBareFunction;\n  validate(defs.callee, node, "callee", callee, 1);\n  return node;\n}\nfunction pipelinePrimaryTopicReference() {\n  return {\n    type: "PipelinePrimaryTopicReference"\n  };\n}\nfunction tsParameterProperty(parameter) {\n  const node = {\n    type: "TSParameterProperty",\n    parameter\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, "parameter", parameter, 1);\n  return node;\n}\nfunction tsDeclareFunction(id = null, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: "TSDeclareFunction",\n    id,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.returnType, node, "returnType", returnType, 1);\n  return node;\n}\nfunction tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {\n  const node = {\n    type: "TSDeclareMethod",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType\n  };\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, "decorators", decorators, 1);\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.params, node, "params", params, 1);\n  validate(defs.returnType, node, "returnType", returnType, 1);\n  return node;\n}\nfunction tsQualifiedName(left, right) {\n  const node = {\n    type: "TSQualifiedName",\n    left,\n    right\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, "left", left, 1);\n  validate(defs.right, node, "right", right, 1);\n  return node;\n}\nfunction tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSCallSignatureDeclaration",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSConstructSignatureDeclaration",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsPropertySignature(key, typeAnnotation = null) {\n  const node = {\n    type: "TSPropertySignature",\n    key,\n    typeAnnotation,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSMethodSignature",\n    key,\n    typeParameters,\n    parameters,\n    typeAnnotation,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, "key", key, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsIndexSignature(parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSIndexSignature",\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsAnyKeyword() {\n  return {\n    type: "TSAnyKeyword"\n  };\n}\nfunction tsBooleanKeyword() {\n  return {\n    type: "TSBooleanKeyword"\n  };\n}\nfunction tsBigIntKeyword() {\n  return {\n    type: "TSBigIntKeyword"\n  };\n}\nfunction tsIntrinsicKeyword() {\n  return {\n    type: "TSIntrinsicKeyword"\n  };\n}\nfunction tsNeverKeyword() {\n  return {\n    type: "TSNeverKeyword"\n  };\n}\nfunction tsNullKeyword() {\n  return {\n    type: "TSNullKeyword"\n  };\n}\nfunction tsNumberKeyword() {\n  return {\n    type: "TSNumberKeyword"\n  };\n}\nfunction tsObjectKeyword() {\n  return {\n    type: "TSObjectKeyword"\n  };\n}\nfunction tsStringKeyword() {\n  return {\n    type: "TSStringKeyword"\n  };\n}\nfunction tsSymbolKeyword() {\n  return {\n    type: "TSSymbolKeyword"\n  };\n}\nfunction tsUndefinedKeyword() {\n  return {\n    type: "TSUndefinedKeyword"\n  };\n}\nfunction tsUnknownKeyword() {\n  return {\n    type: "TSUnknownKeyword"\n  };\n}\nfunction tsVoidKeyword() {\n  return {\n    type: "TSVoidKeyword"\n  };\n}\nfunction tsThisType() {\n  return {\n    type: "TSThisType"\n  };\n}\nfunction tsFunctionType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSFunctionType",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsConstructorType(typeParameters = null, parameters, typeAnnotation = null) {\n  const node = {\n    type: "TSConstructorType",\n    typeParameters,\n    parameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.parameters, node, "parameters", parameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeReference(typeName, typeParameters = null) {\n  const node = {\n    type: "TSTypeReference",\n    typeName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, "typeName", typeName, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction tsTypePredicate(parameterName, typeAnnotation = null, asserts = null) {\n  const node = {\n    type: "TSTypePredicate",\n    parameterName,\n    typeAnnotation,\n    asserts\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, "parameterName", parameterName, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  validate(defs.asserts, node, "asserts", asserts);\n  return node;\n}\nfunction tsTypeQuery(exprName, typeParameters = null) {\n  const node = {\n    type: "TSTypeQuery",\n    exprName,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, "exprName", exprName, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction tsTypeLiteral(members) {\n  const node = {\n    type: "TSTypeLiteral",\n    members\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction tsArrayType(elementType) {\n  const node = {\n    type: "TSArrayType",\n    elementType\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, "elementType", elementType, 1);\n  return node;\n}\nfunction tsTupleType(elementTypes) {\n  const node = {\n    type: "TSTupleType",\n    elementTypes\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, "elementTypes", elementTypes, 1);\n  return node;\n}\nfunction tsOptionalType(typeAnnotation) {\n  const node = {\n    type: "TSOptionalType",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsRestType(typeAnnotation) {\n  const node = {\n    type: "TSRestType",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsNamedTupleMember(label, elementType, optional = false) {\n  const node = {\n    type: "TSNamedTupleMember",\n    label,\n    elementType,\n    optional\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, "label", label, 1);\n  validate(defs.elementType, node, "elementType", elementType, 1);\n  validate(defs.optional, node, "optional", optional);\n  return node;\n}\nfunction tsUnionType(types) {\n  const node = {\n    type: "TSUnionType",\n    types\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, "types", types, 1);\n  return node;\n}\nfunction tsIntersectionType(types) {\n  const node = {\n    type: "TSIntersectionType",\n    types\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, "types", types, 1);\n  return node;\n}\nfunction tsConditionalType(checkType, extendsType, trueType, falseType) {\n  const node = {\n    type: "TSConditionalType",\n    checkType,\n    extendsType,\n    trueType,\n    falseType\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, "checkType", checkType, 1);\n  validate(defs.extendsType, node, "extendsType", extendsType, 1);\n  validate(defs.trueType, node, "trueType", trueType, 1);\n  validate(defs.falseType, node, "falseType", falseType, 1);\n  return node;\n}\nfunction tsInferType(typeParameter) {\n  const node = {\n    type: "TSInferType",\n    typeParameter\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);\n  return node;\n}\nfunction tsParenthesizedType(typeAnnotation) {\n  const node = {\n    type: "TSParenthesizedType",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeOperator(typeAnnotation) {\n  const node = {\n    type: "TSTypeOperator",\n    typeAnnotation,\n    operator: null\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsIndexedAccessType(objectType, indexType) {\n  const node = {\n    type: "TSIndexedAccessType",\n    objectType,\n    indexType\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, "objectType", objectType, 1);\n  validate(defs.indexType, node, "indexType", indexType, 1);\n  return node;\n}\nfunction tsMappedType(typeParameter, typeAnnotation = null, nameType = null) {\n  const node = {\n    type: "TSMappedType",\n    typeParameter,\n    typeAnnotation,\n    nameType\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.typeParameter, node, "typeParameter", typeParameter, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  validate(defs.nameType, node, "nameType", nameType, 1);\n  return node;\n}\nfunction tsLiteralType(literal) {\n  const node = {\n    type: "TSLiteralType",\n    literal\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, "literal", literal, 1);\n  return node;\n}\nfunction tsExpressionWithTypeArguments(expression, typeParameters = null) {\n  const node = {\n    type: "TSExpressionWithTypeArguments",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSExpressionWithTypeArguments;\n  validate(defs.expression, node, "expression", expression, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction tsInterfaceDeclaration(id, typeParameters = null, _extends = null, body) {\n  const node = {\n    type: "TSInterfaceDeclaration",\n    id,\n    typeParameters,\n    extends: _extends,\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.extends, node, "extends", _extends, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction tsInterfaceBody(body) {\n  const node = {\n    type: "TSInterfaceBody",\n    body\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction tsTypeAliasDeclaration(id, typeParameters = null, typeAnnotation) {\n  const node = {\n    type: "TSTypeAliasDeclaration",\n    id,\n    typeParameters,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsInstantiationExpression(expression, typeParameters = null) {\n  const node = {\n    type: "TSInstantiationExpression",\n    expression,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction tsAsExpression(expression, typeAnnotation) {\n  const node = {\n    type: "TSAsExpression",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsSatisfiesExpression(expression, typeAnnotation) {\n  const node = {\n    type: "TSSatisfiesExpression",\n    expression,\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeAssertion(typeAnnotation, expression) {\n  const node = {\n    type: "TSTypeAssertion",\n    typeAnnotation,\n    expression\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction tsEnumDeclaration(id, members) {\n  const node = {\n    type: "TSEnumDeclaration",\n    id,\n    members\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.members, node, "members", members, 1);\n  return node;\n}\nfunction tsEnumMember(id, initializer = null) {\n  const node = {\n    type: "TSEnumMember",\n    id,\n    initializer\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.initializer, node, "initializer", initializer, 1);\n  return node;\n}\nfunction tsModuleDeclaration(id, body) {\n  const node = {\n    type: "TSModuleDeclaration",\n    id,\n    body,\n    kind: null\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction tsModuleBlock(body) {\n  const node = {\n    type: "TSModuleBlock",\n    body\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, "body", body, 1);\n  return node;\n}\nfunction tsImportType(argument, qualifier = null, typeParameters = null) {\n  const node = {\n    type: "TSImportType",\n    argument,\n    qualifier,\n    typeParameters\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.argument, node, "argument", argument, 1);\n  validate(defs.qualifier, node, "qualifier", qualifier, 1);\n  validate(defs.typeParameters, node, "typeParameters", typeParameters, 1);\n  return node;\n}\nfunction tsImportEqualsDeclaration(id, moduleReference) {\n  const node = {\n    type: "TSImportEqualsDeclaration",\n    id,\n    moduleReference,\n    isExport: null\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  validate(defs.moduleReference, node, "moduleReference", moduleReference, 1);\n  return node;\n}\nfunction tsExternalModuleReference(expression) {\n  const node = {\n    type: "TSExternalModuleReference",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction tsNonNullExpression(expression) {\n  const node = {\n    type: "TSNonNullExpression",\n    expression\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction tsExportAssignment(expression) {\n  const node = {\n    type: "TSExportAssignment",\n    expression\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, "expression", expression, 1);\n  return node;\n}\nfunction tsNamespaceExportDeclaration(id) {\n  const node = {\n    type: "TSNamespaceExportDeclaration",\n    id\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, "id", id, 1);\n  return node;\n}\nfunction tsTypeAnnotation(typeAnnotation) {\n  const node = {\n    type: "TSTypeAnnotation",\n    typeAnnotation\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, "typeAnnotation", typeAnnotation, 1);\n  return node;\n}\nfunction tsTypeParameterInstantiation(params) {\n  const node = {\n    type: "TSTypeParameterInstantiation",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, "params", params, 1);\n  return node;\n}\nfunction tsTypeParameterDeclaration(params) {\n  const node = {\n    type: "TSTypeParameterDeclaration",\n    params\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, "params", params, 1);\n  return node;\n}\nfunction tsTypeParameter(constraint = null, _default = null, name) {\n  const node = {\n    type: "TSTypeParameter",\n    constraint,\n    default: _default,\n    name\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, "constraint", constraint, 1);\n  validate(defs.default, node, "default", _default, 1);\n  validate(defs.name, node, "name", name);\n  return node;\n}\nfunction NumberLiteral(value) {\n  (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");\n  return numericLiteral(value);\n}\nfunction RegexLiteral(pattern, flags = "") {\n  (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");\n  return regExpLiteral(pattern, flags);\n}\nfunction RestProperty(argument) {\n  (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");\n  return restElement(argument);\n}\nfunction SpreadProperty(argument) {\n  (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");\n  return spreadElement(argument);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDgwNzkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIsb0JBQW9CO0FBQ3BCLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEMsNkJBQTZCO0FBQzdCLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3QixpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQiw0QkFBNEI7QUFDNUIscUJBQXFCO0FBQ3JCLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEIsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQiw0QkFBNEI7QUFDNUIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyx1QkFBdUI7QUFDdkIsMkJBQTJCO0FBQzNCLFlBQVk7QUFDWixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsaUJBQWM7QUFDZCx1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLDhCQUE4QjtBQUM5Qix3QkFBd0I7QUFDeEIsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1Qix3QkFBd0I7QUFDeEIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzNDLHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCwwQkFBMEIsR0FBRywwQkFBMEI7QUFDdkQsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ3ZDLDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDLHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QywyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQseUJBQXlCLEdBQUcseUJBQXlCO0FBQ3JELHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCwwQkFBMEIsR0FBRywwQkFBMEI7QUFDdkQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyxlQUFlLEdBQUcsZUFBZTtBQUNqQyx3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixvQkFBb0I7QUFDcEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QixxQkFBcUI7QUFDckIsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkMsNEJBQTRCO0FBQzVCLHNCQUFzQjtBQUN0Qix3QkFBd0I7QUFDeEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixnQ0FBZ0M7QUFDaEMsa0JBQWtCO0FBQ2xCLDhCQUE4QjtBQUM5QixpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDLCtCQUErQjtBQUMvQiw0QkFBNEI7QUFDNUIscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZiwrQkFBK0I7QUFDL0Isd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLHFCQUFxQjtBQUNyQixtQ0FBbUM7QUFDbkMsNEJBQTRCO0FBQzVCLGdCQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLG9CQUFvQjtBQUNwQixvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0MsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDLHNCQUFzQixHQUFHLHNCQUFzQjtBQUMvQyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ25ELGtDQUFrQyxHQUFHLGtDQUFrQztBQUN2RSx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQsdUNBQXVDLEdBQUcsdUNBQXVDO0FBQ2pGLHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCx5QkFBeUIsR0FBRyx5QkFBeUI7QUFDckQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0MsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELHFDQUFxQyxHQUFHLHFDQUFxQztBQUM3RSxpQ0FBaUMsR0FBRyxpQ0FBaUM7QUFDckUsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQy9DLGlDQUFpQyxHQUFHLGlDQUFpQztBQUNyRSxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDM0Msd0JBQXdCLEdBQUcsd0JBQXdCO0FBQ25ELDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RCxtQkFBbUIsR0FBRyxtQkFBbUI7QUFDekMsaUNBQWlDLEdBQUcsaUNBQWlDO0FBQ3JFLHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDL0QsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RCxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0Msb0JBQW9CLEdBQUcsb0JBQW9CO0FBQzNDLHlCQUF5QixHQUFHLHlCQUF5QjtBQUNyRCxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0MsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELDBCQUEwQixHQUFHLDBCQUEwQjtBQUN2RCxvQ0FBb0MsR0FBRyxvQ0FBb0M7QUFDM0Usc0JBQXNCLEdBQUcsc0JBQXNCO0FBQy9DLDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RCxxQkFBcUIsR0FBRyxxQkFBcUI7QUFDN0MsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ3pELDJCQUEyQixHQUFHLDJCQUEyQjtBQUN6RCwyQkFBMkIsR0FBRywyQkFBMkI7QUFDekQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELGtCQUFrQixHQUFHLGtCQUFrQjtBQUN2Qyw2QkFBNkIsR0FBRyw2QkFBNkI7QUFDN0QsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHVCQUF1QixHQUFHLHVCQUF1QjtBQUNqRCxrQkFBa0IsR0FBRyxrQkFBa0I7QUFDdkMsbUJBQW1CLEdBQUcsbUJBQW1CO0FBQ3pDLDhCQUE4QixHQUFHLDhCQUE4QjtBQUMvRCx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDbkQsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELHFCQUFxQixHQUFHLHFCQUFxQjtBQUM3QyxzQkFBc0IsR0FBRyxzQkFBc0I7QUFDL0MsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELGtDQUFrQyxHQUFHLGtDQUFrQztBQUN2RSxvQ0FBb0MsR0FBRyxvQ0FBb0M7QUFDM0UsdUJBQXVCLEdBQUcsdUJBQXVCO0FBQ2pELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6Qyx1QkFBdUIsR0FBRyx1QkFBdUI7QUFDakQsMEJBQTBCLEdBQUcsMEJBQTBCO0FBQ3ZELG1CQUFtQixHQUFHLG1CQUFtQjtBQUN6Qyx3QkFBd0IsR0FBRyx3QkFBd0I7QUFDbkQscUJBQXFCLEdBQUcscUJBQXFCO0FBQzdDLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0IsaUJBQWlCO0FBQ2pCLHNCQUFzQjtBQUN0QiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyxrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0Isd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLGdCQUFnQjtBQUNoQiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIsZ0JBQWdCLG1CQUFPLENBQUMsS0FBOEI7QUFDdEQsMEJBQTBCLG1CQUFPLENBQUMsS0FBbUM7QUFDckUsWUFBWSxtQkFBTyxDQUFDLEtBQTRCO0FBQ2hEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzPzY2YWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFueVR5cGVBbm5vdGF0aW9uID0gYW55VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFyZ3VtZW50UGxhY2Vob2xkZXIgPSBhcmd1bWVudFBsYWNlaG9sZGVyO1xuZXhwb3J0cy5hcnJheUV4cHJlc3Npb24gPSBhcnJheUV4cHJlc3Npb247XG5leHBvcnRzLmFycmF5UGF0dGVybiA9IGFycmF5UGF0dGVybjtcbmV4cG9ydHMuYXJyYXlUeXBlQW5ub3RhdGlvbiA9IGFycmF5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmFycm93RnVuY3Rpb25FeHByZXNzaW9uID0gYXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmFzc2lnbm1lbnRFeHByZXNzaW9uID0gYXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmFzc2lnbm1lbnRQYXR0ZXJuID0gYXNzaWdubWVudFBhdHRlcm47XG5leHBvcnRzLmF3YWl0RXhwcmVzc2lvbiA9IGF3YWl0RXhwcmVzc2lvbjtcbmV4cG9ydHMuYmlnSW50TGl0ZXJhbCA9IGJpZ0ludExpdGVyYWw7XG5leHBvcnRzLmJpbmFyeUV4cHJlc3Npb24gPSBiaW5hcnlFeHByZXNzaW9uO1xuZXhwb3J0cy5iaW5kRXhwcmVzc2lvbiA9IGJpbmRFeHByZXNzaW9uO1xuZXhwb3J0cy5ibG9ja1N0YXRlbWVudCA9IGJsb2NrU3RhdGVtZW50O1xuZXhwb3J0cy5ib29sZWFuTGl0ZXJhbCA9IGJvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5ib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gYm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuYm9vbGVhblR5cGVBbm5vdGF0aW9uID0gYm9vbGVhblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5icmVha1N0YXRlbWVudCA9IGJyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5jYWxsRXhwcmVzc2lvbiA9IGNhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5jYXRjaENsYXVzZSA9IGNhdGNoQ2xhdXNlO1xuZXhwb3J0cy5jbGFzc0FjY2Vzc29yUHJvcGVydHkgPSBjbGFzc0FjY2Vzc29yUHJvcGVydHk7XG5leHBvcnRzLmNsYXNzQm9keSA9IGNsYXNzQm9keTtcbmV4cG9ydHMuY2xhc3NEZWNsYXJhdGlvbiA9IGNsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmNsYXNzRXhwcmVzc2lvbiA9IGNsYXNzRXhwcmVzc2lvbjtcbmV4cG9ydHMuY2xhc3NJbXBsZW1lbnRzID0gY2xhc3NJbXBsZW1lbnRzO1xuZXhwb3J0cy5jbGFzc01ldGhvZCA9IGNsYXNzTWV0aG9kO1xuZXhwb3J0cy5jbGFzc1ByaXZhdGVNZXRob2QgPSBjbGFzc1ByaXZhdGVNZXRob2Q7XG5leHBvcnRzLmNsYXNzUHJpdmF0ZVByb3BlcnR5ID0gY2xhc3NQcml2YXRlUHJvcGVydHk7XG5leHBvcnRzLmNsYXNzUHJvcGVydHkgPSBjbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5jb25kaXRpb25hbEV4cHJlc3Npb24gPSBjb25kaXRpb25hbEV4cHJlc3Npb247XG5leHBvcnRzLmNvbnRpbnVlU3RhdGVtZW50ID0gY29udGludWVTdGF0ZW1lbnQ7XG5leHBvcnRzLmRlYnVnZ2VyU3RhdGVtZW50ID0gZGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLmRlY2ltYWxMaXRlcmFsID0gZGVjaW1hbExpdGVyYWw7XG5leHBvcnRzLmRlY2xhcmVDbGFzcyA9IGRlY2xhcmVDbGFzcztcbmV4cG9ydHMuZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uID0gZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uO1xuZXhwb3J0cy5kZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmRlY2xhcmVGdW5jdGlvbiA9IGRlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuZGVjbGFyZUludGVyZmFjZSA9IGRlY2xhcmVJbnRlcmZhY2U7XG5leHBvcnRzLmRlY2xhcmVNb2R1bGUgPSBkZWNsYXJlTW9kdWxlO1xuZXhwb3J0cy5kZWNsYXJlTW9kdWxlRXhwb3J0cyA9IGRlY2xhcmVNb2R1bGVFeHBvcnRzO1xuZXhwb3J0cy5kZWNsYXJlT3BhcXVlVHlwZSA9IGRlY2xhcmVPcGFxdWVUeXBlO1xuZXhwb3J0cy5kZWNsYXJlVHlwZUFsaWFzID0gZGVjbGFyZVR5cGVBbGlhcztcbmV4cG9ydHMuZGVjbGFyZVZhcmlhYmxlID0gZGVjbGFyZVZhcmlhYmxlO1xuZXhwb3J0cy5kZWNsYXJlZFByZWRpY2F0ZSA9IGRlY2xhcmVkUHJlZGljYXRlO1xuZXhwb3J0cy5kZWNvcmF0b3IgPSBkZWNvcmF0b3I7XG5leHBvcnRzLmRpcmVjdGl2ZSA9IGRpcmVjdGl2ZTtcbmV4cG9ydHMuZGlyZWN0aXZlTGl0ZXJhbCA9IGRpcmVjdGl2ZUxpdGVyYWw7XG5leHBvcnRzLmRvRXhwcmVzc2lvbiA9IGRvRXhwcmVzc2lvbjtcbmV4cG9ydHMuZG9XaGlsZVN0YXRlbWVudCA9IGRvV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmVtcHR5U3RhdGVtZW50ID0gZW1wdHlTdGF0ZW1lbnQ7XG5leHBvcnRzLmVtcHR5VHlwZUFubm90YXRpb24gPSBlbXB0eVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5lbnVtQm9vbGVhbkJvZHkgPSBlbnVtQm9vbGVhbkJvZHk7XG5leHBvcnRzLmVudW1Cb29sZWFuTWVtYmVyID0gZW51bUJvb2xlYW5NZW1iZXI7XG5leHBvcnRzLmVudW1EZWNsYXJhdGlvbiA9IGVudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuZW51bURlZmF1bHRlZE1lbWJlciA9IGVudW1EZWZhdWx0ZWRNZW1iZXI7XG5leHBvcnRzLmVudW1OdW1iZXJCb2R5ID0gZW51bU51bWJlckJvZHk7XG5leHBvcnRzLmVudW1OdW1iZXJNZW1iZXIgPSBlbnVtTnVtYmVyTWVtYmVyO1xuZXhwb3J0cy5lbnVtU3RyaW5nQm9keSA9IGVudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5lbnVtU3RyaW5nTWVtYmVyID0gZW51bVN0cmluZ01lbWJlcjtcbmV4cG9ydHMuZW51bVN5bWJvbEJvZHkgPSBlbnVtU3ltYm9sQm9keTtcbmV4cG9ydHMuZXhpc3RzVHlwZUFubm90YXRpb24gPSBleGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuZXhwb3J0QWxsRGVjbGFyYXRpb24gPSBleHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uID0gZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5leHBvcnREZWZhdWx0U3BlY2lmaWVyID0gZXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbmV4cG9ydHMuZXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGV4cG9ydE5hbWVkRGVjbGFyYXRpb247XG5leHBvcnRzLmV4cG9ydE5hbWVzcGFjZVNwZWNpZmllciA9IGV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuZXhwb3J0U3BlY2lmaWVyID0gZXhwb3J0U3BlY2lmaWVyO1xuZXhwb3J0cy5leHByZXNzaW9uU3RhdGVtZW50ID0gZXhwcmVzc2lvblN0YXRlbWVudDtcbmV4cG9ydHMuZmlsZSA9IGZpbGU7XG5leHBvcnRzLmZvckluU3RhdGVtZW50ID0gZm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLmZvck9mU3RhdGVtZW50ID0gZm9yT2ZTdGF0ZW1lbnQ7XG5leHBvcnRzLmZvclN0YXRlbWVudCA9IGZvclN0YXRlbWVudDtcbmV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmZ1bmN0aW9uRXhwcmVzc2lvbiA9IGZ1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuZnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA9IGZ1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmZ1bmN0aW9uVHlwZVBhcmFtID0gZnVuY3Rpb25UeXBlUGFyYW07XG5leHBvcnRzLmdlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGdlbmVyaWNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG5leHBvcnRzLmlmU3RhdGVtZW50ID0gaWZTdGF0ZW1lbnQ7XG5leHBvcnRzLmltcG9ydCA9IF9pbXBvcnQ7XG5leHBvcnRzLmltcG9ydEF0dHJpYnV0ZSA9IGltcG9ydEF0dHJpYnV0ZTtcbmV4cG9ydHMuaW1wb3J0RGVjbGFyYXRpb24gPSBpbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaW1wb3J0RGVmYXVsdFNwZWNpZmllciA9IGltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmltcG9ydEV4cHJlc3Npb24gPSBpbXBvcnRFeHByZXNzaW9uO1xuZXhwb3J0cy5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBpbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmltcG9ydFNwZWNpZmllciA9IGltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaW5kZXhlZEFjY2Vzc1R5cGUgPSBpbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMuaW5mZXJyZWRQcmVkaWNhdGUgPSBpbmZlcnJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuaW50ZXJmYWNlRGVjbGFyYXRpb24gPSBpbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaW50ZXJmYWNlRXh0ZW5kcyA9IGludGVyZmFjZUV4dGVuZHM7XG5leHBvcnRzLmludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gaW50ZXJmYWNlVHlwZUFubm90YXRpb247XG5leHBvcnRzLmludGVycHJldGVyRGlyZWN0aXZlID0gaW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uID0gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmpTWEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4QXR0cmlidXRlID0ganN4QXR0cmlidXRlO1xuZXhwb3J0cy5qU1hDbG9zaW5nRWxlbWVudCA9IGV4cG9ydHMuanN4Q2xvc2luZ0VsZW1lbnQgPSBqc3hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMualNYQ2xvc2luZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hDbG9zaW5nRnJhZ21lbnQgPSBqc3hDbG9zaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmpTWEVsZW1lbnQgPSBleHBvcnRzLmpzeEVsZW1lbnQgPSBqc3hFbGVtZW50O1xuZXhwb3J0cy5qU1hFbXB0eUV4cHJlc3Npb24gPSBleHBvcnRzLmpzeEVtcHR5RXhwcmVzc2lvbiA9IGpzeEVtcHR5RXhwcmVzc2lvbjtcbmV4cG9ydHMualNYRXhwcmVzc2lvbkNvbnRhaW5lciA9IGV4cG9ydHMuanN4RXhwcmVzc2lvbkNvbnRhaW5lciA9IGpzeEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmpTWEZyYWdtZW50ID0gZXhwb3J0cy5qc3hGcmFnbWVudCA9IGpzeEZyYWdtZW50O1xuZXhwb3J0cy5qU1hJZGVudGlmaWVyID0gZXhwb3J0cy5qc3hJZGVudGlmaWVyID0ganN4SWRlbnRpZmllcjtcbmV4cG9ydHMualNYTWVtYmVyRXhwcmVzc2lvbiA9IGV4cG9ydHMuanN4TWVtYmVyRXhwcmVzc2lvbiA9IGpzeE1lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmpTWE5hbWVzcGFjZWROYW1lID0gZXhwb3J0cy5qc3hOYW1lc3BhY2VkTmFtZSA9IGpzeE5hbWVzcGFjZWROYW1lO1xuZXhwb3J0cy5qU1hPcGVuaW5nRWxlbWVudCA9IGV4cG9ydHMuanN4T3BlbmluZ0VsZW1lbnQgPSBqc3hPcGVuaW5nRWxlbWVudDtcbmV4cG9ydHMualNYT3BlbmluZ0ZyYWdtZW50ID0gZXhwb3J0cy5qc3hPcGVuaW5nRnJhZ21lbnQgPSBqc3hPcGVuaW5nRnJhZ21lbnQ7XG5leHBvcnRzLmpTWFNwcmVhZEF0dHJpYnV0ZSA9IGV4cG9ydHMuanN4U3ByZWFkQXR0cmlidXRlID0ganN4U3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5qU1hTcHJlYWRDaGlsZCA9IGV4cG9ydHMuanN4U3ByZWFkQ2hpbGQgPSBqc3hTcHJlYWRDaGlsZDtcbmV4cG9ydHMualNYVGV4dCA9IGV4cG9ydHMuanN4VGV4dCA9IGpzeFRleHQ7XG5leHBvcnRzLmxhYmVsZWRTdGF0ZW1lbnQgPSBsYWJlbGVkU3RhdGVtZW50O1xuZXhwb3J0cy5sb2dpY2FsRXhwcmVzc2lvbiA9IGxvZ2ljYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5tZW1iZXJFeHByZXNzaW9uID0gbWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMubWV0YVByb3BlcnR5ID0gbWV0YVByb3BlcnR5O1xuZXhwb3J0cy5taXhlZFR5cGVBbm5vdGF0aW9uID0gbWl4ZWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMubW9kdWxlRXhwcmVzc2lvbiA9IG1vZHVsZUV4cHJlc3Npb247XG5leHBvcnRzLm5ld0V4cHJlc3Npb24gPSBuZXdFeHByZXNzaW9uO1xuZXhwb3J0cy5ub29wID0gbm9vcDtcbmV4cG9ydHMubnVsbExpdGVyYWwgPSBudWxsTGl0ZXJhbDtcbmV4cG9ydHMubnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IG51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLm51bGxhYmxlVHlwZUFubm90YXRpb24gPSBudWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1iZXJMaXRlcmFsID0gTnVtYmVyTGl0ZXJhbDtcbmV4cG9ydHMubnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gbnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1iZXJUeXBlQW5ub3RhdGlvbiA9IG51bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5udW1lcmljTGl0ZXJhbCA9IG51bWVyaWNMaXRlcmFsO1xuZXhwb3J0cy5vYmplY3RFeHByZXNzaW9uID0gb2JqZWN0RXhwcmVzc2lvbjtcbmV4cG9ydHMub2JqZWN0TWV0aG9kID0gb2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5vYmplY3RQYXR0ZXJuID0gb2JqZWN0UGF0dGVybjtcbmV4cG9ydHMub2JqZWN0UHJvcGVydHkgPSBvYmplY3RQcm9wZXJ0eTtcbmV4cG9ydHMub2JqZWN0VHlwZUFubm90YXRpb24gPSBvYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMub2JqZWN0VHlwZUNhbGxQcm9wZXJ0eSA9IG9iamVjdFR5cGVDYWxsUHJvcGVydHk7XG5leHBvcnRzLm9iamVjdFR5cGVJbmRleGVyID0gb2JqZWN0VHlwZUluZGV4ZXI7XG5leHBvcnRzLm9iamVjdFR5cGVJbnRlcm5hbFNsb3QgPSBvYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5vYmplY3RUeXBlUHJvcGVydHkgPSBvYmplY3RUeXBlUHJvcGVydHk7XG5leHBvcnRzLm9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbmV4cG9ydHMub3BhcXVlVHlwZSA9IG9wYXF1ZVR5cGU7XG5leHBvcnRzLm9wdGlvbmFsQ2FsbEV4cHJlc3Npb24gPSBvcHRpb25hbENhbGxFeHByZXNzaW9uO1xuZXhwb3J0cy5vcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gb3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbmV4cG9ydHMub3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uID0gb3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5wYXJlbnRoZXNpemVkRXhwcmVzc2lvbiA9IHBhcmVudGhlc2l6ZWRFeHByZXNzaW9uO1xuZXhwb3J0cy5waXBlbGluZUJhcmVGdW5jdGlvbiA9IHBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuZXhwb3J0cy5waXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZSA9IHBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5waXBlbGluZVRvcGljRXhwcmVzc2lvbiA9IHBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuZXhwb3J0cy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuZXhwb3J0cy5wcml2YXRlTmFtZSA9IHByaXZhdGVOYW1lO1xuZXhwb3J0cy5wcm9ncmFtID0gcHJvZ3JhbTtcbmV4cG9ydHMucXVhbGlmaWVkVHlwZUlkZW50aWZpZXIgPSBxdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbmV4cG9ydHMucmVjb3JkRXhwcmVzc2lvbiA9IHJlY29yZEV4cHJlc3Npb247XG5leHBvcnRzLnJlZ0V4cExpdGVyYWwgPSByZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5yZWdleExpdGVyYWwgPSBSZWdleExpdGVyYWw7XG5leHBvcnRzLnJlc3RFbGVtZW50ID0gcmVzdEVsZW1lbnQ7XG5leHBvcnRzLnJlc3RQcm9wZXJ0eSA9IFJlc3RQcm9wZXJ0eTtcbmV4cG9ydHMucmV0dXJuU3RhdGVtZW50ID0gcmV0dXJuU3RhdGVtZW50O1xuZXhwb3J0cy5zZXF1ZW5jZUV4cHJlc3Npb24gPSBzZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLnNwcmVhZEVsZW1lbnQgPSBzcHJlYWRFbGVtZW50O1xuZXhwb3J0cy5zcHJlYWRQcm9wZXJ0eSA9IFNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5zdGF0aWNCbG9jayA9IHN0YXRpY0Jsb2NrO1xuZXhwb3J0cy5zdHJpbmdMaXRlcmFsID0gc3RyaW5nTGl0ZXJhbDtcbmV4cG9ydHMuc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5zdHJpbmdUeXBlQW5ub3RhdGlvbiA9IHN0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5zdXBlciA9IF9zdXBlcjtcbmV4cG9ydHMuc3dpdGNoQ2FzZSA9IHN3aXRjaENhc2U7XG5leHBvcnRzLnN3aXRjaFN0YXRlbWVudCA9IHN3aXRjaFN0YXRlbWVudDtcbmV4cG9ydHMuc3ltYm9sVHlwZUFubm90YXRpb24gPSBzeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uID0gdGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy50ZW1wbGF0ZUVsZW1lbnQgPSB0ZW1wbGF0ZUVsZW1lbnQ7XG5leHBvcnRzLnRlbXBsYXRlTGl0ZXJhbCA9IHRlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMudGhpc0V4cHJlc3Npb24gPSB0aGlzRXhwcmVzc2lvbjtcbmV4cG9ydHMudGhpc1R5cGVBbm5vdGF0aW9uID0gdGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50aHJvd1N0YXRlbWVudCA9IHRocm93U3RhdGVtZW50O1xuZXhwb3J0cy50b3BpY1JlZmVyZW5jZSA9IHRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy50cnlTdGF0ZW1lbnQgPSB0cnlTdGF0ZW1lbnQ7XG5leHBvcnRzLnRTQW55S2V5d29yZCA9IGV4cG9ydHMudHNBbnlLZXl3b3JkID0gdHNBbnlLZXl3b3JkO1xuZXhwb3J0cy50U0FycmF5VHlwZSA9IGV4cG9ydHMudHNBcnJheVR5cGUgPSB0c0FycmF5VHlwZTtcbmV4cG9ydHMudFNBc0V4cHJlc3Npb24gPSBleHBvcnRzLnRzQXNFeHByZXNzaW9uID0gdHNBc0V4cHJlc3Npb247XG5leHBvcnRzLnRTQmlnSW50S2V5d29yZCA9IGV4cG9ydHMudHNCaWdJbnRLZXl3b3JkID0gdHNCaWdJbnRLZXl3b3JkO1xuZXhwb3J0cy50U0Jvb2xlYW5LZXl3b3JkID0gZXhwb3J0cy50c0Jvb2xlYW5LZXl3b3JkID0gdHNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMudFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLnRTQ29uZGl0aW9uYWxUeXBlID0gZXhwb3J0cy50c0NvbmRpdGlvbmFsVHlwZSA9IHRzQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy50U0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uID0gdHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNDb25zdHJ1Y3RvclR5cGUgPSBleHBvcnRzLnRzQ29uc3RydWN0b3JUeXBlID0gdHNDb25zdHJ1Y3RvclR5cGU7XG5leHBvcnRzLnRTRGVjbGFyZUZ1bmN0aW9uID0gZXhwb3J0cy50c0RlY2xhcmVGdW5jdGlvbiA9IHRzRGVjbGFyZUZ1bmN0aW9uO1xuZXhwb3J0cy50U0RlY2xhcmVNZXRob2QgPSBleHBvcnRzLnRzRGVjbGFyZU1ldGhvZCA9IHRzRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMudFNFbnVtRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzRW51bURlY2xhcmF0aW9uID0gdHNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLnRTRW51bU1lbWJlciA9IGV4cG9ydHMudHNFbnVtTWVtYmVyID0gdHNFbnVtTWVtYmVyO1xuZXhwb3J0cy50U0V4cG9ydEFzc2lnbm1lbnQgPSBleHBvcnRzLnRzRXhwb3J0QXNzaWdubWVudCA9IHRzRXhwb3J0QXNzaWdubWVudDtcbmV4cG9ydHMudFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBleHBvcnRzLnRzRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0gdHNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG5leHBvcnRzLnRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBleHBvcnRzLnRzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSB0c0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlO1xuZXhwb3J0cy50U0Z1bmN0aW9uVHlwZSA9IGV4cG9ydHMudHNGdW5jdGlvblR5cGUgPSB0c0Z1bmN0aW9uVHlwZTtcbmV4cG9ydHMudFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbiA9IHRzSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLnRTSW1wb3J0VHlwZSA9IGV4cG9ydHMudHNJbXBvcnRUeXBlID0gdHNJbXBvcnRUeXBlO1xuZXhwb3J0cy50U0luZGV4U2lnbmF0dXJlID0gZXhwb3J0cy50c0luZGV4U2lnbmF0dXJlID0gdHNJbmRleFNpZ25hdHVyZTtcbmV4cG9ydHMudFNJbmRleGVkQWNjZXNzVHlwZSA9IGV4cG9ydHMudHNJbmRleGVkQWNjZXNzVHlwZSA9IHRzSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLnRTSW5mZXJUeXBlID0gZXhwb3J0cy50c0luZmVyVHlwZSA9IHRzSW5mZXJUeXBlO1xuZXhwb3J0cy50U0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gZXhwb3J0cy50c0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gdHNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMudFNJbnRlcmZhY2VCb2R5ID0gZXhwb3J0cy50c0ludGVyZmFjZUJvZHkgPSB0c0ludGVyZmFjZUJvZHk7XG5leHBvcnRzLnRTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzSW50ZXJmYWNlRGVjbGFyYXRpb24gPSB0c0ludGVyZmFjZURlY2xhcmF0aW9uO1xuZXhwb3J0cy50U0ludGVyc2VjdGlvblR5cGUgPSBleHBvcnRzLnRzSW50ZXJzZWN0aW9uVHlwZSA9IHRzSW50ZXJzZWN0aW9uVHlwZTtcbmV4cG9ydHMudFNJbnRyaW5zaWNLZXl3b3JkID0gZXhwb3J0cy50c0ludHJpbnNpY0tleXdvcmQgPSB0c0ludHJpbnNpY0tleXdvcmQ7XG5leHBvcnRzLnRTTGl0ZXJhbFR5cGUgPSBleHBvcnRzLnRzTGl0ZXJhbFR5cGUgPSB0c0xpdGVyYWxUeXBlO1xuZXhwb3J0cy50U01hcHBlZFR5cGUgPSBleHBvcnRzLnRzTWFwcGVkVHlwZSA9IHRzTWFwcGVkVHlwZTtcbmV4cG9ydHMudFNNZXRob2RTaWduYXR1cmUgPSBleHBvcnRzLnRzTWV0aG9kU2lnbmF0dXJlID0gdHNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLnRTTW9kdWxlQmxvY2sgPSBleHBvcnRzLnRzTW9kdWxlQmxvY2sgPSB0c01vZHVsZUJsb2NrO1xuZXhwb3J0cy50U01vZHVsZURlY2xhcmF0aW9uID0gZXhwb3J0cy50c01vZHVsZURlY2xhcmF0aW9uID0gdHNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMudFNOYW1lZFR1cGxlTWVtYmVyID0gZXhwb3J0cy50c05hbWVkVHVwbGVNZW1iZXIgPSB0c05hbWVkVHVwbGVNZW1iZXI7XG5leHBvcnRzLnRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBleHBvcnRzLnRzTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSB0c05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy50U05ldmVyS2V5d29yZCA9IGV4cG9ydHMudHNOZXZlcktleXdvcmQgPSB0c05ldmVyS2V5d29yZDtcbmV4cG9ydHMudFNOb25OdWxsRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNOb25OdWxsRXhwcmVzc2lvbiA9IHRzTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLnRTTnVsbEtleXdvcmQgPSBleHBvcnRzLnRzTnVsbEtleXdvcmQgPSB0c051bGxLZXl3b3JkO1xuZXhwb3J0cy50U051bWJlcktleXdvcmQgPSBleHBvcnRzLnRzTnVtYmVyS2V5d29yZCA9IHRzTnVtYmVyS2V5d29yZDtcbmV4cG9ydHMudFNPYmplY3RLZXl3b3JkID0gZXhwb3J0cy50c09iamVjdEtleXdvcmQgPSB0c09iamVjdEtleXdvcmQ7XG5leHBvcnRzLnRTT3B0aW9uYWxUeXBlID0gZXhwb3J0cy50c09wdGlvbmFsVHlwZSA9IHRzT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy50U1BhcmFtZXRlclByb3BlcnR5ID0gZXhwb3J0cy50c1BhcmFtZXRlclByb3BlcnR5ID0gdHNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMudFNQYXJlbnRoZXNpemVkVHlwZSA9IGV4cG9ydHMudHNQYXJlbnRoZXNpemVkVHlwZSA9IHRzUGFyZW50aGVzaXplZFR5cGU7XG5leHBvcnRzLnRTUHJvcGVydHlTaWduYXR1cmUgPSBleHBvcnRzLnRzUHJvcGVydHlTaWduYXR1cmUgPSB0c1Byb3BlcnR5U2lnbmF0dXJlO1xuZXhwb3J0cy50U1F1YWxpZmllZE5hbWUgPSBleHBvcnRzLnRzUXVhbGlmaWVkTmFtZSA9IHRzUXVhbGlmaWVkTmFtZTtcbmV4cG9ydHMudFNSZXN0VHlwZSA9IGV4cG9ydHMudHNSZXN0VHlwZSA9IHRzUmVzdFR5cGU7XG5leHBvcnRzLnRTU2F0aXNmaWVzRXhwcmVzc2lvbiA9IGV4cG9ydHMudHNTYXRpc2ZpZXNFeHByZXNzaW9uID0gdHNTYXRpc2ZpZXNFeHByZXNzaW9uO1xuZXhwb3J0cy50U1N0cmluZ0tleXdvcmQgPSBleHBvcnRzLnRzU3RyaW5nS2V5d29yZCA9IHRzU3RyaW5nS2V5d29yZDtcbmV4cG9ydHMudFNTeW1ib2xLZXl3b3JkID0gZXhwb3J0cy50c1N5bWJvbEtleXdvcmQgPSB0c1N5bWJvbEtleXdvcmQ7XG5leHBvcnRzLnRTVGhpc1R5cGUgPSBleHBvcnRzLnRzVGhpc1R5cGUgPSB0c1RoaXNUeXBlO1xuZXhwb3J0cy50U1R1cGxlVHlwZSA9IGV4cG9ydHMudHNUdXBsZVR5cGUgPSB0c1R1cGxlVHlwZTtcbmV4cG9ydHMudFNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IGV4cG9ydHMudHNUeXBlQWxpYXNEZWNsYXJhdGlvbiA9IHRzVHlwZUFsaWFzRGVjbGFyYXRpb247XG5leHBvcnRzLnRTVHlwZUFubm90YXRpb24gPSBleHBvcnRzLnRzVHlwZUFubm90YXRpb24gPSB0c1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50U1R5cGVBc3NlcnRpb24gPSBleHBvcnRzLnRzVHlwZUFzc2VydGlvbiA9IHRzVHlwZUFzc2VydGlvbjtcbmV4cG9ydHMudFNUeXBlTGl0ZXJhbCA9IGV4cG9ydHMudHNUeXBlTGl0ZXJhbCA9IHRzVHlwZUxpdGVyYWw7XG5leHBvcnRzLnRTVHlwZU9wZXJhdG9yID0gZXhwb3J0cy50c1R5cGVPcGVyYXRvciA9IHRzVHlwZU9wZXJhdG9yO1xuZXhwb3J0cy50U1R5cGVQYXJhbWV0ZXIgPSBleHBvcnRzLnRzVHlwZVBhcmFtZXRlciA9IHRzVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMudFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBleHBvcnRzLnRzVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uID0gdHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLnRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSBleHBvcnRzLnRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24gPSB0c1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuZXhwb3J0cy50U1R5cGVQcmVkaWNhdGUgPSBleHBvcnRzLnRzVHlwZVByZWRpY2F0ZSA9IHRzVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMudFNUeXBlUXVlcnkgPSBleHBvcnRzLnRzVHlwZVF1ZXJ5ID0gdHNUeXBlUXVlcnk7XG5leHBvcnRzLnRTVHlwZVJlZmVyZW5jZSA9IGV4cG9ydHMudHNUeXBlUmVmZXJlbmNlID0gdHNUeXBlUmVmZXJlbmNlO1xuZXhwb3J0cy50U1VuZGVmaW5lZEtleXdvcmQgPSBleHBvcnRzLnRzVW5kZWZpbmVkS2V5d29yZCA9IHRzVW5kZWZpbmVkS2V5d29yZDtcbmV4cG9ydHMudFNVbmlvblR5cGUgPSBleHBvcnRzLnRzVW5pb25UeXBlID0gdHNVbmlvblR5cGU7XG5leHBvcnRzLnRTVW5rbm93bktleXdvcmQgPSBleHBvcnRzLnRzVW5rbm93bktleXdvcmQgPSB0c1Vua25vd25LZXl3b3JkO1xuZXhwb3J0cy50U1ZvaWRLZXl3b3JkID0gZXhwb3J0cy50c1ZvaWRLZXl3b3JkID0gdHNWb2lkS2V5d29yZDtcbmV4cG9ydHMudHVwbGVFeHByZXNzaW9uID0gdHVwbGVFeHByZXNzaW9uO1xuZXhwb3J0cy50dXBsZVR5cGVBbm5vdGF0aW9uID0gdHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMudHlwZUFsaWFzID0gdHlwZUFsaWFzO1xuZXhwb3J0cy50eXBlQW5ub3RhdGlvbiA9IHR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy50eXBlQ2FzdEV4cHJlc3Npb24gPSB0eXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLnR5cGVQYXJhbWV0ZXIgPSB0eXBlUGFyYW1ldGVyO1xuZXhwb3J0cy50eXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSB0eXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLnR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uID0gdHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLnR5cGVvZlR5cGVBbm5vdGF0aW9uID0gdHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLnVuYXJ5RXhwcmVzc2lvbiA9IHVuYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMudW5pb25UeXBlQW5ub3RhdGlvbiA9IHVuaW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLnVwZGF0ZUV4cHJlc3Npb24gPSB1cGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy52OEludHJpbnNpY0lkZW50aWZpZXIgPSB2OEludHJpbnNpY0lkZW50aWZpZXI7XG5leHBvcnRzLnZhcmlhYmxlRGVjbGFyYXRpb24gPSB2YXJpYWJsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy52YXJpYWJsZURlY2xhcmF0b3IgPSB2YXJpYWJsZURlY2xhcmF0b3I7XG5leHBvcnRzLnZhcmlhbmNlID0gdmFyaWFuY2U7XG5leHBvcnRzLnZvaWRUeXBlQW5ub3RhdGlvbiA9IHZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMud2hpbGVTdGF0ZW1lbnQgPSB3aGlsZVN0YXRlbWVudDtcbmV4cG9ydHMud2l0aFN0YXRlbWVudCA9IHdpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLnlpZWxkRXhwcmVzc2lvbiA9IHlpZWxkRXhwcmVzc2lvbjtcbnZhciBfdmFsaWRhdGUgPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy92YWxpZGF0ZS5qc1wiKTtcbnZhciBfZGVwcmVjYXRpb25XYXJuaW5nID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL2RlcHJlY2F0aW9uV2FybmluZy5qc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuLi8uLi9kZWZpbml0aW9ucy91dGlscy5qc1wiKTtcbmNvbnN0IHtcbiAgdmFsaWRhdGVJbnRlcm5hbDogdmFsaWRhdGVcbn0gPSBfdmFsaWRhdGU7XG5jb25zdCB7XG4gIE5PREVfRklFTERTXG59ID0gdXRpbHM7XG5mdW5jdGlvbiBhcnJheUV4cHJlc3Npb24oZWxlbWVudHMgPSBbXSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQXJyYXlFeHByZXNzaW9uXCIsXG4gICAgZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFycmF5RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5lbGVtZW50cywgbm9kZSwgXCJlbGVtZW50c1wiLCBlbGVtZW50cywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYXNzaWdubWVudEV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGxlZnQsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFzc2lnbm1lbnRFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9wZXJhdG9yLCBub2RlLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGJpbmFyeUV4cHJlc3Npb24ob3BlcmF0b3IsIGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJCaW5hcnlFeHByZXNzaW9uXCIsXG4gICAgb3BlcmF0b3IsXG4gICAgbGVmdCxcbiAgICByaWdodFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQmluYXJ5RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbnRlcnByZXRlckRpcmVjdGl2ZSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRpcmVjdGl2ZSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGlyZWN0aXZlXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRpcmVjdGl2ZTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGlyZWN0aXZlTGl0ZXJhbCh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGlyZWN0aXZlTGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EaXJlY3RpdmVMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBibG9ja1N0YXRlbWVudChib2R5LCBkaXJlY3RpdmVzID0gW10pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkJsb2NrU3RhdGVtZW50XCIsXG4gICAgYm9keSxcbiAgICBkaXJlY3RpdmVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5CbG9ja1N0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGlyZWN0aXZlcywgbm9kZSwgXCJkaXJlY3RpdmVzXCIsIGRpcmVjdGl2ZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGJyZWFrU3RhdGVtZW50KGxhYmVsID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQnJlYWtTdGF0ZW1lbnRcIixcbiAgICBsYWJlbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQnJlYWtTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubGFiZWwsIG5vZGUsIFwibGFiZWxcIiwgbGFiZWwsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNhbGxFeHByZXNzaW9uKGNhbGxlZSwgX2FyZ3VtZW50cykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2FsbEV4cHJlc3Npb25cIixcbiAgICBjYWxsZWUsXG4gICAgYXJndW1lbnRzOiBfYXJndW1lbnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5DYWxsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsZWUsIG5vZGUsIFwiY2FsbGVlXCIsIGNhbGxlZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnRzLCBub2RlLCBcImFyZ3VtZW50c1wiLCBfYXJndW1lbnRzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjYXRjaENsYXVzZShwYXJhbSA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNhdGNoQ2xhdXNlXCIsXG4gICAgcGFyYW0sXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2F0Y2hDbGF1c2U7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW0sIG5vZGUsIFwicGFyYW1cIiwgcGFyYW0sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixcbiAgICB0ZXN0LFxuICAgIGNvbnNlcXVlbnQsXG4gICAgYWx0ZXJuYXRlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Db25kaXRpb25hbEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbnNlcXVlbnQsIG5vZGUsIFwiY29uc2VxdWVudFwiLCBjb25zZXF1ZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hbHRlcm5hdGUsIG5vZGUsIFwiYWx0ZXJuYXRlXCIsIGFsdGVybmF0ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29udGludWVTdGF0ZW1lbnQobGFiZWwgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDb250aW51ZVN0YXRlbWVudFwiLFxuICAgIGxhYmVsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Db250aW51ZVN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sYWJlbCwgbm9kZSwgXCJsYWJlbFwiLCBsYWJlbCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVidWdnZXJTdGF0ZW1lbnQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJEZWJ1Z2dlclN0YXRlbWVudFwiXG4gIH07XG59XG5mdW5jdGlvbiBkb1doaWxlU3RhdGVtZW50KHRlc3QsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRvV2hpbGVTdGF0ZW1lbnRcIixcbiAgICB0ZXN0LFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRvV2hpbGVTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbXB0eVN0YXRlbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkVtcHR5U3RhdGVtZW50XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4cHJlc3Npb25TdGF0ZW1lbnQoZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRXhwcmVzc2lvblN0YXRlbWVudFwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbGUocHJvZ3JhbSwgY29tbWVudHMgPSBudWxsLCB0b2tlbnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGaWxlXCIsXG4gICAgcHJvZ3JhbSxcbiAgICBjb21tZW50cyxcbiAgICB0b2tlbnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZpbGU7XG4gIHZhbGlkYXRlKGRlZnMucHJvZ3JhbSwgbm9kZSwgXCJwcm9ncmFtXCIsIHByb2dyYW0sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbW1lbnRzLCBub2RlLCBcImNvbW1lbnRzXCIsIGNvbW1lbnRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50b2tlbnMsIG5vZGUsIFwidG9rZW5zXCIsIHRva2Vucyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZm9ySW5TdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZvckluU3RhdGVtZW50XCIsXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Gb3JJblN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmb3JTdGF0ZW1lbnQoaW5pdCA9IG51bGwsIHRlc3QgPSBudWxsLCB1cGRhdGUgPSBudWxsLCBib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIixcbiAgICBpbml0LFxuICAgIHRlc3QsXG4gICAgdXBkYXRlLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZvclN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5pbml0LCBub2RlLCBcImluaXRcIiwgaW5pdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnVwZGF0ZSwgbm9kZSwgXCJ1cGRhdGVcIiwgdXBkYXRlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvbihpZCA9IG51bGwsIHBhcmFtcywgYm9keSwgZ2VuZXJhdG9yID0gZmFsc2UsIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcbiAgICBpZCxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZ1bmN0aW9uRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZ2VuZXJhdG9yLCBub2RlLCBcImdlbmVyYXRvclwiLCBnZW5lcmF0b3IpO1xuICB2YWxpZGF0ZShkZWZzLmFzeW5jLCBub2RlLCBcImFzeW5jXCIsIGFzeW5jKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkV4cHJlc3Npb24oaWQgPSBudWxsLCBwYXJhbXMsIGJvZHksIGdlbmVyYXRvciA9IGZhbHNlLCBhc3luYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcbiAgICBpZCxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkZ1bmN0aW9uRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5nZW5lcmF0b3IsIG5vZGUsIFwiZ2VuZXJhdG9yXCIsIGdlbmVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMuYXN5bmMsIG5vZGUsIFwiYXN5bmNcIiwgYXN5bmMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGlkZW50aWZpZXIobmFtZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSWRlbnRpZmllclwiLFxuICAgIG5hbWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLklkZW50aWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGlmU3RhdGVtZW50KHRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIklmU3RhdGVtZW50XCIsXG4gICAgdGVzdCxcbiAgICBjb25zZXF1ZW50LFxuICAgIGFsdGVybmF0ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSWZTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMudGVzdCwgbm9kZSwgXCJ0ZXN0XCIsIHRlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbnNlcXVlbnQsIG5vZGUsIFwiY29uc2VxdWVudFwiLCBjb25zZXF1ZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hbHRlcm5hdGUsIG5vZGUsIFwiYWx0ZXJuYXRlXCIsIGFsdGVybmF0ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbGFiZWxlZFN0YXRlbWVudChsYWJlbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTGFiZWxlZFN0YXRlbWVudFwiLFxuICAgIGxhYmVsLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkxhYmVsZWRTdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubGFiZWwsIG5vZGUsIFwibGFiZWxcIiwgbGFiZWwsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJTdHJpbmdMaXRlcmFsXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlN0cmluZ0xpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJOdW1lcmljTGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OdW1lcmljTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbnVsbExpdGVyYWwoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJOdWxsTGl0ZXJhbFwiXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQm9vbGVhbkxpdGVyYWxcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQm9vbGVhbkxpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJlZ0V4cExpdGVyYWwocGF0dGVybiwgZmxhZ3MgPSBcIlwiKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJSZWdFeHBMaXRlcmFsXCIsXG4gICAgcGF0dGVybixcbiAgICBmbGFnc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUmVnRXhwTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy5wYXR0ZXJuLCBub2RlLCBcInBhdHRlcm5cIiwgcGF0dGVybik7XG4gIHZhbGlkYXRlKGRlZnMuZmxhZ3MsIG5vZGUsIFwiZmxhZ3NcIiwgZmxhZ3MpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGxvZ2ljYWxFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTG9naWNhbEV4cHJlc3Npb25cIixcbiAgICBvcGVyYXRvcixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Mb2dpY2FsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHksIGNvbXB1dGVkID0gZmFsc2UsIG9wdGlvbmFsID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTWVtYmVyRXhwcmVzc2lvblwiLFxuICAgIG9iamVjdCxcbiAgICBwcm9wZXJ0eSxcbiAgICBjb21wdXRlZCxcbiAgICBvcHRpb25hbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuTWVtYmVyRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydHksIG5vZGUsIFwicHJvcGVydHlcIiwgcHJvcGVydHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbmV3RXhwcmVzc2lvbihjYWxsZWUsIF9hcmd1bWVudHMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk5ld0V4cHJlc3Npb25cIixcbiAgICBjYWxsZWUsXG4gICAgYXJndW1lbnRzOiBfYXJndW1lbnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5OZXdFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmNhbGxlZSwgbm9kZSwgXCJjYWxsZWVcIiwgY2FsbGVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudHMsIG5vZGUsIFwiYXJndW1lbnRzXCIsIF9hcmd1bWVudHMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHByb2dyYW0oYm9keSwgZGlyZWN0aXZlcyA9IFtdLCBzb3VyY2VUeXBlID0gXCJzY3JpcHRcIiwgaW50ZXJwcmV0ZXIgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQcm9ncmFtXCIsXG4gICAgYm9keSxcbiAgICBkaXJlY3RpdmVzLFxuICAgIHNvdXJjZVR5cGUsXG4gICAgaW50ZXJwcmV0ZXJcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlByb2dyYW07XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRpcmVjdGl2ZXMsIG5vZGUsIFwiZGlyZWN0aXZlc1wiLCBkaXJlY3RpdmVzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zb3VyY2VUeXBlLCBub2RlLCBcInNvdXJjZVR5cGVcIiwgc291cmNlVHlwZSk7XG4gIHZhbGlkYXRlKGRlZnMuaW50ZXJwcmV0ZXIsIG5vZGUsIFwiaW50ZXJwcmV0ZXJcIiwgaW50ZXJwcmV0ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0RXhwcmVzc2lvblwiLFxuICAgIHByb3BlcnRpZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdEV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydGllcywgbm9kZSwgXCJwcm9wZXJ0aWVzXCIsIHByb3BlcnRpZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdE1ldGhvZChraW5kID0gXCJtZXRob2RcIiwga2V5LCBwYXJhbXMsIGJvZHksIGNvbXB1dGVkID0gZmFsc2UsIGdlbmVyYXRvciA9IGZhbHNlLCBhc3luYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RNZXRob2RcIixcbiAgICBraW5kLFxuICAgIGtleSxcbiAgICBwYXJhbXMsXG4gICAgYm9keSxcbiAgICBjb21wdXRlZCxcbiAgICBnZW5lcmF0b3IsXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdE1ldGhvZDtcbiAgdmFsaWRhdGUoZGVmcy5raW5kLCBub2RlLCBcImtpbmRcIiwga2luZCk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY29tcHV0ZWQsIG5vZGUsIFwiY29tcHV0ZWRcIiwgY29tcHV0ZWQpO1xuICB2YWxpZGF0ZShkZWZzLmdlbmVyYXRvciwgbm9kZSwgXCJnZW5lcmF0b3JcIiwgZ2VuZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0UHJvcGVydHkoa2V5LCB2YWx1ZSwgY29tcHV0ZWQgPSBmYWxzZSwgc2hvcnRoYW5kID0gZmFsc2UsIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBjb21wdXRlZCxcbiAgICBzaG9ydGhhbmQsXG4gICAgZGVjb3JhdG9yc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0UHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jb21wdXRlZCwgbm9kZSwgXCJjb21wdXRlZFwiLCBjb21wdXRlZCk7XG4gIHZhbGlkYXRlKGRlZnMuc2hvcnRoYW5kLCBub2RlLCBcInNob3J0aGFuZFwiLCBzaG9ydGhhbmQpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiByZXN0RWxlbWVudChhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUmVzdEVsZW1lbnRcIixcbiAgICBhcmd1bWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUmVzdEVsZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHJldHVyblN0YXRlbWVudChhcmd1bWVudCA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlJldHVyblN0YXRlbWVudFwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5SZXR1cm5TdGF0ZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNlcXVlbmNlRXhwcmVzc2lvbihleHByZXNzaW9ucykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvbnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlNlcXVlbmNlRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9ucywgbm9kZSwgXCJleHByZXNzaW9uc1wiLCBleHByZXNzaW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIixcbiAgICBleHByZXNzaW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5QYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3dpdGNoQ2FzZSh0ZXN0ID0gbnVsbCwgY29uc2VxdWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU3dpdGNoQ2FzZVwiLFxuICAgIHRlc3QsXG4gICAgY29uc2VxdWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuU3dpdGNoQ2FzZTtcbiAgdmFsaWRhdGUoZGVmcy50ZXN0LCBub2RlLCBcInRlc3RcIiwgdGVzdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY29uc2VxdWVudCwgbm9kZSwgXCJjb25zZXF1ZW50XCIsIGNvbnNlcXVlbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaFN0YXRlbWVudChkaXNjcmltaW5hbnQsIGNhc2VzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJTd2l0Y2hTdGF0ZW1lbnRcIixcbiAgICBkaXNjcmltaW5hbnQsXG4gICAgY2FzZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlN3aXRjaFN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5kaXNjcmltaW5hbnQsIG5vZGUsIFwiZGlzY3JpbWluYW50XCIsIGRpc2NyaW1pbmFudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2FzZXMsIG5vZGUsIFwiY2FzZXNcIiwgY2FzZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRoaXNFeHByZXNzaW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVGhpc0V4cHJlc3Npb25cIlxuICB9O1xufVxuZnVuY3Rpb24gdGhyb3dTdGF0ZW1lbnQoYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRocm93U3RhdGVtZW50XCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRocm93U3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0cnlTdGF0ZW1lbnQoYmxvY2ssIGhhbmRsZXIgPSBudWxsLCBmaW5hbGl6ZXIgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUcnlTdGF0ZW1lbnRcIixcbiAgICBibG9jayxcbiAgICBoYW5kbGVyLFxuICAgIGZpbmFsaXplclxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHJ5U3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmJsb2NrLCBub2RlLCBcImJsb2NrXCIsIGJsb2NrLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5oYW5kbGVyLCBub2RlLCBcImhhbmRsZXJcIiwgaGFuZGxlciwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZmluYWxpemVyLCBub2RlLCBcImZpbmFsaXplclwiLCBmaW5hbGl6ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQsIHByZWZpeCA9IHRydWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlVuYXJ5RXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGFyZ3VtZW50LFxuICAgIHByZWZpeFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVW5hcnlFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9wZXJhdG9yLCBub2RlLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJlZml4LCBub2RlLCBcInByZWZpeFwiLCBwcmVmaXgpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUV4cHJlc3Npb24ob3BlcmF0b3IsIGFyZ3VtZW50LCBwcmVmaXggPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVXBkYXRlRXhwcmVzc2lvblwiLFxuICAgIG9wZXJhdG9yLFxuICAgIGFyZ3VtZW50LFxuICAgIHByZWZpeFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVXBkYXRlRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vcGVyYXRvciwgbm9kZSwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcik7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnByZWZpeCwgbm9kZSwgXCJwcmVmaXhcIiwgcHJlZml4KTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB2YXJpYWJsZURlY2xhcmF0aW9uKGtpbmQsIGRlY2xhcmF0aW9ucykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLFxuICAgIGtpbmQsXG4gICAgZGVjbGFyYXRpb25zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5WYXJpYWJsZURlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmtpbmQsIG5vZGUsIFwia2luZFwiLCBraW5kKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWNsYXJhdGlvbnMsIG5vZGUsIFwiZGVjbGFyYXRpb25zXCIsIGRlY2xhcmF0aW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdmFyaWFibGVEZWNsYXJhdG9yKGlkLCBpbml0ID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsXG4gICAgaWQsXG4gICAgaW5pdFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVmFyaWFibGVEZWNsYXJhdG9yO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbml0LCBub2RlLCBcImluaXRcIiwgaW5pdCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gd2hpbGVTdGF0ZW1lbnQodGVzdCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiV2hpbGVTdGF0ZW1lbnRcIixcbiAgICB0ZXN0LFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLldoaWxlU3RhdGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLnRlc3QsIG5vZGUsIFwidGVzdFwiLCB0ZXN0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gd2l0aFN0YXRlbWVudChvYmplY3QsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIldpdGhTdGF0ZW1lbnRcIixcbiAgICBvYmplY3QsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuV2l0aFN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFzc2lnbm1lbnRQYXR0ZXJuKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBc3NpZ25tZW50UGF0dGVyblwiLFxuICAgIGxlZnQsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFzc2lnbm1lbnRQYXR0ZXJuO1xuICB2YWxpZGF0ZShkZWZzLmxlZnQsIG5vZGUsIFwibGVmdFwiLCBsZWZ0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yaWdodCwgbm9kZSwgXCJyaWdodFwiLCByaWdodCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYXJyYXlQYXR0ZXJuKGVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBcnJheVBhdHRlcm5cIixcbiAgICBlbGVtZW50c1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQXJyYXlQYXR0ZXJuO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRzLCBub2RlLCBcImVsZW1lbnRzXCIsIGVsZW1lbnRzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihwYXJhbXMsIGJvZHksIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsXG4gICAgcGFyYW1zLFxuICAgIGJvZHksXG4gICAgYXN5bmMsXG4gICAgZXhwcmVzc2lvbjogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQXJyb3dGdW5jdGlvbkV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NCb2R5KGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzQm9keVwiLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzQm9keTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NFeHByZXNzaW9uKGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGJvZHksIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc0V4cHJlc3Npb25cIixcbiAgICBpZCxcbiAgICBzdXBlckNsYXNzLFxuICAgIGJvZHksXG4gICAgZGVjb3JhdG9yc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zdXBlckNsYXNzLCBub2RlLCBcInN1cGVyQ2xhc3NcIiwgc3VwZXJDbGFzcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc0RlY2xhcmF0aW9uKGlkID0gbnVsbCwgc3VwZXJDbGFzcyA9IG51bGwsIGJvZHksIGRlY29yYXRvcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgc3VwZXJDbGFzcyxcbiAgICBib2R5LFxuICAgIGRlY29yYXRvcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkNsYXNzRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnN1cGVyQ2xhc3MsIG5vZGUsIFwic3VwZXJDbGFzc1wiLCBzdXBlckNsYXNzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVjb3JhdG9ycywgbm9kZSwgXCJkZWNvcmF0b3JzXCIsIGRlY29yYXRvcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIixcbiAgICBzb3VyY2VcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleHBvcnREZWZhdWx0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLFxuICAgIGRlY2xhcmF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FeHBvcnREZWZhdWx0RGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuZGVjbGFyYXRpb24sIG5vZGUsIFwiZGVjbGFyYXRpb25cIiwgZGVjbGFyYXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5hbWVkRGVjbGFyYXRpb24oZGVjbGFyYXRpb24gPSBudWxsLCBzcGVjaWZpZXJzID0gW10sIHNvdXJjZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIixcbiAgICBkZWNsYXJhdGlvbixcbiAgICBzcGVjaWZpZXJzLFxuICAgIHNvdXJjZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5kZWNsYXJhdGlvbiwgbm9kZSwgXCJkZWNsYXJhdGlvblwiLCBkZWNsYXJhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3BlY2lmaWVycywgbm9kZSwgXCJzcGVjaWZpZXJzXCIsIHNwZWNpZmllcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBleHBvcnRTcGVjaWZpZXIobG9jYWwsIGV4cG9ydGVkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFeHBvcnRTcGVjaWZpZXJcIixcbiAgICBsb2NhbCxcbiAgICBleHBvcnRlZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRXhwb3J0U3BlY2lmaWVyO1xuICB2YWxpZGF0ZShkZWZzLmxvY2FsLCBub2RlLCBcImxvY2FsXCIsIGxvY2FsLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHBvcnRlZCwgbm9kZSwgXCJleHBvcnRlZFwiLCBleHBvcnRlZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZm9yT2ZTdGF0ZW1lbnQobGVmdCwgcmlnaHQsIGJvZHksIF9hd2FpdCA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJGb3JPZlN0YXRlbWVudFwiLFxuICAgIGxlZnQsXG4gICAgcmlnaHQsXG4gICAgYm9keSxcbiAgICBhd2FpdDogX2F3YWl0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Gb3JPZlN0YXRlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5sZWZ0LCBub2RlLCBcImxlZnRcIiwgbGVmdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmlnaHQsIG5vZGUsIFwicmlnaHRcIiwgcmlnaHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hd2FpdCwgbm9kZSwgXCJhd2FpdFwiLCBfYXdhaXQpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydERlY2xhcmF0aW9uKHNwZWNpZmllcnMsIHNvdXJjZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0RGVjbGFyYXRpb25cIixcbiAgICBzcGVjaWZpZXJzLFxuICAgIHNvdXJjZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW1wb3J0RGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuc3BlY2lmaWVycywgbm9kZSwgXCJzcGVjaWZpZXJzXCIsIHNwZWNpZmllcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbXBvcnREZWZhdWx0U3BlY2lmaWVyKGxvY2FsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsXG4gICAgbG9jYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydERlZmF1bHRTcGVjaWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubG9jYWwsIG5vZGUsIFwibG9jYWxcIiwgbG9jYWwsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydE5hbWVzcGFjZVNwZWNpZmllcihsb2NhbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXG4gICAgbG9jYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5sb2NhbCwgbm9kZSwgXCJsb2NhbFwiLCBsb2NhbCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW1wb3J0U3BlY2lmaWVyKGxvY2FsLCBpbXBvcnRlZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0U3BlY2lmaWVyXCIsXG4gICAgbG9jYWwsXG4gICAgaW1wb3J0ZWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkltcG9ydFNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5sb2NhbCwgbm9kZSwgXCJsb2NhbFwiLCBsb2NhbCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW1wb3J0ZWQsIG5vZGUsIFwiaW1wb3J0ZWRcIiwgaW1wb3J0ZWQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEV4cHJlc3Npb24oc291cmNlLCBvcHRpb25zID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSW1wb3J0RXhwcmVzc2lvblwiLFxuICAgIHNvdXJjZSxcbiAgICBvcHRpb25zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5JbXBvcnRFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25zLCBub2RlLCBcIm9wdGlvbnNcIiwgb3B0aW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbWV0YVByb3BlcnR5KG1ldGEsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJNZXRhUHJvcGVydHlcIixcbiAgICBtZXRhLFxuICAgIHByb3BlcnR5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5NZXRhUHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMubWV0YSwgbm9kZSwgXCJtZXRhXCIsIG1ldGEsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnByb3BlcnR5LCBub2RlLCBcInByb3BlcnR5XCIsIHByb3BlcnR5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc01ldGhvZChraW5kID0gXCJtZXRob2RcIiwga2V5LCBwYXJhbXMsIGJvZHksIGNvbXB1dGVkID0gZmFsc2UsIF9zdGF0aWMgPSBmYWxzZSwgZ2VuZXJhdG9yID0gZmFsc2UsIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzTWV0aG9kXCIsXG4gICAga2luZCxcbiAgICBrZXksXG4gICAgcGFyYW1zLFxuICAgIGJvZHksXG4gICAgY29tcHV0ZWQsXG4gICAgc3RhdGljOiBfc3RhdGljLFxuICAgIGdlbmVyYXRvcixcbiAgICBhc3luY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NNZXRob2Q7XG4gIHZhbGlkYXRlKGRlZnMua2luZCwgbm9kZSwgXCJraW5kXCIsIGtpbmQpO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5zdGF0aWMsIG5vZGUsIFwic3RhdGljXCIsIF9zdGF0aWMpO1xuICB2YWxpZGF0ZShkZWZzLmdlbmVyYXRvciwgbm9kZSwgXCJnZW5lcmF0b3JcIiwgZ2VuZXJhdG9yKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3luYywgbm9kZSwgXCJhc3luY1wiLCBhc3luYyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0UGF0dGVybihwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RQYXR0ZXJuXCIsXG4gICAgcHJvcGVydGllc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0UGF0dGVybjtcbiAgdmFsaWRhdGUoZGVmcy5wcm9wZXJ0aWVzLCBub2RlLCBcInByb3BlcnRpZXNcIiwgcHJvcGVydGllcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3ByZWFkRWxlbWVudChhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU3ByZWFkRWxlbWVudFwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5TcHJlYWRFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLmFyZ3VtZW50LCBub2RlLCBcImFyZ3VtZW50XCIsIGFyZ3VtZW50LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBfc3VwZXIoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJTdXBlclwiXG4gIH07XG59XG5mdW5jdGlvbiB0YWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24odGFnLCBxdWFzaSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIsXG4gICAgdGFnLFxuICAgIHF1YXNpXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMudGFnLCBub2RlLCBcInRhZ1wiLCB0YWcsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnF1YXNpLCBub2RlLCBcInF1YXNpXCIsIHF1YXNpLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnQodmFsdWUsIHRhaWwgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVGVtcGxhdGVFbGVtZW50XCIsXG4gICAgdmFsdWUsXG4gICAgdGFpbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVGVtcGxhdGVFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgdmFsaWRhdGUoZGVmcy50YWlsLCBub2RlLCBcInRhaWxcIiwgdGFpbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdGVtcGxhdGVMaXRlcmFsKHF1YXNpcywgZXhwcmVzc2lvbnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRlbXBsYXRlTGl0ZXJhbFwiLFxuICAgIHF1YXNpcyxcbiAgICBleHByZXNzaW9uc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVGVtcGxhdGVMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLnF1YXNpcywgbm9kZSwgXCJxdWFzaXNcIiwgcXVhc2lzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9ucywgbm9kZSwgXCJleHByZXNzaW9uc1wiLCBleHByZXNzaW9ucywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24geWllbGRFeHByZXNzaW9uKGFyZ3VtZW50ID0gbnVsbCwgZGVsZWdhdGUgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiWWllbGRFeHByZXNzaW9uXCIsXG4gICAgYXJndW1lbnQsXG4gICAgZGVsZWdhdGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLllpZWxkRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVsZWdhdGUsIG5vZGUsIFwiZGVsZWdhdGVcIiwgZGVsZWdhdGUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGF3YWl0RXhwcmVzc2lvbihhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQXdhaXRFeHByZXNzaW9uXCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkF3YWl0RXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gX2ltcG9ydCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkltcG9ydFwiXG4gIH07XG59XG5mdW5jdGlvbiBiaWdJbnRMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJCaWdJbnRMaXRlcmFsXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkJpZ0ludExpdGVyYWw7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihleHBvcnRlZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsXG4gICAgZXhwb3J0ZWRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5leHBvcnRlZCwgbm9kZSwgXCJleHBvcnRlZFwiLCBleHBvcnRlZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG9iamVjdCwgcHJvcGVydHksIGNvbXB1dGVkID0gZmFsc2UsIG9wdGlvbmFsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIixcbiAgICBvYmplY3QsXG4gICAgcHJvcGVydHksXG4gICAgY29tcHV0ZWQsXG4gICAgb3B0aW9uYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3QsIG5vZGUsIFwib2JqZWN0XCIsIG9iamVjdCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucHJvcGVydHksIG5vZGUsIFwicHJvcGVydHlcIiwgcHJvcGVydHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb3B0aW9uYWxDYWxsRXhwcmVzc2lvbihjYWxsZWUsIF9hcmd1bWVudHMsIG9wdGlvbmFsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIsXG4gICAgY2FsbGVlLFxuICAgIGFyZ3VtZW50czogX2FyZ3VtZW50cyxcbiAgICBvcHRpb25hbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsZWUsIG5vZGUsIFwiY2FsbGVlXCIsIGNhbGxlZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnRzLCBub2RlLCBcImFyZ3VtZW50c1wiLCBfYXJndW1lbnRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5vcHRpb25hbCwgbm9kZSwgXCJvcHRpb25hbFwiLCBvcHRpb25hbCk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY2xhc3NQcm9wZXJ0eShrZXksIHZhbHVlID0gbnVsbCwgdHlwZUFubm90YXRpb24gPSBudWxsLCBkZWNvcmF0b3JzID0gbnVsbCwgY29tcHV0ZWQgPSBmYWxzZSwgX3N0YXRpYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc1Byb3BlcnR5XCIsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIHR5cGVBbm5vdGF0aW9uLFxuICAgIGRlY29yYXRvcnMsXG4gICAgY29tcHV0ZWQsXG4gICAgc3RhdGljOiBfc3RhdGljXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5DbGFzc1Byb3BlcnR5O1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jb21wdXRlZCwgbm9kZSwgXCJjb21wdXRlZFwiLCBjb21wdXRlZCk7XG4gIHZhbGlkYXRlKGRlZnMuc3RhdGljLCBub2RlLCBcInN0YXRpY1wiLCBfc3RhdGljKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc0FjY2Vzc29yUHJvcGVydHkoa2V5LCB2YWx1ZSA9IG51bGwsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCwgZGVjb3JhdG9ycyA9IG51bGwsIGNvbXB1dGVkID0gZmFsc2UsIF9zdGF0aWMgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIHR5cGVBbm5vdGF0aW9uLFxuICAgIGRlY29yYXRvcnMsXG4gICAgY29tcHV0ZWQsXG4gICAgc3RhdGljOiBfc3RhdGljXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5DbGFzc0FjY2Vzc29yUHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVjb3JhdG9ycywgbm9kZSwgXCJkZWNvcmF0b3JzXCIsIGRlY29yYXRvcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNvbXB1dGVkLCBub2RlLCBcImNvbXB1dGVkXCIsIGNvbXB1dGVkKTtcbiAgdmFsaWRhdGUoZGVmcy5zdGF0aWMsIG5vZGUsIFwic3RhdGljXCIsIF9zdGF0aWMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGNsYXNzUHJpdmF0ZVByb3BlcnR5KGtleSwgdmFsdWUgPSBudWxsLCBkZWNvcmF0b3JzID0gbnVsbCwgX3N0YXRpYyA9IGZhbHNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZSxcbiAgICBkZWNvcmF0b3JzLFxuICAgIHN0YXRpYzogX3N0YXRpY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NQcml2YXRlUHJvcGVydHk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWNvcmF0b3JzLCBub2RlLCBcImRlY29yYXRvcnNcIiwgZGVjb3JhdG9ycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3RhdGljLCBub2RlLCBcInN0YXRpY1wiLCBfc3RhdGljKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjbGFzc1ByaXZhdGVNZXRob2Qoa2luZCA9IFwibWV0aG9kXCIsIGtleSwgcGFyYW1zLCBib2R5LCBfc3RhdGljID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiLFxuICAgIGtpbmQsXG4gICAga2V5LFxuICAgIHBhcmFtcyxcbiAgICBib2R5LFxuICAgIHN0YXRpYzogX3N0YXRpY1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NQcml2YXRlTWV0aG9kO1xuICB2YWxpZGF0ZShkZWZzLmtpbmQsIG5vZGUsIFwia2luZFwiLCBraW5kKTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zdGF0aWMsIG5vZGUsIFwic3RhdGljXCIsIF9zdGF0aWMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHByaXZhdGVOYW1lKGlkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQcml2YXRlTmFtZVwiLFxuICAgIGlkXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5Qcml2YXRlTmFtZTtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc3RhdGljQmxvY2soYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiU3RhdGljQmxvY2tcIixcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5TdGF0aWNCbG9jaztcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYW55VHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJBbnlUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBhcnJheVR5cGVBbm5vdGF0aW9uKGVsZW1lbnRUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIsXG4gICAgZWxlbWVudFR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkFycmF5VHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMuZWxlbWVudFR5cGUsIG5vZGUsIFwiZWxlbWVudFR5cGVcIiwgZWxlbWVudFR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGJvb2xlYW5UeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBib29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG51bGxMaXRlcmFsVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNsYXNzSW1wbGVtZW50cyhpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJDbGFzc0ltcGxlbWVudHNcIixcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuQ2xhc3NJbXBsZW1lbnRzO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZUNsYXNzKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIF9leHRlbmRzID0gbnVsbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZUNsYXNzXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgZXh0ZW5kczogX2V4dGVuZHMsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZUNsYXNzO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZXh0ZW5kcywgbm9kZSwgXCJleHRlbmRzXCIsIF9leHRlbmRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZUZ1bmN0aW9uKGlkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlRnVuY3Rpb25cIixcbiAgICBpZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZUZ1bmN0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlSW50ZXJmYWNlKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIF9leHRlbmRzID0gbnVsbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZUludGVyZmFjZVwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVJbnRlcmZhY2U7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHRlbmRzLCBub2RlLCBcImV4dGVuZHNcIiwgX2V4dGVuZHMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlTW9kdWxlKGlkLCBib2R5LCBraW5kID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZU1vZHVsZVwiLFxuICAgIGlkLFxuICAgIGJvZHksXG4gICAga2luZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZU1vZHVsZTtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICB2YWxpZGF0ZShkZWZzLmtpbmQsIG5vZGUsIFwia2luZFwiLCBraW5kKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlTW9kdWxlRXhwb3J0cyh0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZU1vZHVsZUV4cG9ydHM7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2xhcmVUeXBlQWxpYXMoaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcmlnaHQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVUeXBlQWxpYXNcIixcbiAgICBpZCxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICByaWdodFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZVR5cGVBbGlhcztcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlT3BhcXVlVHlwZShpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBzdXBlcnR5cGUgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlT3BhcXVlVHlwZVwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHN1cGVydHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZU9wYXF1ZVR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5zdXBlcnR5cGUsIG5vZGUsIFwic3VwZXJ0eXBlXCIsIHN1cGVydHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZVZhcmlhYmxlKGlkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNsYXJlVmFyaWFibGVcIixcbiAgICBpZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZVZhcmlhYmxlO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24oZGVjbGFyYXRpb24gPSBudWxsLCBzcGVjaWZpZXJzID0gbnVsbCwgc291cmNlID0gbnVsbCwgYXR0cmlidXRlcyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLFxuICAgIGRlY2xhcmF0aW9uLFxuICAgIHNwZWNpZmllcnMsXG4gICAgc291cmNlLFxuICAgIGF0dHJpYnV0ZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5kZWNsYXJhdGlvbiwgbm9kZSwgXCJkZWNsYXJhdGlvblwiLCBkZWNsYXJhdGlvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuc3BlY2lmaWVycywgbm9kZSwgXCJzcGVjaWZpZXJzXCIsIHNwZWNpZmllcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNvdXJjZSwgbm9kZSwgXCJzb3VyY2VcIiwgc291cmNlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hdHRyaWJ1dGVzLCBub2RlLCBcImF0dHJpYnV0ZXNcIiwgYXR0cmlidXRlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uKHNvdXJjZSwgYXR0cmlidXRlcyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLFxuICAgIHNvdXJjZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuc291cmNlLCBub2RlLCBcInNvdXJjZVwiLCBzb3VyY2UsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmF0dHJpYnV0ZXMsIG5vZGUsIFwiYXR0cmlidXRlc1wiLCBhdHRyaWJ1dGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBkZWNsYXJlZFByZWRpY2F0ZSh2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRGVjbGFyZWRQcmVkaWNhdGVcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRGVjbGFyZWRQcmVkaWNhdGU7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4aXN0c1R5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiRXhpc3RzVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25UeXBlQW5ub3RhdGlvbih0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtcywgcmVzdCA9IG51bGwsIHJldHVyblR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIixcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbXMsXG4gICAgcmVzdCxcbiAgICByZXR1cm5UeXBlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5GdW5jdGlvblR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucmVzdCwgbm9kZSwgXCJyZXN0XCIsIHJlc3QsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJldHVyblR5cGUsIG5vZGUsIFwicmV0dXJuVHlwZVwiLCByZXR1cm5UeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmdW5jdGlvblR5cGVQYXJhbShuYW1lID0gbnVsbCwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsXG4gICAgbmFtZSxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRnVuY3Rpb25UeXBlUGFyYW07XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZW5lcmljVHlwZUFubm90YXRpb24oaWQsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkdlbmVyaWNUeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGluZmVycmVkUHJlZGljYXRlKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiSW5mZXJyZWRQcmVkaWNhdGVcIlxuICB9O1xufVxuZnVuY3Rpb24gaW50ZXJmYWNlRXh0ZW5kcyhpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJJbnRlcmZhY2VFeHRlbmRzXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkludGVyZmFjZUV4dGVuZHM7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbnRlcmZhY2VEZWNsYXJhdGlvbihpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBfZXh0ZW5kcyA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkludGVyZmFjZURlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgZXh0ZW5kczogX2V4dGVuZHMsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW50ZXJmYWNlRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHRlbmRzLCBub2RlLCBcImV4dGVuZHNcIiwgX2V4dGVuZHMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbnRlcmZhY2VUeXBlQW5ub3RhdGlvbihfZXh0ZW5kcyA9IG51bGwsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIsXG4gICAgZXh0ZW5kczogX2V4dGVuZHMsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW50ZXJmYWNlVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMuZXh0ZW5kcywgbm9kZSwgXCJleHRlbmRzXCIsIF9leHRlbmRzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24odHlwZXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVzLCBub2RlLCBcInR5cGVzXCIsIHR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBtaXhlZFR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBlbXB0eVR5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBudWxsYWJsZVR5cGVBbm5vdGF0aW9uKHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk51bGxhYmxlVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbih2YWx1ZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbnVtYmVyVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBvYmplY3RUeXBlQW5ub3RhdGlvbihwcm9wZXJ0aWVzLCBpbmRleGVycyA9IFtdLCBjYWxsUHJvcGVydGllcyA9IFtdLCBpbnRlcm5hbFNsb3RzID0gW10sIGV4YWN0ID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsXG4gICAgcHJvcGVydGllcyxcbiAgICBpbmRleGVycyxcbiAgICBjYWxsUHJvcGVydGllcyxcbiAgICBpbnRlcm5hbFNsb3RzLFxuICAgIGV4YWN0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5PYmplY3RUeXBlQW5ub3RhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5wcm9wZXJ0aWVzLCBub2RlLCBcInByb3BlcnRpZXNcIiwgcHJvcGVydGllcywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5kZXhlcnMsIG5vZGUsIFwiaW5kZXhlcnNcIiwgaW5kZXhlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmNhbGxQcm9wZXJ0aWVzLCBub2RlLCBcImNhbGxQcm9wZXJ0aWVzXCIsIGNhbGxQcm9wZXJ0aWVzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbnRlcm5hbFNsb3RzLCBub2RlLCBcImludGVybmFsU2xvdHNcIiwgaW50ZXJuYWxTbG90cywgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZXhhY3QsIG5vZGUsIFwiZXhhY3RcIiwgZXhhY3QpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdFR5cGVJbnRlcm5hbFNsb3QoaWQsIHZhbHVlLCBvcHRpb25hbCwgX3N0YXRpYywgbWV0aG9kKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIsXG4gICAgaWQsXG4gICAgdmFsdWUsXG4gICAgb3B0aW9uYWwsXG4gICAgc3RhdGljOiBfc3RhdGljLFxuICAgIG1ldGhvZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0VHlwZUludGVybmFsU2xvdDtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm9wdGlvbmFsLCBub2RlLCBcIm9wdGlvbmFsXCIsIG9wdGlvbmFsKTtcbiAgdmFsaWRhdGUoZGVmcy5zdGF0aWMsIG5vZGUsIFwic3RhdGljXCIsIF9zdGF0aWMpO1xuICB2YWxpZGF0ZShkZWZzLm1ldGhvZCwgbm9kZSwgXCJtZXRob2RcIiwgbWV0aG9kKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBvYmplY3RUeXBlQ2FsbFByb3BlcnR5KHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIsXG4gICAgdmFsdWUsXG4gICAgc3RhdGljOiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5PYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBvYmplY3RUeXBlSW5kZXhlcihpZCA9IG51bGwsIGtleSwgdmFsdWUsIHZhcmlhbmNlID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0VHlwZUluZGV4ZXJcIixcbiAgICBpZCxcbiAgICBrZXksXG4gICAgdmFsdWUsXG4gICAgdmFyaWFuY2UsXG4gICAgc3RhdGljOiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5PYmplY3RUeXBlSW5kZXhlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnZhbHVlLCBub2RlLCBcInZhbHVlXCIsIHZhbHVlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YXJpYW5jZSwgbm9kZSwgXCJ2YXJpYW5jZVwiLCB2YXJpYW5jZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb2JqZWN0VHlwZVByb3BlcnR5KGtleSwgdmFsdWUsIHZhcmlhbmNlID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0VHlwZVByb3BlcnR5XCIsXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIHZhcmlhbmNlLFxuICAgIGtpbmQ6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG9wdGlvbmFsOiBudWxsLFxuICAgIHByb3RvOiBudWxsLFxuICAgIHN0YXRpYzogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT2JqZWN0VHlwZVByb3BlcnR5O1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFyaWFuY2UsIG5vZGUsIFwidmFyaWFuY2VcIiwgdmFyaWFuY2UsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIG9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eShhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsXG4gICAgYXJndW1lbnRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy5hcmd1bWVudCwgbm9kZSwgXCJhcmd1bWVudFwiLCBhcmd1bWVudCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb3BhcXVlVHlwZShpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBzdXBlcnR5cGUgPSBudWxsLCBpbXBsdHlwZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiT3BhcXVlVHlwZVwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIHN1cGVydHlwZSxcbiAgICBpbXBsdHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT3BhcXVlVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnN1cGVydHlwZSwgbm9kZSwgXCJzdXBlcnR5cGVcIiwgc3VwZXJ0eXBlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbXBsdHlwZSwgbm9kZSwgXCJpbXBsdHlwZVwiLCBpbXBsdHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoaWQsIHF1YWxpZmljYXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsXG4gICAgaWQsXG4gICAgcXVhbGlmaWNhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUXVhbGlmaWVkVHlwZUlkZW50aWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnF1YWxpZmljYXRpb24sIG5vZGUsIFwicXVhbGlmaWNhdGlvblwiLCBxdWFsaWZpY2F0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24odmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5TdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1R5cGVBbm5vdGF0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiU3RyaW5nVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gc3ltYm9sVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiB0aGlzVHlwZUFubm90YXRpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUaGlzVHlwZUFubm90YXRpb25cIlxuICB9O1xufVxuZnVuY3Rpb24gdHVwbGVUeXBlQW5ub3RhdGlvbih0eXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHVwbGVUeXBlQW5ub3RhdGlvblwiLFxuICAgIHR5cGVzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UdXBsZVR5cGVBbm5vdGF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVzLCBub2RlLCBcInR5cGVzXCIsIHR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0eXBlb2ZUeXBlQW5ub3RhdGlvbihhcmd1bWVudCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZW9mVHlwZUFubm90YXRpb25cIixcbiAgICBhcmd1bWVudFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHlwZW9mVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR5cGVBbGlhcyhpZCwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCByaWdodCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZUFsaWFzXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcmlnaHRcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVBbGlhcztcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0eXBlQW5ub3RhdGlvbih0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZUFubm90YXRpb25cIixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR5cGVDYXN0RXhwcmVzc2lvbihleHByZXNzaW9uLCB0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHlwZUNhc3RFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmV4cHJlc3Npb24sIG5vZGUsIFwiZXhwcmVzc2lvblwiLCBleHByZXNzaW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHlwZVBhcmFtZXRlcihib3VuZCA9IG51bGwsIF9kZWZhdWx0ID0gbnVsbCwgdmFyaWFuY2UgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUeXBlUGFyYW1ldGVyXCIsXG4gICAgYm91bmQsXG4gICAgZGVmYXVsdDogX2RlZmF1bHQsXG4gICAgdmFyaWFuY2UsXG4gICAgbmFtZTogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVHlwZVBhcmFtZXRlcjtcbiAgdmFsaWRhdGUoZGVmcy5ib3VuZCwgbm9kZSwgXCJib3VuZFwiLCBib3VuZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZGVmYXVsdCwgbm9kZSwgXCJkZWZhdWx0XCIsIF9kZWZhdWx0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YXJpYW5jZSwgbm9kZSwgXCJ2YXJpYW5jZVwiLCB2YXJpYW5jZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKHBhcmFtcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKHBhcmFtcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIixcbiAgICBwYXJhbXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB1bmlvblR5cGVBbm5vdGF0aW9uKHR5cGVzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJVbmlvblR5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlVuaW9uVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudHlwZXMsIG5vZGUsIFwidHlwZXNcIiwgdHlwZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHZhcmlhbmNlKGtpbmQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlZhcmlhbmNlXCIsXG4gICAga2luZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVmFyaWFuY2U7XG4gIHZhbGlkYXRlKGRlZnMua2luZCwgbm9kZSwgXCJraW5kXCIsIGtpbmQpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHZvaWRUeXBlQW5ub3RhdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlZvaWRUeXBlQW5ub3RhdGlvblwiXG4gIH07XG59XG5mdW5jdGlvbiBlbnVtRGVjbGFyYXRpb24oaWQsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkVudW1EZWNsYXJhdGlvblwiLFxuICAgIGlkLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1EZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYm9keSwgbm9kZSwgXCJib2R5XCIsIGJvZHksIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1Cb29sZWFuQm9keShtZW1iZXJzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtQm9vbGVhbkJvZHlcIixcbiAgICBtZW1iZXJzLFxuICAgIGV4cGxpY2l0VHlwZTogbnVsbCxcbiAgICBoYXNVbmtub3duTWVtYmVyczogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bUJvb2xlYW5Cb2R5O1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtTnVtYmVyQm9keShtZW1iZXJzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtTnVtYmVyQm9keVwiLFxuICAgIG1lbWJlcnMsXG4gICAgZXhwbGljaXRUeXBlOiBudWxsLFxuICAgIGhhc1Vua25vd25NZW1iZXJzOiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FbnVtTnVtYmVyQm9keTtcbiAgdmFsaWRhdGUoZGVmcy5tZW1iZXJzLCBub2RlLCBcIm1lbWJlcnNcIiwgbWVtYmVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZW51bVN0cmluZ0JvZHkobWVtYmVycykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bVN0cmluZ0JvZHlcIixcbiAgICBtZW1iZXJzLFxuICAgIGV4cGxpY2l0VHlwZTogbnVsbCxcbiAgICBoYXNVbmtub3duTWVtYmVyczogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bVN0cmluZ0JvZHk7XG4gIHZhbGlkYXRlKGRlZnMubWVtYmVycywgbm9kZSwgXCJtZW1iZXJzXCIsIG1lbWJlcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1TeW1ib2xCb2R5KG1lbWJlcnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkVudW1TeW1ib2xCb2R5XCIsXG4gICAgbWVtYmVycyxcbiAgICBoYXNVbmtub3duTWVtYmVyczogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bVN5bWJvbEJvZHk7XG4gIHZhbGlkYXRlKGRlZnMubWVtYmVycywgbm9kZSwgXCJtZW1iZXJzXCIsIG1lbWJlcnMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1Cb29sZWFuTWVtYmVyKGlkKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtQm9vbGVhbk1lbWJlclwiLFxuICAgIGlkLFxuICAgIGluaXQ6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkVudW1Cb29sZWFuTWVtYmVyO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBlbnVtTnVtYmVyTWVtYmVyKGlkLCBpbml0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJFbnVtTnVtYmVyTWVtYmVyXCIsXG4gICAgaWQsXG4gICAgaW5pdFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRW51bU51bWJlck1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5pdCwgbm9kZSwgXCJpbml0XCIsIGluaXQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVudW1TdHJpbmdNZW1iZXIoaWQsIGluaXQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkVudW1TdHJpbmdNZW1iZXJcIixcbiAgICBpZCxcbiAgICBpbml0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FbnVtU3RyaW5nTWVtYmVyO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbml0LCBub2RlLCBcImluaXRcIiwgaW5pdCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZW51bURlZmF1bHRlZE1lbWJlcihpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiRW51bURlZmF1bHRlZE1lbWJlclwiLFxuICAgIGlkXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5FbnVtRGVmYXVsdGVkTWVtYmVyO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBpbmRleGVkQWNjZXNzVHlwZShvYmplY3RUeXBlLCBpbmRleFR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkluZGV4ZWRBY2Nlc3NUeXBlXCIsXG4gICAgb2JqZWN0VHlwZSxcbiAgICBpbmRleFR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkluZGV4ZWRBY2Nlc3NUeXBlO1xuICB2YWxpZGF0ZShkZWZzLm9iamVjdFR5cGUsIG5vZGUsIFwib2JqZWN0VHlwZVwiLCBvYmplY3RUeXBlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5pbmRleFR5cGUsIG5vZGUsIFwiaW5kZXhUeXBlXCIsIGluZGV4VHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gb3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZShvYmplY3RUeXBlLCBpbmRleFR5cGUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIixcbiAgICBvYmplY3RUeXBlLFxuICAgIGluZGV4VHlwZSxcbiAgICBvcHRpb25hbDogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy5vYmplY3RUeXBlLCBub2RlLCBcIm9iamVjdFR5cGVcIiwgb2JqZWN0VHlwZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5kZXhUeXBlLCBub2RlLCBcImluZGV4VHlwZVwiLCBpbmRleFR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWEF0dHJpYnV0ZVwiLFxuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWEF0dHJpYnV0ZTtcbiAgdmFsaWRhdGUoZGVmcy5uYW1lLCBub2RlLCBcIm5hbWVcIiwgbmFtZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudmFsdWUsIG5vZGUsIFwidmFsdWVcIiwgdmFsdWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeENsb3NpbmdFbGVtZW50KG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWENsb3NpbmdFbGVtZW50XCIsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYQ2xvc2luZ0VsZW1lbnQ7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeEVsZW1lbnQob3BlbmluZ0VsZW1lbnQsIGNsb3NpbmdFbGVtZW50ID0gbnVsbCwgY2hpbGRyZW4sIHNlbGZDbG9zaW5nID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYRWxlbWVudFwiLFxuICAgIG9wZW5pbmdFbGVtZW50LFxuICAgIGNsb3NpbmdFbGVtZW50LFxuICAgIGNoaWxkcmVuLFxuICAgIHNlbGZDbG9zaW5nXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hFbGVtZW50O1xuICB2YWxpZGF0ZShkZWZzLm9wZW5pbmdFbGVtZW50LCBub2RlLCBcIm9wZW5pbmdFbGVtZW50XCIsIG9wZW5pbmdFbGVtZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jbG9zaW5nRWxlbWVudCwgbm9kZSwgXCJjbG9zaW5nRWxlbWVudFwiLCBjbG9zaW5nRWxlbWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2hpbGRyZW4sIG5vZGUsIFwiY2hpbGRyZW5cIiwgY2hpbGRyZW4sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNlbGZDbG9zaW5nLCBub2RlLCBcInNlbGZDbG9zaW5nXCIsIHNlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hFbXB0eUV4cHJlc3Npb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJKU1hFbXB0eUV4cHJlc3Npb25cIlxuICB9O1xufVxuZnVuY3Rpb24ganN4RXhwcmVzc2lvbkNvbnRhaW5lcihleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYRXhwcmVzc2lvbkNvbnRhaW5lcjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4U3ByZWFkQ2hpbGQoZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiSlNYU3ByZWFkQ2hpbGRcIixcbiAgICBleHByZXNzaW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hTcHJlYWRDaGlsZDtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4SWRlbnRpZmllcihuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hJZGVudGlmaWVyXCIsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYSWRlbnRpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5uYW1lLCBub2RlLCBcIm5hbWVcIiwgbmFtZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4TWVtYmVyRXhwcmVzc2lvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsXG4gICAgb2JqZWN0LFxuICAgIHByb3BlcnR5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hNZW1iZXJFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9iamVjdCwgbm9kZSwgXCJvYmplY3RcIiwgb2JqZWN0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5wcm9wZXJ0eSwgbm9kZSwgXCJwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4TmFtZXNwYWNlZE5hbWUobmFtZXNwYWNlLCBuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hOYW1lc3BhY2VkTmFtZVwiLFxuICAgIG5hbWVzcGFjZSxcbiAgICBuYW1lXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hOYW1lc3BhY2VkTmFtZTtcbiAgdmFsaWRhdGUoZGVmcy5uYW1lc3BhY2UsIG5vZGUsIFwibmFtZXNwYWNlXCIsIG5hbWVzcGFjZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeE9wZW5pbmdFbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIHNlbGZDbG9zaW5nID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWE9wZW5pbmdFbGVtZW50XCIsXG4gICAgbmFtZSxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIHNlbGZDbG9zaW5nXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hPcGVuaW5nRWxlbWVudDtcbiAgdmFsaWRhdGUoZGVmcy5uYW1lLCBub2RlLCBcIm5hbWVcIiwgbmFtZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXR0cmlidXRlcywgbm9kZSwgXCJhdHRyaWJ1dGVzXCIsIGF0dHJpYnV0ZXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnNlbGZDbG9zaW5nLCBub2RlLCBcInNlbGZDbG9zaW5nXCIsIHNlbGZDbG9zaW5nKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBqc3hTcHJlYWRBdHRyaWJ1dGUoYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiLFxuICAgIGFyZ3VtZW50XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5KU1hTcHJlYWRBdHRyaWJ1dGU7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeFRleHQodmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkpTWFRleHRcIixcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSlNYVGV4dDtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24ganN4RnJhZ21lbnQob3BlbmluZ0ZyYWdtZW50LCBjbG9zaW5nRnJhZ21lbnQsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJKU1hGcmFnbWVudFwiLFxuICAgIG9wZW5pbmdGcmFnbWVudCxcbiAgICBjbG9zaW5nRnJhZ21lbnQsXG4gICAgY2hpbGRyZW5cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkpTWEZyYWdtZW50O1xuICB2YWxpZGF0ZShkZWZzLm9wZW5pbmdGcmFnbWVudCwgbm9kZSwgXCJvcGVuaW5nRnJhZ21lbnRcIiwgb3BlbmluZ0ZyYWdtZW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jbG9zaW5nRnJhZ21lbnQsIG5vZGUsIFwiY2xvc2luZ0ZyYWdtZW50XCIsIGNsb3NpbmdGcmFnbWVudCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuY2hpbGRyZW4sIG5vZGUsIFwiY2hpbGRyZW5cIiwgY2hpbGRyZW4sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGpzeE9wZW5pbmdGcmFnbWVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIkpTWE9wZW5pbmdGcmFnbWVudFwiXG4gIH07XG59XG5mdW5jdGlvbiBqc3hDbG9zaW5nRnJhZ21lbnQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJKU1hDbG9zaW5nRnJhZ21lbnRcIlxuICB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIk5vb3BcIlxuICB9O1xufVxuZnVuY3Rpb24gcGxhY2Vob2xkZXIoZXhwZWN0ZWROb2RlLCBuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQbGFjZWhvbGRlclwiLFxuICAgIGV4cGVjdGVkTm9kZSxcbiAgICBuYW1lXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5QbGFjZWhvbGRlcjtcbiAgdmFsaWRhdGUoZGVmcy5leHBlY3RlZE5vZGUsIG5vZGUsIFwiZXhwZWN0ZWROb2RlXCIsIGV4cGVjdGVkTm9kZSk7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHY4SW50cmluc2ljSWRlbnRpZmllcihuYW1lKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIixcbiAgICBuYW1lXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5WOEludHJpbnNpY0lkZW50aWZpZXI7XG4gIHZhbGlkYXRlKGRlZnMubmFtZSwgbm9kZSwgXCJuYW1lXCIsIG5hbWUpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGFyZ3VtZW50UGxhY2Vob2xkZXIoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJBcmd1bWVudFBsYWNlaG9sZGVyXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGJpbmRFeHByZXNzaW9uKG9iamVjdCwgY2FsbGVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJCaW5kRXhwcmVzc2lvblwiLFxuICAgIG9iamVjdCxcbiAgICBjYWxsZWVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkJpbmRFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLm9iamVjdCwgbm9kZSwgXCJvYmplY3RcIiwgb2JqZWN0LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsZWUsIG5vZGUsIFwiY2FsbGVlXCIsIGNhbGxlZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gaW1wb3J0QXR0cmlidXRlKGtleSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkltcG9ydEF0dHJpYnV0ZVwiLFxuICAgIGtleSxcbiAgICB2YWx1ZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuSW1wb3J0QXR0cmlidXRlO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZGVjb3JhdG9yKGV4cHJlc3Npb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRlY29yYXRvclwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRlY29yYXRvcjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZG9FeHByZXNzaW9uKGJvZHksIGFzeW5jID0gZmFsc2UpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkRvRXhwcmVzc2lvblwiLFxuICAgIGJvZHksXG4gICAgYXN5bmNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLkRvRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuYXN5bmMsIG5vZGUsIFwiYXN5bmNcIiwgYXN5bmMpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGV4cG9ydERlZmF1bHRTcGVjaWZpZXIoZXhwb3J0ZWQpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIixcbiAgICBleHBvcnRlZFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuRXhwb3J0RGVmYXVsdFNwZWNpZmllcjtcbiAgdmFsaWRhdGUoZGVmcy5leHBvcnRlZCwgbm9kZSwgXCJleHBvcnRlZFwiLCBleHBvcnRlZCwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcmVjb3JkRXhwcmVzc2lvbihwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJSZWNvcmRFeHByZXNzaW9uXCIsXG4gICAgcHJvcGVydGllc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuUmVjb3JkRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5wcm9wZXJ0aWVzLCBub2RlLCBcInByb3BlcnRpZXNcIiwgcHJvcGVydGllcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHVwbGVFeHByZXNzaW9uKGVsZW1lbnRzID0gW10pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlR1cGxlRXhwcmVzc2lvblwiLFxuICAgIGVsZW1lbnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UdXBsZUV4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuZWxlbWVudHMsIG5vZGUsIFwiZWxlbWVudHNcIiwgZWxlbWVudHMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlY2ltYWxMaXRlcmFsKHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJEZWNpbWFsTGl0ZXJhbFwiLFxuICAgIHZhbHVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5EZWNpbWFsTGl0ZXJhbDtcbiAgdmFsaWRhdGUoZGVmcy52YWx1ZSwgbm9kZSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gbW9kdWxlRXhwcmVzc2lvbihib2R5KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJNb2R1bGVFeHByZXNzaW9uXCIsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuTW9kdWxlRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5ib2R5LCBub2RlLCBcImJvZHlcIiwgYm9keSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdG9waWNSZWZlcmVuY2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BpY1JlZmVyZW5jZVwiXG4gIH07XG59XG5mdW5jdGlvbiBwaXBlbGluZVRvcGljRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlBpcGVsaW5lVG9waWNFeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmV4cHJlc3Npb24sIG5vZGUsIFwiZXhwcmVzc2lvblwiLCBleHByZXNzaW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwaXBlbGluZUJhcmVGdW5jdGlvbihjYWxsZWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsXG4gICAgY2FsbGVlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5QaXBlbGluZUJhcmVGdW5jdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5jYWxsZWUsIG5vZGUsIFwiY2FsbGVlXCIsIGNhbGxlZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gcGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJQaXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZVwiXG4gIH07XG59XG5mdW5jdGlvbiB0c1BhcmFtZXRlclByb3BlcnR5KHBhcmFtZXRlcikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLFxuICAgIHBhcmFtZXRlclxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbWV0ZXIsIG5vZGUsIFwicGFyYW1ldGVyXCIsIHBhcmFtZXRlciwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNEZWNsYXJlRnVuY3Rpb24oaWQgPSBudWxsLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtcywgcmV0dXJuVHlwZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1zLFxuICAgIHJldHVyblR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRGVjbGFyZUZ1bmN0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1zLCBub2RlLCBcInBhcmFtc1wiLCBwYXJhbXMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJldHVyblR5cGUsIG5vZGUsIFwicmV0dXJuVHlwZVwiLCByZXR1cm5UeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0RlY2xhcmVNZXRob2QoZGVjb3JhdG9ycyA9IG51bGwsIGtleSwgdHlwZVBhcmFtZXRlcnMgPSBudWxsLCBwYXJhbXMsIHJldHVyblR5cGUgPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0RlY2xhcmVNZXRob2RcIixcbiAgICBkZWNvcmF0b3JzLFxuICAgIGtleSxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbXMsXG4gICAgcmV0dXJuVHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNEZWNsYXJlTWV0aG9kO1xuICB2YWxpZGF0ZShkZWZzLmRlY29yYXRvcnMsIG5vZGUsIFwiZGVjb3JhdG9yc1wiLCBkZWNvcmF0b3JzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5rZXksIG5vZGUsIFwia2V5XCIsIGtleSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5yZXR1cm5UeXBlLCBub2RlLCBcInJldHVyblR5cGVcIiwgcmV0dXJuVHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNRdWFsaWZpZWROYW1lKGxlZnQsIHJpZ2h0KSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1F1YWxpZmllZE5hbWVcIixcbiAgICBsZWZ0LFxuICAgIHJpZ2h0XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1F1YWxpZmllZE5hbWU7XG4gIHZhbGlkYXRlKGRlZnMubGVmdCwgbm9kZSwgXCJsZWZ0XCIsIGxlZnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnJpZ2h0LCBub2RlLCBcInJpZ2h0XCIsIHJpZ2h0LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbih0eXBlUGFyYW1ldGVycyA9IG51bGwsIHBhcmFtZXRlcnMsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIixcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1Byb3BlcnR5U2lnbmF0dXJlKGtleSwgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCIsXG4gICAga2V5LFxuICAgIHR5cGVBbm5vdGF0aW9uLFxuICAgIGtpbmQ6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTUHJvcGVydHlTaWduYXR1cmU7XG4gIHZhbGlkYXRlKGRlZnMua2V5LCBub2RlLCBcImtleVwiLCBrZXksIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c01ldGhvZFNpZ25hdHVyZShrZXksIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCwgcGFyYW1ldGVycywgdHlwZUFubm90YXRpb24gPSBudWxsKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU01ldGhvZFNpZ25hdHVyZVwiLFxuICAgIGtleSxcbiAgICB0eXBlUGFyYW1ldGVycyxcbiAgICBwYXJhbWV0ZXJzLFxuICAgIHR5cGVBbm5vdGF0aW9uLFxuICAgIGtpbmQ6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTWV0aG9kU2lnbmF0dXJlO1xuICB2YWxpZGF0ZShkZWZzLmtleSwgbm9kZSwgXCJrZXlcIiwga2V5LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0luZGV4U2lnbmF0dXJlKHBhcmFtZXRlcnMsIHR5cGVBbm5vdGF0aW9uID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbmRleFNpZ25hdHVyZVwiLFxuICAgIHBhcmFtZXRlcnMsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW5kZXhTaWduYXR1cmU7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVycywgbm9kZSwgXCJwYXJhbWV0ZXJzXCIsIHBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0FueUtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU0FueUtleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNCb29sZWFuS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTQm9vbGVhbktleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNCaWdJbnRLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNCaWdJbnRLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzSW50cmluc2ljS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTSW50cmluc2ljS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c05ldmVyS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTTmV2ZXJLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzTnVsbEtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU051bGxLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzTnVtYmVyS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTTnVtYmVyS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c09iamVjdEtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU09iamVjdEtleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNTdHJpbmdLZXl3b3JkKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiVFNTdHJpbmdLZXl3b3JkXCJcbiAgfTtcbn1cbmZ1bmN0aW9uIHRzU3ltYm9sS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTU3ltYm9sS2V5d29yZFwiXG4gIH07XG59XG5mdW5jdGlvbiB0c1VuZGVmaW5lZEtleXdvcmQoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUU1VuZGVmaW5lZEtleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNVbmtub3duS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTVW5rbm93bktleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNWb2lkS2V5d29yZCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTVm9pZEtleXdvcmRcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNUaGlzVHlwZSgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcIlRTVGhpc1R5cGVcIlxuICB9O1xufVxuZnVuY3Rpb24gdHNGdW5jdGlvblR5cGUodHlwZVBhcmFtZXRlcnMgPSBudWxsLCBwYXJhbWV0ZXJzLCB0eXBlQW5ub3RhdGlvbiA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRnVuY3Rpb25UeXBlXCIsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNGdW5jdGlvblR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtZXRlcnMsIG5vZGUsIFwicGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNDb25zdHJ1Y3RvclR5cGUodHlwZVBhcmFtZXRlcnMgPSBudWxsLCBwYXJhbWV0ZXJzLCB0eXBlQW5ub3RhdGlvbiA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTQ29uc3RydWN0b3JUeXBlXCIsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgcGFyYW1ldGVycyxcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNDb25zdHJ1Y3RvclR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZVBhcmFtZXRlcnMsIG5vZGUsIFwidHlwZVBhcmFtZXRlcnNcIiwgdHlwZVBhcmFtZXRlcnMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtZXRlcnMsIG5vZGUsIFwicGFyYW1ldGVyc1wiLCBwYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlUmVmZXJlbmNlKHR5cGVOYW1lLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVJlZmVyZW5jZVwiLFxuICAgIHR5cGVOYW1lLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVSZWZlcmVuY2U7XG4gIHZhbGlkYXRlKGRlZnMudHlwZU5hbWUsIG5vZGUsIFwidHlwZU5hbWVcIiwgdHlwZU5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVQcmVkaWNhdGUocGFyYW1ldGVyTmFtZSwgdHlwZUFubm90YXRpb24gPSBudWxsLCBhc3NlcnRzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUeXBlUHJlZGljYXRlXCIsXG4gICAgcGFyYW1ldGVyTmFtZSxcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBhc3NlcnRzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVQcmVkaWNhdGU7XG4gIHZhbGlkYXRlKGRlZnMucGFyYW1ldGVyTmFtZSwgbm9kZSwgXCJwYXJhbWV0ZXJOYW1lXCIsIHBhcmFtZXRlck5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5hc3NlcnRzLCBub2RlLCBcImFzc2VydHNcIiwgYXNzZXJ0cyk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlUXVlcnkoZXhwck5hbWUsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUeXBlUXVlcnlcIixcbiAgICBleHByTmFtZSxcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlUXVlcnk7XG4gIHZhbGlkYXRlKGRlZnMuZXhwck5hbWUsIG5vZGUsIFwiZXhwck5hbWVcIiwgZXhwck5hbWUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVMaXRlcmFsKG1lbWJlcnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZUxpdGVyYWxcIixcbiAgICBtZW1iZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVMaXRlcmFsO1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0FycmF5VHlwZShlbGVtZW50VHlwZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNBcnJheVR5cGVcIixcbiAgICBlbGVtZW50VHlwZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNBcnJheVR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuZWxlbWVudFR5cGUsIG5vZGUsIFwiZWxlbWVudFR5cGVcIiwgZWxlbWVudFR5cGUsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHVwbGVUeXBlKGVsZW1lbnRUeXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUdXBsZVR5cGVcIixcbiAgICBlbGVtZW50VHlwZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHVwbGVUeXBlO1xuICB2YWxpZGF0ZShkZWZzLmVsZW1lbnRUeXBlcywgbm9kZSwgXCJlbGVtZW50VHlwZXNcIiwgZWxlbWVudFR5cGVzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c09wdGlvbmFsVHlwZSh0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNPcHRpb25hbFR5cGVcIixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNPcHRpb25hbFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzUmVzdFR5cGUodHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTUmVzdFR5cGVcIixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNSZXN0VHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNOYW1lZFR1cGxlTWVtYmVyKGxhYmVsLCBlbGVtZW50VHlwZSwgb3B0aW9uYWwgPSBmYWxzZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIsXG4gICAgbGFiZWwsXG4gICAgZWxlbWVudFR5cGUsXG4gICAgb3B0aW9uYWxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTmFtZWRUdXBsZU1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5sYWJlbCwgbm9kZSwgXCJsYWJlbFwiLCBsYWJlbCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZWxlbWVudFR5cGUsIG5vZGUsIFwiZWxlbWVudFR5cGVcIiwgZWxlbWVudFR5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm9wdGlvbmFsLCBub2RlLCBcIm9wdGlvbmFsXCIsIG9wdGlvbmFsKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1VuaW9uVHlwZSh0eXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNVbmlvblR5cGVcIixcbiAgICB0eXBlc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNVbmlvblR5cGU7XG4gIHZhbGlkYXRlKGRlZnMudHlwZXMsIG5vZGUsIFwidHlwZXNcIiwgdHlwZXMsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzSW50ZXJzZWN0aW9uVHlwZSh0eXBlcykge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsXG4gICAgdHlwZXNcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW50ZXJzZWN0aW9uVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlcywgbm9kZSwgXCJ0eXBlc1wiLCB0eXBlcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNDb25kaXRpb25hbFR5cGUoY2hlY2tUeXBlLCBleHRlbmRzVHlwZSwgdHJ1ZVR5cGUsIGZhbHNlVHlwZSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNDb25kaXRpb25hbFR5cGVcIixcbiAgICBjaGVja1R5cGUsXG4gICAgZXh0ZW5kc1R5cGUsXG4gICAgdHJ1ZVR5cGUsXG4gICAgZmFsc2VUeXBlXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0NvbmRpdGlvbmFsVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy5jaGVja1R5cGUsIG5vZGUsIFwiY2hlY2tUeXBlXCIsIGNoZWNrVHlwZSwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuZXh0ZW5kc1R5cGUsIG5vZGUsIFwiZXh0ZW5kc1R5cGVcIiwgZXh0ZW5kc1R5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnRydWVUeXBlLCBub2RlLCBcInRydWVUeXBlXCIsIHRydWVUeXBlLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5mYWxzZVR5cGUsIG5vZGUsIFwiZmFsc2VUeXBlXCIsIGZhbHNlVHlwZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbmZlclR5cGUodHlwZVBhcmFtZXRlcikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbmZlclR5cGVcIixcbiAgICB0eXBlUGFyYW1ldGVyXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0luZmVyVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVyLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJcIiwgdHlwZVBhcmFtZXRlciwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNQYXJlbnRoZXNpemVkVHlwZSh0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiLFxuICAgIHR5cGVBbm5vdGF0aW9uXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1BhcmVudGhlc2l6ZWRUeXBlO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVPcGVyYXRvcih0eXBlQW5ub3RhdGlvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUeXBlT3BlcmF0b3JcIixcbiAgICB0eXBlQW5ub3RhdGlvbixcbiAgICBvcGVyYXRvcjogbnVsbFxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlT3BlcmF0b3I7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzSW5kZXhlZEFjY2Vzc1R5cGUob2JqZWN0VHlwZSwgaW5kZXhUeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIsXG4gICAgb2JqZWN0VHlwZSxcbiAgICBpbmRleFR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW5kZXhlZEFjY2Vzc1R5cGU7XG4gIHZhbGlkYXRlKGRlZnMub2JqZWN0VHlwZSwgbm9kZSwgXCJvYmplY3RUeXBlXCIsIG9iamVjdFR5cGUsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmluZGV4VHlwZSwgbm9kZSwgXCJpbmRleFR5cGVcIiwgaW5kZXhUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c01hcHBlZFR5cGUodHlwZVBhcmFtZXRlciwgdHlwZUFubm90YXRpb24gPSBudWxsLCBuYW1lVHlwZSA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTWFwcGVkVHlwZVwiLFxuICAgIHR5cGVQYXJhbWV0ZXIsXG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgbmFtZVR5cGVcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTWFwcGVkVHlwZTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVyLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJcIiwgdHlwZVBhcmFtZXRlciwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWVUeXBlLCBub2RlLCBcIm5hbWVUeXBlXCIsIG5hbWVUeXBlLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0xpdGVyYWxUeXBlKGxpdGVyYWwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTGl0ZXJhbFR5cGVcIixcbiAgICBsaXRlcmFsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0xpdGVyYWxUeXBlO1xuICB2YWxpZGF0ZShkZWZzLmxpdGVyYWwsIG5vZGUsIFwibGl0ZXJhbFwiLCBsaXRlcmFsLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhleHByZXNzaW9uLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlUGFyYW1ldGVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ludGVyZmFjZURlY2xhcmF0aW9uKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIF9leHRlbmRzID0gbnVsbCwgYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLFxuICAgIGlkLFxuICAgIHR5cGVQYXJhbWV0ZXJzLFxuICAgIGV4dGVuZHM6IF9leHRlbmRzLFxuICAgIGJvZHlcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTSW50ZXJmYWNlRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHRlbmRzLCBub2RlLCBcImV4dGVuZHNcIiwgX2V4dGVuZHMsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ludGVyZmFjZUJvZHkoYm9keSkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbnRlcmZhY2VCb2R5XCIsXG4gICAgYm9keVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNJbnRlcmZhY2VCb2R5O1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVBbGlhc0RlY2xhcmF0aW9uKGlkLCB0eXBlUGFyYW1ldGVycyA9IG51bGwsIHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgdHlwZVBhcmFtZXRlcnMsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHlwZUFsaWFzRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVQYXJhbWV0ZXJzLCBub2RlLCBcInR5cGVQYXJhbWV0ZXJzXCIsIHR5cGVQYXJhbWV0ZXJzLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlQW5ub3RhdGlvbiwgbm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiLCB0eXBlQW5ub3RhdGlvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbnN0YW50aWF0aW9uRXhwcmVzc2lvbihleHByZXNzaW9uLCB0eXBlUGFyYW1ldGVycyA9IG51bGwpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIixcbiAgICBleHByZXNzaW9uLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0luc3RhbnRpYXRpb25FeHByZXNzaW9uO1xuICB2YWxpZGF0ZShkZWZzLmV4cHJlc3Npb24sIG5vZGUsIFwiZXhwcmVzc2lvblwiLCBleHByZXNzaW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNBc0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTQXNFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvbixcbiAgICB0eXBlQW5ub3RhdGlvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNBc0V4cHJlc3Npb247XG4gIHZhbGlkYXRlKGRlZnMuZXhwcmVzc2lvbiwgbm9kZSwgXCJleHByZXNzaW9uXCIsIGV4cHJlc3Npb24sIDEpO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1NhdGlzZmllc0V4cHJlc3Npb24oZXhwcmVzc2lvbiwgdHlwZUFubm90YXRpb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLFxuICAgIGV4cHJlc3Npb24sXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTU2F0aXNmaWVzRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZUFzc2VydGlvbih0eXBlQW5ub3RhdGlvbiwgZXhwcmVzc2lvbikge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNUeXBlQXNzZXJ0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb24sXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlQXNzZXJ0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnR5cGVBbm5vdGF0aW9uLCBub2RlLCBcInR5cGVBbm5vdGF0aW9uXCIsIHR5cGVBbm5vdGF0aW9uLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFbnVtRGVjbGFyYXRpb24oaWQsIG1lbWJlcnMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRW51bURlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgbWVtYmVyc1xuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFbnVtRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm1lbWJlcnMsIG5vZGUsIFwibWVtYmVyc1wiLCBtZW1iZXJzLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0VudW1NZW1iZXIoaWQsIGluaXRpYWxpemVyID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNFbnVtTWVtYmVyXCIsXG4gICAgaWQsXG4gICAgaW5pdGlhbGl6ZXJcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRW51bU1lbWJlcjtcbiAgdmFsaWRhdGUoZGVmcy5pZCwgbm9kZSwgXCJpZFwiLCBpZCwgMSk7XG4gIHZhbGlkYXRlKGRlZnMuaW5pdGlhbGl6ZXIsIG5vZGUsIFwiaW5pdGlhbGl6ZXJcIiwgaW5pdGlhbGl6ZXIsIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzTW9kdWxlRGVjbGFyYXRpb24oaWQsIGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIixcbiAgICBpZCxcbiAgICBib2R5LFxuICAgIGtpbmQ6IG51bGxcbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTTW9kdWxlRGVjbGFyYXRpb247XG4gIHZhbGlkYXRlKGRlZnMuaWQsIG5vZGUsIFwiaWRcIiwgaWQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c01vZHVsZUJsb2NrKGJvZHkpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTTW9kdWxlQmxvY2tcIixcbiAgICBib2R5XG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU01vZHVsZUJsb2NrO1xuICB2YWxpZGF0ZShkZWZzLmJvZHksIG5vZGUsIFwiYm9keVwiLCBib2R5LCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c0ltcG9ydFR5cGUoYXJndW1lbnQsIHF1YWxpZmllciA9IG51bGwsIHR5cGVQYXJhbWV0ZXJzID0gbnVsbCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNJbXBvcnRUeXBlXCIsXG4gICAgYXJndW1lbnQsXG4gICAgcXVhbGlmaWVyLFxuICAgIHR5cGVQYXJhbWV0ZXJzXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0ltcG9ydFR5cGU7XG4gIHZhbGlkYXRlKGRlZnMuYXJndW1lbnQsIG5vZGUsIFwiYXJndW1lbnRcIiwgYXJndW1lbnQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLnF1YWxpZmllciwgbm9kZSwgXCJxdWFsaWZpZXJcIiwgcXVhbGlmaWVyLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy50eXBlUGFyYW1ldGVycywgbm9kZSwgXCJ0eXBlUGFyYW1ldGVyc1wiLCB0eXBlUGFyYW1ldGVycywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihpZCwgbW9kdWxlUmVmZXJlbmNlKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsXG4gICAgaWQsXG4gICAgbW9kdWxlUmVmZXJlbmNlLFxuICAgIGlzRXhwb3J0OiBudWxsXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5tb2R1bGVSZWZlcmVuY2UsIG5vZGUsIFwibW9kdWxlUmVmZXJlbmNlXCIsIG1vZHVsZVJlZmVyZW5jZSwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZShleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNOb25OdWxsRXhwcmVzc2lvbihleHByZXNzaW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU05vbk51bGxFeHByZXNzaW9uXCIsXG4gICAgZXhwcmVzc2lvblxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNOb25OdWxsRXhwcmVzc2lvbjtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNFeHBvcnRBc3NpZ25tZW50KGV4cHJlc3Npb24pIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTRXhwb3J0QXNzaWdubWVudFwiLFxuICAgIGV4cHJlc3Npb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTRXhwb3J0QXNzaWdubWVudDtcbiAgdmFsaWRhdGUoZGVmcy5leHByZXNzaW9uLCBub2RlLCBcImV4cHJlc3Npb25cIiwgZXhwcmVzc2lvbiwgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihpZCkge1xuICBjb25zdCBub2RlID0ge1xuICAgIHR5cGU6IFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLFxuICAgIGlkXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLmlkLCBub2RlLCBcImlkXCIsIGlkLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVBbm5vdGF0aW9uKHR5cGVBbm5vdGF0aW9uKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVBbm5vdGF0aW9uXCIsXG4gICAgdHlwZUFubm90YXRpb25cbiAgfTtcbiAgY29uc3QgZGVmcyA9IE5PREVfRklFTERTLlRTVHlwZUFubm90YXRpb247XG4gIHZhbGlkYXRlKGRlZnMudHlwZUFubm90YXRpb24sIG5vZGUsIFwidHlwZUFubm90YXRpb25cIiwgdHlwZUFubm90YXRpb24sIDEpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24ocGFyYW1zKSB7XG4gIGNvbnN0IG5vZGUgPSB7XG4gICAgdHlwZTogXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uO1xuICB2YWxpZGF0ZShkZWZzLnBhcmFtcywgbm9kZSwgXCJwYXJhbXNcIiwgcGFyYW1zLCAxKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiB0c1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihwYXJhbXMpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsXG4gICAgcGFyYW1zXG4gIH07XG4gIGNvbnN0IGRlZnMgPSBOT0RFX0ZJRUxEUy5UU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbiAgdmFsaWRhdGUoZGVmcy5wYXJhbXMsIG5vZGUsIFwicGFyYW1zXCIsIHBhcmFtcywgMSk7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gdHNUeXBlUGFyYW1ldGVyKGNvbnN0cmFpbnQgPSBudWxsLCBfZGVmYXVsdCA9IG51bGwsIG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IHtcbiAgICB0eXBlOiBcIlRTVHlwZVBhcmFtZXRlclwiLFxuICAgIGNvbnN0cmFpbnQsXG4gICAgZGVmYXVsdDogX2RlZmF1bHQsXG4gICAgbmFtZVxuICB9O1xuICBjb25zdCBkZWZzID0gTk9ERV9GSUVMRFMuVFNUeXBlUGFyYW1ldGVyO1xuICB2YWxpZGF0ZShkZWZzLmNvbnN0cmFpbnQsIG5vZGUsIFwiY29uc3RyYWludFwiLCBjb25zdHJhaW50LCAxKTtcbiAgdmFsaWRhdGUoZGVmcy5kZWZhdWx0LCBub2RlLCBcImRlZmF1bHRcIiwgX2RlZmF1bHQsIDEpO1xuICB2YWxpZGF0ZShkZWZzLm5hbWUsIG5vZGUsIFwibmFtZVwiLCBuYW1lKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBOdW1iZXJMaXRlcmFsKHZhbHVlKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiTnVtYmVyTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiVGhlIG5vZGUgdHlwZSBcIik7XG4gIHJldHVybiBudW1lcmljTGl0ZXJhbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBSZWdleExpdGVyYWwocGF0dGVybiwgZmxhZ3MgPSBcIlwiKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiUmVnZXhMaXRlcmFsXCIsIFwiUmVnRXhwTGl0ZXJhbFwiLCBcIlRoZSBub2RlIHR5cGUgXCIpO1xuICByZXR1cm4gcmVnRXhwTGl0ZXJhbChwYXR0ZXJuLCBmbGFncyk7XG59XG5mdW5jdGlvbiBSZXN0UHJvcGVydHkoYXJndW1lbnQpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJSZXN0UHJvcGVydHlcIiwgXCJSZXN0RWxlbWVudFwiLCBcIlRoZSBub2RlIHR5cGUgXCIpO1xuICByZXR1cm4gcmVzdEVsZW1lbnQoYXJndW1lbnQpO1xufVxuZnVuY3Rpb24gU3ByZWFkUHJvcGVydHkoYXJndW1lbnQpIHtcbiAgKDAsIF9kZXByZWNhdGlvbldhcm5pbmcuZGVmYXVsdCkoXCJTcHJlYWRQcm9wZXJ0eVwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJUaGUgbm9kZSB0eXBlIFwiKTtcbiAgcmV0dXJuIHNwcmVhZEVsZW1lbnQoYXJndW1lbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///48079\n')},76779:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "AnyTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.anyTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ArgumentPlaceholder", ({\n  enumerable: true,\n  get: function () {\n    return _index.argumentPlaceholder;\n  }\n}));\nObject.defineProperty(exports, "ArrayExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayExpression;\n  }\n}));\nObject.defineProperty(exports, "ArrayPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayPattern;\n  }\n}));\nObject.defineProperty(exports, "ArrayTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrayTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ArrowFunctionExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.arrowFunctionExpression;\n  }\n}));\nObject.defineProperty(exports, "AssignmentExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.assignmentExpression;\n  }\n}));\nObject.defineProperty(exports, "AssignmentPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.assignmentPattern;\n  }\n}));\nObject.defineProperty(exports, "AwaitExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.awaitExpression;\n  }\n}));\nObject.defineProperty(exports, "BigIntLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.bigIntLiteral;\n  }\n}));\nObject.defineProperty(exports, "BinaryExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.binaryExpression;\n  }\n}));\nObject.defineProperty(exports, "BindExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.bindExpression;\n  }\n}));\nObject.defineProperty(exports, "BlockStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.blockStatement;\n  }\n}));\nObject.defineProperty(exports, "BooleanLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteral;\n  }\n}));\nObject.defineProperty(exports, "BooleanLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "BooleanTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.booleanTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "BreakStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.breakStatement;\n  }\n}));\nObject.defineProperty(exports, "CallExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.callExpression;\n  }\n}));\nObject.defineProperty(exports, "CatchClause", ({\n  enumerable: true,\n  get: function () {\n    return _index.catchClause;\n  }\n}));\nObject.defineProperty(exports, "ClassAccessorProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.classAccessorProperty;\n  }\n}));\nObject.defineProperty(exports, "ClassBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.classBody;\n  }\n}));\nObject.defineProperty(exports, "ClassDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.classDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ClassExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.classExpression;\n  }\n}));\nObject.defineProperty(exports, "ClassImplements", ({\n  enumerable: true,\n  get: function () {\n    return _index.classImplements;\n  }\n}));\nObject.defineProperty(exports, "ClassMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.classMethod;\n  }\n}));\nObject.defineProperty(exports, "ClassPrivateMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateMethod;\n  }\n}));\nObject.defineProperty(exports, "ClassPrivateProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.classPrivateProperty;\n  }\n}));\nObject.defineProperty(exports, "ClassProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.classProperty;\n  }\n}));\nObject.defineProperty(exports, "ConditionalExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.conditionalExpression;\n  }\n}));\nObject.defineProperty(exports, "ContinueStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.continueStatement;\n  }\n}));\nObject.defineProperty(exports, "DebuggerStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.debuggerStatement;\n  }\n}));\nObject.defineProperty(exports, "DecimalLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.decimalLiteral;\n  }\n}));\nObject.defineProperty(exports, "DeclareClass", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareClass;\n  }\n}));\nObject.defineProperty(exports, "DeclareExportAllDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareExportAllDeclaration;\n  }\n}));\nObject.defineProperty(exports, "DeclareExportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareExportDeclaration;\n  }\n}));\nObject.defineProperty(exports, "DeclareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareFunction;\n  }\n}));\nObject.defineProperty(exports, "DeclareInterface", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareInterface;\n  }\n}));\nObject.defineProperty(exports, "DeclareModule", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareModule;\n  }\n}));\nObject.defineProperty(exports, "DeclareModuleExports", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareModuleExports;\n  }\n}));\nObject.defineProperty(exports, "DeclareOpaqueType", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareOpaqueType;\n  }\n}));\nObject.defineProperty(exports, "DeclareTypeAlias", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareTypeAlias;\n  }\n}));\nObject.defineProperty(exports, "DeclareVariable", ({\n  enumerable: true,\n  get: function () {\n    return _index.declareVariable;\n  }\n}));\nObject.defineProperty(exports, "DeclaredPredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.declaredPredicate;\n  }\n}));\nObject.defineProperty(exports, "Decorator", ({\n  enumerable: true,\n  get: function () {\n    return _index.decorator;\n  }\n}));\nObject.defineProperty(exports, "Directive", ({\n  enumerable: true,\n  get: function () {\n    return _index.directive;\n  }\n}));\nObject.defineProperty(exports, "DirectiveLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.directiveLiteral;\n  }\n}));\nObject.defineProperty(exports, "DoExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.doExpression;\n  }\n}));\nObject.defineProperty(exports, "DoWhileStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.doWhileStatement;\n  }\n}));\nObject.defineProperty(exports, "EmptyStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.emptyStatement;\n  }\n}));\nObject.defineProperty(exports, "EmptyTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.emptyTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "EnumBooleanBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanBody;\n  }\n}));\nObject.defineProperty(exports, "EnumBooleanMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumBooleanMember;\n  }\n}));\nObject.defineProperty(exports, "EnumDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumDeclaration;\n  }\n}));\nObject.defineProperty(exports, "EnumDefaultedMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumDefaultedMember;\n  }\n}));\nObject.defineProperty(exports, "EnumNumberBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberBody;\n  }\n}));\nObject.defineProperty(exports, "EnumNumberMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumNumberMember;\n  }\n}));\nObject.defineProperty(exports, "EnumStringBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumStringBody;\n  }\n}));\nObject.defineProperty(exports, "EnumStringMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumStringMember;\n  }\n}));\nObject.defineProperty(exports, "EnumSymbolBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.enumSymbolBody;\n  }\n}));\nObject.defineProperty(exports, "ExistsTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.existsTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ExportAllDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportAllDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportDefaultDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportDefaultSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportDefaultSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ExportNamedDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportNamedDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ExportNamespaceSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportNamespaceSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ExportSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.exportSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ExpressionStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.expressionStatement;\n  }\n}));\nObject.defineProperty(exports, "File", ({\n  enumerable: true,\n  get: function () {\n    return _index.file;\n  }\n}));\nObject.defineProperty(exports, "ForInStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forInStatement;\n  }\n}));\nObject.defineProperty(exports, "ForOfStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forOfStatement;\n  }\n}));\nObject.defineProperty(exports, "ForStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.forStatement;\n  }\n}));\nObject.defineProperty(exports, "FunctionDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionDeclaration;\n  }\n}));\nObject.defineProperty(exports, "FunctionExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionExpression;\n  }\n}));\nObject.defineProperty(exports, "FunctionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "FunctionTypeParam", ({\n  enumerable: true,\n  get: function () {\n    return _index.functionTypeParam;\n  }\n}));\nObject.defineProperty(exports, "GenericTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.genericTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "Identifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.identifier;\n  }\n}));\nObject.defineProperty(exports, "IfStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.ifStatement;\n  }\n}));\nObject.defineProperty(exports, "Import", ({\n  enumerable: true,\n  get: function () {\n    return _index.import;\n  }\n}));\nObject.defineProperty(exports, "ImportAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.importAttribute;\n  }\n}));\nObject.defineProperty(exports, "ImportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.importDeclaration;\n  }\n}));\nObject.defineProperty(exports, "ImportDefaultSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importDefaultSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ImportExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.importExpression;\n  }\n}));\nObject.defineProperty(exports, "ImportNamespaceSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importNamespaceSpecifier;\n  }\n}));\nObject.defineProperty(exports, "ImportSpecifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.importSpecifier;\n  }\n}));\nObject.defineProperty(exports, "IndexedAccessType", ({\n  enumerable: true,\n  get: function () {\n    return _index.indexedAccessType;\n  }\n}));\nObject.defineProperty(exports, "InferredPredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.inferredPredicate;\n  }\n}));\nObject.defineProperty(exports, "InterfaceDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceDeclaration;\n  }\n}));\nObject.defineProperty(exports, "InterfaceExtends", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceExtends;\n  }\n}));\nObject.defineProperty(exports, "InterfaceTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.interfaceTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "InterpreterDirective", ({\n  enumerable: true,\n  get: function () {\n    return _index.interpreterDirective;\n  }\n}));\nObject.defineProperty(exports, "IntersectionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.intersectionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "JSXAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxAttribute;\n  }\n}));\nObject.defineProperty(exports, "JSXClosingElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingElement;\n  }\n}));\nObject.defineProperty(exports, "JSXClosingFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxClosingFragment;\n  }\n}));\nObject.defineProperty(exports, "JSXElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxElement;\n  }\n}));\nObject.defineProperty(exports, "JSXEmptyExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxEmptyExpression;\n  }\n}));\nObject.defineProperty(exports, "JSXExpressionContainer", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxExpressionContainer;\n  }\n}));\nObject.defineProperty(exports, "JSXFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxFragment;\n  }\n}));\nObject.defineProperty(exports, "JSXIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxIdentifier;\n  }\n}));\nObject.defineProperty(exports, "JSXMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxMemberExpression;\n  }\n}));\nObject.defineProperty(exports, "JSXNamespacedName", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxNamespacedName;\n  }\n}));\nObject.defineProperty(exports, "JSXOpeningElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningElement;\n  }\n}));\nObject.defineProperty(exports, "JSXOpeningFragment", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxOpeningFragment;\n  }\n}));\nObject.defineProperty(exports, "JSXSpreadAttribute", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadAttribute;\n  }\n}));\nObject.defineProperty(exports, "JSXSpreadChild", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxSpreadChild;\n  }\n}));\nObject.defineProperty(exports, "JSXText", ({\n  enumerable: true,\n  get: function () {\n    return _index.jsxText;\n  }\n}));\nObject.defineProperty(exports, "LabeledStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.labeledStatement;\n  }\n}));\nObject.defineProperty(exports, "LogicalExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.logicalExpression;\n  }\n}));\nObject.defineProperty(exports, "MemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.memberExpression;\n  }\n}));\nObject.defineProperty(exports, "MetaProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.metaProperty;\n  }\n}));\nObject.defineProperty(exports, "MixedTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.mixedTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ModuleExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.moduleExpression;\n  }\n}));\nObject.defineProperty(exports, "NewExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.newExpression;\n  }\n}));\nObject.defineProperty(exports, "Noop", ({\n  enumerable: true,\n  get: function () {\n    return _index.noop;\n  }\n}));\nObject.defineProperty(exports, "NullLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteral;\n  }\n}));\nObject.defineProperty(exports, "NullLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NullableTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.nullableTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NumberLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteral;\n  }\n}));\nObject.defineProperty(exports, "NumberLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NumberTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.numberTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "NumericLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.numericLiteral;\n  }\n}));\nObject.defineProperty(exports, "ObjectExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectExpression;\n  }\n}));\nObject.defineProperty(exports, "ObjectMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectMethod;\n  }\n}));\nObject.defineProperty(exports, "ObjectPattern", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectPattern;\n  }\n}));\nObject.defineProperty(exports, "ObjectProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectProperty;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeCallProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeCallProperty;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeIndexer", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeIndexer;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeInternalSlot", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeInternalSlot;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeProperty;\n  }\n}));\nObject.defineProperty(exports, "ObjectTypeSpreadProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.objectTypeSpreadProperty;\n  }\n}));\nObject.defineProperty(exports, "OpaqueType", ({\n  enumerable: true,\n  get: function () {\n    return _index.opaqueType;\n  }\n}));\nObject.defineProperty(exports, "OptionalCallExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.optionalCallExpression;\n  }\n}));\nObject.defineProperty(exports, "OptionalIndexedAccessType", ({\n  enumerable: true,\n  get: function () {\n    return _index.optionalIndexedAccessType;\n  }\n}));\nObject.defineProperty(exports, "OptionalMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.optionalMemberExpression;\n  }\n}));\nObject.defineProperty(exports, "ParenthesizedExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.parenthesizedExpression;\n  }\n}));\nObject.defineProperty(exports, "PipelineBareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelineBareFunction;\n  }\n}));\nObject.defineProperty(exports, "PipelinePrimaryTopicReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelinePrimaryTopicReference;\n  }\n}));\nObject.defineProperty(exports, "PipelineTopicExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.pipelineTopicExpression;\n  }\n}));\nObject.defineProperty(exports, "Placeholder", ({\n  enumerable: true,\n  get: function () {\n    return _index.placeholder;\n  }\n}));\nObject.defineProperty(exports, "PrivateName", ({\n  enumerable: true,\n  get: function () {\n    return _index.privateName;\n  }\n}));\nObject.defineProperty(exports, "Program", ({\n  enumerable: true,\n  get: function () {\n    return _index.program;\n  }\n}));\nObject.defineProperty(exports, "QualifiedTypeIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.qualifiedTypeIdentifier;\n  }\n}));\nObject.defineProperty(exports, "RecordExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.recordExpression;\n  }\n}));\nObject.defineProperty(exports, "RegExpLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.regExpLiteral;\n  }\n}));\nObject.defineProperty(exports, "RegexLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.regexLiteral;\n  }\n}));\nObject.defineProperty(exports, "RestElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.restElement;\n  }\n}));\nObject.defineProperty(exports, "RestProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.restProperty;\n  }\n}));\nObject.defineProperty(exports, "ReturnStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.returnStatement;\n  }\n}));\nObject.defineProperty(exports, "SequenceExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.sequenceExpression;\n  }\n}));\nObject.defineProperty(exports, "SpreadElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.spreadElement;\n  }\n}));\nObject.defineProperty(exports, "SpreadProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.spreadProperty;\n  }\n}));\nObject.defineProperty(exports, "StaticBlock", ({\n  enumerable: true,\n  get: function () {\n    return _index.staticBlock;\n  }\n}));\nObject.defineProperty(exports, "StringLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteral;\n  }\n}));\nObject.defineProperty(exports, "StringLiteralTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringLiteralTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "StringTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.stringTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "Super", ({\n  enumerable: true,\n  get: function () {\n    return _index.super;\n  }\n}));\nObject.defineProperty(exports, "SwitchCase", ({\n  enumerable: true,\n  get: function () {\n    return _index.switchCase;\n  }\n}));\nObject.defineProperty(exports, "SwitchStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.switchStatement;\n  }\n}));\nObject.defineProperty(exports, "SymbolTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.symbolTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TSAnyKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsAnyKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSArrayType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsArrayType;\n  }\n}));\nObject.defineProperty(exports, "TSAsExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsAsExpression;\n  }\n}));\nObject.defineProperty(exports, "TSBigIntKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsBigIntKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSBooleanKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsBooleanKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSCallSignatureDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsCallSignatureDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSConditionalType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConditionalType;\n  }\n}));\nObject.defineProperty(exports, "TSConstructSignatureDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructSignatureDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSConstructorType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsConstructorType;\n  }\n}));\nObject.defineProperty(exports, "TSDeclareFunction", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareFunction;\n  }\n}));\nObject.defineProperty(exports, "TSDeclareMethod", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsDeclareMethod;\n  }\n}));\nObject.defineProperty(exports, "TSEnumDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSEnumMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsEnumMember;\n  }\n}));\nObject.defineProperty(exports, "TSExportAssignment", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExportAssignment;\n  }\n}));\nObject.defineProperty(exports, "TSExpressionWithTypeArguments", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExpressionWithTypeArguments;\n  }\n}));\nObject.defineProperty(exports, "TSExternalModuleReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsExternalModuleReference;\n  }\n}));\nObject.defineProperty(exports, "TSFunctionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsFunctionType;\n  }\n}));\nObject.defineProperty(exports, "TSImportEqualsDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsImportEqualsDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSImportType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsImportType;\n  }\n}));\nObject.defineProperty(exports, "TSIndexSignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexSignature;\n  }\n}));\nObject.defineProperty(exports, "TSIndexedAccessType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIndexedAccessType;\n  }\n}));\nObject.defineProperty(exports, "TSInferType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInferType;\n  }\n}));\nObject.defineProperty(exports, "TSInstantiationExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInstantiationExpression;\n  }\n}));\nObject.defineProperty(exports, "TSInterfaceBody", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceBody;\n  }\n}));\nObject.defineProperty(exports, "TSInterfaceDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsInterfaceDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSIntersectionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIntersectionType;\n  }\n}));\nObject.defineProperty(exports, "TSIntrinsicKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsIntrinsicKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSLiteralType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsLiteralType;\n  }\n}));\nObject.defineProperty(exports, "TSMappedType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsMappedType;\n  }\n}));\nObject.defineProperty(exports, "TSMethodSignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsMethodSignature;\n  }\n}));\nObject.defineProperty(exports, "TSModuleBlock", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleBlock;\n  }\n}));\nObject.defineProperty(exports, "TSModuleDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsModuleDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSNamedTupleMember", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNamedTupleMember;\n  }\n}));\nObject.defineProperty(exports, "TSNamespaceExportDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNamespaceExportDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSNeverKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNeverKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSNonNullExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNonNullExpression;\n  }\n}));\nObject.defineProperty(exports, "TSNullKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNullKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSNumberKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsNumberKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSObjectKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsObjectKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSOptionalType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsOptionalType;\n  }\n}));\nObject.defineProperty(exports, "TSParameterProperty", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsParameterProperty;\n  }\n}));\nObject.defineProperty(exports, "TSParenthesizedType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsParenthesizedType;\n  }\n}));\nObject.defineProperty(exports, "TSPropertySignature", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsPropertySignature;\n  }\n}));\nObject.defineProperty(exports, "TSQualifiedName", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsQualifiedName;\n  }\n}));\nObject.defineProperty(exports, "TSRestType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsRestType;\n  }\n}));\nObject.defineProperty(exports, "TSSatisfiesExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsSatisfiesExpression;\n  }\n}));\nObject.defineProperty(exports, "TSStringKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsStringKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSSymbolKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsSymbolKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSThisType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsThisType;\n  }\n}));\nObject.defineProperty(exports, "TSTupleType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTupleType;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAliasDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAliasDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TSTypeAssertion", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeAssertion;\n  }\n}));\nObject.defineProperty(exports, "TSTypeLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeLiteral;\n  }\n}));\nObject.defineProperty(exports, "TSTypeOperator", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeOperator;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameter", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameter;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameterDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TSTypeParameterInstantiation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeParameterInstantiation;\n  }\n}));\nObject.defineProperty(exports, "TSTypePredicate", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypePredicate;\n  }\n}));\nObject.defineProperty(exports, "TSTypeQuery", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeQuery;\n  }\n}));\nObject.defineProperty(exports, "TSTypeReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsTypeReference;\n  }\n}));\nObject.defineProperty(exports, "TSUndefinedKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUndefinedKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUnionType;\n  }\n}));\nObject.defineProperty(exports, "TSUnknownKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsUnknownKeyword;\n  }\n}));\nObject.defineProperty(exports, "TSVoidKeyword", ({\n  enumerable: true,\n  get: function () {\n    return _index.tsVoidKeyword;\n  }\n}));\nObject.defineProperty(exports, "TaggedTemplateExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.taggedTemplateExpression;\n  }\n}));\nObject.defineProperty(exports, "TemplateElement", ({\n  enumerable: true,\n  get: function () {\n    return _index.templateElement;\n  }\n}));\nObject.defineProperty(exports, "TemplateLiteral", ({\n  enumerable: true,\n  get: function () {\n    return _index.templateLiteral;\n  }\n}));\nObject.defineProperty(exports, "ThisExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.thisExpression;\n  }\n}));\nObject.defineProperty(exports, "ThisTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.thisTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "ThrowStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.throwStatement;\n  }\n}));\nObject.defineProperty(exports, "TopicReference", ({\n  enumerable: true,\n  get: function () {\n    return _index.topicReference;\n  }\n}));\nObject.defineProperty(exports, "TryStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.tryStatement;\n  }\n}));\nObject.defineProperty(exports, "TupleExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.tupleExpression;\n  }\n}));\nObject.defineProperty(exports, "TupleTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.tupleTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TypeAlias", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeAlias;\n  }\n}));\nObject.defineProperty(exports, "TypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "TypeCastExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeCastExpression;\n  }\n}));\nObject.defineProperty(exports, "TypeParameter", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameter;\n  }\n}));\nObject.defineProperty(exports, "TypeParameterDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterDeclaration;\n  }\n}));\nObject.defineProperty(exports, "TypeParameterInstantiation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeParameterInstantiation;\n  }\n}));\nObject.defineProperty(exports, "TypeofTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.typeofTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "UnaryExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.unaryExpression;\n  }\n}));\nObject.defineProperty(exports, "UnionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.unionTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "UpdateExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.updateExpression;\n  }\n}));\nObject.defineProperty(exports, "V8IntrinsicIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _index.v8IntrinsicIdentifier;\n  }\n}));\nObject.defineProperty(exports, "VariableDeclaration", ({\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclaration;\n  }\n}));\nObject.defineProperty(exports, "VariableDeclarator", ({\n  enumerable: true,\n  get: function () {\n    return _index.variableDeclarator;\n  }\n}));\nObject.defineProperty(exports, "Variance", ({\n  enumerable: true,\n  get: function () {\n    return _index.variance;\n  }\n}));\nObject.defineProperty(exports, "VoidTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _index.voidTypeAnnotation;\n  }\n}));\nObject.defineProperty(exports, "WhileStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.whileStatement;\n  }\n}));\nObject.defineProperty(exports, "WithStatement", ({\n  enumerable: true,\n  get: function () {\n    return _index.withStatement;\n  }\n}));\nObject.defineProperty(exports, "YieldExpression", ({\n  enumerable: true,\n  get: function () {\n    return _index.yieldExpression;\n  }\n}));\nvar _index = __webpack_require__(48079);\n\n//# sourceMappingURL=uppercase.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzY3NzkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0RBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0RBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUVBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0RBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseUNBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbUVBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaUVBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkRBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YscURBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMERBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0VBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNkNBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNERBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0RBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0RBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YseURBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsdURBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsNENBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0RBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsaURBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYSxtQkFBTyxDQUFDLEtBQVk7O0FBRWpDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL2dlbmVyYXRlZC91cHBlcmNhc2UuanM/NDA1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5hbnlUeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5hcmd1bWVudFBsYWNlaG9sZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFycmF5RXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguYXJyYXlFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFycmF5UGF0dGVyblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguYXJyYXlQYXR0ZXJuO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFycmF5VHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmFycmF5VHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmFycm93RnVuY3Rpb25FeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5hc3NpZ25tZW50RXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBc3NpZ25tZW50UGF0dGVyblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguYXNzaWdubWVudFBhdHRlcm47XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXdhaXRFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5hd2FpdEV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmlnSW50TGl0ZXJhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguYmlnSW50TGl0ZXJhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5iaW5hcnlFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpbmRFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5iaW5kRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCbG9ja1N0YXRlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguYmxvY2tTdGF0ZW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQm9vbGVhbkxpdGVyYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmJvb2xlYW5MaXRlcmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5ib29sZWFuVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQnJlYWtTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmJyZWFrU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5jYWxsRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYXRjaENsYXVzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguY2F0Y2hDbGF1c2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5jbGFzc0FjY2Vzc29yUHJvcGVydHk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xhc3NCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5jbGFzc0JvZHk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xhc3NEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguY2xhc3NEZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGFzc0V4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmNsYXNzRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGFzc0ltcGxlbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmNsYXNzSW1wbGVtZW50cztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGFzc01ldGhvZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguY2xhc3NNZXRob2Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5jbGFzc1ByaXZhdGVNZXRob2Q7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmNsYXNzUHJpdmF0ZVByb3BlcnR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsYXNzUHJvcGVydHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmNsYXNzUHJvcGVydHk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5jb25kaXRpb25hbEV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29udGludWVTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmNvbnRpbnVlU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWJ1Z2dlclN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNpbWFsTGl0ZXJhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGVjaW1hbExpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZUNsYXNzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlQ2xhc3M7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlRXhwb3J0RGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZUZ1bmN0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlRnVuY3Rpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZUludGVyZmFjZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGVjbGFyZUludGVyZmFjZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJlTW9kdWxlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlTW9kdWxlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNsYXJlTW9kdWxlRXhwb3J0cztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJlT3BhcXVlVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGVjbGFyZU9wYXF1ZVR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjbGFyZVR5cGVBbGlhc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGVjbGFyZVR5cGVBbGlhcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJlVmFyaWFibGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmRlY2xhcmVWYXJpYWJsZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWNsYXJlZFByZWRpY2F0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGVjbGFyZWRQcmVkaWNhdGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVjb3JhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kZWNvcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlyZWN0aXZlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kaXJlY3RpdmU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlyZWN0aXZlTGl0ZXJhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZGlyZWN0aXZlTGl0ZXJhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb0V4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmRvRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEb1doaWxlU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5kb1doaWxlU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVtcHR5U3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbXB0eVN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbXB0eVR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudW1Cb29sZWFuQm9keVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZW51bUJvb2xlYW5Cb2R5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudW1Cb29sZWFuTWVtYmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtQm9vbGVhbk1lbWJlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnVtRGVjbGFyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmVudW1EZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtRGVmYXVsdGVkTWVtYmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudW1OdW1iZXJCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtTnVtYmVyQm9keTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnVtTnVtYmVyTWVtYmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtTnVtYmVyTWVtYmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudW1TdHJpbmdCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtU3RyaW5nQm9keTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbnVtU3RyaW5nTWVtYmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtU3RyaW5nTWVtYmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVudW1TeW1ib2xCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5lbnVtU3ltYm9sQm9keTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZXhpc3RzVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmV4cG9ydEFsbERlY2xhcmF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmV4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeHBvcnRTcGVjaWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmV4cG9ydFNwZWNpZmllcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5leHByZXNzaW9uU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZpbGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmZpbGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRm9ySW5TdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmZvckluU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZvck9mU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5mb3JPZlN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGb3JTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmZvclN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5mdW5jdGlvbkRlY2xhcmF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZnVuY3Rpb25FeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmZ1bmN0aW9uVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmZ1bmN0aW9uVHlwZVBhcmFtO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguZ2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmlkZW50aWZpZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSWZTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmlmU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcG9ydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguaW1wb3J0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcG9ydEF0dHJpYnV0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguaW1wb3J0QXR0cmlidXRlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcG9ydERlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbXBvcnREZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltcG9ydEV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmltcG9ydEV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1wb3J0U3BlY2lmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbXBvcnRTcGVjaWZpZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5kZXhlZEFjY2Vzc1R5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmluZGV4ZWRBY2Nlc3NUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkluZmVycmVkUHJlZGljYXRlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbmZlcnJlZFByZWRpY2F0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguaW50ZXJmYWNlRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJmYWNlRXh0ZW5kc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguaW50ZXJmYWNlRXh0ZW5kcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguaW50ZXJmYWNlVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmludGVycHJldGVyRGlyZWN0aXZlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5pbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hBdHRyaWJ1dGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeEF0dHJpYnV0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hDbG9zaW5nRWxlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguanN4Q2xvc2luZ0VsZW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5qc3hDbG9zaW5nRnJhZ21lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNYRWxlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguanN4RWxlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hFbXB0eUV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeEVtcHR5RXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5qc3hFeHByZXNzaW9uQ29udGFpbmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTWEZyYWdtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5qc3hGcmFnbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hJZGVudGlmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5qc3hJZGVudGlmaWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeE1lbWJlckV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeE5hbWVzcGFjZWROYW1lO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTWE9wZW5pbmdFbGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5qc3hPcGVuaW5nRWxlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeE9wZW5pbmdGcmFnbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LmpzeFNwcmVhZEF0dHJpYnV0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU1hTcHJlYWRDaGlsZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguanN4U3ByZWFkQ2hpbGQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNYVGV4dFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguanN4VGV4dDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMYWJlbGVkU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5sYWJlbGVkU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxvZ2ljYWxFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5sb2dpY2FsRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5tZW1iZXJFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldGFQcm9wZXJ0eVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgubWV0YVByb3BlcnR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1peGVkVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm1peGVkVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTW9kdWxlRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgubW9kdWxlRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOZXdFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5uZXdFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5vb3BcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm5vb3A7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbExpdGVyYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm51bGxMaXRlcmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm51bGxMaXRlcmFsVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgubnVsbGFibGVUeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdW1iZXJMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5udW1iZXJMaXRlcmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgubnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5udW1iZXJUeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdW1lcmljTGl0ZXJhbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgubnVtZXJpY0xpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT2JqZWN0RXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub2JqZWN0RXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RNZXRob2RcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm9iamVjdE1ldGhvZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RQYXR0ZXJuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5vYmplY3RQYXR0ZXJuO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9iamVjdFByb3BlcnR5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5vYmplY3RQcm9wZXJ0eTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub2JqZWN0VHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub2JqZWN0VHlwZUNhbGxQcm9wZXJ0eTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RUeXBlSW5kZXhlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub2JqZWN0VHlwZUluZGV4ZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub2JqZWN0VHlwZUludGVybmFsU2xvdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RUeXBlUHJvcGVydHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm9iamVjdFR5cGVQcm9wZXJ0eTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPcGFxdWVUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5vcGFxdWVUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm9wdGlvbmFsQ2FsbEV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgub3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4Lm9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgucGFyZW50aGVzaXplZEV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnBpcGVsaW5lQmFyZUZ1bmN0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5waXBlbGluZVByaW1hcnlUb3BpY1JlZmVyZW5jZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgucGlwZWxpbmVUb3BpY0V4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGxhY2Vob2xkZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnBsYWNlaG9sZGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByaXZhdGVOYW1lXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5wcml2YXRlTmFtZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmFtXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5wcm9ncmFtO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5xdWFsaWZpZWRUeXBlSWRlbnRpZmllcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWNvcmRFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5yZWNvcmRFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlZ0V4cExpdGVyYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnJlZ0V4cExpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVnZXhMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5yZWdleExpdGVyYWw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzdEVsZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnJlc3RFbGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlc3RQcm9wZXJ0eVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgucmVzdFByb3BlcnR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJldHVyblN0YXRlbWVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgucmV0dXJuU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguc2VxdWVuY2VFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNwcmVhZEVsZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnNwcmVhZEVsZW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3ByZWFkUHJvcGVydHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnNwcmVhZFByb3BlcnR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXRpY0Jsb2NrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5zdGF0aWNCbG9jaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdHJpbmdMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5zdHJpbmdMaXRlcmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguc3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC5zdHJpbmdUeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdXBlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguc3VwZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3dpdGNoQ2FzZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguc3dpdGNoQ2FzZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTd2l0Y2hTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnN3aXRjaFN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXguc3ltYm9sVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNBbnlLZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0FueUtleXdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNBcnJheVR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzQXJyYXlUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTQXNFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0FzRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0JpZ0ludEtleXdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzQmlnSW50S2V5d29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0Jvb2xlYW5LZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0Jvb2xlYW5LZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0NvbmRpdGlvbmFsVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNDb25kaXRpb25hbFR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0NvbnN0cnVjdG9yVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNDb25zdHJ1Y3RvclR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzRGVjbGFyZUZ1bmN0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTRGVjbGFyZU1ldGhvZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNEZWNsYXJlTWV0aG9kO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTRW51bURlY2xhcmF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0VudW1EZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0VudW1NZW1iZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzRW51bU1lbWJlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzRXhwb3J0QXNzaWdubWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0Z1bmN0aW9uVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNGdW5jdGlvblR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0ltcG9ydFR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW1wb3J0VHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0luZGV4U2lnbmF0dXJlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0luZGV4U2lnbmF0dXJlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW5kZXhlZEFjY2Vzc1R5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNJbmZlclR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW5mZXJUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW5zdGFudGlhdGlvbkV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNJbnRlcmZhY2VCb2R5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0ludGVyZmFjZUJvZHk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0ludGVyc2VjdGlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW50ZXJzZWN0aW9uVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0ludHJpbnNpY0tleXdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzSW50cmluc2ljS2V5d29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU0xpdGVyYWxUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c0xpdGVyYWxUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTTWFwcGVkVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNNYXBwZWRUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c01ldGhvZFNpZ25hdHVyZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU01vZHVsZUJsb2NrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c01vZHVsZUJsb2NrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzTW9kdWxlRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c05hbWVkVHVwbGVNZW1iZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU05ldmVyS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNOZXZlcktleXdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNOb25OdWxsRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU051bGxLZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c051bGxLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTTnVtYmVyS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNOdW1iZXJLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTT2JqZWN0S2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNPYmplY3RLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTT3B0aW9uYWxUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c09wdGlvbmFsVHlwZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1BhcmFtZXRlclByb3BlcnR5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTUGFyZW50aGVzaXplZFR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzUGFyZW50aGVzaXplZFR5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNQcm9wZXJ0eVNpZ25hdHVyZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1F1YWxpZmllZE5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzUXVhbGlmaWVkTmFtZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1Jlc3RUeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1Jlc3RUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNTYXRpc2ZpZXNFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTU3RyaW5nS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNTdHJpbmdLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTU3ltYm9sS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNTeW1ib2xLZXl3b3JkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTVGhpc1R5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVGhpc1R5cGU7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNUdXBsZVR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVHVwbGVUeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVHlwZUFsaWFzRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNUeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVBc3NlcnRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVHlwZUFzc2VydGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVMaXRlcmFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1R5cGVMaXRlcmFsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTVHlwZU9wZXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1R5cGVPcGVyYXRvcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVQYXJhbWV0ZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVHlwZVBhcmFtZXRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVQcmVkaWNhdGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVHlwZVByZWRpY2F0ZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUU1R5cGVRdWVyeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNUeXBlUXVlcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNUeXBlUmVmZXJlbmNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1R5cGVSZWZlcmVuY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50c1VuZGVmaW5lZEtleXdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNVbmlvblR5cGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVW5pb25UeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRTVW5rbm93bktleXdvcmRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRzVW5rbm93bktleXdvcmQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVFNWb2lkS2V5d29yZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHNWb2lkS2V5d29yZDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZW1wbGF0ZUVsZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRlbXBsYXRlRWxlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUZW1wbGF0ZUxpdGVyYWxcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRlbXBsYXRlTGl0ZXJhbDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUaGlzRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudGhpc0V4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50aGlzVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGhyb3dTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRocm93U3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRvcGljUmVmZXJlbmNlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50b3BpY1JlZmVyZW5jZTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcnlTdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnRyeVN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUdXBsZUV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnR1cGxlRXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50dXBsZVR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVBbGlhc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHlwZUFsaWFzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50eXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnR5cGVDYXN0RXhwcmVzc2lvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlUGFyYW1ldGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50eXBlUGFyYW1ldGVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC50eXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudHlwZW9mVHlwZUFubm90YXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC51bmFyeUV4cHJlc3Npb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudW5pb25UeXBlQW5ub3RhdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVcGRhdGVFeHByZXNzaW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC51cGRhdGVFeHByZXNzaW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudjhJbnRyaW5zaWNJZGVudGlmaWVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnZhcmlhYmxlRGVjbGFyYXRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFyaWFibGVEZWNsYXJhdG9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC52YXJpYWJsZURlY2xhcmF0b3I7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmFyaWFuY2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luZGV4LnZhcmlhbmNlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgudm9pZFR5cGVBbm5vdGF0aW9uO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIldoaWxlU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC53aGlsZVN0YXRlbWVudDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJXaXRoU3RhdGVtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmRleC53aXRoU3RhdGVtZW50O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIllpZWxkRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5kZXgueWllbGRFeHByZXNzaW9uO1xuICB9XG59KTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9pbmRleC5qc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBwZXJjYXNlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76779\n')},10985:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.buildUndefinedNode = buildUndefinedNode;\nvar _index = __webpack_require__(48079);\nfunction buildUndefinedNode() {\n  return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);\n}\n\n//# sourceMappingURL=productions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5ODUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLGFBQWEsbUJBQU8sQ0FBQyxLQUFzQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvYnVpbGRlcnMvcHJvZHVjdGlvbnMuanM/ZGI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuYnVpbGRVbmRlZmluZWROb2RlID0gYnVpbGRVbmRlZmluZWROb2RlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGJ1aWxkVW5kZWZpbmVkTm9kZSgpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXgudW5hcnlFeHByZXNzaW9uKShcInZvaWRcIiwgKDAsIF9pbmRleC5udW1lcmljTGl0ZXJhbCkoMCksIHRydWUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9kdWN0aW9ucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///10985\n')},49018:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = buildChildren;\nvar _index = __webpack_require__(98960);\nvar _cleanJSXElementLiteralChild = __webpack_require__(53043);\nfunction buildChildren(node) {\n  const elements = [];\n  for (let i = 0; i < node.children.length; i++) {\n    let child = node.children[i];\n    if ((0, _index.isJSXText)(child)) {\n      (0, _cleanJSXElementLiteralChild.default)(child, elements);\n      continue;\n    }\n    if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;\n    if ((0, _index.isJSXEmptyExpression)(child)) continue;\n    elements.push(child);\n  }\n  return elements;\n}\n\n//# sourceMappingURL=buildChildren.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkwMTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBcUM7QUFDMUQsbUNBQW1DLG1CQUFPLENBQUMsS0FBa0Q7QUFDN0Y7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9idWlsZGVycy9yZWFjdC9idWlsZENoaWxkcmVuLmpzP2U5ZTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBidWlsZENoaWxkcmVuO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi8uLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfY2xlYW5KU1hFbGVtZW50TGl0ZXJhbENoaWxkID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL3JlYWN0L2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZC5qc1wiKTtcbmZ1bmN0aW9uIGJ1aWxkQ2hpbGRyZW4obm9kZSkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgIGlmICgoMCwgX2luZGV4LmlzSlNYVGV4dCkoY2hpbGQpKSB7XG4gICAgICAoMCwgX2NsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZC5kZWZhdWx0KShjaGlsZCwgZWxlbWVudHMpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcikoY2hpbGQpKSBjaGlsZCA9IGNoaWxkLmV4cHJlc3Npb247XG4gICAgaWYgKCgwLCBfaW5kZXguaXNKU1hFbXB0eUV4cHJlc3Npb24pKGNoaWxkKSkgY29udGludWU7XG4gICAgZWxlbWVudHMucHVzaChjaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZENoaWxkcmVuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49018\n')},46049:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = createTSUnionType;\nvar _index = __webpack_require__(48079);\nvar _removeTypeDuplicates = __webpack_require__(78812);\nvar _index2 = __webpack_require__(98960);\nfunction createTSUnionType(typeAnnotations) {\n  const types = typeAnnotations.map(type => {\n    return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;\n  });\n  const flattened = (0, _removeTypeDuplicates.default)(types);\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return (0, _index.tsUnionType)(flattened);\n  }\n}\n\n//# sourceMappingURL=createTSUnionType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYwNDkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUMsNEJBQTRCLG1CQUFPLENBQUMsS0FBd0Q7QUFDNUYsY0FBYyxtQkFBTyxDQUFDLEtBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2J1aWxkZXJzL3R5cGVzY3JpcHQvY3JlYXRlVFNVbmlvblR5cGUuanM/ZjYyZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRTVW5pb25UeXBlO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX3JlbW92ZVR5cGVEdXBsaWNhdGVzID0gcmVxdWlyZShcIi4uLy4uL21vZGlmaWNhdGlvbnMvdHlwZXNjcmlwdC9yZW1vdmVUeXBlRHVwbGljYXRlcy5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gY3JlYXRlVFNVbmlvblR5cGUodHlwZUFubm90YXRpb25zKSB7XG4gIGNvbnN0IHR5cGVzID0gdHlwZUFubm90YXRpb25zLm1hcCh0eXBlID0+IHtcbiAgICByZXR1cm4gKDAsIF9pbmRleDIuaXNUU1R5cGVBbm5vdGF0aW9uKSh0eXBlKSA/IHR5cGUudHlwZUFubm90YXRpb24gOiB0eXBlO1xuICB9KTtcbiAgY29uc3QgZmxhdHRlbmVkID0gKDAsIF9yZW1vdmVUeXBlRHVwbGljYXRlcy5kZWZhdWx0KSh0eXBlcyk7XG4gIGlmIChmbGF0dGVuZWQubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC50c1VuaW9uVHlwZSkoZmxhdHRlbmVkKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVUU1VuaW9uVHlwZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46049\n')},2107:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = clone;\nvar _cloneNode = __webpack_require__(85279);\nfunction clone(node) {\n  return (0, _cloneNode.default)(node, false);\n}\n\n//# sourceMappingURL=clone.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEwNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGlCQUFpQixtQkFBTyxDQUFDLEtBQWdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZS5qcz9hOTIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmU7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKG5vZGUsIGZhbHNlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2107\n')},10245:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = cloneDeep;\nvar _cloneNode = __webpack_require__(85279);\nfunction cloneDeep(node) {\n  return (0, _cloneNode.default)(node);\n}\n\n//# sourceMappingURL=cloneDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyNDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxLQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVEZWVwLmpzPzVkYjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZURlZXA7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lRGVlcChub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVEZWVwLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10245\n')},35299:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = cloneDeepWithoutLoc;\nvar _cloneNode = __webpack_require__(85279);\nfunction cloneDeepWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, true, true);\n}\n\n//# sourceMappingURL=cloneDeepWithoutLoc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUyOTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxLQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVEZWVwV2l0aG91dExvYy5qcz82ZmQ5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY2xvbmVEZWVwV2l0aG91dExvYztcbnZhciBfY2xvbmVOb2RlID0gcmVxdWlyZShcIi4vY2xvbmVOb2RlLmpzXCIpO1xuZnVuY3Rpb24gY2xvbmVEZWVwV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCB0cnVlLCB0cnVlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xvbmVEZWVwV2l0aG91dExvYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35299\n')},85279:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = cloneNode;\nvar _index = __webpack_require__(39793);\nvar _index2 = __webpack_require__(98960);\nconst {\n  hasOwn\n} = {\n  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)\n};\nfunction cloneIfNode(obj, deep, withoutLoc, commentsCache) {\n  if (obj && typeof obj.type === "string") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n  return obj;\n}\nfunction cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\nfunction cloneNode(node, deep = true, withoutLoc = false) {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\nfunction cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {\n  if (!node) return node;\n  const {\n    type\n  } = node;\n  const newNode = {\n    type: node.type\n  };\n  if ((0, _index2.isIdentifier)(node)) {\n    newNode.name = node.name;\n    if (hasOwn(node, "optional") && typeof node.optional === "boolean") {\n      newNode.optional = node.optional;\n    }\n    if (hasOwn(node, "typeAnnotation")) {\n      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;\n    }\n    if (hasOwn(node, "decorators")) {\n      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;\n    }\n  } else if (!hasOwn(_index.NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: "${type}"`);\n  } else {\n    for (const field of Object.keys(_index.NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);\n        } else {\n          newNode[field] = node[field];\n        }\n      }\n    }\n  }\n  if (hasOwn(node, "loc")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, "leadingComments")) {\n    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, "innerComments")) {\n    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, "trailingComments")) {\n    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);\n  }\n  if (hasOwn(node, "extra")) {\n    newNode.extra = Object.assign({}, node.extra);\n  }\n  return newNode;\n}\nfunction maybeCloneComments(comments, deep, withoutLoc, commentsCache) {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n    const {\n      type,\n      value,\n      loc\n    } = comment;\n    const ret = {\n      type,\n      value,\n      loc\n    };\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n    commentsCache.set(comment, ret);\n    return ret;\n  });\n}\n\n//# sourceMappingURL=cloneNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUyNzkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLEtBQWtDO0FBQ3hEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkNBQTJDLEtBQUs7QUFDaEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jbG9uZS9jbG9uZU5vZGUuanM/OTk5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lTm9kZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmNvbnN0IHtcbiAgaGFzT3duXG59ID0ge1xuICBoYXNPd246IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KVxufTtcbmZ1bmN0aW9uIGNsb25lSWZOb2RlKG9iaiwgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSkge1xuICBpZiAob2JqICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjbG9uZU5vZGVJbnRlcm5hbChvYmosIGRlZXAsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBjbG9uZUlmTm9kZU9yQXJyYXkob2JqLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLm1hcChub2RlID0+IGNsb25lSWZOb2RlKG5vZGUsIGRlZXAsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpKTtcbiAgfVxuICByZXR1cm4gY2xvbmVJZk5vZGUob2JqLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKTtcbn1cbmZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCBkZWVwID0gdHJ1ZSwgd2l0aG91dExvYyA9IGZhbHNlKSB7XG4gIHJldHVybiBjbG9uZU5vZGVJbnRlcm5hbChub2RlLCBkZWVwLCB3aXRob3V0TG9jLCBuZXcgTWFwKCkpO1xufVxuZnVuY3Rpb24gY2xvbmVOb2RlSW50ZXJuYWwobm9kZSwgZGVlcCA9IHRydWUsIHdpdGhvdXRMb2MgPSBmYWxzZSwgY29tbWVudHNDYWNoZSkge1xuICBpZiAoIW5vZGUpIHJldHVybiBub2RlO1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gbm9kZTtcbiAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICB0eXBlOiBub2RlLnR5cGVcbiAgfTtcbiAgaWYgKCgwLCBfaW5kZXgyLmlzSWRlbnRpZmllcikobm9kZSkpIHtcbiAgICBuZXdOb2RlLm5hbWUgPSBub2RlLm5hbWU7XG4gICAgaWYgKGhhc093bihub2RlLCBcIm9wdGlvbmFsXCIpICYmIHR5cGVvZiBub2RlLm9wdGlvbmFsID09PSBcImJvb2xlYW5cIikge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IG5vZGUub3B0aW9uYWw7XG4gICAgfVxuICAgIGlmIChoYXNPd24obm9kZSwgXCJ0eXBlQW5ub3RhdGlvblwiKSkge1xuICAgICAgbmV3Tm9kZS50eXBlQW5ub3RhdGlvbiA9IGRlZXAgPyBjbG9uZUlmTm9kZU9yQXJyYXkobm9kZS50eXBlQW5ub3RhdGlvbiwgdHJ1ZSwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSkgOiBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIH1cbiAgICBpZiAoaGFzT3duKG5vZGUsIFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgbmV3Tm9kZS5kZWNvcmF0b3JzID0gZGVlcCA/IGNsb25lSWZOb2RlT3JBcnJheShub2RlLmRlY29yYXRvcnMsIHRydWUsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpIDogbm9kZS5kZWNvcmF0b3JzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghaGFzT3duKF9pbmRleC5OT0RFX0ZJRUxEUywgdHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbm9kZSB0eXBlOiBcIiR7dHlwZX1cImApO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgT2JqZWN0LmtleXMoX2luZGV4Lk5PREVfRklFTERTW3R5cGVdKSkge1xuICAgICAgaWYgKGhhc093bihub2RlLCBmaWVsZCkpIHtcbiAgICAgICAgaWYgKGRlZXApIHtcbiAgICAgICAgICBuZXdOb2RlW2ZpZWxkXSA9ICgwLCBfaW5kZXgyLmlzRmlsZSkobm9kZSkgJiYgZmllbGQgPT09IFwiY29tbWVudHNcIiA/IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKSA6IGNsb25lSWZOb2RlT3JBcnJheShub2RlW2ZpZWxkXSwgdHJ1ZSwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3Tm9kZVtmaWVsZF0gPSBub2RlW2ZpZWxkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaGFzT3duKG5vZGUsIFwibG9jXCIpKSB7XG4gICAgaWYgKHdpdGhvdXRMb2MpIHtcbiAgICAgIG5ld05vZGUubG9jID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5sb2MgPSBub2RlLmxvYztcbiAgICB9XG4gIH1cbiAgaWYgKGhhc093bihub2RlLCBcImxlYWRpbmdDb21tZW50c1wiKSkge1xuICAgIG5ld05vZGUubGVhZGluZ0NvbW1lbnRzID0gbWF5YmVDbG9uZUNvbW1lbnRzKG5vZGUubGVhZGluZ0NvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKTtcbiAgfVxuICBpZiAoaGFzT3duKG5vZGUsIFwiaW5uZXJDb21tZW50c1wiKSkge1xuICAgIG5ld05vZGUuaW5uZXJDb21tZW50cyA9IG1heWJlQ2xvbmVDb21tZW50cyhub2RlLmlubmVyQ29tbWVudHMsIGRlZXAsIHdpdGhvdXRMb2MsIGNvbW1lbnRzQ2FjaGUpO1xuICB9XG4gIGlmIChoYXNPd24obm9kZSwgXCJ0cmFpbGluZ0NvbW1lbnRzXCIpKSB7XG4gICAgbmV3Tm9kZS50cmFpbGluZ0NvbW1lbnRzID0gbWF5YmVDbG9uZUNvbW1lbnRzKG5vZGUudHJhaWxpbmdDb21tZW50cywgZGVlcCwgd2l0aG91dExvYywgY29tbWVudHNDYWNoZSk7XG4gIH1cbiAgaWYgKGhhc093bihub2RlLCBcImV4dHJhXCIpKSB7XG4gICAgbmV3Tm9kZS5leHRyYSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUuZXh0cmEpO1xuICB9XG4gIHJldHVybiBuZXdOb2RlO1xufVxuZnVuY3Rpb24gbWF5YmVDbG9uZUNvbW1lbnRzKGNvbW1lbnRzLCBkZWVwLCB3aXRob3V0TG9jLCBjb21tZW50c0NhY2hlKSB7XG4gIGlmICghY29tbWVudHMgfHwgIWRlZXApIHtcbiAgICByZXR1cm4gY29tbWVudHM7XG4gIH1cbiAgcmV0dXJuIGNvbW1lbnRzLm1hcChjb21tZW50ID0+IHtcbiAgICBjb25zdCBjYWNoZSA9IGNvbW1lbnRzQ2FjaGUuZ2V0KGNvbW1lbnQpO1xuICAgIGlmIChjYWNoZSkgcmV0dXJuIGNhY2hlO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY1xuICAgIH0gPSBjb21tZW50O1xuICAgIGNvbnN0IHJldCA9IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIGxvY1xuICAgIH07XG4gICAgaWYgKHdpdGhvdXRMb2MpIHtcbiAgICAgIHJldC5sb2MgPSBudWxsO1xuICAgIH1cbiAgICBjb21tZW50c0NhY2hlLnNldChjb21tZW50LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbG9uZU5vZGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///85279\n')},62425:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = cloneWithoutLoc;\nvar _cloneNode = __webpack_require__(85279);\nfunction cloneWithoutLoc(node) {\n  return (0, _cloneNode.default)(node, false, true);\n}\n\n//# sourceMappingURL=cloneWithoutLoc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI0MjUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxLQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY2xvbmUvY2xvbmVXaXRob3V0TG9jLmpzPzM3MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBjbG9uZVdpdGhvdXRMb2M7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuL2Nsb25lTm9kZS5qc1wiKTtcbmZ1bmN0aW9uIGNsb25lV2l0aG91dExvYyhub2RlKSB7XG4gIHJldHVybiAoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShub2RlLCBmYWxzZSwgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lV2l0aG91dExvYy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62425\n')},76211:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = addComment;\nvar _addComments = __webpack_require__(52598);\nfunction addComment(node, type, content, line) {\n  return (0, _addComments.default)(node, type, [{\n    type: line ? "CommentLine" : "CommentBlock",\n    value: content\n  }]);\n}\n\n//# sourceMappingURL=addComment.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYyMTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixtQkFBbUIsbUJBQU8sQ0FBQyxLQUFrQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb21tZW50cy9hZGRDb21tZW50LmpzPzQzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhZGRDb21tZW50O1xudmFyIF9hZGRDb21tZW50cyA9IHJlcXVpcmUoXCIuL2FkZENvbW1lbnRzLmpzXCIpO1xuZnVuY3Rpb24gYWRkQ29tbWVudChub2RlLCB0eXBlLCBjb250ZW50LCBsaW5lKSB7XG4gIHJldHVybiAoMCwgX2FkZENvbW1lbnRzLmRlZmF1bHQpKG5vZGUsIHR5cGUsIFt7XG4gICAgdHlwZTogbGluZSA/IFwiQ29tbWVudExpbmVcIiA6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgdmFsdWU6IGNvbnRlbnRcbiAgfV0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGRDb21tZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///76211\n')},52598:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = addComments;\nfunction addComments(node, type, comments) {\n  if (!comments || !node) return node;\n  const key = `${type}Comments`;\n  if (node[key]) {\n    if (type === "leading") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n  return node;\n}\n\n//# sourceMappingURL=addComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI1OTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0EsaUJBQWlCLEtBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvYWRkQ29tbWVudHMuanM/ZTYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFkZENvbW1lbnRzO1xuZnVuY3Rpb24gYWRkQ29tbWVudHMobm9kZSwgdHlwZSwgY29tbWVudHMpIHtcbiAgaWYgKCFjb21tZW50cyB8fCAhbm9kZSkgcmV0dXJuIG5vZGU7XG4gIGNvbnN0IGtleSA9IGAke3R5cGV9Q29tbWVudHNgO1xuICBpZiAobm9kZVtrZXldKSB7XG4gICAgaWYgKHR5cGUgPT09IFwibGVhZGluZ1wiKSB7XG4gICAgICBub2RlW2tleV0gPSBjb21tZW50cy5jb25jYXQobm9kZVtrZXldKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZVtrZXldLnB1c2goLi4uY29tbWVudHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlW2tleV0gPSBjb21tZW50cztcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkQ29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52598\n')},7932:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inheritInnerComments;\nvar _inherit = __webpack_require__(73205);\nfunction inheritInnerComments(child, parent) {\n  (0, _inherit.default)("innerComments", child, parent);\n}\n\n//# sourceMappingURL=inheritInnerComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkzMi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGVBQWUsbUJBQU8sQ0FBQyxLQUFxQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanM/MTc3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRJbm5lckNvbW1lbnRzO1xudmFyIF9pbmhlcml0ID0gcmVxdWlyZShcIi4uL3V0aWxzL2luaGVyaXQuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0SW5uZXJDb21tZW50cyhjaGlsZCwgcGFyZW50KSB7XG4gICgwLCBfaW5oZXJpdC5kZWZhdWx0KShcImlubmVyQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRJbm5lckNvbW1lbnRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7932\n')},55766:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inheritLeadingComments;\nvar _inherit = __webpack_require__(73205);\nfunction inheritLeadingComments(child, parent) {\n  (0, _inherit.default)("leadingComments", child, parent);\n}\n\n//# sourceMappingURL=inheritLeadingComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTU3NjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2luaGVyaXRMZWFkaW5nQ29tbWVudHMuanM/ZmRkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRMZWFkaW5nQ29tbWVudHM7XG52YXIgX2luaGVyaXQgPSByZXF1aXJlKFwiLi4vdXRpbHMvaW5oZXJpdC5qc1wiKTtcbmZ1bmN0aW9uIGluaGVyaXRMZWFkaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJsZWFkaW5nQ29tbWVudHNcIiwgY2hpbGQsIHBhcmVudCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRMZWFkaW5nQ29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///55766\n')},15586:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inheritTrailingComments;\nvar _inherit = __webpack_require__(73205);\nfunction inheritTrailingComments(child, parent) {\n  (0, _inherit.default)("trailingComments", child, parent);\n}\n\n//# sourceMappingURL=inheritTrailingComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1ODYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBcUI7QUFDNUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbW1lbnRzL2luaGVyaXRUcmFpbGluZ0NvbW1lbnRzLmpzPzg4ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpbmhlcml0VHJhaWxpbmdDb21tZW50cztcbnZhciBfaW5oZXJpdCA9IHJlcXVpcmUoXCIuLi91dGlscy9pbmhlcml0LmpzXCIpO1xuZnVuY3Rpb24gaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMoY2hpbGQsIHBhcmVudCkge1xuICAoMCwgX2luaGVyaXQuZGVmYXVsdCkoXCJ0cmFpbGluZ0NvbW1lbnRzXCIsIGNoaWxkLCBwYXJlbnQpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15586\n')},18125:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inheritsComments;\nvar _inheritTrailingComments = __webpack_require__(15586);\nvar _inheritLeadingComments = __webpack_require__(55766);\nvar _inheritInnerComments = __webpack_require__(7932);\nfunction inheritsComments(child, parent) {\n  (0, _inheritTrailingComments.default)(child, parent);\n  (0, _inheritLeadingComments.default)(child, parent);\n  (0, _inheritInnerComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inheritsComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxMjUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZiwrQkFBK0IsbUJBQU8sQ0FBQyxLQUE4QjtBQUNyRSw4QkFBOEIsbUJBQU8sQ0FBQyxLQUE2QjtBQUNuRSw0QkFBNEIsbUJBQU8sQ0FBQyxJQUEyQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvaW5oZXJpdHNDb21tZW50cy5qcz8xNzI1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaW5oZXJpdHNDb21tZW50cztcbnZhciBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qc1wiKTtcbnZhciBfaW5oZXJpdExlYWRpbmdDb21tZW50cyA9IHJlcXVpcmUoXCIuL2luaGVyaXRMZWFkaW5nQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gcmVxdWlyZShcIi4vaW5oZXJpdElubmVyQ29tbWVudHMuanNcIik7XG5mdW5jdGlvbiBpbmhlcml0c0NvbW1lbnRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgKDAsIF9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5kZWZhdWx0KShjaGlsZCwgcGFyZW50KTtcbiAgKDAsIF9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICAoMCwgX2luaGVyaXRJbm5lckNvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRzQ29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18125\n')},93437:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = removeComments;\nvar _index = __webpack_require__(93422);\nfunction removeComments(node) {\n  _index.COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n  return node;\n}\n\n//# sourceMappingURL=removeComments.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM0MzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvY29tbWVudHMvcmVtb3ZlQ29tbWVudHMuanM/YmU1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlbW92ZUNvbW1lbnRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiByZW1vdmVDb21tZW50cyhub2RlKSB7XG4gIF9pbmRleC5DT01NRU5UX0tFWVMuZm9yRWFjaChrZXkgPT4ge1xuICAgIG5vZGVba2V5XSA9IG51bGw7XG4gIH0pO1xuICByZXR1cm4gbm9kZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlQ29tbWVudHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93437\n')},67980:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.WHILE_TYPES = exports.USERWHITESPACABLE_TYPES = exports.UNARYLIKE_TYPES = exports.TYPESCRIPT_TYPES = exports.TSTYPE_TYPES = exports.TSTYPEELEMENT_TYPES = exports.TSENTITYNAME_TYPES = exports.TSBASETYPE_TYPES = exports.TERMINATORLESS_TYPES = exports.STATEMENT_TYPES = exports.STANDARDIZED_TYPES = exports.SCOPABLE_TYPES = exports.PUREISH_TYPES = exports.PROPERTY_TYPES = exports.PRIVATE_TYPES = exports.PATTERN_TYPES = exports.PATTERNLIKE_TYPES = exports.OBJECTMEMBER_TYPES = exports.MODULESPECIFIER_TYPES = exports.MODULEDECLARATION_TYPES = exports.MISCELLANEOUS_TYPES = exports.METHOD_TYPES = exports.LVAL_TYPES = exports.LOOP_TYPES = exports.LITERAL_TYPES = exports.JSX_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = exports.IMMUTABLE_TYPES = exports.FUNCTION_TYPES = exports.FUNCTIONPARENT_TYPES = exports.FOR_TYPES = exports.FORXSTATEMENT_TYPES = exports.FLOW_TYPES = exports.FLOWTYPE_TYPES = exports.FLOWPREDICATE_TYPES = exports.FLOWDECLARATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = exports.EXPRESSION_TYPES = exports.EXPRESSIONWRAPPER_TYPES = exports.EXPORTDECLARATION_TYPES = exports.ENUMMEMBER_TYPES = exports.ENUMBODY_TYPES = exports.DECLARATION_TYPES = exports.CONDITIONAL_TYPES = exports.COMPLETIONSTATEMENT_TYPES = exports.CLASS_TYPES = exports.BLOCK_TYPES = exports.BLOCKPARENT_TYPES = exports.BINARY_TYPES = exports.ACCESSOR_TYPES = void 0;\nvar _index = __webpack_require__(39793);\nconst STANDARDIZED_TYPES = exports.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];\nconst EXPRESSION_TYPES = exports.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];\nconst BINARY_TYPES = exports.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];\nconst SCOPABLE_TYPES = exports.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];\nconst BLOCKPARENT_TYPES = exports.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];\nconst BLOCK_TYPES = exports.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];\nconst STATEMENT_TYPES = exports.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];\nconst TERMINATORLESS_TYPES = exports.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];\nconst COMPLETIONSTATEMENT_TYPES = exports.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];\nconst CONDITIONAL_TYPES = exports.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];\nconst LOOP_TYPES = exports.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];\nconst WHILE_TYPES = exports.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];\nconst EXPRESSIONWRAPPER_TYPES = exports.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];\nconst FOR_TYPES = exports.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];\nconst FORXSTATEMENT_TYPES = exports.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];\nconst FUNCTION_TYPES = exports.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];\nconst FUNCTIONPARENT_TYPES = exports.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];\nconst PUREISH_TYPES = exports.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];\nconst DECLARATION_TYPES = exports.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];\nconst PATTERNLIKE_TYPES = exports.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];\nconst LVAL_TYPES = exports.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];\nconst TSENTITYNAME_TYPES = exports.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];\nconst LITERAL_TYPES = exports.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];\nconst IMMUTABLE_TYPES = exports.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];\nconst USERWHITESPACABLE_TYPES = exports.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];\nconst METHOD_TYPES = exports.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];\nconst OBJECTMEMBER_TYPES = exports.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];\nconst PROPERTY_TYPES = exports.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];\nconst UNARYLIKE_TYPES = exports.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];\nconst PATTERN_TYPES = exports.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];\nconst CLASS_TYPES = exports.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];\nconst IMPORTOREXPORTDECLARATION_TYPES = exports.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];\nconst EXPORTDECLARATION_TYPES = exports.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];\nconst MODULESPECIFIER_TYPES = exports.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];\nconst ACCESSOR_TYPES = exports.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];\nconst PRIVATE_TYPES = exports.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];\nconst FLOW_TYPES = exports.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];\nconst FLOWTYPE_TYPES = exports.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];\nconst FLOWBASEANNOTATION_TYPES = exports.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];\nconst FLOWDECLARATION_TYPES = exports.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];\nconst FLOWPREDICATE_TYPES = exports.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];\nconst ENUMBODY_TYPES = exports.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];\nconst ENUMMEMBER_TYPES = exports.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];\nconst JSX_TYPES = exports.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];\nconst MISCELLANEOUS_TYPES = exports.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];\nconst TYPESCRIPT_TYPES = exports.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];\nconst TSTYPEELEMENT_TYPES = exports.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];\nconst TSTYPE_TYPES = exports.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];\nconst TSBASETYPE_TYPES = exports.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];\nconst MODULEDECLARATION_TYPES = exports.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjc5ODAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbUJBQW1CLEdBQUcsK0JBQStCLEdBQUcsdUJBQXVCLEdBQUcsd0JBQXdCLEdBQUcsb0JBQW9CLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEdBQUcsNkJBQTZCLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcscUJBQXFCLEdBQUcsaUJBQWlCLEdBQUcsdUNBQXVDLEdBQUcsdUJBQXVCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsaUJBQWlCLEdBQUcsMkJBQTJCLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsZ0NBQWdDLEdBQUcsd0JBQXdCLEdBQUcsK0JBQStCLEdBQUcsK0JBQStCLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsaUNBQWlDLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCO0FBQ2oxQyxhQUFhLG1CQUFPLENBQUMsS0FBNEI7QUFDakQsMkJBQTJCLDBCQUEwQjtBQUNyRCx5QkFBeUIsd0JBQXdCO0FBQ2pELHFCQUFxQixvQkFBb0I7QUFDekMsdUJBQXVCLHNCQUFzQjtBQUM3QywwQkFBMEIseUJBQXlCO0FBQ25ELG9CQUFvQixtQkFBbUI7QUFDdkMsd0JBQXdCLHVCQUF1QjtBQUMvQyw2QkFBNkIsNEJBQTRCO0FBQ3pELGtDQUFrQyxpQ0FBaUM7QUFDbkUsMEJBQTBCLHlCQUF5QjtBQUNuRCxtQkFBbUIsa0JBQWtCO0FBQ3JDLG9CQUFvQixtQkFBbUI7QUFDdkMsZ0NBQWdDLCtCQUErQjtBQUMvRCxrQkFBa0IsaUJBQWlCO0FBQ25DLDRCQUE0QiwyQkFBMkI7QUFDdkQsdUJBQXVCLHNCQUFzQjtBQUM3Qyw2QkFBNkIsNEJBQTRCO0FBQ3pELHNCQUFzQixxQkFBcUI7QUFDM0MsMEJBQTBCLHlCQUF5QjtBQUNuRCwwQkFBMEIseUJBQXlCO0FBQ25ELG1CQUFtQixrQkFBa0I7QUFDckMsMkJBQTJCLDBCQUEwQjtBQUNyRCxzQkFBc0IscUJBQXFCO0FBQzNDLHdCQUF3Qix1QkFBdUI7QUFDL0MsZ0NBQWdDLCtCQUErQjtBQUMvRCxxQkFBcUIsb0JBQW9CO0FBQ3pDLDJCQUEyQiwwQkFBMEI7QUFDckQsdUJBQXVCLHNCQUFzQjtBQUM3Qyx3QkFBd0IsdUJBQXVCO0FBQy9DLHNCQUFzQixxQkFBcUI7QUFDM0Msb0JBQW9CLG1CQUFtQjtBQUN2Qyx3Q0FBd0MsdUNBQXVDO0FBQy9FLGdDQUFnQywrQkFBK0I7QUFDL0QsOEJBQThCLDZCQUE2QjtBQUMzRCx1QkFBdUIsc0JBQXNCO0FBQzdDLHNCQUFzQixxQkFBcUI7QUFDM0MsbUJBQW1CLGtCQUFrQjtBQUNyQyx1QkFBdUIsc0JBQXNCO0FBQzdDLGlDQUFpQyxnQ0FBZ0M7QUFDakUsOEJBQThCLDZCQUE2QjtBQUMzRCw0QkFBNEIsMkJBQTJCO0FBQ3ZELHVCQUF1QixzQkFBc0I7QUFDN0MseUJBQXlCLHdCQUF3QjtBQUNqRCxrQkFBa0IsaUJBQWlCO0FBQ25DLDRCQUE0QiwyQkFBMkI7QUFDdkQseUJBQXlCLHdCQUF3QjtBQUNqRCw0QkFBNEIsMkJBQTJCO0FBQ3ZELHFCQUFxQixvQkFBb0I7QUFDekMseUJBQXlCLHdCQUF3QjtBQUNqRCxnQ0FBZ0MsK0JBQStCOztBQUUvRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb25zdGFudHMvZ2VuZXJhdGVkL2luZGV4LmpzPzcyNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLldISUxFX1RZUEVTID0gZXhwb3J0cy5VU0VSV0hJVEVTUEFDQUJMRV9UWVBFUyA9IGV4cG9ydHMuVU5BUllMSUtFX1RZUEVTID0gZXhwb3J0cy5UWVBFU0NSSVBUX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVfVFlQRVMgPSBleHBvcnRzLlRTVFlQRUVMRU1FTlRfVFlQRVMgPSBleHBvcnRzLlRTRU5USVRZTkFNRV9UWVBFUyA9IGV4cG9ydHMuVFNCQVNFVFlQRV9UWVBFUyA9IGV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBleHBvcnRzLlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuU1RBTkRBUkRJWkVEX1RZUEVTID0gZXhwb3J0cy5TQ09QQUJMRV9UWVBFUyA9IGV4cG9ydHMuUFVSRUlTSF9UWVBFUyA9IGV4cG9ydHMuUFJPUEVSVFlfVFlQRVMgPSBleHBvcnRzLlBSSVZBVEVfVFlQRVMgPSBleHBvcnRzLlBBVFRFUk5fVFlQRVMgPSBleHBvcnRzLlBBVFRFUk5MSUtFX1RZUEVTID0gZXhwb3J0cy5PQkpFQ1RNRU1CRVJfVFlQRVMgPSBleHBvcnRzLk1PRFVMRVNQRUNJRklFUl9UWVBFUyA9IGV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLk1JU0NFTExBTkVPVVNfVFlQRVMgPSBleHBvcnRzLk1FVEhPRF9UWVBFUyA9IGV4cG9ydHMuTFZBTF9UWVBFUyA9IGV4cG9ydHMuTE9PUF9UWVBFUyA9IGV4cG9ydHMuTElURVJBTF9UWVBFUyA9IGV4cG9ydHMuSlNYX1RZUEVTID0gZXhwb3J0cy5JTVBPUlRPUkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5JTU1VVEFCTEVfVFlQRVMgPSBleHBvcnRzLkZVTkNUSU9OX1RZUEVTID0gZXhwb3J0cy5GVU5DVElPTlBBUkVOVF9UWVBFUyA9IGV4cG9ydHMuRk9SX1RZUEVTID0gZXhwb3J0cy5GT1JYU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5GTE9XX1RZUEVTID0gZXhwb3J0cy5GTE9XVFlQRV9UWVBFUyA9IGV4cG9ydHMuRkxPV1BSRURJQ0FURV9UWVBFUyA9IGV4cG9ydHMuRkxPV0RFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5GTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBleHBvcnRzLkVYUFJFU1NJT05fVFlQRVMgPSBleHBvcnRzLkVYUFJFU1NJT05XUkFQUEVSX1RZUEVTID0gZXhwb3J0cy5FWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuRU5VTU1FTUJFUl9UWVBFUyA9IGV4cG9ydHMuRU5VTUJPRFlfVFlQRVMgPSBleHBvcnRzLkRFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5DT05ESVRJT05BTF9UWVBFUyA9IGV4cG9ydHMuQ09NUExFVElPTlNUQVRFTUVOVF9UWVBFUyA9IGV4cG9ydHMuQ0xBU1NfVFlQRVMgPSBleHBvcnRzLkJMT0NLX1RZUEVTID0gZXhwb3J0cy5CTE9DS1BBUkVOVF9UWVBFUyA9IGV4cG9ydHMuQklOQVJZX1RZUEVTID0gZXhwb3J0cy5BQ0NFU1NPUl9UWVBFUyA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5jb25zdCBTVEFOREFSRElaRURfVFlQRVMgPSBleHBvcnRzLlNUQU5EQVJESVpFRF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJTdGFuZGFyZGl6ZWRcIl07XG5jb25zdCBFWFBSRVNTSU9OX1RZUEVTID0gZXhwb3J0cy5FWFBSRVNTSU9OX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkV4cHJlc3Npb25cIl07XG5jb25zdCBCSU5BUllfVFlQRVMgPSBleHBvcnRzLkJJTkFSWV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJCaW5hcnlcIl07XG5jb25zdCBTQ09QQUJMRV9UWVBFUyA9IGV4cG9ydHMuU0NPUEFCTEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiU2NvcGFibGVcIl07XG5jb25zdCBCTE9DS1BBUkVOVF9UWVBFUyA9IGV4cG9ydHMuQkxPQ0tQQVJFTlRfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQmxvY2tQYXJlbnRcIl07XG5jb25zdCBCTE9DS19UWVBFUyA9IGV4cG9ydHMuQkxPQ0tfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQmxvY2tcIl07XG5jb25zdCBTVEFURU1FTlRfVFlQRVMgPSBleHBvcnRzLlNUQVRFTUVOVF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJTdGF0ZW1lbnRcIl07XG5jb25zdCBURVJNSU5BVE9STEVTU19UWVBFUyA9IGV4cG9ydHMuVEVSTUlOQVRPUkxFU1NfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiVGVybWluYXRvcmxlc3NcIl07XG5jb25zdCBDT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5DT01QTEVUSU9OU1RBVEVNRU5UX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl07XG5jb25zdCBDT05ESVRJT05BTF9UWVBFUyA9IGV4cG9ydHMuQ09ORElUSU9OQUxfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQ29uZGl0aW9uYWxcIl07XG5jb25zdCBMT09QX1RZUEVTID0gZXhwb3J0cy5MT09QX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkxvb3BcIl07XG5jb25zdCBXSElMRV9UWVBFUyA9IGV4cG9ydHMuV0hJTEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiV2hpbGVcIl07XG5jb25zdCBFWFBSRVNTSU9OV1JBUFBFUl9UWVBFUyA9IGV4cG9ydHMuRVhQUkVTU0lPTldSQVBQRVJfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwcmVzc2lvbldyYXBwZXJcIl07XG5jb25zdCBGT1JfVFlQRVMgPSBleHBvcnRzLkZPUl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGb3JcIl07XG5jb25zdCBGT1JYU1RBVEVNRU5UX1RZUEVTID0gZXhwb3J0cy5GT1JYU1RBVEVNRU5UX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZvclhTdGF0ZW1lbnRcIl07XG5jb25zdCBGVU5DVElPTl9UWVBFUyA9IGV4cG9ydHMuRlVOQ1RJT05fVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRnVuY3Rpb25cIl07XG5jb25zdCBGVU5DVElPTlBBUkVOVF9UWVBFUyA9IGV4cG9ydHMuRlVOQ1RJT05QQVJFTlRfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRnVuY3Rpb25QYXJlbnRcIl07XG5jb25zdCBQVVJFSVNIX1RZUEVTID0gZXhwb3J0cy5QVVJFSVNIX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlB1cmVpc2hcIl07XG5jb25zdCBERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuREVDTEFSQVRJT05fVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRGVjbGFyYXRpb25cIl07XG5jb25zdCBQQVRURVJOTElLRV9UWVBFUyA9IGV4cG9ydHMuUEFUVEVSTkxJS0VfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiUGF0dGVybkxpa2VcIl07XG5jb25zdCBMVkFMX1RZUEVTID0gZXhwb3J0cy5MVkFMX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkxWYWxcIl07XG5jb25zdCBUU0VOVElUWU5BTUVfVFlQRVMgPSBleHBvcnRzLlRTRU5USVRZTkFNRV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJUU0VudGl0eU5hbWVcIl07XG5jb25zdCBMSVRFUkFMX1RZUEVTID0gZXhwb3J0cy5MSVRFUkFMX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkxpdGVyYWxcIl07XG5jb25zdCBJTU1VVEFCTEVfVFlQRVMgPSBleHBvcnRzLklNTVVUQUJMRV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJJbW11dGFibGVcIl07XG5jb25zdCBVU0VSV0hJVEVTUEFDQUJMRV9UWVBFUyA9IGV4cG9ydHMuVVNFUldISVRFU1BBQ0FCTEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiVXNlcldoaXRlc3BhY2FibGVcIl07XG5jb25zdCBNRVRIT0RfVFlQRVMgPSBleHBvcnRzLk1FVEhPRF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJNZXRob2RcIl07XG5jb25zdCBPQkpFQ1RNRU1CRVJfVFlQRVMgPSBleHBvcnRzLk9CSkVDVE1FTUJFUl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJPYmplY3RNZW1iZXJcIl07XG5jb25zdCBQUk9QRVJUWV9UWVBFUyA9IGV4cG9ydHMuUFJPUEVSVFlfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiUHJvcGVydHlcIl07XG5jb25zdCBVTkFSWUxJS0VfVFlQRVMgPSBleHBvcnRzLlVOQVJZTElLRV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJVbmFyeUxpa2VcIl07XG5jb25zdCBQQVRURVJOX1RZUEVTID0gZXhwb3J0cy5QQVRURVJOX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlBhdHRlcm5cIl07XG5jb25zdCBDTEFTU19UWVBFUyA9IGV4cG9ydHMuQ0xBU1NfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQ2xhc3NcIl07XG5jb25zdCBJTVBPUlRPUkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gZXhwb3J0cy5JTVBPUlRPUkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb25cIl07XG5jb25zdCBFWFBPUlRERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuRVhQT1JUREVDTEFSQVRJT05fVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRXhwb3J0RGVjbGFyYXRpb25cIl07XG5jb25zdCBNT0RVTEVTUEVDSUZJRVJfVFlQRVMgPSBleHBvcnRzLk1PRFVMRVNQRUNJRklFUl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJNb2R1bGVTcGVjaWZpZXJcIl07XG5jb25zdCBBQ0NFU1NPUl9UWVBFUyA9IGV4cG9ydHMuQUNDRVNTT1JfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiQWNjZXNzb3JcIl07XG5jb25zdCBQUklWQVRFX1RZUEVTID0gZXhwb3J0cy5QUklWQVRFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlByaXZhdGVcIl07XG5jb25zdCBGTE9XX1RZUEVTID0gZXhwb3J0cy5GTE9XX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dcIl07XG5jb25zdCBGTE9XVFlQRV9UWVBFUyA9IGV4cG9ydHMuRkxPV1RZUEVfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRmxvd1R5cGVcIl07XG5jb25zdCBGTE9XQkFTRUFOTk9UQVRJT05fVFlQRVMgPSBleHBvcnRzLkZMT1dCQVNFQU5OT1RBVElPTl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93QmFzZUFubm90YXRpb25cIl07XG5jb25zdCBGTE9XREVDTEFSQVRJT05fVFlQRVMgPSBleHBvcnRzLkZMT1dERUNMQVJBVElPTl9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJGbG93RGVjbGFyYXRpb25cIl07XG5jb25zdCBGTE9XUFJFRElDQVRFX1RZUEVTID0gZXhwb3J0cy5GTE9XUFJFRElDQVRFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkZsb3dQcmVkaWNhdGVcIl07XG5jb25zdCBFTlVNQk9EWV9UWVBFUyA9IGV4cG9ydHMuRU5VTUJPRFlfVFlQRVMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW1wiRW51bUJvZHlcIl07XG5jb25zdCBFTlVNTUVNQkVSX1RZUEVTID0gZXhwb3J0cy5FTlVNTUVNQkVSX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIkVudW1NZW1iZXJcIl07XG5jb25zdCBKU1hfVFlQRVMgPSBleHBvcnRzLkpTWF9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJKU1hcIl07XG5jb25zdCBNSVNDRUxMQU5FT1VTX1RZUEVTID0gZXhwb3J0cy5NSVNDRUxMQU5FT1VTX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIk1pc2NlbGxhbmVvdXNcIl07XG5jb25zdCBUWVBFU0NSSVBUX1RZUEVTID0gZXhwb3J0cy5UWVBFU0NSSVBUX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlR5cGVTY3JpcHRcIl07XG5jb25zdCBUU1RZUEVFTEVNRU5UX1RZUEVTID0gZXhwb3J0cy5UU1RZUEVFTEVNRU5UX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTVHlwZUVsZW1lbnRcIl07XG5jb25zdCBUU1RZUEVfVFlQRVMgPSBleHBvcnRzLlRTVFlQRV9UWVBFUyA9IF9pbmRleC5GTElQUEVEX0FMSUFTX0tFWVNbXCJUU1R5cGVcIl07XG5jb25zdCBUU0JBU0VUWVBFX1RZUEVTID0gZXhwb3J0cy5UU0JBU0VUWVBFX1RZUEVTID0gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZU1tcIlRTQmFzZVR5cGVcIl07XG5jb25zdCBNT0RVTEVERUNMQVJBVElPTl9UWVBFUyA9IGV4cG9ydHMuTU9EVUxFREVDTEFSQVRJT05fVFlQRVMgPSBJTVBPUlRPUkVYUE9SVERFQ0xBUkFUSU9OX1RZUEVTO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67980\n')},93422:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.UPDATE_OPERATORS = exports.UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = exports.STATEMENT_OR_BLOCK_KEYS = exports.NUMBER_UNARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = exports.NOT_LOCAL_BINDING = exports.LOGICAL_OPERATORS = exports.INHERIT_KEYS = exports.FOR_INIT_KEYS = exports.FLATTENABLE_KEYS = exports.EQUALITY_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = exports.COMMENT_KEYS = exports.BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = exports.BLOCK_SCOPED_SYMBOL = exports.BINARY_OPERATORS = exports.ASSIGNMENT_OPERATORS = void 0;\nconst STATEMENT_OR_BLOCK_KEYS = exports.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];\nconst FLATTENABLE_KEYS = exports.FLATTENABLE_KEYS = ["body", "expressions"];\nconst FOR_INIT_KEYS = exports.FOR_INIT_KEYS = ["left", "init"];\nconst COMMENT_KEYS = exports.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];\nconst LOGICAL_OPERATORS = exports.LOGICAL_OPERATORS = ["||", "&&", "??"];\nconst UPDATE_OPERATORS = exports.UPDATE_OPERATORS = ["++", "--"];\nconst BOOLEAN_NUMBER_BINARY_OPERATORS = exports.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];\nconst EQUALITY_BINARY_OPERATORS = exports.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];\nconst COMPARISON_BINARY_OPERATORS = exports.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];\nconst BOOLEAN_BINARY_OPERATORS = exports.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];\nconst NUMBER_BINARY_OPERATORS = exports.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];\nconst BINARY_OPERATORS = exports.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];\nconst ASSIGNMENT_OPERATORS = exports.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map(op => op + "="), ...LOGICAL_OPERATORS.map(op => op + "=")];\nconst BOOLEAN_UNARY_OPERATORS = exports.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];\nconst NUMBER_UNARY_OPERATORS = exports.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];\nconst STRING_UNARY_OPERATORS = exports.STRING_UNARY_OPERATORS = ["typeof"];\nconst UNARY_OPERATORS = exports.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];\nconst INHERIT_KEYS = exports.INHERIT_KEYS = {\n  optional: ["typeAnnotation", "typeParameters", "returnType"],\n  force: ["start", "loc", "end"]\n};\nconst BLOCK_SCOPED_SYMBOL = exports.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");\nconst NOT_LOCAL_BINDING = exports.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM0MjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcsK0JBQStCLEdBQUcsOEJBQThCLEdBQUcsK0JBQStCLEdBQUcseUJBQXlCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcscUJBQXFCLEdBQUcsd0JBQXdCLEdBQUcsaUNBQWlDLEdBQUcsbUNBQW1DLEdBQUcsb0JBQW9CLEdBQUcsK0JBQStCLEdBQUcsdUNBQXVDLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsNEJBQTRCO0FBQ2xtQixnQ0FBZ0MsK0JBQStCO0FBQy9ELHlCQUF5Qix3QkFBd0I7QUFDakQsc0JBQXNCLHFCQUFxQjtBQUMzQyxxQkFBcUIsb0JBQW9CO0FBQ3pDLDBCQUEwQix5QkFBeUI7QUFDbkQseUJBQXlCLHdCQUF3QjtBQUNqRCx3Q0FBd0MsdUNBQXVDO0FBQy9FLGtDQUFrQyxpQ0FBaUM7QUFDbkUsb0NBQW9DLG1DQUFtQztBQUN2RSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFLGdDQUFnQywrQkFBK0I7QUFDL0QseUJBQXlCLHdCQUF3QjtBQUNqRCw2QkFBNkIsNEJBQTRCO0FBQ3pELGdDQUFnQywrQkFBK0I7QUFDL0QsK0JBQStCLDhCQUE4QjtBQUM3RCwrQkFBK0IsOEJBQThCO0FBQzdELHdCQUF3Qix1QkFBdUI7QUFDL0MscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkJBQTJCO0FBQ3ZELDBCQUEwQix5QkFBeUI7O0FBRW5EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnN0YW50cy9pbmRleC5qcz9jM2Y4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5VUERBVEVfT1BFUkFUT1JTID0gZXhwb3J0cy5VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUUklOR19VTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLlNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gZXhwb3J0cy5OVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuTk9UX0xPQ0FMX0JJTkRJTkcgPSBleHBvcnRzLkxPR0lDQUxfT1BFUkFUT1JTID0gZXhwb3J0cy5JTkhFUklUX0tFWVMgPSBleHBvcnRzLkZPUl9JTklUX0tFWVMgPSBleHBvcnRzLkZMQVRURU5BQkxFX0tFWVMgPSBleHBvcnRzLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkNPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NTUVOVF9LRVlTID0gZXhwb3J0cy5CT09MRUFOX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CTE9DS19TQ09QRURfU1lNQk9MID0gZXhwb3J0cy5CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5BU1NJR05NRU5UX09QRVJBVE9SUyA9IHZvaWQgMDtcbmNvbnN0IFNUQVRFTUVOVF9PUl9CTE9DS19LRVlTID0gZXhwb3J0cy5TVEFURU1FTlRfT1JfQkxPQ0tfS0VZUyA9IFtcImNvbnNlcXVlbnRcIiwgXCJib2R5XCIsIFwiYWx0ZXJuYXRlXCJdO1xuY29uc3QgRkxBVFRFTkFCTEVfS0VZUyA9IGV4cG9ydHMuRkxBVFRFTkFCTEVfS0VZUyA9IFtcImJvZHlcIiwgXCJleHByZXNzaW9uc1wiXTtcbmNvbnN0IEZPUl9JTklUX0tFWVMgPSBleHBvcnRzLkZPUl9JTklUX0tFWVMgPSBbXCJsZWZ0XCIsIFwiaW5pdFwiXTtcbmNvbnN0IENPTU1FTlRfS0VZUyA9IGV4cG9ydHMuQ09NTUVOVF9LRVlTID0gW1wibGVhZGluZ0NvbW1lbnRzXCIsIFwidHJhaWxpbmdDb21tZW50c1wiLCBcImlubmVyQ29tbWVudHNcIl07XG5jb25zdCBMT0dJQ0FMX09QRVJBVE9SUyA9IGV4cG9ydHMuTE9HSUNBTF9PUEVSQVRPUlMgPSBbXCJ8fFwiLCBcIiYmXCIsIFwiPz9cIl07XG5jb25zdCBVUERBVEVfT1BFUkFUT1JTID0gZXhwb3J0cy5VUERBVEVfT1BFUkFUT1JTID0gW1wiKytcIiwgXCItLVwiXTtcbmNvbnN0IEJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBleHBvcnRzLkJPT0xFQU5fTlVNQkVSX0JJTkFSWV9PUEVSQVRPUlMgPSBbXCI+XCIsIFwiPFwiLCBcIj49XCIsIFwiPD1cIl07XG5jb25zdCBFUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5FUVVBTElUWV9CSU5BUllfT1BFUkFUT1JTID0gW1wiPT1cIiwgXCI9PT1cIiwgXCIhPVwiLCBcIiE9PVwiXTtcbmNvbnN0IENPTVBBUklTT05fQklOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTID0gWy4uLkVRVUFMSVRZX0JJTkFSWV9PUEVSQVRPUlMsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCJdO1xuY29uc3QgQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX0JJTkFSWV9PUEVSQVRPUlMgPSBbLi4uQ09NUEFSSVNPTl9CSU5BUllfT1BFUkFUT1JTLCAuLi5CT09MRUFOX05VTUJFUl9CSU5BUllfT1BFUkFUT1JTXTtcbmNvbnN0IE5VTUJFUl9CSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfQklOQVJZX09QRVJBVE9SUyA9IFtcIi1cIiwgXCIvXCIsIFwiJVwiLCBcIipcIiwgXCIqKlwiLCBcIiZcIiwgXCJ8XCIsIFwiPj5cIiwgXCI+Pj5cIiwgXCI8PFwiLCBcIl5cIl07XG5jb25zdCBCSU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CSU5BUllfT1BFUkFUT1JTID0gW1wiK1wiLCAuLi5OVU1CRVJfQklOQVJZX09QRVJBVE9SUywgLi4uQk9PTEVBTl9CSU5BUllfT1BFUkFUT1JTLCBcInw+XCJdO1xuY29uc3QgQVNTSUdOTUVOVF9PUEVSQVRPUlMgPSBleHBvcnRzLkFTU0lHTk1FTlRfT1BFUkFUT1JTID0gW1wiPVwiLCBcIis9XCIsIC4uLk5VTUJFUl9CSU5BUllfT1BFUkFUT1JTLm1hcChvcCA9PiBvcCArIFwiPVwiKSwgLi4uTE9HSUNBTF9PUEVSQVRPUlMubWFwKG9wID0+IG9wICsgXCI9XCIpXTtcbmNvbnN0IEJPT0xFQU5fVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5CT09MRUFOX1VOQVJZX09QRVJBVE9SUyA9IFtcImRlbGV0ZVwiLCBcIiFcIl07XG5jb25zdCBOVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gZXhwb3J0cy5OVU1CRVJfVU5BUllfT1BFUkFUT1JTID0gW1wiK1wiLCBcIi1cIiwgXCJ+XCJdO1xuY29uc3QgU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuU1RSSU5HX1VOQVJZX09QRVJBVE9SUyA9IFtcInR5cGVvZlwiXTtcbmNvbnN0IFVOQVJZX09QRVJBVE9SUyA9IGV4cG9ydHMuVU5BUllfT1BFUkFUT1JTID0gW1widm9pZFwiLCBcInRocm93XCIsIC4uLkJPT0xFQU5fVU5BUllfT1BFUkFUT1JTLCAuLi5OVU1CRVJfVU5BUllfT1BFUkFUT1JTLCAuLi5TVFJJTkdfVU5BUllfT1BFUkFUT1JTXTtcbmNvbnN0IElOSEVSSVRfS0VZUyA9IGV4cG9ydHMuSU5IRVJJVF9LRVlTID0ge1xuICBvcHRpb25hbDogW1widHlwZUFubm90YXRpb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJldHVyblR5cGVcIl0sXG4gIGZvcmNlOiBbXCJzdGFydFwiLCBcImxvY1wiLCBcImVuZFwiXVxufTtcbmNvbnN0IEJMT0NLX1NDT1BFRF9TWU1CT0wgPSBleHBvcnRzLkJMT0NLX1NDT1BFRF9TWU1CT0wgPSBTeW1ib2wuZm9yKFwidmFyIHVzZWQgdG8gYmUgYmxvY2sgc2NvcGVkXCIpO1xuY29uc3QgTk9UX0xPQ0FMX0JJTkRJTkcgPSBleHBvcnRzLk5PVF9MT0NBTF9CSU5ESU5HID0gU3ltYm9sLmZvcihcInNob3VsZCBub3QgYmUgY29uc2lkZXJlZCBhIGxvY2FsIGJpbmRpbmdcIik7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///93422\n')},57931:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = ensureBlock;\nvar _toBlock = __webpack_require__(25010);\nfunction ensureBlock(node, key = "body") {\n  const result = (0, _toBlock.default)(node[key], node);\n  node[key] = result;\n  return result;\n}\n\n//# sourceMappingURL=ensureBlock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc5MzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixlQUFlLG1CQUFPLENBQUMsS0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvZW5zdXJlQmxvY2suanM/ZTBmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVuc3VyZUJsb2NrO1xudmFyIF90b0Jsb2NrID0gcmVxdWlyZShcIi4vdG9CbG9jay5qc1wiKTtcbmZ1bmN0aW9uIGVuc3VyZUJsb2NrKG5vZGUsIGtleSA9IFwiYm9keVwiKSB7XG4gIGNvbnN0IHJlc3VsdCA9ICgwLCBfdG9CbG9jay5kZWZhdWx0KShub2RlW2tleV0sIG5vZGUpO1xuICBub2RlW2tleV0gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVuc3VyZUJsb2NrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///57931\n')},14089:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = gatherSequenceExpressions;\nvar _getBindingIdentifiers = __webpack_require__(70329);\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(48079);\nvar _productions = __webpack_require__(10985);\nvar _cloneNode = __webpack_require__(85279);\n;\nfunction gatherSequenceExpressions(nodes, declars) {\n  const exprs = [];\n  let ensureLastUndefined = true;\n  for (const node of nodes) {\n    if (!(0, _index.isEmptyStatement)(node)) {\n      ensureLastUndefined = false;\n    }\n    if ((0, _index.isExpression)(node)) {\n      exprs.push(node);\n    } else if ((0, _index.isExpressionStatement)(node)) {\n      exprs.push(node.expression);\n    } else if ((0, _index.isVariableDeclaration)(node)) {\n      if (node.kind !== "var") return;\n      for (const declar of node.declarations) {\n        const bindings = (0, _getBindingIdentifiers.default)(declar);\n        for (const key of Object.keys(bindings)) {\n          declars.push({\n            kind: node.kind,\n            id: (0, _cloneNode.default)(bindings[key])\n          });\n        }\n        if (declar.init) {\n          exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));\n        }\n      }\n      ensureLastUndefined = true;\n    } else if ((0, _index.isIfStatement)(node)) {\n      const consequent = node.consequent ? gatherSequenceExpressions([node.consequent], declars) : (0, _productions.buildUndefinedNode)();\n      const alternate = node.alternate ? gatherSequenceExpressions([node.alternate], declars) : (0, _productions.buildUndefinedNode)();\n      if (!consequent || !alternate) return;\n      exprs.push((0, _index2.conditionalExpression)(node.test, consequent, alternate));\n    } else if ((0, _index.isBlockStatement)(node)) {\n      const body = gatherSequenceExpressions(node.body, declars);\n      if (!body) return;\n      exprs.push(body);\n    } else if ((0, _index.isEmptyStatement)(node)) {\n      if (nodes.indexOf(node) === 0) {\n        ensureLastUndefined = true;\n      }\n    } else {\n      return;\n    }\n  }\n  if (ensureLastUndefined) {\n    exprs.push((0, _productions.buildUndefinedNode)());\n  }\n  if (exprs.length === 1) {\n    return exprs[0];\n  } else {\n    return (0, _index2.sequenceExpression)(exprs);\n  }\n}\n\n//# sourceMappingURL=gatherSequenceExpressions.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwODkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZiw2QkFBNkIsbUJBQU8sQ0FBQyxLQUF3QztBQUM3RSxhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLEtBQWdDO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLEtBQTRCO0FBQ3ZELGlCQUFpQixtQkFBTyxDQUFDLEtBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5qcz9mODIwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucztcbnZhciBfZ2V0QmluZGluZ0lkZW50aWZpZXJzID0gcmVxdWlyZShcIi4uL3JldHJpZXZlcnMvZ2V0QmluZGluZ0lkZW50aWZpZXJzLmpzXCIpO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbnZhciBfcHJvZHVjdGlvbnMgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvcHJvZHVjdGlvbnMuanNcIik7XG52YXIgX2Nsb25lTm9kZSA9IHJlcXVpcmUoXCIuLi9jbG9uZS9jbG9uZU5vZGUuanNcIik7XG47XG5mdW5jdGlvbiBnYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zKG5vZGVzLCBkZWNsYXJzKSB7XG4gIGNvbnN0IGV4cHJzID0gW107XG4gIGxldCBlbnN1cmVMYXN0VW5kZWZpbmVkID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKCEoMCwgX2luZGV4LmlzRW1wdHlTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBlbnN1cmVMYXN0VW5kZWZpbmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzRXhwcmVzc2lvbikobm9kZSkpIHtcbiAgICAgIGV4cHJzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzRXhwcmVzc2lvblN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGV4cHJzLnB1c2gobm9kZS5leHByZXNzaW9uKTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNWYXJpYWJsZURlY2xhcmF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIikgcmV0dXJuO1xuICAgICAgZm9yIChjb25zdCBkZWNsYXIgb2Ygbm9kZS5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgYmluZGluZ3MgPSAoMCwgX2dldEJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0KShkZWNsYXIpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhiaW5kaW5ncykpIHtcbiAgICAgICAgICBkZWNsYXJzLnB1c2goe1xuICAgICAgICAgICAga2luZDogbm9kZS5raW5kLFxuICAgICAgICAgICAgaWQ6ICgwLCBfY2xvbmVOb2RlLmRlZmF1bHQpKGJpbmRpbmdzW2tleV0pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2xhci5pbml0KSB7XG4gICAgICAgICAgZXhwcnMucHVzaCgoMCwgX2luZGV4Mi5hc3NpZ25tZW50RXhwcmVzc2lvbikoXCI9XCIsIGRlY2xhci5pZCwgZGVjbGFyLmluaXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5zdXJlTGFzdFVuZGVmaW5lZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzSWZTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBjb25zdCBjb25zZXF1ZW50ID0gbm9kZS5jb25zZXF1ZW50ID8gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhbbm9kZS5jb25zZXF1ZW50XSwgZGVjbGFycykgOiAoMCwgX3Byb2R1Y3Rpb25zLmJ1aWxkVW5kZWZpbmVkTm9kZSkoKTtcbiAgICAgIGNvbnN0IGFsdGVybmF0ZSA9IG5vZGUuYWx0ZXJuYXRlID8gZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyhbbm9kZS5hbHRlcm5hdGVdLCBkZWNsYXJzKSA6ICgwLCBfcHJvZHVjdGlvbnMuYnVpbGRVbmRlZmluZWROb2RlKSgpO1xuICAgICAgaWYgKCFjb25zZXF1ZW50IHx8ICFhbHRlcm5hdGUpIHJldHVybjtcbiAgICAgIGV4cHJzLnB1c2goKDAsIF9pbmRleDIuY29uZGl0aW9uYWxFeHByZXNzaW9uKShub2RlLnRlc3QsIGNvbnNlcXVlbnQsIGFsdGVybmF0ZSkpO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSkge1xuICAgICAgY29uc3QgYm9keSA9IGdhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMobm9kZS5ib2R5LCBkZWNsYXJzKTtcbiAgICAgIGlmICghYm9keSkgcmV0dXJuO1xuICAgICAgZXhwcnMucHVzaChib2R5KTtcbiAgICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNFbXB0eVN0YXRlbWVudCkobm9kZSkpIHtcbiAgICAgIGlmIChub2Rlcy5pbmRleE9mKG5vZGUpID09PSAwKSB7XG4gICAgICAgIGVuc3VyZUxhc3RVbmRlZmluZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGlmIChlbnN1cmVMYXN0VW5kZWZpbmVkKSB7XG4gICAgZXhwcnMucHVzaCgoMCwgX3Byb2R1Y3Rpb25zLmJ1aWxkVW5kZWZpbmVkTm9kZSkoKSk7XG4gIH1cbiAgaWYgKGV4cHJzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBleHByc1swXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleDIuc2VxdWVuY2VFeHByZXNzaW9uKShleHBycyk7XG4gIH1cbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14089\n')},82234:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = toBindingIdentifierName;\nvar _toIdentifier = __webpack_require__(36744);\nfunction toBindingIdentifierName(name) {\n  name = (0, _toIdentifier.default)(name);\n  if (name === "eval" || name === "arguments") name = "_" + name;\n  return name;\n}\n\n//# sourceMappingURL=toBindingIdentifierName.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIyMzQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyxLQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanM/MDZiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmluZGluZ0lkZW50aWZpZXJOYW1lO1xudmFyIF90b0lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi90b0lkZW50aWZpZXIuanNcIik7XG5mdW5jdGlvbiB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZShuYW1lKSB7XG4gIG5hbWUgPSAoMCwgX3RvSWRlbnRpZmllci5kZWZhdWx0KShuYW1lKTtcbiAgaWYgKG5hbWUgPT09IFwiZXZhbFwiIHx8IG5hbWUgPT09IFwiYXJndW1lbnRzXCIpIG5hbWUgPSBcIl9cIiArIG5hbWU7XG4gIHJldHVybiBuYW1lO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0JpbmRpbmdJZGVudGlmaWVyTmFtZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///82234\n')},25010:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = toBlock;\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(48079);\nfunction toBlock(node, parent) {\n  if ((0, _index.isBlockStatement)(node)) {\n    return node;\n  }\n  let blockNodes = [];\n  if ((0, _index.isEmptyStatement)(node)) {\n    blockNodes = [];\n  } else {\n    if (!(0, _index.isStatement)(node)) {\n      if ((0, _index.isFunction)(parent)) {\n        node = (0, _index2.returnStatement)(node);\n      } else {\n        node = (0, _index2.expressionStatement)(node);\n      }\n    }\n    blockNodes = [node];\n  }\n  return (0, _index2.blockStatement)(blockNodes);\n}\n\n//# sourceMappingURL=toBlock.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUwMTAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLEtBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvQmxvY2suanM/M2E0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvQmxvY2s7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gdG9CbG9jayhub2RlLCBwYXJlbnQpIHtcbiAgaWYgKCgwLCBfaW5kZXguaXNCbG9ja1N0YXRlbWVudCkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBsZXQgYmxvY2tOb2RlcyA9IFtdO1xuICBpZiAoKDAsIF9pbmRleC5pc0VtcHR5U3RhdGVtZW50KShub2RlKSkge1xuICAgIGJsb2NrTm9kZXMgPSBbXTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoISgwLCBfaW5kZXguaXNTdGF0ZW1lbnQpKG5vZGUpKSB7XG4gICAgICBpZiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShwYXJlbnQpKSB7XG4gICAgICAgIG5vZGUgPSAoMCwgX2luZGV4Mi5yZXR1cm5TdGF0ZW1lbnQpKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZSA9ICgwLCBfaW5kZXgyLmV4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBibG9ja05vZGVzID0gW25vZGVdO1xuICB9XG4gIHJldHVybiAoMCwgX2luZGV4Mi5ibG9ja1N0YXRlbWVudCkoYmxvY2tOb2Rlcyk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvQmxvY2suanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25010\n')},33017:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = toComputedKey;\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(48079);\nfunction toComputedKey(node, key = node.key || node.property) {\n  if (!node.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);\n  return key;\n}\n\n//# sourceMappingURL=toComputedKey.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMwMTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLEtBQWdDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9Db21wdXRlZEtleS5qcz9hMGJiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdG9Db21wdXRlZEtleTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiB0b0NvbXB1dGVkS2V5KG5vZGUsIGtleSA9IG5vZGUua2V5IHx8IG5vZGUucHJvcGVydHkpIHtcbiAgaWYgKCFub2RlLmNvbXB1dGVkICYmICgwLCBfaW5kZXguaXNJZGVudGlmaWVyKShrZXkpKSBrZXkgPSAoMCwgX2luZGV4Mi5zdHJpbmdMaXRlcmFsKShrZXkubmFtZSk7XG4gIHJldHVybiBrZXk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvQ29tcHV0ZWRLZXkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33017\n')},26133:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _index = __webpack_require__(98960);\nvar _default = exports["default"] = toExpression;\nfunction toExpression(node) {\n  if ((0, _index.isExpressionStatement)(node)) {\n    node = node.expression;\n  }\n  if ((0, _index.isExpression)(node)) {\n    return node;\n  }\n  if ((0, _index.isClass)(node)) {\n    node.type = "ClassExpression";\n  } else if ((0, _index.isFunction)(node)) {\n    node.type = "FunctionExpression";\n  }\n  if (!(0, _index.isExpression)(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n  return node;\n}\n\n//# sourceMappingURL=toExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYxMzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uLmpzPzczMDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gdG9FeHByZXNzaW9uO1xuZnVuY3Rpb24gdG9FeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKCgwLCBfaW5kZXguaXNFeHByZXNzaW9uU3RhdGVtZW50KShub2RlKSkge1xuICAgIG5vZGUgPSBub2RlLmV4cHJlc3Npb247XG4gIH1cbiAgaWYgKCgwLCBfaW5kZXguaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGlmICgoMCwgX2luZGV4LmlzQ2xhc3MpKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzRnVuY3Rpb24pKG5vZGUpKSB7XG4gICAgbm9kZS50eXBlID0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIjtcbiAgfVxuICBpZiAoISgwLCBfaW5kZXguaXNFeHByZXNzaW9uKShub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHR1cm4gJHtub2RlLnR5cGV9IHRvIGFuIGV4cHJlc3Npb25gKTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9FeHByZXNzaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26133\n')},36744:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = toIdentifier;\nvar _isValidIdentifier = __webpack_require__(60983);\nvar _helperValidatorIdentifier = __webpack_require__(61000);\nfunction toIdentifier(input) {\n  input = input + "";\n  let name = "";\n  for (const c of input) {\n    name += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";\n  }\n  name = name.replace(/^[-0-9]+/, "");\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : "";\n  });\n  if (!(0, _isValidIdentifier.default)(name)) {\n    name = `_${name}`;\n  }\n  return name || "_";\n}\n\n//# sourceMappingURL=toIdentifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzY3NDQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZix5QkFBeUIsbUJBQU8sQ0FBQyxLQUFvQztBQUNyRSxpQ0FBaUMsbUJBQU8sQ0FBQyxLQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9JZGVudGlmaWVyLmpzPzViOGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b0lkZW50aWZpZXI7XG52YXIgX2lzVmFsaWRJZGVudGlmaWVyID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXIuanNcIik7XG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcbmZ1bmN0aW9uIHRvSWRlbnRpZmllcihpbnB1dCkge1xuICBpbnB1dCA9IGlucHV0ICsgXCJcIjtcbiAgbGV0IG5hbWUgPSBcIlwiO1xuICBmb3IgKGNvbnN0IGMgb2YgaW5wdXQpIHtcbiAgICBuYW1lICs9ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0lkZW50aWZpZXJDaGFyKShjLmNvZGVQb2ludEF0KDApKSA/IGMgOiBcIi1cIjtcbiAgfVxuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9eWy0wLTldKy8sIFwiXCIpO1xuICBuYW1lID0gbmFtZS5yZXBsYWNlKC9bLVxcc10rKC4pPy9nLCBmdW5jdGlvbiAobWF0Y2gsIGMpIHtcbiAgICByZXR1cm4gYyA/IGMudG9VcHBlckNhc2UoKSA6IFwiXCI7XG4gIH0pO1xuICBpZiAoISgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkobmFtZSkpIHtcbiAgICBuYW1lID0gYF8ke25hbWV9YDtcbiAgfVxuICByZXR1cm4gbmFtZSB8fCBcIl9cIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9JZGVudGlmaWVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36744\n')},72402:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = toKeyAlias;\nvar _index = __webpack_require__(98960);\nvar _cloneNode = __webpack_require__(85279);\nvar _removePropertiesDeep = __webpack_require__(87639);\nfunction toKeyAlias(node, key = node.key) {\n  let alias;\n  if (node.kind === "method") {\n    return toKeyAlias.increment() + "";\n  } else if ((0, _index.isIdentifier)(key)) {\n    alias = key.name;\n  } else if ((0, _index.isStringLiteral)(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));\n  }\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n  return alias;\n}\ntoKeyAlias.uid = 0;\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return toKeyAlias.uid = 0;\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n\n//# sourceMappingURL=toKeyAlias.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI0MDIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsS0FBdUI7QUFDaEQsNEJBQTRCLG1CQUFPLENBQUMsS0FBMEM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvS2V5QWxpYXMuanM/MGIxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHRvS2V5QWxpYXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9jbG9uZU5vZGUgPSByZXF1aXJlKFwiLi4vY2xvbmUvY2xvbmVOb2RlLmpzXCIpO1xudmFyIF9yZW1vdmVQcm9wZXJ0aWVzRGVlcCA9IHJlcXVpcmUoXCIuLi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXNEZWVwLmpzXCIpO1xuZnVuY3Rpb24gdG9LZXlBbGlhcyhub2RlLCBrZXkgPSBub2RlLmtleSkge1xuICBsZXQgYWxpYXM7XG4gIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy5pbmNyZW1lbnQoKSArIFwiXCI7XG4gIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKGtleSkpIHtcbiAgICBhbGlhcyA9IGtleS5uYW1lO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNTdHJpbmdMaXRlcmFsKShrZXkpKSB7XG4gICAgYWxpYXMgPSBKU09OLnN0cmluZ2lmeShrZXkudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGFsaWFzID0gSlNPTi5zdHJpbmdpZnkoKDAsIF9yZW1vdmVQcm9wZXJ0aWVzRGVlcC5kZWZhdWx0KSgoMCwgX2Nsb25lTm9kZS5kZWZhdWx0KShrZXkpKSk7XG4gIH1cbiAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICBhbGlhcyA9IGBbJHthbGlhc31dYDtcbiAgfVxuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBhbGlhcyA9IGBzdGF0aWM6JHthbGlhc31gO1xuICB9XG4gIHJldHVybiBhbGlhcztcbn1cbnRvS2V5QWxpYXMudWlkID0gMDtcbnRvS2V5QWxpYXMuaW5jcmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodG9LZXlBbGlhcy51aWQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICByZXR1cm4gdG9LZXlBbGlhcy51aWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0b0tleUFsaWFzLnVpZCsrO1xuICB9XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b0tleUFsaWFzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72402\n')},90640:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\nexports["default"] = toSequenceExpression;\nvar _gatherSequenceExpressions = __webpack_require__(14089);\n;\nfunction toSequenceExpression(nodes, scope) {\n  if (!(nodes != null && nodes.length)) return;\n  const declars = [];\n  const result = (0, _gatherSequenceExpressions.default)(nodes, declars);\n  if (!result) return;\n  for (const declar of declars) {\n    scope.push(declar);\n  }\n  return result;\n}\n\n//# sourceMappingURL=toSequenceExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA2NDAuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDZCQUE2QztBQUM3QztBQUNBLENBQUMsQ0FBQztBQUNGLGtCQUFlO0FBQ2YsaUNBQWlDLG1CQUFPLENBQUMsS0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uLmpzPzQyZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0b1NlcXVlbmNlRXhwcmVzc2lvbjtcbnZhciBfZ2F0aGVyU2VxdWVuY2VFeHByZXNzaW9ucyA9IHJlcXVpcmUoXCIuL2dhdGhlclNlcXVlbmNlRXhwcmVzc2lvbnMuanNcIik7XG47XG5mdW5jdGlvbiB0b1NlcXVlbmNlRXhwcmVzc2lvbihub2Rlcywgc2NvcGUpIHtcbiAgaWYgKCEobm9kZXMgIT0gbnVsbCAmJiBub2Rlcy5sZW5ndGgpKSByZXR1cm47XG4gIGNvbnN0IGRlY2xhcnMgPSBbXTtcbiAgY29uc3QgcmVzdWx0ID0gKDAsIF9nYXRoZXJTZXF1ZW5jZUV4cHJlc3Npb25zLmRlZmF1bHQpKG5vZGVzLCBkZWNsYXJzKTtcbiAgaWYgKCFyZXN1bHQpIHJldHVybjtcbiAgZm9yIChjb25zdCBkZWNsYXIgb2YgZGVjbGFycykge1xuICAgIHNjb3BlLnB1c2goZGVjbGFyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1NlcXVlbmNlRXhwcmVzc2lvbi5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90640\n')},99198:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(48079);\nvar _default = exports["default"] = toStatement;\nfunction toStatement(node, ignore) {\n  if ((0, _index.isStatement)(node)) {\n    return node;\n  }\n  let mustHaveId = false;\n  let newType;\n  if ((0, _index.isClass)(node)) {\n    mustHaveId = true;\n    newType = "ClassDeclaration";\n  } else if ((0, _index.isFunction)(node)) {\n    mustHaveId = true;\n    newType = "FunctionDeclaration";\n  } else if ((0, _index.isAssignmentExpression)(node)) {\n    return (0, _index2.expressionStatement)(node);\n  }\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n  node.type = newType;\n  return node;\n}\n\n//# sourceMappingURL=toStatement.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkxOTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQsY0FBYyxtQkFBTyxDQUFDLEtBQWdDO0FBQ3RELGVBQWUsa0JBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdG9TdGF0ZW1lbnQuanM/YWZkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSB0b1N0YXRlbWVudDtcbmZ1bmN0aW9uIHRvU3RhdGVtZW50KG5vZGUsIGlnbm9yZSkge1xuICBpZiAoKDAsIF9pbmRleC5pc1N0YXRlbWVudCkobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBsZXQgbXVzdEhhdmVJZCA9IGZhbHNlO1xuICBsZXQgbmV3VHlwZTtcbiAgaWYgKCgwLCBfaW5kZXguaXNDbGFzcykobm9kZSkpIHtcbiAgICBtdXN0SGF2ZUlkID0gdHJ1ZTtcbiAgICBuZXdUeXBlID0gXCJDbGFzc0RlY2xhcmF0aW9uXCI7XG4gIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShub2RlKSkge1xuICAgIG11c3RIYXZlSWQgPSB0cnVlO1xuICAgIG5ld1R5cGUgPSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzQXNzaWdubWVudEV4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXgyLmV4cHJlc3Npb25TdGF0ZW1lbnQpKG5vZGUpO1xuICB9XG4gIGlmIChtdXN0SGF2ZUlkICYmICFub2RlLmlkKSB7XG4gICAgbmV3VHlwZSA9IGZhbHNlO1xuICB9XG4gIGlmICghbmV3VHlwZSkge1xuICAgIGlmIChpZ25vcmUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgdHVybiAke25vZGUudHlwZX0gdG8gYSBzdGF0ZW1lbnRgKTtcbiAgICB9XG4gIH1cbiAgbm9kZS50eXBlID0gbmV3VHlwZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRvU3RhdGVtZW50LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99198\n')},44544:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _isValidIdentifier = __webpack_require__(60983);\nvar _index = __webpack_require__(48079);\nvar _default = exports["default"] = valueToNode;\nconst objectToString = Function.call.bind(Object.prototype.toString);\nfunction isRegExp(value) {\n  return objectToString(value) === "[object RegExp]";\n}\nfunction isPlainObject(value) {\n  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\nfunction valueToNode(value) {\n  if (value === undefined) {\n    return (0, _index.identifier)("undefined");\n  }\n  if (value === true || value === false) {\n    return (0, _index.booleanLiteral)(value);\n  }\n  if (value === null) {\n    return (0, _index.nullLiteral)();\n  }\n  if (typeof value === "string") {\n    return (0, _index.stringLiteral)(value);\n  }\n  if (typeof value === "number") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = (0, _index.numericLiteral)(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        numerator = (0, _index.numericLiteral)(0);\n      } else {\n        numerator = (0, _index.numericLiteral)(1);\n      }\n      result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));\n    }\n    if (value < 0 || Object.is(value, -0)) {\n      result = (0, _index.unaryExpression)("-", result);\n    }\n    return result;\n  }\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())[1];\n    return (0, _index.regExpLiteral)(pattern, flags);\n  }\n  if (Array.isArray(value)) {\n    return (0, _index.arrayExpression)(value.map(valueToNode));\n  }\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey;\n      if ((0, _isValidIdentifier.default)(key)) {\n        nodeKey = (0, _index.identifier)(key);\n      } else {\n        nodeKey = (0, _index.stringLiteral)(key);\n      }\n      props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key])));\n    }\n    return (0, _index.objectExpression)(props);\n  }\n  throw new Error("don\'t know how to turn this value into a node");\n}\n\n//# sourceMappingURL=valueToNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ1NDQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZix5QkFBeUIsbUJBQU8sQ0FBQyxLQUFvQztBQUNyRSxhQUFhLG1CQUFPLENBQUMsS0FBZ0M7QUFDckQsZUFBZSxrQkFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2NvbnZlcnRlcnMvdmFsdWVUb05vZGUuanM/NWJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllci5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gdmFsdWVUb05vZGU7XG5jb25zdCBvYmplY3RUb1N0cmluZyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKTtcbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyh2YWx1ZSkgPT09IFwiW29iamVjdCBSZWdFeHBdXCI7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT09IG51bGwgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIHJldHVybiBwcm90byA9PT0gbnVsbCB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pID09PSBudWxsO1xufVxuZnVuY3Rpb24gdmFsdWVUb05vZGUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5pZGVudGlmaWVyKShcInVuZGVmaW5lZFwiKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguYm9vbGVhbkxpdGVyYWwpKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5udWxsTGl0ZXJhbCkoKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuICgwLCBfaW5kZXguc3RyaW5nTGl0ZXJhbCkodmFsdWUpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICByZXN1bHQgPSAoMCwgX2luZGV4Lm51bWVyaWNMaXRlcmFsKShNYXRoLmFicyh2YWx1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbnVtZXJhdG9yO1xuICAgICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpIHtcbiAgICAgICAgbnVtZXJhdG9yID0gKDAsIF9pbmRleC5udW1lcmljTGl0ZXJhbCkoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBudW1lcmF0b3IgPSAoMCwgX2luZGV4Lm51bWVyaWNMaXRlcmFsKSgxKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9ICgwLCBfaW5kZXguYmluYXJ5RXhwcmVzc2lvbikoXCIvXCIsIG51bWVyYXRvciwgKDAsIF9pbmRleC5udW1lcmljTGl0ZXJhbCkoMCkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCAwIHx8IE9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICByZXN1bHQgPSAoMCwgX2luZGV4LnVuYXJ5RXhwcmVzc2lvbikoXCItXCIsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSB2YWx1ZS5zb3VyY2U7XG4gICAgY29uc3QgZmxhZ3MgPSAvXFwvKFthLXpdKikkLy5leGVjKHZhbHVlLnRvU3RyaW5nKCkpWzFdO1xuICAgIHJldHVybiAoMCwgX2luZGV4LnJlZ0V4cExpdGVyYWwpKHBhdHRlcm4sIGZsYWdzKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gKDAsIF9pbmRleC5hcnJheUV4cHJlc3Npb24pKHZhbHVlLm1hcCh2YWx1ZVRvTm9kZSkpO1xuICB9XG4gIGlmIChpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICBsZXQgbm9kZUtleTtcbiAgICAgIGlmICgoMCwgX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQpKGtleSkpIHtcbiAgICAgICAgbm9kZUtleSA9ICgwLCBfaW5kZXguaWRlbnRpZmllcikoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVLZXkgPSAoMCwgX2luZGV4LnN0cmluZ0xpdGVyYWwpKGtleSk7XG4gICAgICB9XG4gICAgICBwcm9wcy5wdXNoKCgwLCBfaW5kZXgub2JqZWN0UHJvcGVydHkpKG5vZGVLZXksIHZhbHVlVG9Ob2RlKHZhbHVlW2tleV0pKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2luZGV4Lm9iamVjdEV4cHJlc3Npb24pKHByb3BzKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJkb24ndCBrbm93IGhvdyB0byB0dXJuIHRoaXMgdmFsdWUgaW50byBhIG5vZGVcIik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlVG9Ob2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44544\n')},5158:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.patternLikeCommon = exports.importAttributes = exports.functionTypeAnnotationCommon = exports.functionDeclarationCommon = exports.functionCommon = exports.classMethodOrPropertyCommon = exports.classMethodOrDeclareMethodCommon = void 0;\nvar _is = __webpack_require__(93828);\nvar _isValidIdentifier = __webpack_require__(60983);\nvar _helperValidatorIdentifier = __webpack_require__(61000);\nvar _helperStringParser = __webpack_require__(53973);\nvar _index = __webpack_require__(93422);\nvar _utils = __webpack_require__(77596);\nconst defineType = (0, _utils.defineAliasedType)("Standardized");\ndefineType("ArrayExpression", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),\n      default: !process.env.BABEL_TYPES_8_BREAKING ? [] : undefined\n    }\n  },\n  visitor: ["elements"],\n  aliases: ["Expression"]\n});\ndefineType("AssignmentExpression", {\n  fields: {\n    operator: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function () {\n        const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);\n        const pattern = (0, _utils.assertOneOf)("=");\n        return function (node, key, val) {\n          const validator = (0, _is.default)("Pattern", node.left) ? pattern : identifier;\n          validator(node, key, val);\n        };\n      }(), {\n        type: "string"\n      })\n    },\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  builder: ["operator", "left", "right"],\n  visitor: ["left", "right"],\n  aliases: ["Expression"]\n});\ndefineType("BinaryExpression", {\n  builder: ["operator", "left", "right"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)\n    },\n    left: {\n      validate: function () {\n        const expression = (0, _utils.assertNodeType)("Expression");\n        const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.operator === "in" ? inOp : expression;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: ["Expression", "PrivateName"]\n        });\n        return validator;\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  visitor: ["left", "right"],\n  aliases: ["Binary", "Expression"]\n});\ndefineType("InterpreterDirective", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\ndefineType("Directive", {\n  visitor: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertNodeType)("DirectiveLiteral")\n    }\n  }\n});\ndefineType("DirectiveLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\ndefineType("BlockStatement", {\n  builder: ["body", "directives"],\n  visitor: ["directives", "body"],\n  fields: {\n    directives: {\n      validate: (0, _utils.arrayOfType)("Directive"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)("Statement")\n  },\n  aliases: ["Scopable", "BlockParent", "Block", "Statement"]\n});\ndefineType("BreakStatement", {\n  visitor: ["label"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    }\n  },\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"]\n});\ndefineType("CallExpression", {\n  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],\n  builder: ["callee", "arguments"],\n  aliases: ["Expression"],\n  fields: Object.assign({\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")\n    },\n    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder")\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  } : {}, {\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),\n      optional: true\n    }\n  })\n});\ndefineType("CatchClause", {\n  visitor: ["param", "body"],\n  fields: {\n    param: {\n      validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  },\n  aliases: ["Scopable", "BlockParent"]\n});\ndefineType("ConditionalExpression", {\n  visitor: ["test", "consequent", "alternate"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    alternate: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Expression", "Conditional"]\n});\ndefineType("ContinueStatement", {\n  visitor: ["label"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    }\n  },\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"]\n});\ndefineType("DebuggerStatement", {\n  aliases: ["Statement"]\n});\ndefineType("DoWhileStatement", {\n  builder: ["test", "body"],\n  visitor: ["body", "test"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  },\n  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]\n});\ndefineType("EmptyStatement", {\n  aliases: ["Statement"]\n});\ndefineType("ExpressionStatement", {\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Statement", "ExpressionWrapper"]\n});\ndefineType("File", {\n  builder: ["program", "comments", "tokens"],\n  visitor: ["program"],\n  fields: {\n    program: {\n      validate: (0, _utils.assertNodeType)("Program")\n    },\n    comments: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {}, {\n        each: {\n          oneOfNodeTypes: ["CommentBlock", "CommentLine"]\n        }\n      }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),\n      optional: true\n    },\n    tokens: {\n      validate: (0, _utils.assertEach)(Object.assign(() => {}, {\n        type: "any"\n      })),\n      optional: true\n    }\n  }\n});\ndefineType("ForInStatement", {\n  visitor: ["left", "right", "body"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],\n  fields: {\n    left: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\ndefineType("ForStatement", {\n  visitor: ["init", "test", "update", "body"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],\n  fields: {\n    init: {\n      validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),\n      optional: true\n    },\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    update: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\nconst functionCommon = () => ({\n  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),\n  generator: {\n    default: false\n  },\n  async: {\n    default: false\n  }\n});\nexports.functionCommon = functionCommon;\nconst functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n    optional: true\n  }\n});\nexports.functionTypeAnnotationCommon = functionTypeAnnotationCommon;\nconst functionDeclarationCommon = () => Object.assign({}, functionCommon(), {\n  declare: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  id: {\n    validate: (0, _utils.assertNodeType)("Identifier"),\n    optional: true\n  }\n});\nexports.functionDeclarationCommon = functionDeclarationCommon;\ndefineType("FunctionDeclaration", {\n  builder: ["id", "params", "body", "generator", "async"],\n  visitor: ["id", "typeParameters", "params", "returnType", "body"],\n  fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),\n      optional: true\n    }\n  }),\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)("Identifier");\n    return function (parent, key, node) {\n      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {\n        identifier(node, "id", node.id);\n      }\n    };\n  }()\n});\ndefineType("FunctionExpression", {\n  inherits: "FunctionDeclaration",\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),\n      optional: true\n    }\n  })\n});\nconst patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)("Decorator"),\n    optional: true\n  }\n});\nexports.patternLikeCommon = patternLikeCommon;\ndefineType("Identifier", {\n  builder: ["name"],\n  visitor: ["typeAnnotation", "decorators"],\n  aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    name: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {\n        if (!(0, _isValidIdentifier.default)(val, false)) {\n          throw new TypeError(`"${val}" is not a valid identifier name`);\n        }\n      }, {\n        type: "string"\n      })) : (0, _utils.assertValueType)("string")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key, node) {\n    const match = /\\.(\\w+)$/.exec(key);\n    if (!match) return;\n    const [, parentKey] = match;\n    const nonComp = {\n      computed: false\n    };\n    if (parentKey === "property") {\n      if ((0, _is.default)("MemberExpression", parent, nonComp)) return;\n      if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;\n    } else if (parentKey === "key") {\n      if ((0, _is.default)("Property", parent, nonComp)) return;\n      if ((0, _is.default)("Method", parent, nonComp)) return;\n    } else if (parentKey === "exported") {\n      if ((0, _is.default)("ExportSpecifier", parent)) return;\n    } else if (parentKey === "imported") {\n      if ((0, _is.default)("ImportSpecifier", parent, {\n        imported: node\n      })) return;\n    } else if (parentKey === "meta") {\n      if ((0, _is.default)("MetaProperty", parent, {\n        meta: node\n      })) return;\n    }\n    if (((0, _helperValidatorIdentifier.isKeyword)(node.name) || (0, _helperValidatorIdentifier.isReservedWord)(node.name, false)) && node.name !== "this") {\n      throw new TypeError(`"${node.name}" is not a valid identifier`);\n    }\n  } : undefined\n});\ndefineType("IfStatement", {\n  visitor: ["test", "consequent", "alternate"],\n  aliases: ["Statement", "Conditional"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    consequent: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    },\n    alternate: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\ndefineType("LabeledStatement", {\n  visitor: ["label", "body"],\n  aliases: ["Statement"],\n  fields: {\n    label: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\ndefineType("StringLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\ndefineType("NumericLiteral", {\n  builder: ["value"],\n  deprecatedAlias: "NumberLiteral",\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function (node, key, val) {\n        if (1 / val < 0 || !Number.isFinite(val)) {\n          const error = new Error("NumericLiterals must be non-negative finite numbers. " + `You can use t.valueToNode(${val}) instead.`);\n          {}\n        }\n      }, {\n        type: "number"\n      }))\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\ndefineType("NullLiteral", {\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\ndefineType("BooleanLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("boolean")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\ndefineType("RegExpLiteral", {\n  builder: ["pattern", "flags"],\n  deprecatedAlias: "RegexLiteral",\n  aliases: ["Expression", "Pureish", "Literal"],\n  fields: {\n    pattern: {\n      validate: (0, _utils.assertValueType)("string")\n    },\n    flags: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function (node, key, val) {\n        const invalid = /[^gimsuy]/.exec(val);\n        if (invalid) {\n          throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);\n        }\n      }, {\n        type: "string"\n      })) : (0, _utils.assertValueType)("string"),\n      default: ""\n    }\n  }\n});\ndefineType("LogicalExpression", {\n  builder: ["operator", "left", "right"],\n  visitor: ["left", "right"],\n  aliases: ["Binary", "Expression"],\n  fields: {\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)\n    },\n    left: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("MemberExpression", {\n  builder: ["object", "property", "computed", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])],\n  visitor: ["object", "property"],\n  aliases: ["Expression", "LVal"],\n  fields: Object.assign({\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression", "Super")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");\n        const computed = (0, _utils.assertNodeType)("Expression");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    }\n  }, !process.env.BABEL_TYPES_8_BREAKING ? {\n    optional: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  } : {})\n});\ndefineType("NewExpression", {\n  inherits: "CallExpression"\n});\ndefineType("Program", {\n  visitor: ["directives", "body"],\n  builder: ["body", "directives", "sourceType", "interpreter"],\n  fields: {\n    sourceType: {\n      validate: (0, _utils.assertOneOf)("script", "module"),\n      default: "script"\n    },\n    interpreter: {\n      validate: (0, _utils.assertNodeType)("InterpreterDirective"),\n      default: null,\n      optional: true\n    },\n    directives: {\n      validate: (0, _utils.arrayOfType)("Directive"),\n      default: []\n    },\n    body: (0, _utils.validateArrayOfType)("Statement")\n  },\n  aliases: ["Scopable", "BlockParent", "Block"]\n});\ndefineType("ObjectExpression", {\n  visitor: ["properties"],\n  aliases: ["Expression"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")\n  }\n});\ndefineType("ObjectMethod", {\n  builder: ["kind", "key", "params", "body", "computed", "generator", "async"],\n  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    kind: Object.assign({\n      validate: (0, _utils.assertOneOf)("method", "get", "set")\n    }, !process.env.BABEL_TYPES_8_BREAKING ? {\n      default: "method"\n    } : {}),\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");\n        const computed = (0, _utils.assertNodeType)("Expression");\n        const validator = function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];\n        return validator;\n      }()\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }),\n  aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]\n});\ndefineType("ObjectProperty", {\n  builder: ["key", "value", "computed", "shorthand", ...(!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])],\n  fields: {\n    computed: {\n      default: false\n    },\n    key: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");\n        const computed = (0, _utils.assertNodeType)("Expression");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]\n        });\n        return validator;\n      }()\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression", "PatternLike")\n    },\n    shorthand: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, shorthand) {\n        if (!shorthand) return;\n        if (node.computed) {\n          throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");\n        }\n        if (!(0, _is.default)("Identifier", node.key)) {\n          throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");\n        }\n      }, {\n        type: "boolean"\n      })) : (0, _utils.assertValueType)("boolean"),\n      default: false\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    }\n  },\n  visitor: ["key", "value", "decorators"],\n  aliases: ["UserWhitespacable", "Property", "ObjectMember"],\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const pattern = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");\n    const expression = (0, _utils.assertNodeType)("Expression");\n    return function (parent, key, node) {\n      const validator = (0, _is.default)("ObjectPattern", parent) ? pattern : expression;\n      validator(node, "value", node.value);\n    };\n  }()\n});\ndefineType("RestElement", {\n  visitor: ["argument", "typeAnnotation"],\n  builder: ["argument"],\n  aliases: ["LVal", "PatternLike"],\n  deprecatedAlias: "RestProperty",\n  fields: Object.assign({}, patternLikeCommon(), {\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")\n    }\n  }),\n  validate: process.env.BABEL_TYPES_8_BREAKING ? function (parent, key) {\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key);\n    if (!match) throw new Error("Internal Babel error: malformed key.");\n    const [, listKey, index] = match;\n    if (parent[listKey].length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  } : undefined\n});\ndefineType("ReturnStatement", {\n  visitor: ["argument"],\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    }\n  }\n});\ndefineType("SequenceExpression", {\n  visitor: ["expressions"],\n  fields: {\n    expressions: (0, _utils.validateArrayOfType)("Expression")\n  },\n  aliases: ["Expression"]\n});\ndefineType("ParenthesizedExpression", {\n  visitor: ["expression"],\n  aliases: ["Expression", "ExpressionWrapper"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("SwitchCase", {\n  visitor: ["test", "consequent"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    consequent: (0, _utils.validateArrayOfType)("Statement")\n  }\n});\ndefineType("SwitchStatement", {\n  visitor: ["discriminant", "cases"],\n  aliases: ["Statement", "BlockParent", "Scopable"],\n  fields: {\n    discriminant: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    cases: (0, _utils.validateArrayOfType)("SwitchCase")\n  }\n});\ndefineType("ThisExpression", {\n  aliases: ["Expression"]\n});\ndefineType("ThrowStatement", {\n  visitor: ["argument"],\n  aliases: ["Statement", "Terminatorless", "CompletionStatement"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("TryStatement", {\n  visitor: ["block", "handler", "finalizer"],\n  aliases: ["Statement"],\n  fields: {\n    block: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function (node) {\n        if (!node.handler && !node.finalizer) {\n          throw new TypeError("TryStatement expects either a handler or finalizer, or both");\n        }\n      }, {\n        oneOfNodeTypes: ["BlockStatement"]\n      })) : (0, _utils.assertNodeType)("BlockStatement")\n    },\n    handler: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("CatchClause")\n    },\n    finalizer: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  }\n});\ndefineType("UnaryExpression", {\n  builder: ["operator", "argument", "prefix"],\n  fields: {\n    prefix: {\n      default: true\n    },\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)\n    }\n  },\n  visitor: ["argument"],\n  aliases: ["UnaryLike", "Expression"]\n});\ndefineType("UpdateExpression", {\n  builder: ["operator", "argument", "prefix"],\n  fields: {\n    prefix: {\n      default: false\n    },\n    argument: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")\n    },\n    operator: {\n      validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)\n    }\n  },\n  visitor: ["argument"],\n  aliases: ["Expression"]\n});\ndefineType("VariableDeclaration", {\n  builder: ["kind", "declarations"],\n  visitor: ["declarations"],\n  aliases: ["Statement", "Declaration"],\n  fields: {\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    kind: {\n      validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")\n    },\n    declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")\n  },\n  validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {\n    const withoutInit = (0, _utils.assertNodeType)("Identifier");\n    return function (parent, key, node) {\n      if ((0, _is.default)("ForXStatement", parent, {\n        left: node\n      })) {\n        if (node.declarations.length !== 1) {\n          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);\n        }\n      } else {\n        node.declarations.forEach(decl => {\n          if (!decl.init) withoutInit(decl, "id", decl.id);\n        });\n      }\n    };\n  })() : undefined\n});\ndefineType("VariableDeclarator", {\n  visitor: ["id", "init"],\n  fields: {\n    id: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")\n    },\n    definite: {\n      optional: true,\n      validate: (0, _utils.assertValueType)("boolean")\n    },\n    init: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("WhileStatement", {\n  visitor: ["test", "body"],\n  aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],\n  fields: {\n    test: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\ndefineType("WithStatement", {\n  visitor: ["object", "body"],\n  aliases: ["Statement"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    }\n  }\n});\ndefineType("AssignmentPattern", {\n  visitor: ["left", "right", "decorators"],\n  builder: ["left", "right"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    left: {\n      validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    }\n  })\n});\ndefineType("ArrayPattern", {\n  visitor: ["elements", "typeAnnotation"],\n  builder: ["elements"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    elements: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))\n    }\n  })\n});\ndefineType("ArrowFunctionExpression", {\n  builder: ["params", "body", "async"],\n  visitor: ["typeParameters", "params", "returnType", "body"],\n  aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],\n  fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {\n    expression: {\n      validate: (0, _utils.assertValueType)("boolean")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")\n    },\n    predicate: {\n      validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),\n      optional: true\n    }\n  })\n});\ndefineType("ClassBody", {\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")\n  }\n});\ndefineType("ClassExpression", {\n  builder: ["id", "superClass", "body", "decorators"],\n  visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],\n  aliases: ["Scopable", "Class", "Expression"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("ClassBody")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)("InterfaceExtends"),\n      optional: true\n    }\n  }\n});\ndefineType("ClassDeclaration", {\n  inherits: "ClassExpression",\n  aliases: ["Scopable", "Class", "Statement", "Declaration"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),\n      optional: true\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("ClassBody")\n    },\n    superClass: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    superTypeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    },\n    implements: {\n      validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    mixins: {\n      validate: (0, _utils.assertNodeType)("InterfaceExtends"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    abstract: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  },\n  validate: !process.env.BABEL_TYPES_8_BREAKING ? undefined : function () {\n    const identifier = (0, _utils.assertNodeType)("Identifier");\n    return function (parent, key, node) {\n      if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {\n        identifier(node, "id", node.id);\n      }\n    };\n  }()\n});\nconst importAttributes = exports.importAttributes = {\n  attributes: {\n    optional: true,\n    validate: (0, _utils.arrayOfType)("ImportAttribute")\n  },\n  assertions: {\n    deprecated: true,\n    optional: true,\n    validate: (0, _utils.arrayOfType)("ImportAttribute")\n  }\n};\ndefineType("ExportAllDeclaration", {\n  builder: ["source"],\n  visitor: ["source", "attributes", "assertions"],\n  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],\n  fields: Object.assign({\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))\n  }, importAttributes)\n});\ndefineType("ExportDefaultDeclaration", {\n  visitor: ["declaration"],\n  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],\n  fields: {\n    declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))\n  }\n});\ndefineType("ExportNamedDeclaration", {\n  builder: ["declaration", "specifiers", "source"],\n  visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],\n  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],\n  fields: Object.assign({\n    declaration: {\n      optional: true,\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function (node, key, val) {\n        if (val && node.specifiers.length) {\n          throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");\n        }\n        if (val && node.source) {\n          throw new TypeError("Cannot export a declaration from a source");\n        }\n      }, {\n        oneOfNodeTypes: ["Declaration"]\n      })) : (0, _utils.assertNodeType)("Declaration")\n    }\n  }, importAttributes, {\n    specifiers: {\n      default: [],\n      validate: (0, _utils.arrayOf)(function () {\n        const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");\n        const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");\n        if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;\n        return Object.assign(function (node, key, val) {\n          const validator = node.source ? sourced : sourceless;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]\n        });\n      }())\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral"),\n      optional: true\n    },\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))\n  })\n});\ndefineType("ExportSpecifier", {\n  visitor: ["local", "exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    },\n    exportKind: {\n      validate: (0, _utils.assertOneOf)("type", "value"),\n      optional: true\n    }\n  }\n});\ndefineType("ForOfStatement", {\n  visitor: ["left", "right", "body"],\n  builder: ["left", "right", "body", "await"],\n  aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],\n  fields: {\n    left: {\n      validate: function () {\n        if (!process.env.BABEL_TYPES_8_BREAKING) {\n          return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");\n        }\n        const declaration = (0, _utils.assertNodeType)("VariableDeclaration");\n        const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");\n        return Object.assign(function (node, key, val) {\n          if ((0, _is.default)("VariableDeclaration", val)) {\n            declaration(node, key, val);\n          } else {\n            lval(node, key, val);\n          }\n        }, {\n          oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]\n        });\n      }()\n    },\n    right: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("Statement")\n    },\n    await: {\n      default: false\n    }\n  }\n});\ndefineType("ImportDeclaration", {\n  builder: ["specifiers", "source"],\n  visitor: ["specifiers", "source", "attributes", "assertions"],\n  aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],\n  fields: Object.assign({}, importAttributes, {\n    module: {\n      optional: true,\n      validate: (0, _utils.assertValueType)("boolean")\n    },\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)("source", "defer")\n    },\n    specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),\n    source: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),\n      optional: true\n    }\n  })\n});\ndefineType("ImportDefaultSpecifier", {\n  visitor: ["local"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\ndefineType("ImportNamespaceSpecifier", {\n  visitor: ["local"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\ndefineType("ImportSpecifier", {\n  visitor: ["imported", "local"],\n  builder: ["local", "imported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    local: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    imported: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    },\n    importKind: {\n      validate: (0, _utils.assertOneOf)("type", "typeof", "value"),\n      optional: true\n    }\n  }\n});\ndefineType("ImportExpression", {\n  visitor: ["source", "options"],\n  aliases: ["Expression"],\n  fields: {\n    phase: {\n      default: null,\n      validate: (0, _utils.assertOneOf)("source", "defer")\n    },\n    source: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    options: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    }\n  }\n});\ndefineType("MetaProperty", {\n  visitor: ["meta", "property"],\n  aliases: ["Expression"],\n  fields: {\n    meta: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function (node, key, val) {\n        let property;\n        switch (val.name) {\n          case "function":\n            property = "sent";\n            break;\n          case "new":\n            property = "target";\n            break;\n          case "import":\n            property = "meta";\n            break;\n        }\n        if (!(0, _is.default)("Identifier", node.property, {\n          name: property\n        })) {\n          throw new TypeError("Unrecognised MetaProperty");\n        }\n      }, {\n        oneOfNodeTypes: ["Identifier"]\n      })) : (0, _utils.assertNodeType)("Identifier")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\nconst classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  accessibility: {\n    validate: (0, _utils.assertOneOf)("public", "private", "protected"),\n    optional: true\n  },\n  static: {\n    default: false\n  },\n  override: {\n    default: false\n  },\n  computed: {\n    default: false\n  },\n  optional: {\n    validate: (0, _utils.assertValueType)("boolean"),\n    optional: true\n  },\n  key: {\n    validate: (0, _utils.chain)(function () {\n      const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");\n      const computed = (0, _utils.assertNodeType)("Expression");\n      return function (node, key, val) {\n        const validator = node.computed ? computed : normal;\n        validator(node, key, val);\n      };\n    }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))\n  }\n});\nexports.classMethodOrPropertyCommon = classMethodOrPropertyCommon;\nconst classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {\n  params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),\n  kind: {\n    validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),\n    default: "method"\n  },\n  access: {\n    validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),\n    optional: true\n  },\n  decorators: {\n    validate: (0, _utils.arrayOfType)("Decorator"),\n    optional: true\n  }\n});\nexports.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;\ndefineType("ClassMethod", {\n  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],\n  builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],\n  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  })\n});\ndefineType("ObjectPattern", {\n  visitor: ["properties", "typeAnnotation", "decorators"],\n  builder: ["properties"],\n  aliases: ["Pattern", "PatternLike", "LVal"],\n  fields: Object.assign({}, patternLikeCommon(), {\n    properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")\n  })\n});\ndefineType("SpreadElement", {\n  visitor: ["argument"],\n  aliases: ["UnaryLike"],\n  deprecatedAlias: "SpreadProperty",\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("Super", {\n  aliases: ["Expression"]\n});\ndefineType("TaggedTemplateExpression", {\n  visitor: ["tag", "typeParameters", "quasi"],\n  builder: ["tag", "quasi"],\n  aliases: ["Expression"],\n  fields: {\n    tag: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    quasi: {\n      validate: (0, _utils.assertNodeType)("TemplateLiteral")\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\ndefineType("TemplateElement", {\n  builder: ["value", "tail"],\n  fields: {\n    value: {\n      validate: (0, _utils.chain)((0, _utils.assertShape)({\n        raw: {\n          validate: (0, _utils.assertValueType)("string")\n        },\n        cooked: {\n          validate: (0, _utils.assertValueType)("string"),\n          optional: true\n        }\n      }), function templateElementCookedValidator(node) {\n        const raw = node.value.raw;\n        let unterminatedCalled = false;\n        const error = () => {\n          throw new Error("Internal @babel/types error.");\n        };\n        const {\n          str,\n          firstInvalidLoc\n        } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {\n          unterminated() {\n            unterminatedCalled = true;\n          },\n          strictNumericEscape: error,\n          invalidEscapeSequence: error,\n          numericSeparatorInEscapeSequence: error,\n          unexpectedNumericSeparator: error,\n          invalidDigit: error,\n          invalidCodePoint: error\n        });\n        if (!unterminatedCalled) throw new Error("Invalid raw");\n        node.value.cooked = firstInvalidLoc ? null : str;\n      })\n    },\n    tail: {\n      default: false\n    }\n  }\n});\ndefineType("TemplateLiteral", {\n  visitor: ["quasis", "expressions"],\n  aliases: ["Expression", "Literal"],\n  fields: {\n    quasis: (0, _utils.validateArrayOfType)("TemplateElement"),\n    expressions: {\n      validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function (node, key, val) {\n        if (node.quasis.length !== val.length + 1) {\n          throw new TypeError(`Number of ${node.type} quasis should be exactly one more than the number of expressions.\\nExpected ${val.length + 1} quasis but got ${node.quasis.length}`);\n        }\n      })\n    }\n  }\n});\ndefineType("YieldExpression", {\n  builder: ["argument", "delegate"],\n  visitor: ["argument"],\n  aliases: ["Expression", "Terminatorless"],\n  fields: {\n    delegate: {\n      validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function (node, key, val) {\n        if (val && !node.argument) {\n          throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");\n        }\n      }, {\n        type: "boolean"\n      })) : (0, _utils.assertValueType)("boolean"),\n      default: false\n    },\n    argument: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("AwaitExpression", {\n  builder: ["argument"],\n  visitor: ["argument"],\n  aliases: ["Expression", "Terminatorless"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("Import", {\n  aliases: ["Expression"]\n});\ndefineType("BigIntLiteral", {\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  },\n  aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n});\ndefineType("ExportNamespaceSpecifier", {\n  visitor: ["exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\ndefineType("OptionalMemberExpression", {\n  builder: ["object", "property", "computed", "optional"],\n  visitor: ["object", "property"],\n  aliases: ["Expression"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    property: {\n      validate: function () {\n        const normal = (0, _utils.assertNodeType)("Identifier");\n        const computed = (0, _utils.assertNodeType)("Expression");\n        const validator = Object.assign(function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        }, {\n          oneOfNodeTypes: ["Expression", "Identifier"]\n        });\n        return validator;\n      }()\n    },\n    computed: {\n      default: false\n    },\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())\n    }\n  }\n});\ndefineType("OptionalCallExpression", {\n  visitor: ["callee", "arguments", "typeParameters", "typeArguments"],\n  builder: ["callee", "arguments", "optional"],\n  aliases: ["Expression"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),\n    optional: {\n      validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())\n    },\n    typeArguments: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),\n      optional: true\n    },\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\ndefineType("ClassProperty", {\n  visitor: ["decorators", "key", "typeAnnotation", "value"],\n  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],\n  aliases: ["Property"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)("Variance"),\n      optional: true\n    }\n  })\n});\ndefineType("ClassAccessorProperty", {\n  visitor: ["decorators", "key", "typeAnnotation", "value"],\n  builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],\n  aliases: ["Property", "Accessor"],\n  fields: Object.assign({}, classMethodOrPropertyCommon(), {\n    key: {\n      validate: (0, _utils.chain)(function () {\n        const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");\n        const computed = (0, _utils.assertNodeType)("Expression");\n        return function (node, key, val) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n      }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    declare: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)("Variance"),\n      optional: true\n    }\n  })\n});\ndefineType("ClassPrivateProperty", {\n  visitor: ["decorators", "key", "typeAnnotation", "value"],\n  builder: ["key", "value", "decorators", "static"],\n  aliases: ["Property", "Private"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)("PrivateName")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    },\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    },\n    static: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      default: false\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    definite: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    variance: {\n      validate: (0, _utils.assertNodeType)("Variance"),\n      optional: true\n    }\n  }\n});\ndefineType("ClassPrivateMethod", {\n  builder: ["kind", "key", "params", "body", "static"],\n  visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],\n  aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],\n  fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)("get", "set", "method"),\n      default: "method"\n    },\n    key: {\n      validate: (0, _utils.assertNodeType)("PrivateName")\n    },\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    }\n  })\n});\ndefineType("PrivateName", {\n  visitor: ["id"],\n  aliases: ["Private"],\n  fields: {\n    id: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\ndefineType("StaticBlock", {\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("Statement")\n  },\n  aliases: ["Scopable", "BlockParent", "FunctionParent"]\n});\n\n//# sourceMappingURL=core.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTE1OC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRix5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxvQ0FBb0MsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0IsR0FBRyxtQ0FBbUMsR0FBRyx3Q0FBd0M7QUFDek8sVUFBVSxtQkFBTyxDQUFDLEtBQXFCO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLEtBQW9DO0FBQ3JFLGlDQUFpQyxtQkFBTyxDQUFDLEtBQW9DO0FBQzdFLDBCQUEwQixtQkFBTyxDQUFDLEtBQTZCO0FBQy9ELGFBQWEsbUJBQU8sQ0FBQyxLQUF1QjtBQUM1QyxhQUFhLG1CQUFPLENBQUMsS0FBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQyx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILElBQUk7QUFDN0g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxXQUFXO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsUUFBUTtBQUN6RTtBQUNBLElBQUk7QUFDSixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRHQUE0RyxZQUFZO0FBQ3hIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxtQ0FBbUM7QUFDbkMsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXLDhFQUE4RSxnQkFBZ0IsaUJBQWlCLG1CQUFtQjtBQUN4TDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2NvcmUuanM/MzFlOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucGF0dGVybkxpa2VDb21tb24gPSBleHBvcnRzLmltcG9ydEF0dHJpYnV0ZXMgPSBleHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24gPSBleHBvcnRzLmZ1bmN0aW9uQ29tbW9uID0gZXhwb3J0cy5jbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24gPSBleHBvcnRzLmNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uID0gdm9pZCAwO1xudmFyIF9pcyA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzLmpzXCIpO1xudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2lzVmFsaWRJZGVudGlmaWVyLmpzXCIpO1xudmFyIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyID0gcmVxdWlyZShcIkBiYWJlbC9oZWxwZXItdmFsaWRhdG9yLWlkZW50aWZpZXJcIik7XG52YXIgX2hlbHBlclN0cmluZ1BhcnNlciA9IHJlcXVpcmUoXCJAYmFiZWwvaGVscGVyLXN0cmluZy1wYXJzZXJcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9pbmRleC5qc1wiKTtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IGRlZmluZVR5cGUgPSAoMCwgX3V0aWxzLmRlZmluZUFsaWFzZWRUeXBlKShcIlN0YW5kYXJkaXplZFwiKTtcbmRlZmluZVR5cGUoXCJBcnJheUV4cHJlc3Npb25cIiwge1xuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZikoKDAsIF91dGlscy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUpKFwibnVsbFwiLCBcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpKSxcbiAgICAgIGRlZmF1bHQ6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gW10gOiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLCB7XG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikgOiBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKC4uLl9pbmRleC5BU1NJR05NRU5UX09QRVJBVE9SUyk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcIj1cIik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSAoMCwgX2lzLmRlZmF1bHQpKFwiUGF0dGVyblwiLCBub2RlLmxlZnQpID8gcGF0dGVybiA6IGlkZW50aWZpZXI7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIsIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiXSxcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJCaW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2luZGV4LkJJTkFSWV9PUEVSQVRPUlMpXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBleHByZXNzaW9uID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCBpbk9wID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5vcGVyYXRvciA9PT0gXCJpblwiID8gaW5PcCA6IGV4cHJlc3Npb247XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIl1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9LFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIkludGVycHJldGVyRGlyZWN0aXZlXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEaXJlY3RpdmVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRpcmVjdGl2ZUxpdGVyYWxcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRpcmVjdGl2ZUxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkJsb2NrU3RhdGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIl0sXG4gIHZpc2l0b3I6IFtcImRpcmVjdGl2ZXNcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXJlY3RpdmVzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEaXJlY3RpdmVcIiksXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlN0YXRlbWVudFwiKVxuICB9LFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiQmxvY2tcIiwgXCJTdGF0ZW1lbnRcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkJyZWFrU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wibGFiZWxcIl0sXG4gIGZpZWxkczoge1xuICAgIGxhYmVsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQ2FsbEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInR5cGVBcmd1bWVudHNcIl0sXG4gIGJ1aWxkZXI6IFtcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTdXBlclwiLCBcIlY4SW50cmluc2ljSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgYXJndW1lbnRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlNwcmVhZEVsZW1lbnRcIiwgXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIpXG4gIH0sICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8ge1xuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9IDoge30sIHtcbiAgICB0eXBlQXJndW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiQ2F0Y2hDbGF1c2VcIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbVwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNvbnNlcXVlbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIkNvbmRpdGlvbmFsXCJdXG59KTtcbmRlZmluZVR5cGUoXCJDb250aW51ZVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImxhYmVsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsYWJlbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkRlYnVnZ2VyU3RhdGVtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdXG59KTtcbmRlZmluZVR5cGUoXCJEb1doaWxlU3RhdGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1widGVzdFwiLCBcImJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcImJvZHlcIiwgXCJ0ZXN0XCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIldoaWxlXCIsIFwiU2NvcGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkVtcHR5U3RhdGVtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdXG59KTtcbmRlZmluZVR5cGUoXCJFeHByZXNzaW9uU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCIsIFwiRXhwcmVzc2lvbldyYXBwZXJcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkZpbGVcIiwge1xuICBidWlsZGVyOiBbXCJwcm9ncmFtXCIsIFwiY29tbWVudHNcIiwgXCJ0b2tlbnNcIl0sXG4gIHZpc2l0b3I6IFtcInByb2dyYW1cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb2dyYW06IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByb2dyYW1cIilcbiAgICB9LFxuICAgIGNvbW1lbnRzOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIGVhY2g6IHtcbiAgICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiQ29tbWVudEJsb2NrXCIsIFwiQ29tbWVudExpbmVcIl1cbiAgICAgICAgfVxuICAgICAgfSkgOiAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ29tbWVudEJsb2NrXCIsIFwiQ29tbWVudExpbmVcIikpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHRva2Vuczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICB0eXBlOiBcImFueVwiXG4gICAgICB9KSksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRm9ySW5TdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIlN0YXRlbWVudFwiLCBcIkZvclwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIkZvclhTdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkxWYWxcIikgOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkZvclN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImluaXRcIiwgXCJ0ZXN0XCIsIFwidXBkYXRlXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJTdGF0ZW1lbnRcIiwgXCJGb3JcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkxvb3BcIl0sXG4gIGZpZWxkczoge1xuICAgIGluaXQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdXBkYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBmdW5jdGlvbkNvbW1vbiA9ICgpID0+ICh7XG4gIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIklkZW50aWZpZXJcIiwgXCJQYXR0ZXJuXCIsIFwiUmVzdEVsZW1lbnRcIiksXG4gIGdlbmVyYXRvcjoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIGFzeW5jOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfVxufSk7XG5leHBvcnRzLmZ1bmN0aW9uQ29tbW9uID0gZnVuY3Rpb25Db21tb247XG5jb25zdCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uID0gKCkgPT4gKHtcbiAgcmV0dXJuVHlwZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufSk7XG5leHBvcnRzLmZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uO1xuY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9ICgpID0+IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uKCksIHtcbiAgZGVjbGFyZToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGlkOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbiA9IGZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb247XG5kZWZpbmVUeXBlKFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImdlbmVyYXRvclwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiLCBcImJvZHlcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25EZWNsYXJhdGlvbkNvbW1vbigpLCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKCksIHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgcHJlZGljYXRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNsYXJlZFByZWRpY2F0ZVwiLCBcIkluZmVycmVkUHJlZGljYXRlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0pLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIlN0YXRlbWVudFwiLCBcIlB1cmVpc2hcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXJlbnQsIGtleSwgbm9kZSkge1xuICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIsIHBhcmVudCkpIHtcbiAgICAgICAgaWRlbnRpZmllcihub2RlLCBcImlkXCIsIG5vZGUuaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKVxufSk7XG5kZWZpbmVUeXBlKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfSxcbiAgICBwcmVkaWNhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkRlY2xhcmVkUHJlZGljYXRlXCIsIFwiSW5mZXJyZWRQcmVkaWNhdGVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuY29uc3QgcGF0dGVybkxpa2VDb21tb24gPSAoKSA9PiAoe1xuICB0eXBlQW5ub3RhdGlvbjoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgb3B0aW9uYWw6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9LFxuICBkZWNvcmF0b3JzOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH1cbn0pO1xuZXhwb3J0cy5wYXR0ZXJuTGlrZUNvbW1vbiA9IHBhdHRlcm5MaWtlQ29tbW9uO1xuZGVmaW5lVHlwZShcIklkZW50aWZpZXJcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIiwgXCJUU0VudGl0eU5hbWVcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24oKSwge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBpZiAoISgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkodmFsLCBmYWxzZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7dmFsfVwiIGlzIG5vdCBhIHZhbGlkIGlkZW50aWZpZXIgbmFtZWApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSksXG4gIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvXFwuKFxcdyspJC8uZXhlYyhrZXkpO1xuICAgIGlmICghbWF0Y2gpIHJldHVybjtcbiAgICBjb25zdCBbLCBwYXJlbnRLZXldID0gbWF0Y2g7XG4gICAgY29uc3Qgbm9uQ29tcCA9IHtcbiAgICAgIGNvbXB1dGVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKHBhcmVudEtleSA9PT0gXCJwcm9wZXJ0eVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIk1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwgcGFyZW50LCBub25Db21wKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcImtleVwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlByb3BlcnR5XCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiTWV0aG9kXCIsIHBhcmVudCwgbm9uQ29tcCkpIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBhcmVudEtleSA9PT0gXCJleHBvcnRlZFwiKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydFNwZWNpZmllclwiLCBwYXJlbnQpKSByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwYXJlbnRLZXkgPT09IFwiaW1wb3J0ZWRcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJJbXBvcnRTcGVjaWZpZXJcIiwgcGFyZW50LCB7XG4gICAgICAgIGltcG9ydGVkOiBub2RlXG4gICAgICB9KSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGFyZW50S2V5ID09PSBcIm1ldGFcIikge1xuICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJNZXRhUHJvcGVydHlcIiwgcGFyZW50LCB7XG4gICAgICAgIG1ldGE6IG5vZGVcbiAgICAgIH0pKSByZXR1cm47XG4gICAgfVxuICAgIGlmICgoKDAsIF9oZWxwZXJWYWxpZGF0b3JJZGVudGlmaWVyLmlzS2V5d29yZCkobm9kZS5uYW1lKSB8fCAoMCwgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIuaXNSZXNlcnZlZFdvcmQpKG5vZGUubmFtZSwgZmFsc2UpKSAmJiBub2RlLm5hbWUgIT09IFwidGhpc1wiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7bm9kZS5uYW1lfVwiIGlzIG5vdCBhIHZhbGlkIGlkZW50aWZpZXJgKTtcbiAgICB9XG4gIH0gOiB1bmRlZmluZWRcbn0pO1xuZGVmaW5lVHlwZShcIklmU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImNvbnNlcXVlbnRcIiwgXCJhbHRlcm5hdGVcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkNvbmRpdGlvbmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0ZXN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGFsdGVybmF0ZToge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkxhYmVsZWRTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsYWJlbFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiU3RyaW5nTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbmRlZmluZVR5cGUoXCJOdW1lcmljTGl0ZXJhbFwiLCB7XG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBkZXByZWNhdGVkQWxpYXM6IFwiTnVtYmVyTGl0ZXJhbFwiLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcIm51bWJlclwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKDEgLyB2YWwgPCAwIHx8ICFOdW1iZXIuaXNGaW5pdGUodmFsKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiTnVtZXJpY0xpdGVyYWxzIG11c3QgYmUgbm9uLW5lZ2F0aXZlIGZpbml0ZSBudW1iZXJzLiBcIiArIGBZb3UgY2FuIHVzZSB0LnZhbHVlVG9Ob2RlKCR7dmFsfSkgaW5zdGVhZC5gKTtcbiAgICAgICAgICB7fVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCJcbiAgICAgIH0pKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCIsIFwiSW1tdXRhYmxlXCJdXG59KTtcbmRlZmluZVR5cGUoXCJOdWxsTGl0ZXJhbFwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQm9vbGVhbkxpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIlJlZ0V4cExpdGVyYWxcIiwge1xuICBidWlsZGVyOiBbXCJwYXR0ZXJuXCIsIFwiZmxhZ3NcIl0sXG4gIGRlcHJlY2F0ZWRBbGlhczogXCJSZWdleExpdGVyYWxcIixcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiLCBcIlB1cmVpc2hcIiwgXCJMaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXR0ZXJuOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfSxcbiAgICBmbGFnczoge1xuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGNvbnN0IGludmFsaWQgPSAvW15naW1zdXldLy5leGVjKHZhbCk7XG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke2ludmFsaWRbMF19XCIgaXMgbm90IGEgdmFsaWQgUmVnRXhwIGZsYWdgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiXG4gICAgICB9KSkgOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksXG4gICAgICBkZWZhdWx0OiBcIlwiXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJMb2dpY2FsRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkJpbmFyeVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZXJhdG9yOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoLi4uX2luZGV4LkxPR0lDQUxfT1BFUkFUT1JTKVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIC4uLighcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IFtcIm9wdGlvbmFsXCJdIDogW10pXSxcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlN1cGVyXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsaWRhdG9yLm9uZU9mTm9kZVR5cGVzID0gW1wiRXhwcmVzc2lvblwiLCBcIklkZW50aWZpZXJcIiwgXCJQcml2YXRlTmFtZVwiXTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRvcjtcbiAgICAgIH0oKVxuICAgIH0sXG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfVxuICB9LCAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvcHRpb25hbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSA6IHt9KVxufSk7XG5kZWZpbmVUeXBlKFwiTmV3RXhwcmVzc2lvblwiLCB7XG4gIGluaGVyaXRzOiBcIkNhbGxFeHByZXNzaW9uXCJcbn0pO1xuZGVmaW5lVHlwZShcIlByb2dyYW1cIiwge1xuICB2aXNpdG9yOiBbXCJkaXJlY3RpdmVzXCIsIFwiYm9keVwiXSxcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImRpcmVjdGl2ZXNcIiwgXCJzb3VyY2VUeXBlXCIsIFwiaW50ZXJwcmV0ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIHNvdXJjZVR5cGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInNjcmlwdFwiLCBcIm1vZHVsZVwiKSxcbiAgICAgIGRlZmF1bHQ6IFwic2NyaXB0XCJcbiAgICB9LFxuICAgIGludGVycHJldGVyOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKSxcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGlyZWN0aXZlczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGlyZWN0aXZlXCIpLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9LFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkJsb2NrXCJdXG59KTtcbmRlZmluZVR5cGUoXCJPYmplY3RFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicHJvcGVydGllc1wiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJvcGVydGllczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIk9iamVjdE1ldGhvZFwiLCBcIk9iamVjdFByb3BlcnR5XCIsIFwiU3ByZWFkRWxlbWVudFwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPYmplY3RNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcImRlY29yYXRvcnNcIiwgXCJrZXlcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGtpbmQ6IE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwibWV0aG9kXCIsIFwiZ2V0XCIsIFwic2V0XCIpXG4gICAgfSwgIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB7XG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSA6IHt9KSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGtleToge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiLCBcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiKTtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSksXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCIsIFwiRnVuY3Rpb25cIiwgXCJTY29wYWJsZVwiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIiwgXCJNZXRob2RcIiwgXCJPYmplY3RNZW1iZXJcIl1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFByb3BlcnR5XCIsIHtcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJjb21wdXRlZFwiLCBcInNob3J0aGFuZFwiLCAuLi4oIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBbXCJkZWNvcmF0b3JzXCJdIDogW10pXSxcbiAgZmllbGRzOiB7XG4gICAgY29tcHV0ZWQ6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJEZWNpbWFsTGl0ZXJhbFwiLCBcIlByaXZhdGVOYW1lXCIpO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLmNvbXB1dGVkID8gY29tcHV0ZWQgOiBub3JtYWw7XG4gICAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCIsIFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJEZWNpbWFsTGl0ZXJhbFwiLCBcIlByaXZhdGVOYW1lXCJdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgfSgpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIlBhdHRlcm5MaWtlXCIpXG4gICAgfSxcbiAgICBzaG9ydGhhbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCBzaG9ydGhhbmQpIHtcbiAgICAgICAgaWYgKCFzaG9ydGhhbmQpIHJldHVybjtcbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcGVydHkgc2hvcnRoYW5kIG9mIE9iamVjdFByb3BlcnR5IGNhbm5vdCBiZSB0cnVlIGlmIGNvbXB1dGVkIGlzIHRydWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCBub2RlLmtleSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvcGVydHkgc2hvcnRoYW5kIG9mIE9iamVjdFByb3BlcnR5IGNhbm5vdCBiZSB0cnVlIGlmIGtleSBpcyBub3QgYW4gSWRlbnRpZmllclwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIlxuICAgICAgfSkpIDogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICBhbGlhc2VzOiBbXCJVc2VyV2hpdGVzcGFjYWJsZVwiLCBcIlByb3BlcnR5XCIsIFwiT2JqZWN0TWVtYmVyXCJdLFxuICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGF0dGVybiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlBhdHRlcm5cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIiwgXCJUU1R5cGVBc3NlcnRpb25cIik7XG4gICAgY29uc3QgZXhwcmVzc2lvbiA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHBhcmVudCwga2V5LCBub2RlKSB7XG4gICAgICBjb25zdCB2YWxpZGF0b3IgPSAoMCwgX2lzLmRlZmF1bHQpKFwiT2JqZWN0UGF0dGVyblwiLCBwYXJlbnQpID8gcGF0dGVybiA6IGV4cHJlc3Npb247XG4gICAgICB2YWxpZGF0b3Iobm9kZSwgXCJ2YWx1ZVwiLCBub2RlLnZhbHVlKTtcbiAgICB9O1xuICB9KClcbn0pO1xuZGVmaW5lVHlwZShcIlJlc3RFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkxWYWxcIiwgXCJQYXR0ZXJuTGlrZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIlJlc3RQcm9wZXJ0eVwiLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uKCksIHtcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJMVmFsXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0pLFxuICB2YWxpZGF0ZTogcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IGZ1bmN0aW9uIChwYXJlbnQsIGtleSkge1xuICAgIGNvbnN0IG1hdGNoID0gLyhcXHcrKVxcWyhcXGQrKVxcXS8uZXhlYyhrZXkpO1xuICAgIGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEJhYmVsIGVycm9yOiBtYWxmb3JtZWQga2V5LlwiKTtcbiAgICBjb25zdCBbLCBsaXN0S2V5LCBpbmRleF0gPSBtYXRjaDtcbiAgICBpZiAocGFyZW50W2xpc3RLZXldLmxlbmd0aCA+ICtpbmRleCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlc3RFbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50IG9mICR7bGlzdEtleX1gKTtcbiAgICB9XG4gIH0gOiB1bmRlZmluZWRcbn0pO1xuZGVmaW5lVHlwZShcIlJldHVyblN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJUZXJtaW5hdG9ybGVzc1wiLCBcIkNvbXBsZXRpb25TdGF0ZW1lbnRcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlNlcXVlbmNlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiRXhwcmVzc2lvbldyYXBwZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlN3aXRjaENhc2VcIiwge1xuICB2aXNpdG9yOiBbXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgdGVzdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBjb25zZXF1ZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiU3RhdGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlN3aXRjaFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJCbG9ja1BhcmVudFwiLCBcIlNjb3BhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBkaXNjcmltaW5hbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGNhc2VzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiU3dpdGNoQ2FzZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUaGlzRXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlRocm93U3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIlRlcm1pbmF0b3JsZXNzXCIsIFwiQ29tcGxldGlvblN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRyeVN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcImJsb2NrXCIsIFwiaGFuZGxlclwiLCBcImZpbmFsaXplclwiXSxcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICBmaWVsZHM6IHtcbiAgICBibG9jazoge1xuICAgICAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUcnlTdGF0ZW1lbnQgZXhwZWN0cyBlaXRoZXIgYSBoYW5kbGVyIG9yIGZpbmFsaXplciwgb3IgYm90aFwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiQmxvY2tTdGF0ZW1lbnRcIl1cbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQmxvY2tTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGhhbmRsZXI6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiQ2F0Y2hDbGF1c2VcIilcbiAgICB9LFxuICAgIGZpbmFsaXplcjoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVW5hcnlFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcHJlZml4OiB7XG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5faW5kZXguVU5BUllfT1BFUkFUT1JTKVxuICAgIH1cbiAgfSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiLCBcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlVwZGF0ZUV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvcGVyYXRvclwiLCBcImFyZ3VtZW50XCIsIFwicHJlZml4XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcmVmaXg6IHtcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBhcmd1bWVudDoge1xuICAgICAgdmFsaWRhdGU6ICFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3BlcmF0b3I6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5faW5kZXguVVBEQVRFX09QRVJBVE9SUylcbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiLCBcImRlY2xhcmF0aW9uc1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjbGFyYXRpb25zXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidmFyXCIsIFwibGV0XCIsIFwiY29uc3RcIiwgXCJ1c2luZ1wiLCBcImF3YWl0IHVzaW5nXCIpXG4gICAgfSxcbiAgICBkZWNsYXJhdGlvbnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJWYXJpYWJsZURlY2xhcmF0b3JcIilcbiAgfSxcbiAgdmFsaWRhdGU6IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoKCkgPT4ge1xuICAgIGNvbnN0IHdpdGhvdXRJbml0ID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgIGlmICgoMCwgX2lzLmRlZmF1bHQpKFwiRm9yWFN0YXRlbWVudFwiLCBwYXJlbnQsIHtcbiAgICAgICAgbGVmdDogbm9kZVxuICAgICAgfSkpIHtcbiAgICAgICAgaWYgKG5vZGUuZGVjbGFyYXRpb25zLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4YWN0bHkgb25lIFZhcmlhYmxlRGVjbGFyYXRvciBpcyByZXF1aXJlZCBpbiB0aGUgVmFyaWFibGVEZWNsYXJhdGlvbiBvZiBhICR7cGFyZW50LnR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb25zLmZvckVhY2goZGVjbCA9PiB7XG4gICAgICAgICAgaWYgKCFkZWNsLmluaXQpIHdpdGhvdXRJbml0KGRlY2wsIFwiaWRcIiwgZGVjbC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCkgOiB1bmRlZmluZWRcbn0pO1xuZGVmaW5lVHlwZShcIlZhcmlhYmxlRGVjbGFyYXRvclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdFwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiTFZhbFwiKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIilcbiAgICB9LFxuICAgIGRlZmluaXRlOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBpbml0OiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIldoaWxlU3RhdGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1widGVzdFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkJsb2NrUGFyZW50XCIsIFwiTG9vcFwiLCBcIldoaWxlXCIsIFwiU2NvcGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHRlc3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0YXRlbWVudFwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiV2l0aFN0YXRlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkFzc2lnbm1lbnRQYXR0ZXJuXCIsIHtcbiAgdmlzaXRvcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiZGVjb3JhdG9yc1wiXSxcbiAgYnVpbGRlcjogW1wibGVmdFwiLCBcInJpZ2h0XCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uKCksIHtcbiAgICBsZWZ0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk1lbWJlckV4cHJlc3Npb25cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkFycmF5UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJQYXR0ZXJuXCIsIFwiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIHBhdHRlcm5MaWtlQ29tbW9uKCksIHtcbiAgICBlbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImFycmF5XCIpLCAoMCwgX3V0aWxzLmFzc2VydEVhY2gpKCgwLCBfdXRpbHMuYXNzZXJ0Tm9kZU9yVmFsdWVUeXBlKShcIm51bGxcIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIikpKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wicGFyYW1zXCIsIFwiYm9keVwiLCBcImFzeW5jXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJTY29wYWJsZVwiLCBcIkZ1bmN0aW9uXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJGdW5jdGlvblBhcmVudFwiLCBcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGZ1bmN0aW9uQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiLCBcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByZWRpY2F0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiQ2xhc3NCb2R5XCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkNsYXNzTWV0aG9kXCIsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIFwiQ2xhc3NQcm9wZXJ0eVwiLCBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIsIFwiVFNEZWNsYXJlTWV0aG9kXCIsIFwiVFNJbmRleFNpZ25hdHVyZVwiLCBcIlN0YXRpY0Jsb2NrXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwic3VwZXJDbGFzc1wiLCBcImJvZHlcIiwgXCJkZWNvcmF0b3JzXCJdLFxuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVyQ2xhc3NcIiwgXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIsIFwibWl4aW5zXCIsIFwiaW1wbGVtZW50c1wiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiwgXCJOb29wXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkNsYXNzQm9keVwiKVxuICAgIH0sXG4gICAgc3VwZXJDbGFzczoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBzdXBlclR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgaW1wbGVtZW50czoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIiwgXCJDbGFzc0ltcGxlbWVudHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIG1peGluczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc0RlY2xhcmF0aW9uXCIsIHtcbiAgaW5oZXJpdHM6IFwiQ2xhc3NFeHByZXNzaW9uXCIsXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiQ2xhc3NcIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJDbGFzc0JvZHlcIilcbiAgICB9LFxuICAgIHN1cGVyQ2xhc3M6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgc3VwZXJUeXBlUGFyYW1ldGVyczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGltcGxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGRlY29yYXRvcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBtaXhpbnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkludGVyZmFjZUV4dGVuZHNcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjbGFyZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgYWJzdHJhY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH0sXG4gIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBpZGVudGlmaWVyID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgIGlmICghKDAsIF9pcy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCBwYXJlbnQpKSB7XG4gICAgICAgIGlkZW50aWZpZXIobm9kZSwgXCJpZFwiLCBub2RlLmlkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KClcbn0pO1xuY29uc3QgaW1wb3J0QXR0cmlidXRlcyA9IGV4cG9ydHMuaW1wb3J0QXR0cmlidXRlcyA9IHtcbiAgYXR0cmlidXRlczoge1xuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkltcG9ydEF0dHJpYnV0ZVwiKVxuICB9LFxuICBhc3NlcnRpb25zOiB7XG4gICAgZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbXBvcnRBdHRyaWJ1dGVcIilcbiAgfVxufTtcbmRlZmluZVR5cGUoXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcInNvdXJjZVwiXSxcbiAgdmlzaXRvcjogW1wic291cmNlXCIsIFwiYXR0cmlidXRlc1wiLCBcImFzc2VydGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH0sXG4gICAgZXhwb3J0S2luZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ2YWx1ZVwiKSlcbiAgfSwgaW1wb3J0QXR0cmlidXRlcylcbn0pO1xuZGVmaW5lVHlwZShcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY2xhcmF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiLCBcIkltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb25cIiwgXCJFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVjbGFyYXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRGVjbGFyZUZ1bmN0aW9uXCIsIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiLCBcIkNsYXNzRGVjbGFyYXRpb25cIiwgXCJFeHByZXNzaW9uXCIpLFxuICAgIGV4cG9ydEtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ2YWx1ZVwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImRlY2xhcmF0aW9uXCIsIFwic3BlY2lmaWVyc1wiLCBcInNvdXJjZVwiXSxcbiAgdmlzaXRvcjogcHJvY2Vzcy5lbnYgPyBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCJdIDogW1wiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCIsIFwiYXR0cmlidXRlc1wiLCBcImFzc2VydGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiLCBcIkV4cG9ydERlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIGRlY2xhcmF0aW9uOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJEZWNsYXJhdGlvblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLnNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9ubHkgZGVjbGFyYXRpb24gb3Igc3BlY2lmaWVycyBpcyBhbGxvd2VkIG9uIEV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCAmJiBub2RlLnNvdXJjZSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgZXhwb3J0IGEgZGVjbGFyYXRpb24gZnJvbSBhIHNvdXJjZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRGVjbGFyYXRpb25cIl1cbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRGVjbGFyYXRpb25cIilcbiAgICB9XG4gIH0sIGltcG9ydEF0dHJpYnV0ZXMsIHtcbiAgICBzcGVjaWZpZXJzOiB7XG4gICAgICBkZWZhdWx0OiBbXSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2YpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgc291cmNlZCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwb3J0U3BlY2lmaWVyXCIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKTtcbiAgICAgICAgY29uc3Qgc291cmNlbGVzcyA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwb3J0U3BlY2lmaWVyXCIpO1xuICAgICAgICBpZiAoIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcpIHJldHVybiBzb3VyY2VkO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBub2RlLnNvdXJjZSA/IHNvdXJjZWQgOiBzb3VyY2VsZXNzO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRXhwb3J0U3BlY2lmaWVyXCIsIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiXVxuICAgICAgICB9KTtcbiAgICAgIH0oKSlcbiAgICB9LFxuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBleHBvcnRLaW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInZhbHVlXCIpKVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiRXhwb3J0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wibG9jYWxcIiwgXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgZXhwb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfSxcbiAgICBleHBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRm9yT2ZTdGF0ZW1lbnRcIiwge1xuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCJdLFxuICBidWlsZGVyOiBbXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCIsIFwiYXdhaXRcIl0sXG4gIGFsaWFzZXM6IFtcIlNjb3BhYmxlXCIsIFwiU3RhdGVtZW50XCIsIFwiRm9yXCIsIFwiQmxvY2tQYXJlbnRcIiwgXCJMb29wXCIsIFwiRm9yWFN0YXRlbWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGVmdDoge1xuICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HKSB7XG4gICAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiLCBcIkxWYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjbGFyYXRpb24gPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGx2YWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJNZW1iZXJFeHByZXNzaW9uXCIsIFwiQXJyYXlQYXR0ZXJuXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIlRTQXNFeHByZXNzaW9uXCIsIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIsIFwiVFNUeXBlQXNzZXJ0aW9uXCIsIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgaWYgKCgwLCBfaXMuZGVmYXVsdCkoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIsIHZhbCkpIHtcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbHZhbChub2RlLCBrZXksIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiwgXCJJZGVudGlmaWVyXCIsIFwiTWVtYmVyRXhwcmVzc2lvblwiLCBcIkFycmF5UGF0dGVyblwiLCBcIk9iamVjdFBhdHRlcm5cIiwgXCJUU0FzRXhwcmVzc2lvblwiLCBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBcIlRTVHlwZUFzc2VydGlvblwiLCBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIl1cbiAgICAgICAgfSk7XG4gICAgICB9KClcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgICB9LFxuICAgIGF3YWl0OiB7XG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSW1wb3J0RGVjbGFyYXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCJdLFxuICB2aXNpdG9yOiBbXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCIsIFwiYXR0cmlidXRlc1wiLCBcImFzc2VydGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCIsIFwiSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBpbXBvcnRBdHRyaWJ1dGVzLCB7XG4gICAgbW9kdWxlOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpXG4gICAgfSxcbiAgICBwaGFzZToge1xuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInNvdXJjZVwiLCBcImRlZmVyXCIpXG4gICAgfSxcbiAgICBzcGVjaWZpZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSW1wb3J0U3BlY2lmaWVyXCIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSxcbiAgICBzb3VyY2U6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgICB9LFxuICAgIGltcG9ydEtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcInR5cGVcIiwgXCJ0eXBlb2ZcIiwgXCJ2YWx1ZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImxvY2FsXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGxvY2FsOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJsb2NhbFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSW1wb3J0U3BlY2lmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wiaW1wb3J0ZWRcIiwgXCJsb2NhbFwiXSxcbiAgYnVpbGRlcjogW1wibG9jYWxcIiwgXCJpbXBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsb2NhbDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgaW1wb3J0ZWQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidHlwZW9mXCIsIFwidmFsdWVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSW1wb3J0RXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNvdXJjZVwiLCBcIm9wdGlvbnNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHBoYXNlOiB7XG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwic291cmNlXCIsIFwiZGVmZXJcIilcbiAgICB9LFxuICAgIHNvdXJjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJNZXRhUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJtZXRhXCIsIFwicHJvcGVydHlcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG1ldGE6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpLCBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICBsZXQgcHJvcGVydHk7XG4gICAgICAgIHN3aXRjaCAodmFsLm5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHByb3BlcnR5ID0gXCJzZW50XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibmV3XCI6XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IFwidGFyZ2V0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaW1wb3J0XCI6XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IFwibWV0YVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzLmRlZmF1bHQpKFwiSWRlbnRpZmllclwiLCBub2RlLnByb3BlcnR5LCB7XG4gICAgICAgICAgbmFtZTogcHJvcGVydHlcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5yZWNvZ25pc2VkIE1ldGFQcm9wZXJ0eVwiKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiSWRlbnRpZmllclwiXVxuICAgICAgfSkpIDogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBwcm9wZXJ0eToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5jb25zdCBjbGFzc01ldGhvZE9yUHJvcGVydHlDb21tb24gPSAoKSA9PiAoe1xuICBhYnN0cmFjdDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGFjY2Vzc2liaWxpdHk6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIHN0YXRpYzoge1xuICAgIGRlZmF1bHQ6IGZhbHNlXG4gIH0sXG4gIG92ZXJyaWRlOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBkZWZhdWx0OiBmYWxzZVxuICB9LFxuICBvcHRpb25hbDoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0sXG4gIGtleToge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKShmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICAgICAgY29uc3QgY29tcHV0ZWQgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIik7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgdmFsaWRhdG9yKG5vZGUsIGtleSwgdmFsKTtcbiAgICAgIH07XG4gICAgfSgpLCAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIsIFwiRXhwcmVzc2lvblwiKSlcbiAgfVxufSk7XG5leHBvcnRzLmNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbiA9IGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbjtcbmNvbnN0IGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uID0gKCkgPT4gT2JqZWN0LmFzc2lnbih7fSwgZnVuY3Rpb25Db21tb24oKSwgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uKCksIHtcbiAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlBhdHRlcm5cIiwgXCJSZXN0RWxlbWVudFwiLCBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIiksXG4gIGtpbmQ6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiwgXCJjb25zdHJ1Y3RvclwiKSxcbiAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gIH0sXG4gIGFjY2Vzczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIiksICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiKSksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgZGVjb3JhdG9yczoge1xuICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkRlY29yYXRvclwiKSxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9XG59KTtcbmV4cG9ydHMuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24gPSBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbjtcbmRlZmluZVR5cGUoXCJDbGFzc01ldGhvZFwiLCB7XG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCJdLFxuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCIsIFwiZ2VuZXJhdG9yXCIsIFwiYXN5bmNcIl0sXG4gIHZpc2l0b3I6IFtcImRlY29yYXRvcnNcIiwgXCJrZXlcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGNsYXNzTWV0aG9kT3JEZWNsYXJlTWV0aG9kQ29tbW9uKCksIGZ1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24oKSwge1xuICAgIGJvZHk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiT2JqZWN0UGF0dGVyblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIl0sXG4gIGJ1aWxkZXI6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIlBhdHRlcm5cIiwgXCJQYXR0ZXJuTGlrZVwiLCBcIkxWYWxcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgcGF0dGVybkxpa2VDb21tb24oKSwge1xuICAgIHByb3BlcnRpZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJSZXN0RWxlbWVudFwiLCBcIk9iamVjdFByb3BlcnR5XCIpXG4gIH0pXG59KTtcbmRlZmluZVR5cGUoXCJTcHJlYWRFbGVtZW50XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVuYXJ5TGlrZVwiXSxcbiAgZGVwcmVjYXRlZEFsaWFzOiBcIlNwcmVhZFByb3BlcnR5XCIsXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdXBlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInRhZ1wiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicXVhc2lcIl0sXG4gIGJ1aWxkZXI6IFtcInRhZ1wiLCBcInF1YXNpXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0YWc6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHF1YXNpOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUZW1wbGF0ZUxpdGVyYWxcIilcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiLCBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVGVtcGxhdGVFbGVtZW50XCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIiwgXCJ0YWlsXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuY2hhaW4pKCgwLCBfdXRpbHMuYXNzZXJ0U2hhcGUpKHtcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgICAgICB9LFxuICAgICAgICBjb29rZWQ6IHtcbiAgICAgICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pLCBmdW5jdGlvbiB0ZW1wbGF0ZUVsZW1lbnRDb29rZWRWYWxpZGF0b3Iobm9kZSkge1xuICAgICAgICBjb25zdCByYXcgPSBub2RlLnZhbHVlLnJhdztcbiAgICAgICAgbGV0IHVudGVybWluYXRlZENhbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBAYmFiZWwvdHlwZXMgZXJyb3IuXCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RyLFxuICAgICAgICAgIGZpcnN0SW52YWxpZExvY1xuICAgICAgICB9ID0gKDAsIF9oZWxwZXJTdHJpbmdQYXJzZXIucmVhZFN0cmluZ0NvbnRlbnRzKShcInRlbXBsYXRlXCIsIHJhdywgMCwgMCwgMCwge1xuICAgICAgICAgIHVudGVybWluYXRlZCgpIHtcbiAgICAgICAgICAgIHVudGVybWluYXRlZENhbGxlZCA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiBlcnJvcixcbiAgICAgICAgICBpbnZhbGlkRXNjYXBlU2VxdWVuY2U6IGVycm9yLFxuICAgICAgICAgIG51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiBlcnJvcixcbiAgICAgICAgICB1bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcjogZXJyb3IsXG4gICAgICAgICAgaW52YWxpZERpZ2l0OiBlcnJvcixcbiAgICAgICAgICBpbnZhbGlkQ29kZVBvaW50OiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF1bnRlcm1pbmF0ZWRDYWxsZWQpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcmF3XCIpO1xuICAgICAgICBub2RlLnZhbHVlLmNvb2tlZCA9IGZpcnN0SW52YWxpZExvYyA/IG51bGwgOiBzdHI7XG4gICAgICB9KVxuICAgIH0sXG4gICAgdGFpbDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRlbXBsYXRlTGl0ZXJhbFwiLCB7XG4gIHZpc2l0b3I6IFtcInF1YXNpc1wiLCBcImV4cHJlc3Npb25zXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTGl0ZXJhbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgcXVhc2lzOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVGVtcGxhdGVFbGVtZW50XCIpLFxuICAgIGV4cHJlc3Npb25zOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYXJyYXlcIiksICgwLCBfdXRpbHMuYXNzZXJ0RWFjaCkoKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiVFNUeXBlXCIpKSwgZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgIGlmIChub2RlLnF1YXNpcy5sZW5ndGggIT09IHZhbC5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTnVtYmVyIG9mICR7bm9kZS50eXBlfSBxdWFzaXMgc2hvdWxkIGJlIGV4YWN0bHkgb25lIG1vcmUgdGhhbiB0aGUgbnVtYmVyIG9mIGV4cHJlc3Npb25zLlxcbkV4cGVjdGVkICR7dmFsLmxlbmd0aCArIDF9IHF1YXNpcyBidXQgZ290ICR7bm9kZS5xdWFzaXMubGVuZ3RofWApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiWWllbGRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIiwgXCJkZWxlZ2F0ZVwiXSxcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJUZXJtaW5hdG9ybGVzc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZGVsZWdhdGU6IHtcbiAgICAgIHZhbGlkYXRlOiBwcm9jZXNzLmVudi5CQUJFTF9UWVBFU184X0JSRUFLSU5HID8gKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgT2JqZWN0LmFzc2lnbihmdW5jdGlvbiAobm9kZSwga2V5LCB2YWwpIHtcbiAgICAgICAgaWYgKHZhbCAmJiAhbm9kZS5hcmd1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcm9wZXJ0eSBkZWxlZ2F0ZSBvZiBZaWVsZEV4cHJlc3Npb24gY2Fubm90IGJlIHRydWUgaWYgdGhlcmUgaXMgbm8gYXJndW1lbnRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCJcbiAgICAgIH0pKSA6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiQXdhaXRFeHByZXNzaW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiYXJndW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImFyZ3VtZW50XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiVGVybWluYXRvcmxlc3NcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbXBvcnRcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJCaWdJbnRMaXRlcmFsXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9LFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiUHVyZWlzaFwiLCBcIkxpdGVyYWxcIiwgXCJJbW11dGFibGVcIl1cbn0pO1xuZGVmaW5lVHlwZShcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cG9ydGVkXCJdLFxuICBhbGlhc2VzOiBbXCJNb2R1bGVTcGVjaWZpZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cG9ydGVkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiwge1xuICBidWlsZGVyOiBbXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIFwib3B0aW9uYWxcIl0sXG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcInByb3BlcnR5XCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSBPYmplY3QuYXNzaWduKGZ1bmN0aW9uIChub2RlLCBrZXksIHZhbCkge1xuICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IG5vZGUuY29tcHV0ZWQgPyBjb21wdXRlZCA6IG5vcm1hbDtcbiAgICAgICAgICB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb25lT2ZOb2RlVHlwZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJJZGVudGlmaWVyXCJdXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsaWRhdG9yO1xuICAgICAgfSgpXG4gICAgfSxcbiAgICBjb21wdXRlZDoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9wdGlvbmFsOiB7XG4gICAgICB2YWxpZGF0ZTogIXByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpIDogKDAsIF91dGlscy5jaGFpbikoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSwgKDAsIF91dGlscy5hc3NlcnRPcHRpb25hbENoYWluU3RhcnQpKCkpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJ0eXBlQXJndW1lbnRzXCJdLFxuICBidWlsZGVyOiBbXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJvcHRpb25hbFwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBhcmd1bWVudHM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFeHByZXNzaW9uXCIsIFwiU3ByZWFkRWxlbWVudFwiLCBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIiksXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHZhbGlkYXRlOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikgOiAoMCwgX3V0aWxzLmNoYWluKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLCAoMCwgX3V0aWxzLmFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCkoKSlcbiAgICB9LFxuICAgIHR5cGVBcmd1bWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHR5cGVQYXJhbWV0ZXJzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJkZWNvcmF0b3JzXCIsIFwia2V5XCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJ2YWx1ZVwiXSxcbiAgYnVpbGRlcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImRlY29yYXRvcnNcIiwgXCJjb21wdXRlZFwiLCBcInN0YXRpY1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgY2xhc3NNZXRob2RPclByb3BlcnR5Q29tbW9uKCksIHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWZpbml0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZUFubm90YXRpb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB2YXJpYW5jZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFuY2VcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiLCB7XG4gIHZpc2l0b3I6IFtcImRlY29yYXRvcnNcIiwgXCJrZXlcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcInZhbHVlXCJdLFxuICBidWlsZGVyOiBbXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwiZGVjb3JhdG9yc1wiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCJdLFxuICBhbGlhc2VzOiBbXCJQcm9wZXJ0eVwiLCBcIkFjY2Vzc29yXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe30sIGNsYXNzTWV0aG9kT3JQcm9wZXJ0eUNvbW1vbigpLCB7XG4gICAga2V5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5jaGFpbikoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBub3JtYWwgPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIsIFwiUHJpdmF0ZU5hbWVcIik7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgICAgICAgY29uc3QgdmFsaWRhdG9yID0gbm9kZS5jb21wdXRlZCA/IGNvbXB1dGVkIDogbm9ybWFsO1xuICAgICAgICAgIHZhbGlkYXRvcihub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIH07XG4gICAgICB9KCksICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJOdW1lcmljTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIsIFwiUHJpdmF0ZU5hbWVcIikpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWZpbml0ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgdHlwZUFubm90YXRpb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIsIFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVjb3JhdG9yczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRGVjb3JhdG9yXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHJlYWRvbmx5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNsYXJlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB2YXJpYW5jZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVmFyaWFuY2VcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwidmFsdWVcIl0sXG4gIGJ1aWxkZXI6IFtcImtleVwiLCBcInZhbHVlXCIsIFwiZGVjb3JhdG9yc1wiLCBcInN0YXRpY1wiXSxcbiAgYWxpYXNlczogW1wiUHJvcGVydHlcIiwgXCJQcml2YXRlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICB0eXBlQW5ub3RhdGlvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIiwgXCJUU1R5cGVBbm5vdGF0aW9uXCIsIFwiTm9vcFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgc3RhdGljOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICByZWFkb25seToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVmaW5pdGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIHZhcmlhbmNlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJWYXJpYW5jZVwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiwge1xuICBidWlsZGVyOiBbXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcInN0YXRpY1wiXSxcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiLCBcImJvZHlcIl0sXG4gIGFsaWFzZXM6IFtcIkZ1bmN0aW9uXCIsIFwiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCIsIFwiTWV0aG9kXCIsIFwiUHJpdmF0ZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBjbGFzc01ldGhvZE9yRGVjbGFyZU1ldGhvZENvbW1vbigpLCBmdW5jdGlvblR5cGVBbm5vdGF0aW9uQ29tbW9uKCksIHtcbiAgICBraW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnZXRcIiwgXCJzZXRcIiwgXCJtZXRob2RcIiksXG4gICAgICBkZWZhdWx0OiBcIm1ldGhvZFwiXG4gICAgfSxcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlByaXZhdGVOYW1lXCIpXG4gICAgfSxcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlByaXZhdGVOYW1lXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIlByaXZhdGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdGF0aWNCbG9ja1wiLCB7XG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgfSxcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1BhcmVudFwiLCBcIkZ1bmN0aW9uUGFyZW50XCJdXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29yZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5158\n')},85689:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.DEPRECATED_ALIASES = void 0;\nconst DEPRECATED_ALIASES = exports.DEPRECATED_ALIASES = {\n  ModuleDeclaration: "ImportOrExportDeclaration"\n};\n\n//# sourceMappingURL=deprecated-aliases.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODU2ODkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMEJBQTBCO0FBQzFCLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9kZXByZWNhdGVkLWFsaWFzZXMuanM/ZDA3NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuREVQUkVDQVRFRF9BTElBU0VTID0gdm9pZCAwO1xuY29uc3QgREVQUkVDQVRFRF9BTElBU0VTID0gZXhwb3J0cy5ERVBSRUNBVEVEX0FMSUFTRVMgPSB7XG4gIE1vZHVsZURlY2xhcmF0aW9uOiBcIkltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb25cIlxufTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwcmVjYXRlZC1hbGlhc2VzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///85689\n')},27095:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = __webpack_require__(77596);\n(0, _utils.default)("ArgumentPlaceholder", {});\n(0, _utils.default)("BindExpression", {\n  visitor: ["object", "callee"],\n  aliases: ["Expression"],\n  fields: !process.env.BABEL_TYPES_8_BREAKING ? {\n    object: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: ["Expression"]\n      })\n    },\n    callee: {\n      validate: Object.assign(() => {}, {\n        oneOfNodeTypes: ["Expression"]\n      })\n    }\n  } : {\n    object: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    },\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("ImportAttribute", {\n  visitor: ["key", "value"],\n  fields: {\n    key: {\n      validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")\n    },\n    value: {\n      validate: (0, _utils.assertNodeType)("StringLiteral")\n    }\n  }\n});\n(0, _utils.default)("Decorator", {\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\n(0, _utils.default)("DoExpression", {\n  visitor: ["body"],\n  builder: ["body", "async"],\n  aliases: ["Expression"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)("BlockStatement")\n    },\n    async: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      default: false\n    }\n  }\n});\n(0, _utils.default)("ExportDefaultSpecifier", {\n  visitor: ["exported"],\n  aliases: ["ModuleSpecifier"],\n  fields: {\n    exported: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    }\n  }\n});\n(0, _utils.default)("RecordExpression", {\n  visitor: ["properties"],\n  aliases: ["Expression"],\n  fields: {\n    properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")\n  }\n});\n(0, _utils.default)("TupleExpression", {\n  fields: {\n    elements: {\n      validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),\n      default: []\n    }\n  },\n  visitor: ["elements"],\n  aliases: ["Expression"]\n});\n{\n  (0, _utils.default)("DecimalLiteral", {\n    builder: ["value"],\n    fields: {\n      value: {\n        validate: (0, _utils.assertValueType)("string")\n      }\n    },\n    aliases: ["Expression", "Pureish", "Literal", "Immutable"]\n  });\n}\n(0, _utils.default)("ModuleExpression", {\n  visitor: ["body"],\n  fields: {\n    body: {\n      validate: (0, _utils.assertNodeType)("Program")\n    }\n  },\n  aliases: ["Expression"]\n});\n(0, _utils.default)("TopicReference", {\n  aliases: ["Expression"]\n});\n(0, _utils.default)("PipelineTopicExpression", {\n  builder: ["expression"],\n  visitor: ["expression"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Expression"]\n});\n(0, _utils.default)("PipelineBareFunction", {\n  builder: ["callee"],\n  visitor: ["callee"],\n  fields: {\n    callee: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  },\n  aliases: ["Expression"]\n});\n(0, _utils.default)("PipelinePrimaryTopicReference", {\n  aliases: ["Expression"]\n});\n\n//# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcwOTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvZXhwZXJpbWVudGFsLmpzPzNjNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJBcmd1bWVudFBsYWNlaG9sZGVyXCIsIHt9KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJCaW5kRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFwiLCBcImNhbGxlZVwiXSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiAhcHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORyA/IHtcbiAgICBvYmplY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiBPYmplY3QuYXNzaWduKCgpID0+IHt9LCB7XG4gICAgICAgIG9uZU9mTm9kZVR5cGVzOiBbXCJFeHByZXNzaW9uXCJdXG4gICAgICB9KVxuICAgIH0sXG4gICAgY2FsbGVlOiB7XG4gICAgICB2YWxpZGF0ZTogT2JqZWN0LmFzc2lnbigoKSA9PiB7fSwge1xuICAgICAgICBvbmVPZk5vZGVUeXBlczogW1wiRXhwcmVzc2lvblwiXVxuICAgICAgfSlcbiAgICB9XG4gIH0gOiB7XG4gICAgb2JqZWN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gICAgfSxcbiAgICBjYWxsZWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkltcG9ydEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcImtleVwiLCBcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBrZXk6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpXG4gICAgfSxcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRGVjb3JhdG9yXCIsIHtcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiRG9FeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgYnVpbGRlcjogW1wiYm9keVwiLCBcImFzeW5jXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBib2R5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJCbG9ja1N0YXRlbWVudFwiKVxuICAgIH0sXG4gICAgYXN5bmM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIiwge1xuICB2aXNpdG9yOiBbXCJleHBvcnRlZFwiXSxcbiAgYWxpYXNlczogW1wiTW9kdWxlU3BlY2lmaWVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBvcnRlZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUmVjb3JkRXhwcmVzc2lvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHByb3BlcnRpZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJPYmplY3RQcm9wZXJ0eVwiLCBcIlNwcmVhZEVsZW1lbnRcIilcbiAgfVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVHVwbGVFeHByZXNzaW9uXCIsIHtcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIkV4cHJlc3Npb25cIiwgXCJTcHJlYWRFbGVtZW50XCIpLFxuICAgICAgZGVmYXVsdDogW11cbiAgICB9XG4gIH0sXG4gIHZpc2l0b3I6IFtcImVsZW1lbnRzXCJdLFxuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbntcbiAgKDAsIF91dGlscy5kZWZhdWx0KShcIkRlY2ltYWxMaXRlcmFsXCIsIHtcbiAgICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgICBmaWVsZHM6IHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICAgIH1cbiAgICB9LFxuICAgIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJQdXJlaXNoXCIsIFwiTGl0ZXJhbFwiLCBcIkltbXV0YWJsZVwiXVxuICB9KTtcbn1cbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJNb2R1bGVFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiUHJvZ3JhbVwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiVG9waWNSZWZlcmVuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcbigwLCBfdXRpbHMuZGVmYXVsdCkoXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiLCB7XG4gIGJ1aWxkZXI6IFtcImV4cHJlc3Npb25cIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIl1cbn0pO1xuKDAsIF91dGlscy5kZWZhdWx0KShcIlBpcGVsaW5lQmFyZUZ1bmN0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1wiY2FsbGVlXCJdLFxuICB2aXNpdG9yOiBbXCJjYWxsZWVcIl0sXG4gIGZpZWxkczoge1xuICAgIGNhbGxlZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfSxcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXVxufSk7XG4oMCwgX3V0aWxzLmRlZmF1bHQpKFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCJdXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///27095\n')},99897:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _core = __webpack_require__(5158);\nvar _utils = __webpack_require__(77596);\nconst defineType = (0, _utils.defineAliasedType)("Flow");\nconst defineInterfaceishType = name => {\n  const isDeclareClass = name === "DeclareClass";\n  defineType(name, {\n    builder: ["id", "typeParameters", "extends", "body"],\n    visitor: ["id", "typeParameters", "extends", ...(isDeclareClass ? ["mixins", "implements"] : []), "body"],\n    aliases: ["FlowDeclaration", "Statement", "Declaration"],\n    fields: Object.assign({\n      id: (0, _utils.validateType)("Identifier"),\n      typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n      extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))\n    }, isDeclareClass ? {\n      mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),\n      implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))\n    } : {}, {\n      body: (0, _utils.validateType)("ObjectTypeAnnotation")\n    })\n  });\n};\ndefineType("AnyTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("ArrayTypeAnnotation", {\n  visitor: ["elementType"],\n  aliases: ["FlowType"],\n  fields: {\n    elementType: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("BooleanTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("BooleanLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("NullLiteralTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("ClassImplements", {\n  visitor: ["id", "typeParameters"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\ndefineInterfaceishType("DeclareClass");\ndefineType("DeclareFunction", {\n  visitor: ["id"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")\n  }\n});\ndefineInterfaceishType("DeclareInterface");\ndefineType("DeclareModule", {\n  builder: ["id", "body", "kind"],\n  visitor: ["id", "body"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier", "StringLiteral"),\n    body: (0, _utils.validateType)("BlockStatement"),\n    kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))\n  }\n});\ndefineType("DeclareModuleExports", {\n  visitor: ["typeAnnotation"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")\n  }\n});\ndefineType("DeclareTypeAlias", {\n  visitor: ["id", "typeParameters", "right"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    right: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("DeclareOpaqueType", {\n  visitor: ["id", "typeParameters", "supertype"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    supertype: (0, _utils.validateOptionalType)("FlowType"),\n    impltype: (0, _utils.validateOptionalType)("FlowType")\n  }\n});\ndefineType("DeclareVariable", {\n  visitor: ["id"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\ndefineType("DeclareExportDeclaration", {\n  visitor: ["declaration", "specifiers", "source", "attributes"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: Object.assign({\n    declaration: (0, _utils.validateOptionalType)("Flow"),\n    specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),\n    source: (0, _utils.validateOptionalType)("StringLiteral"),\n    default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }, _core.importAttributes)\n});\ndefineType("DeclareExportAllDeclaration", {\n  visitor: ["source", "attributes"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: Object.assign({\n    source: (0, _utils.validateType)("StringLiteral"),\n    exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))\n  }, _core.importAttributes)\n});\ndefineType("DeclaredPredicate", {\n  visitor: ["value"],\n  aliases: ["FlowPredicate"],\n  fields: {\n    value: (0, _utils.validateType)("Flow")\n  }\n});\ndefineType("ExistsTypeAnnotation", {\n  aliases: ["FlowType"]\n});\ndefineType("FunctionTypeAnnotation", {\n  visitor: ["typeParameters", "params", "rest", "returnType"],\n  aliases: ["FlowType"],\n  fields: {\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),\n    rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),\n    this: (0, _utils.validateOptionalType)("FunctionTypeParam"),\n    returnType: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("FunctionTypeParam", {\n  visitor: ["name", "typeAnnotation"],\n  fields: {\n    name: (0, _utils.validateOptionalType)("Identifier"),\n    typeAnnotation: (0, _utils.validateType)("FlowType"),\n    optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("GenericTypeAnnotation", {\n  visitor: ["id", "typeParameters"],\n  aliases: ["FlowType"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\ndefineType("InferredPredicate", {\n  aliases: ["FlowPredicate"]\n});\ndefineType("InterfaceExtends", {\n  visitor: ["id", "typeParameters"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")\n  }\n});\ndefineInterfaceishType("InterfaceDeclaration");\ndefineType("InterfaceTypeAnnotation", {\n  visitor: ["extends", "body"],\n  aliases: ["FlowType"],\n  fields: {\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),\n    body: (0, _utils.validateType)("ObjectTypeAnnotation")\n  }\n});\ndefineType("IntersectionTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\ndefineType("MixedTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("EmptyTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("NullableTypeAnnotation", {\n  visitor: ["typeAnnotation"],\n  aliases: ["FlowType"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("NumberLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("number"))\n  }\n});\ndefineType("NumberTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("ObjectTypeAnnotation", {\n  visitor: ["properties", "indexers", "callProperties", "internalSlots"],\n  aliases: ["FlowType"],\n  builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],\n  fields: {\n    properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),\n    indexers: {\n      validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),\n      optional: true,\n      default: []\n    },\n    callProperties: {\n      validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),\n      optional: true,\n      default: []\n    },\n    internalSlots: {\n      validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),\n      optional: true,\n      default: []\n    },\n    exact: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      default: false\n    },\n    inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("ObjectTypeInternalSlot", {\n  visitor: ["id", "value"],\n  builder: ["id", "value", "optional", "static", "method"],\n  aliases: ["UserWhitespacable"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    value: (0, _utils.validateType)("FlowType"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("ObjectTypeCallProperty", {\n  visitor: ["value"],\n  aliases: ["UserWhitespacable"],\n  fields: {\n    value: (0, _utils.validateType)("FlowType"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("ObjectTypeIndexer", {\n  visitor: ["variance", "id", "key", "value"],\n  builder: ["id", "key", "value", "variance"],\n  aliases: ["UserWhitespacable"],\n  fields: {\n    id: (0, _utils.validateOptionalType)("Identifier"),\n    key: (0, _utils.validateType)("FlowType"),\n    value: (0, _utils.validateType)("FlowType"),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    variance: (0, _utils.validateOptionalType)("Variance")\n  }\n});\ndefineType("ObjectTypeProperty", {\n  visitor: ["key", "value", "variance"],\n  aliases: ["UserWhitespacable"],\n  fields: {\n    key: (0, _utils.validateType)("Identifier", "StringLiteral"),\n    value: (0, _utils.validateType)("FlowType"),\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),\n    static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    variance: (0, _utils.validateOptionalType)("Variance"),\n    method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("ObjectTypeSpreadProperty", {\n  visitor: ["argument"],\n  aliases: ["UserWhitespacable"],\n  fields: {\n    argument: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("OpaqueType", {\n  visitor: ["id", "typeParameters", "supertype", "impltype"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    supertype: (0, _utils.validateOptionalType)("FlowType"),\n    impltype: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("QualifiedTypeIdentifier", {\n  visitor: ["qualification", "id"],\n  builder: ["id", "qualification"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")\n  }\n});\ndefineType("StringLiteralTypeAnnotation", {\n  builder: ["value"],\n  aliases: ["FlowType"],\n  fields: {\n    value: (0, _utils.validate)((0, _utils.assertValueType)("string"))\n  }\n});\ndefineType("StringTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("SymbolTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("ThisTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("TupleTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\ndefineType("TypeofTypeAnnotation", {\n  visitor: ["argument"],\n  aliases: ["FlowType"],\n  fields: {\n    argument: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("TypeAlias", {\n  visitor: ["id", "typeParameters", "right"],\n  aliases: ["FlowDeclaration", "Statement", "Declaration"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),\n    right: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("TypeAnnotation", {\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("TypeCastExpression", {\n  visitor: ["expression", "typeAnnotation"],\n  aliases: ["ExpressionWrapper", "Expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression"),\n    typeAnnotation: (0, _utils.validateType)("TypeAnnotation")\n  }\n});\ndefineType("TypeParameter", {\n  visitor: ["bound", "default", "variance"],\n  fields: {\n    name: (0, _utils.validate)((0, _utils.assertValueType)("string")),\n    bound: (0, _utils.validateOptionalType)("TypeAnnotation"),\n    default: (0, _utils.validateOptionalType)("FlowType"),\n    variance: (0, _utils.validateOptionalType)("Variance")\n  }\n});\ndefineType("TypeParameterDeclaration", {\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))\n  }\n});\ndefineType("TypeParameterInstantiation", {\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\ndefineType("UnionTypeAnnotation", {\n  visitor: ["types"],\n  aliases: ["FlowType"],\n  fields: {\n    types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))\n  }\n});\ndefineType("Variance", {\n  builder: ["kind"],\n  fields: {\n    kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))\n  }\n});\ndefineType("VoidTypeAnnotation", {\n  aliases: ["FlowType", "FlowBaseAnnotation"]\n});\ndefineType("EnumDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "body"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")\n  }\n});\ndefineType("EnumBooleanBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("EnumNumberBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)("EnumNumberMember"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("EnumStringBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),\n    members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("EnumSymbolBody", {\n  aliases: ["EnumBody"],\n  visitor: ["members"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),\n    hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\ndefineType("EnumBooleanMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("BooleanLiteral")\n  }\n});\ndefineType("EnumNumberMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id", "init"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("NumericLiteral")\n  }\n});\ndefineType("EnumStringMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id", "init"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier"),\n    init: (0, _utils.validateType)("StringLiteral")\n  }\n});\ndefineType("EnumDefaultedMember", {\n  aliases: ["EnumMember"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\ndefineType("IndexedAccessType", {\n  visitor: ["objectType", "indexType"],\n  aliases: ["FlowType"],\n  fields: {\n    objectType: (0, _utils.validateType)("FlowType"),\n    indexType: (0, _utils.validateType)("FlowType")\n  }\n});\ndefineType("OptionalIndexedAccessType", {\n  visitor: ["objectType", "indexType"],\n  aliases: ["FlowType"],\n  fields: {\n    objectType: (0, _utils.validateType)("FlowType"),\n    indexType: (0, _utils.validateType)("FlowType"),\n    optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))\n  }\n});\n\n//# sourceMappingURL=flow.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTk4OTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLElBQVc7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvZmxvdy5qcz8xYjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2NvcmUgPSByZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgZGVmaW5lVHlwZSA9ICgwLCBfdXRpbHMuZGVmaW5lQWxpYXNlZFR5cGUpKFwiRmxvd1wiKTtcbmNvbnN0IGRlZmluZUludGVyZmFjZWlzaFR5cGUgPSBuYW1lID0+IHtcbiAgY29uc3QgaXNEZWNsYXJlQ2xhc3MgPSBuYW1lID09PSBcIkRlY2xhcmVDbGFzc1wiO1xuICBkZWZpbmVUeXBlKG5hbWUsIHtcbiAgICBidWlsZGVyOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gICAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImV4dGVuZHNcIiwgLi4uKGlzRGVjbGFyZUNsYXNzID8gW1wibWl4aW5zXCIsIFwiaW1wbGVtZW50c1wiXSA6IFtdKSwgXCJib2R5XCJdLFxuICAgIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICAgIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKVxuICAgIH0sIGlzRGVjbGFyZUNsYXNzID8ge1xuICAgICAgbWl4aW5zOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSksXG4gICAgICBpbXBsZW1lbnRzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiQ2xhc3NJbXBsZW1lbnRzXCIpKVxuICAgIH0gOiB7fSwge1xuICAgICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIilcbiAgICB9KVxuICB9KTtcbn07XG5kZWZpbmVUeXBlKFwiQW55VHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImVsZW1lbnRUeXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJDbGFzc0ltcGxlbWVudHNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZUludGVyZmFjZWlzaFR5cGUoXCJEZWNsYXJlQ2xhc3NcIik7XG5kZWZpbmVUeXBlKFwiRGVjbGFyZUZ1bmN0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBwcmVkaWNhdGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRGVjbGFyZWRQcmVkaWNhdGVcIilcbiAgfVxufSk7XG5kZWZpbmVJbnRlcmZhY2Vpc2hUeXBlKFwiRGVjbGFyZUludGVyZmFjZVwiKTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlTW9kdWxlXCIsIHtcbiAgYnVpbGRlcjogW1wiaWRcIiwgXCJib2R5XCIsIFwia2luZFwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJsb2NrU3RhdGVtZW50XCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJDb21tb25KU1wiLCBcIkVTXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVUeXBlQWxpYXNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVPcGFxdWVUeXBlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInN1cGVydHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW1wbHR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRGVjbGFyZVZhcmlhYmxlXCIsIHtcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJhdHRyaWJ1dGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93RGVjbGFyYXRpb25cIiwgXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBkZWNsYXJhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGbG93XCIpLFxuICAgIHNwZWNpZmllcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJFeHBvcnRTcGVjaWZpZXJcIiwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpLFxuICAgIHNvdXJjZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGRlZmF1bHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfSwgX2NvcmUuaW1wb3J0QXR0cmlidXRlcylcbn0pO1xuZGVmaW5lVHlwZShcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInNvdXJjZVwiLCBcImF0dHJpYnV0ZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IE9iamVjdC5hc3NpZ24oe1xuICAgIHNvdXJjZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBleHBvcnRLaW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwidHlwZVwiLCBcInZhbHVlXCIpKVxuICB9LCBfY29yZS5pbXBvcnRBdHRyaWJ1dGVzKVxufSk7XG5kZWZpbmVUeXBlKFwiRGVjbGFyZWRQcmVkaWNhdGVcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1ByZWRpY2F0ZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRXhpc3RzVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmVzdFwiLCBcInJldHVyblR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiRnVuY3Rpb25UeXBlUGFyYW1cIiksXG4gICAgcmVzdDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJGdW5jdGlvblR5cGVQYXJhbVwiKSxcbiAgICB0aGlzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpLFxuICAgIHJldHVyblR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkZ1bmN0aW9uVHlwZVBhcmFtXCIsIHtcbiAgdmlzaXRvcjogW1wibmFtZVwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIG9wdGlvbmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkluZmVycmVkUHJlZGljYXRlXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1ByZWRpY2F0ZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiSW50ZXJmYWNlRXh0ZW5kc1wiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG5kZWZpbmVJbnRlcmZhY2Vpc2hUeXBlKFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG5kZWZpbmVUeXBlKFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHRlbmRzXCIsIFwiYm9keVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4dGVuZHM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJJbnRlcmZhY2VFeHRlbmRzXCIpKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk1peGVkVHlwZUFubm90YXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiLCBcIkZsb3dCYXNlQW5ub3RhdGlvblwiXVxufSk7XG5kZWZpbmVUeXBlKFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYnVpbGRlcjogW1widmFsdWVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwibnVtYmVyXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIsIFwiaW50ZXJuYWxTbG90c1wiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGJ1aWxkZXI6IFtcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIsIFwiaW50ZXJuYWxTbG90c1wiLCBcImV4YWN0XCJdLFxuICBmaWVsZHM6IHtcbiAgICBwcm9wZXJ0aWVzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVQcm9wZXJ0eVwiLCBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiKSksXG4gICAgaW5kZXhlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVJbmRleGVyXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgY2FsbFByb3BlcnRpZXM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIGRlZmF1bHQ6IFtdXG4gICAgfSxcbiAgICBpbnRlcm5hbFNsb3RzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBkZWZhdWx0OiBbXVxuICAgIH0sXG4gICAgZXhhY3Q6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGluZXhhY3Q6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidmFsdWVcIl0sXG4gIGJ1aWxkZXI6IFtcImlkXCIsIFwidmFsdWVcIiwgXCJvcHRpb25hbFwiLCBcInN0YXRpY1wiLCBcIm1ldGhvZFwiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBtZXRob2Q6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIiwge1xuICB2aXNpdG9yOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBzdGF0aWM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9iamVjdFR5cGVJbmRleGVyXCIsIHtcbiAgdmlzaXRvcjogW1widmFyaWFuY2VcIiwgXCJpZFwiLCBcImtleVwiLCBcInZhbHVlXCJdLFxuICBidWlsZGVyOiBbXCJpZFwiLCBcImtleVwiLCBcInZhbHVlXCIsIFwidmFyaWFuY2VcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIHN0YXRpYzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgdmFyaWFuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVmFyaWFuY2VcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidmFsdWVcIiwgXCJ2YXJpYW5jZVwiXSxcbiAgYWxpYXNlczogW1wiVXNlcldoaXRlc3BhY2FibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGtleTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiksXG4gICAgdmFsdWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpLFxuICAgIGtpbmQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiaW5pdFwiLCBcImdldFwiLCBcInNldFwiKSksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKSxcbiAgICBwcm90bzogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIHZhcmlhbmNlOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlZhcmlhbmNlXCIpLFxuICAgIG1ldGhvZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIsIHtcbiAgdmlzaXRvcjogW1wiYXJndW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIlVzZXJXaGl0ZXNwYWNhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiT3BhcXVlVHlwZVwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJzdXBlcnR5cGVcIiwgXCJpbXBsdHlwZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd0RlY2xhcmF0aW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSxcbiAgICBzdXBlcnR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW1wbHR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIsIHtcbiAgdmlzaXRvcjogW1wicXVhbGlmaWNhdGlvblwiLCBcImlkXCJdLFxuICBidWlsZGVyOiBbXCJpZFwiLCBcInF1YWxpZmljYXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHF1YWxpZmljYXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIiwge1xuICBidWlsZGVyOiBbXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIHZhbHVlOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIiwgXCJGbG93QmFzZUFubm90YXRpb25cIl1cbn0pO1xuZGVmaW5lVHlwZShcIlRoaXNUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZXNcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGbG93VHlwZVwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZW9mVHlwZUFubm90YXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgYWxpYXNlczogW1wiRmxvd1R5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGFyZ3VtZW50OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUeXBlQWxpYXNcIiwge1xuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicmlnaHRcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dEZWNsYXJhdGlvblwiLCBcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgcmlnaHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlR5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25XcmFwcGVyXCIsIFwiRXhwcmVzc2lvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZVBhcmFtZXRlclwiLCB7XG4gIHZpc2l0b3I6IFtcImJvdW5kXCIsIFwiZGVmYXVsdFwiLCBcInZhcmlhbmNlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIikpLFxuICAgIGJvdW5kOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlR5cGVBbm5vdGF0aW9uXCIpLFxuICAgIGRlZmF1bHQ6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgdmFyaWFuY2U6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVmFyaWFuY2VcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1wicGFyYW1zXCJdLFxuICBmaWVsZHM6IHtcbiAgICBwYXJhbXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiVHlwZVBhcmFtZXRlclwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJGbG93VHlwZVwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgdHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXJyYXlPZlR5cGUpKFwiRmxvd1R5cGVcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlZhcmlhbmNlXCIsIHtcbiAgYnVpbGRlcjogW1wia2luZFwiXSxcbiAgZmllbGRzOiB7XG4gICAga2luZDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJtaW51c1wiLCBcInBsdXNcIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlZvaWRUeXBlQW5ub3RhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCIsIFwiRmxvd0Jhc2VBbm5vdGF0aW9uXCJdXG59KTtcbmRlZmluZVR5cGUoXCJFbnVtRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFbnVtQm9vbGVhbkJvZHlcIiwgXCJFbnVtTnVtYmVyQm9keVwiLCBcIkVudW1TdHJpbmdCb2R5XCIsIFwiRW51bVN5bWJvbEJvZHlcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bUJvb2xlYW5Cb2R5XCIsIHtcbiAgYWxpYXNlczogW1wiRW51bUJvZHlcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cGxpY2l0VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSksXG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkVudW1Cb29sZWFuTWVtYmVyXCIpLFxuICAgIGhhc1Vua25vd25NZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJFbnVtTnVtYmVyQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBsaWNpdFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtTnVtYmVyTWVtYmVyXCIpLFxuICAgIGhhc1Vua25vd25NZW1iZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlKSgoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJFbnVtU3RyaW5nQm9keVwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1Cb2R5XCJdLFxuICB2aXNpdG9yOiBbXCJtZW1iZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHBsaWNpdFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpLFxuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJFbnVtU3RyaW5nTWVtYmVyXCIsIFwiRW51bURlZmF1bHRlZE1lbWJlclwiKSxcbiAgICBoYXNVbmtub3duTWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bVN5bWJvbEJvZHlcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtQm9keVwiXSxcbiAgdmlzaXRvcjogW1wibWVtYmVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIiksXG4gICAgaGFzVW5rbm93bk1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGUpKCgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIikpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1Cb29sZWFuTWVtYmVyXCIsIHtcbiAgYWxpYXNlczogW1wiRW51bU1lbWJlclwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkJvb2xlYW5MaXRlcmFsXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1OdW1iZXJNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIk51bWVyaWNMaXRlcmFsXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkVudW1TdHJpbmdNZW1iZXJcIiwge1xuICBhbGlhc2VzOiBbXCJFbnVtTWVtYmVyXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcImluaXRcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIGluaXQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiRW51bURlZmF1bHRlZE1lbWJlclwiLCB7XG4gIGFsaWFzZXM6IFtcIkVudW1NZW1iZXJcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJJbmRleGVkQWNjZXNzVHlwZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm9iamVjdFR5cGVcIiwgXCJpbmRleFR5cGVcIl0sXG4gIGFsaWFzZXM6IFtcIkZsb3dUeXBlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvYmplY3RUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBpbmRleFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkZsb3dUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIiwge1xuICB2aXNpdG9yOiBbXCJvYmplY3RUeXBlXCIsIFwiaW5kZXhUeXBlXCJdLFxuICBhbGlhc2VzOiBbXCJGbG93VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgb2JqZWN0VHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRmxvd1R5cGVcIiksXG4gICAgaW5kZXhUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJGbG93VHlwZVwiKSxcbiAgICBvcHRpb25hbDogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSlcbiAgfVxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZsb3cuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///99897\n')},39793:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nObject.defineProperty(exports, "ALIAS_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, "BUILDER_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.BUILDER_KEYS;\n  }\n}));\nObject.defineProperty(exports, "DEPRECATED_ALIASES", ({\n  enumerable: true,\n  get: function () {\n    return _deprecatedAliases.DEPRECATED_ALIASES;\n  }\n}));\nObject.defineProperty(exports, "DEPRECATED_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.DEPRECATED_KEYS;\n  }\n}));\nObject.defineProperty(exports, "FLIPPED_ALIAS_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.FLIPPED_ALIAS_KEYS;\n  }\n}));\nObject.defineProperty(exports, "NODE_FIELDS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_FIELDS;\n  }\n}));\nObject.defineProperty(exports, "NODE_PARENT_VALIDATIONS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.NODE_PARENT_VALIDATIONS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS_ALIAS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_ALIAS;\n  }\n}));\nObject.defineProperty(exports, "PLACEHOLDERS_FLIPPED_ALIAS", ({\n  enumerable: true,\n  get: function () {\n    return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;\n  }\n}));\nexports.TYPES = void 0;\nObject.defineProperty(exports, "VISITOR_KEYS", ({\n  enumerable: true,\n  get: function () {\n    return _utils.VISITOR_KEYS;\n  }\n}));\n__webpack_require__(5158);\n__webpack_require__(99897);\n__webpack_require__(46184);\n__webpack_require__(45589);\n__webpack_require__(27095);\n__webpack_require__(46106);\nvar _utils = __webpack_require__(77596);\nvar _placeholders = __webpack_require__(59187);\nvar _deprecatedAliases = __webpack_require__(85689);\nObject.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach(deprecatedAlias => {\n  _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];\n});\nconst TYPES = exports.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk3OTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOENBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsbURBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsK0NBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsMkRBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsZ0RBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysc0RBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsOERBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDO0FBQ0YsYUFBYTtBQUNiLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1CQUFPLENBQUMsSUFBVztBQUNuQixtQkFBTyxDQUFDLEtBQVc7QUFDbkIsbUJBQU8sQ0FBQyxLQUFVO0FBQ2xCLG1CQUFPLENBQUMsS0FBVztBQUNuQixtQkFBTyxDQUFDLEtBQW1CO0FBQzNCLG1CQUFPLENBQUMsS0FBaUI7QUFDekIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsS0FBbUI7QUFDL0MseUJBQXlCLG1CQUFPLENBQUMsS0FBeUI7QUFDMUQ7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLGFBQWE7O0FBRTNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL2RlZmluaXRpb25zL2luZGV4LmpzP2YyM2EiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBTElBU19LRVlTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJVSUxERVJfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuQlVJTERFUl9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFUFJFQ0FURURfQUxJQVNFU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGVwcmVjYXRlZEFsaWFzZXMuREVQUkVDQVRFRF9BTElBU0VTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRFUFJFQ0FURURfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuREVQUkVDQVRFRF9LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZMSVBQRURfQUxJQVNfS0VZU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5PREVfRklFTERTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlscy5OT0RFX0ZJRUxEUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOT0RFX1BBUkVOVF9WQUxJREFUSU9OU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUExBQ0VIT0xERVJTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9wbGFjZWhvbGRlcnMuUExBQ0VIT0xERVJTO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBMQUNFSE9MREVSU19BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19BTElBUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQTEFDRUhPTERFUlNfRkxJUFBFRF9BTElBU1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTO1xuICB9XG59KTtcbmV4cG9ydHMuVFlQRVMgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWSVNJVE9SX0tFWVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWxzLlZJU0lUT1JfS0VZUztcbiAgfVxufSk7XG5yZXF1aXJlKFwiLi9jb3JlLmpzXCIpO1xucmVxdWlyZShcIi4vZmxvdy5qc1wiKTtcbnJlcXVpcmUoXCIuL2pzeC5qc1wiKTtcbnJlcXVpcmUoXCIuL21pc2MuanNcIik7XG5yZXF1aXJlKFwiLi9leHBlcmltZW50YWwuanNcIik7XG5yZXF1aXJlKFwiLi90eXBlc2NyaXB0LmpzXCIpO1xudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIF9wbGFjZWhvbGRlcnMgPSByZXF1aXJlKFwiLi9wbGFjZWhvbGRlcnMuanNcIik7XG52YXIgX2RlcHJlY2F0ZWRBbGlhc2VzID0gcmVxdWlyZShcIi4vZGVwcmVjYXRlZC1hbGlhc2VzLmpzXCIpO1xuT2JqZWN0LmtleXMoX2RlcHJlY2F0ZWRBbGlhc2VzLkRFUFJFQ0FURURfQUxJQVNFUykuZm9yRWFjaChkZXByZWNhdGVkQWxpYXMgPT4ge1xuICBfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTW2RlcHJlY2F0ZWRBbGlhc10gPSBfdXRpbHMuRkxJUFBFRF9BTElBU19LRVlTW19kZXByZWNhdGVkQWxpYXNlcy5ERVBSRUNBVEVEX0FMSUFTRVNbZGVwcmVjYXRlZEFsaWFzXV07XG59KTtcbmNvbnN0IFRZUEVTID0gZXhwb3J0cy5UWVBFUyA9IFtdLmNvbmNhdChPYmplY3Qua2V5cyhfdXRpbHMuVklTSVRPUl9LRVlTKSwgT2JqZWN0LmtleXMoX3V0aWxzLkZMSVBQRURfQUxJQVNfS0VZUyksIE9iamVjdC5rZXlzKF91dGlscy5ERVBSRUNBVEVEX0tFWVMpKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39793\n')},46184:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = __webpack_require__(77596);\nconst defineType = (0, _utils.defineAliasedType)("JSX");\ndefineType("JSXAttribute", {\n  visitor: ["name", "value"],\n  aliases: ["Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")\n    },\n    value: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")\n    }\n  }\n});\ndefineType("JSXClosingElement", {\n  visitor: ["name"],\n  aliases: ["Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")\n    }\n  }\n});\ndefineType("JSXElement", {\n  builder: ["openingElement", "closingElement", "children", "selfClosing"],\n  visitor: ["openingElement", "children", "closingElement"],\n  aliases: ["Immutable", "Expression"],\n  fields: Object.assign({\n    openingElement: {\n      validate: (0, _utils.assertNodeType)("JSXOpeningElement")\n    },\n    closingElement: {\n      optional: true,\n      validate: (0, _utils.assertNodeType)("JSXClosingElement")\n    },\n    children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")\n  }, {\n    selfClosing: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    }\n  })\n});\ndefineType("JSXEmptyExpression", {});\ndefineType("JSXExpressionContainer", {\n  visitor: ["expression"],\n  aliases: ["Immutable"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")\n    }\n  }\n});\ndefineType("JSXSpreadChild", {\n  visitor: ["expression"],\n  aliases: ["Immutable"],\n  fields: {\n    expression: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("JSXIdentifier", {\n  builder: ["name"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\ndefineType("JSXMemberExpression", {\n  visitor: ["object", "property"],\n  fields: {\n    object: {\n      validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")\n    },\n    property: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    }\n  }\n});\ndefineType("JSXNamespacedName", {\n  visitor: ["namespace", "name"],\n  fields: {\n    namespace: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    },\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier")\n    }\n  }\n});\ndefineType("JSXOpeningElement", {\n  builder: ["name", "attributes", "selfClosing"],\n  visitor: ["name", "attributes"],\n  aliases: ["Immutable"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")\n    },\n    selfClosing: {\n      default: false\n    },\n    attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),\n    typeParameters: {\n      validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),\n      optional: true\n    }\n  }\n});\ndefineType("JSXSpreadAttribute", {\n  visitor: ["argument"],\n  fields: {\n    argument: {\n      validate: (0, _utils.assertNodeType)("Expression")\n    }\n  }\n});\ndefineType("JSXText", {\n  aliases: ["Immutable"],\n  builder: ["value"],\n  fields: {\n    value: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\ndefineType("JSXFragment", {\n  builder: ["openingFragment", "closingFragment", "children"],\n  visitor: ["openingFragment", "children", "closingFragment"],\n  aliases: ["Immutable", "Expression"],\n  fields: {\n    openingFragment: {\n      validate: (0, _utils.assertNodeType)("JSXOpeningFragment")\n    },\n    closingFragment: {\n      validate: (0, _utils.assertNodeType)("JSXClosingFragment")\n    },\n    children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")\n  }\n});\ndefineType("JSXOpeningFragment", {\n  aliases: ["Immutable"]\n});\ndefineType("JSXClosingFragment", {\n  aliases: ["Immutable"]\n});\n\n//# sourceMappingURL=jsx.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYxODQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy9qc3guanM/NTY0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgZGVmaW5lVHlwZSA9ICgwLCBfdXRpbHMuZGVmaW5lQWxpYXNlZFR5cGUpKFwiSlNYXCIpO1xuZGVmaW5lVHlwZShcIkpTWEF0dHJpYnV0ZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIiwgXCJ2YWx1ZVwiXSxcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIilcbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWEVsZW1lbnRcIiwgXCJKU1hGcmFnbWVudFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hDbG9zaW5nRWxlbWVudFwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVcIl0sXG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiLCBcIkpTWE1lbWJlckV4cHJlc3Npb25cIiwgXCJKU1hOYW1lc3BhY2VkTmFtZVwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYRWxlbWVudFwiLCB7XG4gIGJ1aWxkZXI6IFtcIm9wZW5pbmdFbGVtZW50XCIsIFwiY2xvc2luZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiLCBcInNlbGZDbG9zaW5nXCJdLFxuICB2aXNpdG9yOiBbXCJvcGVuaW5nRWxlbWVudFwiLCBcImNoaWxkcmVuXCIsIFwiY2xvc2luZ0VsZW1lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7XG4gICAgb3BlbmluZ0VsZW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWE9wZW5pbmdFbGVtZW50XCIpXG4gICAgfSxcbiAgICBjbG9zaW5nRWxlbWVudDoge1xuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hDbG9zaW5nRWxlbWVudFwiKVxuICAgIH0sXG4gICAgY2hpbGRyZW46ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJKU1hUZXh0XCIsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBcIkpTWFNwcmVhZENoaWxkXCIsIFwiSlNYRWxlbWVudFwiLCBcIkpTWEZyYWdtZW50XCIpXG4gIH0sIHtcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIkpTWEVtcHR5RXhwcmVzc2lvblwiLCB7fSk7XG5kZWZpbmVUeXBlKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiLCBcIkpTWEVtcHR5RXhwcmVzc2lvblwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYU3ByZWFkQ2hpbGRcIiwge1xuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWElkZW50aWZpZXJcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIsIHtcbiAgdmlzaXRvcjogW1wib2JqZWN0XCIsIFwicHJvcGVydHlcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWElkZW50aWZpZXJcIilcbiAgICB9LFxuICAgIHByb3BlcnR5OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIpXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hOYW1lc3BhY2VkTmFtZVwiLCB7XG4gIHZpc2l0b3I6IFtcIm5hbWVzcGFjZVwiLCBcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWVzcGFjZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH0sXG4gICAgbmFtZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYSWRlbnRpZmllclwiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYT3BlbmluZ0VsZW1lbnRcIiwge1xuICBidWlsZGVyOiBbXCJuYW1lXCIsIFwiYXR0cmlidXRlc1wiLCBcInNlbGZDbG9zaW5nXCJdLFxuICB2aXNpdG9yOiBbXCJuYW1lXCIsIFwiYXR0cmlidXRlc1wiXSxcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdLFxuICBmaWVsZHM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJKU1hJZGVudGlmaWVyXCIsIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiLCBcIkpTWE5hbWVzcGFjZWROYW1lXCIpXG4gICAgfSxcbiAgICBzZWxmQ2xvc2luZzoge1xuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGF0dHJpYnV0ZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJKU1hBdHRyaWJ1dGVcIiwgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIsIFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIiwge1xuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiXSxcbiAgZmllbGRzOiB7XG4gICAgYXJndW1lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWFRleHRcIiwge1xuICBhbGlhc2VzOiBbXCJJbW11dGFibGVcIl0sXG4gIGJ1aWxkZXI6IFtcInZhbHVlXCJdLFxuICBmaWVsZHM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcInN0cmluZ1wiKVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYRnJhZ21lbnRcIiwge1xuICBidWlsZGVyOiBbXCJvcGVuaW5nRnJhZ21lbnRcIiwgXCJjbG9zaW5nRnJhZ21lbnRcIiwgXCJjaGlsZHJlblwiXSxcbiAgdmlzaXRvcjogW1wib3BlbmluZ0ZyYWdtZW50XCIsIFwiY2hpbGRyZW5cIiwgXCJjbG9zaW5nRnJhZ21lbnRcIl0sXG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiLCBcIkV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIG9wZW5pbmdGcmFnbWVudDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpXG4gICAgfSxcbiAgICBjbG9zaW5nRnJhZ21lbnQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIkpTWENsb3NpbmdGcmFnbWVudFwiKVxuICAgIH0sXG4gICAgY2hpbGRyZW46ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJKU1hUZXh0XCIsIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiLCBcIkpTWFNwcmVhZENoaWxkXCIsIFwiSlNYRWxlbWVudFwiLCBcIkpTWEZyYWdtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIkpTWE9wZW5pbmdGcmFnbWVudFwiLCB7XG4gIGFsaWFzZXM6IFtcIkltbXV0YWJsZVwiXVxufSk7XG5kZWZpbmVUeXBlKFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIsIHtcbiAgYWxpYXNlczogW1wiSW1tdXRhYmxlXCJdXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46184\n')},45589:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = __webpack_require__(77596);\nvar _placeholders = __webpack_require__(59187);\nvar _core = __webpack_require__(5158);\nconst defineType = (0, _utils.defineAliasedType)("Miscellaneous");\n{\n  defineType("Noop", {\n    visitor: []\n  });\n}\ndefineType("Placeholder", {\n  visitor: [],\n  builder: ["expectedNode", "name"],\n  fields: Object.assign({\n    name: {\n      validate: (0, _utils.assertNodeType)("Identifier")\n    },\n    expectedNode: {\n      validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)\n    }\n  }, (0, _core.patternLikeCommon)())\n});\ndefineType("V8IntrinsicIdentifier", {\n  builder: ["name"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    }\n  }\n});\n\n//# sourceMappingURL=misc.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU1ODkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsS0FBbUI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLElBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvbWlzYy5qcz8zMTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgX3BsYWNlaG9sZGVycyA9IHJlcXVpcmUoXCIuL3BsYWNlaG9sZGVycy5qc1wiKTtcbnZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmUuanNcIik7XG5jb25zdCBkZWZpbmVUeXBlID0gKDAsIF91dGlscy5kZWZpbmVBbGlhc2VkVHlwZSkoXCJNaXNjZWxsYW5lb3VzXCIpO1xue1xuICBkZWZpbmVUeXBlKFwiTm9vcFwiLCB7XG4gICAgdmlzaXRvcjogW11cbiAgfSk7XG59XG5kZWZpbmVUeXBlKFwiUGxhY2Vob2xkZXJcIiwge1xuICB2aXNpdG9yOiBbXSxcbiAgYnVpbGRlcjogW1wiZXhwZWN0ZWROb2RlXCIsIFwibmFtZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHtcbiAgICBuYW1lOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIpXG4gICAgfSxcbiAgICBleHBlY3RlZE5vZGU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSguLi5fcGxhY2Vob2xkZXJzLlBMQUNFSE9MREVSUylcbiAgICB9XG4gIH0sICgwLCBfY29yZS5wYXR0ZXJuTGlrZUNvbW1vbikoKSlcbn0pO1xuZGVmaW5lVHlwZShcIlY4SW50cmluc2ljSWRlbnRpZmllclwiLCB7XG4gIGJ1aWxkZXI6IFtcIm5hbWVcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///45589\n')},59187:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS = void 0;\nvar _utils = __webpack_require__(77596);\nconst PLACEHOLDERS = exports.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];\nconst PLACEHOLDERS_ALIAS = exports.PLACEHOLDERS_ALIAS = {\n  Declaration: ["Statement"],\n  Pattern: ["PatternLike", "LVal"]\n};\nfor (const type of PLACEHOLDERS) {\n  const alias = _utils.ALIAS_KEYS[type];\n  if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\nconst PLACEHOLDERS_FLIPPED_ALIAS = exports.PLACEHOLDERS_FLIPPED_ALIAS = {};\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n\n//# sourceMappingURL=placeholders.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkxODcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0NBQWtDLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CO0FBQ3RGLGFBQWEsbUJBQU8sQ0FBQyxLQUFZO0FBQ2pDLHFCQUFxQixvQkFBb0I7QUFDekMsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrQ0FBa0M7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvZGVmaW5pdGlvbnMvcGxhY2Vob2xkZXJzLmpzPzk2NGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0gZXhwb3J0cy5QTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSUyA9IHZvaWQgMDtcbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IFBMQUNFSE9MREVSUyA9IGV4cG9ydHMuUExBQ0VIT0xERVJTID0gW1wiSWRlbnRpZmllclwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJFeHByZXNzaW9uXCIsIFwiU3RhdGVtZW50XCIsIFwiRGVjbGFyYXRpb25cIiwgXCJCbG9ja1N0YXRlbWVudFwiLCBcIkNsYXNzQm9keVwiLCBcIlBhdHRlcm5cIl07XG5jb25zdCBQTEFDRUhPTERFUlNfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSU19BTElBUyA9IHtcbiAgRGVjbGFyYXRpb246IFtcIlN0YXRlbWVudFwiXSxcbiAgUGF0dGVybjogW1wiUGF0dGVybkxpa2VcIiwgXCJMVmFsXCJdXG59O1xuZm9yIChjb25zdCB0eXBlIG9mIFBMQUNFSE9MREVSUykge1xuICBjb25zdCBhbGlhcyA9IF91dGlscy5BTElBU19LRVlTW3R5cGVdO1xuICBpZiAoYWxpYXMgIT0gbnVsbCAmJiBhbGlhcy5sZW5ndGgpIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXSA9IGFsaWFzO1xufVxuY29uc3QgUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVMgPSBleHBvcnRzLlBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTID0ge307XG5PYmplY3Qua2V5cyhQTEFDRUhPTERFUlNfQUxJQVMpLmZvckVhY2godHlwZSA9PiB7XG4gIFBMQUNFSE9MREVSU19BTElBU1t0eXBlXS5mb3JFYWNoKGFsaWFzID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVMsIGFsaWFzKSkge1xuICAgICAgUExBQ0VIT0xERVJTX0ZMSVBQRURfQUxJQVNbYWxpYXNdID0gW107XG4gICAgfVxuICAgIFBMQUNFSE9MREVSU19GTElQUEVEX0FMSUFTW2FsaWFzXS5wdXNoKHR5cGUpO1xuICB9KTtcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wbGFjZWhvbGRlcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59187\n')},46106:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\nvar _utils = __webpack_require__(77596);\nvar _core = __webpack_require__(5158);\nvar _is = __webpack_require__(93828);\nconst defineType = (0, _utils.defineAliasedType)("TypeScript");\nconst bool = (0, _utils.assertValueType)("boolean");\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),\n    optional: true\n  },\n  typeParameters: {\n    validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),\n    optional: true\n  }\n});\ndefineType("TSParameterProperty", {\n  aliases: ["LVal"],\n  visitor: ["parameter"],\n  fields: {\n    accessibility: {\n      validate: (0, _utils.assertOneOf)("public", "private", "protected"),\n      optional: true\n    },\n    readonly: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    parameter: {\n      validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")\n    },\n    override: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    decorators: {\n      validate: (0, _utils.arrayOfType)("Decorator"),\n      optional: true\n    }\n  }\n});\ndefineType("TSDeclareFunction", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "params", "returnType"],\n  fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType("TSDeclareMethod", {\n  visitor: ["decorators", "key", "typeParameters", "params", "returnType"],\n  fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())\n});\ndefineType("TSQualifiedName", {\n  aliases: ["TSEntityName"],\n  visitor: ["left", "right"],\n  fields: {\n    left: (0, _utils.validateType)("TSEntityName"),\n    right: (0, _utils.validateType)("Identifier")\n  }\n});\nconst signatureDeclarationCommon = () => ({\n  typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n  ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),\n  ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")\n});\nconst callConstructSignatureDeclaration = {\n  aliases: ["TSTypeElement"],\n  visitor: ["typeParameters", "parameters", "typeAnnotation"],\n  fields: signatureDeclarationCommon()\n};\ndefineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);\ndefineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);\nconst namedTypeElementCommon = () => ({\n  key: (0, _utils.validateType)("Expression"),\n  computed: {\n    default: false\n  },\n  optional: (0, _utils.validateOptional)(bool)\n});\ndefineType("TSPropertySignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["key", "typeAnnotation"],\n  fields: Object.assign({}, namedTypeElementCommon(), {\n    readonly: (0, _utils.validateOptional)(bool),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),\n    kind: {\n      validate: (0, _utils.assertOneOf)("get", "set")\n    }\n  })\n});\ndefineType("TSMethodSignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],\n  fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {\n    kind: {\n      validate: (0, _utils.assertOneOf)("method", "get", "set")\n    }\n  })\n});\ndefineType("TSIndexSignature", {\n  aliases: ["TSTypeElement"],\n  visitor: ["parameters", "typeAnnotation"],\n  fields: {\n    readonly: (0, _utils.validateOptional)(bool),\n    static: (0, _utils.validateOptional)(bool),\n    parameters: (0, _utils.validateArrayOfType)("Identifier"),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")\n  }\n});\nconst tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: ["TSType", "TSBaseType"],\n    visitor: [],\n    fields: {}\n  });\n}\ndefineType("TSThisType", {\n  aliases: ["TSType", "TSBaseType"],\n  visitor: [],\n  fields: {}\n});\nconst fnOrCtrBase = {\n  aliases: ["TSType"],\n  visitor: ["typeParameters", "parameters", "typeAnnotation"]\n};\ndefineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {\n  fields: signatureDeclarationCommon()\n}));\ndefineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {\n  fields: Object.assign({}, signatureDeclarationCommon(), {\n    abstract: (0, _utils.validateOptional)(bool)\n  })\n}));\ndefineType("TSTypeReference", {\n  aliases: ["TSType"],\n  visitor: ["typeName", "typeParameters"],\n  fields: {\n    typeName: (0, _utils.validateType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\ndefineType("TSTypePredicate", {\n  aliases: ["TSType"],\n  visitor: ["parameterName", "typeAnnotation"],\n  builder: ["parameterName", "typeAnnotation", "asserts"],\n  fields: {\n    parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),\n    asserts: (0, _utils.validateOptional)(bool)\n  }\n});\ndefineType("TSTypeQuery", {\n  aliases: ["TSType"],\n  visitor: ["exprName", "typeParameters"],\n  fields: {\n    exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\ndefineType("TSTypeLiteral", {\n  aliases: ["TSType"],\n  visitor: ["members"],\n  fields: {\n    members: (0, _utils.validateArrayOfType)("TSTypeElement")\n  }\n});\ndefineType("TSArrayType", {\n  aliases: ["TSType"],\n  visitor: ["elementType"],\n  fields: {\n    elementType: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSTupleType", {\n  aliases: ["TSType"],\n  visitor: ["elementTypes"],\n  fields: {\n    elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")\n  }\n});\ndefineType("TSOptionalType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSRestType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSNamedTupleMember", {\n  visitor: ["label", "elementType"],\n  builder: ["label", "elementType", "optional"],\n  fields: {\n    label: (0, _utils.validateType)("Identifier"),\n    optional: {\n      validate: bool,\n      default: false\n    },\n    elementType: (0, _utils.validateType)("TSType")\n  }\n});\nconst unionOrIntersection = {\n  aliases: ["TSType"],\n  visitor: ["types"],\n  fields: {\n    types: (0, _utils.validateArrayOfType)("TSType")\n  }\n};\ndefineType("TSUnionType", unionOrIntersection);\ndefineType("TSIntersectionType", unionOrIntersection);\ndefineType("TSConditionalType", {\n  aliases: ["TSType"],\n  visitor: ["checkType", "extendsType", "trueType", "falseType"],\n  fields: {\n    checkType: (0, _utils.validateType)("TSType"),\n    extendsType: (0, _utils.validateType)("TSType"),\n    trueType: (0, _utils.validateType)("TSType"),\n    falseType: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSInferType", {\n  aliases: ["TSType"],\n  visitor: ["typeParameter"],\n  fields: {\n    typeParameter: (0, _utils.validateType)("TSTypeParameter")\n  }\n});\ndefineType("TSParenthesizedType", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSTypeOperator", {\n  aliases: ["TSType"],\n  visitor: ["typeAnnotation"],\n  fields: {\n    operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSIndexedAccessType", {\n  aliases: ["TSType"],\n  visitor: ["objectType", "indexType"],\n  fields: {\n    objectType: (0, _utils.validateType)("TSType"),\n    indexType: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSMappedType", {\n  aliases: ["TSType"],\n  visitor: ["typeParameter", "nameType", "typeAnnotation"],\n  builder: ["typeParameter", "typeAnnotation", "nameType"],\n  fields: Object.assign({}, {\n    typeParameter: (0, _utils.validateType)("TSTypeParameter")\n  }, {\n    readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),\n    optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),\n    typeAnnotation: (0, _utils.validateOptionalType)("TSType"),\n    nameType: (0, _utils.validateOptionalType)("TSType")\n  })\n});\ndefineType("TSLiteralType", {\n  aliases: ["TSType", "TSBaseType"],\n  visitor: ["literal"],\n  fields: {\n    literal: {\n      validate: function () {\n        const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");\n        const unaryOperator = (0, _utils.assertOneOf)("-");\n        const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");\n        function validator(parent, key, node) {\n          if ((0, _is.default)("UnaryExpression", node)) {\n            unaryOperator(node, "operator", node.operator);\n            unaryExpression(node, "argument", node.argument);\n          } else {\n            literal(parent, key, node);\n          }\n        }\n        validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];\n        return validator;\n      }()\n    }\n  }\n});\nconst expressionWithTypeArguments = {\n  aliases: ["TSType"],\n  visitor: ["expression", "typeParameters"],\n  fields: {\n    expression: (0, _utils.validateType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n};\n{\n  defineType("TSExpressionWithTypeArguments", expressionWithTypeArguments);\n}\ndefineType("TSInterfaceDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "extends", "body"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n    extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),\n    body: (0, _utils.validateType)("TSInterfaceBody")\n  }\n});\ndefineType("TSInterfaceBody", {\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("TSTypeElement")\n  }\n});\ndefineType("TSTypeAliasDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "typeParameters", "typeAnnotation"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n});\ndefineType("TSInstantiationExpression", {\n  aliases: ["Expression"],\n  visitor: ["expression", "typeParameters"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")\n  }\n});\nconst TSTypeExpression = {\n  aliases: ["Expression", "LVal", "PatternLike"],\n  visitor: ["expression", "typeAnnotation"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression"),\n    typeAnnotation: (0, _utils.validateType)("TSType")\n  }\n};\ndefineType("TSAsExpression", TSTypeExpression);\ndefineType("TSSatisfiesExpression", TSTypeExpression);\ndefineType("TSTypeAssertion", {\n  aliases: ["Expression", "LVal", "PatternLike"],\n  visitor: ["typeAnnotation", "expression"],\n  fields: {\n    typeAnnotation: (0, _utils.validateType)("TSType"),\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\ndefineType("TSEnumDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "members"],\n  fields: {\n    declare: (0, _utils.validateOptional)(bool),\n    const: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    members: (0, _utils.validateArrayOfType)("TSEnumMember"),\n    initializer: (0, _utils.validateOptionalType)("Expression")\n  }\n});\ndefineType("TSEnumMember", {\n  visitor: ["id", "initializer"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier", "StringLiteral"),\n    initializer: (0, _utils.validateOptionalType)("Expression")\n  }\n});\ndefineType("TSModuleDeclaration", {\n  aliases: ["Statement", "Declaration"],\n  visitor: ["id", "body"],\n  fields: {\n    kind: {\n      validate: (0, _utils.assertOneOf)("global", "module", "namespace")\n    },\n    declare: (0, _utils.validateOptional)(bool),\n    global: (0, _utils.validateOptional)(bool),\n    id: (0, _utils.validateType)("Identifier", "StringLiteral"),\n    body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")\n  }\n});\ndefineType("TSModuleBlock", {\n  aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],\n  visitor: ["body"],\n  fields: {\n    body: (0, _utils.validateArrayOfType)("Statement")\n  }\n});\ndefineType("TSImportType", {\n  aliases: ["TSType"],\n  visitor: ["argument", "qualifier", "typeParameters"],\n  fields: {\n    argument: (0, _utils.validateType)("StringLiteral"),\n    qualifier: (0, _utils.validateOptionalType)("TSEntityName"),\n    typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),\n    options: {\n      validate: (0, _utils.assertNodeType)("Expression"),\n      optional: true\n    }\n  }\n});\ndefineType("TSImportEqualsDeclaration", {\n  aliases: ["Statement"],\n  visitor: ["id", "moduleReference"],\n  fields: {\n    isExport: (0, _utils.validate)(bool),\n    id: (0, _utils.validateType)("Identifier"),\n    moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),\n    importKind: {\n      validate: (0, _utils.assertOneOf)("type", "value"),\n      optional: true\n    }\n  }\n});\ndefineType("TSExternalModuleReference", {\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("StringLiteral")\n  }\n});\ndefineType("TSNonNullExpression", {\n  aliases: ["Expression", "LVal", "PatternLike"],\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\ndefineType("TSExportAssignment", {\n  aliases: ["Statement"],\n  visitor: ["expression"],\n  fields: {\n    expression: (0, _utils.validateType)("Expression")\n  }\n});\ndefineType("TSNamespaceExportDeclaration", {\n  aliases: ["Statement"],\n  visitor: ["id"],\n  fields: {\n    id: (0, _utils.validateType)("Identifier")\n  }\n});\ndefineType("TSTypeAnnotation", {\n  visitor: ["typeAnnotation"],\n  fields: {\n    typeAnnotation: {\n      validate: (0, _utils.assertNodeType)("TSType")\n    }\n  }\n});\ndefineType("TSTypeParameterInstantiation", {\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)("TSType")\n  }\n});\ndefineType("TSTypeParameterDeclaration", {\n  visitor: ["params"],\n  fields: {\n    params: (0, _utils.validateArrayOfType)("TSTypeParameter")\n  }\n});\ndefineType("TSTypeParameter", {\n  builder: ["constraint", "default", "name"],\n  visitor: ["constraint", "default"],\n  fields: {\n    name: {\n      validate: (0, _utils.assertValueType)("string")\n    },\n    in: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    out: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    const: {\n      validate: (0, _utils.assertValueType)("boolean"),\n      optional: true\n    },\n    constraint: {\n      validate: (0, _utils.assertNodeType)("TSType"),\n      optional: true\n    },\n    default: {\n      validate: (0, _utils.assertNodeType)("TSType"),\n      optional: true\n    }\n  }\n});\n\n//# sourceMappingURL=typescript.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYxMDYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakMsWUFBWSxtQkFBTyxDQUFDLElBQVc7QUFDL0IsVUFBVSxtQkFBTyxDQUFDLEtBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLENBQUM7QUFDRCxnREFBZ0Q7QUFDaEQsMEJBQTBCO0FBQzFCO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy90eXBlc2NyaXB0LmpzP2RmYzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmUuanNcIik7XG52YXIgX2lzID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXMuanNcIik7XG5jb25zdCBkZWZpbmVUeXBlID0gKDAsIF91dGlscy5kZWZpbmVBbGlhc2VkVHlwZSkoXCJUeXBlU2NyaXB0XCIpO1xuY29uc3QgYm9vbCA9ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIik7XG5jb25zdCB0U0Z1bmN0aW9uVHlwZUFubm90YXRpb25Db21tb24gPSAoKSA9PiAoe1xuICByZXR1cm5UeXBlOiB7XG4gICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSxcbiAgdHlwZVBhcmFtZXRlcnM6IHtcbiAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCBcIk5vb3BcIiksXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiLCB7XG4gIGFsaWFzZXM6IFtcIkxWYWxcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtZXRlclwiXSxcbiAgZmllbGRzOiB7XG4gICAgYWNjZXNzaWJpbGl0eToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICByZWFkb25seToge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0VmFsdWVUeXBlKShcImJvb2xlYW5cIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgcGFyYW1ldGVyOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiQXNzaWdubWVudFBhdHRlcm5cIilcbiAgICB9LFxuICAgIG92ZXJyaWRlOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBkZWNvcmF0b3JzOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hcnJheU9mVHlwZSkoXCJEZWNvcmF0b3JcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNEZWNsYXJlRnVuY3Rpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiLCBcInJldHVyblR5cGVcIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgKDAsIF9jb3JlLmZ1bmN0aW9uRGVjbGFyYXRpb25Db21tb24pKCksIHRTRnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbigpKVxufSk7XG5kZWZpbmVUeXBlKFwiVFNEZWNsYXJlTWV0aG9kXCIsIHtcbiAgdmlzaXRvcjogW1wiZGVjb3JhdG9yc1wiLCBcImtleVwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCAoMCwgX2NvcmUuY2xhc3NNZXRob2RPckRlY2xhcmVNZXRob2RDb21tb24pKCksIHRTRnVuY3Rpb25UeXBlQW5ub3RhdGlvbkNvbW1vbigpKVxufSk7XG5kZWZpbmVUeXBlKFwiVFNRdWFsaWZpZWROYW1lXCIsIHtcbiAgYWxpYXNlczogW1wiVFNFbnRpdHlOYW1lXCJdLFxuICB2aXNpdG9yOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sXG4gIGZpZWxkczoge1xuICAgIGxlZnQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiKSxcbiAgICByaWdodDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmNvbnN0IHNpZ25hdHVyZURlY2xhcmF0aW9uQ29tbW9uID0gKCkgPT4gKHtcbiAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gIFtcInBhcmFtZXRlcnNcIl06ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJBcnJheVBhdHRlcm5cIiwgXCJJZGVudGlmaWVyXCIsIFwiT2JqZWN0UGF0dGVyblwiLCBcIlJlc3RFbGVtZW50XCIpLFxuICBbXCJ0eXBlQW5ub3RhdGlvblwiXTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG59KTtcbmNvbnN0IGNhbGxDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbiA9IHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1widHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczogc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24oKVxufTtcbmRlZmluZVR5cGUoXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLCBjYWxsQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24pO1xuZGVmaW5lVHlwZShcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgY2FsbENvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uKTtcbmNvbnN0IG5hbWVkVHlwZUVsZW1lbnRDb21tb24gPSAoKSA9PiAoe1xuICBrZXk6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gIGNvbXB1dGVkOiB7XG4gICAgZGVmYXVsdDogZmFsc2VcbiAgfSxcbiAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbClcbn0pO1xuZGVmaW5lVHlwZShcIlRTUHJvcGVydHlTaWduYXR1cmVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVFbGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJrZXlcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCBuYW1lZFR5cGVFbGVtZW50Q29tbW9uKCksIHtcbiAgICByZWFkb25seTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgIGtpbmQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydE9uZU9mKShcImdldFwiLCBcInNldFwiKVxuICAgIH1cbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlRTTWV0aG9kU2lnbmF0dXJlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlRWxlbWVudFwiXSxcbiAgdmlzaXRvcjogW1wia2V5XCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24oKSwgbmFtZWRUeXBlRWxlbWVudENvbW1vbigpLCB7XG4gICAga2luZDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwibWV0aG9kXCIsIFwiZ2V0XCIsIFwic2V0XCIpXG4gICAgfVxuICB9KVxufSk7XG5kZWZpbmVUeXBlKFwiVFNJbmRleFNpZ25hdHVyZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZUVsZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiXSxcbiAgZmllbGRzOiB7XG4gICAgcmVhZG9ubHk6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgc3RhdGljOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIHBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZUFubm90YXRpb25cIilcbiAgfVxufSk7XG5jb25zdCB0c0tleXdvcmRUeXBlcyA9IFtcIlRTQW55S2V5d29yZFwiLCBcIlRTQm9vbGVhbktleXdvcmRcIiwgXCJUU0JpZ0ludEtleXdvcmRcIiwgXCJUU0ludHJpbnNpY0tleXdvcmRcIiwgXCJUU05ldmVyS2V5d29yZFwiLCBcIlRTTnVsbEtleXdvcmRcIiwgXCJUU051bWJlcktleXdvcmRcIiwgXCJUU09iamVjdEtleXdvcmRcIiwgXCJUU1N0cmluZ0tleXdvcmRcIiwgXCJUU1N5bWJvbEtleXdvcmRcIiwgXCJUU1VuZGVmaW5lZEtleXdvcmRcIiwgXCJUU1Vua25vd25LZXl3b3JkXCIsIFwiVFNWb2lkS2V5d29yZFwiXTtcbmZvciAoY29uc3QgdHlwZSBvZiB0c0tleXdvcmRUeXBlcykge1xuICBkZWZpbmVUeXBlKHR5cGUsIHtcbiAgICBhbGlhc2VzOiBbXCJUU1R5cGVcIiwgXCJUU0Jhc2VUeXBlXCJdLFxuICAgIHZpc2l0b3I6IFtdLFxuICAgIGZpZWxkczoge31cbiAgfSk7XG59XG5kZWZpbmVUeXBlKFwiVFNUaGlzVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiLCBcIlRTQmFzZVR5cGVcIl0sXG4gIHZpc2l0b3I6IFtdLFxuICBmaWVsZHM6IHt9XG59KTtcbmNvbnN0IGZuT3JDdHJCYXNlID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJzXCIsIFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCJdXG59O1xuZGVmaW5lVHlwZShcIlRTRnVuY3Rpb25UeXBlXCIsIE9iamVjdC5hc3NpZ24oe30sIGZuT3JDdHJCYXNlLCB7XG4gIGZpZWxkczogc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24oKVxufSkpO1xuZGVmaW5lVHlwZShcIlRTQ29uc3RydWN0b3JUeXBlXCIsIE9iamVjdC5hc3NpZ24oe30sIGZuT3JDdHJCYXNlLCB7XG4gIGZpZWxkczogT2JqZWN0LmFzc2lnbih7fSwgc2lnbmF0dXJlRGVjbGFyYXRpb25Db21tb24oKSwge1xuICAgIGFic3RyYWN0OiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpXG4gIH0pXG59KSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlUmVmZXJlbmNlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlTmFtZVwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlTmFtZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlUHJlZGljYXRlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJwYXJhbWV0ZXJOYW1lXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGJ1aWxkZXI6IFtcInBhcmFtZXRlck5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImFzc2VydHNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtZXRlck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiwgXCJUU1RoaXNUeXBlXCIpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZUFubm90YXRpb25cIiksXG4gICAgYXNzZXJ0czogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKShib29sKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVRdWVyeVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZXhwck5hbWVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwck5hbWU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTRW50aXR5TmFtZVwiLCBcIlRTSW1wb3J0VHlwZVwiKSxcbiAgICB0eXBlUGFyYW1ldGVyczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZUxpdGVyYWxcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIG1lbWJlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVFbGVtZW50XCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTQXJyYXlUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJlbGVtZW50VHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgZWxlbWVudFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R1cGxlVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiZWxlbWVudFR5cGVzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBlbGVtZW50VHlwZXM6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJUU1R5cGVcIiwgXCJUU05hbWVkVHVwbGVNZW1iZXJcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNPcHRpb25hbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTUmVzdFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTTmFtZWRUdXBsZU1lbWJlclwiLCB7XG4gIHZpc2l0b3I6IFtcImxhYmVsXCIsIFwiZWxlbWVudFR5cGVcIl0sXG4gIGJ1aWxkZXI6IFtcImxhYmVsXCIsIFwiZWxlbWVudFR5cGVcIiwgXCJvcHRpb25hbFwiXSxcbiAgZmllbGRzOiB7XG4gICAgbGFiZWw6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgb3B0aW9uYWw6IHtcbiAgICAgIHZhbGlkYXRlOiBib29sLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGVsZW1lbnRUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5jb25zdCB1bmlvbk9ySW50ZXJzZWN0aW9uID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVzXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59O1xuZGVmaW5lVHlwZShcIlRTVW5pb25UeXBlXCIsIHVuaW9uT3JJbnRlcnNlY3Rpb24pO1xuZGVmaW5lVHlwZShcIlRTSW50ZXJzZWN0aW9uVHlwZVwiLCB1bmlvbk9ySW50ZXJzZWN0aW9uKTtcbmRlZmluZVR5cGUoXCJUU0NvbmRpdGlvbmFsVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1wiY2hlY2tUeXBlXCIsIFwiZXh0ZW5kc1R5cGVcIiwgXCJ0cnVlVHlwZVwiLCBcImZhbHNlVHlwZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgY2hlY2tUeXBlOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgZXh0ZW5kc1R5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICB0cnVlVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgIGZhbHNlVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTSW5mZXJUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlUGFyYW1ldGVyXCJdLFxuICBmaWVsZHM6IHtcbiAgICB0eXBlUGFyYW1ldGVyOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVQYXJhbWV0ZXJcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiLCB7XG4gIGFsaWFzZXM6IFtcIlRTVHlwZVwiXSxcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlT3BlcmF0b3JcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBvcGVyYXRvcjogKDAsIF91dGlscy52YWxpZGF0ZSkoKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwic3RyaW5nXCIpKSxcbiAgICB0eXBlQW5ub3RhdGlvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcIm9iamVjdFR5cGVcIiwgXCJpbmRleFR5cGVcIl0sXG4gIGZpZWxkczoge1xuICAgIG9iamVjdFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBpbmRleFR5cGU6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU01hcHBlZFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcInR5cGVQYXJhbWV0ZXJcIiwgXCJuYW1lVHlwZVwiLCBcInR5cGVBbm5vdGF0aW9uXCJdLFxuICBidWlsZGVyOiBbXCJ0eXBlUGFyYW1ldGVyXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJuYW1lVHlwZVwiXSxcbiAgZmllbGRzOiBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgdHlwZVBhcmFtZXRlcjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpXG4gIH0sIHtcbiAgICByZWFkb25seTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFzc2VydE9uZU9mKSh0cnVlLCBmYWxzZSwgXCIrXCIsIFwiLVwiKSksXG4gICAgb3B0aW9uYWw6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoKDAsIF91dGlscy5hc3NlcnRPbmVPZikodHJ1ZSwgZmFsc2UsIFwiK1wiLCBcIi1cIikpLFxuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVwiKSxcbiAgICBuYW1lVHlwZTogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJUU1R5cGVcIilcbiAgfSlcbn0pO1xuZGVmaW5lVHlwZShcIlRTTGl0ZXJhbFR5cGVcIiwge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIiwgXCJUU0Jhc2VUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJsaXRlcmFsXCJdLFxuICBmaWVsZHM6IHtcbiAgICBsaXRlcmFsOiB7XG4gICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCB1bmFyeUV4cHJlc3Npb24gPSAoMCwgX3V0aWxzLmFzc2VydE5vZGVUeXBlKShcIk51bWVyaWNMaXRlcmFsXCIsIFwiQmlnSW50TGl0ZXJhbFwiKTtcbiAgICAgICAgY29uc3QgdW5hcnlPcGVyYXRvciA9ICgwLCBfdXRpbHMuYXNzZXJ0T25lT2YpKFwiLVwiKTtcbiAgICAgICAgY29uc3QgbGl0ZXJhbCA9ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiTnVtZXJpY0xpdGVyYWxcIiwgXCJTdHJpbmdMaXRlcmFsXCIsIFwiQm9vbGVhbkxpdGVyYWxcIiwgXCJCaWdJbnRMaXRlcmFsXCIsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0b3IocGFyZW50LCBrZXksIG5vZGUpIHtcbiAgICAgICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KShcIlVuYXJ5RXhwcmVzc2lvblwiLCBub2RlKSkge1xuICAgICAgICAgICAgdW5hcnlPcGVyYXRvcihub2RlLCBcIm9wZXJhdG9yXCIsIG5vZGUub3BlcmF0b3IpO1xuICAgICAgICAgICAgdW5hcnlFeHByZXNzaW9uKG5vZGUsIFwiYXJndW1lbnRcIiwgbm9kZS5hcmd1bWVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpdGVyYWwocGFyZW50LCBrZXksIG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWxpZGF0b3Iub25lT2ZOb2RlVHlwZXMgPSBbXCJOdW1lcmljTGl0ZXJhbFwiLCBcIlN0cmluZ0xpdGVyYWxcIiwgXCJCb29sZWFuTGl0ZXJhbFwiLCBcIkJpZ0ludExpdGVyYWxcIiwgXCJUZW1wbGF0ZUxpdGVyYWxcIiwgXCJVbmFyeUV4cHJlc3Npb25cIl07XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3I7XG4gICAgICB9KClcbiAgICB9XG4gIH1cbn0pO1xuY29uc3QgZXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzID0ge1xuICBhbGlhc2VzOiBbXCJUU1R5cGVcIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufTtcbntcbiAgZGVmaW5lVHlwZShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIsIGV4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyk7XG59XG5kZWZpbmVUeXBlKFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwiZXh0ZW5kc1wiLCBcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgZXh0ZW5kczogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsKSgoMCwgX3V0aWxzLmFycmF5T2ZUeXBlKShcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU0ludGVyZmFjZUJvZHlcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNJbnRlcmZhY2VCb2R5XCIsIHtcbiAgdmlzaXRvcjogW1wiYm9keVwiXSxcbiAgZmllbGRzOiB7XG4gICAgYm9keTogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTVHlwZUVsZW1lbnRcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgdHlwZVBhcmFtZXRlcnM6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIsIHtcbiAgYWxpYXNlczogW1wiRXhwcmVzc2lvblwiXSxcbiAgdmlzaXRvcjogW1wiZXhwcmVzc2lvblwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIilcbiAgfVxufSk7XG5jb25zdCBUU1R5cGVFeHByZXNzaW9uID0ge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiLCBcIlBhdHRlcm5MaWtlXCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCIsIFwidHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIiksXG4gICAgdHlwZUFubm90YXRpb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59O1xuZGVmaW5lVHlwZShcIlRTQXNFeHByZXNzaW9uXCIsIFRTVHlwZUV4cHJlc3Npb24pO1xuZGVmaW5lVHlwZShcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiLCBUU1R5cGVFeHByZXNzaW9uKTtcbmRlZmluZVR5cGUoXCJUU1R5cGVBc3NlcnRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJFeHByZXNzaW9uXCIsIFwiTFZhbFwiLCBcIlBhdHRlcm5MaWtlXCJdLFxuICB2aXNpdG9yOiBbXCJ0eXBlQW5ub3RhdGlvblwiLCBcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgZXhwcmVzc2lvbjogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiRXhwcmVzc2lvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0VudW1EZWNsYXJhdGlvblwiLCB7XG4gIGFsaWFzZXM6IFtcIlN0YXRlbWVudFwiLCBcIkRlY2xhcmF0aW9uXCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1lbWJlcnNcIl0sXG4gIGZpZWxkczoge1xuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgY29uc3Q6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgaWQ6ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIklkZW50aWZpZXJcIiksXG4gICAgbWVtYmVyczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTRW51bU1lbWJlclwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTRW51bU1lbWJlclwiLCB7XG4gIHZpc2l0b3I6IFtcImlkXCIsIFwiaW5pdGlhbGl6ZXJcIl0sXG4gIGZpZWxkczoge1xuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBpbml0aWFsaXplcjogKDAsIF91dGlscy52YWxpZGF0ZU9wdGlvbmFsVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIiwgXCJEZWNsYXJhdGlvblwiXSxcbiAgdmlzaXRvcjogW1wiaWRcIiwgXCJib2R5XCJdLFxuICBmaWVsZHM6IHtcbiAgICBraW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJnbG9iYWxcIiwgXCJtb2R1bGVcIiwgXCJuYW1lc3BhY2VcIilcbiAgICB9LFxuICAgIGRlY2xhcmU6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbCkoYm9vbCksXG4gICAgZ2xvYmFsOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWwpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIsIFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBib2R5OiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJUU01vZHVsZUJsb2NrXCIsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU01vZHVsZUJsb2NrXCIsIHtcbiAgYWxpYXNlczogW1wiU2NvcGFibGVcIiwgXCJCbG9ja1wiLCBcIkJsb2NrUGFyZW50XCIsIFwiRnVuY3Rpb25QYXJlbnRcIl0sXG4gIHZpc2l0b3I6IFtcImJvZHlcIl0sXG4gIGZpZWxkczoge1xuICAgIGJvZHk6ICgwLCBfdXRpbHMudmFsaWRhdGVBcnJheU9mVHlwZSkoXCJTdGF0ZW1lbnRcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNJbXBvcnRUeXBlXCIsIHtcbiAgYWxpYXNlczogW1wiVFNUeXBlXCJdLFxuICB2aXNpdG9yOiBbXCJhcmd1bWVudFwiLCBcInF1YWxpZmllclwiLCBcInR5cGVQYXJhbWV0ZXJzXCJdLFxuICBmaWVsZHM6IHtcbiAgICBhcmd1bWVudDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBxdWFsaWZpZXI6ICgwLCBfdXRpbHMudmFsaWRhdGVPcHRpb25hbFR5cGUpKFwiVFNFbnRpdHlOYW1lXCIpLFxuICAgIHR5cGVQYXJhbWV0ZXJzOiAoMCwgX3V0aWxzLnZhbGlkYXRlT3B0aW9uYWxUeXBlKShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgb3B0aW9uczoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiRXhwcmVzc2lvblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU0ltcG9ydEVxdWFsc0RlY2xhcmF0aW9uXCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJpZFwiLCBcIm1vZHVsZVJlZmVyZW5jZVwiXSxcbiAgZmllbGRzOiB7XG4gICAgaXNFeHBvcnQ6ICgwLCBfdXRpbHMudmFsaWRhdGUpKGJvb2wpLFxuICAgIGlkOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJJZGVudGlmaWVyXCIpLFxuICAgIG1vZHVsZVJlZmVyZW5jZTogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiVFNFbnRpdHlOYW1lXCIsIFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSxcbiAgICBpbXBvcnRLaW5kOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRPbmVPZikoXCJ0eXBlXCIsIFwidmFsdWVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiLCB7XG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIlN0cmluZ0xpdGVyYWxcIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNOb25OdWxsRXhwcmVzc2lvblwiLCB7XG4gIGFsaWFzZXM6IFtcIkV4cHJlc3Npb25cIiwgXCJMVmFsXCIsIFwiUGF0dGVybkxpa2VcIl0sXG4gIHZpc2l0b3I6IFtcImV4cHJlc3Npb25cIl0sXG4gIGZpZWxkczoge1xuICAgIGV4cHJlc3Npb246ICgwLCBfdXRpbHMudmFsaWRhdGVUeXBlKShcIkV4cHJlc3Npb25cIilcbiAgfVxufSk7XG5kZWZpbmVUeXBlKFwiVFNFeHBvcnRBc3NpZ25tZW50XCIsIHtcbiAgYWxpYXNlczogW1wiU3RhdGVtZW50XCJdLFxuICB2aXNpdG9yOiBbXCJleHByZXNzaW9uXCJdLFxuICBmaWVsZHM6IHtcbiAgICBleHByZXNzaW9uOiAoMCwgX3V0aWxzLnZhbGlkYXRlVHlwZSkoXCJFeHByZXNzaW9uXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIiwge1xuICBhbGlhc2VzOiBbXCJTdGF0ZW1lbnRcIl0sXG4gIHZpc2l0b3I6IFtcImlkXCJdLFxuICBmaWVsZHM6IHtcbiAgICBpZDogKDAsIF91dGlscy52YWxpZGF0ZVR5cGUpKFwiSWRlbnRpZmllclwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVBbm5vdGF0aW9uXCIsIHtcbiAgdmlzaXRvcjogW1widHlwZUFubm90YXRpb25cIl0sXG4gIGZpZWxkczoge1xuICAgIHR5cGVBbm5vdGF0aW9uOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVcIilcbiAgICB9XG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiwge1xuICB2aXNpdG9yOiBbXCJwYXJhbXNcIl0sXG4gIGZpZWxkczoge1xuICAgIHBhcmFtczogKDAsIF91dGlscy52YWxpZGF0ZUFycmF5T2ZUeXBlKShcIlRTVHlwZVwiKVxuICB9XG59KTtcbmRlZmluZVR5cGUoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiLCB7XG4gIHZpc2l0b3I6IFtcInBhcmFtc1wiXSxcbiAgZmllbGRzOiB7XG4gICAgcGFyYW1zOiAoMCwgX3V0aWxzLnZhbGlkYXRlQXJyYXlPZlR5cGUpKFwiVFNUeXBlUGFyYW1ldGVyXCIpXG4gIH1cbn0pO1xuZGVmaW5lVHlwZShcIlRTVHlwZVBhcmFtZXRlclwiLCB7XG4gIGJ1aWxkZXI6IFtcImNvbnN0cmFpbnRcIiwgXCJkZWZhdWx0XCIsIFwibmFtZVwiXSxcbiAgdmlzaXRvcjogW1wiY29uc3RyYWludFwiLCBcImRlZmF1bHRcIl0sXG4gIGZpZWxkczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJzdHJpbmdcIilcbiAgICB9LFxuICAgIGluOiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBvdXQ6IHtcbiAgICAgIHZhbGlkYXRlOiAoMCwgX3V0aWxzLmFzc2VydFZhbHVlVHlwZSkoXCJib29sZWFuXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9LFxuICAgIGNvbnN0OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnRWYWx1ZVR5cGUpKFwiYm9vbGVhblwiKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSxcbiAgICBjb25zdHJhaW50OiB7XG4gICAgICB2YWxpZGF0ZTogKDAsIF91dGlscy5hc3NlcnROb2RlVHlwZSkoXCJUU1R5cGVcIiksXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0sXG4gICAgZGVmYXVsdDoge1xuICAgICAgdmFsaWRhdGU6ICgwLCBfdXRpbHMuYXNzZXJ0Tm9kZVR5cGUpKFwiVFNUeXBlXCIpLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlc2NyaXB0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46106\n')},77596:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;\nexports.arrayOf = arrayOf;\nexports.arrayOfType = arrayOfType;\nexports.assertEach = assertEach;\nexports.assertNodeOrValueType = assertNodeOrValueType;\nexports.assertNodeType = assertNodeType;\nexports.assertOneOf = assertOneOf;\nexports.assertOptionalChainStart = assertOptionalChainStart;\nexports.assertShape = assertShape;\nexports.assertValueType = assertValueType;\nexports.chain = chain;\nexports["default"] = defineType;\nexports.defineAliasedType = defineAliasedType;\nexports.validate = validate;\nexports.validateArrayOfType = validateArrayOfType;\nexports.validateOptional = validateOptional;\nexports.validateOptionalType = validateOptionalType;\nexports.validateType = validateType;\nvar _is = __webpack_require__(93828);\nvar _validate = __webpack_require__(57446);\nconst VISITOR_KEYS = exports.VISITOR_KEYS = {};\nconst ALIAS_KEYS = exports.ALIAS_KEYS = {};\nconst FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {};\nconst NODE_FIELDS = exports.NODE_FIELDS = {};\nconst BUILDER_KEYS = exports.BUILDER_KEYS = {};\nconst DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {};\nconst NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {};\nfunction getType(val) {\n  if (Array.isArray(val)) {\n    return "array";\n  } else if (val === null) {\n    return "null";\n  } else {\n    return typeof val;\n  }\n}\nfunction validate(validate) {\n  return {\n    validate\n  };\n}\nfunction validateType(...typeNames) {\n  return validate(assertNodeType(...typeNames));\n}\nfunction validateOptional(validate) {\n  return {\n    validate,\n    optional: true\n  };\n}\nfunction validateOptionalType(...typeNames) {\n  return {\n    validate: assertNodeType(...typeNames),\n    optional: true\n  };\n}\nfunction arrayOf(elementType) {\n  return chain(assertValueType("array"), assertEach(elementType));\n}\nfunction arrayOfType(...typeNames) {\n  return arrayOf(assertNodeType(...typeNames));\n}\nfunction validateArrayOfType(...typeNames) {\n  return validate(arrayOfType(...typeNames));\n}\nfunction assertEach(callback) {\n  const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {};\n  function validator(node, key, val) {\n    if (!Array.isArray(val)) return;\n    for (let i = 0; i < val.length; i++) {\n      const subkey = `${key}[${i}]`;\n      const v = val[i];\n      callback(node, subkey, v);\n      childValidator(node, subkey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\nfunction assertOneOf(...values) {\n  function validate(node, key, val) {\n    if (!values.includes(val)) {\n      throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);\n    }\n  }\n  validate.oneOf = values;\n  return validate;\n}\nfunction assertNodeType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if ((0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeTypes = types;\n  return validate;\n}\nfunction assertNodeOrValueType(...types) {\n  function validate(node, key, val) {\n    for (const type of types) {\n      if (getType(val) === type || (0, _is.default)(type, val)) {\n        (0, _validate.validateChild)(node, key, val);\n        return;\n      }\n    }\n    throw new TypeError(`Property ${key} of ${node.type} expected node to be of a type ${JSON.stringify(types)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);\n  }\n  validate.oneOfNodeOrValueTypes = types;\n  return validate;\n}\nfunction assertValueType(type) {\n  function validate(node, key, val) {\n    const valid = getType(val) === type;\n    if (!valid) {\n      throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);\n    }\n  }\n  validate.type = type;\n  return validate;\n}\nfunction assertShape(shape) {\n  function validate(node, key, val) {\n    const errors = [];\n    for (const property of Object.keys(shape)) {\n      try {\n        (0, _validate.validateField)(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(`Property ${key} of ${node.type} expected to have the following:\\n${errors.join("\\n")}`);\n    }\n  }\n  validate.shapeOf = shape;\n  return validate;\n}\nfunction assertOptionalChainStart() {\n  function validate(node) {\n    var _current;\n    let current = node;\n    while (node) {\n      const {\n        type\n      } = current;\n      if (type === "OptionalCallExpression") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n      if (type === "OptionalMemberExpression") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n      break;\n    }\n    throw new TypeError(`Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);\n  }\n  return validate;\n}\nfunction chain(...fns) {\n  function validate(...args) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {\n    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);\n  }\n  return validate;\n}\nconst validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);\nconst validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);\nconst store = {};\nfunction defineAliasedType(...aliases) {\n  return (type, opts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      var _store$opts$inherits$, _defined;\n      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();\n      (_defined = defined) != null ? _defined : defined = [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\nfunction defineType(type, opts = {}) {\n  const inherits = opts.inherits && store[opts.inherits] || {};\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {\n          throw new Error("field defaults can only be primitives or empty arrays currently");\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate\n        };\n      }\n    }\n  }\n  const visitor = opts.visitor || inherits.visitor || [];\n  const aliases = opts.aliases || inherits.aliases || [];\n  const builder = opts.builder || inherits.builder || opts.visitor || [];\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option "${k}" on ${type}`);\n    }\n  }\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type;\n  }\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n    if (field.default !== undefined && !builder.includes(key)) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key "${k}" on ${type}.${key}`);\n      }\n    }\n  }\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type);\n  });\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  store[type] = opts;\n}\n\n//# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc1OTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysb0JBQW9CLEdBQUcsK0JBQStCLEdBQUcsbUJBQW1CLEdBQUcsMEJBQTBCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCO0FBQy9LLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLDZCQUE2QjtBQUM3QixzQkFBc0I7QUFDdEIsbUJBQW1CO0FBQ25CLGdDQUFnQztBQUNoQyxtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLGFBQWE7QUFDYixrQkFBZTtBQUNmLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEIsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLFVBQVUsbUJBQU8sQ0FBQyxLQUFxQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUEyQjtBQUNuRCxxQkFBcUIsb0JBQW9CO0FBQ3pDLG1CQUFtQixrQkFBa0I7QUFDckMsMkJBQTJCLDBCQUEwQjtBQUNyRCxvQkFBb0IsbUJBQW1CO0FBQ3ZDLHFCQUFxQixvQkFBb0I7QUFDekMsd0JBQXdCLHVCQUF1QjtBQUMvQyxnQ0FBZ0MsK0JBQStCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLHdCQUF3QixJQUFJLEdBQUcsRUFBRTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssOEJBQThCLHdCQUF3QixVQUFVLG9CQUFvQjtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxLQUFLLEtBQUssV0FBVyxnQ0FBZ0MsdUJBQXVCLGtCQUFrQixnREFBZ0Q7QUFDbEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUssS0FBSyxXQUFXLGdDQUFnQyx1QkFBdUIsa0JBQWtCLGdEQUFnRDtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssbUJBQW1CLE1BQU0sVUFBVSxhQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxLQUFLLEtBQUssV0FBVyxtQ0FBbUMsa0JBQWtCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxtR0FBbUcsc0RBQXNEO0FBQzVNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEVBQUUsT0FBTyxLQUFLO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFLE9BQU8sS0FBSyxHQUFHLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9kZWZpbml0aW9ucy91dGlscy5qcz85ZDljIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5WSVNJVE9SX0tFWVMgPSBleHBvcnRzLk5PREVfUEFSRU5UX1ZBTElEQVRJT05TID0gZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IGV4cG9ydHMuRkxJUFBFRF9BTElBU19LRVlTID0gZXhwb3J0cy5ERVBSRUNBVEVEX0tFWVMgPSBleHBvcnRzLkJVSUxERVJfS0VZUyA9IGV4cG9ydHMuQUxJQVNfS0VZUyA9IHZvaWQgMDtcbmV4cG9ydHMuYXJyYXlPZiA9IGFycmF5T2Y7XG5leHBvcnRzLmFycmF5T2ZUeXBlID0gYXJyYXlPZlR5cGU7XG5leHBvcnRzLmFzc2VydEVhY2ggPSBhc3NlcnRFYWNoO1xuZXhwb3J0cy5hc3NlcnROb2RlT3JWYWx1ZVR5cGUgPSBhc3NlcnROb2RlT3JWYWx1ZVR5cGU7XG5leHBvcnRzLmFzc2VydE5vZGVUeXBlID0gYXNzZXJ0Tm9kZVR5cGU7XG5leHBvcnRzLmFzc2VydE9uZU9mID0gYXNzZXJ0T25lT2Y7XG5leHBvcnRzLmFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydCA9IGFzc2VydE9wdGlvbmFsQ2hhaW5TdGFydDtcbmV4cG9ydHMuYXNzZXJ0U2hhcGUgPSBhc3NlcnRTaGFwZTtcbmV4cG9ydHMuYXNzZXJ0VmFsdWVUeXBlID0gYXNzZXJ0VmFsdWVUeXBlO1xuZXhwb3J0cy5jaGFpbiA9IGNoYWluO1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVmaW5lVHlwZTtcbmV4cG9ydHMuZGVmaW5lQWxpYXNlZFR5cGUgPSBkZWZpbmVBbGlhc2VkVHlwZTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmV4cG9ydHMudmFsaWRhdGVBcnJheU9mVHlwZSA9IHZhbGlkYXRlQXJyYXlPZlR5cGU7XG5leHBvcnRzLnZhbGlkYXRlT3B0aW9uYWwgPSB2YWxpZGF0ZU9wdGlvbmFsO1xuZXhwb3J0cy52YWxpZGF0ZU9wdGlvbmFsVHlwZSA9IHZhbGlkYXRlT3B0aW9uYWxUeXBlO1xuZXhwb3J0cy52YWxpZGF0ZVR5cGUgPSB2YWxpZGF0ZVR5cGU7XG52YXIgX2lzID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvaXMuanNcIik7XG52YXIgX3ZhbGlkYXRlID0gcmVxdWlyZShcIi4uL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanNcIik7XG5jb25zdCBWSVNJVE9SX0tFWVMgPSBleHBvcnRzLlZJU0lUT1JfS0VZUyA9IHt9O1xuY29uc3QgQUxJQVNfS0VZUyA9IGV4cG9ydHMuQUxJQVNfS0VZUyA9IHt9O1xuY29uc3QgRkxJUFBFRF9BTElBU19LRVlTID0gZXhwb3J0cy5GTElQUEVEX0FMSUFTX0tFWVMgPSB7fTtcbmNvbnN0IE5PREVfRklFTERTID0gZXhwb3J0cy5OT0RFX0ZJRUxEUyA9IHt9O1xuY29uc3QgQlVJTERFUl9LRVlTID0gZXhwb3J0cy5CVUlMREVSX0tFWVMgPSB7fTtcbmNvbnN0IERFUFJFQ0FURURfS0VZUyA9IGV4cG9ydHMuREVQUkVDQVRFRF9LRVlTID0ge307XG5jb25zdCBOT0RFX1BBUkVOVF9WQUxJREFUSU9OUyA9IGV4cG9ydHMuTk9ERV9QQVJFTlRfVkFMSURBVElPTlMgPSB7fTtcbmZ1bmN0aW9uIGdldFR5cGUodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKC4uLnR5cGVOYW1lcykge1xuICByZXR1cm4gdmFsaWRhdGUoYXNzZXJ0Tm9kZVR5cGUoLi4udHlwZU5hbWVzKSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbmFsKHZhbGlkYXRlKSB7XG4gIHJldHVybiB7XG4gICAgdmFsaWRhdGUsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uYWxUeXBlKC4uLnR5cGVOYW1lcykge1xuICByZXR1cm4ge1xuICAgIHZhbGlkYXRlOiBhc3NlcnROb2RlVHlwZSguLi50eXBlTmFtZXMpLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH07XG59XG5mdW5jdGlvbiBhcnJheU9mKGVsZW1lbnRUeXBlKSB7XG4gIHJldHVybiBjaGFpbihhc3NlcnRWYWx1ZVR5cGUoXCJhcnJheVwiKSwgYXNzZXJ0RWFjaChlbGVtZW50VHlwZSkpO1xufVxuZnVuY3Rpb24gYXJyYXlPZlR5cGUoLi4udHlwZU5hbWVzKSB7XG4gIHJldHVybiBhcnJheU9mKGFzc2VydE5vZGVUeXBlKC4uLnR5cGVOYW1lcykpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcnJheU9mVHlwZSguLi50eXBlTmFtZXMpIHtcbiAgcmV0dXJuIHZhbGlkYXRlKGFycmF5T2ZUeXBlKC4uLnR5cGVOYW1lcykpO1xufVxuZnVuY3Rpb24gYXNzZXJ0RWFjaChjYWxsYmFjaykge1xuICBjb25zdCBjaGlsZFZhbGlkYXRvciA9IHByb2Nlc3MuZW52LkJBQkVMX1RZUEVTXzhfQlJFQUtJTkcgPyBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCA6ICgpID0+IHt9O1xuICBmdW5jdGlvbiB2YWxpZGF0b3Iobm9kZSwga2V5LCB2YWwpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsKSkgcmV0dXJuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJrZXkgPSBgJHtrZXl9WyR7aX1dYDtcbiAgICAgIGNvbnN0IHYgPSB2YWxbaV07XG4gICAgICBjYWxsYmFjayhub2RlLCBzdWJrZXksIHYpO1xuICAgICAgY2hpbGRWYWxpZGF0b3Iobm9kZSwgc3Via2V5LCB2KTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdG9yLmVhY2ggPSBjYWxsYmFjaztcbiAgcmV0dXJuIHZhbGlkYXRvcjtcbn1cbmZ1bmN0aW9uIGFzc2VydE9uZU9mKC4uLnZhbHVlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBleHBlY3RlZCB2YWx1ZSB0byBiZSBvbmUgb2YgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZXMpfSBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUub25lT2YgPSB2YWx1ZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vZGVUeXBlKC4uLnR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIHR5cGVzKSB7XG4gICAgICBpZiAoKDAsIF9pcy5kZWZhdWx0KSh0eXBlLCB2YWwpKSB7XG4gICAgICAgICgwLCBfdmFsaWRhdGUudmFsaWRhdGVDaGlsZCkobm9kZSwga2V5LCB2YWwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFByb3BlcnR5ICR7a2V5fSBvZiAke25vZGUudHlwZX0gZXhwZWN0ZWQgbm9kZSB0byBiZSBvZiBhIHR5cGUgJHtKU09OLnN0cmluZ2lmeSh0eXBlcyl9IGJ1dCBpbnN0ZWFkIGdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLnR5cGUpfWApO1xuICB9XG4gIHZhbGlkYXRlLm9uZU9mTm9kZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE5vZGVPclZhbHVlVHlwZSguLi50eXBlcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShub2RlLCBrZXksIHZhbCkge1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgICAgaWYgKGdldFR5cGUodmFsKSA9PT0gdHlwZSB8fCAoMCwgX2lzLmRlZmF1bHQpKHR5cGUsIHZhbCkpIHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUNoaWxkKShub2RlLCBrZXksIHZhbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IG9mICR7bm9kZS50eXBlfSBleHBlY3RlZCBub2RlIHRvIGJlIG9mIGEgdHlwZSAke0pTT04uc3RyaW5naWZ5KHR5cGVzKX0gYnV0IGluc3RlYWQgZ290ICR7SlNPTi5zdHJpbmdpZnkodmFsID09IG51bGwgPyB2b2lkIDAgOiB2YWwudHlwZSl9YCk7XG4gIH1cbiAgdmFsaWRhdGUub25lT2ZOb2RlT3JWYWx1ZVR5cGVzID0gdHlwZXM7XG4gIHJldHVybiB2YWxpZGF0ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydFZhbHVlVHlwZSh0eXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gICAgY29uc3QgdmFsaWQgPSBnZXRUeXBlKHZhbCkgPT09IHR5cGU7XG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IGV4cGVjdGVkIHR5cGUgb2YgJHt0eXBlfSBidXQgZ290ICR7Z2V0VHlwZSh2YWwpfWApO1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZS50eXBlID0gdHlwZTtcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2hhcGUoc2hhcGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUobm9kZSwga2V5LCB2YWwpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKHNoYXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKDAsIF92YWxpZGF0ZS52YWxpZGF0ZUZpZWxkKShub2RlLCBwcm9wZXJ0eSwgdmFsW3Byb3BlcnR5XSwgc2hhcGVbcHJvcGVydHldKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgUHJvcGVydHkgJHtrZXl9IG9mICR7bm9kZS50eXBlfSBleHBlY3RlZCB0byBoYXZlIHRoZSBmb2xsb3dpbmc6XFxuJHtlcnJvcnMuam9pbihcIlxcblwiKX1gKTtcbiAgICB9XG4gIH1cbiAgdmFsaWRhdGUuc2hhcGVPZiA9IHNoYXBlO1xuICByZXR1cm4gdmFsaWRhdGU7XG59XG5mdW5jdGlvbiBhc3NlcnRPcHRpb25hbENoYWluU3RhcnQoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUpIHtcbiAgICB2YXIgX2N1cnJlbnQ7XG4gICAgbGV0IGN1cnJlbnQgPSBub2RlO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBjdXJyZW50O1xuICAgICAgaWYgKHR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChjdXJyZW50Lm9wdGlvbmFsKSByZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmNhbGxlZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgICBpZiAoY3VycmVudC5vcHRpb25hbCkgcmV0dXJuO1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vYmplY3Q7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vbi1vcHRpb25hbCAke25vZGUudHlwZX0gbXVzdCBjaGFpbiBmcm9tIGFuIG9wdGlvbmFsIE9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiBvciBPcHRpb25hbENhbGxFeHByZXNzaW9uLiBGb3VuZCBjaGFpbiBmcm9tICR7KF9jdXJyZW50ID0gY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jdXJyZW50LnR5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuZnVuY3Rpb24gY2hhaW4oLi4uZm5zKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKC4uLmFyZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIGZucykge1xuICAgICAgZm4oLi4uYXJncyk7XG4gICAgfVxuICB9XG4gIHZhbGlkYXRlLmNoYWluT2YgPSBmbnM7XG4gIGlmIChmbnMubGVuZ3RoID49IDIgJiYgXCJ0eXBlXCIgaW4gZm5zWzBdICYmIGZuc1swXS50eXBlID09PSBcImFycmF5XCIgJiYgIShcImVhY2hcIiBpbiBmbnNbMV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBbiBhc3NlcnRWYWx1ZVR5cGUoXCJhcnJheVwiKSB2YWxpZGF0b3IgY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYW4gYXNzZXJ0RWFjaCguLi4pIHZhbGlkYXRvci5gKTtcbiAgfVxuICByZXR1cm4gdmFsaWRhdGU7XG59XG5jb25zdCB2YWxpZFR5cGVPcHRzID0gbmV3IFNldChbXCJhbGlhc2VzXCIsIFwiYnVpbGRlclwiLCBcImRlcHJlY2F0ZWRBbGlhc1wiLCBcImZpZWxkc1wiLCBcImluaGVyaXRzXCIsIFwidmlzaXRvclwiLCBcInZhbGlkYXRlXCJdKTtcbmNvbnN0IHZhbGlkRmllbGRLZXlzID0gbmV3IFNldChbXCJkZWZhdWx0XCIsIFwib3B0aW9uYWxcIiwgXCJkZXByZWNhdGVkXCIsIFwidmFsaWRhdGVcIl0pO1xuY29uc3Qgc3RvcmUgPSB7fTtcbmZ1bmN0aW9uIGRlZmluZUFsaWFzZWRUeXBlKC4uLmFsaWFzZXMpIHtcbiAgcmV0dXJuICh0eXBlLCBvcHRzID0ge30pID0+IHtcbiAgICBsZXQgZGVmaW5lZCA9IG9wdHMuYWxpYXNlcztcbiAgICBpZiAoIWRlZmluZWQpIHtcbiAgICAgIHZhciBfc3RvcmUkb3B0cyRpbmhlcml0cyQsIF9kZWZpbmVkO1xuICAgICAgaWYgKG9wdHMuaW5oZXJpdHMpIGRlZmluZWQgPSAoX3N0b3JlJG9wdHMkaW5oZXJpdHMkID0gc3RvcmVbb3B0cy5pbmhlcml0c10uYWxpYXNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdG9yZSRvcHRzJGluaGVyaXRzJC5zbGljZSgpO1xuICAgICAgKF9kZWZpbmVkID0gZGVmaW5lZCkgIT0gbnVsbCA/IF9kZWZpbmVkIDogZGVmaW5lZCA9IFtdO1xuICAgICAgb3B0cy5hbGlhc2VzID0gZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYWRkaXRpb25hbCA9IGFsaWFzZXMuZmlsdGVyKGEgPT4gIWRlZmluZWQuaW5jbHVkZXMoYSkpO1xuICAgIGRlZmluZWQudW5zaGlmdCguLi5hZGRpdGlvbmFsKTtcbiAgICBkZWZpbmVUeXBlKHR5cGUsIG9wdHMpO1xuICB9O1xufVxuZnVuY3Rpb24gZGVmaW5lVHlwZSh0eXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgaW5oZXJpdHMgPSBvcHRzLmluaGVyaXRzICYmIHN0b3JlW29wdHMuaW5oZXJpdHNdIHx8IHt9O1xuICBsZXQgZmllbGRzID0gb3B0cy5maWVsZHM7XG4gIGlmICghZmllbGRzKSB7XG4gICAgZmllbGRzID0ge307XG4gICAgaWYgKGluaGVyaXRzLmZpZWxkcykge1xuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGluaGVyaXRzLmZpZWxkcyk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gaW5oZXJpdHMuZmllbGRzW2tleV07XG4gICAgICAgIGNvbnN0IGRlZiA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlZikgPyBkZWYubGVuZ3RoID4gMCA6IGRlZiAmJiB0eXBlb2YgZGVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmllbGQgZGVmYXVsdHMgY2FuIG9ubHkgYmUgcHJpbWl0aXZlcyBvciBlbXB0eSBhcnJheXMgY3VycmVudGx5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkc1trZXldID0ge1xuICAgICAgICAgIGRlZmF1bHQ6IEFycmF5LmlzQXJyYXkoZGVmKSA/IFtdIDogZGVmLFxuICAgICAgICAgIG9wdGlvbmFsOiBmaWVsZC5vcHRpb25hbCxcbiAgICAgICAgICBkZXByZWNhdGVkOiBmaWVsZC5kZXByZWNhdGVkLFxuICAgICAgICAgIHZhbGlkYXRlOiBmaWVsZC52YWxpZGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCB2aXNpdG9yID0gb3B0cy52aXNpdG9yIHx8IGluaGVyaXRzLnZpc2l0b3IgfHwgW107XG4gIGNvbnN0IGFsaWFzZXMgPSBvcHRzLmFsaWFzZXMgfHwgaW5oZXJpdHMuYWxpYXNlcyB8fCBbXTtcbiAgY29uc3QgYnVpbGRlciA9IG9wdHMuYnVpbGRlciB8fCBpbmhlcml0cy5idWlsZGVyIHx8IG9wdHMudmlzaXRvciB8fCBbXTtcbiAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKG9wdHMpKSB7XG4gICAgaWYgKCF2YWxpZFR5cGVPcHRzLmhhcyhrKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHR5cGUgb3B0aW9uIFwiJHtrfVwiIG9uICR7dHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdHMuZGVwcmVjYXRlZEFsaWFzKSB7XG4gICAgREVQUkVDQVRFRF9LRVlTW29wdHMuZGVwcmVjYXRlZEFsaWFzXSA9IHR5cGU7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgdmlzaXRvci5jb25jYXQoYnVpbGRlcikpIHtcbiAgICBmaWVsZHNba2V5XSA9IGZpZWxkc1trZXldIHx8IHt9O1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1trZXldO1xuICAgIGlmIChmaWVsZC5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgIWJ1aWxkZXIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgZmllbGQub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmllbGQuZGVmYXVsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWVsZC5kZWZhdWx0ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCFmaWVsZC52YWxpZGF0ZSAmJiBmaWVsZC5kZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgIGZpZWxkLnZhbGlkYXRlID0gYXNzZXJ0VmFsdWVUeXBlKGdldFR5cGUoZmllbGQuZGVmYXVsdCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGsgb2YgT2JqZWN0LmtleXMoZmllbGQpKSB7XG4gICAgICBpZiAoIXZhbGlkRmllbGRLZXlzLmhhcyhrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmllbGQga2V5IFwiJHtrfVwiIG9uICR7dHlwZX0uJHtrZXl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFZJU0lUT1JfS0VZU1t0eXBlXSA9IG9wdHMudmlzaXRvciA9IHZpc2l0b3I7XG4gIEJVSUxERVJfS0VZU1t0eXBlXSA9IG9wdHMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gIE5PREVfRklFTERTW3R5cGVdID0gb3B0cy5maWVsZHMgPSBmaWVsZHM7XG4gIEFMSUFTX0tFWVNbdHlwZV0gPSBvcHRzLmFsaWFzZXMgPSBhbGlhc2VzO1xuICBhbGlhc2VzLmZvckVhY2goYWxpYXMgPT4ge1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10gPSBGTElQUEVEX0FMSUFTX0tFWVNbYWxpYXNdIHx8IFtdO1xuICAgIEZMSVBQRURfQUxJQVNfS0VZU1thbGlhc10ucHVzaCh0eXBlKTtcbiAgfSk7XG4gIGlmIChvcHRzLnZhbGlkYXRlKSB7XG4gICAgTk9ERV9QQVJFTlRfVkFMSURBVElPTlNbdHlwZV0gPSBvcHRzLnZhbGlkYXRlO1xuICB9XG4gIHN0b3JlW3R5cGVdID0gb3B0cztcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///77596\n')},2352:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nvar _exportNames = {\n  react: true,\n  assertNode: true,\n  createTypeAnnotationBasedOnTypeof: true,\n  createUnionTypeAnnotation: true,\n  createFlowUnionType: true,\n  createTSUnionType: true,\n  cloneNode: true,\n  clone: true,\n  cloneDeep: true,\n  cloneDeepWithoutLoc: true,\n  cloneWithoutLoc: true,\n  addComment: true,\n  addComments: true,\n  inheritInnerComments: true,\n  inheritLeadingComments: true,\n  inheritsComments: true,\n  inheritTrailingComments: true,\n  removeComments: true,\n  ensureBlock: true,\n  toBindingIdentifierName: true,\n  toBlock: true,\n  toComputedKey: true,\n  toExpression: true,\n  toIdentifier: true,\n  toKeyAlias: true,\n  toStatement: true,\n  valueToNode: true,\n  appendToMemberExpression: true,\n  inherits: true,\n  prependToMemberExpression: true,\n  removeProperties: true,\n  removePropertiesDeep: true,\n  removeTypeDuplicates: true,\n  getAssignmentIdentifiers: true,\n  getBindingIdentifiers: true,\n  getOuterBindingIdentifiers: true,\n  getFunctionName: true,\n  traverse: true,\n  traverseFast: true,\n  shallowEqual: true,\n  is: true,\n  isBinding: true,\n  isBlockScoped: true,\n  isImmutable: true,\n  isLet: true,\n  isNode: true,\n  isNodesEquivalent: true,\n  isPlaceholderType: true,\n  isReferenced: true,\n  isScope: true,\n  isSpecifierDefault: true,\n  isType: true,\n  isValidES3Identifier: true,\n  isValidIdentifier: true,\n  isVar: true,\n  matchesPattern: true,\n  validate: true,\n  buildMatchMemberExpression: true,\n  __internal__deprecationWarning: true\n};\nObject.defineProperty(exports, "__internal__deprecationWarning", ({\n  enumerable: true,\n  get: function () {\n    return _deprecationWarning.default;\n  }\n}));\nObject.defineProperty(exports, "addComment", ({\n  enumerable: true,\n  get: function () {\n    return _addComment.default;\n  }\n}));\nObject.defineProperty(exports, "addComments", ({\n  enumerable: true,\n  get: function () {\n    return _addComments.default;\n  }\n}));\nObject.defineProperty(exports, "appendToMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _appendToMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, "assertNode", ({\n  enumerable: true,\n  get: function () {\n    return _assertNode.default;\n  }\n}));\nObject.defineProperty(exports, "buildMatchMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _buildMatchMemberExpression.default;\n  }\n}));\nObject.defineProperty(exports, "clone", ({\n  enumerable: true,\n  get: function () {\n    return _clone.default;\n  }\n}));\nObject.defineProperty(exports, "cloneDeep", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeep.default;\n  }\n}));\nObject.defineProperty(exports, "cloneDeepWithoutLoc", ({\n  enumerable: true,\n  get: function () {\n    return _cloneDeepWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, "cloneNode", ({\n  enumerable: true,\n  get: function () {\n    return _cloneNode.default;\n  }\n}));\nObject.defineProperty(exports, "cloneWithoutLoc", ({\n  enumerable: true,\n  get: function () {\n    return _cloneWithoutLoc.default;\n  }\n}));\nObject.defineProperty(exports, "createFlowUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "createTSUnionType", ({\n  enumerable: true,\n  get: function () {\n    return _createTSUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "createTypeAnnotationBasedOnTypeof", ({\n  enumerable: true,\n  get: function () {\n    return _createTypeAnnotationBasedOnTypeof.default;\n  }\n}));\nObject.defineProperty(exports, "createUnionTypeAnnotation", ({\n  enumerable: true,\n  get: function () {\n    return _createFlowUnionType.default;\n  }\n}));\nObject.defineProperty(exports, "ensureBlock", ({\n  enumerable: true,\n  get: function () {\n    return _ensureBlock.default;\n  }\n}));\nObject.defineProperty(exports, "getAssignmentIdentifiers", ({\n  enumerable: true,\n  get: function () {\n    return _getAssignmentIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, "getBindingIdentifiers", ({\n  enumerable: true,\n  get: function () {\n    return _getBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, "getFunctionName", ({\n  enumerable: true,\n  get: function () {\n    return _getFunctionName.default;\n  }\n}));\nObject.defineProperty(exports, "getOuterBindingIdentifiers", ({\n  enumerable: true,\n  get: function () {\n    return _getOuterBindingIdentifiers.default;\n  }\n}));\nObject.defineProperty(exports, "inheritInnerComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritInnerComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritLeadingComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritLeadingComments.default;\n  }\n}));\nObject.defineProperty(exports, "inheritTrailingComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritTrailingComments.default;\n  }\n}));\nObject.defineProperty(exports, "inherits", ({\n  enumerable: true,\n  get: function () {\n    return _inherits.default;\n  }\n}));\nObject.defineProperty(exports, "inheritsComments", ({\n  enumerable: true,\n  get: function () {\n    return _inheritsComments.default;\n  }\n}));\nObject.defineProperty(exports, "is", ({\n  enumerable: true,\n  get: function () {\n    return _is.default;\n  }\n}));\nObject.defineProperty(exports, "isBinding", ({\n  enumerable: true,\n  get: function () {\n    return _isBinding.default;\n  }\n}));\nObject.defineProperty(exports, "isBlockScoped", ({\n  enumerable: true,\n  get: function () {\n    return _isBlockScoped.default;\n  }\n}));\nObject.defineProperty(exports, "isImmutable", ({\n  enumerable: true,\n  get: function () {\n    return _isImmutable.default;\n  }\n}));\nObject.defineProperty(exports, "isLet", ({\n  enumerable: true,\n  get: function () {\n    return _isLet.default;\n  }\n}));\nObject.defineProperty(exports, "isNode", ({\n  enumerable: true,\n  get: function () {\n    return _isNode.default;\n  }\n}));\nObject.defineProperty(exports, "isNodesEquivalent", ({\n  enumerable: true,\n  get: function () {\n    return _isNodesEquivalent.default;\n  }\n}));\nObject.defineProperty(exports, "isPlaceholderType", ({\n  enumerable: true,\n  get: function () {\n    return _isPlaceholderType.default;\n  }\n}));\nObject.defineProperty(exports, "isReferenced", ({\n  enumerable: true,\n  get: function () {\n    return _isReferenced.default;\n  }\n}));\nObject.defineProperty(exports, "isScope", ({\n  enumerable: true,\n  get: function () {\n    return _isScope.default;\n  }\n}));\nObject.defineProperty(exports, "isSpecifierDefault", ({\n  enumerable: true,\n  get: function () {\n    return _isSpecifierDefault.default;\n  }\n}));\nObject.defineProperty(exports, "isType", ({\n  enumerable: true,\n  get: function () {\n    return _isType.default;\n  }\n}));\nObject.defineProperty(exports, "isValidES3Identifier", ({\n  enumerable: true,\n  get: function () {\n    return _isValidES3Identifier.default;\n  }\n}));\nObject.defineProperty(exports, "isValidIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _isValidIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, "isVar", ({\n  enumerable: true,\n  get: function () {\n    return _isVar.default;\n  }\n}));\nObject.defineProperty(exports, "matchesPattern", ({\n  enumerable: true,\n  get: function () {\n    return _matchesPattern.default;\n  }\n}));\nObject.defineProperty(exports, "prependToMemberExpression", ({\n  enumerable: true,\n  get: function () {\n    return _prependToMemberExpression.default;\n  }\n}));\nexports.react = void 0;\nObject.defineProperty(exports, "removeComments", ({\n  enumerable: true,\n  get: function () {\n    return _removeComments.default;\n  }\n}));\nObject.defineProperty(exports, "removeProperties", ({\n  enumerable: true,\n  get: function () {\n    return _removeProperties.default;\n  }\n}));\nObject.defineProperty(exports, "removePropertiesDeep", ({\n  enumerable: true,\n  get: function () {\n    return _removePropertiesDeep.default;\n  }\n}));\nObject.defineProperty(exports, "removeTypeDuplicates", ({\n  enumerable: true,\n  get: function () {\n    return _removeTypeDuplicates.default;\n  }\n}));\nObject.defineProperty(exports, "shallowEqual", ({\n  enumerable: true,\n  get: function () {\n    return _shallowEqual.default;\n  }\n}));\nObject.defineProperty(exports, "toBindingIdentifierName", ({\n  enumerable: true,\n  get: function () {\n    return _toBindingIdentifierName.default;\n  }\n}));\nObject.defineProperty(exports, "toBlock", ({\n  enumerable: true,\n  get: function () {\n    return _toBlock.default;\n  }\n}));\nObject.defineProperty(exports, "toComputedKey", ({\n  enumerable: true,\n  get: function () {\n    return _toComputedKey.default;\n  }\n}));\nObject.defineProperty(exports, "toExpression", ({\n  enumerable: true,\n  get: function () {\n    return _toExpression.default;\n  }\n}));\nObject.defineProperty(exports, "toIdentifier", ({\n  enumerable: true,\n  get: function () {\n    return _toIdentifier.default;\n  }\n}));\nObject.defineProperty(exports, "toKeyAlias", ({\n  enumerable: true,\n  get: function () {\n    return _toKeyAlias.default;\n  }\n}));\nObject.defineProperty(exports, "toStatement", ({\n  enumerable: true,\n  get: function () {\n    return _toStatement.default;\n  }\n}));\nObject.defineProperty(exports, "traverse", ({\n  enumerable: true,\n  get: function () {\n    return _traverse.default;\n  }\n}));\nObject.defineProperty(exports, "traverseFast", ({\n  enumerable: true,\n  get: function () {\n    return _traverseFast.default;\n  }\n}));\nObject.defineProperty(exports, "validate", ({\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n}));\nObject.defineProperty(exports, "valueToNode", ({\n  enumerable: true,\n  get: function () {\n    return _valueToNode.default;\n  }\n}));\nvar _isReactComponent = __webpack_require__(45682);\nvar _isCompatTag = __webpack_require__(85004);\nvar _buildChildren = __webpack_require__(49018);\nvar _assertNode = __webpack_require__(34568);\nvar _index = __webpack_require__(72246);\nObject.keys(_index).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index[key];\n    }\n  });\n});\nvar _createTypeAnnotationBasedOnTypeof = __webpack_require__(95958);\nvar _createFlowUnionType = __webpack_require__(31009);\nvar _createTSUnionType = __webpack_require__(46049);\nvar _index2 = __webpack_require__(48079);\nObject.keys(_index2).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index2[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index2[key];\n    }\n  });\n});\nvar _uppercase = __webpack_require__(76779);\nObject.keys(_uppercase).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _uppercase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _uppercase[key];\n    }\n  });\n});\nvar _productions = __webpack_require__(10985);\nObject.keys(_productions).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _productions[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _productions[key];\n    }\n  });\n});\nvar _cloneNode = __webpack_require__(85279);\nvar _clone = __webpack_require__(2107);\nvar _cloneDeep = __webpack_require__(10245);\nvar _cloneDeepWithoutLoc = __webpack_require__(35299);\nvar _cloneWithoutLoc = __webpack_require__(62425);\nvar _addComment = __webpack_require__(76211);\nvar _addComments = __webpack_require__(52598);\nvar _inheritInnerComments = __webpack_require__(7932);\nvar _inheritLeadingComments = __webpack_require__(55766);\nvar _inheritsComments = __webpack_require__(18125);\nvar _inheritTrailingComments = __webpack_require__(15586);\nvar _removeComments = __webpack_require__(93437);\nvar _index3 = __webpack_require__(67980);\nObject.keys(_index3).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index3[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index3[key];\n    }\n  });\n});\nvar _index4 = __webpack_require__(93422);\nObject.keys(_index4).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index4[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index4[key];\n    }\n  });\n});\nvar _ensureBlock = __webpack_require__(57931);\nvar _toBindingIdentifierName = __webpack_require__(82234);\nvar _toBlock = __webpack_require__(25010);\nvar _toComputedKey = __webpack_require__(33017);\nvar _toExpression = __webpack_require__(26133);\nvar _toIdentifier = __webpack_require__(36744);\nvar _toKeyAlias = __webpack_require__(72402);\nvar _toStatement = __webpack_require__(99198);\nvar _valueToNode = __webpack_require__(44544);\nvar _index5 = __webpack_require__(39793);\nObject.keys(_index5).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index5[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index5[key];\n    }\n  });\n});\nvar _appendToMemberExpression = __webpack_require__(74001);\nvar _inherits = __webpack_require__(89564);\nvar _prependToMemberExpression = __webpack_require__(96219);\nvar _removeProperties = __webpack_require__(85333);\nvar _removePropertiesDeep = __webpack_require__(87639);\nvar _removeTypeDuplicates = __webpack_require__(95237);\nvar _getAssignmentIdentifiers = __webpack_require__(1343);\nvar _getBindingIdentifiers = __webpack_require__(70329);\nvar _getOuterBindingIdentifiers = __webpack_require__(49420);\nvar _getFunctionName = __webpack_require__(5109);\nvar _traverse = __webpack_require__(53357);\nObject.keys(_traverse).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _traverse[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _traverse[key];\n    }\n  });\n});\nvar _traverseFast = __webpack_require__(58943);\nvar _shallowEqual = __webpack_require__(96616);\nvar _is = __webpack_require__(93828);\nvar _isBinding = __webpack_require__(2687);\nvar _isBlockScoped = __webpack_require__(29127);\nvar _isImmutable = __webpack_require__(19722);\nvar _isLet = __webpack_require__(63847);\nvar _isNode = __webpack_require__(73908);\nvar _isNodesEquivalent = __webpack_require__(7003);\nvar _isPlaceholderType = __webpack_require__(53571);\nvar _isReferenced = __webpack_require__(37591);\nvar _isScope = __webpack_require__(89246);\nvar _isSpecifierDefault = __webpack_require__(22457);\nvar _isType = __webpack_require__(94460);\nvar _isValidES3Identifier = __webpack_require__(91384);\nvar _isValidIdentifier = __webpack_require__(60983);\nvar _isVar = __webpack_require__(70499);\nvar _matchesPattern = __webpack_require__(94965);\nvar _validate = __webpack_require__(57446);\nvar _buildMatchMemberExpression = __webpack_require__(3937);\nvar _index6 = __webpack_require__(98960);\nObject.keys(_index6).forEach(function (key) {\n  if (key === "default" || key === "__esModule") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _index6[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _index6[key];\n    }\n  });\n});\nvar _deprecationWarning = __webpack_require__(63762);\nconst react = exports.react = {\n  isReactComponent: _isReactComponent.default,\n  isCompatTag: _isCompatTag.default,\n  buildChildren: _buildChildren.default\n};\n{\n  exports.toSequenceExpression = __webpack_require__(90640)["default"];\n}\nif (process.env.BABEL_TYPES_8_BREAKING) {\n  console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHVEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFFQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZEQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDREQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG1EQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDhEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDRDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLG9EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHNDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGlEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLCtDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGdEQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHNEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDBDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHdEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHFEQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLHlDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGtEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLDZEQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQztBQUNGLGFBQWE7QUFDYixrREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixvREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixpREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRixnREFBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiw0Q0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRiwrQ0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7QUFDRix3QkFBd0IsbUJBQU8sQ0FBQyxLQUF3QztBQUN4RSxtQkFBbUIsbUJBQU8sQ0FBQyxLQUFtQztBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQyxLQUFtQztBQUNoRSxrQkFBa0IsbUJBQU8sQ0FBQyxLQUF5QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsS0FBOEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCx5Q0FBeUMsbUJBQU8sQ0FBQyxLQUFzRDtBQUN2RywyQkFBMkIsbUJBQU8sQ0FBQyxLQUF3QztBQUMzRSx5QkFBeUIsbUJBQU8sQ0FBQyxLQUE0QztBQUM3RSxjQUFjLG1CQUFPLENBQUMsS0FBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxpQkFBaUIsbUJBQU8sQ0FBQyxLQUFtQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLEtBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsaUJBQWlCLG1CQUFPLENBQUMsS0FBc0I7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLElBQWtCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLEtBQXNCO0FBQy9DLDJCQUEyQixtQkFBTyxDQUFDLEtBQWdDO0FBQ25FLHVCQUF1QixtQkFBTyxDQUFDLEtBQTRCO0FBQzNELGtCQUFrQixtQkFBTyxDQUFDLEtBQTBCO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLEtBQTJCO0FBQ3RELDRCQUE0QixtQkFBTyxDQUFDLElBQW9DO0FBQ3hFLDhCQUE4QixtQkFBTyxDQUFDLEtBQXNDO0FBQzVFLHdCQUF3QixtQkFBTyxDQUFDLEtBQWdDO0FBQ2hFLCtCQUErQixtQkFBTyxDQUFDLEtBQXVDO0FBQzlFLHNCQUFzQixtQkFBTyxDQUFDLEtBQThCO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxLQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGNBQWMsbUJBQU8sQ0FBQyxLQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELG1CQUFtQixtQkFBTyxDQUFDLEtBQTZCO0FBQ3hELCtCQUErQixtQkFBTyxDQUFDLEtBQXlDO0FBQ2hGLGVBQWUsbUJBQU8sQ0FBQyxLQUF5QjtBQUNoRCxxQkFBcUIsbUJBQU8sQ0FBQyxLQUErQjtBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQyxLQUE4QjtBQUMxRCxvQkFBb0IsbUJBQU8sQ0FBQyxLQUE4QjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyxLQUE0QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxLQUE2QjtBQUN4RCxtQkFBbUIsbUJBQU8sQ0FBQyxLQUE2QjtBQUN4RCxjQUFjLG1CQUFPLENBQUMsS0FBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxnQ0FBZ0MsbUJBQU8sQ0FBQyxLQUE2QztBQUNyRixnQkFBZ0IsbUJBQU8sQ0FBQyxLQUE2QjtBQUNyRCxpQ0FBaUMsbUJBQU8sQ0FBQyxLQUE4QztBQUN2Rix3QkFBd0IsbUJBQU8sQ0FBQyxLQUFxQztBQUNyRSw0QkFBNEIsbUJBQU8sQ0FBQyxLQUF5QztBQUM3RSw0QkFBNEIsbUJBQU8sQ0FBQyxLQUE4QztBQUNsRixnQ0FBZ0MsbUJBQU8sQ0FBQyxJQUEwQztBQUNsRiw2QkFBNkIsbUJBQU8sQ0FBQyxLQUF1QztBQUM1RSxrQ0FBa0MsbUJBQU8sQ0FBQyxLQUE0QztBQUN0Rix1QkFBdUIsbUJBQU8sQ0FBQyxJQUFpQztBQUNoRSxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELG9CQUFvQixtQkFBTyxDQUFDLEtBQTRCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLEtBQXlCO0FBQ3JELFVBQVUsbUJBQU8sQ0FBQyxLQUFvQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyxJQUEyQjtBQUNwRCxxQkFBcUIsbUJBQU8sQ0FBQyxLQUErQjtBQUM1RCxtQkFBbUIsbUJBQU8sQ0FBQyxLQUE2QjtBQUN4RCxhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLEtBQXdCO0FBQzlDLHlCQUF5QixtQkFBTyxDQUFDLElBQW1DO0FBQ3BFLHlCQUF5QixtQkFBTyxDQUFDLEtBQW1DO0FBQ3BFLG9CQUFvQixtQkFBTyxDQUFDLEtBQThCO0FBQzFELGVBQWUsbUJBQU8sQ0FBQyxLQUF5QjtBQUNoRCwwQkFBMEIsbUJBQU8sQ0FBQyxLQUFvQztBQUN0RSxjQUFjLG1CQUFPLENBQUMsS0FBd0I7QUFDOUMsNEJBQTRCLG1CQUFPLENBQUMsS0FBc0M7QUFDMUUseUJBQXlCLG1CQUFPLENBQUMsS0FBbUM7QUFDcEUsYUFBYSxtQkFBTyxDQUFDLEtBQXVCO0FBQzVDLHNCQUFzQixtQkFBTyxDQUFDLEtBQWdDO0FBQzlELGdCQUFnQixtQkFBTyxDQUFDLEtBQTBCO0FBQ2xELGtDQUFrQyxtQkFBTyxDQUFDLElBQTRDO0FBQ3RGLGNBQWMsbUJBQU8sQ0FBQyxLQUFpQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELDBCQUEwQixtQkFBTyxDQUFDLEtBQStCO0FBQ2pFLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxvRUFBc0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvaW5kZXguanM/NDRkNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbnZhciBfZXhwb3J0TmFtZXMgPSB7XG4gIHJlYWN0OiB0cnVlLFxuICBhc3NlcnROb2RlOiB0cnVlLFxuICBjcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2Y6IHRydWUsXG4gIGNyZWF0ZVVuaW9uVHlwZUFubm90YXRpb246IHRydWUsXG4gIGNyZWF0ZUZsb3dVbmlvblR5cGU6IHRydWUsXG4gIGNyZWF0ZVRTVW5pb25UeXBlOiB0cnVlLFxuICBjbG9uZU5vZGU6IHRydWUsXG4gIGNsb25lOiB0cnVlLFxuICBjbG9uZURlZXA6IHRydWUsXG4gIGNsb25lRGVlcFdpdGhvdXRMb2M6IHRydWUsXG4gIGNsb25lV2l0aG91dExvYzogdHJ1ZSxcbiAgYWRkQ29tbWVudDogdHJ1ZSxcbiAgYWRkQ29tbWVudHM6IHRydWUsXG4gIGluaGVyaXRJbm5lckNvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0TGVhZGluZ0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0c0NvbW1lbnRzOiB0cnVlLFxuICBpbmhlcml0VHJhaWxpbmdDb21tZW50czogdHJ1ZSxcbiAgcmVtb3ZlQ29tbWVudHM6IHRydWUsXG4gIGVuc3VyZUJsb2NrOiB0cnVlLFxuICB0b0JpbmRpbmdJZGVudGlmaWVyTmFtZTogdHJ1ZSxcbiAgdG9CbG9jazogdHJ1ZSxcbiAgdG9Db21wdXRlZEtleTogdHJ1ZSxcbiAgdG9FeHByZXNzaW9uOiB0cnVlLFxuICB0b0lkZW50aWZpZXI6IHRydWUsXG4gIHRvS2V5QWxpYXM6IHRydWUsXG4gIHRvU3RhdGVtZW50OiB0cnVlLFxuICB2YWx1ZVRvTm9kZTogdHJ1ZSxcbiAgYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uOiB0cnVlLFxuICBpbmhlcml0czogdHJ1ZSxcbiAgcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbjogdHJ1ZSxcbiAgcmVtb3ZlUHJvcGVydGllczogdHJ1ZSxcbiAgcmVtb3ZlUHJvcGVydGllc0RlZXA6IHRydWUsXG4gIHJlbW92ZVR5cGVEdXBsaWNhdGVzOiB0cnVlLFxuICBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnM6IHRydWUsXG4gIGdldEJpbmRpbmdJZGVudGlmaWVyczogdHJ1ZSxcbiAgZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnM6IHRydWUsXG4gIGdldEZ1bmN0aW9uTmFtZTogdHJ1ZSxcbiAgdHJhdmVyc2U6IHRydWUsXG4gIHRyYXZlcnNlRmFzdDogdHJ1ZSxcbiAgc2hhbGxvd0VxdWFsOiB0cnVlLFxuICBpczogdHJ1ZSxcbiAgaXNCaW5kaW5nOiB0cnVlLFxuICBpc0Jsb2NrU2NvcGVkOiB0cnVlLFxuICBpc0ltbXV0YWJsZTogdHJ1ZSxcbiAgaXNMZXQ6IHRydWUsXG4gIGlzTm9kZTogdHJ1ZSxcbiAgaXNOb2Rlc0VxdWl2YWxlbnQ6IHRydWUsXG4gIGlzUGxhY2Vob2xkZXJUeXBlOiB0cnVlLFxuICBpc1JlZmVyZW5jZWQ6IHRydWUsXG4gIGlzU2NvcGU6IHRydWUsXG4gIGlzU3BlY2lmaWVyRGVmYXVsdDogdHJ1ZSxcbiAgaXNUeXBlOiB0cnVlLFxuICBpc1ZhbGlkRVMzSWRlbnRpZmllcjogdHJ1ZSxcbiAgaXNWYWxpZElkZW50aWZpZXI6IHRydWUsXG4gIGlzVmFyOiB0cnVlLFxuICBtYXRjaGVzUGF0dGVybjogdHJ1ZSxcbiAgdmFsaWRhdGU6IHRydWUsXG4gIGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uOiB0cnVlLFxuICBfX2ludGVybmFsX19kZXByZWNhdGlvbldhcm5pbmc6IHRydWVcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2ludGVybmFsX19kZXByZWNhdGlvbldhcm5pbmdcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2RlcHJlY2F0aW9uV2FybmluZy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZENvbW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FkZENvbW1lbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYWRkQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhcHBlbmRUb01lbWJlckV4cHJlc3Npb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFzc2VydE5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fzc2VydE5vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZURlZXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lRGVlcC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lRGVlcFdpdGhvdXRMb2NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lRGVlcFdpdGhvdXRMb2MuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjbG9uZU5vZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Nsb25lTm9kZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNsb25lV2l0aG91dExvY1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY2xvbmVXaXRob3V0TG9jLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlRmxvd1VuaW9uVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlRmxvd1VuaW9uVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVRTVW5pb25UeXBlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUU1VuaW9uVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVR5cGVBbm5vdGF0aW9uQmFzZWRPblR5cGVvZlwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVW5pb25UeXBlQW5ub3RhdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfY3JlYXRlRmxvd1VuaW9uVHlwZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuc3VyZUJsb2NrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9lbnN1cmVCbG9jay5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEFzc2lnbm1lbnRJZGVudGlmaWVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZ2V0QXNzaWdubWVudElkZW50aWZpZXJzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QmluZGluZ0lkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGdW5jdGlvbk5hbWVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2dldEZ1bmN0aW9uTmFtZS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRPdXRlckJpbmRpbmdJZGVudGlmaWVycy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRJbm5lckNvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0SW5uZXJDb21tZW50cy5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImluaGVyaXRMZWFkaW5nQ29tbWVudHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2luaGVyaXRMZWFkaW5nQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0VHJhaWxpbmdDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaW5oZXJpdHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpbmhlcml0c0NvbW1lbnRzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pbmhlcml0c0NvbW1lbnRzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNCaW5kaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0JpbmRpbmcuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Jsb2NrU2NvcGVkXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc0Jsb2NrU2NvcGVkLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJbW11dGFibGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzSW1tdXRhYmxlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNMZXRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzTGV0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNOb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9pc05vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc05vZGVzRXF1aXZhbGVudFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNOb2Rlc0VxdWl2YWxlbnQuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BsYWNlaG9sZGVyVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNQbGFjZWhvbGRlclR5cGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1JlZmVyZW5jZWRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzUmVmZXJlbmNlZC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzU2NvcGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzU2NvcGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1NwZWNpZmllckRlZmF1bHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzU3BlY2lmaWVyRGVmYXVsdC5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNUeXBlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZEVTM0lkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFsaWRFUzNJZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZElkZW50aWZpZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFsaWRJZGVudGlmaWVyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2lzVmFyLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWF0Y2hlc1BhdHRlcm5cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX21hdGNoZXNQYXR0ZXJuLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcHJlcGVuZFRvTWVtYmVyRXhwcmVzc2lvbi5kZWZhdWx0O1xuICB9XG59KTtcbmV4cG9ydHMucmVhY3QgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVDb21tZW50c1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVtb3ZlQ29tbWVudHMuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVQcm9wZXJ0aWVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9yZW1vdmVQcm9wZXJ0aWVzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlUHJvcGVydGllc0RlZXBcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVByb3BlcnRpZXNEZWVwLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlVHlwZUR1cGxpY2F0ZXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlbW92ZVR5cGVEdXBsaWNhdGVzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhbGxvd0VxdWFsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zaGFsbG93RXF1YWwuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0JpbmRpbmdJZGVudGlmaWVyTmFtZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0Jsb2NrXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0Jsb2NrLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9Db21wdXRlZEtleVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9Db21wdXRlZEtleS5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvRXhwcmVzc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdG9FeHByZXNzaW9uLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9JZGVudGlmaWVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0lkZW50aWZpZXIuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0tleUFsaWFzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b0tleUFsaWFzLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9TdGF0ZW1lbnRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RvU3RhdGVtZW50LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhdmVyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RyYXZlcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhdmVyc2VGYXN0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90cmF2ZXJzZUZhc3QuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsaWRhdGUuZGVmYXVsdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWx1ZVRvTm9kZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdmFsdWVUb05vZGUuZGVmYXVsdDtcbiAgfVxufSk7XG52YXIgX2lzUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL3JlYWN0L2lzUmVhY3RDb21wb25lbnQuanNcIik7XG52YXIgX2lzQ29tcGF0VGFnID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qc1wiKTtcbnZhciBfYnVpbGRDaGlsZHJlbiA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL3JlYWN0L2J1aWxkQ2hpbGRyZW4uanNcIik7XG52YXIgX2Fzc2VydE5vZGUgPSByZXF1aXJlKFwiLi9hc3NlcnRzL2Fzc2VydE5vZGUuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vYXNzZXJ0cy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleFtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfY3JlYXRlVHlwZUFubm90YXRpb25CYXNlZE9uVHlwZW9mID0gcmVxdWlyZShcIi4vYnVpbGRlcnMvZmxvdy9jcmVhdGVUeXBlQW5ub3RhdGlvbkJhc2VkT25UeXBlb2YuanNcIik7XG52YXIgX2NyZWF0ZUZsb3dVbmlvblR5cGUgPSByZXF1aXJlKFwiLi9idWlsZGVycy9mbG93L2NyZWF0ZUZsb3dVbmlvblR5cGUuanNcIik7XG52YXIgX2NyZWF0ZVRTVW5pb25UeXBlID0gcmVxdWlyZShcIi4vYnVpbGRlcnMvdHlwZXNjcmlwdC9jcmVhdGVUU1VuaW9uVHlwZS5qc1wiKTtcbnZhciBfaW5kZXgyID0gcmVxdWlyZShcIi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4MikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4MltrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDJba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX3VwcGVyY2FzZSA9IHJlcXVpcmUoXCIuL2J1aWxkZXJzL2dlbmVyYXRlZC91cHBlcmNhc2UuanNcIik7XG5PYmplY3Qua2V5cyhfdXBwZXJjYXNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfdXBwZXJjYXNlW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3VwcGVyY2FzZVtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfcHJvZHVjdGlvbnMgPSByZXF1aXJlKFwiLi9idWlsZGVycy9wcm9kdWN0aW9ucy5qc1wiKTtcbk9iamVjdC5rZXlzKF9wcm9kdWN0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3Byb2R1Y3Rpb25zW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3Byb2R1Y3Rpb25zW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9jbG9uZU5vZGUgPSByZXF1aXJlKFwiLi9jbG9uZS9jbG9uZU5vZGUuanNcIik7XG52YXIgX2Nsb25lID0gcmVxdWlyZShcIi4vY2xvbmUvY2xvbmUuanNcIik7XG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lRGVlcC5qc1wiKTtcbnZhciBfY2xvbmVEZWVwV2l0aG91dExvYyA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lRGVlcFdpdGhvdXRMb2MuanNcIik7XG52YXIgX2Nsb25lV2l0aG91dExvYyA9IHJlcXVpcmUoXCIuL2Nsb25lL2Nsb25lV2l0aG91dExvYy5qc1wiKTtcbnZhciBfYWRkQ29tbWVudCA9IHJlcXVpcmUoXCIuL2NvbW1lbnRzL2FkZENvbW1lbnQuanNcIik7XG52YXIgX2FkZENvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvYWRkQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRJbm5lckNvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdElubmVyQ29tbWVudHMuanNcIik7XG52YXIgX2luaGVyaXRMZWFkaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0TGVhZGluZ0NvbW1lbnRzLmpzXCIpO1xudmFyIF9pbmhlcml0c0NvbW1lbnRzID0gcmVxdWlyZShcIi4vY29tbWVudHMvaW5oZXJpdHNDb21tZW50cy5qc1wiKTtcbnZhciBfaW5oZXJpdFRyYWlsaW5nQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9pbmhlcml0VHJhaWxpbmdDb21tZW50cy5qc1wiKTtcbnZhciBfcmVtb3ZlQ29tbWVudHMgPSByZXF1aXJlKFwiLi9jb21tZW50cy9yZW1vdmVDb21tZW50cy5qc1wiKTtcbnZhciBfaW5kZXgzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbk9iamVjdC5rZXlzKF9pbmRleDMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoX2V4cG9ydE5hbWVzLCBrZXkpKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9pbmRleDNba2V5XSkgcmV0dXJuO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfaW5kZXgzW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF9pbmRleDQgPSByZXF1aXJlKFwiLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg0KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg0W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NFtrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZW5zdXJlQmxvY2sgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL2Vuc3VyZUJsb2NrLmpzXCIpO1xudmFyIF90b0JpbmRpbmdJZGVudGlmaWVyTmFtZSA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9CaW5kaW5nSWRlbnRpZmllck5hbWUuanNcIik7XG52YXIgX3RvQmxvY2sgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQmxvY2suanNcIik7XG52YXIgX3RvQ29tcHV0ZWRLZXkgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvQ29tcHV0ZWRLZXkuanNcIik7XG52YXIgX3RvRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9FeHByZXNzaW9uLmpzXCIpO1xudmFyIF90b0lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvSWRlbnRpZmllci5qc1wiKTtcbnZhciBfdG9LZXlBbGlhcyA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdG9LZXlBbGlhcy5qc1wiKTtcbnZhciBfdG9TdGF0ZW1lbnQgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvU3RhdGVtZW50LmpzXCIpO1xudmFyIF92YWx1ZVRvTm9kZSA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlcnMvdmFsdWVUb05vZGUuanNcIik7XG52YXIgX2luZGV4NSA9IHJlcXVpcmUoXCIuL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuT2JqZWN0LmtleXMoX2luZGV4NSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2luZGV4NVtrZXldKSByZXR1cm47XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9pbmRleDVba2V5XTtcbiAgICB9XG4gIH0pO1xufSk7XG52YXIgX2FwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzXCIpO1xudmFyIF9pbmhlcml0cyA9IHJlcXVpcmUoXCIuL21vZGlmaWNhdGlvbnMvaW5oZXJpdHMuanNcIik7XG52YXIgX3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3ByZXBlbmRUb01lbWJlckV4cHJlc3Npb24uanNcIik7XG52YXIgX3JlbW92ZVByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXMuanNcIik7XG52YXIgX3JlbW92ZVByb3BlcnRpZXNEZWVwID0gcmVxdWlyZShcIi4vbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzRGVlcC5qc1wiKTtcbnZhciBfcmVtb3ZlVHlwZUR1cGxpY2F0ZXMgPSByZXF1aXJlKFwiLi9tb2RpZmljYXRpb25zL2Zsb3cvcmVtb3ZlVHlwZUR1cGxpY2F0ZXMuanNcIik7XG52YXIgX2dldEFzc2lnbm1lbnRJZGVudGlmaWVycyA9IHJlcXVpcmUoXCIuL3JldHJpZXZlcnMvZ2V0QXNzaWdubWVudElkZW50aWZpZXJzLmpzXCIpO1xudmFyIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qc1wiKTtcbnZhciBfZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmpzXCIpO1xudmFyIF9nZXRGdW5jdGlvbk5hbWUgPSByZXF1aXJlKFwiLi9yZXRyaWV2ZXJzL2dldEZ1bmN0aW9uTmFtZS5qc1wiKTtcbnZhciBfdHJhdmVyc2UgPSByZXF1aXJlKFwiLi90cmF2ZXJzZS90cmF2ZXJzZS5qc1wiKTtcbk9iamVjdC5rZXlzKF90cmF2ZXJzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3RyYXZlcnNlW2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3RyYXZlcnNlW2tleV07XG4gICAgfVxuICB9KTtcbn0pO1xudmFyIF90cmF2ZXJzZUZhc3QgPSByZXF1aXJlKFwiLi90cmF2ZXJzZS90cmF2ZXJzZUZhc3QuanNcIik7XG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuL3V0aWxzL3NoYWxsb3dFcXVhbC5qc1wiKTtcbnZhciBfaXMgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzLmpzXCIpO1xudmFyIF9pc0JpbmRpbmcgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzQmluZGluZy5qc1wiKTtcbnZhciBfaXNCbG9ja1Njb3BlZCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNCbG9ja1Njb3BlZC5qc1wiKTtcbnZhciBfaXNJbW11dGFibGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzSW1tdXRhYmxlLmpzXCIpO1xudmFyIF9pc0xldCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNMZXQuanNcIik7XG52YXIgX2lzTm9kZSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2RlLmpzXCIpO1xudmFyIF9pc05vZGVzRXF1aXZhbGVudCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNOb2Rlc0VxdWl2YWxlbnQuanNcIik7XG52YXIgX2lzUGxhY2Vob2xkZXJUeXBlID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1BsYWNlaG9sZGVyVHlwZS5qc1wiKTtcbnZhciBfaXNSZWZlcmVuY2VkID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1JlZmVyZW5jZWQuanNcIik7XG52YXIgX2lzU2NvcGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzU2NvcGUuanNcIik7XG52YXIgX2lzU3BlY2lmaWVyRGVmYXVsdCA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzXCIpO1xudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVHlwZS5qc1wiKTtcbnZhciBfaXNWYWxpZEVTM0lkZW50aWZpZXIgPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzXCIpO1xudmFyIF9pc1ZhbGlkSWRlbnRpZmllciA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvaXNWYWxpZElkZW50aWZpZXIuanNcIik7XG52YXIgX2lzVmFyID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9pc1Zhci5qc1wiKTtcbnZhciBfbWF0Y2hlc1BhdHRlcm4gPSByZXF1aXJlKFwiLi92YWxpZGF0b3JzL21hdGNoZXNQYXR0ZXJuLmpzXCIpO1xudmFyIF92YWxpZGF0ZSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanNcIik7XG52YXIgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5qc1wiKTtcbnZhciBfaW5kZXg2ID0gcmVxdWlyZShcIi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5PYmplY3Qua2V5cyhfaW5kZXg2KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfaW5kZXg2W2tleV0pIHJldHVybjtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX2luZGV4NltrZXldO1xuICAgIH1cbiAgfSk7XG59KTtcbnZhciBfZGVwcmVjYXRpb25XYXJuaW5nID0gcmVxdWlyZShcIi4vdXRpbHMvZGVwcmVjYXRpb25XYXJuaW5nLmpzXCIpO1xuY29uc3QgcmVhY3QgPSBleHBvcnRzLnJlYWN0ID0ge1xuICBpc1JlYWN0Q29tcG9uZW50OiBfaXNSZWFjdENvbXBvbmVudC5kZWZhdWx0LFxuICBpc0NvbXBhdFRhZzogX2lzQ29tcGF0VGFnLmRlZmF1bHQsXG4gIGJ1aWxkQ2hpbGRyZW46IF9idWlsZENoaWxkcmVuLmRlZmF1bHRcbn07XG57XG4gIGV4cG9ydHMudG9TZXF1ZW5jZUV4cHJlc3Npb24gPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJzL3RvU2VxdWVuY2VFeHByZXNzaW9uLmpzXCIpLmRlZmF1bHQ7XG59XG5pZiAocHJvY2Vzcy5lbnYuQkFCRUxfVFlQRVNfOF9CUkVBS0lORykge1xuICBjb25zb2xlLndhcm4oXCJCQUJFTF9UWVBFU184X0JSRUFLSU5HIGlzIG5vdCBzdXBwb3J0ZWQgYW55bW9yZS4gVXNlIHRoZSBsYXRlc3QgQmFiZWwgOC4wLjAgcHJlLXJlbGVhc2UgaW5zdGVhZCFcIik7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2352\n')},74001:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = appendToMemberExpression;\nvar _index = __webpack_require__(48079);\nfunction appendToMemberExpression(member, append, computed = false) {\n  member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\n//# sourceMappingURL=appendToMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQwMDEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBZ0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvYXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzP2ExMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhcHBlbmRUb01lbWJlckV4cHJlc3Npb247XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2J1aWxkZXJzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGFwcGVuZFRvTWVtYmVyRXhwcmVzc2lvbihtZW1iZXIsIGFwcGVuZCwgY29tcHV0ZWQgPSBmYWxzZSkge1xuICBtZW1iZXIub2JqZWN0ID0gKDAsIF9pbmRleC5tZW1iZXJFeHByZXNzaW9uKShtZW1iZXIub2JqZWN0LCBtZW1iZXIucHJvcGVydHksIG1lbWJlci5jb21wdXRlZCk7XG4gIG1lbWJlci5wcm9wZXJ0eSA9IGFwcGVuZDtcbiAgbWVtYmVyLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgcmV0dXJuIG1lbWJlcjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74001\n')},95237:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = removeTypeDuplicates;\nvar _index = __webpack_require__(98960);\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isAnyTypeAnnotation)(node)) {\n      return [node];\n    }\n    if ((0, _index.isFlowBaseAnnotation)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isUnionTypeAnnotation)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _index.isGenericTypeAnnotation)(node)) {\n      const name = getQualifiedName(node.id);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUyMzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBcUM7QUFDMUQ7QUFDQSx5REFBeUQsYUFBYSxHQUFHLHFDQUFxQztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvZmxvdy9yZW1vdmVUeXBlRHVwbGljYXRlcy5qcz85ODc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmVtb3ZlVHlwZUR1cGxpY2F0ZXM7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uLy4uL3ZhbGlkYXRvcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gZ2V0UXVhbGlmaWVkTmFtZShub2RlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzSWRlbnRpZmllcikobm9kZSkgPyBub2RlLm5hbWUgOiBgJHtub2RlLmlkLm5hbWV9LiR7Z2V0UXVhbGlmaWVkTmFtZShub2RlLnF1YWxpZmljYXRpb24pfWA7XG59XG5mdW5jdGlvbiByZW1vdmVUeXBlRHVwbGljYXRlcyhub2Rlc0luKSB7XG4gIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShub2Rlc0luKTtcbiAgY29uc3QgZ2VuZXJpY3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGJhc2VzID0gbmV3IE1hcCgpO1xuICBjb25zdCB0eXBlR3JvdXBzID0gbmV3IFNldCgpO1xuICBjb25zdCB0eXBlcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICghbm9kZSkgY29udGludWU7XG4gICAgaWYgKHR5cGVzLmluY2x1ZGVzKG5vZGUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNBbnlUeXBlQW5ub3RhdGlvbikobm9kZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzRmxvd0Jhc2VBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgYmFzZXMuc2V0KG5vZGUudHlwZSwgbm9kZSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNVbmlvblR5cGVBbm5vdGF0aW9uKShub2RlKSkge1xuICAgICAgaWYgKCF0eXBlR3JvdXBzLmhhcyhub2RlLnR5cGVzKSkge1xuICAgICAgICBub2Rlcy5wdXNoKC4uLm5vZGUudHlwZXMpO1xuICAgICAgICB0eXBlR3JvdXBzLmFkZChub2RlLnR5cGVzKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pbmRleC5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbikobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBnZXRRdWFsaWZpZWROYW1lKG5vZGUuaWQpO1xuICAgICAgaWYgKGdlbmVyaWNzLmhhcyhuYW1lKSkge1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSBnZW5lcmljcy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChleGlzdGluZy50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgIGlmIChub2RlLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMucHVzaCguLi5ub2RlLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcyk7XG4gICAgICAgICAgICBleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMgPSByZW1vdmVUeXBlRHVwbGljYXRlcyhleGlzdGluZy50eXBlUGFyYW1ldGVycy5wYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGlzdGluZyA9IG5vZGUudHlwZVBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyaWNzLnNldChuYW1lLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0eXBlcy5wdXNoKG5vZGUpO1xuICB9XG4gIGZvciAoY29uc3QgWywgYmFzZVR5cGVdIG9mIGJhc2VzKSB7XG4gICAgdHlwZXMucHVzaChiYXNlVHlwZSk7XG4gIH1cbiAgZm9yIChjb25zdCBbLCBnZW5lcmljTmFtZV0gb2YgZ2VuZXJpY3MpIHtcbiAgICB0eXBlcy5wdXNoKGdlbmVyaWNOYW1lKTtcbiAgfVxuICByZXR1cm4gdHlwZXM7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbW92ZVR5cGVEdXBsaWNhdGVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///95237\n')},89564:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inherits;\nvar _index = __webpack_require__(93422);\nvar _inheritsComments = __webpack_require__(18125);\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n  for (const key of _index.INHERIT_KEYS.optional) {\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of Object.keys(parent)) {\n    if (key[0] === "_" && key !== "__clone") {\n      child[key] = parent[key];\n    }\n  }\n  for (const key of _index.INHERIT_KEYS.force) {\n    child[key] = parent[key];\n  }\n  (0, _inheritsComments.default)(child, parent);\n  return child;\n}\n\n//# sourceMappingURL=inherits.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODk1NjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsS0FBaUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL21vZGlmaWNhdGlvbnMvaW5oZXJpdHMuanM/MGFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXRzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG52YXIgX2luaGVyaXRzQ29tbWVudHMgPSByZXF1aXJlKFwiLi4vY29tbWVudHMvaW5oZXJpdHNDb21tZW50cy5qc1wiKTtcbmZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgaWYgKCFjaGlsZCB8fCAhcGFyZW50KSByZXR1cm4gY2hpbGQ7XG4gIGZvciAoY29uc3Qga2V5IG9mIF9pbmRleC5JTkhFUklUX0tFWVMub3B0aW9uYWwpIHtcbiAgICBpZiAoY2hpbGRba2V5XSA9PSBudWxsKSB7XG4gICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBhcmVudCkpIHtcbiAgICBpZiAoa2V5WzBdID09PSBcIl9cIiAmJiBrZXkgIT09IFwiX19jbG9uZVwiKSB7XG4gICAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIF9pbmRleC5JTkhFUklUX0tFWVMuZm9yY2UpIHtcbiAgICBjaGlsZFtrZXldID0gcGFyZW50W2tleV07XG4gIH1cbiAgKDAsIF9pbmhlcml0c0NvbW1lbnRzLmRlZmF1bHQpKGNoaWxkLCBwYXJlbnQpO1xuICByZXR1cm4gY2hpbGQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXRzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89564\n')},96219:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = prependToMemberExpression;\nvar _index = __webpack_require__(48079);\nvar _index2 = __webpack_require__(2352);\nfunction prependToMemberExpression(member, prepend) {\n  if ((0, _index2.isSuper)(member.object)) {\n    throw new Error("Cannot prepend node to super property access (`super.foo`).");\n  }\n  member.object = (0, _index.memberExpression)(prepend, member.object);\n  return member;\n}\n\n//# sourceMappingURL=prependToMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYyMTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBZ0M7QUFDckQsY0FBYyxtQkFBTyxDQUFDLElBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzPzBlNzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9idWlsZGVycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHByZXBlbmRUb01lbWJlckV4cHJlc3Npb24obWVtYmVyLCBwcmVwZW5kKSB7XG4gIGlmICgoMCwgX2luZGV4Mi5pc1N1cGVyKShtZW1iZXIub2JqZWN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBwcmVwZW5kIG5vZGUgdG8gc3VwZXIgcHJvcGVydHkgYWNjZXNzIChgc3VwZXIuZm9vYCkuXCIpO1xuICB9XG4gIG1lbWJlci5vYmplY3QgPSAoMCwgX2luZGV4Lm1lbWJlckV4cHJlc3Npb24pKHByZXBlbmQsIG1lbWJlci5vYmplY3QpO1xuICByZXR1cm4gbWVtYmVyO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVwZW5kVG9NZW1iZXJFeHByZXNzaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///96219\n')},85333:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = removeProperties;\nvar _index = __webpack_require__(93422);\nconst CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];\nconst CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];\nfunction removeProperties(node, opts = {}) {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    if (node[key] != null) node[key] = undefined;\n  }\n  for (const key of Object.keys(node)) {\n    if (key[0] === "_" && node[key] != null) node[key] = undefined;\n  }\n  const symbols = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    node[sym] = null;\n  }\n}\n\n//# sourceMappingURL=removeProperties.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUzMzMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBdUI7QUFDNUM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy9yZW1vdmVQcm9wZXJ0aWVzLmpzP2M3OGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVQcm9wZXJ0aWVzO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5jb25zdCBDTEVBUl9LRVlTID0gW1widG9rZW5zXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJsb2NcIiwgXCJyYXdcIiwgXCJyYXdWYWx1ZVwiXTtcbmNvbnN0IENMRUFSX0tFWVNfUExVU19DT01NRU5UUyA9IFsuLi5faW5kZXguQ09NTUVOVF9LRVlTLCBcImNvbW1lbnRzXCIsIC4uLkNMRUFSX0tFWVNdO1xuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhub2RlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgbWFwID0gb3B0cy5wcmVzZXJ2ZUNvbW1lbnRzID8gQ0xFQVJfS0VZUyA6IENMRUFSX0tFWVNfUExVU19DT01NRU5UUztcbiAgZm9yIChjb25zdCBrZXkgb2YgbWFwKSB7XG4gICAgaWYgKG5vZGVba2V5XSAhPSBudWxsKSBub2RlW2tleV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobm9kZSkpIHtcbiAgICBpZiAoa2V5WzBdID09PSBcIl9cIiAmJiBub2RlW2tleV0gIT0gbnVsbCkgbm9kZVtrZXldID0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG5vZGUpO1xuICBmb3IgKGNvbnN0IHN5bSBvZiBzeW1ib2xzKSB7XG4gICAgbm9kZVtzeW1dID0gbnVsbDtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVQcm9wZXJ0aWVzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///85333\n')},87639:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = removePropertiesDeep;\nvar _traverseFast = __webpack_require__(58943);\nvar _removeProperties = __webpack_require__(85333);\nfunction removePropertiesDeep(tree, opts) {\n  (0, _traverseFast.default)(tree, _removeProperties.default, opts);\n  return tree;\n}\n\n//# sourceMappingURL=removePropertiesDeep.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODc2MzkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyxLQUE2QjtBQUN6RCx3QkFBd0IsbUJBQU8sQ0FBQyxLQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9tb2RpZmljYXRpb25zL3JlbW92ZVByb3BlcnRpZXNEZWVwLmpzPzdkNjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVQcm9wZXJ0aWVzRGVlcDtcbnZhciBfdHJhdmVyc2VGYXN0ID0gcmVxdWlyZShcIi4uL3RyYXZlcnNlL3RyYXZlcnNlRmFzdC5qc1wiKTtcbnZhciBfcmVtb3ZlUHJvcGVydGllcyA9IHJlcXVpcmUoXCIuL3JlbW92ZVByb3BlcnRpZXMuanNcIik7XG5mdW5jdGlvbiByZW1vdmVQcm9wZXJ0aWVzRGVlcCh0cmVlLCBvcHRzKSB7XG4gICgwLCBfdHJhdmVyc2VGYXN0LmRlZmF1bHQpKHRyZWUsIF9yZW1vdmVQcm9wZXJ0aWVzLmRlZmF1bHQsIG9wdHMpO1xuICByZXR1cm4gdHJlZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVtb3ZlUHJvcGVydGllc0RlZXAuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///87639\n')},78812:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = removeTypeDuplicates;\nvar _index = __webpack_require__(98960);\nfunction getQualifiedName(node) {\n  return (0, _index.isIdentifier)(node) ? node.name : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\nfunction removeTypeDuplicates(nodesIn) {\n  const nodes = Array.from(nodesIn);\n  const generics = new Map();\n  const bases = new Map();\n  const typeGroups = new Set();\n  const types = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n    if (types.includes(node)) {\n      continue;\n    }\n    if ((0, _index.isTSAnyKeyword)(node)) {\n      return [node];\n    }\n    if ((0, _index.isTSBaseType)(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n    if ((0, _index.isTSUnionType)(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n    if ((0, _index.isTSTypeReference)(node) && node.typeParameters) {\n      const name = getQualifiedName(node.typeName);\n      if (generics.has(name)) {\n        let existing = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n      continue;\n    }\n    types.push(node);\n  }\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n  return types;\n}\n\n//# sourceMappingURL=removeTypeDuplicates.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg4MTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBcUM7QUFDMUQ7QUFDQSx5REFBeUQsZ0JBQWdCLEdBQUcsNEJBQTRCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvbW9kaWZpY2F0aW9ucy90eXBlc2NyaXB0L3JlbW92ZVR5cGVEdXBsaWNhdGVzLmpzP2ZlN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSByZW1vdmVUeXBlRHVwbGljYXRlcztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBnZXRRdWFsaWZpZWROYW1lKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguaXNJZGVudGlmaWVyKShub2RlKSA/IG5vZGUubmFtZSA6IGAke25vZGUucmlnaHQubmFtZX0uJHtnZXRRdWFsaWZpZWROYW1lKG5vZGUubGVmdCl9YDtcbn1cbmZ1bmN0aW9uIHJlbW92ZVR5cGVEdXBsaWNhdGVzKG5vZGVzSW4pIHtcbiAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGVzSW4pO1xuICBjb25zdCBnZW5lcmljcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgYmFzZXMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHR5cGVHcm91cHMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHR5cGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCFub2RlKSBjb250aW51ZTtcbiAgICBpZiAodHlwZXMuaW5jbHVkZXMobm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pbmRleC5pc1RTQW55S2V5d29yZCkobm9kZSkpIHtcbiAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzVFNCYXNlVHlwZSkobm9kZSkpIHtcbiAgICAgIGJhc2VzLnNldChub2RlLnR5cGUsIG5vZGUpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzVFNVbmlvblR5cGUpKG5vZGUpKSB7XG4gICAgICBpZiAoIXR5cGVHcm91cHMuaGFzKG5vZGUudHlwZXMpKSB7XG4gICAgICAgIG5vZGVzLnB1c2goLi4ubm9kZS50eXBlcyk7XG4gICAgICAgIHR5cGVHcm91cHMuYWRkKG5vZGUudHlwZXMpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgoMCwgX2luZGV4LmlzVFNUeXBlUmVmZXJlbmNlKShub2RlKSAmJiBub2RlLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICBjb25zdCBuYW1lID0gZ2V0UXVhbGlmaWVkTmFtZShub2RlLnR5cGVOYW1lKTtcbiAgICAgIGlmIChnZW5lcmljcy5oYXMobmFtZSkpIHtcbiAgICAgICAgbGV0IGV4aXN0aW5nID0gZ2VuZXJpY3MuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoZXhpc3RpbmcudHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICBpZiAobm9kZS50eXBlUGFyYW1ldGVycykge1xuICAgICAgICAgICAgZXhpc3RpbmcudHlwZVBhcmFtZXRlcnMucGFyYW1zLnB1c2goLi4ubm9kZS50eXBlUGFyYW1ldGVycy5wYXJhbXMpO1xuICAgICAgICAgICAgZXhpc3RpbmcudHlwZVBhcmFtZXRlcnMucGFyYW1zID0gcmVtb3ZlVHlwZUR1cGxpY2F0ZXMoZXhpc3RpbmcudHlwZVBhcmFtZXRlcnMucGFyYW1zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhpc3RpbmcgPSBub2RlLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmljcy5zZXQobmFtZSwgbm9kZSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdHlwZXMucHVzaChub2RlKTtcbiAgfVxuICBmb3IgKGNvbnN0IFssIGJhc2VUeXBlXSBvZiBiYXNlcykge1xuICAgIHR5cGVzLnB1c2goYmFzZVR5cGUpO1xuICB9XG4gIGZvciAoY29uc3QgWywgZ2VuZXJpY05hbWVdIG9mIGdlbmVyaWNzKSB7XG4gICAgdHlwZXMucHVzaChnZW5lcmljTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZW1vdmVUeXBlRHVwbGljYXRlcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78812\n')},1343:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = getAssignmentIdentifiers;\nfunction getAssignmentIdentifiers(node) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n    switch (id.type) {\n      case "ArrayPattern":\n        search.push(...id.elements);\n        break;\n      case "AssignmentExpression":\n      case "AssignmentPattern":\n      case "ForInStatement":\n      case "ForOfStatement":\n        search.push(id.left);\n        break;\n      case "ObjectPattern":\n        search.push(...id.properties);\n        break;\n      case "ObjectProperty":\n        search.push(id.value);\n        break;\n      case "RestElement":\n      case "UpdateExpression":\n        search.push(id.argument);\n        break;\n      case "UnaryExpression":\n        if (id.operator === "delete") {\n          search.push(id.argument);\n        }\n        break;\n      case "Identifier":\n        ids[id.name] = id;\n        break;\n      default:\n        break;\n    }\n  }\n  return ids;\n}\n\n//# sourceMappingURL=getAssignmentIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0My5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3JldHJpZXZlcnMvZ2V0QXNzaWdubWVudElkZW50aWZpZXJzLmpzPzk1ZGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnM7XG5mdW5jdGlvbiBnZXRBc3NpZ25tZW50SWRlbnRpZmllcnMobm9kZSkge1xuICBjb25zdCBzZWFyY2ggPSBbXS5jb25jYXQobm9kZSk7XG4gIGNvbnN0IGlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHdoaWxlIChzZWFyY2gubGVuZ3RoKSB7XG4gICAgY29uc3QgaWQgPSBzZWFyY2gucG9wKCk7XG4gICAgaWYgKCFpZCkgY29udGludWU7XG4gICAgc3dpdGNoIChpZC50eXBlKSB7XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICAgIHNlYXJjaC5wdXNoKC4uLmlkLmVsZW1lbnRzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgICBjYXNlIFwiRm9yT2ZTdGF0ZW1lbnRcIjpcbiAgICAgICAgc2VhcmNoLnB1c2goaWQubGVmdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgc2VhcmNoLnB1c2goLi4uaWQucHJvcGVydGllcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLnZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmFyZ3VtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChpZC5vcGVyYXRvciA9PT0gXCJkZWxldGVcIikge1xuICAgICAgICAgIHNlYXJjaC5wdXNoKGlkLmFyZ3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGlkc1tpZC5uYW1lXSA9IGlkO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaWRzO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRBc3NpZ25tZW50SWRlbnRpZmllcnMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1343\n')},70329:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = getBindingIdentifiers;\nvar _index = __webpack_require__(98960);\nfunction getBindingIdentifiers(node, duplicates, outerOnly, newBindingsOnly) {\n  const search = [].concat(node);\n  const ids = Object.create(null);\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id) || (0, _index.isUnaryExpression)(id) || (0, _index.isUpdateExpression)(id))) {\n      continue;\n    }\n    if ((0, _index.isIdentifier)(id)) {\n      if (duplicates) {\n        const _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n    if ((0, _index.isExportDeclaration)(id) && !(0, _index.isExportAllDeclaration)(id)) {\n      if ((0, _index.isDeclaration)(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n    if (outerOnly) {\n      if ((0, _index.isFunctionDeclaration)(id)) {\n        search.push(id.id);\n        continue;\n      }\n      if ((0, _index.isFunctionExpression)(id)) {\n        continue;\n      }\n    }\n    const keys = getBindingIdentifiers.keys[id.type];\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes = id[key];\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\nconst keys = {\n  DeclareClass: ["id"],\n  DeclareFunction: ["id"],\n  DeclareModule: ["id"],\n  DeclareVariable: ["id"],\n  DeclareInterface: ["id"],\n  DeclareTypeAlias: ["id"],\n  DeclareOpaqueType: ["id"],\n  InterfaceDeclaration: ["id"],\n  TypeAlias: ["id"],\n  OpaqueType: ["id"],\n  CatchClause: ["param"],\n  LabeledStatement: ["label"],\n  UnaryExpression: ["argument"],\n  AssignmentExpression: ["left"],\n  ImportSpecifier: ["local"],\n  ImportNamespaceSpecifier: ["local"],\n  ImportDefaultSpecifier: ["local"],\n  ImportDeclaration: ["specifiers"],\n  ExportSpecifier: ["exported"],\n  ExportNamespaceSpecifier: ["exported"],\n  ExportDefaultSpecifier: ["exported"],\n  FunctionDeclaration: ["id", "params"],\n  FunctionExpression: ["id", "params"],\n  ArrowFunctionExpression: ["params"],\n  ObjectMethod: ["params"],\n  ClassMethod: ["params"],\n  ClassPrivateMethod: ["params"],\n  ForInStatement: ["left"],\n  ForOfStatement: ["left"],\n  ClassDeclaration: ["id"],\n  ClassExpression: ["id"],\n  RestElement: ["argument"],\n  UpdateExpression: ["argument"],\n  ObjectProperty: ["value"],\n  AssignmentPattern: ["left"],\n  ArrayPattern: ["elements"],\n  ObjectPattern: ["properties"],\n  VariableDeclaration: ["declarations"],\n  VariableDeclarator: ["id"]\n};\ngetBindingIdentifiers.keys = keys;\n\n//# sourceMappingURL=getBindingIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAzMjkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvcmV0cmlldmVycy9nZXRCaW5kaW5nSWRlbnRpZmllcnMuanM/N2ZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGdldEJpbmRpbmdJZGVudGlmaWVycztcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vdmFsaWRhdG9ycy9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBnZXRCaW5kaW5nSWRlbnRpZmllcnMobm9kZSwgZHVwbGljYXRlcywgb3V0ZXJPbmx5LCBuZXdCaW5kaW5nc09ubHkpIHtcbiAgY29uc3Qgc2VhcmNoID0gW10uY29uY2F0KG5vZGUpO1xuICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB3aGlsZSAoc2VhcmNoLmxlbmd0aCkge1xuICAgIGNvbnN0IGlkID0gc2VhcmNoLnNoaWZ0KCk7XG4gICAgaWYgKCFpZCkgY29udGludWU7XG4gICAgaWYgKG5ld0JpbmRpbmdzT25seSAmJiAoKDAsIF9pbmRleC5pc0Fzc2lnbm1lbnRFeHByZXNzaW9uKShpZCkgfHwgKDAsIF9pbmRleC5pc1VuYXJ5RXhwcmVzc2lvbikoaWQpIHx8ICgwLCBfaW5kZXguaXNVcGRhdGVFeHByZXNzaW9uKShpZCkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKCgwLCBfaW5kZXguaXNJZGVudGlmaWVyKShpZCkpIHtcbiAgICAgIGlmIChkdXBsaWNhdGVzKSB7XG4gICAgICAgIGNvbnN0IF9pZHMgPSBpZHNbaWQubmFtZV0gPSBpZHNbaWQubmFtZV0gfHwgW107XG4gICAgICAgIF9pZHMucHVzaChpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHNbaWQubmFtZV0gPSBpZDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKDAsIF9pbmRleC5pc0V4cG9ydERlY2xhcmF0aW9uKShpZCkgJiYgISgwLCBfaW5kZXguaXNFeHBvcnRBbGxEZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICBpZiAoKDAsIF9pbmRleC5pc0RlY2xhcmF0aW9uKShpZC5kZWNsYXJhdGlvbikpIHtcbiAgICAgICAgc2VhcmNoLnB1c2goaWQuZGVjbGFyYXRpb24pO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChvdXRlck9ubHkpIHtcbiAgICAgIGlmICgoMCwgX2luZGV4LmlzRnVuY3Rpb25EZWNsYXJhdGlvbikoaWQpKSB7XG4gICAgICAgIHNlYXJjaC5wdXNoKGlkLmlkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uRXhwcmVzc2lvbikoaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBrZXlzID0gZ2V0QmluZGluZ0lkZW50aWZpZXJzLmtleXNbaWQudHlwZV07XG4gICAgaWYgKGtleXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgICBjb25zdCBub2RlcyA9IGlkW2tleV07XG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgc2VhcmNoLnB1c2goLi4ubm9kZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWFyY2gucHVzaChub2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpZHM7XG59XG5jb25zdCBrZXlzID0ge1xuICBEZWNsYXJlQ2xhc3M6IFtcImlkXCJdLFxuICBEZWNsYXJlRnVuY3Rpb246IFtcImlkXCJdLFxuICBEZWNsYXJlTW9kdWxlOiBbXCJpZFwiXSxcbiAgRGVjbGFyZVZhcmlhYmxlOiBbXCJpZFwiXSxcbiAgRGVjbGFyZUludGVyZmFjZTogW1wiaWRcIl0sXG4gIERlY2xhcmVUeXBlQWxpYXM6IFtcImlkXCJdLFxuICBEZWNsYXJlT3BhcXVlVHlwZTogW1wiaWRcIl0sXG4gIEludGVyZmFjZURlY2xhcmF0aW9uOiBbXCJpZFwiXSxcbiAgVHlwZUFsaWFzOiBbXCJpZFwiXSxcbiAgT3BhcXVlVHlwZTogW1wiaWRcIl0sXG4gIENhdGNoQ2xhdXNlOiBbXCJwYXJhbVwiXSxcbiAgTGFiZWxlZFN0YXRlbWVudDogW1wibGFiZWxcIl0sXG4gIFVuYXJ5RXhwcmVzc2lvbjogW1wiYXJndW1lbnRcIl0sXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBbXCJsZWZ0XCJdLFxuICBJbXBvcnRTcGVjaWZpZXI6IFtcImxvY2FsXCJdLFxuICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFtcImxvY2FsXCJdLFxuICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBbXCJsb2NhbFwiXSxcbiAgSW1wb3J0RGVjbGFyYXRpb246IFtcInNwZWNpZmllcnNcIl0sXG4gIEV4cG9ydFNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjogW1wiZXhwb3J0ZWRcIl0sXG4gIEV4cG9ydERlZmF1bHRTcGVjaWZpZXI6IFtcImV4cG9ydGVkXCJdLFxuICBGdW5jdGlvbkRlY2xhcmF0aW9uOiBbXCJpZFwiLCBcInBhcmFtc1wiXSxcbiAgRnVuY3Rpb25FeHByZXNzaW9uOiBbXCJpZFwiLCBcInBhcmFtc1wiXSxcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IFtcInBhcmFtc1wiXSxcbiAgT2JqZWN0TWV0aG9kOiBbXCJwYXJhbXNcIl0sXG4gIENsYXNzTWV0aG9kOiBbXCJwYXJhbXNcIl0sXG4gIENsYXNzUHJpdmF0ZU1ldGhvZDogW1wicGFyYW1zXCJdLFxuICBGb3JJblN0YXRlbWVudDogW1wibGVmdFwiXSxcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFtcImxlZnRcIl0sXG4gIENsYXNzRGVjbGFyYXRpb246IFtcImlkXCJdLFxuICBDbGFzc0V4cHJlc3Npb246IFtcImlkXCJdLFxuICBSZXN0RWxlbWVudDogW1wiYXJndW1lbnRcIl0sXG4gIFVwZGF0ZUV4cHJlc3Npb246IFtcImFyZ3VtZW50XCJdLFxuICBPYmplY3RQcm9wZXJ0eTogW1widmFsdWVcIl0sXG4gIEFzc2lnbm1lbnRQYXR0ZXJuOiBbXCJsZWZ0XCJdLFxuICBBcnJheVBhdHRlcm46IFtcImVsZW1lbnRzXCJdLFxuICBPYmplY3RQYXR0ZXJuOiBbXCJwcm9wZXJ0aWVzXCJdLFxuICBWYXJpYWJsZURlY2xhcmF0aW9uOiBbXCJkZWNsYXJhdGlvbnNcIl0sXG4gIFZhcmlhYmxlRGVjbGFyYXRvcjogW1wiaWRcIl1cbn07XG5nZXRCaW5kaW5nSWRlbnRpZmllcnMua2V5cyA9IGtleXM7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEJpbmRpbmdJZGVudGlmaWVycy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70329\n')},5109:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = getFunctionName;\nvar _index = __webpack_require__(98960);\nfunction getNameFromLiteralId(id) {\n  if ((0, _index.isNullLiteral)(id)) {\n    return "null";\n  }\n  if ((0, _index.isRegExpLiteral)(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n  if ((0, _index.isTemplateLiteral)(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join("");\n  }\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n  return null;\n}\nfunction getObjectMemberKey(node) {\n  if (!node.computed || (0, _index.isLiteral)(node.key)) {\n    return node.key;\n  }\n}\nfunction getFunctionName(node, parent) {\n  if ("id" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id\n    };\n  }\n  let prefix = "";\n  let id;\n  if ((0, _index.isObjectProperty)(parent, {\n    value: node\n  })) {\n    id = getObjectMemberKey(parent);\n  } else if ((0, _index.isObjectMethod)(node) || (0, _index.isClassMethod)(node)) {\n    id = getObjectMemberKey(node);\n    if (node.kind === "get") prefix = "get ";else if (node.kind === "set") prefix = "set ";\n  } else if ((0, _index.isVariableDeclarator)(parent, {\n    init: node\n  })) {\n    id = parent.id;\n  } else if ((0, _index.isAssignmentExpression)(parent, {\n    operator: "=",\n    right: node\n  })) {\n    id = parent.left;\n  }\n  if (!id) return null;\n  const name = (0, _index.isLiteral)(id) ? getNameFromLiteralId(id) : (0, _index.isIdentifier)(id) ? id.name : (0, _index.isPrivateName)(id) ? id.id.name : null;\n  if (name == null) return null;\n  return {\n    name: prefix + name,\n    originalNode: id\n  };\n}\n\n//# sourceMappingURL=getFunctionName.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEwOS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxLQUFrQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXLEdBQUcsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLElBQUk7QUFDSjtBQUNBLDZDQUE2QztBQUM3QyxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldEZ1bmN0aW9uTmFtZS5qcz85ZTU1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0RnVuY3Rpb25OYW1lO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIGdldE5hbWVGcm9tTGl0ZXJhbElkKGlkKSB7XG4gIGlmICgoMCwgX2luZGV4LmlzTnVsbExpdGVyYWwpKGlkKSkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBpZiAoKDAsIF9pbmRleC5pc1JlZ0V4cExpdGVyYWwpKGlkKSkge1xuICAgIHJldHVybiBgLyR7aWQucGF0dGVybn0vJHtpZC5mbGFnc31gO1xuICB9XG4gIGlmICgoMCwgX2luZGV4LmlzVGVtcGxhdGVMaXRlcmFsKShpZCkpIHtcbiAgICByZXR1cm4gaWQucXVhc2lzLm1hcChxdWFzaSA9PiBxdWFzaS52YWx1ZS5yYXcpLmpvaW4oXCJcIik7XG4gIH1cbiAgaWYgKGlkLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gU3RyaW5nKGlkLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldE9iamVjdE1lbWJlcktleShub2RlKSB7XG4gIGlmICghbm9kZS5jb21wdXRlZCB8fCAoMCwgX2luZGV4LmlzTGl0ZXJhbCkobm9kZS5rZXkpKSB7XG4gICAgcmV0dXJuIG5vZGUua2V5O1xuICB9XG59XG5mdW5jdGlvbiBnZXRGdW5jdGlvbk5hbWUobm9kZSwgcGFyZW50KSB7XG4gIGlmIChcImlkXCIgaW4gbm9kZSAmJiBub2RlLmlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5vZGUuaWQubmFtZSxcbiAgICAgIG9yaWdpbmFsTm9kZTogbm9kZS5pZFxuICAgIH07XG4gIH1cbiAgbGV0IHByZWZpeCA9IFwiXCI7XG4gIGxldCBpZDtcbiAgaWYgKCgwLCBfaW5kZXguaXNPYmplY3RQcm9wZXJ0eSkocGFyZW50LCB7XG4gICAgdmFsdWU6IG5vZGVcbiAgfSkpIHtcbiAgICBpZCA9IGdldE9iamVjdE1lbWJlcktleShwYXJlbnQpO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNPYmplY3RNZXRob2QpKG5vZGUpIHx8ICgwLCBfaW5kZXguaXNDbGFzc01ldGhvZCkobm9kZSkpIHtcbiAgICBpZCA9IGdldE9iamVjdE1lbWJlcktleShub2RlKTtcbiAgICBpZiAobm9kZS5raW5kID09PSBcImdldFwiKSBwcmVmaXggPSBcImdldCBcIjtlbHNlIGlmIChub2RlLmtpbmQgPT09IFwic2V0XCIpIHByZWZpeCA9IFwic2V0IFwiO1xuICB9IGVsc2UgaWYgKCgwLCBfaW5kZXguaXNWYXJpYWJsZURlY2xhcmF0b3IpKHBhcmVudCwge1xuICAgIGluaXQ6IG5vZGVcbiAgfSkpIHtcbiAgICBpZCA9IHBhcmVudC5pZDtcbiAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzQXNzaWdubWVudEV4cHJlc3Npb24pKHBhcmVudCwge1xuICAgIG9wZXJhdG9yOiBcIj1cIixcbiAgICByaWdodDogbm9kZVxuICB9KSkge1xuICAgIGlkID0gcGFyZW50LmxlZnQ7XG4gIH1cbiAgaWYgKCFpZCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG5hbWUgPSAoMCwgX2luZGV4LmlzTGl0ZXJhbCkoaWQpID8gZ2V0TmFtZUZyb21MaXRlcmFsSWQoaWQpIDogKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKGlkKSA/IGlkLm5hbWUgOiAoMCwgX2luZGV4LmlzUHJpdmF0ZU5hbWUpKGlkKSA/IGlkLmlkLm5hbWUgOiBudWxsO1xuICBpZiAobmFtZSA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBwcmVmaXggKyBuYW1lLFxuICAgIG9yaWdpbmFsTm9kZTogaWRcbiAgfTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RnVuY3Rpb25OYW1lLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5109\n')},49420:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _getBindingIdentifiers = __webpack_require__(70329);\nvar _default = exports["default"] = getOuterBindingIdentifiers;\nfunction getOuterBindingIdentifiers(node, duplicates) {\n  return (0, _getBindingIdentifiers.default)(node, duplicates, true);\n}\n\n//# sourceMappingURL=getOuterBindingIdentifiers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk0MjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZiw2QkFBNkIsbUJBQU8sQ0FBQyxLQUE0QjtBQUNqRSxlQUFlLGtCQUFlO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi9yZXRyaWV2ZXJzL2dldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmpzPzZiNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IHJlcXVpcmUoXCIuL2dldEJpbmRpbmdJZGVudGlmaWVycy5qc1wiKTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHMuZGVmYXVsdCA9IGdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzO1xuZnVuY3Rpb24gZ2V0T3V0ZXJCaW5kaW5nSWRlbnRpZmllcnMobm9kZSwgZHVwbGljYXRlcykge1xuICByZXR1cm4gKDAsIF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdCkobm9kZSwgZHVwbGljYXRlcywgdHJ1ZSk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldE91dGVyQmluZGluZ0lkZW50aWZpZXJzLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///49420\n')},53357:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = traverse;\nvar _index = __webpack_require__(39793);\nfunction traverse(node, handlers, state) {\n  if (typeof handlers === "function") {\n    handlers = {\n      enter: handlers\n    };\n  }\n  const {\n    enter,\n    exit\n  } = handlers;\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\nfunction traverseSimpleImpl(node, enter, exit, state, ancestors) {\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  if (enter) enter(node, ancestors, state);\n  for (const key of keys) {\n    const subNode = node[key];\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n        ancestors.push({\n          node,\n          key,\n          index: i\n        });\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key\n      });\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n      ancestors.pop();\n    }\n  }\n  if (exit) exit(node, ancestors, state);\n}\n\n//# sourceMappingURL=traverse.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMzNTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3RyYXZlcnNlL3RyYXZlcnNlLmpzP2IwYTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB0cmF2ZXJzZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiB0cmF2ZXJzZShub2RlLCBoYW5kbGVycywgc3RhdGUpIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGVycyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaGFuZGxlcnMgPSB7XG4gICAgICBlbnRlcjogaGFuZGxlcnNcbiAgICB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBlbnRlcixcbiAgICBleGl0XG4gIH0gPSBoYW5kbGVycztcbiAgdHJhdmVyc2VTaW1wbGVJbXBsKG5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgW10pO1xufVxuZnVuY3Rpb24gdHJhdmVyc2VTaW1wbGVJbXBsKG5vZGUsIGVudGVyLCBleGl0LCBzdGF0ZSwgYW5jZXN0b3JzKSB7XG4gIGNvbnN0IGtleXMgPSBfaW5kZXguVklTSVRPUl9LRVlTW25vZGUudHlwZV07XG4gIGlmICgha2V5cykgcmV0dXJuO1xuICBpZiAoZW50ZXIpIGVudGVyKG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3Qgc3ViTm9kZSA9IG5vZGVba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzdWJOb2RlKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJOb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gc3ViTm9kZVtpXTtcbiAgICAgICAgaWYgKCFjaGlsZCkgY29udGludWU7XG4gICAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgICAgdHJhdmVyc2VTaW1wbGVJbXBsKGNoaWxkLCBlbnRlciwgZXhpdCwgc3RhdGUsIGFuY2VzdG9ycyk7XG4gICAgICAgIGFuY2VzdG9ycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHN1Yk5vZGUpIHtcbiAgICAgIGFuY2VzdG9ycy5wdXNoKHtcbiAgICAgICAgbm9kZSxcbiAgICAgICAga2V5XG4gICAgICB9KTtcbiAgICAgIHRyYXZlcnNlU2ltcGxlSW1wbChzdWJOb2RlLCBlbnRlciwgZXhpdCwgc3RhdGUsIGFuY2VzdG9ycyk7XG4gICAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgfVxuICB9XG4gIGlmIChleGl0KSBleGl0KG5vZGUsIGFuY2VzdG9ycywgc3RhdGUpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmF2ZXJzZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53357\n')},58943:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = traverseFast;\nvar _index = __webpack_require__(39793);\nfunction traverseFast(node, enter, opts) {\n  if (!node) return;\n  const keys = _index.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  opts = opts || {};\n  enter(node, opts);\n  for (const key of keys) {\n    const subNode = node[key];\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        traverseFast(node, enter, opts);\n      }\n    } else {\n      traverseFast(subNode, enter, opts);\n    }\n  }\n}\n\n//# sourceMappingURL=traverseFast.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTg5NDMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3RyYXZlcnNlL3RyYXZlcnNlRmFzdC5qcz9iZTEzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdHJhdmVyc2VGYXN0O1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9ucy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHRyYXZlcnNlRmFzdChub2RlLCBlbnRlciwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybjtcbiAgY29uc3Qga2V5cyA9IF9pbmRleC5WSVNJVE9SX0tFWVNbbm9kZS50eXBlXTtcbiAgaWYgKCFrZXlzKSByZXR1cm47XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBlbnRlcihub2RlLCBvcHRzKTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGNvbnN0IHN1Yk5vZGUgPSBub2RlW2tleV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3ViTm9kZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdWJOb2RlKSB7XG4gICAgICAgIHRyYXZlcnNlRmFzdChub2RlLCBlbnRlciwgb3B0cyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYXZlcnNlRmFzdChzdWJOb2RlLCBlbnRlciwgb3B0cyk7XG4gICAgfVxuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYXZlcnNlRmFzdC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///58943\n')},63762:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = deprecationWarning;\nconst warnings = new Set();\nfunction deprecationWarning(oldName, newName, prefix = "") {\n  if (warnings.has(oldName)) return;\n  warnings.add(oldName);\n  const {\n    internal,\n    trace\n  } = captureShortStackTrace(1, 2);\n  if (internal) {\n    return;\n  }\n  console.warn(`${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`);\n}\nfunction captureShortStackTrace(skip, length) {\n  const {\n    stackTraceLimit,\n    prepareStackTrace\n  } = Error;\n  let stackTrace;\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n  if (!stackTrace) return {\n    internal: false,\n    trace: ""\n  };\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()),\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join("\\n")\n  };\n}\n\n//# sourceMappingURL=deprecationWarning.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM3NjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTyxJQUFJLFFBQVEsOENBQThDLFFBQVEsTUFBTSxNQUFNO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanM/NDFlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlcHJlY2F0aW9uV2FybmluZztcbmNvbnN0IHdhcm5pbmdzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gZGVwcmVjYXRpb25XYXJuaW5nKG9sZE5hbWUsIG5ld05hbWUsIHByZWZpeCA9IFwiXCIpIHtcbiAgaWYgKHdhcm5pbmdzLmhhcyhvbGROYW1lKSkgcmV0dXJuO1xuICB3YXJuaW5ncy5hZGQob2xkTmFtZSk7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbCxcbiAgICB0cmFjZVxuICB9ID0gY2FwdHVyZVNob3J0U3RhY2tUcmFjZSgxLCAyKTtcbiAgaWYgKGludGVybmFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUud2FybihgJHtwcmVmaXh9XFxgJHtvbGROYW1lfVxcYCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2UgbWlncmF0ZSB0byBcXGAke25ld05hbWV9XFxgXFxuJHt0cmFjZX1gKTtcbn1cbmZ1bmN0aW9uIGNhcHR1cmVTaG9ydFN0YWNrVHJhY2Uoc2tpcCwgbGVuZ3RoKSB7XG4gIGNvbnN0IHtcbiAgICBzdGFja1RyYWNlTGltaXQsXG4gICAgcHJlcGFyZVN0YWNrVHJhY2VcbiAgfSA9IEVycm9yO1xuICBsZXQgc3RhY2tUcmFjZTtcbiAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMSArIHNraXAgKyBsZW5ndGg7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKGVyciwgc3RhY2spIHtcbiAgICBzdGFja1RyYWNlID0gc3RhY2s7XG4gIH07XG4gIG5ldyBFcnJvcigpLnN0YWNrO1xuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXQ7XG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJlcGFyZVN0YWNrVHJhY2U7XG4gIGlmICghc3RhY2tUcmFjZSkgcmV0dXJuIHtcbiAgICBpbnRlcm5hbDogZmFsc2UsXG4gICAgdHJhY2U6IFwiXCJcbiAgfTtcbiAgY29uc3Qgc2hvcnRTdGFja1RyYWNlID0gc3RhY2tUcmFjZS5zbGljZSgxICsgc2tpcCwgMSArIHNraXAgKyBsZW5ndGgpO1xuICByZXR1cm4ge1xuICAgIGludGVybmFsOiAvW1xcXFwvXUBiYWJlbFtcXFxcL10vLnRlc3Qoc2hvcnRTdGFja1RyYWNlWzFdLmdldEZpbGVOYW1lKCkpLFxuICAgIHRyYWNlOiBzaG9ydFN0YWNrVHJhY2UubWFwKGZyYW1lID0+IGAgICAgYXQgJHtmcmFtZX1gKS5qb2luKFwiXFxuXCIpXG4gIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcHJlY2F0aW9uV2FybmluZy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63762\n')},73205:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = inherit;\nfunction inherit(key, child, parent) {\n  if (child && parent) {\n    child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));\n  }\n}\n\n//# sourceMappingURL=inherit.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMyMDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3V0aWxzL2luaGVyaXQuanM/N2FiMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluaGVyaXQ7XG5mdW5jdGlvbiBpbmhlcml0KGtleSwgY2hpbGQsIHBhcmVudCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50KSB7XG4gICAgY2hpbGRba2V5XSA9IEFycmF5LmZyb20obmV3IFNldChbXS5jb25jYXQoY2hpbGRba2V5XSwgcGFyZW50W2tleV0pLmZpbHRlcihCb29sZWFuKSkpO1xuICB9XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaGVyaXQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73205\n')},53043:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = cleanJSXElementLiteralChild;\nvar _index = __webpack_require__(48079);\nvar _index2 = __webpack_require__(2352);\nfunction cleanJSXElementLiteralChild(child, args) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n  let lastNonEmptyLine = 0;\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n  let str = "";\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n    let trimmedLine = line.replace(/\\t/g, " ");\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, "");\n    }\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, "");\n    }\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += " ";\n      }\n      str += trimmedLine;\n    }\n  }\n  if (str) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str), child));\n}\n\n//# sourceMappingURL=cleanJSXElementLiteralChild.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMwNDMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBbUM7QUFDeEQsY0FBYyxtQkFBTyxDQUFDLElBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi91dGlscy9yZWFjdC9jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQuanM/MTk4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGNsZWFuSlNYRWxlbWVudExpdGVyYWxDaGlsZDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vLi4vYnVpbGRlcnMvZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xudmFyIF9pbmRleDIgPSByZXF1aXJlKFwiLi4vLi4vaW5kZXguanNcIik7XG5mdW5jdGlvbiBjbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQoY2hpbGQsIGFyZ3MpIHtcbiAgY29uc3QgbGluZXMgPSBjaGlsZC52YWx1ZS5zcGxpdCgvXFxyXFxufFxcbnxcXHIvKTtcbiAgbGV0IGxhc3ROb25FbXB0eUxpbmUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKC9bXiBcXHRdLy5leGVjKGxpbmVzW2ldKSkge1xuICAgICAgbGFzdE5vbkVtcHR5TGluZSA9IGk7XG4gICAgfVxuICB9XG4gIGxldCBzdHIgPSBcIlwiO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgIGNvbnN0IGlzRmlyc3RMaW5lID0gaSA9PT0gMDtcbiAgICBjb25zdCBpc0xhc3RMaW5lID0gaSA9PT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBpc0xhc3ROb25FbXB0eUxpbmUgPSBpID09PSBsYXN0Tm9uRW1wdHlMaW5lO1xuICAgIGxldCB0cmltbWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFx0L2csIFwiIFwiKTtcbiAgICBpZiAoIWlzRmlyc3RMaW5lKSB7XG4gICAgICB0cmltbWVkTGluZSA9IHRyaW1tZWRMaW5lLnJlcGxhY2UoL14gKy8sIFwiXCIpO1xuICAgIH1cbiAgICBpZiAoIWlzTGFzdExpbmUpIHtcbiAgICAgIHRyaW1tZWRMaW5lID0gdHJpbW1lZExpbmUucmVwbGFjZSgvICskLywgXCJcIik7XG4gICAgfVxuICAgIGlmICh0cmltbWVkTGluZSkge1xuICAgICAgaWYgKCFpc0xhc3ROb25FbXB0eUxpbmUpIHtcbiAgICAgICAgdHJpbW1lZExpbmUgKz0gXCIgXCI7XG4gICAgICB9XG4gICAgICBzdHIgKz0gdHJpbW1lZExpbmU7XG4gICAgfVxuICB9XG4gIGlmIChzdHIpIGFyZ3MucHVzaCgoMCwgX2luZGV4Mi5pbmhlcml0cykoKDAsIF9pbmRleC5zdHJpbmdMaXRlcmFsKShzdHIpLCBjaGlsZCkpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGVhbkpTWEVsZW1lbnRMaXRlcmFsQ2hpbGQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53043\n')},96616:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = shallowEqual;\nfunction shallowEqual(actual, expected) {\n  const keys = Object.keys(expected);\n  for (const key of keys) {\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=shallowEqual.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTY2MTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdXRpbHMvc2hhbGxvd0VxdWFsLmpzP2FiMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBzaGFsbG93RXF1YWw7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZXhwZWN0ZWQpO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgaWYgKGFjdHVhbFtrZXldICE9PSBleHBlY3RlZFtrZXldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFsbG93RXF1YWwuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///96616\n')},3937:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = buildMatchMemberExpression;\nvar _matchesPattern = __webpack_require__(94965);\nfunction buildMatchMemberExpression(match, allowPartial) {\n  const parts = match.split(".");\n  return member => (0, _matchesPattern.default)(member, parts, allowPartial);\n}\n\n//# sourceMappingURL=buildMatchMemberExpression.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkzNy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLHNCQUFzQixtQkFBTyxDQUFDLEtBQXFCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24uanM/YmQ1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uO1xudmFyIF9tYXRjaGVzUGF0dGVybiA9IHJlcXVpcmUoXCIuL21hdGNoZXNQYXR0ZXJuLmpzXCIpO1xuZnVuY3Rpb24gYnVpbGRNYXRjaE1lbWJlckV4cHJlc3Npb24obWF0Y2gsIGFsbG93UGFydGlhbCkge1xuICBjb25zdCBwYXJ0cyA9IG1hdGNoLnNwbGl0KFwiLlwiKTtcbiAgcmV0dXJuIG1lbWJlciA9PiAoMCwgX21hdGNoZXNQYXR0ZXJuLmRlZmF1bHQpKG1lbWJlciwgcGFydHMsIGFsbG93UGFydGlhbCk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3937\n')},98960:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports.isAccessor = isAccessor;\nexports.isAnyTypeAnnotation = isAnyTypeAnnotation;\nexports.isArgumentPlaceholder = isArgumentPlaceholder;\nexports.isArrayExpression = isArrayExpression;\nexports.isArrayPattern = isArrayPattern;\nexports.isArrayTypeAnnotation = isArrayTypeAnnotation;\nexports.isArrowFunctionExpression = isArrowFunctionExpression;\nexports.isAssignmentExpression = isAssignmentExpression;\nexports.isAssignmentPattern = isAssignmentPattern;\nexports.isAwaitExpression = isAwaitExpression;\nexports.isBigIntLiteral = isBigIntLiteral;\nexports.isBinary = isBinary;\nexports.isBinaryExpression = isBinaryExpression;\nexports.isBindExpression = isBindExpression;\nexports.isBlock = isBlock;\nexports.isBlockParent = isBlockParent;\nexports.isBlockStatement = isBlockStatement;\nexports.isBooleanLiteral = isBooleanLiteral;\nexports.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;\nexports.isBooleanTypeAnnotation = isBooleanTypeAnnotation;\nexports.isBreakStatement = isBreakStatement;\nexports.isCallExpression = isCallExpression;\nexports.isCatchClause = isCatchClause;\nexports.isClass = isClass;\nexports.isClassAccessorProperty = isClassAccessorProperty;\nexports.isClassBody = isClassBody;\nexports.isClassDeclaration = isClassDeclaration;\nexports.isClassExpression = isClassExpression;\nexports.isClassImplements = isClassImplements;\nexports.isClassMethod = isClassMethod;\nexports.isClassPrivateMethod = isClassPrivateMethod;\nexports.isClassPrivateProperty = isClassPrivateProperty;\nexports.isClassProperty = isClassProperty;\nexports.isCompletionStatement = isCompletionStatement;\nexports.isConditional = isConditional;\nexports.isConditionalExpression = isConditionalExpression;\nexports.isContinueStatement = isContinueStatement;\nexports.isDebuggerStatement = isDebuggerStatement;\nexports.isDecimalLiteral = isDecimalLiteral;\nexports.isDeclaration = isDeclaration;\nexports.isDeclareClass = isDeclareClass;\nexports.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;\nexports.isDeclareExportDeclaration = isDeclareExportDeclaration;\nexports.isDeclareFunction = isDeclareFunction;\nexports.isDeclareInterface = isDeclareInterface;\nexports.isDeclareModule = isDeclareModule;\nexports.isDeclareModuleExports = isDeclareModuleExports;\nexports.isDeclareOpaqueType = isDeclareOpaqueType;\nexports.isDeclareTypeAlias = isDeclareTypeAlias;\nexports.isDeclareVariable = isDeclareVariable;\nexports.isDeclaredPredicate = isDeclaredPredicate;\nexports.isDecorator = isDecorator;\nexports.isDirective = isDirective;\nexports.isDirectiveLiteral = isDirectiveLiteral;\nexports.isDoExpression = isDoExpression;\nexports.isDoWhileStatement = isDoWhileStatement;\nexports.isEmptyStatement = isEmptyStatement;\nexports.isEmptyTypeAnnotation = isEmptyTypeAnnotation;\nexports.isEnumBody = isEnumBody;\nexports.isEnumBooleanBody = isEnumBooleanBody;\nexports.isEnumBooleanMember = isEnumBooleanMember;\nexports.isEnumDeclaration = isEnumDeclaration;\nexports.isEnumDefaultedMember = isEnumDefaultedMember;\nexports.isEnumMember = isEnumMember;\nexports.isEnumNumberBody = isEnumNumberBody;\nexports.isEnumNumberMember = isEnumNumberMember;\nexports.isEnumStringBody = isEnumStringBody;\nexports.isEnumStringMember = isEnumStringMember;\nexports.isEnumSymbolBody = isEnumSymbolBody;\nexports.isExistsTypeAnnotation = isExistsTypeAnnotation;\nexports.isExportAllDeclaration = isExportAllDeclaration;\nexports.isExportDeclaration = isExportDeclaration;\nexports.isExportDefaultDeclaration = isExportDefaultDeclaration;\nexports.isExportDefaultSpecifier = isExportDefaultSpecifier;\nexports.isExportNamedDeclaration = isExportNamedDeclaration;\nexports.isExportNamespaceSpecifier = isExportNamespaceSpecifier;\nexports.isExportSpecifier = isExportSpecifier;\nexports.isExpression = isExpression;\nexports.isExpressionStatement = isExpressionStatement;\nexports.isExpressionWrapper = isExpressionWrapper;\nexports.isFile = isFile;\nexports.isFlow = isFlow;\nexports.isFlowBaseAnnotation = isFlowBaseAnnotation;\nexports.isFlowDeclaration = isFlowDeclaration;\nexports.isFlowPredicate = isFlowPredicate;\nexports.isFlowType = isFlowType;\nexports.isFor = isFor;\nexports.isForInStatement = isForInStatement;\nexports.isForOfStatement = isForOfStatement;\nexports.isForStatement = isForStatement;\nexports.isForXStatement = isForXStatement;\nexports.isFunction = isFunction;\nexports.isFunctionDeclaration = isFunctionDeclaration;\nexports.isFunctionExpression = isFunctionExpression;\nexports.isFunctionParent = isFunctionParent;\nexports.isFunctionTypeAnnotation = isFunctionTypeAnnotation;\nexports.isFunctionTypeParam = isFunctionTypeParam;\nexports.isGenericTypeAnnotation = isGenericTypeAnnotation;\nexports.isIdentifier = isIdentifier;\nexports.isIfStatement = isIfStatement;\nexports.isImmutable = isImmutable;\nexports.isImport = isImport;\nexports.isImportAttribute = isImportAttribute;\nexports.isImportDeclaration = isImportDeclaration;\nexports.isImportDefaultSpecifier = isImportDefaultSpecifier;\nexports.isImportExpression = isImportExpression;\nexports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;\nexports.isImportOrExportDeclaration = isImportOrExportDeclaration;\nexports.isImportSpecifier = isImportSpecifier;\nexports.isIndexedAccessType = isIndexedAccessType;\nexports.isInferredPredicate = isInferredPredicate;\nexports.isInterfaceDeclaration = isInterfaceDeclaration;\nexports.isInterfaceExtends = isInterfaceExtends;\nexports.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;\nexports.isInterpreterDirective = isInterpreterDirective;\nexports.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;\nexports.isJSX = isJSX;\nexports.isJSXAttribute = isJSXAttribute;\nexports.isJSXClosingElement = isJSXClosingElement;\nexports.isJSXClosingFragment = isJSXClosingFragment;\nexports.isJSXElement = isJSXElement;\nexports.isJSXEmptyExpression = isJSXEmptyExpression;\nexports.isJSXExpressionContainer = isJSXExpressionContainer;\nexports.isJSXFragment = isJSXFragment;\nexports.isJSXIdentifier = isJSXIdentifier;\nexports.isJSXMemberExpression = isJSXMemberExpression;\nexports.isJSXNamespacedName = isJSXNamespacedName;\nexports.isJSXOpeningElement = isJSXOpeningElement;\nexports.isJSXOpeningFragment = isJSXOpeningFragment;\nexports.isJSXSpreadAttribute = isJSXSpreadAttribute;\nexports.isJSXSpreadChild = isJSXSpreadChild;\nexports.isJSXText = isJSXText;\nexports.isLVal = isLVal;\nexports.isLabeledStatement = isLabeledStatement;\nexports.isLiteral = isLiteral;\nexports.isLogicalExpression = isLogicalExpression;\nexports.isLoop = isLoop;\nexports.isMemberExpression = isMemberExpression;\nexports.isMetaProperty = isMetaProperty;\nexports.isMethod = isMethod;\nexports.isMiscellaneous = isMiscellaneous;\nexports.isMixedTypeAnnotation = isMixedTypeAnnotation;\nexports.isModuleDeclaration = isModuleDeclaration;\nexports.isModuleExpression = isModuleExpression;\nexports.isModuleSpecifier = isModuleSpecifier;\nexports.isNewExpression = isNewExpression;\nexports.isNoop = isNoop;\nexports.isNullLiteral = isNullLiteral;\nexports.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;\nexports.isNullableTypeAnnotation = isNullableTypeAnnotation;\nexports.isNumberLiteral = isNumberLiteral;\nexports.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;\nexports.isNumberTypeAnnotation = isNumberTypeAnnotation;\nexports.isNumericLiteral = isNumericLiteral;\nexports.isObjectExpression = isObjectExpression;\nexports.isObjectMember = isObjectMember;\nexports.isObjectMethod = isObjectMethod;\nexports.isObjectPattern = isObjectPattern;\nexports.isObjectProperty = isObjectProperty;\nexports.isObjectTypeAnnotation = isObjectTypeAnnotation;\nexports.isObjectTypeCallProperty = isObjectTypeCallProperty;\nexports.isObjectTypeIndexer = isObjectTypeIndexer;\nexports.isObjectTypeInternalSlot = isObjectTypeInternalSlot;\nexports.isObjectTypeProperty = isObjectTypeProperty;\nexports.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;\nexports.isOpaqueType = isOpaqueType;\nexports.isOptionalCallExpression = isOptionalCallExpression;\nexports.isOptionalIndexedAccessType = isOptionalIndexedAccessType;\nexports.isOptionalMemberExpression = isOptionalMemberExpression;\nexports.isParenthesizedExpression = isParenthesizedExpression;\nexports.isPattern = isPattern;\nexports.isPatternLike = isPatternLike;\nexports.isPipelineBareFunction = isPipelineBareFunction;\nexports.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;\nexports.isPipelineTopicExpression = isPipelineTopicExpression;\nexports.isPlaceholder = isPlaceholder;\nexports.isPrivate = isPrivate;\nexports.isPrivateName = isPrivateName;\nexports.isProgram = isProgram;\nexports.isProperty = isProperty;\nexports.isPureish = isPureish;\nexports.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;\nexports.isRecordExpression = isRecordExpression;\nexports.isRegExpLiteral = isRegExpLiteral;\nexports.isRegexLiteral = isRegexLiteral;\nexports.isRestElement = isRestElement;\nexports.isRestProperty = isRestProperty;\nexports.isReturnStatement = isReturnStatement;\nexports.isScopable = isScopable;\nexports.isSequenceExpression = isSequenceExpression;\nexports.isSpreadElement = isSpreadElement;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStandardized = isStandardized;\nexports.isStatement = isStatement;\nexports.isStaticBlock = isStaticBlock;\nexports.isStringLiteral = isStringLiteral;\nexports.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;\nexports.isStringTypeAnnotation = isStringTypeAnnotation;\nexports.isSuper = isSuper;\nexports.isSwitchCase = isSwitchCase;\nexports.isSwitchStatement = isSwitchStatement;\nexports.isSymbolTypeAnnotation = isSymbolTypeAnnotation;\nexports.isTSAnyKeyword = isTSAnyKeyword;\nexports.isTSArrayType = isTSArrayType;\nexports.isTSAsExpression = isTSAsExpression;\nexports.isTSBaseType = isTSBaseType;\nexports.isTSBigIntKeyword = isTSBigIntKeyword;\nexports.isTSBooleanKeyword = isTSBooleanKeyword;\nexports.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;\nexports.isTSConditionalType = isTSConditionalType;\nexports.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;\nexports.isTSConstructorType = isTSConstructorType;\nexports.isTSDeclareFunction = isTSDeclareFunction;\nexports.isTSDeclareMethod = isTSDeclareMethod;\nexports.isTSEntityName = isTSEntityName;\nexports.isTSEnumDeclaration = isTSEnumDeclaration;\nexports.isTSEnumMember = isTSEnumMember;\nexports.isTSExportAssignment = isTSExportAssignment;\nexports.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;\nexports.isTSExternalModuleReference = isTSExternalModuleReference;\nexports.isTSFunctionType = isTSFunctionType;\nexports.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;\nexports.isTSImportType = isTSImportType;\nexports.isTSIndexSignature = isTSIndexSignature;\nexports.isTSIndexedAccessType = isTSIndexedAccessType;\nexports.isTSInferType = isTSInferType;\nexports.isTSInstantiationExpression = isTSInstantiationExpression;\nexports.isTSInterfaceBody = isTSInterfaceBody;\nexports.isTSInterfaceDeclaration = isTSInterfaceDeclaration;\nexports.isTSIntersectionType = isTSIntersectionType;\nexports.isTSIntrinsicKeyword = isTSIntrinsicKeyword;\nexports.isTSLiteralType = isTSLiteralType;\nexports.isTSMappedType = isTSMappedType;\nexports.isTSMethodSignature = isTSMethodSignature;\nexports.isTSModuleBlock = isTSModuleBlock;\nexports.isTSModuleDeclaration = isTSModuleDeclaration;\nexports.isTSNamedTupleMember = isTSNamedTupleMember;\nexports.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;\nexports.isTSNeverKeyword = isTSNeverKeyword;\nexports.isTSNonNullExpression = isTSNonNullExpression;\nexports.isTSNullKeyword = isTSNullKeyword;\nexports.isTSNumberKeyword = isTSNumberKeyword;\nexports.isTSObjectKeyword = isTSObjectKeyword;\nexports.isTSOptionalType = isTSOptionalType;\nexports.isTSParameterProperty = isTSParameterProperty;\nexports.isTSParenthesizedType = isTSParenthesizedType;\nexports.isTSPropertySignature = isTSPropertySignature;\nexports.isTSQualifiedName = isTSQualifiedName;\nexports.isTSRestType = isTSRestType;\nexports.isTSSatisfiesExpression = isTSSatisfiesExpression;\nexports.isTSStringKeyword = isTSStringKeyword;\nexports.isTSSymbolKeyword = isTSSymbolKeyword;\nexports.isTSThisType = isTSThisType;\nexports.isTSTupleType = isTSTupleType;\nexports.isTSType = isTSType;\nexports.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;\nexports.isTSTypeAnnotation = isTSTypeAnnotation;\nexports.isTSTypeAssertion = isTSTypeAssertion;\nexports.isTSTypeElement = isTSTypeElement;\nexports.isTSTypeLiteral = isTSTypeLiteral;\nexports.isTSTypeOperator = isTSTypeOperator;\nexports.isTSTypeParameter = isTSTypeParameter;\nexports.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;\nexports.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;\nexports.isTSTypePredicate = isTSTypePredicate;\nexports.isTSTypeQuery = isTSTypeQuery;\nexports.isTSTypeReference = isTSTypeReference;\nexports.isTSUndefinedKeyword = isTSUndefinedKeyword;\nexports.isTSUnionType = isTSUnionType;\nexports.isTSUnknownKeyword = isTSUnknownKeyword;\nexports.isTSVoidKeyword = isTSVoidKeyword;\nexports.isTaggedTemplateExpression = isTaggedTemplateExpression;\nexports.isTemplateElement = isTemplateElement;\nexports.isTemplateLiteral = isTemplateLiteral;\nexports.isTerminatorless = isTerminatorless;\nexports.isThisExpression = isThisExpression;\nexports.isThisTypeAnnotation = isThisTypeAnnotation;\nexports.isThrowStatement = isThrowStatement;\nexports.isTopicReference = isTopicReference;\nexports.isTryStatement = isTryStatement;\nexports.isTupleExpression = isTupleExpression;\nexports.isTupleTypeAnnotation = isTupleTypeAnnotation;\nexports.isTypeAlias = isTypeAlias;\nexports.isTypeAnnotation = isTypeAnnotation;\nexports.isTypeCastExpression = isTypeCastExpression;\nexports.isTypeParameter = isTypeParameter;\nexports.isTypeParameterDeclaration = isTypeParameterDeclaration;\nexports.isTypeParameterInstantiation = isTypeParameterInstantiation;\nexports.isTypeScript = isTypeScript;\nexports.isTypeofTypeAnnotation = isTypeofTypeAnnotation;\nexports.isUnaryExpression = isUnaryExpression;\nexports.isUnaryLike = isUnaryLike;\nexports.isUnionTypeAnnotation = isUnionTypeAnnotation;\nexports.isUpdateExpression = isUpdateExpression;\nexports.isUserWhitespacable = isUserWhitespacable;\nexports.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;\nexports.isVariableDeclaration = isVariableDeclaration;\nexports.isVariableDeclarator = isVariableDeclarator;\nexports.isVariance = isVariance;\nexports.isVoidTypeAnnotation = isVoidTypeAnnotation;\nexports.isWhile = isWhile;\nexports.isWhileStatement = isWhileStatement;\nexports.isWithStatement = isWithStatement;\nexports.isYieldExpression = isYieldExpression;\nvar _shallowEqual = __webpack_require__(96616);\nvar _deprecationWarning = __webpack_require__(63762);\nfunction isArrayExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ArrayExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "AssignmentExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BinaryExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterpreterDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== "InterpreterDirective") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirective(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Directive") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDirectiveLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DirectiveLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BlockStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBreakStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BreakStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "CallExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCatchClause(node, opts) {\n  if (!node) return false;\n  if (node.type !== "CatchClause") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditionalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ConditionalExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isContinueStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ContinueStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDebuggerStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DebuggerStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DoWhileStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EmptyStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExpressionStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFile(node, opts) {\n  if (!node) return false;\n  if (node.type !== "File") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForInStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ForInStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ForStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "FunctionDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "FunctionExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Identifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "IfStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLabeledStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "LabeledStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "StringLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumericLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NumericLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NullLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BooleanLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegExpLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "RegExpLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLogicalExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "LogicalExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "MemberExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNewExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NewExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProgram(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Program") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectMethod") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "RestElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isReturnStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ReturnStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSequenceExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "SequenceExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isParenthesizedExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ParenthesizedExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchCase(node, opts) {\n  if (!node) return false;\n  if (node.type !== "SwitchCase") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSwitchStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "SwitchStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ThisExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThrowStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ThrowStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTryStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TryStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "UnaryExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUpdateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "UpdateExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "VariableDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariableDeclarator(node, opts) {\n  if (!node) return false;\n  if (node.type !== "VariableDeclarator") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhileStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "WhileStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWithStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "WithStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAssignmentPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== "AssignmentPattern") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ArrayPattern") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrowFunctionExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ArrowFunctionExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportAllDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportDefaultDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamedDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportNamedDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForOfStatement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ForOfStatement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportDefaultSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportNamespaceSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMetaProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "MetaProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassMethod") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectPattern(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectPattern") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "SpreadElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSuper(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Super") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTaggedTemplateExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TaggedTemplateExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TemplateElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTemplateLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TemplateLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isYieldExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "YieldExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAwaitExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "AwaitExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImport(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Import") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBigIntLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BigIntLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportNamespaceSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportNamespaceSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "OptionalMemberExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalCallExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "OptionalCallExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassAccessorProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassAccessorProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassPrivateProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassPrivateMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassPrivateMethod") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivateName(node, opts) {\n  if (!node) return false;\n  if (node.type !== "PrivateName") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStaticBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== "StaticBlock") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAnyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "AnyTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArrayTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ArrayTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BooleanTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBooleanLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BooleanLiteralTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NullLiteralTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClassImplements(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ClassImplements") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareClass(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareClass") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareFunction") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareInterface(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareInterface") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModule(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareModule") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareModuleExports(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareModuleExports") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareTypeAlias") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareOpaqueType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareVariable(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareVariable") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareExportDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclareExportAllDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclareExportAllDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DeclaredPredicate") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExistsTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExistsTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "FunctionTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionTypeParam(node, opts) {\n  if (!node) return false;\n  if (node.type !== "FunctionTypeParam") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isGenericTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "GenericTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInferredPredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== "InferredPredicate") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceExtends(node, opts) {\n  if (!node) return false;\n  if (node.type !== "InterfaceExtends") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "InterfaceDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isInterfaceTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "InterfaceTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIntersectionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "IntersectionTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMixedTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "MixedTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEmptyTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EmptyTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNullableTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NullableTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NumberLiteralTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "NumberTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeInternalSlot(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeInternalSlot") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeCallProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeCallProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeIndexer(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeIndexer") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectTypeSpreadProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ObjectTypeSpreadProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOpaqueType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "OpaqueType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isQualifiedTypeIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "QualifiedTypeIdentifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringLiteralTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "StringLiteralTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStringTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "StringTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSymbolTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "SymbolTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isThisTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ThisTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TupleTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeofTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeofTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAlias(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeAlias") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeCastExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeCastExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeParameter") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeParameterDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TypeParameterInstantiation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnionTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "UnionTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVariance(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Variance") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isVoidTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "VoidTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumBooleanBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumNumberBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumStringBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumSymbolBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumSymbolBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBooleanMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumBooleanMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumNumberMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumNumberMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumStringMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumStringMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumDefaultedMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "EnumDefaultedMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "IndexedAccessType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isOptionalIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "OptionalIndexedAccessType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXAttribute") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXClosingElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXEmptyExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXEmptyExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXExpressionContainer(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXExpressionContainer") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadChild(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXSpreadChild") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXIdentifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXMemberExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXMemberExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXNamespacedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXNamespacedName") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningElement(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXOpeningElement") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXSpreadAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXSpreadAttribute") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXText(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXText") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXFragment") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXOpeningFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXOpeningFragment") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSXClosingFragment(node, opts) {\n  if (!node) return false;\n  if (node.type !== "JSXClosingFragment") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNoop(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Noop") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Placeholder") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isV8IntrinsicIdentifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "V8IntrinsicIdentifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isArgumentPlaceholder(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ArgumentPlaceholder") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBindExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "BindExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportAttribute(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ImportAttribute") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecorator(node, opts) {\n  if (!node) return false;\n  if (node.type !== "Decorator") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDoExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DoExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDefaultSpecifier(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ExportDefaultSpecifier") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRecordExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "RecordExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTupleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TupleExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDecimalLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "DecimalLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "ModuleExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TopicReference") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineTopicExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "PipelineTopicExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelineBareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== "PipelineBareFunction") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPipelinePrimaryTopicReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== "PipelinePrimaryTopicReference") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParameterProperty(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSParameterProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareFunction(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSDeclareFunction") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSDeclareMethod(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSDeclareMethod") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSQualifiedName(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSQualifiedName") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSCallSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSCallSignatureDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructSignatureDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSConstructSignatureDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSPropertySignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSPropertySignature") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMethodSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSMethodSignature") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexSignature(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSIndexSignature") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAnyKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSAnyKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBooleanKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSBooleanKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBigIntKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSBigIntKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntrinsicKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSIntrinsicKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNeverKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNeverKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNullKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNullKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNumberKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNumberKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSObjectKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSObjectKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSStringKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSStringKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSymbolKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSSymbolKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUndefinedKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSUndefinedKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnknownKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSUnknownKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSVoidKeyword(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSVoidKeyword") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSThisType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSThisType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSFunctionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSFunctionType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConstructorType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSConstructorType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeReference") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypePredicate(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypePredicate") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeQuery(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeQuery") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeLiteral(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSArrayType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSArrayType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTupleType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTupleType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSOptionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSOptionalType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSRestType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSRestType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamedTupleMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNamedTupleMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSUnionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSUnionType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIntersectionType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSIntersectionType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSConditionalType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSConditionalType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInferType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSInferType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSParenthesizedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSParenthesizedType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeOperator(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeOperator") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSIndexedAccessType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSIndexedAccessType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSMappedType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSMappedType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSLiteralType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSLiteralType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExpressionWithTypeArguments(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSExpressionWithTypeArguments") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSInterfaceDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInterfaceBody(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSInterfaceBody") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAliasDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeAliasDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSInstantiationExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSInstantiationExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSAsExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSAsExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSSatisfiesExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSSatisfiesExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAssertion(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeAssertion") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSEnumDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEnumMember(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSEnumMember") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSModuleDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSModuleBlock(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSModuleBlock") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportType(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSImportType") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSImportEqualsDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSImportEqualsDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExternalModuleReference(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSExternalModuleReference") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNonNullExpression(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNonNullExpression") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSExportAssignment(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSExportAssignment") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSNamespaceExportDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSNamespaceExportDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeAnnotation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeAnnotation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterInstantiation(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeParameterInstantiation") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameterDeclaration(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeParameterDeclaration") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeParameter(node, opts) {\n  if (!node) return false;\n  if (node.type !== "TSTypeParameter") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStandardized(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ArrayExpression":\n    case "AssignmentExpression":\n    case "BinaryExpression":\n    case "InterpreterDirective":\n    case "Directive":\n    case "DirectiveLiteral":\n    case "BlockStatement":\n    case "BreakStatement":\n    case "CallExpression":\n    case "CatchClause":\n    case "ConditionalExpression":\n    case "ContinueStatement":\n    case "DebuggerStatement":\n    case "DoWhileStatement":\n    case "EmptyStatement":\n    case "ExpressionStatement":\n    case "File":\n    case "ForInStatement":\n    case "ForStatement":\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "Identifier":\n    case "IfStatement":\n    case "LabeledStatement":\n    case "StringLiteral":\n    case "NumericLiteral":\n    case "NullLiteral":\n    case "BooleanLiteral":\n    case "RegExpLiteral":\n    case "LogicalExpression":\n    case "MemberExpression":\n    case "NewExpression":\n    case "Program":\n    case "ObjectExpression":\n    case "ObjectMethod":\n    case "ObjectProperty":\n    case "RestElement":\n    case "ReturnStatement":\n    case "SequenceExpression":\n    case "ParenthesizedExpression":\n    case "SwitchCase":\n    case "SwitchStatement":\n    case "ThisExpression":\n    case "ThrowStatement":\n    case "TryStatement":\n    case "UnaryExpression":\n    case "UpdateExpression":\n    case "VariableDeclaration":\n    case "VariableDeclarator":\n    case "WhileStatement":\n    case "WithStatement":\n    case "AssignmentPattern":\n    case "ArrayPattern":\n    case "ArrowFunctionExpression":\n    case "ClassBody":\n    case "ClassExpression":\n    case "ClassDeclaration":\n    case "ExportAllDeclaration":\n    case "ExportDefaultDeclaration":\n    case "ExportNamedDeclaration":\n    case "ExportSpecifier":\n    case "ForOfStatement":\n    case "ImportDeclaration":\n    case "ImportDefaultSpecifier":\n    case "ImportNamespaceSpecifier":\n    case "ImportSpecifier":\n    case "ImportExpression":\n    case "MetaProperty":\n    case "ClassMethod":\n    case "ObjectPattern":\n    case "SpreadElement":\n    case "Super":\n    case "TaggedTemplateExpression":\n    case "TemplateElement":\n    case "TemplateLiteral":\n    case "YieldExpression":\n    case "AwaitExpression":\n    case "Import":\n    case "BigIntLiteral":\n    case "ExportNamespaceSpecifier":\n    case "OptionalMemberExpression":\n    case "OptionalCallExpression":\n    case "ClassProperty":\n    case "ClassAccessorProperty":\n    case "ClassPrivateProperty":\n    case "ClassPrivateMethod":\n    case "PrivateName":\n    case "StaticBlock":\n      break;\n    case "Placeholder":\n      switch (node.expectedNode) {\n        case "Identifier":\n        case "StringLiteral":\n        case "BlockStatement":\n        case "ClassBody":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpression(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ArrayExpression":\n    case "AssignmentExpression":\n    case "BinaryExpression":\n    case "CallExpression":\n    case "ConditionalExpression":\n    case "FunctionExpression":\n    case "Identifier":\n    case "StringLiteral":\n    case "NumericLiteral":\n    case "NullLiteral":\n    case "BooleanLiteral":\n    case "RegExpLiteral":\n    case "LogicalExpression":\n    case "MemberExpression":\n    case "NewExpression":\n    case "ObjectExpression":\n    case "SequenceExpression":\n    case "ParenthesizedExpression":\n    case "ThisExpression":\n    case "UnaryExpression":\n    case "UpdateExpression":\n    case "ArrowFunctionExpression":\n    case "ClassExpression":\n    case "ImportExpression":\n    case "MetaProperty":\n    case "Super":\n    case "TaggedTemplateExpression":\n    case "TemplateLiteral":\n    case "YieldExpression":\n    case "AwaitExpression":\n    case "Import":\n    case "BigIntLiteral":\n    case "OptionalMemberExpression":\n    case "OptionalCallExpression":\n    case "TypeCastExpression":\n    case "JSXElement":\n    case "JSXFragment":\n    case "BindExpression":\n    case "DoExpression":\n    case "RecordExpression":\n    case "TupleExpression":\n    case "DecimalLiteral":\n    case "ModuleExpression":\n    case "TopicReference":\n    case "PipelineTopicExpression":\n    case "PipelineBareFunction":\n    case "PipelinePrimaryTopicReference":\n    case "TSInstantiationExpression":\n    case "TSAsExpression":\n    case "TSSatisfiesExpression":\n    case "TSTypeAssertion":\n    case "TSNonNullExpression":\n      break;\n    case "Placeholder":\n      switch (node.expectedNode) {\n        case "Expression":\n        case "Identifier":\n        case "StringLiteral":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBinary(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BinaryExpression":\n    case "LogicalExpression":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isScopable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BlockStatement":\n    case "CatchClause":\n    case "DoWhileStatement":\n    case "ForInStatement":\n    case "ForStatement":\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "Program":\n    case "ObjectMethod":\n    case "SwitchStatement":\n    case "WhileStatement":\n    case "ArrowFunctionExpression":\n    case "ClassExpression":\n    case "ClassDeclaration":\n    case "ForOfStatement":\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n    case "StaticBlock":\n    case "TSModuleBlock":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "BlockStatement") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlockParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BlockStatement":\n    case "CatchClause":\n    case "DoWhileStatement":\n    case "ForInStatement":\n    case "ForStatement":\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "Program":\n    case "ObjectMethod":\n    case "SwitchStatement":\n    case "WhileStatement":\n    case "ArrowFunctionExpression":\n    case "ForOfStatement":\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n    case "StaticBlock":\n    case "TSModuleBlock":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "BlockStatement") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isBlock(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BlockStatement":\n    case "Program":\n    case "TSModuleBlock":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "BlockStatement") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BlockStatement":\n    case "BreakStatement":\n    case "ContinueStatement":\n    case "DebuggerStatement":\n    case "DoWhileStatement":\n    case "EmptyStatement":\n    case "ExpressionStatement":\n    case "ForInStatement":\n    case "ForStatement":\n    case "FunctionDeclaration":\n    case "IfStatement":\n    case "LabeledStatement":\n    case "ReturnStatement":\n    case "SwitchStatement":\n    case "ThrowStatement":\n    case "TryStatement":\n    case "VariableDeclaration":\n    case "WhileStatement":\n    case "WithStatement":\n    case "ClassDeclaration":\n    case "ExportAllDeclaration":\n    case "ExportDefaultDeclaration":\n    case "ExportNamedDeclaration":\n    case "ForOfStatement":\n    case "ImportDeclaration":\n    case "DeclareClass":\n    case "DeclareFunction":\n    case "DeclareInterface":\n    case "DeclareModule":\n    case "DeclareModuleExports":\n    case "DeclareTypeAlias":\n    case "DeclareOpaqueType":\n    case "DeclareVariable":\n    case "DeclareExportDeclaration":\n    case "DeclareExportAllDeclaration":\n    case "InterfaceDeclaration":\n    case "OpaqueType":\n    case "TypeAlias":\n    case "EnumDeclaration":\n    case "TSDeclareFunction":\n    case "TSInterfaceDeclaration":\n    case "TSTypeAliasDeclaration":\n    case "TSEnumDeclaration":\n    case "TSModuleDeclaration":\n    case "TSImportEqualsDeclaration":\n    case "TSExportAssignment":\n    case "TSNamespaceExportDeclaration":\n      break;\n    case "Placeholder":\n      switch (node.expectedNode) {\n        case "Statement":\n        case "Declaration":\n        case "BlockStatement":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTerminatorless(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BreakStatement":\n    case "ContinueStatement":\n    case "ReturnStatement":\n    case "ThrowStatement":\n    case "YieldExpression":\n    case "AwaitExpression":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isCompletionStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "BreakStatement":\n    case "ContinueStatement":\n    case "ReturnStatement":\n    case "ThrowStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isConditional(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ConditionalExpression":\n    case "IfStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLoop(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "DoWhileStatement":\n    case "ForInStatement":\n    case "ForStatement":\n    case "WhileStatement":\n    case "ForOfStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isWhile(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "DoWhileStatement":\n    case "WhileStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExpressionWrapper(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ExpressionStatement":\n    case "ParenthesizedExpression":\n    case "TypeCastExpression":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ForInStatement":\n    case "ForStatement":\n    case "ForOfStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isForXStatement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ForInStatement":\n    case "ForOfStatement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunction(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "ObjectMethod":\n    case "ArrowFunctionExpression":\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFunctionParent(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "ObjectMethod":\n    case "ArrowFunctionExpression":\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n    case "StaticBlock":\n    case "TSModuleBlock":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPureish(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n    case "StringLiteral":\n    case "NumericLiteral":\n    case "NullLiteral":\n    case "BooleanLiteral":\n    case "RegExpLiteral":\n    case "ArrowFunctionExpression":\n    case "BigIntLiteral":\n    case "DecimalLiteral":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "StringLiteral") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "FunctionDeclaration":\n    case "VariableDeclaration":\n    case "ClassDeclaration":\n    case "ExportAllDeclaration":\n    case "ExportDefaultDeclaration":\n    case "ExportNamedDeclaration":\n    case "ImportDeclaration":\n    case "DeclareClass":\n    case "DeclareFunction":\n    case "DeclareInterface":\n    case "DeclareModule":\n    case "DeclareModuleExports":\n    case "DeclareTypeAlias":\n    case "DeclareOpaqueType":\n    case "DeclareVariable":\n    case "DeclareExportDeclaration":\n    case "DeclareExportAllDeclaration":\n    case "InterfaceDeclaration":\n    case "OpaqueType":\n    case "TypeAlias":\n    case "EnumDeclaration":\n    case "TSDeclareFunction":\n    case "TSInterfaceDeclaration":\n    case "TSTypeAliasDeclaration":\n    case "TSEnumDeclaration":\n    case "TSModuleDeclaration":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "Declaration") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPatternLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "Identifier":\n    case "RestElement":\n    case "AssignmentPattern":\n    case "ArrayPattern":\n    case "ObjectPattern":\n    case "TSAsExpression":\n    case "TSSatisfiesExpression":\n    case "TSTypeAssertion":\n    case "TSNonNullExpression":\n      break;\n    case "Placeholder":\n      switch (node.expectedNode) {\n        case "Pattern":\n        case "Identifier":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLVal(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "Identifier":\n    case "MemberExpression":\n    case "RestElement":\n    case "AssignmentPattern":\n    case "ArrayPattern":\n    case "ObjectPattern":\n    case "TSParameterProperty":\n    case "TSAsExpression":\n    case "TSSatisfiesExpression":\n    case "TSTypeAssertion":\n    case "TSNonNullExpression":\n      break;\n    case "Placeholder":\n      switch (node.expectedNode) {\n        case "Pattern":\n        case "Identifier":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSEntityName(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "Identifier":\n    case "TSQualifiedName":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "Identifier") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isLiteral(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "StringLiteral":\n    case "NumericLiteral":\n    case "NullLiteral":\n    case "BooleanLiteral":\n    case "RegExpLiteral":\n    case "TemplateLiteral":\n    case "BigIntLiteral":\n    case "DecimalLiteral":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "StringLiteral") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImmutable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "StringLiteral":\n    case "NumericLiteral":\n    case "NullLiteral":\n    case "BooleanLiteral":\n    case "BigIntLiteral":\n    case "JSXAttribute":\n    case "JSXClosingElement":\n    case "JSXElement":\n    case "JSXExpressionContainer":\n    case "JSXSpreadChild":\n    case "JSXOpeningElement":\n    case "JSXText":\n    case "JSXFragment":\n    case "JSXOpeningFragment":\n    case "JSXClosingFragment":\n    case "DecimalLiteral":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "StringLiteral") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUserWhitespacable(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ObjectMethod":\n    case "ObjectProperty":\n    case "ObjectTypeInternalSlot":\n    case "ObjectTypeCallProperty":\n    case "ObjectTypeIndexer":\n    case "ObjectTypeProperty":\n    case "ObjectTypeSpreadProperty":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMethod(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ObjectMethod":\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isObjectMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ObjectMethod":\n    case "ObjectProperty":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isProperty(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ObjectProperty":\n    case "ClassProperty":\n    case "ClassAccessorProperty":\n    case "ClassPrivateProperty":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isUnaryLike(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "UnaryExpression":\n    case "SpreadElement":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPattern(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "AssignmentPattern":\n    case "ArrayPattern":\n    case "ObjectPattern":\n      break;\n    case "Placeholder":\n      if (node.expectedNode === "Pattern") break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isClass(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ClassExpression":\n    case "ClassDeclaration":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isImportOrExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ExportAllDeclaration":\n    case "ExportDefaultDeclaration":\n    case "ExportNamedDeclaration":\n    case "ImportDeclaration":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isExportDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ExportAllDeclaration":\n    case "ExportDefaultDeclaration":\n    case "ExportNamedDeclaration":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleSpecifier(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ExportSpecifier":\n    case "ImportDefaultSpecifier":\n    case "ImportNamespaceSpecifier":\n    case "ImportSpecifier":\n    case "ExportNamespaceSpecifier":\n    case "ExportDefaultSpecifier":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isAccessor(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ClassAccessorProperty":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isPrivate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "ClassPrivateProperty":\n    case "ClassPrivateMethod":\n    case "PrivateName":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlow(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "AnyTypeAnnotation":\n    case "ArrayTypeAnnotation":\n    case "BooleanTypeAnnotation":\n    case "BooleanLiteralTypeAnnotation":\n    case "NullLiteralTypeAnnotation":\n    case "ClassImplements":\n    case "DeclareClass":\n    case "DeclareFunction":\n    case "DeclareInterface":\n    case "DeclareModule":\n    case "DeclareModuleExports":\n    case "DeclareTypeAlias":\n    case "DeclareOpaqueType":\n    case "DeclareVariable":\n    case "DeclareExportDeclaration":\n    case "DeclareExportAllDeclaration":\n    case "DeclaredPredicate":\n    case "ExistsTypeAnnotation":\n    case "FunctionTypeAnnotation":\n    case "FunctionTypeParam":\n    case "GenericTypeAnnotation":\n    case "InferredPredicate":\n    case "InterfaceExtends":\n    case "InterfaceDeclaration":\n    case "InterfaceTypeAnnotation":\n    case "IntersectionTypeAnnotation":\n    case "MixedTypeAnnotation":\n    case "EmptyTypeAnnotation":\n    case "NullableTypeAnnotation":\n    case "NumberLiteralTypeAnnotation":\n    case "NumberTypeAnnotation":\n    case "ObjectTypeAnnotation":\n    case "ObjectTypeInternalSlot":\n    case "ObjectTypeCallProperty":\n    case "ObjectTypeIndexer":\n    case "ObjectTypeProperty":\n    case "ObjectTypeSpreadProperty":\n    case "OpaqueType":\n    case "QualifiedTypeIdentifier":\n    case "StringLiteralTypeAnnotation":\n    case "StringTypeAnnotation":\n    case "SymbolTypeAnnotation":\n    case "ThisTypeAnnotation":\n    case "TupleTypeAnnotation":\n    case "TypeofTypeAnnotation":\n    case "TypeAlias":\n    case "TypeAnnotation":\n    case "TypeCastExpression":\n    case "TypeParameter":\n    case "TypeParameterDeclaration":\n    case "TypeParameterInstantiation":\n    case "UnionTypeAnnotation":\n    case "Variance":\n    case "VoidTypeAnnotation":\n    case "EnumDeclaration":\n    case "EnumBooleanBody":\n    case "EnumNumberBody":\n    case "EnumStringBody":\n    case "EnumSymbolBody":\n    case "EnumBooleanMember":\n    case "EnumNumberMember":\n    case "EnumStringMember":\n    case "EnumDefaultedMember":\n    case "IndexedAccessType":\n    case "OptionalIndexedAccessType":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "AnyTypeAnnotation":\n    case "ArrayTypeAnnotation":\n    case "BooleanTypeAnnotation":\n    case "BooleanLiteralTypeAnnotation":\n    case "NullLiteralTypeAnnotation":\n    case "ExistsTypeAnnotation":\n    case "FunctionTypeAnnotation":\n    case "GenericTypeAnnotation":\n    case "InterfaceTypeAnnotation":\n    case "IntersectionTypeAnnotation":\n    case "MixedTypeAnnotation":\n    case "EmptyTypeAnnotation":\n    case "NullableTypeAnnotation":\n    case "NumberLiteralTypeAnnotation":\n    case "NumberTypeAnnotation":\n    case "ObjectTypeAnnotation":\n    case "StringLiteralTypeAnnotation":\n    case "StringTypeAnnotation":\n    case "SymbolTypeAnnotation":\n    case "ThisTypeAnnotation":\n    case "TupleTypeAnnotation":\n    case "TypeofTypeAnnotation":\n    case "UnionTypeAnnotation":\n    case "VoidTypeAnnotation":\n    case "IndexedAccessType":\n    case "OptionalIndexedAccessType":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowBaseAnnotation(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "AnyTypeAnnotation":\n    case "BooleanTypeAnnotation":\n    case "NullLiteralTypeAnnotation":\n    case "MixedTypeAnnotation":\n    case "EmptyTypeAnnotation":\n    case "NumberTypeAnnotation":\n    case "StringTypeAnnotation":\n    case "SymbolTypeAnnotation":\n    case "ThisTypeAnnotation":\n    case "VoidTypeAnnotation":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowDeclaration(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "DeclareClass":\n    case "DeclareFunction":\n    case "DeclareInterface":\n    case "DeclareModule":\n    case "DeclareModuleExports":\n    case "DeclareTypeAlias":\n    case "DeclareOpaqueType":\n    case "DeclareVariable":\n    case "DeclareExportDeclaration":\n    case "DeclareExportAllDeclaration":\n    case "InterfaceDeclaration":\n    case "OpaqueType":\n    case "TypeAlias":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isFlowPredicate(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "DeclaredPredicate":\n    case "InferredPredicate":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumBody(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "EnumBooleanBody":\n    case "EnumNumberBody":\n    case "EnumStringBody":\n    case "EnumSymbolBody":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isEnumMember(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "EnumBooleanMember":\n    case "EnumNumberMember":\n    case "EnumStringMember":\n    case "EnumDefaultedMember":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isJSX(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "JSXAttribute":\n    case "JSXClosingElement":\n    case "JSXElement":\n    case "JSXEmptyExpression":\n    case "JSXExpressionContainer":\n    case "JSXSpreadChild":\n    case "JSXIdentifier":\n    case "JSXMemberExpression":\n    case "JSXNamespacedName":\n    case "JSXOpeningElement":\n    case "JSXSpreadAttribute":\n    case "JSXText":\n    case "JSXFragment":\n    case "JSXOpeningFragment":\n    case "JSXClosingFragment":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isMiscellaneous(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "Noop":\n    case "Placeholder":\n    case "V8IntrinsicIdentifier":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTypeScript(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "TSParameterProperty":\n    case "TSDeclareFunction":\n    case "TSDeclareMethod":\n    case "TSQualifiedName":\n    case "TSCallSignatureDeclaration":\n    case "TSConstructSignatureDeclaration":\n    case "TSPropertySignature":\n    case "TSMethodSignature":\n    case "TSIndexSignature":\n    case "TSAnyKeyword":\n    case "TSBooleanKeyword":\n    case "TSBigIntKeyword":\n    case "TSIntrinsicKeyword":\n    case "TSNeverKeyword":\n    case "TSNullKeyword":\n    case "TSNumberKeyword":\n    case "TSObjectKeyword":\n    case "TSStringKeyword":\n    case "TSSymbolKeyword":\n    case "TSUndefinedKeyword":\n    case "TSUnknownKeyword":\n    case "TSVoidKeyword":\n    case "TSThisType":\n    case "TSFunctionType":\n    case "TSConstructorType":\n    case "TSTypeReference":\n    case "TSTypePredicate":\n    case "TSTypeQuery":\n    case "TSTypeLiteral":\n    case "TSArrayType":\n    case "TSTupleType":\n    case "TSOptionalType":\n    case "TSRestType":\n    case "TSNamedTupleMember":\n    case "TSUnionType":\n    case "TSIntersectionType":\n    case "TSConditionalType":\n    case "TSInferType":\n    case "TSParenthesizedType":\n    case "TSTypeOperator":\n    case "TSIndexedAccessType":\n    case "TSMappedType":\n    case "TSLiteralType":\n    case "TSExpressionWithTypeArguments":\n    case "TSInterfaceDeclaration":\n    case "TSInterfaceBody":\n    case "TSTypeAliasDeclaration":\n    case "TSInstantiationExpression":\n    case "TSAsExpression":\n    case "TSSatisfiesExpression":\n    case "TSTypeAssertion":\n    case "TSEnumDeclaration":\n    case "TSEnumMember":\n    case "TSModuleDeclaration":\n    case "TSModuleBlock":\n    case "TSImportType":\n    case "TSImportEqualsDeclaration":\n    case "TSExternalModuleReference":\n    case "TSNonNullExpression":\n    case "TSExportAssignment":\n    case "TSNamespaceExportDeclaration":\n    case "TSTypeAnnotation":\n    case "TSTypeParameterInstantiation":\n    case "TSTypeParameterDeclaration":\n    case "TSTypeParameter":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSTypeElement(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "TSCallSignatureDeclaration":\n    case "TSConstructSignatureDeclaration":\n    case "TSPropertySignature":\n    case "TSMethodSignature":\n    case "TSIndexSignature":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "TSAnyKeyword":\n    case "TSBooleanKeyword":\n    case "TSBigIntKeyword":\n    case "TSIntrinsicKeyword":\n    case "TSNeverKeyword":\n    case "TSNullKeyword":\n    case "TSNumberKeyword":\n    case "TSObjectKeyword":\n    case "TSStringKeyword":\n    case "TSSymbolKeyword":\n    case "TSUndefinedKeyword":\n    case "TSUnknownKeyword":\n    case "TSVoidKeyword":\n    case "TSThisType":\n    case "TSFunctionType":\n    case "TSConstructorType":\n    case "TSTypeReference":\n    case "TSTypePredicate":\n    case "TSTypeQuery":\n    case "TSTypeLiteral":\n    case "TSArrayType":\n    case "TSTupleType":\n    case "TSOptionalType":\n    case "TSRestType":\n    case "TSUnionType":\n    case "TSIntersectionType":\n    case "TSConditionalType":\n    case "TSInferType":\n    case "TSParenthesizedType":\n    case "TSTypeOperator":\n    case "TSIndexedAccessType":\n    case "TSMappedType":\n    case "TSLiteralType":\n    case "TSExpressionWithTypeArguments":\n    case "TSImportType":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isTSBaseType(node, opts) {\n  if (!node) return false;\n  switch (node.type) {\n    case "TSAnyKeyword":\n    case "TSBooleanKeyword":\n    case "TSBigIntKeyword":\n    case "TSIntrinsicKeyword":\n    case "TSNeverKeyword":\n    case "TSNullKeyword":\n    case "TSNumberKeyword":\n    case "TSObjectKeyword":\n    case "TSStringKeyword":\n    case "TSSymbolKeyword":\n    case "TSUndefinedKeyword":\n    case "TSUnknownKeyword":\n    case "TSVoidKeyword":\n    case "TSThisType":\n    case "TSLiteralType":\n      break;\n    default:\n      return false;\n  }\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isNumberLiteral(node, opts) {\n  (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");\n  if (!node) return false;\n  if (node.type !== "NumberLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRegexLiteral(node, opts) {\n  (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");\n  if (!node) return false;\n  if (node.type !== "RegexLiteral") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isRestProperty(node, opts) {\n  (0, _deprecationWarning.default)("isRestProperty", "isRestElement");\n  if (!node) return false;\n  if (node.type !== "RestProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isSpreadProperty(node, opts) {\n  (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");\n  if (!node) return false;\n  if (node.type !== "SpreadProperty") return false;\n  return opts == null || (0, _shallowEqual.default)(node, opts);\n}\nfunction isModuleDeclaration(node, opts) {\n  (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");\n  return isImportOrExportDeclaration(node, opts);\n}\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg5NjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWtCO0FBQ2xCLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixnQkFBZ0I7QUFDaEIsMEJBQTBCO0FBQzFCLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2YscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsc0NBQXNDO0FBQ3RDLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHFCQUFxQjtBQUNyQixlQUFlO0FBQ2YsK0JBQStCO0FBQy9CLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5Qix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLHFCQUFxQjtBQUNyQiwrQkFBK0I7QUFDL0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0IsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQiwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCLGtCQUFrQjtBQUNsQix5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0Isb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5QiwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixjQUFjO0FBQ2QsY0FBYztBQUNkLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2Isd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLGtCQUFrQjtBQUNsQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QixnQ0FBZ0M7QUFDaEMsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixnQkFBZ0I7QUFDaEIseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsMEJBQTBCO0FBQzFCLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkMseUJBQXlCO0FBQ3pCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQixpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLG9DQUFvQztBQUNwQyxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsb0JBQW9CO0FBQ3BCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCLHVCQUF1QjtBQUN2Qiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4QixpQkFBaUI7QUFDakIsY0FBYztBQUNkLDBCQUEwQjtBQUMxQixpQkFBaUI7QUFDakIsMkJBQTJCO0FBQzNCLGNBQWM7QUFDZCwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLGdCQUFnQjtBQUNoQix1QkFBdUI7QUFDdkIsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQiwwQkFBMEI7QUFDMUIseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsdUJBQXVCO0FBQ3ZCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQixzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEMsb0JBQW9CO0FBQ3BCLGdDQUFnQztBQUNoQyxtQ0FBbUM7QUFDbkMsa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLDhCQUE4QjtBQUM5Qix1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBQ2pDLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGlDQUFpQztBQUNqQywwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEIsNEJBQTRCO0FBQzVCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHFDQUFxQztBQUNyQyw4QkFBOEI7QUFDOUIsZUFBZTtBQUNmLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCLG9CQUFvQjtBQUNwQix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLG9DQUFvQztBQUNwQywyQkFBMkI7QUFDM0IseUNBQXlDO0FBQ3pDLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0Isc0JBQXNCO0FBQ3RCLDRCQUE0QjtBQUM1Qix1Q0FBdUM7QUFDdkMsbUNBQW1DO0FBQ25DLHdCQUF3QjtBQUN4QixtQ0FBbUM7QUFDbkMsc0JBQXNCO0FBQ3RCLDBCQUEwQjtBQUMxQiw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLG1DQUFtQztBQUNuQyx5QkFBeUI7QUFDekIsZ0NBQWdDO0FBQ2hDLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsc0NBQXNDO0FBQ3RDLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixvQkFBb0I7QUFDcEIsK0JBQStCO0FBQy9CLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixnQkFBZ0I7QUFDaEIsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQix5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHFCQUFxQjtBQUNyQiwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLGtDQUFrQztBQUNsQyx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsbUJBQW1CO0FBQ25CLHdCQUF3QjtBQUN4Qiw0QkFBNEI7QUFDNUIsdUJBQXVCO0FBQ3ZCLGtDQUFrQztBQUNsQyxvQ0FBb0M7QUFDcEMsb0JBQW9CO0FBQ3BCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsbUJBQW1CO0FBQ25CLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCLGtCQUFrQjtBQUNsQiw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLEtBQTZCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLEtBQW1DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2dlbmVyYXRlZC9pbmRleC5qcz9iMTgwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5pc0FjY2Vzc29yID0gaXNBY2Nlc3NvcjtcbmV4cG9ydHMuaXNBbnlUeXBlQW5ub3RhdGlvbiA9IGlzQW55VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQXJndW1lbnRQbGFjZWhvbGRlciA9IGlzQXJndW1lbnRQbGFjZWhvbGRlcjtcbmV4cG9ydHMuaXNBcnJheUV4cHJlc3Npb24gPSBpc0FycmF5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBcnJheVBhdHRlcm4gPSBpc0FycmF5UGF0dGVybjtcbmV4cG9ydHMuaXNBcnJheVR5cGVBbm5vdGF0aW9uID0gaXNBcnJheVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNBc3NpZ25tZW50RXhwcmVzc2lvbiA9IGlzQXNzaWdubWVudEV4cHJlc3Npb247XG5leHBvcnRzLmlzQXNzaWdubWVudFBhdHRlcm4gPSBpc0Fzc2lnbm1lbnRQYXR0ZXJuO1xuZXhwb3J0cy5pc0F3YWl0RXhwcmVzc2lvbiA9IGlzQXdhaXRFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0JpZ0ludExpdGVyYWwgPSBpc0JpZ0ludExpdGVyYWw7XG5leHBvcnRzLmlzQmluYXJ5ID0gaXNCaW5hcnk7XG5leHBvcnRzLmlzQmluYXJ5RXhwcmVzc2lvbiA9IGlzQmluYXJ5RXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNCaW5kRXhwcmVzc2lvbiA9IGlzQmluZEV4cHJlc3Npb247XG5leHBvcnRzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuZXhwb3J0cy5pc0Jsb2NrUGFyZW50ID0gaXNCbG9ja1BhcmVudDtcbmV4cG9ydHMuaXNCbG9ja1N0YXRlbWVudCA9IGlzQmxvY2tTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQm9vbGVhbkxpdGVyYWwgPSBpc0Jvb2xlYW5MaXRlcmFsO1xuZXhwb3J0cy5pc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb24gPSBpc0Jvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQm9vbGVhblR5cGVBbm5vdGF0aW9uID0gaXNCb29sZWFuVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzQnJlYWtTdGF0ZW1lbnQgPSBpc0JyZWFrU3RhdGVtZW50O1xuZXhwb3J0cy5pc0NhbGxFeHByZXNzaW9uID0gaXNDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNDYXRjaENsYXVzZSA9IGlzQ2F0Y2hDbGF1c2U7XG5leHBvcnRzLmlzQ2xhc3MgPSBpc0NsYXNzO1xuZXhwb3J0cy5pc0NsYXNzQWNjZXNzb3JQcm9wZXJ0eSA9IGlzQ2xhc3NBY2Nlc3NvclByb3BlcnR5O1xuZXhwb3J0cy5pc0NsYXNzQm9keSA9IGlzQ2xhc3NCb2R5O1xuZXhwb3J0cy5pc0NsYXNzRGVjbGFyYXRpb24gPSBpc0NsYXNzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzQ2xhc3NFeHByZXNzaW9uID0gaXNDbGFzc0V4cHJlc3Npb247XG5leHBvcnRzLmlzQ2xhc3NJbXBsZW1lbnRzID0gaXNDbGFzc0ltcGxlbWVudHM7XG5leHBvcnRzLmlzQ2xhc3NNZXRob2QgPSBpc0NsYXNzTWV0aG9kO1xuZXhwb3J0cy5pc0NsYXNzUHJpdmF0ZU1ldGhvZCA9IGlzQ2xhc3NQcml2YXRlTWV0aG9kO1xuZXhwb3J0cy5pc0NsYXNzUHJpdmF0ZVByb3BlcnR5ID0gaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eTtcbmV4cG9ydHMuaXNDbGFzc1Byb3BlcnR5ID0gaXNDbGFzc1Byb3BlcnR5O1xuZXhwb3J0cy5pc0NvbXBsZXRpb25TdGF0ZW1lbnQgPSBpc0NvbXBsZXRpb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmlzQ29uZGl0aW9uYWwgPSBpc0NvbmRpdGlvbmFsO1xuZXhwb3J0cy5pc0NvbmRpdGlvbmFsRXhwcmVzc2lvbiA9IGlzQ29uZGl0aW9uYWxFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0NvbnRpbnVlU3RhdGVtZW50ID0gaXNDb250aW51ZVN0YXRlbWVudDtcbmV4cG9ydHMuaXNEZWJ1Z2dlclN0YXRlbWVudCA9IGlzRGVidWdnZXJTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRGVjaW1hbExpdGVyYWwgPSBpc0RlY2ltYWxMaXRlcmFsO1xuZXhwb3J0cy5pc0RlY2xhcmF0aW9uID0gaXNEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlQ2xhc3MgPSBpc0RlY2xhcmVDbGFzcztcbmV4cG9ydHMuaXNEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24gPSBpc0RlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24gPSBpc0RlY2xhcmVFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlRnVuY3Rpb24gPSBpc0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNEZWNsYXJlSW50ZXJmYWNlID0gaXNEZWNsYXJlSW50ZXJmYWNlO1xuZXhwb3J0cy5pc0RlY2xhcmVNb2R1bGUgPSBpc0RlY2xhcmVNb2R1bGU7XG5leHBvcnRzLmlzRGVjbGFyZU1vZHVsZUV4cG9ydHMgPSBpc0RlY2xhcmVNb2R1bGVFeHBvcnRzO1xuZXhwb3J0cy5pc0RlY2xhcmVPcGFxdWVUeXBlID0gaXNEZWNsYXJlT3BhcXVlVHlwZTtcbmV4cG9ydHMuaXNEZWNsYXJlVHlwZUFsaWFzID0gaXNEZWNsYXJlVHlwZUFsaWFzO1xuZXhwb3J0cy5pc0RlY2xhcmVWYXJpYWJsZSA9IGlzRGVjbGFyZVZhcmlhYmxlO1xuZXhwb3J0cy5pc0RlY2xhcmVkUHJlZGljYXRlID0gaXNEZWNsYXJlZFByZWRpY2F0ZTtcbmV4cG9ydHMuaXNEZWNvcmF0b3IgPSBpc0RlY29yYXRvcjtcbmV4cG9ydHMuaXNEaXJlY3RpdmUgPSBpc0RpcmVjdGl2ZTtcbmV4cG9ydHMuaXNEaXJlY3RpdmVMaXRlcmFsID0gaXNEaXJlY3RpdmVMaXRlcmFsO1xuZXhwb3J0cy5pc0RvRXhwcmVzc2lvbiA9IGlzRG9FeHByZXNzaW9uO1xuZXhwb3J0cy5pc0RvV2hpbGVTdGF0ZW1lbnQgPSBpc0RvV2hpbGVTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRW1wdHlTdGF0ZW1lbnQgPSBpc0VtcHR5U3RhdGVtZW50O1xuZXhwb3J0cy5pc0VtcHR5VHlwZUFubm90YXRpb24gPSBpc0VtcHR5VHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRW51bUJvZHkgPSBpc0VudW1Cb2R5O1xuZXhwb3J0cy5pc0VudW1Cb29sZWFuQm9keSA9IGlzRW51bUJvb2xlYW5Cb2R5O1xuZXhwb3J0cy5pc0VudW1Cb29sZWFuTWVtYmVyID0gaXNFbnVtQm9vbGVhbk1lbWJlcjtcbmV4cG9ydHMuaXNFbnVtRGVjbGFyYXRpb24gPSBpc0VudW1EZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFbnVtRGVmYXVsdGVkTWVtYmVyID0gaXNFbnVtRGVmYXVsdGVkTWVtYmVyO1xuZXhwb3J0cy5pc0VudW1NZW1iZXIgPSBpc0VudW1NZW1iZXI7XG5leHBvcnRzLmlzRW51bU51bWJlckJvZHkgPSBpc0VudW1OdW1iZXJCb2R5O1xuZXhwb3J0cy5pc0VudW1OdW1iZXJNZW1iZXIgPSBpc0VudW1OdW1iZXJNZW1iZXI7XG5leHBvcnRzLmlzRW51bVN0cmluZ0JvZHkgPSBpc0VudW1TdHJpbmdCb2R5O1xuZXhwb3J0cy5pc0VudW1TdHJpbmdNZW1iZXIgPSBpc0VudW1TdHJpbmdNZW1iZXI7XG5leHBvcnRzLmlzRW51bVN5bWJvbEJvZHkgPSBpc0VudW1TeW1ib2xCb2R5O1xuZXhwb3J0cy5pc0V4aXN0c1R5cGVBbm5vdGF0aW9uID0gaXNFeGlzdHNUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnRBbGxEZWNsYXJhdGlvbiA9IGlzRXhwb3J0QWxsRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRXhwb3J0RGVjbGFyYXRpb24gPSBpc0V4cG9ydERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHREZWNsYXJhdGlvbiA9IGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIgPSBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXI7XG5leHBvcnRzLmlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbiA9IGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIgPSBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcjtcbmV4cG9ydHMuaXNFeHBvcnRTcGVjaWZpZXIgPSBpc0V4cG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaXNFeHByZXNzaW9uID0gaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0V4cHJlc3Npb25TdGF0ZW1lbnQgPSBpc0V4cHJlc3Npb25TdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRXhwcmVzc2lvbldyYXBwZXIgPSBpc0V4cHJlc3Npb25XcmFwcGVyO1xuZXhwb3J0cy5pc0ZpbGUgPSBpc0ZpbGU7XG5leHBvcnRzLmlzRmxvdyA9IGlzRmxvdztcbmV4cG9ydHMuaXNGbG93QmFzZUFubm90YXRpb24gPSBpc0Zsb3dCYXNlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNGbG93RGVjbGFyYXRpb24gPSBpc0Zsb3dEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNGbG93UHJlZGljYXRlID0gaXNGbG93UHJlZGljYXRlO1xuZXhwb3J0cy5pc0Zsb3dUeXBlID0gaXNGbG93VHlwZTtcbmV4cG9ydHMuaXNGb3IgPSBpc0ZvcjtcbmV4cG9ydHMuaXNGb3JJblN0YXRlbWVudCA9IGlzRm9ySW5TdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRm9yT2ZTdGF0ZW1lbnQgPSBpc0Zvck9mU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZvclN0YXRlbWVudCA9IGlzRm9yU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ZvclhTdGF0ZW1lbnQgPSBpc0ZvclhTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuZXhwb3J0cy5pc0Z1bmN0aW9uRGVjbGFyYXRpb24gPSBpc0Z1bmN0aW9uRGVjbGFyYXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25FeHByZXNzaW9uID0gaXNGdW5jdGlvbkV4cHJlc3Npb247XG5leHBvcnRzLmlzRnVuY3Rpb25QYXJlbnQgPSBpc0Z1bmN0aW9uUGFyZW50O1xuZXhwb3J0cy5pc0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSBpc0Z1bmN0aW9uVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzRnVuY3Rpb25UeXBlUGFyYW0gPSBpc0Z1bmN0aW9uVHlwZVBhcmFtO1xuZXhwb3J0cy5pc0dlbmVyaWNUeXBlQW5ub3RhdGlvbiA9IGlzR2VuZXJpY1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0lkZW50aWZpZXIgPSBpc0lkZW50aWZpZXI7XG5leHBvcnRzLmlzSWZTdGF0ZW1lbnQgPSBpc0lmU3RhdGVtZW50O1xuZXhwb3J0cy5pc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlO1xuZXhwb3J0cy5pc0ltcG9ydCA9IGlzSW1wb3J0O1xuZXhwb3J0cy5pc0ltcG9ydEF0dHJpYnV0ZSA9IGlzSW1wb3J0QXR0cmlidXRlO1xuZXhwb3J0cy5pc0ltcG9ydERlY2xhcmF0aW9uID0gaXNJbXBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyID0gaXNJbXBvcnREZWZhdWx0U3BlY2lmaWVyO1xuZXhwb3J0cy5pc0ltcG9ydEV4cHJlc3Npb24gPSBpc0ltcG9ydEV4cHJlc3Npb247XG5leHBvcnRzLmlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyID0gaXNJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI7XG5leHBvcnRzLmlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbiA9IGlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbXBvcnRTcGVjaWZpZXIgPSBpc0ltcG9ydFNwZWNpZmllcjtcbmV4cG9ydHMuaXNJbmRleGVkQWNjZXNzVHlwZSA9IGlzSW5kZXhlZEFjY2Vzc1R5cGU7XG5leHBvcnRzLmlzSW5mZXJyZWRQcmVkaWNhdGUgPSBpc0luZmVycmVkUHJlZGljYXRlO1xuZXhwb3J0cy5pc0ludGVyZmFjZURlY2xhcmF0aW9uID0gaXNJbnRlcmZhY2VEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcmZhY2VFeHRlbmRzID0gaXNJbnRlcmZhY2VFeHRlbmRzO1xuZXhwb3J0cy5pc0ludGVyZmFjZVR5cGVBbm5vdGF0aW9uID0gaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNJbnRlcnByZXRlckRpcmVjdGl2ZSA9IGlzSW50ZXJwcmV0ZXJEaXJlY3RpdmU7XG5leHBvcnRzLmlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24gPSBpc0ludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc0pTWCA9IGlzSlNYO1xuZXhwb3J0cy5pc0pTWEF0dHJpYnV0ZSA9IGlzSlNYQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWENsb3NpbmdFbGVtZW50ID0gaXNKU1hDbG9zaW5nRWxlbWVudDtcbmV4cG9ydHMuaXNKU1hDbG9zaW5nRnJhZ21lbnQgPSBpc0pTWENsb3NpbmdGcmFnbWVudDtcbmV4cG9ydHMuaXNKU1hFbGVtZW50ID0gaXNKU1hFbGVtZW50O1xuZXhwb3J0cy5pc0pTWEVtcHR5RXhwcmVzc2lvbiA9IGlzSlNYRW1wdHlFeHByZXNzaW9uO1xuZXhwb3J0cy5pc0pTWEV4cHJlc3Npb25Db250YWluZXIgPSBpc0pTWEV4cHJlc3Npb25Db250YWluZXI7XG5leHBvcnRzLmlzSlNYRnJhZ21lbnQgPSBpc0pTWEZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWElkZW50aWZpZXIgPSBpc0pTWElkZW50aWZpZXI7XG5leHBvcnRzLmlzSlNYTWVtYmVyRXhwcmVzc2lvbiA9IGlzSlNYTWVtYmVyRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNKU1hOYW1lc3BhY2VkTmFtZSA9IGlzSlNYTmFtZXNwYWNlZE5hbWU7XG5leHBvcnRzLmlzSlNYT3BlbmluZ0VsZW1lbnQgPSBpc0pTWE9wZW5pbmdFbGVtZW50O1xuZXhwb3J0cy5pc0pTWE9wZW5pbmdGcmFnbWVudCA9IGlzSlNYT3BlbmluZ0ZyYWdtZW50O1xuZXhwb3J0cy5pc0pTWFNwcmVhZEF0dHJpYnV0ZSA9IGlzSlNYU3ByZWFkQXR0cmlidXRlO1xuZXhwb3J0cy5pc0pTWFNwcmVhZENoaWxkID0gaXNKU1hTcHJlYWRDaGlsZDtcbmV4cG9ydHMuaXNKU1hUZXh0ID0gaXNKU1hUZXh0O1xuZXhwb3J0cy5pc0xWYWwgPSBpc0xWYWw7XG5leHBvcnRzLmlzTGFiZWxlZFN0YXRlbWVudCA9IGlzTGFiZWxlZFN0YXRlbWVudDtcbmV4cG9ydHMuaXNMaXRlcmFsID0gaXNMaXRlcmFsO1xuZXhwb3J0cy5pc0xvZ2ljYWxFeHByZXNzaW9uID0gaXNMb2dpY2FsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNMb29wID0gaXNMb29wO1xuZXhwb3J0cy5pc01lbWJlckV4cHJlc3Npb24gPSBpc01lbWJlckV4cHJlc3Npb247XG5leHBvcnRzLmlzTWV0YVByb3BlcnR5ID0gaXNNZXRhUHJvcGVydHk7XG5leHBvcnRzLmlzTWV0aG9kID0gaXNNZXRob2Q7XG5leHBvcnRzLmlzTWlzY2VsbGFuZW91cyA9IGlzTWlzY2VsbGFuZW91cztcbmV4cG9ydHMuaXNNaXhlZFR5cGVBbm5vdGF0aW9uID0gaXNNaXhlZFR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc01vZHVsZURlY2xhcmF0aW9uID0gaXNNb2R1bGVEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNNb2R1bGVFeHByZXNzaW9uID0gaXNNb2R1bGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc01vZHVsZVNwZWNpZmllciA9IGlzTW9kdWxlU3BlY2lmaWVyO1xuZXhwb3J0cy5pc05ld0V4cHJlc3Npb24gPSBpc05ld0V4cHJlc3Npb247XG5leHBvcnRzLmlzTm9vcCA9IGlzTm9vcDtcbmV4cG9ydHMuaXNOdWxsTGl0ZXJhbCA9IGlzTnVsbExpdGVyYWw7XG5leHBvcnRzLmlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbiA9IGlzTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uID0gaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWJlckxpdGVyYWwgPSBpc051bWJlckxpdGVyYWw7XG5leHBvcnRzLmlzTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzTnVtYmVyVHlwZUFubm90YXRpb24gPSBpc051bWJlclR5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc051bWVyaWNMaXRlcmFsID0gaXNOdW1lcmljTGl0ZXJhbDtcbmV4cG9ydHMuaXNPYmplY3RFeHByZXNzaW9uID0gaXNPYmplY3RFeHByZXNzaW9uO1xuZXhwb3J0cy5pc09iamVjdE1lbWJlciA9IGlzT2JqZWN0TWVtYmVyO1xuZXhwb3J0cy5pc09iamVjdE1ldGhvZCA9IGlzT2JqZWN0TWV0aG9kO1xuZXhwb3J0cy5pc09iamVjdFBhdHRlcm4gPSBpc09iamVjdFBhdHRlcm47XG5leHBvcnRzLmlzT2JqZWN0UHJvcGVydHkgPSBpc09iamVjdFByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVBbm5vdGF0aW9uID0gaXNPYmplY3RUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5ID0gaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVJbmRleGVyID0gaXNPYmplY3RUeXBlSW5kZXhlcjtcbmV4cG9ydHMuaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90ID0gaXNPYmplY3RUeXBlSW50ZXJuYWxTbG90O1xuZXhwb3J0cy5pc09iamVjdFR5cGVQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVByb3BlcnR5O1xuZXhwb3J0cy5pc09iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eSA9IGlzT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5O1xuZXhwb3J0cy5pc09wYXF1ZVR5cGUgPSBpc09wYXF1ZVR5cGU7XG5leHBvcnRzLmlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlID0gaXNPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5pc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQYXR0ZXJuID0gaXNQYXR0ZXJuO1xuZXhwb3J0cy5pc1BhdHRlcm5MaWtlID0gaXNQYXR0ZXJuTGlrZTtcbmV4cG9ydHMuaXNQaXBlbGluZUJhcmVGdW5jdGlvbiA9IGlzUGlwZWxpbmVCYXJlRnVuY3Rpb247XG5leHBvcnRzLmlzUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2UgPSBpc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlO1xuZXhwb3J0cy5pc1BpcGVsaW5lVG9waWNFeHByZXNzaW9uID0gaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNQbGFjZWhvbGRlciA9IGlzUGxhY2Vob2xkZXI7XG5leHBvcnRzLmlzUHJpdmF0ZSA9IGlzUHJpdmF0ZTtcbmV4cG9ydHMuaXNQcml2YXRlTmFtZSA9IGlzUHJpdmF0ZU5hbWU7XG5leHBvcnRzLmlzUHJvZ3JhbSA9IGlzUHJvZ3JhbTtcbmV4cG9ydHMuaXNQcm9wZXJ0eSA9IGlzUHJvcGVydHk7XG5leHBvcnRzLmlzUHVyZWlzaCA9IGlzUHVyZWlzaDtcbmV4cG9ydHMuaXNRdWFsaWZpZWRUeXBlSWRlbnRpZmllciA9IGlzUXVhbGlmaWVkVHlwZUlkZW50aWZpZXI7XG5leHBvcnRzLmlzUmVjb3JkRXhwcmVzc2lvbiA9IGlzUmVjb3JkRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNSZWdFeHBMaXRlcmFsID0gaXNSZWdFeHBMaXRlcmFsO1xuZXhwb3J0cy5pc1JlZ2V4TGl0ZXJhbCA9IGlzUmVnZXhMaXRlcmFsO1xuZXhwb3J0cy5pc1Jlc3RFbGVtZW50ID0gaXNSZXN0RWxlbWVudDtcbmV4cG9ydHMuaXNSZXN0UHJvcGVydHkgPSBpc1Jlc3RQcm9wZXJ0eTtcbmV4cG9ydHMuaXNSZXR1cm5TdGF0ZW1lbnQgPSBpc1JldHVyblN0YXRlbWVudDtcbmV4cG9ydHMuaXNTY29wYWJsZSA9IGlzU2NvcGFibGU7XG5leHBvcnRzLmlzU2VxdWVuY2VFeHByZXNzaW9uID0gaXNTZXF1ZW5jZUV4cHJlc3Npb247XG5leHBvcnRzLmlzU3ByZWFkRWxlbWVudCA9IGlzU3ByZWFkRWxlbWVudDtcbmV4cG9ydHMuaXNTcHJlYWRQcm9wZXJ0eSA9IGlzU3ByZWFkUHJvcGVydHk7XG5leHBvcnRzLmlzU3RhbmRhcmRpemVkID0gaXNTdGFuZGFyZGl6ZWQ7XG5leHBvcnRzLmlzU3RhdGVtZW50ID0gaXNTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzU3RhdGljQmxvY2sgPSBpc1N0YXRpY0Jsb2NrO1xuZXhwb3J0cy5pc1N0cmluZ0xpdGVyYWwgPSBpc1N0cmluZ0xpdGVyYWw7XG5leHBvcnRzLmlzU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uID0gaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzU3RyaW5nVHlwZUFubm90YXRpb24gPSBpc1N0cmluZ1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1N1cGVyID0gaXNTdXBlcjtcbmV4cG9ydHMuaXNTd2l0Y2hDYXNlID0gaXNTd2l0Y2hDYXNlO1xuZXhwb3J0cy5pc1N3aXRjaFN0YXRlbWVudCA9IGlzU3dpdGNoU3RhdGVtZW50O1xuZXhwb3J0cy5pc1N5bWJvbFR5cGVBbm5vdGF0aW9uID0gaXNTeW1ib2xUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUU0FueUtleXdvcmQgPSBpc1RTQW55S2V5d29yZDtcbmV4cG9ydHMuaXNUU0FycmF5VHlwZSA9IGlzVFNBcnJheVR5cGU7XG5leHBvcnRzLmlzVFNBc0V4cHJlc3Npb24gPSBpc1RTQXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTQmFzZVR5cGUgPSBpc1RTQmFzZVR5cGU7XG5leHBvcnRzLmlzVFNCaWdJbnRLZXl3b3JkID0gaXNUU0JpZ0ludEtleXdvcmQ7XG5leHBvcnRzLmlzVFNCb29sZWFuS2V5d29yZCA9IGlzVFNCb29sZWFuS2V5d29yZDtcbmV4cG9ydHMuaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbiA9IGlzVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNDb25kaXRpb25hbFR5cGUgPSBpc1RTQ29uZGl0aW9uYWxUeXBlO1xuZXhwb3J0cy5pc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb24gPSBpc1RTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNDb25zdHJ1Y3RvclR5cGUgPSBpc1RTQ29uc3RydWN0b3JUeXBlO1xuZXhwb3J0cy5pc1RTRGVjbGFyZUZ1bmN0aW9uID0gaXNUU0RlY2xhcmVGdW5jdGlvbjtcbmV4cG9ydHMuaXNUU0RlY2xhcmVNZXRob2QgPSBpc1RTRGVjbGFyZU1ldGhvZDtcbmV4cG9ydHMuaXNUU0VudGl0eU5hbWUgPSBpc1RTRW50aXR5TmFtZTtcbmV4cG9ydHMuaXNUU0VudW1EZWNsYXJhdGlvbiA9IGlzVFNFbnVtRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNFbnVtTWVtYmVyID0gaXNUU0VudW1NZW1iZXI7XG5leHBvcnRzLmlzVFNFeHBvcnRBc3NpZ25tZW50ID0gaXNUU0V4cG9ydEFzc2lnbm1lbnQ7XG5leHBvcnRzLmlzVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHMgPSBpc1RTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzO1xuZXhwb3J0cy5pc1RTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UgPSBpc1RTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2U7XG5leHBvcnRzLmlzVFNGdW5jdGlvblR5cGUgPSBpc1RTRnVuY3Rpb25UeXBlO1xuZXhwb3J0cy5pc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24gPSBpc1RTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNJbXBvcnRUeXBlID0gaXNUU0ltcG9ydFR5cGU7XG5leHBvcnRzLmlzVFNJbmRleFNpZ25hdHVyZSA9IGlzVFNJbmRleFNpZ25hdHVyZTtcbmV4cG9ydHMuaXNUU0luZGV4ZWRBY2Nlc3NUeXBlID0gaXNUU0luZGV4ZWRBY2Nlc3NUeXBlO1xuZXhwb3J0cy5pc1RTSW5mZXJUeXBlID0gaXNUU0luZmVyVHlwZTtcbmV4cG9ydHMuaXNUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uID0gaXNUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RTSW50ZXJmYWNlQm9keSA9IGlzVFNJbnRlcmZhY2VCb2R5O1xuZXhwb3J0cy5pc1RTSW50ZXJmYWNlRGVjbGFyYXRpb24gPSBpc1RTSW50ZXJmYWNlRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNJbnRlcnNlY3Rpb25UeXBlID0gaXNUU0ludGVyc2VjdGlvblR5cGU7XG5leHBvcnRzLmlzVFNJbnRyaW5zaWNLZXl3b3JkID0gaXNUU0ludHJpbnNpY0tleXdvcmQ7XG5leHBvcnRzLmlzVFNMaXRlcmFsVHlwZSA9IGlzVFNMaXRlcmFsVHlwZTtcbmV4cG9ydHMuaXNUU01hcHBlZFR5cGUgPSBpc1RTTWFwcGVkVHlwZTtcbmV4cG9ydHMuaXNUU01ldGhvZFNpZ25hdHVyZSA9IGlzVFNNZXRob2RTaWduYXR1cmU7XG5leHBvcnRzLmlzVFNNb2R1bGVCbG9jayA9IGlzVFNNb2R1bGVCbG9jaztcbmV4cG9ydHMuaXNUU01vZHVsZURlY2xhcmF0aW9uID0gaXNUU01vZHVsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTTmFtZWRUdXBsZU1lbWJlciA9IGlzVFNOYW1lZFR1cGxlTWVtYmVyO1xuZXhwb3J0cy5pc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb24gPSBpc1RTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNOZXZlcktleXdvcmQgPSBpc1RTTmV2ZXJLZXl3b3JkO1xuZXhwb3J0cy5pc1RTTm9uTnVsbEV4cHJlc3Npb24gPSBpc1RTTm9uTnVsbEV4cHJlc3Npb247XG5leHBvcnRzLmlzVFNOdWxsS2V5d29yZCA9IGlzVFNOdWxsS2V5d29yZDtcbmV4cG9ydHMuaXNUU051bWJlcktleXdvcmQgPSBpc1RTTnVtYmVyS2V5d29yZDtcbmV4cG9ydHMuaXNUU09iamVjdEtleXdvcmQgPSBpc1RTT2JqZWN0S2V5d29yZDtcbmV4cG9ydHMuaXNUU09wdGlvbmFsVHlwZSA9IGlzVFNPcHRpb25hbFR5cGU7XG5leHBvcnRzLmlzVFNQYXJhbWV0ZXJQcm9wZXJ0eSA9IGlzVFNQYXJhbWV0ZXJQcm9wZXJ0eTtcbmV4cG9ydHMuaXNUU1BhcmVudGhlc2l6ZWRUeXBlID0gaXNUU1BhcmVudGhlc2l6ZWRUeXBlO1xuZXhwb3J0cy5pc1RTUHJvcGVydHlTaWduYXR1cmUgPSBpc1RTUHJvcGVydHlTaWduYXR1cmU7XG5leHBvcnRzLmlzVFNRdWFsaWZpZWROYW1lID0gaXNUU1F1YWxpZmllZE5hbWU7XG5leHBvcnRzLmlzVFNSZXN0VHlwZSA9IGlzVFNSZXN0VHlwZTtcbmV4cG9ydHMuaXNUU1NhdGlzZmllc0V4cHJlc3Npb24gPSBpc1RTU2F0aXNmaWVzRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUU1N0cmluZ0tleXdvcmQgPSBpc1RTU3RyaW5nS2V5d29yZDtcbmV4cG9ydHMuaXNUU1N5bWJvbEtleXdvcmQgPSBpc1RTU3ltYm9sS2V5d29yZDtcbmV4cG9ydHMuaXNUU1RoaXNUeXBlID0gaXNUU1RoaXNUeXBlO1xuZXhwb3J0cy5pc1RTVHVwbGVUeXBlID0gaXNUU1R1cGxlVHlwZTtcbmV4cG9ydHMuaXNUU1R5cGUgPSBpc1RTVHlwZTtcbmV4cG9ydHMuaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uID0gaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1RTVHlwZUFubm90YXRpb24gPSBpc1RTVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVFNUeXBlQXNzZXJ0aW9uID0gaXNUU1R5cGVBc3NlcnRpb247XG5leHBvcnRzLmlzVFNUeXBlRWxlbWVudCA9IGlzVFNUeXBlRWxlbWVudDtcbmV4cG9ydHMuaXNUU1R5cGVMaXRlcmFsID0gaXNUU1R5cGVMaXRlcmFsO1xuZXhwb3J0cy5pc1RTVHlwZU9wZXJhdG9yID0gaXNUU1R5cGVPcGVyYXRvcjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXIgPSBpc1RTVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuaXNUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbiA9IGlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb247XG5leHBvcnRzLmlzVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGlzVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbjtcbmV4cG9ydHMuaXNUU1R5cGVQcmVkaWNhdGUgPSBpc1RTVHlwZVByZWRpY2F0ZTtcbmV4cG9ydHMuaXNUU1R5cGVRdWVyeSA9IGlzVFNUeXBlUXVlcnk7XG5leHBvcnRzLmlzVFNUeXBlUmVmZXJlbmNlID0gaXNUU1R5cGVSZWZlcmVuY2U7XG5leHBvcnRzLmlzVFNVbmRlZmluZWRLZXl3b3JkID0gaXNUU1VuZGVmaW5lZEtleXdvcmQ7XG5leHBvcnRzLmlzVFNVbmlvblR5cGUgPSBpc1RTVW5pb25UeXBlO1xuZXhwb3J0cy5pc1RTVW5rbm93bktleXdvcmQgPSBpc1RTVW5rbm93bktleXdvcmQ7XG5leHBvcnRzLmlzVFNWb2lkS2V5d29yZCA9IGlzVFNWb2lkS2V5d29yZDtcbmV4cG9ydHMuaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gPSBpc1RhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbjtcbmV4cG9ydHMuaXNUZW1wbGF0ZUVsZW1lbnQgPSBpc1RlbXBsYXRlRWxlbWVudDtcbmV4cG9ydHMuaXNUZW1wbGF0ZUxpdGVyYWwgPSBpc1RlbXBsYXRlTGl0ZXJhbDtcbmV4cG9ydHMuaXNUZXJtaW5hdG9ybGVzcyA9IGlzVGVybWluYXRvcmxlc3M7XG5leHBvcnRzLmlzVGhpc0V4cHJlc3Npb24gPSBpc1RoaXNFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1RoaXNUeXBlQW5ub3RhdGlvbiA9IGlzVGhpc1R5cGVBbm5vdGF0aW9uO1xuZXhwb3J0cy5pc1Rocm93U3RhdGVtZW50ID0gaXNUaHJvd1N0YXRlbWVudDtcbmV4cG9ydHMuaXNUb3BpY1JlZmVyZW5jZSA9IGlzVG9waWNSZWZlcmVuY2U7XG5leHBvcnRzLmlzVHJ5U3RhdGVtZW50ID0gaXNUcnlTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzVHVwbGVFeHByZXNzaW9uID0gaXNUdXBsZUV4cHJlc3Npb247XG5leHBvcnRzLmlzVHVwbGVUeXBlQW5ub3RhdGlvbiA9IGlzVHVwbGVUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNUeXBlQWxpYXMgPSBpc1R5cGVBbGlhcztcbmV4cG9ydHMuaXNUeXBlQW5ub3RhdGlvbiA9IGlzVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVHlwZUNhc3RFeHByZXNzaW9uID0gaXNUeXBlQ2FzdEV4cHJlc3Npb247XG5leHBvcnRzLmlzVHlwZVBhcmFtZXRlciA9IGlzVHlwZVBhcmFtZXRlcjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24gPSBpc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbjtcbmV4cG9ydHMuaXNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbiA9IGlzVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb247XG5leHBvcnRzLmlzVHlwZVNjcmlwdCA9IGlzVHlwZVNjcmlwdDtcbmV4cG9ydHMuaXNUeXBlb2ZUeXBlQW5ub3RhdGlvbiA9IGlzVHlwZW9mVHlwZUFubm90YXRpb247XG5leHBvcnRzLmlzVW5hcnlFeHByZXNzaW9uID0gaXNVbmFyeUV4cHJlc3Npb247XG5leHBvcnRzLmlzVW5hcnlMaWtlID0gaXNVbmFyeUxpa2U7XG5leHBvcnRzLmlzVW5pb25UeXBlQW5ub3RhdGlvbiA9IGlzVW5pb25UeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNVcGRhdGVFeHByZXNzaW9uID0gaXNVcGRhdGVFeHByZXNzaW9uO1xuZXhwb3J0cy5pc1VzZXJXaGl0ZXNwYWNhYmxlID0gaXNVc2VyV2hpdGVzcGFjYWJsZTtcbmV4cG9ydHMuaXNWOEludHJpbnNpY0lkZW50aWZpZXIgPSBpc1Y4SW50cmluc2ljSWRlbnRpZmllcjtcbmV4cG9ydHMuaXNWYXJpYWJsZURlY2xhcmF0aW9uID0gaXNWYXJpYWJsZURlY2xhcmF0aW9uO1xuZXhwb3J0cy5pc1ZhcmlhYmxlRGVjbGFyYXRvciA9IGlzVmFyaWFibGVEZWNsYXJhdG9yO1xuZXhwb3J0cy5pc1ZhcmlhbmNlID0gaXNWYXJpYW5jZTtcbmV4cG9ydHMuaXNWb2lkVHlwZUFubm90YXRpb24gPSBpc1ZvaWRUeXBlQW5ub3RhdGlvbjtcbmV4cG9ydHMuaXNXaGlsZSA9IGlzV2hpbGU7XG5leHBvcnRzLmlzV2hpbGVTdGF0ZW1lbnQgPSBpc1doaWxlU3RhdGVtZW50O1xuZXhwb3J0cy5pc1dpdGhTdGF0ZW1lbnQgPSBpc1dpdGhTdGF0ZW1lbnQ7XG5leHBvcnRzLmlzWWllbGRFeHByZXNzaW9uID0gaXNZaWVsZEV4cHJlc3Npb247XG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9zaGFsbG93RXF1YWwuanNcIik7XG52YXIgX2RlcHJlY2F0aW9uV2FybmluZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZXByZWNhdGlvbldhcm5pbmcuanNcIik7XG5mdW5jdGlvbiBpc0FycmF5RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycmF5RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmluYXJ5RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ludGVycHJldGVyRGlyZWN0aXZlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RpdmUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEaXJlY3RpdmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEaXJlY3RpdmVMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGlyZWN0aXZlTGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCcmVha1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJyZWFrU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NhdGNoQ2xhdXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2F0Y2hDbGF1c2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb25kaXRpb25hbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDb250aW51ZVN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNvbnRpbnVlU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVidWdnZXJTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWJ1Z2dlclN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RvV2hpbGVTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEb1doaWxlU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlTdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbXB0eVN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0V4cHJlc3Npb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRmlsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZpbGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGb3JJblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZvckluU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRm9yU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRm9yU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25EZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvbkV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0lmU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSWZTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMYWJlbGVkU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTGFiZWxlZFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTnVtZXJpY0xpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJOdW1lcmljTGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bGxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVsbExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJlZ0V4cExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMb2dpY2FsRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkxvZ2ljYWxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNOZXdFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTmV3RXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1Byb2dyYW0obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQcm9ncmFtXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFByb3BlcnR5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUmVzdEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJSZXN0RWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1JldHVyblN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJldHVyblN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1NlcXVlbmNlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTd2l0Y2hDYXNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3dpdGNoQ2FzZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N3aXRjaFN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlN3aXRjaFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RoaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVGhpc0V4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUaHJvd1N0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRocm93U3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHJ5U3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHJ5U3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVW5hcnlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVW5hcnlFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVXBkYXRlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlVwZGF0ZUV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNWYXJpYWJsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhYmxlRGVjbGFyYXRvcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1doaWxlU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiV2hpbGVTdGF0ZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNXaXRoU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiV2l0aFN0YXRlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Fzc2lnbm1lbnRQYXR0ZXJuKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQXNzaWdubWVudFBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBcnJheVBhdHRlcm4obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJBcnJheVBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NCb2R5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFeHBvcnRBbGxEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0TmFtZWREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFeHBvcnRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeHBvcnRTcGVjaWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGb3JPZlN0YXRlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkZvck9mU3RhdGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnREZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0U3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0RXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkltcG9ydEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNNZXRhUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJNZXRhUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc01ldGhvZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzTWV0aG9kXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0UGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFBhdHRlcm5cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTcHJlYWRFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N1cGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3VwZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZUVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUZW1wbGF0ZUVsZW1lbnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUZW1wbGF0ZUxpdGVyYWwobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUZW1wbGF0ZUxpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNZaWVsZEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJZaWVsZEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBd2FpdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJBd2FpdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbXBvcnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbXBvcnRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaWdJbnRMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQmlnSW50TGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0V4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NQcml2YXRlTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUHJpdmF0ZU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQcml2YXRlTmFtZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0YXRpY0Jsb2NrKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3RhdGljQmxvY2tcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNBbnlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFueVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycmF5VHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJCb29sZWFuVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bGxMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQ2xhc3NJbXBsZW1lbnRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiQ2xhc3NJbXBsZW1lbnRzXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUNsYXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZUNsYXNzXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZUZ1bmN0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjbGFyZUludGVyZmFjZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkRlY2xhcmVJbnRlcmZhY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlTW9kdWxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU1vZHVsZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlVHlwZUFsaWFzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZVR5cGVBbGlhc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2xhcmVPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjbGFyZU9wYXF1ZVR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlVmFyaWFibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlVmFyaWFibGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJlZFByZWRpY2F0ZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkRlY2xhcmVkUHJlZGljYXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhpc3RzVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25UeXBlUGFyYW0obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVQYXJhbVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0dlbmVyaWNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0luZmVycmVkUHJlZGljYXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW5mZXJyZWRQcmVkaWNhdGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmZhY2VFeHRlbmRzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJmYWNlRXh0ZW5kc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNJbnRlcmZhY2VUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc01peGVkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVtcHR5VHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNOdWxsYWJsZVR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc051bWJlclR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVtYmVyVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09iamVjdFR5cGVJbmRleGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT2JqZWN0VHlwZUluZGV4ZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPYmplY3RUeXBlU3ByZWFkUHJvcGVydHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNPcGFxdWVUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiT3BhcXVlVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1F1YWxpZmllZFR5cGVJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTdHJpbmdUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzU3ltYm9sVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RoaXNUeXBlQW5ub3RhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R1cGxlVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZW9mVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVBbGlhcyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR5cGVBbGlhc1wiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUeXBlQ2FzdEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUeXBlUGFyYW1ldGVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZVBhcmFtZXRlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVbmlvblR5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVW5pb25UeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ZhcmlhbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVmFyaWFuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNWb2lkVHlwZUFubm90YXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJWb2lkVHlwZUFubm90YXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtQm9vbGVhbkJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtQm9vbGVhbkJvZHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtTnVtYmVyQm9keShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1OdW1iZXJCb2R5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bVN0cmluZ0JvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtU3RyaW5nQm9keVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1TeW1ib2xCb2R5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRW51bVN5bWJvbEJvZHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtQm9vbGVhbk1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1Cb29sZWFuTWVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bU51bWJlck1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkVudW1OdW1iZXJNZW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFbnVtU3RyaW5nTWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRW51bVN0cmluZ01lbWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1EZWZhdWx0ZWRNZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJbmRleGVkQWNjZXNzVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc09wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYQXR0cmlidXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQ2xvc2luZ0VsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJKU1hDbG9zaW5nRWxlbWVudFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0pTWEVsZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJKU1hFbGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYRW1wdHlFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hTcHJlYWRDaGlsZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWFNwcmVhZENoaWxkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYSWRlbnRpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWElkZW50aWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hNZW1iZXJFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0pTWE5hbWVzcGFjZWROYW1lKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYTmFtZXNwYWNlZE5hbWVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hPcGVuaW5nRWxlbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWE9wZW5pbmdFbGVtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYU3ByZWFkQXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYU3ByZWFkQXR0cmlidXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYVGV4dChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWFRleHRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNKU1hGcmFnbWVudChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkpTWEZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYT3BlbmluZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYQ2xvc2luZ0ZyYWdtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTm9vcChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIk5vb3BcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlBsYWNlaG9sZGVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVjhJbnRyaW5zaWNJZGVudGlmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQXJndW1lbnRQbGFjZWhvbGRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFyZ3VtZW50UGxhY2Vob2xkZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCaW5kRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkJpbmRFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSW1wb3J0QXR0cmlidXRlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiSW1wb3J0QXR0cmlidXRlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRGVjb3JhdG9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjb3JhdG9yXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRG9FeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRG9FeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNSZWNvcmRFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUmVjb3JkRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1R1cGxlRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlR1cGxlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0RlY2ltYWxMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRGVjaW1hbExpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNNb2R1bGVFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTW9kdWxlRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVG9waWNSZWZlcmVuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQaXBlbGluZVRvcGljRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlBpcGVsaW5lVG9waWNFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUGlwZWxpbmVCYXJlRnVuY3Rpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1BpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1BhcmFtZXRlclByb3BlcnR5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTRGVjbGFyZUZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNEZWNsYXJlRnVuY3Rpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0RlY2xhcmVNZXRob2Qobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0RlY2xhcmVNZXRob2RcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1F1YWxpZmllZE5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1F1YWxpZmllZE5hbWVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1Byb3BlcnR5U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTWV0aG9kU2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNNZXRob2RTaWduYXR1cmVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0luZGV4U2lnbmF0dXJlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbmRleFNpZ25hdHVyZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQW55S2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQW55S2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQm9vbGVhbktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0Jvb2xlYW5LZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNCaWdJbnRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNCaWdJbnRLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbnRyaW5zaWNLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbnRyaW5zaWNLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNOZXZlcktleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU05ldmVyS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTnVsbEtleXdvcmQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU051bGxLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNOdW1iZXJLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNOdW1iZXJLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNPYmplY3RLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNPYmplY3RLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNTdHJpbmdLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNTdHJpbmdLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNTeW1ib2xLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNTeW1ib2xLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNVbmRlZmluZWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNVbmRlZmluZWRLZXl3b3JkXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNVbmtub3duS2V5d29yZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVW5rbm93bktleXdvcmRcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1ZvaWRLZXl3b3JkKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNWb2lkS2V5d29yZFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVGhpc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1RoaXNUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNGdW5jdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0Z1bmN0aW9uVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTQ29uc3RydWN0b3JUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVSZWZlcmVuY2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVSZWZlcmVuY2VcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVQcmVkaWNhdGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVRdWVyeShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZVF1ZXJ5XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZUxpdGVyYWxcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0FycmF5VHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQXJyYXlUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUdXBsZVR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R1cGxlVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTT3B0aW9uYWxUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNPcHRpb25hbFR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1Jlc3RUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNSZXN0VHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTmFtZWRUdXBsZU1lbWJlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVW5pb25UeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNVbmlvblR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0ludGVyc2VjdGlvblR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0ludGVyc2VjdGlvblR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0NvbmRpdGlvbmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTQ29uZGl0aW9uYWxUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbmZlclR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0luZmVyVHlwZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTUGFyZW50aGVzaXplZFR5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlT3BlcmF0b3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVPcGVyYXRvclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTSW5kZXhlZEFjY2Vzc1R5cGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNNYXBwZWRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNNYXBwZWRUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNMaXRlcmFsVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTGl0ZXJhbFR5cGVcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50cyhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbnRlcmZhY2VEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0ludGVyZmFjZUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0ludGVyZmFjZUJvZHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTSW5zdGFudGlhdGlvbkV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNBc0V4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0FzRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTU2F0aXNmaWVzRXhwcmVzc2lvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZUFzc2VydGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZUFzc2VydGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTRW51bURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFbnVtRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU0VudW1NZW1iZXJcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU01vZHVsZURlY2xhcmF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTW9kdWxlQmxvY2sobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU01vZHVsZUJsb2NrXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbXBvcnRUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNJbXBvcnRUeXBlXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTTm9uTnVsbEV4cHJlc3Npb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU05vbk51bGxFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNFeHBvcnRBc3NpZ25tZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVFNUeXBlQW5ub3RhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZVBhcmFtZXRlcihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlRTVHlwZVBhcmFtZXRlclwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1N0YW5kYXJkaXplZChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiOlxuICAgIGNhc2UgXCJEaXJlY3RpdmVcIjpcbiAgICBjYXNlIFwiRGlyZWN0aXZlTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDYXRjaENsYXVzZVwiOlxuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRGVidWdnZXJTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRG9XaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJFbXB0eVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZpbGVcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiSWZTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiTGFiZWxlZFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJTd2l0Y2hDYXNlXCI6XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUaGlzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlVwZGF0ZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiV2l0aFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NCb2R5XCI6XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJNZXRhUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgY2FzZSBcIlN1cGVyXCI6XG4gICAgY2FzZSBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUZW1wbGF0ZUVsZW1lbnRcIjpcbiAgICBjYXNlIFwiVGVtcGxhdGVMaXRlcmFsXCI6XG4gICAgY2FzZSBcIllpZWxkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgIGNhc2UgXCJTdGF0aWNCbG9ja1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgICAgICBjYXNlIFwiQ2xhc3NCb2R5XCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNFeHByZXNzaW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRoaXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJbXBvcnRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJTdXBlclwiOlxuICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVGVtcGxhdGVMaXRlcmFsXCI6XG4gICAgY2FzZSBcIllpZWxkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkpTWEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjpcbiAgICBjYXNlIFwiQmluZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRG9FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlJlY29yZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVHVwbGVFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkRlY2ltYWxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk1vZHVsZUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVG9waWNSZWZlcmVuY2VcIjpcbiAgICBjYXNlIFwiUGlwZWxpbmVUb3BpY0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiUGlwZWxpbmVCYXJlRnVuY3Rpb25cIjpcbiAgICBjYXNlIFwiUGlwZWxpbmVQcmltYXJ5VG9waWNSZWZlcmVuY2VcIjpcbiAgICBjYXNlIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgc3dpdGNoIChub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgICAgICBjYXNlIFwiRXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQmluYXJ5KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzU2NvcGFibGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQ2F0Y2hDbGF1c2VcIjpcbiAgICBjYXNlIFwiRG9XaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiUHJvZ3JhbVwiOlxuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiU3dpdGNoU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNsYXNzTWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJTdGF0aWNCbG9ja1wiOlxuICAgIGNhc2UgXCJUU01vZHVsZUJsb2NrXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiUGxhY2Vob2xkZXJcIjpcbiAgICAgIGlmIChub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJCbG9ja1N0YXRlbWVudFwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Jsb2NrUGFyZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICBjYXNlIFwiU3RhdGljQmxvY2tcIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiQmxvY2tTdGF0ZW1lbnRcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNCbG9jayhub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJQcm9ncmFtXCI6XG4gICAgY2FzZSBcIlRTTW9kdWxlQmxvY2tcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIkJsb2NrU3RhdGVtZW50XCIpIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJsb2NrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkRlYnVnZ2VyU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRW1wdHlTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJTd2l0Y2hTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiVGhyb3dTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiVHJ5U3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiV2l0aFN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVDbGFzc1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUludGVyZmFjZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVUeXBlQWxpYXNcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiRGVjbGFyZVZhcmlhYmxlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiT3BhcXVlVHlwZVwiOlxuICAgIGNhc2UgXCJUeXBlQWxpYXNcIjpcbiAgICBjYXNlIFwiRW51bURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU01vZHVsZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNFeHBvcnRBc3NpZ25tZW50XCI6XG4gICAgY2FzZSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgc3dpdGNoIChub2RlLmV4cGVjdGVkTm9kZSkge1xuICAgICAgICBjYXNlIFwiU3RhdGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJEZWNsYXJhdGlvblwiOlxuICAgICAgICBjYXNlIFwiQmxvY2tTdGF0ZW1lbnRcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1Rlcm1pbmF0b3JsZXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlJldHVyblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJUaHJvd1N0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb25TdGF0ZW1lbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQnJlYWtTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiQ29udGludWVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIlRocm93U3RhdGVtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NvbmRpdGlvbmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJJZlN0YXRlbWVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMb29wKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9ySW5TdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRm9yU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIldoaWxlU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1doaWxlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkRvV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiV2hpbGVTdGF0ZW1lbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwcmVzc2lvbldyYXBwZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRm9yKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNGb3JYU3RhdGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkZvckluU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkZvck9mU3RhdGVtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25QYXJlbnQobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzTWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJTdGF0aWNCbG9ja1wiOlxuICAgIGNhc2UgXCJUU01vZHVsZUJsb2NrXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1B1cmVpc2gobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJOdW1lcmljTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJSZWdFeHBMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiRGVjaW1hbExpdGVyYWxcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIlN0cmluZ0xpdGVyYWxcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkVudW1EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0RlY2xhcmVGdW5jdGlvblwiOlxuICAgIGNhc2UgXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiRGVjbGFyYXRpb25cIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQYXR0ZXJuTGlrZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMVmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBzd2l0Y2ggKG5vZGUuZXhwZWN0ZWROb2RlKSB7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0VudGl0eU5hbWUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGNhc2UgXCJUU1F1YWxpZmllZE5hbWVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIklkZW50aWZpZXJcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNMaXRlcmFsKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlN0cmluZ0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICBjYXNlIFwiTnVsbExpdGVyYWxcIjpcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjpcbiAgICBjYXNlIFwiUmVnRXhwTGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJUZW1wbGF0ZUxpdGVyYWxcIjpcbiAgICBjYXNlIFwiQmlnSW50TGl0ZXJhbFwiOlxuICAgIGNhc2UgXCJEZWNpbWFsTGl0ZXJhbFwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltbXV0YWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsXCI6XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsXCI6XG4gICAgY2FzZSBcIkJpZ0ludExpdGVyYWxcIjpcbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgY2FzZSBcIkpTWENsb3NpbmdFbGVtZW50XCI6XG4gICAgY2FzZSBcIkpTWEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiOlxuICAgIGNhc2UgXCJKU1hTcHJlYWRDaGlsZFwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hUZXh0XCI6XG4gICAgY2FzZSBcIkpTWEZyYWdtZW50XCI6XG4gICAgY2FzZSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiOlxuICAgIGNhc2UgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIjpcbiAgICBjYXNlIFwiRGVjaW1hbExpdGVyYWxcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgICAgaWYgKG5vZGUuZXhwZWN0ZWROb2RlID09PSBcIlN0cmluZ0xpdGVyYWxcIikgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVc2VyV2hpdGVzcGFjYWJsZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVJbmRleGVyXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTWV0aG9kKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0TWVtYmVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdE1ldGhvZFwiOlxuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNVbmFyeUxpa2Uobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzUGF0dGVybihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIlBsYWNlaG9sZGVyXCI6XG4gICAgICBpZiAobm9kZS5leHBlY3RlZE5vZGUgPT09IFwiUGF0dGVyblwiKSBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0NsYXNzKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkNsYXNzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJDbGFzc0RlY2xhcmF0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0ltcG9ydE9yRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW1wb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTW9kdWxlU3BlY2lmaWVyKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzQWNjZXNzb3Iobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1ByaXZhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgY2FzZSBcIlByaXZhdGVOYW1lXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3cobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiQW55VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkNsYXNzSW1wbGVtZW50c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVkUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25UeXBlUGFyYW1cIjpcbiAgICBjYXNlIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkluZmVycmVkUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZUV4dGVuZHNcIjpcbiAgICBjYXNlIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiSW50ZXJzZWN0aW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk51bWJlclR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlSW5kZXhlclwiOlxuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiUXVhbGlmaWVkVHlwZUlkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVBbGlhc1wiOlxuICAgIGNhc2UgXCJUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVHlwZVBhcmFtZXRlclwiOlxuICAgIGNhc2UgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICBjYXNlIFwiVW5pb25UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJWYXJpYW5jZVwiOlxuICAgIGNhc2UgXCJWb2lkVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRW51bURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkVudW1Cb29sZWFuQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtTnVtYmVyQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtU3RyaW5nQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtU3ltYm9sQm9keVwiOlxuICAgIGNhc2UgXCJFbnVtQm9vbGVhbk1lbWJlclwiOlxuICAgIGNhc2UgXCJFbnVtTnVtYmVyTWVtYmVyXCI6XG4gICAgY2FzZSBcIkVudW1TdHJpbmdNZW1iZXJcIjpcbiAgICBjYXNlIFwiRW51bURlZmF1bHRlZE1lbWJlclwiOlxuICAgIGNhc2UgXCJJbmRleGVkQWNjZXNzVHlwZVwiOlxuICAgIGNhc2UgXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkFueVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkFycmF5VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5MaXRlcmFsVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJFeGlzdHNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkVtcHR5VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiTnVtYmVyVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIlVuaW9uVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRmxvd0Jhc2VBbm5vdGF0aW9uKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkFueVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk1peGVkVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJTdHJpbmdUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJTeW1ib2xUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUaGlzVHlwZUFubm90YXRpb25cIjpcbiAgICBjYXNlIFwiVm9pZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJEZWNsYXJlQ2xhc3NcIjpcbiAgICBjYXNlIFwiRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICBjYXNlIFwiRGVjbGFyZU1vZHVsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgIGNhc2UgXCJEZWNsYXJlVHlwZUFsaWFzXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVPcGFxdWVUeXBlXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVWYXJpYWJsZVwiOlxuICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIk9wYXF1ZVR5cGVcIjpcbiAgICBjYXNlIFwiVHlwZUFsaWFzXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0Zsb3dQcmVkaWNhdGUobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRGVjbGFyZWRQcmVkaWNhdGVcIjpcbiAgICBjYXNlIFwiSW5mZXJyZWRQcmVkaWNhdGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzRW51bUJvZHkobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRW51bUJvb2xlYW5Cb2R5XCI6XG4gICAgY2FzZSBcIkVudW1OdW1iZXJCb2R5XCI6XG4gICAgY2FzZSBcIkVudW1TdHJpbmdCb2R5XCI6XG4gICAgY2FzZSBcIkVudW1TeW1ib2xCb2R5XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc0VudW1NZW1iZXIobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiRW51bUJvb2xlYW5NZW1iZXJcIjpcbiAgICBjYXNlIFwiRW51bU51bWJlck1lbWJlclwiOlxuICAgIGNhc2UgXCJFbnVtU3RyaW5nTWVtYmVyXCI6XG4gICAgY2FzZSBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzSlNYKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIkpTWEF0dHJpYnV0ZVwiOlxuICAgIGNhc2UgXCJKU1hDbG9zaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hFbGVtZW50XCI6XG4gICAgY2FzZSBcIkpTWEVtcHR5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCI6XG4gICAgY2FzZSBcIkpTWFNwcmVhZENoaWxkXCI6XG4gICAgY2FzZSBcIkpTWElkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJKU1hOYW1lc3BhY2VkTmFtZVwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRWxlbWVudFwiOlxuICAgIGNhc2UgXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpcbiAgICBjYXNlIFwiSlNYVGV4dFwiOlxuICAgIGNhc2UgXCJKU1hGcmFnbWVudFwiOlxuICAgIGNhc2UgXCJKU1hPcGVuaW5nRnJhZ21lbnRcIjpcbiAgICBjYXNlIFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc01pc2NlbGxhbmVvdXMobm9kZSwgb3B0cykge1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiTm9vcFwiOlxuICAgIGNhc2UgXCJQbGFjZWhvbGRlclwiOlxuICAgIGNhc2UgXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzVHlwZVNjcmlwdChub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6XG4gICAgY2FzZSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCI6XG4gICAgY2FzZSBcIlRTRGVjbGFyZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJUU1F1YWxpZmllZE5hbWVcIjpcbiAgICBjYXNlIFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU1Byb3BlcnR5U2lnbmF0dXJlXCI6XG4gICAgY2FzZSBcIlRTTWV0aG9kU2lnbmF0dXJlXCI6XG4gICAgY2FzZSBcIlRTSW5kZXhTaWduYXR1cmVcIjpcbiAgICBjYXNlIFwiVFNBbnlLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTQm9vbGVhbktleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNCaWdJbnRLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTSW50cmluc2ljS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU05ldmVyS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU051bGxLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTnVtYmVyS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU09iamVjdEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNTdHJpbmdLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTU3ltYm9sS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1VuZGVmaW5lZEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNVbmtub3duS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1ZvaWRLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVGhpc1R5cGVcIjpcbiAgICBjYXNlIFwiVFNGdW5jdGlvblR5cGVcIjpcbiAgICBjYXNlIFwiVFNDb25zdHJ1Y3RvclR5cGVcIjpcbiAgICBjYXNlIFwiVFNUeXBlUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlRTVHlwZVByZWRpY2F0ZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVRdWVyeVwiOlxuICAgIGNhc2UgXCJUU1R5cGVMaXRlcmFsXCI6XG4gICAgY2FzZSBcIlRTQXJyYXlUeXBlXCI6XG4gICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgY2FzZSBcIlRTT3B0aW9uYWxUeXBlXCI6XG4gICAgY2FzZSBcIlRTUmVzdFR5cGVcIjpcbiAgICBjYXNlIFwiVFNOYW1lZFR1cGxlTWVtYmVyXCI6XG4gICAgY2FzZSBcIlRTVW5pb25UeXBlXCI6XG4gICAgY2FzZSBcIlRTSW50ZXJzZWN0aW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgIGNhc2UgXCJUU0luZmVyVHlwZVwiOlxuICAgIGNhc2UgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCI6XG4gICAgY2FzZSBcIlRTVHlwZU9wZXJhdG9yXCI6XG4gICAgY2FzZSBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIjpcbiAgICBjYXNlIFwiVFNNYXBwZWRUeXBlXCI6XG4gICAgY2FzZSBcIlRTTGl0ZXJhbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNFeHByZXNzaW9uV2l0aFR5cGVBcmd1bWVudHNcIjpcbiAgICBjYXNlIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0ludGVyZmFjZUJvZHlcIjpcbiAgICBjYXNlIFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTQXNFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICBjYXNlIFwiVFNFbnVtRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNFbnVtTWVtYmVyXCI6XG4gICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOlxuICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICBjYXNlIFwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCI6XG4gICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNFeHBvcnRBc3NpZ25tZW50XCI6XG4gICAgY2FzZSBcIlRTTmFtZXNwYWNlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlclwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU1R5cGVFbGVtZW50KG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlRTQ2FsbFNpZ25hdHVyZURlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOlxuICAgIGNhc2UgXCJUU01ldGhvZFNpZ25hdHVyZVwiOlxuICAgIGNhc2UgXCJUU0luZGV4U2lnbmF0dXJlXCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1RTVHlwZShub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgIGNhc2UgXCJUU0FueUtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNCb29sZWFuS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU0JpZ0ludEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNJbnRyaW5zaWNLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTmV2ZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTTnVsbEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNOdW1iZXJLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTT2JqZWN0S2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1N0cmluZ0tleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNTeW1ib2xLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVW5kZWZpbmVkS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1Vua25vd25LZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVm9pZEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNUaGlzVHlwZVwiOlxuICAgIGNhc2UgXCJUU0Z1bmN0aW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0NvbnN0cnVjdG9yVHlwZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVSZWZlcmVuY2VcIjpcbiAgICBjYXNlIFwiVFNUeXBlUHJlZGljYXRlXCI6XG4gICAgY2FzZSBcIlRTVHlwZVF1ZXJ5XCI6XG4gICAgY2FzZSBcIlRTVHlwZUxpdGVyYWxcIjpcbiAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICBjYXNlIFwiVFNUdXBsZVR5cGVcIjpcbiAgICBjYXNlIFwiVFNPcHRpb25hbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNSZXN0VHlwZVwiOlxuICAgIGNhc2UgXCJUU1VuaW9uVHlwZVwiOlxuICAgIGNhc2UgXCJUU0ludGVyc2VjdGlvblR5cGVcIjpcbiAgICBjYXNlIFwiVFNDb25kaXRpb25hbFR5cGVcIjpcbiAgICBjYXNlIFwiVFNJbmZlclR5cGVcIjpcbiAgICBjYXNlIFwiVFNQYXJlbnRoZXNpemVkVHlwZVwiOlxuICAgIGNhc2UgXCJUU1R5cGVPcGVyYXRvclwiOlxuICAgIGNhc2UgXCJUU0luZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgY2FzZSBcIlRTTWFwcGVkVHlwZVwiOlxuICAgIGNhc2UgXCJUU0xpdGVyYWxUeXBlXCI6XG4gICAgY2FzZSBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCI6XG4gICAgY2FzZSBcIlRTSW1wb3J0VHlwZVwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNUU0Jhc2VUeXBlKG5vZGUsIG9wdHMpIHtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlRTQW55S2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU0Jvb2xlYW5LZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTQmlnSW50S2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU0ludHJpbnNpY0tleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNOZXZlcktleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNOdWxsS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU051bWJlcktleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNPYmplY3RLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTU3RyaW5nS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1N5bWJvbEtleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI6XG4gICAgY2FzZSBcIlRTVW5rbm93bktleXdvcmRcIjpcbiAgICBjYXNlIFwiVFNWb2lkS2V5d29yZFwiOlxuICAgIGNhc2UgXCJUU1RoaXNUeXBlXCI6XG4gICAgY2FzZSBcIlRTTGl0ZXJhbFR5cGVcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG9wdHMgPT0gbnVsbCB8fCAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyTGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiaXNOdW1iZXJMaXRlcmFsXCIsIFwiaXNOdW1lcmljTGl0ZXJhbFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTnVtYmVyTGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1JlZ2V4TGl0ZXJhbChub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiaXNSZWdleExpdGVyYWxcIiwgXCJpc1JlZ0V4cExpdGVyYWxcIik7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlICE9PSBcIlJlZ2V4TGl0ZXJhbFwiKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBvcHRzID09IG51bGwgfHwgKDAsIF9zaGFsbG93RXF1YWwuZGVmYXVsdCkobm9kZSwgb3B0cyk7XG59XG5mdW5jdGlvbiBpc1Jlc3RQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiaXNSZXN0UHJvcGVydHlcIiwgXCJpc1Jlc3RFbGVtZW50XCIpO1xuICBpZiAoIW5vZGUpIHJldHVybiBmYWxzZTtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJSZXN0UHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNTcHJlYWRQcm9wZXJ0eShub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiaXNTcHJlYWRQcm9wZXJ0eVwiLCBcImlzU3ByZWFkRWxlbWVudFwiKTtcbiAgaWYgKCFub2RlKSByZXR1cm4gZmFsc2U7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiU3ByZWFkUHJvcGVydHlcIikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gb3B0cyA9PSBudWxsIHx8ICgwLCBfc2hhbGxvd0VxdWFsLmRlZmF1bHQpKG5vZGUsIG9wdHMpO1xufVxuZnVuY3Rpb24gaXNNb2R1bGVEZWNsYXJhdGlvbihub2RlLCBvcHRzKSB7XG4gICgwLCBfZGVwcmVjYXRpb25XYXJuaW5nLmRlZmF1bHQpKFwiaXNNb2R1bGVEZWNsYXJhdGlvblwiLCBcImlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvblwiKTtcbiAgcmV0dXJuIGlzSW1wb3J0T3JFeHBvcnREZWNsYXJhdGlvbihub2RlLCBvcHRzKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98960\n')},93828:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = is;\nvar _shallowEqual = __webpack_require__(96616);\nvar _isType = __webpack_require__(94460);\nvar _isPlaceholderType = __webpack_require__(53571);\nvar _index = __webpack_require__(39793);\nfunction is(type, node, opts) {\n  if (!node) return false;\n  const matches = (0, _isType.default)(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {\n      return (0, _isPlaceholderType.default)(node.expectedNode, type);\n    }\n    return false;\n  }\n  if (opts === undefined) {\n    return true;\n  } else {\n    return (0, _shallowEqual.default)(node, opts);\n  }\n}\n\n//# sourceMappingURL=is.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTM4MjguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixvQkFBb0IsbUJBQU8sQ0FBQyxLQUEwQjtBQUN0RCxjQUFjLG1CQUFPLENBQUMsS0FBYTtBQUNuQyx5QkFBeUIsbUJBQU8sQ0FBQyxLQUF3QjtBQUN6RCxhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pcy5qcz9mNWYyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXM7XG52YXIgX3NoYWxsb3dFcXVhbCA9IHJlcXVpcmUoXCIuLi91dGlscy9zaGFsbG93RXF1YWwuanNcIik7XG52YXIgX2lzVHlwZSA9IHJlcXVpcmUoXCIuL2lzVHlwZS5qc1wiKTtcbnZhciBfaXNQbGFjZWhvbGRlclR5cGUgPSByZXF1aXJlKFwiLi9pc1BsYWNlaG9sZGVyVHlwZS5qc1wiKTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpcyh0eXBlLCBub2RlLCBvcHRzKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuIGZhbHNlO1xuICBjb25zdCBtYXRjaGVzID0gKDAsIF9pc1R5cGUuZGVmYXVsdCkobm9kZS50eXBlLCB0eXBlKTtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgaWYgKCFvcHRzICYmIG5vZGUudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiICYmIHR5cGUgaW4gX2luZGV4LkZMSVBQRURfQUxJQVNfS0VZUykge1xuICAgICAgcmV0dXJuICgwLCBfaXNQbGFjZWhvbGRlclR5cGUuZGVmYXVsdCkobm9kZS5leHBlY3RlZE5vZGUsIHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoMCwgX3NoYWxsb3dFcXVhbC5kZWZhdWx0KShub2RlLCBvcHRzKTtcbiAgfVxufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///93828\n')},2687:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isBinding;\nvar _getBindingIdentifiers = __webpack_require__(70329);\nfunction isBinding(node, parent, grandparent) {\n  if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {\n    return false;\n  }\n  const keys = _getBindingIdentifiers.default.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isBinding.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY4Ny5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLDZCQUE2QixtQkFBTyxDQUFDLEtBQXdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNCaW5kaW5nLmpzP2M0ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0JpbmRpbmc7XG52YXIgX2dldEJpbmRpbmdJZGVudGlmaWVycyA9IHJlcXVpcmUoXCIuLi9yZXRyaWV2ZXJzL2dldEJpbmRpbmdJZGVudGlmaWVycy5qc1wiKTtcbmZ1bmN0aW9uIGlzQmluZGluZyhub2RlLCBwYXJlbnQsIGdyYW5kcGFyZW50KSB7XG4gIGlmIChncmFuZHBhcmVudCAmJiBub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmVudC50eXBlID09PSBcIk9iamVjdFByb3BlcnR5XCIgJiYgZ3JhbmRwYXJlbnQudHlwZSA9PT0gXCJPYmplY3RFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5cyA9IF9nZXRCaW5kaW5nSWRlbnRpZmllcnMuZGVmYXVsdC5rZXlzW3BhcmVudC50eXBlXTtcbiAgaWYgKGtleXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBjb25zdCB2YWwgPSBwYXJlbnRba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgaWYgKHZhbC5pbmNsdWRlcyhub2RlKSkgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsID09PSBub2RlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0JpbmRpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2687\n')},29127:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isBlockScoped;\nvar _index = __webpack_require__(98960);\nvar _isLet = __webpack_require__(63847);\nfunction isBlockScoped(node) {\n  return (0, _index.isFunctionDeclaration)(node) || (0, _index.isClassDeclaration)(node) || (0, _isLet.default)(node);\n}\n\n//# sourceMappingURL=isBlockScoped.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkxMjcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLEtBQVk7QUFDakM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNCbG9ja1Njb3BlZC5qcz9lOTExIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNCbG9ja1Njb3BlZDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2lzTGV0ID0gcmVxdWlyZShcIi4vaXNMZXQuanNcIik7XG5mdW5jdGlvbiBpc0Jsb2NrU2NvcGVkKG5vZGUpIHtcbiAgcmV0dXJuICgwLCBfaW5kZXguaXNGdW5jdGlvbkRlY2xhcmF0aW9uKShub2RlKSB8fCAoMCwgX2luZGV4LmlzQ2xhc3NEZWNsYXJhdGlvbikobm9kZSkgfHwgKDAsIF9pc0xldC5kZWZhdWx0KShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNCbG9ja1Njb3BlZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29127\n')},19722:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isImmutable;\nvar _isType = __webpack_require__(94460);\nvar _index = __webpack_require__(98960);\nfunction isImmutable(node) {\n  if ((0, _isType.default)(node.type, "Immutable")) return true;\n  if ((0, _index.isIdentifier)(node)) {\n    if (node.name === "undefined") {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isImmutable.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3MjIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixjQUFjLG1CQUFPLENBQUMsS0FBYTtBQUNuQyxhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNJbW11dGFibGUuanM/MGFlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzSW1tdXRhYmxlO1xudmFyIF9pc1R5cGUgPSByZXF1aXJlKFwiLi9pc1R5cGUuanNcIik7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXNJbW11dGFibGUobm9kZSkge1xuICBpZiAoKDAsIF9pc1R5cGUuZGVmYXVsdCkobm9kZS50eXBlLCBcIkltbXV0YWJsZVwiKSkgcmV0dXJuIHRydWU7XG4gIGlmICgoMCwgX2luZGV4LmlzSWRlbnRpZmllcikobm9kZSkpIHtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzSW1tdXRhYmxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19722\n')},63847:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isLet;\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(93422);\nfunction isLet(node) {\n  return (0, _index.isVariableDeclaration)(node) && (node.kind !== "var" || node[_index2.BLOCK_SCOPED_SYMBOL]);\n}\n\n//# sourceMappingURL=isLet.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM4NDcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLEtBQXVCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTGV0LmpzP2U0MzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc0xldDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc0xldChub2RlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzVmFyaWFibGVEZWNsYXJhdGlvbikobm9kZSkgJiYgKG5vZGUua2luZCAhPT0gXCJ2YXJcIiB8fCBub2RlW19pbmRleDIuQkxPQ0tfU0NPUEVEX1NZTUJPTF0pO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0xldC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///63847\n')},73908:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isNode;\nvar _index = __webpack_require__(39793);\nfunction isNode(node) {\n  return !!(node && _index.VISITOR_KEYS[node.type]);\n}\n\n//# sourceMappingURL=isNode.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM5MDguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNOb2RlLmpzP2U2ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc05vZGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgX2luZGV4LlZJU0lUT1JfS0VZU1tub2RlLnR5cGVdKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOb2RlLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///73908\n')},7003:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isNodesEquivalent;\nvar _index = __webpack_require__(39793);\nfunction isNodesEquivalent(a, b) {\n  if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {\n    return a === b;\n  }\n  if (a.type !== b.type) {\n    return false;\n  }\n  const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = _index.VISITOR_KEYS[a.type];\n  for (const field of fields) {\n    const val_a = a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n//# sourceMappingURL=isNodesEquivalent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAwMy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLGFBQWEsbUJBQU8sQ0FBQyxLQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzTm9kZXNFcXVpdmFsZW50LmpzP2Y4YzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc05vZGVzRXF1aXZhbGVudDtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc05vZGVzRXF1aXZhbGVudChhLCBiKSB7XG4gIGlmICh0eXBlb2YgYSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgYiAhPT0gXCJvYmplY3RcIiB8fCBhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG4gIH1cbiAgaWYgKGEudHlwZSAhPT0gYi50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKF9pbmRleC5OT0RFX0ZJRUxEU1thLnR5cGVdIHx8IGEudHlwZSk7XG4gIGNvbnN0IHZpc2l0b3JLZXlzID0gX2luZGV4LlZJU0lUT1JfS0VZU1thLnR5cGVdO1xuICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgIGNvbnN0IHZhbF9hID0gYVtmaWVsZF07XG4gICAgY29uc3QgdmFsX2IgPSBiW2ZpZWxkXTtcbiAgICBpZiAodHlwZW9mIHZhbF9hICE9PSB0eXBlb2YgdmFsX2IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHZhbF9hID09IG51bGwgJiYgdmFsX2IgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmICh2YWxfYSA9PSBudWxsIHx8IHZhbF9iID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsX2EpKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsX2IpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWxfYS5sZW5ndGggIT09IHZhbF9iLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbF9hLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNOb2Rlc0VxdWl2YWxlbnQodmFsX2FbaV0sIHZhbF9iW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsX2EgPT09IFwib2JqZWN0XCIgJiYgISh2aXNpdG9yS2V5cyAhPSBudWxsICYmIHZpc2l0b3JLZXlzLmluY2x1ZGVzKGZpZWxkKSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHZhbF9hKSkge1xuICAgICAgICBpZiAodmFsX2Fba2V5XSAhPT0gdmFsX2Jba2V5XSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghaXNOb2Rlc0VxdWl2YWxlbnQodmFsX2EsIHZhbF9iKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNOb2Rlc0VxdWl2YWxlbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7003\n')},53571:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isPlaceholderType;\nvar _index = __webpack_require__(39793);\nfunction isPlaceholderType(placeholderType, targetType) {\n  if (placeholderType === targetType) return true;\n  const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases) {\n    for (const alias of aliases) {\n      if (targetType === alias) return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isPlaceholderType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM1NzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1BsYWNlaG9sZGVyVHlwZS5qcz9lM2Y0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNQbGFjZWhvbGRlclR5cGU7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXNQbGFjZWhvbGRlclR5cGUocGxhY2Vob2xkZXJUeXBlLCB0YXJnZXRUeXBlKSB7XG4gIGlmIChwbGFjZWhvbGRlclR5cGUgPT09IHRhcmdldFR5cGUpIHJldHVybiB0cnVlO1xuICBjb25zdCBhbGlhc2VzID0gX2luZGV4LlBMQUNFSE9MREVSU19BTElBU1twbGFjZWhvbGRlclR5cGVdO1xuICBpZiAoYWxpYXNlcykge1xuICAgIGZvciAoY29uc3QgYWxpYXMgb2YgYWxpYXNlcykge1xuICAgICAgaWYgKHRhcmdldFR5cGUgPT09IGFsaWFzKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1BsYWNlaG9sZGVyVHlwZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53571\n')},37591:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isReferenced;\nfunction isReferenced(node, parent, grandparent) {\n  switch (parent.type) {\n    case "MemberExpression":\n    case "OptionalMemberExpression":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n    case "JSXMemberExpression":\n      return parent.object === node;\n    case "VariableDeclarator":\n      return parent.init === node;\n    case "ArrowFunctionExpression":\n      return parent.body === node;\n    case "PrivateName":\n      return false;\n    case "ClassMethod":\n    case "ClassPrivateMethod":\n    case "ObjectMethod":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n    case "ObjectProperty":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return !grandparent || grandparent.type !== "ObjectPattern";\n    case "ClassProperty":\n    case "ClassAccessorProperty":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case "ClassPrivateProperty":\n      return parent.key !== node;\n    case "ClassDeclaration":\n    case "ClassExpression":\n      return parent.superClass === node;\n    case "AssignmentExpression":\n      return parent.right === node;\n    case "AssignmentPattern":\n      return parent.right === node;\n    case "LabeledStatement":\n      return false;\n    case "CatchClause":\n      return false;\n    case "RestElement":\n      return false;\n    case "BreakStatement":\n    case "ContinueStatement":\n      return false;\n    case "FunctionDeclaration":\n    case "FunctionExpression":\n      return false;\n    case "ExportNamespaceSpecifier":\n    case "ExportDefaultSpecifier":\n      return false;\n    case "ExportSpecifier":\n      if (grandparent != null && grandparent.source) {\n        return false;\n      }\n      return parent.local === node;\n    case "ImportDefaultSpecifier":\n    case "ImportNamespaceSpecifier":\n    case "ImportSpecifier":\n      return false;\n    case "ImportAttribute":\n      return false;\n    case "JSXAttribute":\n      return false;\n    case "ObjectPattern":\n    case "ArrayPattern":\n      return false;\n    case "MetaProperty":\n      return false;\n    case "ObjectTypeProperty":\n      return parent.key !== node;\n    case "TSEnumMember":\n      return parent.id !== node;\n    case "TSPropertySignature":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n  }\n  return true;\n}\n\n//# sourceMappingURL=isReferenced.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc1OTEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzUmVmZXJlbmNlZC5qcz8zZmQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNSZWZlcmVuY2VkO1xuZnVuY3Rpb24gaXNSZWZlcmVuY2VkKG5vZGUsIHBhcmVudCwgZ3JhbmRwYXJlbnQpIHtcbiAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKHBhcmVudC5wcm9wZXJ0eSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbiAgICBjYXNlIFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5pbml0ID09PSBub2RlO1xuICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIHBhcmVudC5ib2R5ID09PSBub2RlO1xuICAgIGNhc2UgXCJQcml2YXRlTmFtZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgICBpZiAocGFyZW50LmtleSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICBpZiAocGFyZW50LmtleSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gISFwYXJlbnQuY29tcHV0ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gIWdyYW5kcGFyZW50IHx8IGdyYW5kcGFyZW50LnR5cGUgIT09IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIGNhc2UgXCJDbGFzc1Byb3BlcnR5XCI6XG4gICAgY2FzZSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgICAgaWYgKHBhcmVudC5rZXkgPT09IG5vZGUpIHtcbiAgICAgICAgcmV0dXJuICEhcGFyZW50LmNvbXB1dGVkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gcGFyZW50LmtleSAhPT0gbm9kZTtcbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQuc3VwZXJDbGFzcyA9PT0gbm9kZTtcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXJlbnQucmlnaHQgPT09IG5vZGU7XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnJpZ2h0ID09PSBub2RlO1xuICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkNhdGNoQ2xhdXNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkJyZWFrU3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkNvbnRpbnVlU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgICAgaWYgKGdyYW5kcGFyZW50ICE9IG51bGwgJiYgZ3JhbmRwYXJlbnQuc291cmNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnQubG9jYWwgPT09IG5vZGU7XG4gICAgY2FzZSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICBjYXNlIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgY2FzZSBcIkltcG9ydFNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJJbXBvcnRBdHRyaWJ1dGVcIjpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFwiSlNYQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBcIk1ldGFQcm9wZXJ0eVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBwYXJlbnQua2V5ICE9PSBub2RlO1xuICAgIGNhc2UgXCJUU0VudW1NZW1iZXJcIjpcbiAgICAgIHJldHVybiBwYXJlbnQuaWQgIT09IG5vZGU7XG4gICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgIGlmIChwYXJlbnQua2V5ID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiAhIXBhcmVudC5jb21wdXRlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1JlZmVyZW5jZWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37591\n')},89246:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isScope;\nvar _index = __webpack_require__(98960);\nfunction isScope(node, parent) {\n  if ((0, _index.isBlockStatement)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return false;\n  }\n  if ((0, _index.isPattern)(node) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {\n    return true;\n  }\n  return (0, _index.isScopable)(node);\n}\n\n//# sourceMappingURL=isScope.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkyNDYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTY29wZS5qcz8zZmI2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNTY29wZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1Njb3BlKG5vZGUsIHBhcmVudCkge1xuICBpZiAoKDAsIF9pbmRleC5pc0Jsb2NrU3RhdGVtZW50KShub2RlKSAmJiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShwYXJlbnQpIHx8ICgwLCBfaW5kZXguaXNDYXRjaENsYXVzZSkocGFyZW50KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCgwLCBfaW5kZXguaXNQYXR0ZXJuKShub2RlKSAmJiAoKDAsIF9pbmRleC5pc0Z1bmN0aW9uKShwYXJlbnQpIHx8ICgwLCBfaW5kZXguaXNDYXRjaENsYXVzZSkocGFyZW50KSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKDAsIF9pbmRleC5pc1Njb3BhYmxlKShub2RlKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY29wZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///89246\n')},22457:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isSpecifierDefault;\nvar _index = __webpack_require__(98960);\nfunction isSpecifierDefault(specifier) {\n  return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {\n    name: "default"\n  });\n}\n\n//# sourceMappingURL=isSpecifierDefault.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjI0NTcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvaXNTcGVjaWZpZXJEZWZhdWx0LmpzPzgwZDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1NwZWNpZmllckRlZmF1bHQ7XG52YXIgX2luZGV4ID0gcmVxdWlyZShcIi4vZ2VuZXJhdGVkL2luZGV4LmpzXCIpO1xuZnVuY3Rpb24gaXNTcGVjaWZpZXJEZWZhdWx0KHNwZWNpZmllcikge1xuICByZXR1cm4gKDAsIF9pbmRleC5pc0ltcG9ydERlZmF1bHRTcGVjaWZpZXIpKHNwZWNpZmllcikgfHwgKDAsIF9pbmRleC5pc0lkZW50aWZpZXIpKHNwZWNpZmllci5pbXBvcnRlZCB8fCBzcGVjaWZpZXIuZXhwb3J0ZWQsIHtcbiAgICBuYW1lOiBcImRlZmF1bHRcIlxuICB9KTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTcGVjaWZpZXJEZWZhdWx0LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22457\n')},94460:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isType;\nvar _index = __webpack_require__(39793);\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n  if (nodeType == null) return false;\n  if (_index.ALIAS_KEYS[targetType]) return false;\n  const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n    for (const alias of aliases) {\n      if (nodeType === alias) return true;\n    }\n  }\n  return false;\n}\n\n//# sourceMappingURL=isType.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ0NjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1R5cGUuanM/ZmE0OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzVHlwZTtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi4vZGVmaW5pdGlvbnMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1R5cGUobm9kZVR5cGUsIHRhcmdldFR5cGUpIHtcbiAgaWYgKG5vZGVUeXBlID09PSB0YXJnZXRUeXBlKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKG5vZGVUeXBlID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgaWYgKF9pbmRleC5BTElBU19LRVlTW3RhcmdldFR5cGVdKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGFsaWFzZXMgPSBfaW5kZXguRkxJUFBFRF9BTElBU19LRVlTW3RhcmdldFR5cGVdO1xuICBpZiAoYWxpYXNlcykge1xuICAgIGlmIChhbGlhc2VzWzBdID09PSBub2RlVHlwZSkgcmV0dXJuIHRydWU7XG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICBpZiAobm9kZVR5cGUgPT09IGFsaWFzKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc1R5cGUuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94460\n')},91384:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isValidES3Identifier;\nvar _isValidIdentifier = __webpack_require__(60983);\nconst RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);\nfunction isValidES3Identifier(name) {\n  return (0, _isValidIdentifier.default)(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n\n//# sourceMappingURL=isValidES3Identifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEzODQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZix5QkFBeUIsbUJBQU8sQ0FBQyxLQUF3QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFsaWRFUzNJZGVudGlmaWVyLmpzPzFiM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhbGlkRVMzSWRlbnRpZmllcjtcbnZhciBfaXNWYWxpZElkZW50aWZpZXIgPSByZXF1aXJlKFwiLi9pc1ZhbGlkSWRlbnRpZmllci5qc1wiKTtcbmNvbnN0IFJFU0VSVkVEX1dPUkRTX0VTM19PTkxZID0gbmV3IFNldChbXCJhYnN0cmFjdFwiLCBcImJvb2xlYW5cIiwgXCJieXRlXCIsIFwiY2hhclwiLCBcImRvdWJsZVwiLCBcImVudW1cIiwgXCJmaW5hbFwiLCBcImZsb2F0XCIsIFwiZ290b1wiLCBcImltcGxlbWVudHNcIiwgXCJpbnRcIiwgXCJpbnRlcmZhY2VcIiwgXCJsb25nXCIsIFwibmF0aXZlXCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzaG9ydFwiLCBcInN0YXRpY1wiLCBcInN5bmNocm9uaXplZFwiLCBcInRocm93c1wiLCBcInRyYW5zaWVudFwiLCBcInZvbGF0aWxlXCJdKTtcbmZ1bmN0aW9uIGlzVmFsaWRFUzNJZGVudGlmaWVyKG5hbWUpIHtcbiAgcmV0dXJuICgwLCBfaXNWYWxpZElkZW50aWZpZXIuZGVmYXVsdCkobmFtZSkgJiYgIVJFU0VSVkVEX1dPUkRTX0VTM19PTkxZLmhhcyhuYW1lKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYWxpZEVTM0lkZW50aWZpZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///91384\n')},60983:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isValidIdentifier;\nvar _helperValidatorIdentifier = __webpack_require__(61000);\nfunction isValidIdentifier(name, reserved = true) {\n  if (typeof name !== "string") return false;\n  if (reserved) {\n    if ((0, _helperValidatorIdentifier.isKeyword)(name) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name, true)) {\n      return false;\n    }\n  }\n  return (0, _helperValidatorIdentifier.isIdentifierName)(name);\n}\n\n//# sourceMappingURL=isValidIdentifier.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA5ODMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixpQ0FBaUMsbUJBQU8sQ0FBQyxLQUFvQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9pc1ZhbGlkSWRlbnRpZmllci5qcz84MWUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNWYWxpZElkZW50aWZpZXI7XG52YXIgX2hlbHBlclZhbGlkYXRvcklkZW50aWZpZXIgPSByZXF1aXJlKFwiQGJhYmVsL2hlbHBlci12YWxpZGF0b3ItaWRlbnRpZmllclwiKTtcbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKG5hbWUsIHJlc2VydmVkID0gdHJ1ZSkge1xuICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgaWYgKHJlc2VydmVkKSB7XG4gICAgaWYgKCgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0tleXdvcmQpKG5hbWUpIHx8ICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc1N0cmljdFJlc2VydmVkV29yZCkobmFtZSwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICgwLCBfaGVscGVyVmFsaWRhdG9ySWRlbnRpZmllci5pc0lkZW50aWZpZXJOYW1lKShuYW1lKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYWxpZElkZW50aWZpZXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///60983\n')},70499:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isVar;\nvar _index = __webpack_require__(98960);\nvar _index2 = __webpack_require__(93422);\nfunction isVar(node) {\n  return (0, _index.isVariableDeclaration)(node, {\n    kind: "var"\n  }) && !node[_index2.BLOCK_SCOPED_SYMBOL];\n}\n\n//# sourceMappingURL=isVar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzA0OTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLEtBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3R5cGVzL2xpYi92YWxpZGF0b3JzL2lzVmFyLmpzP2ZkNjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhcjtcbnZhciBfaW5kZXggPSByZXF1aXJlKFwiLi9nZW5lcmF0ZWQvaW5kZXguanNcIik7XG52YXIgX2luZGV4MiA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaW5kZXguanNcIik7XG5mdW5jdGlvbiBpc1Zhcihub2RlKSB7XG4gIHJldHVybiAoMCwgX2luZGV4LmlzVmFyaWFibGVEZWNsYXJhdGlvbikobm9kZSwge1xuICAgIGtpbmQ6IFwidmFyXCJcbiAgfSkgJiYgIW5vZGVbX2luZGV4Mi5CTE9DS19TQ09QRURfU1lNQk9MXTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNWYXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70499\n')},94965:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = matchesPattern;\nvar _index = __webpack_require__(98960);\nfunction matchesPattern(member, match, allowPartial) {\n  if (!(0, _index.isMemberExpression)(member)) return false;\n  const parts = Array.isArray(match) ? match : match.split(".");\n  const nodes = [];\n  let node;\n  for (node = member; (0, _index.isMemberExpression)(node); node = node.object) {\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if ((0, _index.isIdentifier)(node)) {\n      value = node.name;\n    } else if ((0, _index.isStringLiteral)(node)) {\n      value = node.value;\n    } else if ((0, _index.isThisExpression)(node)) {\n      value = "this";\n    } else {\n      return false;\n    }\n    if (parts[i] !== value) return false;\n  }\n  return true;\n}\n\n//# sourceMappingURL=matchesPattern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQ5NjUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixhQUFhLG1CQUFPLENBQUMsS0FBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQ0FBc0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvbWF0Y2hlc1BhdHRlcm4uanM/OGM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IG1hdGNoZXNQYXR0ZXJuO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlZC9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIG1hdGNoZXNQYXR0ZXJuKG1lbWJlciwgbWF0Y2gsIGFsbG93UGFydGlhbCkge1xuICBpZiAoISgwLCBfaW5kZXguaXNNZW1iZXJFeHByZXNzaW9uKShtZW1iZXIpKSByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShtYXRjaCkgPyBtYXRjaCA6IG1hdGNoLnNwbGl0KFwiLlwiKTtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgbGV0IG5vZGU7XG4gIGZvciAobm9kZSA9IG1lbWJlcjsgKDAsIF9pbmRleC5pc01lbWJlckV4cHJlc3Npb24pKG5vZGUpOyBub2RlID0gbm9kZS5vYmplY3QpIHtcbiAgICBub2Rlcy5wdXNoKG5vZGUucHJvcGVydHkpO1xuICB9XG4gIG5vZGVzLnB1c2gobm9kZSk7XG4gIGlmIChub2Rlcy5sZW5ndGggPCBwYXJ0cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKCFhbGxvd1BhcnRpYWwgJiYgbm9kZXMubGVuZ3RoID4gcGFydHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gbm9kZXMubGVuZ3RoIC0gMTsgaSA8IHBhcnRzLmxlbmd0aDsgaSsrLCBqLS0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbal07XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICgoMCwgX2luZGV4LmlzSWRlbnRpZmllcikobm9kZSkpIHtcbiAgICAgIHZhbHVlID0gbm9kZS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pbmRleC5pc1N0cmluZ0xpdGVyYWwpKG5vZGUpKSB7XG4gICAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgfSBlbHNlIGlmICgoMCwgX2luZGV4LmlzVGhpc0V4cHJlc3Npb24pKG5vZGUpKSB7XG4gICAgICB2YWx1ZSA9IFwidGhpc1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJ0c1tpXSAhPT0gdmFsdWUpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2hlc1BhdHRlcm4uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94965\n')},85004:(__unused_webpack_module,exports)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = isCompatTag;\nfunction isCompatTag(tagName) {\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n\n//# sourceMappingURL=isCompatTag.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUwMDQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC90eXBlcy9saWIvdmFsaWRhdG9ycy9yZWFjdC9pc0NvbXBhdFRhZy5qcz8zMThlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gaXNDb21wYXRUYWc7XG5mdW5jdGlvbiBpc0NvbXBhdFRhZyh0YWdOYW1lKSB7XG4gIHJldHVybiAhIXRhZ05hbWUgJiYgL15bYS16XS8udGVzdCh0YWdOYW1lKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNDb21wYXRUYWcuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///85004\n')},45682:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = void 0;\nvar _buildMatchMemberExpression = __webpack_require__(3937);\nconst isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");\nvar _default = exports["default"] = isReactComponent;\n\n//# sourceMappingURL=isReactComponent.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU2ODIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixrQ0FBa0MsbUJBQU8sQ0FBQyxJQUFrQztBQUM1RTtBQUNBLGVBQWUsa0JBQWU7O0FBRTlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvcmVhY3QvaXNSZWFjdENvbXBvbmVudC5qcz9lNjVhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbiA9IHJlcXVpcmUoXCIuLi9idWlsZE1hdGNoTWVtYmVyRXhwcmVzc2lvbi5qc1wiKTtcbmNvbnN0IGlzUmVhY3RDb21wb25lbnQgPSAoMCwgX2J1aWxkTWF0Y2hNZW1iZXJFeHByZXNzaW9uLmRlZmF1bHQpKFwiUmVhY3QuQ29tcG9uZW50XCIpO1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0cy5kZWZhdWx0ID0gaXNSZWFjdENvbXBvbmVudDtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNSZWFjdENvbXBvbmVudC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45682\n')},57446:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", ({\n  value: true\n}));\nexports["default"] = validate;\nexports.validateChild = validateChild;\nexports.validateField = validateField;\nexports.validateInternal = validateInternal;\nvar _index = __webpack_require__(39793);\nfunction validate(node, key, val) {\n  if (!node) return;\n  const fields = _index.NODE_FIELDS[node.type];\n  if (!fields) return;\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\nfunction validateInternal(field, node, key, val, maybeNode) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n  if (maybeNode) {\n    var _NODE_PARENT_VALIDATI;\n    const type = val.type;\n    if (type == null) return;\n    (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n  }\n}\nfunction validateField(node, key, val, field) {\n  if (!(field != null && field.validate)) return;\n  if (field.optional && val == null) return;\n  field.validate(node, key, val);\n}\nfunction validateChild(node, key, val) {\n  var _NODE_PARENT_VALIDATI2;\n  const type = val == null ? void 0 : val.type;\n  if (type == null) return;\n  (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node, key, val);\n}\n\n//# sourceMappingURL=validate.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc0NDYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsOENBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxFQUFDO0FBQ0Ysa0JBQWU7QUFDZixxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCLHdCQUF3QjtBQUN4QixhQUFhLG1CQUFPLENBQUMsS0FBeUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvdHlwZXMvbGliL3ZhbGlkYXRvcnMvdmFsaWRhdGUuanM/ODNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZhbGlkYXRlO1xuZXhwb3J0cy52YWxpZGF0ZUNoaWxkID0gdmFsaWRhdGVDaGlsZDtcbmV4cG9ydHMudmFsaWRhdGVGaWVsZCA9IHZhbGlkYXRlRmllbGQ7XG5leHBvcnRzLnZhbGlkYXRlSW50ZXJuYWwgPSB2YWxpZGF0ZUludGVybmFsO1xudmFyIF9pbmRleCA9IHJlcXVpcmUoXCIuLi9kZWZpbml0aW9ucy9pbmRleC5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuO1xuICBjb25zdCBmaWVsZHMgPSBfaW5kZXguTk9ERV9GSUVMRFNbbm9kZS50eXBlXTtcbiAgaWYgKCFmaWVsZHMpIHJldHVybjtcbiAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcbiAgdmFsaWRhdGVGaWVsZChub2RlLCBrZXksIHZhbCwgZmllbGQpO1xuICB2YWxpZGF0ZUNoaWxkKG5vZGUsIGtleSwgdmFsKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSW50ZXJuYWwoZmllbGQsIG5vZGUsIGtleSwgdmFsLCBtYXliZU5vZGUpIHtcbiAgaWYgKCEoZmllbGQgIT0gbnVsbCAmJiBmaWVsZC52YWxpZGF0ZSkpIHJldHVybjtcbiAgaWYgKGZpZWxkLm9wdGlvbmFsICYmIHZhbCA9PSBudWxsKSByZXR1cm47XG4gIGZpZWxkLnZhbGlkYXRlKG5vZGUsIGtleSwgdmFsKTtcbiAgaWYgKG1heWJlTm9kZSkge1xuICAgIHZhciBfTk9ERV9QQVJFTlRfVkFMSURBVEk7XG4gICAgY29uc3QgdHlwZSA9IHZhbC50eXBlO1xuICAgIGlmICh0eXBlID09IG51bGwpIHJldHVybjtcbiAgICAoX05PREVfUEFSRU5UX1ZBTElEQVRJID0gX2luZGV4Lk5PREVfUEFSRU5UX1ZBTElEQVRJT05TW3R5cGVdKSA9PSBudWxsIHx8IF9OT0RFX1BBUkVOVF9WQUxJREFUSS5jYWxsKF9pbmRleC5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUywgbm9kZSwga2V5LCB2YWwpO1xuICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKG5vZGUsIGtleSwgdmFsLCBmaWVsZCkge1xuICBpZiAoIShmaWVsZCAhPSBudWxsICYmIGZpZWxkLnZhbGlkYXRlKSkgcmV0dXJuO1xuICBpZiAoZmllbGQub3B0aW9uYWwgJiYgdmFsID09IG51bGwpIHJldHVybjtcbiAgZmllbGQudmFsaWRhdGUobm9kZSwga2V5LCB2YWwpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZChub2RlLCBrZXksIHZhbCkge1xuICB2YXIgX05PREVfUEFSRU5UX1ZBTElEQVRJMjtcbiAgY29uc3QgdHlwZSA9IHZhbCA9PSBudWxsID8gdm9pZCAwIDogdmFsLnR5cGU7XG4gIGlmICh0eXBlID09IG51bGwpIHJldHVybjtcbiAgKF9OT0RFX1BBUkVOVF9WQUxJREFUSTIgPSBfaW5kZXguTk9ERV9QQVJFTlRfVkFMSURBVElPTlNbdHlwZV0pID09IG51bGwgfHwgX05PREVfUEFSRU5UX1ZBTElEQVRJMi5jYWxsKF9pbmRleC5OT0RFX1BBUkVOVF9WQUxJREFUSU9OUywgbm9kZSwga2V5LCB2YWwpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0ZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57446\n')},68553:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  Ay: () => (/* binding */ Ft)\n});\n\n// UNUSED EXPORTS: DiffEditor, Editor, loader, useMonaco\n\n;// ./node_modules/@monaco-editor/loader/lib/es/_virtual/_rollupPluginBabelHelpers.js\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i["return"] != null) _i["return"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === "string") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === "Object" && o.constructor) n = o.constructor.name;\n  if (n === "Map" || n === "Set") return Array.from(o);\n  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");\n}\n\n\n\n;// ./node_modules/state-local/lib/es/state-local.js\nfunction state_local_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction state_local_ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction state_local_objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      state_local_ownKeys(Object(source), true).forEach(function (key) {\n        state_local_defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      state_local_ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (x) {\n    return fns.reduceRight(function (y, f) {\n      return f(y);\n    }, x);\n  };\n}\n\nfunction curry(fn) {\n  return function curried() {\n    var _this = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return args.length >= fn.length ? fn.apply(this, args) : function () {\n      for (var _len3 = arguments.length, nextArgs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        nextArgs[_key3] = arguments[_key3];\n      }\n\n      return curried.apply(_this, [].concat(args, nextArgs));\n    };\n  };\n}\n\nfunction isObject(value) {\n  return {}.toString.call(value).includes(\'Object\');\n}\n\nfunction isEmpty(obj) {\n  return !Object.keys(obj).length;\n}\n\nfunction isFunction(value) {\n  return typeof value === \'function\';\n}\n\nfunction state_local_hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n\nfunction validateChanges(initial, changes) {\n  if (!isObject(changes)) errorHandler(\'changeType\');\n  if (Object.keys(changes).some(function (field) {\n    return !state_local_hasOwnProperty(initial, field);\n  })) errorHandler(\'changeField\');\n  return changes;\n}\n\nfunction validateSelector(selector) {\n  if (!isFunction(selector)) errorHandler(\'selectorType\');\n}\n\nfunction validateHandler(handler) {\n  if (!(isFunction(handler) || isObject(handler))) errorHandler(\'handlerType\');\n  if (isObject(handler) && Object.values(handler).some(function (_handler) {\n    return !isFunction(_handler);\n  })) errorHandler(\'handlersType\');\n}\n\nfunction validateInitial(initial) {\n  if (!initial) errorHandler(\'initialIsRequired\');\n  if (!isObject(initial)) errorHandler(\'initialType\');\n  if (isEmpty(initial)) errorHandler(\'initialContent\');\n}\n\nfunction throwError(errorMessages, type) {\n  throw new Error(errorMessages[type] || errorMessages["default"]);\n}\n\nvar errorMessages = {\n  initialIsRequired: \'initial state is required\',\n  initialType: \'initial state should be an object\',\n  initialContent: \'initial state shouldn\\\'t be an empty object\',\n  handlerType: \'handler should be an object or a function\',\n  handlersType: \'all handlers should be a functions\',\n  selectorType: \'selector should be a function\',\n  changeType: \'provided value of changes should be an object\',\n  changeField: \'it seams you want to change a field in the state which is not specified in the "initial" state\',\n  "default": \'an unknown error accured in `state-local` package\'\n};\nvar errorHandler = curry(throwError)(errorMessages);\nvar validators = {\n  changes: validateChanges,\n  selector: validateSelector,\n  handler: validateHandler,\n  initial: validateInitial\n};\n\nfunction create(initial) {\n  var handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  validators.initial(initial);\n  validators.handler(handler);\n  var state = {\n    current: initial\n  };\n  var didUpdate = curry(didStateUpdate)(state, handler);\n  var update = curry(updateState)(state);\n  var validate = curry(validators.changes)(initial);\n  var getChanges = curry(extractChanges)(state);\n\n  function getState() {\n    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (state) {\n      return state;\n    };\n    validators.selector(selector);\n    return selector(state.current);\n  }\n\n  function setState(causedChanges) {\n    compose(didUpdate, update, validate, getChanges)(causedChanges);\n  }\n\n  return [getState, setState];\n}\n\nfunction extractChanges(state, causedChanges) {\n  return isFunction(causedChanges) ? causedChanges(state.current) : causedChanges;\n}\n\nfunction updateState(state, changes) {\n  state.current = state_local_objectSpread2(state_local_objectSpread2({}, state.current), changes);\n  return changes;\n}\n\nfunction didStateUpdate(state, handler, changes) {\n  isFunction(handler) ? handler(state.current) : Object.keys(changes).forEach(function (field) {\n    var _handler$field;\n\n    return (_handler$field = handler[field]) === null || _handler$field === void 0 ? void 0 : _handler$field.call(handler, state.current[field]);\n  });\n  return changes;\n}\n\nvar index = {\n  create: create\n};\n\n/* harmony default export */ const state_local = (index);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/config/index.js\nvar config = {\n  paths: {\n    vs: \'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs\'\n  }\n};\n\n/* harmony default export */ const es_config = (config);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/utils/curry.js\nfunction curry_curry(fn) {\n  return function curried() {\n    var _this = this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return args.length >= fn.length ? fn.apply(this, args) : function () {\n      for (var _len2 = arguments.length, nextArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nextArgs[_key2] = arguments[_key2];\n      }\n\n      return curried.apply(_this, [].concat(args, nextArgs));\n    };\n  };\n}\n\n/* harmony default export */ const utils_curry = (curry_curry);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/utils/isObject.js\nfunction isObject_isObject(value) {\n  return {}.toString.call(value).includes(\'Object\');\n}\n\n/* harmony default export */ const utils_isObject = (isObject_isObject);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/validators/index.js\n\n\n\n/**\n * validates the configuration object and informs about deprecation\n * @param {Object} config - the configuration object \n * @return {Object} config - the validated configuration object\n */\n\nfunction validateConfig(config) {\n  if (!config) validators_errorHandler(\'configIsRequired\');\n  if (!utils_isObject(config)) validators_errorHandler(\'configType\');\n\n  if (config.urls) {\n    informAboutDeprecation();\n    return {\n      paths: {\n        vs: config.urls.monacoBase\n      }\n    };\n  }\n\n  return config;\n}\n/**\n * logs deprecation message\n */\n\n\nfunction informAboutDeprecation() {\n  console.warn(validators_errorMessages.deprecation);\n}\n\nfunction validators_throwError(errorMessages, type) {\n  throw new Error(errorMessages[type] || errorMessages["default"]);\n}\n\nvar validators_errorMessages = {\n  configIsRequired: \'the configuration object is required\',\n  configType: \'the configuration object should be an object\',\n  "default": \'an unknown error accured in `@monaco-editor/loader` package\',\n  deprecation: "Deprecation warning!\\n    You are using deprecated way of configuration.\\n\\n    Instead of using\\n      monaco.config({ urls: { monacoBase: \'...\' } })\\n    use\\n      monaco.config({ paths: { vs: \'...\' } })\\n\\n    For more please check the link https://github.com/suren-atoyan/monaco-loader#config\\n  "\n};\nvar validators_errorHandler = utils_curry(validators_throwError)(validators_errorMessages);\nvar validators_validators = {\n  config: validateConfig\n};\n\n/* harmony default export */ const es_validators = (validators_validators);\n\n\n;// ./node_modules/@monaco-editor/loader/lib/es/utils/compose.js\nvar compose_compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (x) {\n    return fns.reduceRight(function (y, f) {\n      return f(y);\n    }, x);\n  };\n};\n\n/* harmony default export */ const utils_compose = (compose_compose);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/utils/deepMerge.js\n\n\nfunction merge(target, source) {\n  Object.keys(source).forEach(function (key) {\n    if (source[key] instanceof Object) {\n      if (target[key]) {\n        Object.assign(source[key], merge(target[key], source[key]));\n      }\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, target), source);\n}\n\n/* harmony default export */ const deepMerge = (merge);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/utils/makeCancelable.js\n// The source (has been changed) is https://github.com/facebook/react/issues/5465#issuecomment-157888325\nvar CANCELATION_MESSAGE = {\n  type: \'cancelation\',\n  msg: \'operation is manually canceled\'\n};\n\nfunction makeCancelable(promise) {\n  var hasCanceled_ = false;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    promise.then(function (val) {\n      return hasCanceled_ ? reject(CANCELATION_MESSAGE) : resolve(val);\n    });\n    promise["catch"](reject);\n  });\n  return wrappedPromise.cancel = function () {\n    return hasCanceled_ = true;\n  }, wrappedPromise;\n}\n\n/* harmony default export */ const utils_makeCancelable = (makeCancelable);\n\n\n;// ./node_modules/@monaco-editor/loader/lib/es/loader/index.js\n\n\n\n\n\n\n\n\n/** the local state of the module */\n\nvar _state$create = state_local.create({\n  config: es_config,\n  isInitialized: false,\n  resolve: null,\n  reject: null,\n  monaco: null\n}),\n    _state$create2 = _slicedToArray(_state$create, 2),\n    getState = _state$create2[0],\n    setState = _state$create2[1];\n/**\n * set the loader configuration\n * @param {Object} config - the configuration object\n */\n\n\nfunction loader_config(globalConfig) {\n  var _validators$config = es_validators.config(globalConfig),\n      monaco = _validators$config.monaco,\n      config = _objectWithoutProperties(_validators$config, ["monaco"]);\n\n  setState(function (state) {\n    return {\n      config: deepMerge(state.config, config),\n      monaco: monaco\n    };\n  });\n}\n/**\n * handles the initialization of the monaco-editor\n * @return {Promise} - returns an instance of monaco (with a cancelable promise)\n */\n\n\nfunction init() {\n  var state = getState(function (_ref) {\n    var monaco = _ref.monaco,\n        isInitialized = _ref.isInitialized,\n        resolve = _ref.resolve;\n    return {\n      monaco: monaco,\n      isInitialized: isInitialized,\n      resolve: resolve\n    };\n  });\n\n  if (!state.isInitialized) {\n    setState({\n      isInitialized: true\n    });\n\n    if (state.monaco) {\n      state.resolve(state.monaco);\n      return utils_makeCancelable(wrapperPromise);\n    }\n\n    if (window.monaco && window.monaco.editor) {\n      storeMonacoInstance(window.monaco);\n      state.resolve(window.monaco);\n      return utils_makeCancelable(wrapperPromise);\n    }\n\n    utils_compose(injectScripts, getMonacoLoaderScript)(configureLoader);\n  }\n\n  return utils_makeCancelable(wrapperPromise);\n}\n/**\n * injects provided scripts into the document.body\n * @param {Object} script - an HTML script element\n * @return {Object} - the injected HTML script element\n */\n\n\nfunction injectScripts(script) {\n  return document.body.appendChild(script);\n}\n/**\n * creates an HTML script element with/without provided src\n * @param {string} [src] - the source path of the script\n * @return {Object} - the created HTML script element\n */\n\n\nfunction createScript(src) {\n  var script = document.createElement(\'script\');\n  return src && (script.src = src), script;\n}\n/**\n * creates an HTML script element with the monaco loader src\n * @return {Object} - the created HTML script element\n */\n\n\nfunction getMonacoLoaderScript(configureLoader) {\n  var state = getState(function (_ref2) {\n    var config = _ref2.config,\n        reject = _ref2.reject;\n    return {\n      config: config,\n      reject: reject\n    };\n  });\n  var loaderScript = createScript("".concat(state.config.paths.vs, "/loader.js"));\n\n  loaderScript.onload = function () {\n    return configureLoader();\n  };\n\n  loaderScript.onerror = state.reject;\n  return loaderScript;\n}\n/**\n * configures the monaco loader\n */\n\n\nfunction configureLoader() {\n  var state = getState(function (_ref3) {\n    var config = _ref3.config,\n        resolve = _ref3.resolve,\n        reject = _ref3.reject;\n    return {\n      config: config,\n      resolve: resolve,\n      reject: reject\n    };\n  });\n  var require = window.require;\n\n  require.config(state.config);\n\n  require([\'vs/editor/editor.main\'], function (monaco) {\n    storeMonacoInstance(monaco);\n    state.resolve(monaco);\n  }, function (error) {\n    state.reject(error);\n  });\n}\n/**\n * store monaco instance in local state\n */\n\n\nfunction storeMonacoInstance(monaco) {\n  if (!getState().monaco) {\n    setState({\n      monaco: monaco\n    });\n  }\n}\n/**\n * internal helper function\n * extracts stored monaco instance\n * @return {Object|null} - the monaco instance\n */\n\n\nfunction __getMonacoInstance() {\n  return getState(function (_ref4) {\n    var monaco = _ref4.monaco;\n    return monaco;\n  });\n}\n\nvar wrapperPromise = new Promise(function (resolve, reject) {\n  return setState({\n    resolve: resolve,\n    reject: reject\n  });\n});\nvar loader = {\n  config: loader_config,\n  init: init,\n  __getMonacoInstance: __getMonacoInstance\n};\n\n/* harmony default export */ const es_loader = (loader);\n\n;// ./node_modules/@monaco-editor/loader/lib/es/index.js\n\n\n\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(96540);\n;// ./node_modules/@monaco-editor/react/dist/index.mjs\nvar le={wrapper:{display:"flex",position:"relative",textAlign:"initial"},fullWidth:{width:"100%"},hide:{display:"none"}},v=le;var ae={container:{display:"flex",height:"100%",width:"100%",justifyContent:"center",alignItems:"center"}},Y=ae;function Me({children:e}){return react.createElement("div",{style:Y.container},e)}var Z=Me;var $=Z;function Ee({width:e,height:r,isEditorReady:n,loading:t,_ref:a,className:m,wrapperProps:E}){return react.createElement("section",{style:{...v.wrapper,width:e,height:r},...E},!n&&react.createElement($,null,t),react.createElement("div",{ref:a,style:{...v.fullWidth,...!n&&v.hide},className:m}))}var ee=Ee;var H=(0,react.memo)(ee);function Ce(e){(0,react.useEffect)(e,[])}var k=Ce;function he(e,r,n=!0){let t=(0,react.useRef)(!0);(0,react.useEffect)(t.current||!n?()=>{t.current=!1}:e,r)}var l=he;function D(){}function h(e,r,n,t){return De(e,t)||be(e,r,n,t)}function De(e,r){return e.editor.getModel(te(e,r))}function be(e,r,n,t){return e.editor.createModel(r,n,t?te(e,t):void 0)}function te(e,r){return e.Uri.parse(r)}function Oe({original:e,modified:r,language:n,originalLanguage:t,modifiedLanguage:a,originalModelPath:m,modifiedModelPath:E,keepCurrentOriginalModel:g=!1,keepCurrentModifiedModel:N=!1,theme:x="light",loading:P="Loading...",options:y={},height:V="100%",width:z="100%",className:F,wrapperProps:j={},beforeMount:A=D,onMount:q=D}){let[M,O]=(0,react.useState)(!1),[T,s]=(0,react.useState)(!0),u=(0,react.useRef)(null),c=(0,react.useRef)(null),w=(0,react.useRef)(null),d=(0,react.useRef)(q),o=(0,react.useRef)(A),b=(0,react.useRef)(!1);k(()=>{let i=es_loader.init();return i.then(f=>(c.current=f)&&s(!1)).catch(f=>f?.type!=="cancelation"&&console.error("Monaco initialization: error:",f)),()=>u.current?I():i.cancel()}),l(()=>{if(u.current&&c.current){let i=u.current.getOriginalEditor(),f=h(c.current,e||"",t||n||"text",m||"");f!==i.getModel()&&i.setModel(f)}},[m],M),l(()=>{if(u.current&&c.current){let i=u.current.getModifiedEditor(),f=h(c.current,r||"",a||n||"text",E||"");f!==i.getModel()&&i.setModel(f)}},[E],M),l(()=>{let i=u.current.getModifiedEditor();i.getOption(c.current.editor.EditorOption.readOnly)?i.setValue(r||""):r!==i.getValue()&&(i.executeEdits("",[{range:i.getModel().getFullModelRange(),text:r||"",forceMoveMarkers:!0}]),i.pushUndoStop())},[r],M),l(()=>{u.current?.getModel()?.original.setValue(e||"")},[e],M),l(()=>{let{original:i,modified:f}=u.current.getModel();c.current.editor.setModelLanguage(i,t||n||"text"),c.current.editor.setModelLanguage(f,a||n||"text")},[n,t,a],M),l(()=>{c.current?.editor.setTheme(x)},[x],M),l(()=>{u.current?.updateOptions(y)},[y],M);let L=(0,react.useCallback)(()=>{if(!c.current)return;o.current(c.current);let i=h(c.current,e||"",t||n||"text",m||""),f=h(c.current,r||"",a||n||"text",E||"");u.current?.setModel({original:i,modified:f})},[n,r,a,e,t,m,E]),U=(0,react.useCallback)(()=>{!b.current&&w.current&&(u.current=c.current.editor.createDiffEditor(w.current,{automaticLayout:!0,...y}),L(),c.current?.editor.setTheme(x),O(!0),b.current=!0)},[y,x,L]);(0,react.useEffect)(()=>{M&&d.current(u.current,c.current)},[M]),(0,react.useEffect)(()=>{!T&&!M&&U()},[T,M,U]);function I(){let i=u.current?.getModel();g||i?.original?.dispose(),N||i?.modified?.dispose(),u.current?.dispose()}return react.createElement(H,{width:z,height:V,isEditorReady:M,loading:P,_ref:w,className:F,wrapperProps:j})}var ie=Oe;var we=(0,react.memo)(ie);function Pe(){let[e,r]=Ie(ce.__getMonacoInstance());return k(()=>{let n;return e||(n=ce.init(),n.then(t=>{r(t)})),()=>n?.cancel()}),e}var Le=(/* unused pure expression or super */ null && (Pe));function He(e){let r=(0,react.useRef)();return (0,react.useEffect)(()=>{r.current=e},[e]),r.current}var se=He;var _=new Map;function Ve({defaultValue:e,defaultLanguage:r,defaultPath:n,value:t,language:a,path:m,theme:E="light",line:g,loading:N="Loading...",options:x={},overrideServices:P={},saveViewState:y=!0,keepCurrentModel:V=!1,width:z="100%",height:F="100%",className:j,wrapperProps:A={},beforeMount:q=D,onMount:M=D,onChange:O,onValidate:T=D}){let[s,u]=(0,react.useState)(!1),[c,w]=(0,react.useState)(!0),d=(0,react.useRef)(null),o=(0,react.useRef)(null),b=(0,react.useRef)(null),L=(0,react.useRef)(M),U=(0,react.useRef)(q),I=(0,react.useRef)(),i=(0,react.useRef)(t),f=se(m),Q=(0,react.useRef)(!1),B=(0,react.useRef)(!1);k(()=>{let p=es_loader.init();return p.then(R=>(d.current=R)&&w(!1)).catch(R=>R?.type!=="cancelation"&&console.error("Monaco initialization: error:",R)),()=>o.current?pe():p.cancel()}),l(()=>{let p=h(d.current,e||t||"",r||a||"",m||n||"");p!==o.current?.getModel()&&(y&&_.set(f,o.current?.saveViewState()),o.current?.setModel(p),y&&o.current?.restoreViewState(_.get(m)))},[m],s),l(()=>{o.current?.updateOptions(x)},[x],s),l(()=>{!o.current||t===void 0||(o.current.getOption(d.current.editor.EditorOption.readOnly)?o.current.setValue(t):t!==o.current.getValue()&&(B.current=!0,o.current.executeEdits("",[{range:o.current.getModel().getFullModelRange(),text:t,forceMoveMarkers:!0}]),o.current.pushUndoStop(),B.current=!1))},[t],s),l(()=>{let p=o.current?.getModel();p&&a&&d.current?.editor.setModelLanguage(p,a)},[a],s),l(()=>{g!==void 0&&o.current?.revealLine(g)},[g],s),l(()=>{d.current?.editor.setTheme(E)},[E],s);let X=(0,react.useCallback)(()=>{if(!(!b.current||!d.current)&&!Q.current){U.current(d.current);let p=m||n,R=h(d.current,t||e||"",r||a||"",p||"");o.current=d.current?.editor.create(b.current,{model:R,automaticLayout:!0,...x},P),y&&o.current.restoreViewState(_.get(p)),d.current.editor.setTheme(E),g!==void 0&&o.current.revealLine(g),u(!0),Q.current=!0}},[e,r,n,t,a,m,x,P,y,E,g]);(0,react.useEffect)(()=>{s&&L.current(o.current,d.current)},[s]),(0,react.useEffect)(()=>{!c&&!s&&X()},[c,s,X]),i.current=t,(0,react.useEffect)(()=>{s&&O&&(I.current?.dispose(),I.current=o.current?.onDidChangeModelContent(p=>{B.current||O(o.current.getValue(),p)}))},[s,O]),(0,react.useEffect)(()=>{if(s){let p=d.current.editor.onDidChangeMarkers(R=>{let G=o.current.getModel()?.uri;if(G&&R.find(J=>J.path===G.path)){let J=d.current.editor.getModelMarkers({resource:G});T?.(J)}});return()=>{p?.dispose()}}return()=>{}},[s,T]);function pe(){I.current?.dispose(),V?y&&_.set(m,o.current.saveViewState()):o.current.getModel()?.dispose(),o.current.dispose()}return react.createElement(H,{width:z,height:F,isEditorReady:s,loading:N,_ref:b,className:j,wrapperProps:A})}var fe=Ve;var de=(0,react.memo)(fe);var Ft=de;\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg1NTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsK0JBQStCO0FBQzdFOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUzs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRTRiOzs7QUM3STViLFNBQVMsMEJBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyxtQkFBTztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyx5QkFBYztBQUN2QixrQkFBa0Isc0JBQXNCO0FBQ3hDOztBQUVBO0FBQ0EsTUFBTSxtQkFBTztBQUNiLFFBQVEsMEJBQWU7QUFDdkIsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixNQUFNLG1CQUFPO0FBQ2I7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkVBQTJFLGVBQWU7QUFDMUY7QUFDQTs7QUFFQTtBQUNBLGlGQUFpRixlQUFlO0FBQ2hHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDBCQUFjO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBYztBQUMxQixHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHlCQUFjLENBQUMseUJBQWMsR0FBRztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrREFBZSxLQUFLLEVBQUM7OztBQ2hNckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZSxNQUFNLEVBQUM7OztBQ050QixTQUFTLFdBQUs7QUFDZDtBQUNBOztBQUVBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQSxpRkFBaUYsZUFBZTtBQUNoRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFlLFdBQUssRUFBQzs7O0FDbEJyQixTQUFTLGlCQUFRO0FBQ2pCLFdBQVc7QUFDWDs7QUFFQSxxREFBZSxpQkFBUSxFQUFDOzs7QUNKYztBQUNNOztBQUU1QztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7QUFFQTtBQUNBLGVBQWUsdUJBQVk7QUFDM0IsT0FBTyxjQUFRLFVBQVUsdUJBQVk7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxlQUFlLHdCQUFhO0FBQzVCOztBQUVBLFNBQVMscUJBQVU7QUFDbkI7QUFDQTs7QUFFQSxJQUFJLHdCQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHdJQUF3SSxRQUFRLHFCQUFxQixrQ0FBa0MsU0FBUyxhQUFhO0FBQzdOO0FBQ0EsSUFBSSx1QkFBWSxHQUFHLFdBQUssQ0FBQyxxQkFBVSxFQUFFLHdCQUFhO0FBQ2xELElBQUkscUJBQVU7QUFDZDtBQUNBOztBQUVBLG9EQUFlLHFCQUFVLEVBQUM7QUFDYTs7O0FDakR2QyxJQUFJLGVBQU87QUFDWCxxRUFBcUUsYUFBYTtBQUNsRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLG9EQUFlLGVBQU8sRUFBQzs7O0FDWm9FOztBQUUzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLGNBQWMsQ0FBQyxjQUFjLEdBQUc7QUFDekM7O0FBRUEsZ0RBQWUsS0FBSyxFQUFDOzs7QUNickI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsMkRBQWUsY0FBYyxFQUFDO0FBQ0M7OztBQ3BCaUg7QUFDaEg7QUFDVTtBQUNNO0FBQ047QUFDQTtBQUNjOztBQUV4RDs7QUFFQSxvQkFBb0IsV0FBSztBQUN6QixVQUFVLFNBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7OztBQUdBLFNBQVMsYUFBTTtBQUNmLDJCQUEyQixhQUFVO0FBQ3JDO0FBQ0EsZUFBZSx3QkFBd0I7O0FBRXZDO0FBQ0E7QUFDQSxjQUFjLFNBQUs7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxhQUFhLG9CQUFjO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQWM7QUFDM0I7O0FBRUEsSUFBSSxhQUFPO0FBQ1g7O0FBRUEsU0FBUyxvQkFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsVUFBVSxhQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQSxnREFBZSxNQUFNLEVBQUM7OztBQzNMaUI7QUFDSzs7Ozs7QUNEcU0sUUFBUSxTQUFTLHVEQUF1RCxZQUFZLGFBQWEsT0FBTyxnQkFBZ0IsTUFBNEIsUUFBUSxXQUFXLHVGQUF1RixNQUFNLGFBQWEsV0FBVyxFQUFFLE9BQU8sbUJBQWdCLFFBQVEsa0JBQWtCLElBQUksU0FBUyxRQUFRLGFBQWEsNkVBQTZFLEVBQUUsT0FBTyxtQkFBZSxZQUFZLE9BQU8sOEJBQThCLE1BQU0sS0FBSyxtQkFBZSxXQUFXLG1CQUFlLFFBQVEsYUFBYSw2QkFBNkIsYUFBYSxHQUFHLFVBQVUsTUFBTSxjQUFFLEtBQXdDLGVBQWUsbUJBQUUsT0FBTyxTQUF5RCxzQkFBc0IsTUFBTSxnQkFBRSxLQUFLLG1CQUFFLG9CQUFvQixhQUFhLE1BQU0sU0FBUyxjQUFjLG9CQUFvQiw0QkFBNEIsaUJBQWlCLGtDQUFrQyxxQkFBcUIsa0RBQWtELGlCQUFpQixzQkFBc0IsYUFBYSw4TkFBOE4sNkRBQTZELDZCQUE2QixFQUFFLFNBQVMsa0JBQUUsV0FBVyxrQkFBRSxPQUFPLGdCQUFDLFNBQVMsZ0JBQUMsU0FBUyxnQkFBQyxTQUFTLGdCQUFDLE1BQU0sZ0JBQUMsTUFBTSxnQkFBQyxLQUFLLE9BQU8sTUFBTSxTQUFFLFFBQVEsd0pBQXdKLFNBQVMseUJBQXlCLDRFQUE0RSxpQ0FBaUMsZUFBZSx5QkFBeUIsNEVBQTRFLGlDQUFpQyxlQUFlLG9DQUFvQyw2R0FBNkcsc0VBQXNFLHFCQUFxQixlQUFlLGdEQUFnRCxlQUFlLElBQUksc0JBQXNCLHNCQUFzQixvR0FBb0csbUJBQW1CLDhCQUE4QixlQUFlLDRCQUE0QixRQUFRLE1BQU0scUJBQUUsTUFBTSxxQkFBcUIscUJBQXFCLG9GQUFvRixxQkFBcUIsc0JBQXNCLEVBQUUsb0JBQW9CLHFCQUFFLE1BQU0sK0VBQStFLHdCQUF3Qix3REFBd0QsVUFBVSxtQkFBRSxNQUFNLGtDQUFrQyxNQUFNLG1CQUFFLE1BQU0sWUFBWSxVQUFVLGFBQWEsNEJBQTRCLHlFQUF5RSxPQUFPLG1CQUFnQixJQUFJLDZFQUE2RSxFQUFFLFVBQVUsT0FBTyxjQUFFLEtBQTZFLGNBQWMsc0NBQXNDLGNBQWMsTUFBTSxrQ0FBa0MsS0FBSyxtQkFBbUIsSUFBSSxPQUFPLGtEQUFFLEdBQXdNLGVBQWUsTUFBTSxnQkFBRSxHQUFHLE9BQU8sbUJBQUUsTUFBTSxZQUFZLGdCQUFnQixVQUFVLGNBQWMsYUFBYSxtSUFBbUksc0JBQXNCLHNHQUFzRyx1REFBdUQsRUFBRSxTQUFTLGtCQUFFLFdBQVcsa0JBQUUsT0FBTyxnQkFBQyxTQUFTLGdCQUFDLFNBQVMsZ0JBQUMsU0FBUyxnQkFBQyxNQUFNLGdCQUFDLE1BQU0sZ0JBQUMsS0FBSyxnQkFBQyxjQUFjLGdCQUFDLE9BQU8sZ0JBQUMsS0FBSyxPQUFPLE1BQU0sU0FBRSxRQUFRLHlKQUF5SixTQUFTLDhDQUE4QyxvSUFBb0ksZUFBZSw0QkFBNEIsZUFBZSwrS0FBK0ssMEVBQTBFLDJDQUEyQyxlQUFlLDRCQUE0Qiw4Q0FBOEMsZUFBZSxxQ0FBcUMsZUFBZSw4QkFBOEIsUUFBUSxNQUFNLHFCQUFFLE1BQU0sMENBQTBDLHFCQUFxQixrREFBa0QsOENBQThDLGdDQUFnQyxpSUFBaUksMEJBQTBCLG1CQUFDLE1BQU0sa0NBQWtDLE1BQU0sbUJBQUMsTUFBTSxZQUFZLHNCQUFzQixtQkFBQyxNQUFNLDZFQUE2RSxxQ0FBcUMsR0FBRyxRQUFRLG1CQUFDLE1BQU0sTUFBTSw4Q0FBOEMsZ0NBQWdDLGtDQUFrQyx3Q0FBd0MsV0FBVyxFQUFFLFFBQVEsRUFBRSxXQUFXLGNBQWMsYUFBYSxRQUFRLGNBQWMsaUhBQWlILE9BQU8sbUJBQWdCLElBQUksNkVBQTZFLEVBQUUsVUFBVSxPQUFPLGNBQUUsS0FBSyxVQUEyRjtBQUM3MU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0Btb25hY28tZWRpdG9yL2xvYWRlci9saWIvZXMvX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcz9lN2Q1Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvc3RhdGUtbG9jYWwvbGliL2VzL3N0YXRlLWxvY2FsLmpzPzg2NjYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL2NvbmZpZy9pbmRleC5qcz8zN2ZkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy91dGlscy9jdXJyeS5qcz8xMjVmIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy91dGlscy9pc09iamVjdC5qcz80YTZkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy92YWxpZGF0b3JzL2luZGV4LmpzPzJjMzciLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL3V0aWxzL2NvbXBvc2UuanM/YTYxYyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0Btb25hY28tZWRpdG9yL2xvYWRlci9saWIvZXMvdXRpbHMvZGVlcE1lcmdlLmpzP2I2YzUiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL3V0aWxzL21ha2VDYW5jZWxhYmxlLmpzP2EyYjYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbW9uYWNvLWVkaXRvci9sb2FkZXIvbGliL2VzL2xvYWRlci9pbmRleC5qcz9mNWI5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvbG9hZGVyL2xpYi9lcy9pbmRleC5qcz9mZmI2Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQG1vbmFjby1lZGl0b3IvcmVhY3QvZGlzdC9pbmRleC5tanM/YmVkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgIGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pO1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuXG4gIHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcblxuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuO1xuICB2YXIgX2FyciA9IFtdO1xuICB2YXIgX24gPSB0cnVlO1xuICB2YXIgX2QgPSBmYWxzZTtcbiAgdmFyIF9lID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgX2Fyci5wdXNoKF9zLnZhbHVlKTtcblxuICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2QgPSB0cnVlO1xuICAgIF9lID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9hcnI7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuXG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5leHBvcnQgeyBfYXJyYXlMaWtlVG9BcnJheSBhcyBhcnJheUxpa2VUb0FycmF5LCBfYXJyYXlXaXRoSG9sZXMgYXMgYXJyYXlXaXRoSG9sZXMsIF9kZWZpbmVQcm9wZXJ0eSBhcyBkZWZpbmVQcm9wZXJ0eSwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0IGFzIGl0ZXJhYmxlVG9BcnJheUxpbWl0LCBfbm9uSXRlcmFibGVSZXN0IGFzIG5vbkl0ZXJhYmxlUmVzdCwgX29iamVjdFNwcmVhZDIgYXMgb2JqZWN0U3ByZWFkMiwgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGFzIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzLCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBhcyBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLCBfc2xpY2VkVG9BcnJheSBhcyBzbGljZWRUb0FycmF5LCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgYXMgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgfTtcbiIsImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZm5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGZuc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBmbnMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKHksIGYpIHtcbiAgICAgIHJldHVybiBmKHkpO1xuICAgIH0sIHgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjdXJyeShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gY3VycmllZCgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID49IGZuLmxlbmd0aCA/IGZuLmFwcGx5KHRoaXMsIGFyZ3MpIDogZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBuZXh0QXJncyA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICBuZXh0QXJnc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmllZC5hcHBseShfdGhpcywgW10uY29uY2F0KGFyZ3MsIG5leHRBcmdzKSk7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpLmluY2x1ZGVzKCdPYmplY3QnKTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgcmV0dXJuICFPYmplY3Qua2V5cyhvYmopLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hhbmdlcyhpbml0aWFsLCBjaGFuZ2VzKSB7XG4gIGlmICghaXNPYmplY3QoY2hhbmdlcykpIGVycm9ySGFuZGxlcignY2hhbmdlVHlwZScpO1xuICBpZiAoT2JqZWN0LmtleXMoY2hhbmdlcykuc29tZShmdW5jdGlvbiAoZmllbGQpIHtcbiAgICByZXR1cm4gIWhhc093blByb3BlcnR5KGluaXRpYWwsIGZpZWxkKTtcbiAgfSkpIGVycm9ySGFuZGxlcignY2hhbmdlRmllbGQnKTtcbiAgcmV0dXJuIGNoYW5nZXM7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgZXJyb3JIYW5kbGVyKCdzZWxlY3RvclR5cGUnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgaWYgKCEoaXNGdW5jdGlvbihoYW5kbGVyKSB8fCBpc09iamVjdChoYW5kbGVyKSkpIGVycm9ySGFuZGxlcignaGFuZGxlclR5cGUnKTtcbiAgaWYgKGlzT2JqZWN0KGhhbmRsZXIpICYmIE9iamVjdC52YWx1ZXMoaGFuZGxlcikuc29tZShmdW5jdGlvbiAoX2hhbmRsZXIpIHtcbiAgICByZXR1cm4gIWlzRnVuY3Rpb24oX2hhbmRsZXIpO1xuICB9KSkgZXJyb3JIYW5kbGVyKCdoYW5kbGVyc1R5cGUnKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbml0aWFsKGluaXRpYWwpIHtcbiAgaWYgKCFpbml0aWFsKSBlcnJvckhhbmRsZXIoJ2luaXRpYWxJc1JlcXVpcmVkJyk7XG4gIGlmICghaXNPYmplY3QoaW5pdGlhbCkpIGVycm9ySGFuZGxlcignaW5pdGlhbFR5cGUnKTtcbiAgaWYgKGlzRW1wdHkoaW5pdGlhbCkpIGVycm9ySGFuZGxlcignaW5pdGlhbENvbnRlbnQnKTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFcnJvcihlcnJvck1lc3NhZ2VzLCB0eXBlKSB7XG4gIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzW3R5cGVdIHx8IGVycm9yTWVzc2FnZXNbXCJkZWZhdWx0XCJdKTtcbn1cblxudmFyIGVycm9yTWVzc2FnZXMgPSB7XG4gIGluaXRpYWxJc1JlcXVpcmVkOiAnaW5pdGlhbCBzdGF0ZSBpcyByZXF1aXJlZCcsXG4gIGluaXRpYWxUeXBlOiAnaW5pdGlhbCBzdGF0ZSBzaG91bGQgYmUgYW4gb2JqZWN0JyxcbiAgaW5pdGlhbENvbnRlbnQ6ICdpbml0aWFsIHN0YXRlIHNob3VsZG5cXCd0IGJlIGFuIGVtcHR5IG9iamVjdCcsXG4gIGhhbmRsZXJUeXBlOiAnaGFuZGxlciBzaG91bGQgYmUgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24nLFxuICBoYW5kbGVyc1R5cGU6ICdhbGwgaGFuZGxlcnMgc2hvdWxkIGJlIGEgZnVuY3Rpb25zJyxcbiAgc2VsZWN0b3JUeXBlOiAnc2VsZWN0b3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24nLFxuICBjaGFuZ2VUeXBlOiAncHJvdmlkZWQgdmFsdWUgb2YgY2hhbmdlcyBzaG91bGQgYmUgYW4gb2JqZWN0JyxcbiAgY2hhbmdlRmllbGQ6ICdpdCBzZWFtcyB5b3Ugd2FudCB0byBjaGFuZ2UgYSBmaWVsZCBpbiB0aGUgc3RhdGUgd2hpY2ggaXMgbm90IHNwZWNpZmllZCBpbiB0aGUgXCJpbml0aWFsXCIgc3RhdGUnLFxuICBcImRlZmF1bHRcIjogJ2FuIHVua25vd24gZXJyb3IgYWNjdXJlZCBpbiBgc3RhdGUtbG9jYWxgIHBhY2thZ2UnXG59O1xudmFyIGVycm9ySGFuZGxlciA9IGN1cnJ5KHRocm93RXJyb3IpKGVycm9yTWVzc2FnZXMpO1xudmFyIHZhbGlkYXRvcnMgPSB7XG4gIGNoYW5nZXM6IHZhbGlkYXRlQ2hhbmdlcyxcbiAgc2VsZWN0b3I6IHZhbGlkYXRlU2VsZWN0b3IsXG4gIGhhbmRsZXI6IHZhbGlkYXRlSGFuZGxlcixcbiAgaW5pdGlhbDogdmFsaWRhdGVJbml0aWFsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGUoaW5pdGlhbCkge1xuICB2YXIgaGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhbGlkYXRvcnMuaW5pdGlhbChpbml0aWFsKTtcbiAgdmFsaWRhdG9ycy5oYW5kbGVyKGhhbmRsZXIpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgY3VycmVudDogaW5pdGlhbFxuICB9O1xuICB2YXIgZGlkVXBkYXRlID0gY3VycnkoZGlkU3RhdGVVcGRhdGUpKHN0YXRlLCBoYW5kbGVyKTtcbiAgdmFyIHVwZGF0ZSA9IGN1cnJ5KHVwZGF0ZVN0YXRlKShzdGF0ZSk7XG4gIHZhciB2YWxpZGF0ZSA9IGN1cnJ5KHZhbGlkYXRvcnMuY2hhbmdlcykoaW5pdGlhbCk7XG4gIHZhciBnZXRDaGFuZ2VzID0gY3VycnkoZXh0cmFjdENoYW5nZXMpKHN0YXRlKTtcblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICB2YXIgc2VsZWN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH07XG4gICAgdmFsaWRhdG9ycy5zZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIHNlbGVjdG9yKHN0YXRlLmN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3RhdGUoY2F1c2VkQ2hhbmdlcykge1xuICAgIGNvbXBvc2UoZGlkVXBkYXRlLCB1cGRhdGUsIHZhbGlkYXRlLCBnZXRDaGFuZ2VzKShjYXVzZWRDaGFuZ2VzKTtcbiAgfVxuXG4gIHJldHVybiBbZ2V0U3RhdGUsIHNldFN0YXRlXTtcbn1cblxuZnVuY3Rpb24gZXh0cmFjdENoYW5nZXMoc3RhdGUsIGNhdXNlZENoYW5nZXMpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24oY2F1c2VkQ2hhbmdlcykgPyBjYXVzZWRDaGFuZ2VzKHN0YXRlLmN1cnJlbnQpIDogY2F1c2VkQ2hhbmdlcztcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoc3RhdGUsIGNoYW5nZXMpIHtcbiAgc3RhdGUuY3VycmVudCA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzdGF0ZS5jdXJyZW50KSwgY2hhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VzO1xufVxuXG5mdW5jdGlvbiBkaWRTdGF0ZVVwZGF0ZShzdGF0ZSwgaGFuZGxlciwgY2hhbmdlcykge1xuICBpc0Z1bmN0aW9uKGhhbmRsZXIpID8gaGFuZGxlcihzdGF0ZS5jdXJyZW50KSA6IE9iamVjdC5rZXlzKGNoYW5nZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgdmFyIF9oYW5kbGVyJGZpZWxkO1xuXG4gICAgcmV0dXJuIChfaGFuZGxlciRmaWVsZCA9IGhhbmRsZXJbZmllbGRdKSA9PT0gbnVsbCB8fCBfaGFuZGxlciRmaWVsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2hhbmRsZXIkZmllbGQuY2FsbChoYW5kbGVyLCBzdGF0ZS5jdXJyZW50W2ZpZWxkXSk7XG4gIH0pO1xuICByZXR1cm4gY2hhbmdlcztcbn1cblxudmFyIGluZGV4ID0ge1xuICBjcmVhdGU6IGNyZWF0ZVxufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iLCJ2YXIgY29uZmlnID0ge1xuICBwYXRoczoge1xuICAgIHZzOiAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9tb25hY28tZWRpdG9yQDAuNDMuMC9taW4vdnMnXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZztcbiIsImZ1bmN0aW9uIGN1cnJ5KGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZ3MubGVuZ3RoID49IGZuLmxlbmd0aCA/IGZuLmFwcGx5KHRoaXMsIGFyZ3MpIDogZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBuZXh0QXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBuZXh0QXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmllZC5hcHBseShfdGhpcywgW10uY29uY2F0KGFyZ3MsIG5leHRBcmdzKSk7XG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY3Vycnk7XG4iLCJmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSkuaW5jbHVkZXMoJ09iamVjdCcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsImltcG9ydCBjdXJyeSBmcm9tICcuLi91dGlscy9jdXJyeS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi4vdXRpbHMvaXNPYmplY3QuanMnO1xuXG4vKipcbiAqIHZhbGlkYXRlcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgYW5kIGluZm9ybXMgYWJvdXQgZGVwcmVjYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNvbmZpZyAtIHRoZSB2YWxpZGF0ZWQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgaWYgKCFjb25maWcpIGVycm9ySGFuZGxlcignY29uZmlnSXNSZXF1aXJlZCcpO1xuICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIGVycm9ySGFuZGxlcignY29uZmlnVHlwZScpO1xuXG4gIGlmIChjb25maWcudXJscykge1xuICAgIGluZm9ybUFib3V0RGVwcmVjYXRpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aHM6IHtcbiAgICAgICAgdnM6IGNvbmZpZy51cmxzLm1vbmFjb0Jhc2VcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cbi8qKlxuICogbG9ncyBkZXByZWNhdGlvbiBtZXNzYWdlXG4gKi9cblxuXG5mdW5jdGlvbiBpbmZvcm1BYm91dERlcHJlY2F0aW9uKCkge1xuICBjb25zb2xlLndhcm4oZXJyb3JNZXNzYWdlcy5kZXByZWNhdGlvbik7XG59XG5cbmZ1bmN0aW9uIHRocm93RXJyb3IoZXJyb3JNZXNzYWdlcywgdHlwZSkge1xuICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlc1t0eXBlXSB8fCBlcnJvck1lc3NhZ2VzW1wiZGVmYXVsdFwiXSk7XG59XG5cbnZhciBlcnJvck1lc3NhZ2VzID0ge1xuICBjb25maWdJc1JlcXVpcmVkOiAndGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIHJlcXVpcmVkJyxcbiAgY29uZmlnVHlwZTogJ3RoZSBjb25maWd1cmF0aW9uIG9iamVjdCBzaG91bGQgYmUgYW4gb2JqZWN0JyxcbiAgXCJkZWZhdWx0XCI6ICdhbiB1bmtub3duIGVycm9yIGFjY3VyZWQgaW4gYEBtb25hY28tZWRpdG9yL2xvYWRlcmAgcGFja2FnZScsXG4gIGRlcHJlY2F0aW9uOiBcIkRlcHJlY2F0aW9uIHdhcm5pbmchXFxuICAgIFlvdSBhcmUgdXNpbmcgZGVwcmVjYXRlZCB3YXkgb2YgY29uZmlndXJhdGlvbi5cXG5cXG4gICAgSW5zdGVhZCBvZiB1c2luZ1xcbiAgICAgIG1vbmFjby5jb25maWcoeyB1cmxzOiB7IG1vbmFjb0Jhc2U6ICcuLi4nIH0gfSlcXG4gICAgdXNlXFxuICAgICAgbW9uYWNvLmNvbmZpZyh7IHBhdGhzOiB7IHZzOiAnLi4uJyB9IH0pXFxuXFxuICAgIEZvciBtb3JlIHBsZWFzZSBjaGVjayB0aGUgbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VyZW4tYXRveWFuL21vbmFjby1sb2FkZXIjY29uZmlnXFxuICBcIlxufTtcbnZhciBlcnJvckhhbmRsZXIgPSBjdXJyeSh0aHJvd0Vycm9yKShlcnJvck1lc3NhZ2VzKTtcbnZhciB2YWxpZGF0b3JzID0ge1xuICBjb25maWc6IHZhbGlkYXRlQ29uZmlnXG59O1xuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0b3JzO1xuZXhwb3J0IHsgZXJyb3JIYW5kbGVyLCBlcnJvck1lc3NhZ2VzIH07XG4iLCJ2YXIgY29tcG9zZSA9IGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmbnMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZm5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2VSaWdodChmdW5jdGlvbiAoeSwgZikge1xuICAgICAgcmV0dXJuIGYoeSk7XG4gICAgfSwgeCk7XG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlO1xuIiwiaW1wb3J0IHsgb2JqZWN0U3ByZWFkMiBhcyBfb2JqZWN0U3ByZWFkMiB9IGZyb20gJy4uL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMnO1xuXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmIChzb3VyY2Vba2V5XSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgaWYgKHRhcmdldFtrZXldKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc291cmNlW2tleV0sIG1lcmdlKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGFyZ2V0KSwgc291cmNlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2U7XG4iLCIvLyBUaGUgc291cmNlIChoYXMgYmVlbiBjaGFuZ2VkKSBpcyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzU0NjUjaXNzdWVjb21tZW50LTE1Nzg4ODMyNVxudmFyIENBTkNFTEFUSU9OX01FU1NBR0UgPSB7XG4gIHR5cGU6ICdjYW5jZWxhdGlvbicsXG4gIG1zZzogJ29wZXJhdGlvbiBpcyBtYW51YWxseSBjYW5jZWxlZCdcbn07XG5cbmZ1bmN0aW9uIG1ha2VDYW5jZWxhYmxlKHByb21pc2UpIHtcbiAgdmFyIGhhc0NhbmNlbGVkXyA9IGZhbHNlO1xuICB2YXIgd3JhcHBlZFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIHJldHVybiBoYXNDYW5jZWxlZF8gPyByZWplY3QoQ0FOQ0VMQVRJT05fTUVTU0FHRSkgOiByZXNvbHZlKHZhbCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZVtcImNhdGNoXCJdKHJlamVjdCk7XG4gIH0pO1xuICByZXR1cm4gd3JhcHBlZFByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBoYXNDYW5jZWxlZF8gPSB0cnVlO1xuICB9LCB3cmFwcGVkUHJvbWlzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWFrZUNhbmNlbGFibGU7XG5leHBvcnQgeyBDQU5DRUxBVElPTl9NRVNTQUdFIH07XG4iLCJpbXBvcnQgeyBzbGljZWRUb0FycmF5IGFzIF9zbGljZWRUb0FycmF5LCBvYmplY3RXaXRob3V0UHJvcGVydGllcyBhcyBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMgfSBmcm9tICcuLi9fdmlydHVhbC9fcm9sbHVwUGx1Z2luQmFiZWxIZWxwZXJzLmpzJztcbmltcG9ydCBzdGF0ZSBmcm9tICdzdGF0ZS1sb2NhbCc7XG5pbXBvcnQgY29uZmlnJDEgZnJvbSAnLi4vY29uZmlnL2luZGV4LmpzJztcbmltcG9ydCB2YWxpZGF0b3JzIGZyb20gJy4uL3ZhbGlkYXRvcnMvaW5kZXguanMnO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSAnLi4vdXRpbHMvY29tcG9zZS5qcyc7XG5pbXBvcnQgbWVyZ2UgZnJvbSAnLi4vdXRpbHMvZGVlcE1lcmdlLmpzJztcbmltcG9ydCBtYWtlQ2FuY2VsYWJsZSBmcm9tICcuLi91dGlscy9tYWtlQ2FuY2VsYWJsZS5qcyc7XG5cbi8qKiB0aGUgbG9jYWwgc3RhdGUgb2YgdGhlIG1vZHVsZSAqL1xuXG52YXIgX3N0YXRlJGNyZWF0ZSA9IHN0YXRlLmNyZWF0ZSh7XG4gIGNvbmZpZzogY29uZmlnJDEsXG4gIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICByZXNvbHZlOiBudWxsLFxuICByZWplY3Q6IG51bGwsXG4gIG1vbmFjbzogbnVsbFxufSksXG4gICAgX3N0YXRlJGNyZWF0ZTIgPSBfc2xpY2VkVG9BcnJheShfc3RhdGUkY3JlYXRlLCAyKSxcbiAgICBnZXRTdGF0ZSA9IF9zdGF0ZSRjcmVhdGUyWzBdLFxuICAgIHNldFN0YXRlID0gX3N0YXRlJGNyZWF0ZTJbMV07XG4vKipcbiAqIHNldCB0aGUgbG9hZGVyIGNvbmZpZ3VyYXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgLSB0aGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbmZpZyhnbG9iYWxDb25maWcpIHtcbiAgdmFyIF92YWxpZGF0b3JzJGNvbmZpZyA9IHZhbGlkYXRvcnMuY29uZmlnKGdsb2JhbENvbmZpZyksXG4gICAgICBtb25hY28gPSBfdmFsaWRhdG9ycyRjb25maWcubW9uYWNvLFxuICAgICAgY29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF92YWxpZGF0b3JzJGNvbmZpZywgW1wibW9uYWNvXCJdKTtcblxuICBzZXRTdGF0ZShmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiBtZXJnZShzdGF0ZS5jb25maWcsIGNvbmZpZyksXG4gICAgICBtb25hY286IG1vbmFjb1xuICAgIH07XG4gIH0pO1xufVxuLyoqXG4gKiBoYW5kbGVzIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgbW9uYWNvLWVkaXRvclxuICogQHJldHVybiB7UHJvbWlzZX0gLSByZXR1cm5zIGFuIGluc3RhbmNlIG9mIG1vbmFjbyAod2l0aCBhIGNhbmNlbGFibGUgcHJvbWlzZSlcbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldFN0YXRlKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG1vbmFjbyA9IF9yZWYubW9uYWNvLFxuICAgICAgICBpc0luaXRpYWxpemVkID0gX3JlZi5pc0luaXRpYWxpemVkLFxuICAgICAgICByZXNvbHZlID0gX3JlZi5yZXNvbHZlO1xuICAgIHJldHVybiB7XG4gICAgICBtb25hY286IG1vbmFjbyxcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGlzSW5pdGlhbGl6ZWQsXG4gICAgICByZXNvbHZlOiByZXNvbHZlXG4gICAgfTtcbiAgfSk7XG5cbiAgaWYgKCFzdGF0ZS5pc0luaXRpYWxpemVkKSB7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgaXNJbml0aWFsaXplZDogdHJ1ZVxuICAgIH0pO1xuXG4gICAgaWYgKHN0YXRlLm1vbmFjbykge1xuICAgICAgc3RhdGUucmVzb2x2ZShzdGF0ZS5tb25hY28pO1xuICAgICAgcmV0dXJuIG1ha2VDYW5jZWxhYmxlKHdyYXBwZXJQcm9taXNlKTtcbiAgICB9XG5cbiAgICBpZiAod2luZG93Lm1vbmFjbyAmJiB3aW5kb3cubW9uYWNvLmVkaXRvcikge1xuICAgICAgc3RvcmVNb25hY29JbnN0YW5jZSh3aW5kb3cubW9uYWNvKTtcbiAgICAgIHN0YXRlLnJlc29sdmUod2luZG93Lm1vbmFjbyk7XG4gICAgICByZXR1cm4gbWFrZUNhbmNlbGFibGUod3JhcHBlclByb21pc2UpO1xuICAgIH1cblxuICAgIGNvbXBvc2UoaW5qZWN0U2NyaXB0cywgZ2V0TW9uYWNvTG9hZGVyU2NyaXB0KShjb25maWd1cmVMb2FkZXIpO1xuICB9XG5cbiAgcmV0dXJuIG1ha2VDYW5jZWxhYmxlKHdyYXBwZXJQcm9taXNlKTtcbn1cbi8qKlxuICogaW5qZWN0cyBwcm92aWRlZCBzY3JpcHRzIGludG8gdGhlIGRvY3VtZW50LmJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBzY3JpcHQgLSBhbiBIVE1MIHNjcmlwdCBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gdGhlIGluamVjdGVkIEhUTUwgc2NyaXB0IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGluamVjdFNjcmlwdHMoc2NyaXB0KSB7XG4gIHJldHVybiBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG4vKipcbiAqIGNyZWF0ZXMgYW4gSFRNTCBzY3JpcHQgZWxlbWVudCB3aXRoL3dpdGhvdXQgcHJvdmlkZWQgc3JjXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NyY10gLSB0aGUgc291cmNlIHBhdGggb2YgdGhlIHNjcmlwdFxuICogQHJldHVybiB7T2JqZWN0fSAtIHRoZSBjcmVhdGVkIEhUTUwgc2NyaXB0IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVNjcmlwdChzcmMpIHtcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICByZXR1cm4gc3JjICYmIChzY3JpcHQuc3JjID0gc3JjKSwgc2NyaXB0O1xufVxuLyoqXG4gKiBjcmVhdGVzIGFuIEhUTUwgc2NyaXB0IGVsZW1lbnQgd2l0aCB0aGUgbW9uYWNvIGxvYWRlciBzcmNcbiAqIEByZXR1cm4ge09iamVjdH0gLSB0aGUgY3JlYXRlZCBIVE1MIHNjcmlwdCBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRNb25hY29Mb2FkZXJTY3JpcHQoY29uZmlndXJlTG9hZGVyKSB7XG4gIHZhciBzdGF0ZSA9IGdldFN0YXRlKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciBjb25maWcgPSBfcmVmMi5jb25maWcsXG4gICAgICAgIHJlamVjdCA9IF9yZWYyLnJlamVjdDtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICByZWplY3Q6IHJlamVjdFxuICAgIH07XG4gIH0pO1xuICB2YXIgbG9hZGVyU2NyaXB0ID0gY3JlYXRlU2NyaXB0KFwiXCIuY29uY2F0KHN0YXRlLmNvbmZpZy5wYXRocy52cywgXCIvbG9hZGVyLmpzXCIpKTtcblxuICBsb2FkZXJTY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb25maWd1cmVMb2FkZXIoKTtcbiAgfTtcblxuICBsb2FkZXJTY3JpcHQub25lcnJvciA9IHN0YXRlLnJlamVjdDtcbiAgcmV0dXJuIGxvYWRlclNjcmlwdDtcbn1cbi8qKlxuICogY29uZmlndXJlcyB0aGUgbW9uYWNvIGxvYWRlclxuICovXG5cblxuZnVuY3Rpb24gY29uZmlndXJlTG9hZGVyKCkge1xuICB2YXIgc3RhdGUgPSBnZXRTdGF0ZShmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgY29uZmlnID0gX3JlZjMuY29uZmlnLFxuICAgICAgICByZXNvbHZlID0gX3JlZjMucmVzb2x2ZSxcbiAgICAgICAgcmVqZWN0ID0gX3JlZjMucmVqZWN0O1xuICAgIHJldHVybiB7XG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICByZWplY3Q6IHJlamVjdFxuICAgIH07XG4gIH0pO1xuICB2YXIgcmVxdWlyZSA9IHdpbmRvdy5yZXF1aXJlO1xuXG4gIHJlcXVpcmUuY29uZmlnKHN0YXRlLmNvbmZpZyk7XG5cbiAgcmVxdWlyZShbJ3ZzL2VkaXRvci9lZGl0b3IubWFpbiddLCBmdW5jdGlvbiAobW9uYWNvKSB7XG4gICAgc3RvcmVNb25hY29JbnN0YW5jZShtb25hY28pO1xuICAgIHN0YXRlLnJlc29sdmUobW9uYWNvKTtcbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgc3RhdGUucmVqZWN0KGVycm9yKTtcbiAgfSk7XG59XG4vKipcbiAqIHN0b3JlIG1vbmFjbyBpbnN0YW5jZSBpbiBsb2NhbCBzdGF0ZVxuICovXG5cblxuZnVuY3Rpb24gc3RvcmVNb25hY29JbnN0YW5jZShtb25hY28pIHtcbiAgaWYgKCFnZXRTdGF0ZSgpLm1vbmFjbykge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIG1vbmFjbzogbW9uYWNvXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogaW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uXG4gKiBleHRyYWN0cyBzdG9yZWQgbW9uYWNvIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gLSB0aGUgbW9uYWNvIGluc3RhbmNlXG4gKi9cblxuXG5mdW5jdGlvbiBfX2dldE1vbmFjb0luc3RhbmNlKCkge1xuICByZXR1cm4gZ2V0U3RhdGUoZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgdmFyIG1vbmFjbyA9IF9yZWY0Lm1vbmFjbztcbiAgICByZXR1cm4gbW9uYWNvO1xuICB9KTtcbn1cblxudmFyIHdyYXBwZXJQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICByZXR1cm4gc2V0U3RhdGUoe1xuICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgcmVqZWN0OiByZWplY3RcbiAgfSk7XG59KTtcbnZhciBsb2FkZXIgPSB7XG4gIGNvbmZpZzogY29uZmlnLFxuICBpbml0OiBpbml0LFxuICBfX2dldE1vbmFjb0luc3RhbmNlOiBfX2dldE1vbmFjb0luc3RhbmNlXG59O1xuXG5leHBvcnQgZGVmYXVsdCBsb2FkZXI7XG4iLCJpbXBvcnQgbG9hZGVyIGZyb20gJy4vbG9hZGVyL2luZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tICcuL2xvYWRlci9pbmRleC5qcyc7XG4iLCJpbXBvcnQgX3QgZnJvbVwiQG1vbmFjby1lZGl0b3IvbG9hZGVyXCI7aW1wb3J0e21lbW8gYXMgVGV9ZnJvbVwicmVhY3RcIjtpbXBvcnQga2Use3VzZVN0YXRlIGFzIHJlLHVzZVJlZiBhcyBTLHVzZUNhbGxiYWNrIGFzIG9lLHVzZUVmZmVjdCBhcyBuZX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBTZSBmcm9tXCJAbW9uYWNvLWVkaXRvci9sb2FkZXJcIjtpbXBvcnR7bWVtbyBhcyB5ZX1mcm9tXCJyZWFjdFwiO2ltcG9ydCBLIGZyb21cInJlYWN0XCI7dmFyIGxlPXt3cmFwcGVyOntkaXNwbGF5OlwiZmxleFwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIix0ZXh0QWxpZ246XCJpbml0aWFsXCJ9LGZ1bGxXaWR0aDp7d2lkdGg6XCIxMDAlXCJ9LGhpZGU6e2Rpc3BsYXk6XCJub25lXCJ9fSx2PWxlO2ltcG9ydCBtZSBmcm9tXCJyZWFjdFwiO3ZhciBhZT17Y29udGFpbmVyOntkaXNwbGF5OlwiZmxleFwiLGhlaWdodDpcIjEwMCVcIix3aWR0aDpcIjEwMCVcIixqdXN0aWZ5Q29udGVudDpcImNlbnRlclwiLGFsaWduSXRlbXM6XCJjZW50ZXJcIn19LFk9YWU7ZnVuY3Rpb24gTWUoe2NoaWxkcmVuOmV9KXtyZXR1cm4gbWUuY3JlYXRlRWxlbWVudChcImRpdlwiLHtzdHlsZTpZLmNvbnRhaW5lcn0sZSl9dmFyIFo9TWU7dmFyICQ9WjtmdW5jdGlvbiBFZSh7d2lkdGg6ZSxoZWlnaHQ6cixpc0VkaXRvclJlYWR5Om4sbG9hZGluZzp0LF9yZWY6YSxjbGFzc05hbWU6bSx3cmFwcGVyUHJvcHM6RX0pe3JldHVybiBLLmNyZWF0ZUVsZW1lbnQoXCJzZWN0aW9uXCIse3N0eWxlOnsuLi52LndyYXBwZXIsd2lkdGg6ZSxoZWlnaHQ6cn0sLi4uRX0sIW4mJksuY3JlYXRlRWxlbWVudCgkLG51bGwsdCksSy5jcmVhdGVFbGVtZW50KFwiZGl2XCIse3JlZjphLHN0eWxlOnsuLi52LmZ1bGxXaWR0aCwuLi4hbiYmdi5oaWRlfSxjbGFzc05hbWU6bX0pKX12YXIgZWU9RWU7dmFyIEg9eWUoZWUpO2ltcG9ydHt1c2VFZmZlY3QgYXMgeGV9ZnJvbVwicmVhY3RcIjtmdW5jdGlvbiBDZShlKXt4ZShlLFtdKX12YXIgaz1DZTtpbXBvcnR7dXNlRWZmZWN0IGFzIGdlLHVzZVJlZiBhcyBSZX1mcm9tXCJyZWFjdFwiO2Z1bmN0aW9uIGhlKGUscixuPSEwKXtsZXQgdD1SZSghMCk7Z2UodC5jdXJyZW50fHwhbj8oKT0+e3QuY3VycmVudD0hMX06ZSxyKX12YXIgbD1oZTtmdW5jdGlvbiBEKCl7fWZ1bmN0aW9uIGgoZSxyLG4sdCl7cmV0dXJuIERlKGUsdCl8fGJlKGUscixuLHQpfWZ1bmN0aW9uIERlKGUscil7cmV0dXJuIGUuZWRpdG9yLmdldE1vZGVsKHRlKGUscikpfWZ1bmN0aW9uIGJlKGUscixuLHQpe3JldHVybiBlLmVkaXRvci5jcmVhdGVNb2RlbChyLG4sdD90ZShlLHQpOnZvaWQgMCl9ZnVuY3Rpb24gdGUoZSxyKXtyZXR1cm4gZS5VcmkucGFyc2Uocil9ZnVuY3Rpb24gT2Uoe29yaWdpbmFsOmUsbW9kaWZpZWQ6cixsYW5ndWFnZTpuLG9yaWdpbmFsTGFuZ3VhZ2U6dCxtb2RpZmllZExhbmd1YWdlOmEsb3JpZ2luYWxNb2RlbFBhdGg6bSxtb2RpZmllZE1vZGVsUGF0aDpFLGtlZXBDdXJyZW50T3JpZ2luYWxNb2RlbDpnPSExLGtlZXBDdXJyZW50TW9kaWZpZWRNb2RlbDpOPSExLHRoZW1lOng9XCJsaWdodFwiLGxvYWRpbmc6UD1cIkxvYWRpbmcuLi5cIixvcHRpb25zOnk9e30saGVpZ2h0OlY9XCIxMDAlXCIsd2lkdGg6ej1cIjEwMCVcIixjbGFzc05hbWU6Rix3cmFwcGVyUHJvcHM6aj17fSxiZWZvcmVNb3VudDpBPUQsb25Nb3VudDpxPUR9KXtsZXRbTSxPXT1yZSghMSksW1Qsc109cmUoITApLHU9UyhudWxsKSxjPVMobnVsbCksdz1TKG51bGwpLGQ9UyhxKSxvPVMoQSksYj1TKCExKTtrKCgpPT57bGV0IGk9U2UuaW5pdCgpO3JldHVybiBpLnRoZW4oZj0+KGMuY3VycmVudD1mKSYmcyghMSkpLmNhdGNoKGY9PmY/LnR5cGUhPT1cImNhbmNlbGF0aW9uXCImJmNvbnNvbGUuZXJyb3IoXCJNb25hY28gaW5pdGlhbGl6YXRpb246IGVycm9yOlwiLGYpKSwoKT0+dS5jdXJyZW50P0koKTppLmNhbmNlbCgpfSksbCgoKT0+e2lmKHUuY3VycmVudCYmYy5jdXJyZW50KXtsZXQgaT11LmN1cnJlbnQuZ2V0T3JpZ2luYWxFZGl0b3IoKSxmPWgoYy5jdXJyZW50LGV8fFwiXCIsdHx8bnx8XCJ0ZXh0XCIsbXx8XCJcIik7ZiE9PWkuZ2V0TW9kZWwoKSYmaS5zZXRNb2RlbChmKX19LFttXSxNKSxsKCgpPT57aWYodS5jdXJyZW50JiZjLmN1cnJlbnQpe2xldCBpPXUuY3VycmVudC5nZXRNb2RpZmllZEVkaXRvcigpLGY9aChjLmN1cnJlbnQscnx8XCJcIixhfHxufHxcInRleHRcIixFfHxcIlwiKTtmIT09aS5nZXRNb2RlbCgpJiZpLnNldE1vZGVsKGYpfX0sW0VdLE0pLGwoKCk9PntsZXQgaT11LmN1cnJlbnQuZ2V0TW9kaWZpZWRFZGl0b3IoKTtpLmdldE9wdGlvbihjLmN1cnJlbnQuZWRpdG9yLkVkaXRvck9wdGlvbi5yZWFkT25seSk/aS5zZXRWYWx1ZShyfHxcIlwiKTpyIT09aS5nZXRWYWx1ZSgpJiYoaS5leGVjdXRlRWRpdHMoXCJcIixbe3JhbmdlOmkuZ2V0TW9kZWwoKS5nZXRGdWxsTW9kZWxSYW5nZSgpLHRleHQ6cnx8XCJcIixmb3JjZU1vdmVNYXJrZXJzOiEwfV0pLGkucHVzaFVuZG9TdG9wKCkpfSxbcl0sTSksbCgoKT0+e3UuY3VycmVudD8uZ2V0TW9kZWwoKT8ub3JpZ2luYWwuc2V0VmFsdWUoZXx8XCJcIil9LFtlXSxNKSxsKCgpPT57bGV0e29yaWdpbmFsOmksbW9kaWZpZWQ6Zn09dS5jdXJyZW50LmdldE1vZGVsKCk7Yy5jdXJyZW50LmVkaXRvci5zZXRNb2RlbExhbmd1YWdlKGksdHx8bnx8XCJ0ZXh0XCIpLGMuY3VycmVudC5lZGl0b3Iuc2V0TW9kZWxMYW5ndWFnZShmLGF8fG58fFwidGV4dFwiKX0sW24sdCxhXSxNKSxsKCgpPT57Yy5jdXJyZW50Py5lZGl0b3Iuc2V0VGhlbWUoeCl9LFt4XSxNKSxsKCgpPT57dS5jdXJyZW50Py51cGRhdGVPcHRpb25zKHkpfSxbeV0sTSk7bGV0IEw9b2UoKCk9PntpZighYy5jdXJyZW50KXJldHVybjtvLmN1cnJlbnQoYy5jdXJyZW50KTtsZXQgaT1oKGMuY3VycmVudCxlfHxcIlwiLHR8fG58fFwidGV4dFwiLG18fFwiXCIpLGY9aChjLmN1cnJlbnQscnx8XCJcIixhfHxufHxcInRleHRcIixFfHxcIlwiKTt1LmN1cnJlbnQ/LnNldE1vZGVsKHtvcmlnaW5hbDppLG1vZGlmaWVkOmZ9KX0sW24scixhLGUsdCxtLEVdKSxVPW9lKCgpPT57IWIuY3VycmVudCYmdy5jdXJyZW50JiYodS5jdXJyZW50PWMuY3VycmVudC5lZGl0b3IuY3JlYXRlRGlmZkVkaXRvcih3LmN1cnJlbnQse2F1dG9tYXRpY0xheW91dDohMCwuLi55fSksTCgpLGMuY3VycmVudD8uZWRpdG9yLnNldFRoZW1lKHgpLE8oITApLGIuY3VycmVudD0hMCl9LFt5LHgsTF0pO25lKCgpPT57TSYmZC5jdXJyZW50KHUuY3VycmVudCxjLmN1cnJlbnQpfSxbTV0pLG5lKCgpPT57IVQmJiFNJiZVKCl9LFtULE0sVV0pO2Z1bmN0aW9uIEkoKXtsZXQgaT11LmN1cnJlbnQ/LmdldE1vZGVsKCk7Z3x8aT8ub3JpZ2luYWw/LmRpc3Bvc2UoKSxOfHxpPy5tb2RpZmllZD8uZGlzcG9zZSgpLHUuY3VycmVudD8uZGlzcG9zZSgpfXJldHVybiBrZS5jcmVhdGVFbGVtZW50KEgse3dpZHRoOnosaGVpZ2h0OlYsaXNFZGl0b3JSZWFkeTpNLGxvYWRpbmc6UCxfcmVmOncsY2xhc3NOYW1lOkYsd3JhcHBlclByb3BzOmp9KX12YXIgaWU9T2U7dmFyIHdlPVRlKGllKTtpbXBvcnR7dXNlU3RhdGUgYXMgSWV9ZnJvbVwicmVhY3RcIjtpbXBvcnQgY2UgZnJvbVwiQG1vbmFjby1lZGl0b3IvbG9hZGVyXCI7ZnVuY3Rpb24gUGUoKXtsZXRbZSxyXT1JZShjZS5fX2dldE1vbmFjb0luc3RhbmNlKCkpO3JldHVybiBrKCgpPT57bGV0IG47cmV0dXJuIGV8fChuPWNlLmluaXQoKSxuLnRoZW4odD0+e3IodCl9KSksKCk9Pm4/LmNhbmNlbCgpfSksZX12YXIgTGU9UGU7aW1wb3J0e21lbW8gYXMgemV9ZnJvbVwicmVhY3RcIjtpbXBvcnQgV2Use3VzZVN0YXRlIGFzIHVlLHVzZUVmZmVjdCBhcyBXLHVzZVJlZiBhcyBDLHVzZUNhbGxiYWNrIGFzIF9lfWZyb21cInJlYWN0XCI7aW1wb3J0IE5lIGZyb21cIkBtb25hY28tZWRpdG9yL2xvYWRlclwiO2ltcG9ydHt1c2VFZmZlY3QgYXMgVWUsdXNlUmVmIGFzIHZlfWZyb21cInJlYWN0XCI7ZnVuY3Rpb24gSGUoZSl7bGV0IHI9dmUoKTtyZXR1cm4gVWUoKCk9PntyLmN1cnJlbnQ9ZX0sW2VdKSxyLmN1cnJlbnR9dmFyIHNlPUhlO3ZhciBfPW5ldyBNYXA7ZnVuY3Rpb24gVmUoe2RlZmF1bHRWYWx1ZTplLGRlZmF1bHRMYW5ndWFnZTpyLGRlZmF1bHRQYXRoOm4sdmFsdWU6dCxsYW5ndWFnZTphLHBhdGg6bSx0aGVtZTpFPVwibGlnaHRcIixsaW5lOmcsbG9hZGluZzpOPVwiTG9hZGluZy4uLlwiLG9wdGlvbnM6eD17fSxvdmVycmlkZVNlcnZpY2VzOlA9e30sc2F2ZVZpZXdTdGF0ZTp5PSEwLGtlZXBDdXJyZW50TW9kZWw6Vj0hMSx3aWR0aDp6PVwiMTAwJVwiLGhlaWdodDpGPVwiMTAwJVwiLGNsYXNzTmFtZTpqLHdyYXBwZXJQcm9wczpBPXt9LGJlZm9yZU1vdW50OnE9RCxvbk1vdW50Ok09RCxvbkNoYW5nZTpPLG9uVmFsaWRhdGU6VD1EfSl7bGV0W3MsdV09dWUoITEpLFtjLHddPXVlKCEwKSxkPUMobnVsbCksbz1DKG51bGwpLGI9QyhudWxsKSxMPUMoTSksVT1DKHEpLEk9QygpLGk9Qyh0KSxmPXNlKG0pLFE9QyghMSksQj1DKCExKTtrKCgpPT57bGV0IHA9TmUuaW5pdCgpO3JldHVybiBwLnRoZW4oUj0+KGQuY3VycmVudD1SKSYmdyghMSkpLmNhdGNoKFI9PlI/LnR5cGUhPT1cImNhbmNlbGF0aW9uXCImJmNvbnNvbGUuZXJyb3IoXCJNb25hY28gaW5pdGlhbGl6YXRpb246IGVycm9yOlwiLFIpKSwoKT0+by5jdXJyZW50P3BlKCk6cC5jYW5jZWwoKX0pLGwoKCk9PntsZXQgcD1oKGQuY3VycmVudCxlfHx0fHxcIlwiLHJ8fGF8fFwiXCIsbXx8bnx8XCJcIik7cCE9PW8uY3VycmVudD8uZ2V0TW9kZWwoKSYmKHkmJl8uc2V0KGYsby5jdXJyZW50Py5zYXZlVmlld1N0YXRlKCkpLG8uY3VycmVudD8uc2V0TW9kZWwocCkseSYmby5jdXJyZW50Py5yZXN0b3JlVmlld1N0YXRlKF8uZ2V0KG0pKSl9LFttXSxzKSxsKCgpPT57by5jdXJyZW50Py51cGRhdGVPcHRpb25zKHgpfSxbeF0scyksbCgoKT0+eyFvLmN1cnJlbnR8fHQ9PT12b2lkIDB8fChvLmN1cnJlbnQuZ2V0T3B0aW9uKGQuY3VycmVudC5lZGl0b3IuRWRpdG9yT3B0aW9uLnJlYWRPbmx5KT9vLmN1cnJlbnQuc2V0VmFsdWUodCk6dCE9PW8uY3VycmVudC5nZXRWYWx1ZSgpJiYoQi5jdXJyZW50PSEwLG8uY3VycmVudC5leGVjdXRlRWRpdHMoXCJcIixbe3JhbmdlOm8uY3VycmVudC5nZXRNb2RlbCgpLmdldEZ1bGxNb2RlbFJhbmdlKCksdGV4dDp0LGZvcmNlTW92ZU1hcmtlcnM6ITB9XSksby5jdXJyZW50LnB1c2hVbmRvU3RvcCgpLEIuY3VycmVudD0hMSkpfSxbdF0scyksbCgoKT0+e2xldCBwPW8uY3VycmVudD8uZ2V0TW9kZWwoKTtwJiZhJiZkLmN1cnJlbnQ/LmVkaXRvci5zZXRNb2RlbExhbmd1YWdlKHAsYSl9LFthXSxzKSxsKCgpPT57ZyE9PXZvaWQgMCYmby5jdXJyZW50Py5yZXZlYWxMaW5lKGcpfSxbZ10scyksbCgoKT0+e2QuY3VycmVudD8uZWRpdG9yLnNldFRoZW1lKEUpfSxbRV0scyk7bGV0IFg9X2UoKCk9PntpZighKCFiLmN1cnJlbnR8fCFkLmN1cnJlbnQpJiYhUS5jdXJyZW50KXtVLmN1cnJlbnQoZC5jdXJyZW50KTtsZXQgcD1tfHxuLFI9aChkLmN1cnJlbnQsdHx8ZXx8XCJcIixyfHxhfHxcIlwiLHB8fFwiXCIpO28uY3VycmVudD1kLmN1cnJlbnQ/LmVkaXRvci5jcmVhdGUoYi5jdXJyZW50LHttb2RlbDpSLGF1dG9tYXRpY0xheW91dDohMCwuLi54fSxQKSx5JiZvLmN1cnJlbnQucmVzdG9yZVZpZXdTdGF0ZShfLmdldChwKSksZC5jdXJyZW50LmVkaXRvci5zZXRUaGVtZShFKSxnIT09dm9pZCAwJiZvLmN1cnJlbnQucmV2ZWFsTGluZShnKSx1KCEwKSxRLmN1cnJlbnQ9ITB9fSxbZSxyLG4sdCxhLG0seCxQLHksRSxnXSk7VygoKT0+e3MmJkwuY3VycmVudChvLmN1cnJlbnQsZC5jdXJyZW50KX0sW3NdKSxXKCgpPT57IWMmJiFzJiZYKCl9LFtjLHMsWF0pLGkuY3VycmVudD10LFcoKCk9PntzJiZPJiYoSS5jdXJyZW50Py5kaXNwb3NlKCksSS5jdXJyZW50PW8uY3VycmVudD8ub25EaWRDaGFuZ2VNb2RlbENvbnRlbnQocD0+e0IuY3VycmVudHx8TyhvLmN1cnJlbnQuZ2V0VmFsdWUoKSxwKX0pKX0sW3MsT10pLFcoKCk9PntpZihzKXtsZXQgcD1kLmN1cnJlbnQuZWRpdG9yLm9uRGlkQ2hhbmdlTWFya2VycyhSPT57bGV0IEc9by5jdXJyZW50LmdldE1vZGVsKCk/LnVyaTtpZihHJiZSLmZpbmQoSj0+Si5wYXRoPT09Ry5wYXRoKSl7bGV0IEo9ZC5jdXJyZW50LmVkaXRvci5nZXRNb2RlbE1hcmtlcnMoe3Jlc291cmNlOkd9KTtUPy4oSil9fSk7cmV0dXJuKCk9PntwPy5kaXNwb3NlKCl9fXJldHVybigpPT57fX0sW3MsVF0pO2Z1bmN0aW9uIHBlKCl7SS5jdXJyZW50Py5kaXNwb3NlKCksVj95JiZfLnNldChtLG8uY3VycmVudC5zYXZlVmlld1N0YXRlKCkpOm8uY3VycmVudC5nZXRNb2RlbCgpPy5kaXNwb3NlKCksby5jdXJyZW50LmRpc3Bvc2UoKX1yZXR1cm4gV2UuY3JlYXRlRWxlbWVudChILHt3aWR0aDp6LGhlaWdodDpGLGlzRWRpdG9yUmVhZHk6cyxsb2FkaW5nOk4sX3JlZjpiLGNsYXNzTmFtZTpqLHdyYXBwZXJQcm9wczpBfSl9dmFyIGZlPVZlO3ZhciBkZT16ZShmZSk7dmFyIEZ0PWRlO2V4cG9ydHt3ZSBhcyBEaWZmRWRpdG9yLGRlIGFzIEVkaXRvcixGdCBhcyBkZWZhdWx0LF90IGFzIGxvYWRlcixMZSBhcyB1c2VNb25hY299O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68553\n')},14652:n=>{"use strict";n.exports=JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}')}}]);