(self.webpackChunkregal_ui_docs=self.webpackChunkregal_ui_docs||[]).push([[3175],{26527:function(module,__unused_webpack_exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(41709));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t"use strict";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1129__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __nested_webpack_require_1129__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === "number") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set(\'dummy\' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == "draft") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(":parent");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(\':parent\').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css(\'display\') != \'none\') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10973__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __nested_webpack_require_10973__(548);\nvar CoSELayout = __nested_webpack_require_10973__(140).CoSELayout;\nvar CoSENode = __nested_webpack_require_10973__(140).CoSENode;\nvar PointD = __nested_webpack_require_10973__(140).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_10973__(140).layoutBase.DimensionD;\nvar LayoutConstants = __nested_webpack_require_10973__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_10973__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_10973__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult["nodeIndexes"];\n    xCoords = spectralResult["xCoords"];\n    yCoords = spectralResult["yCoords"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === \'function\';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position(\'x\') - dimensions.w / 2, theChild.position(\'y\') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data("id");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css(\'padding\'));\n      theNode.paddingTop = parseInt(theChild.css(\'padding\'));\n      theNode.paddingRight = parseInt(theChild.css(\'padding\'));\n      theNode.paddingBottom = parseInt(theChild.css(\'padding\'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css("text-valign");\n        theNode.labelPosHorizontal = theChild.css("text-halign");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data("id")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data("source")];\n      var targetNode = idToLNode[edge.data("target")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it\'s a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints["fixedNodeConstraint"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints["alignmentConstraint"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints["relativePlacementConstraint"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == \'proof\') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === \'function\' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === \'function\' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == "transformed") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == "enforced") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == "cose") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == "all") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_22455__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __nested_webpack_require_22455__(658);\nvar aux = __nested_webpack_require_22455__(548);\n\nvar _require = __nested_webpack_require_22455__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __nested_webpack_require_22455__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // \'draft\', \'default\' or \'proof\' \n  // - \'draft\' only applies spectral layout \n  // - \'default\' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - \'proof\' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: "default",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be "proof"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in "proof" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: "all",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: \'n1\', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [[\'n1\', \'n2\')], [\'n3\', \'n4\']], horizontal: [\'n2\', \'n4\']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: \'n1\', bottom: \'n2\', gap: 100}, {left: \'n3\', right: \'n4\', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: \'run\',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities("get");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == "default" || options.quality == "proof") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == "default" || options.quality == "proof") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css(\'display\') == \'none\';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == "draft") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == "draft") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css("display") != "none" && target.css("display") != "none") {\n                    if (options.quality == "draft") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == "draft") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element\'s calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == "default" || options.quality == "proof") {\n          if (typeof ele === "number") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data(\'id\');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == "left") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == "right") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == "top") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == "bottom") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position("x"), y: ele.position("y") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position("x"), y: ele.position("y") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = "draft" and randomize = false are contradictive so in that case positions don\'t change\n      if (options.quality == "default" || options.quality == "proof" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css(\'display\') == \'none\';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(":parent").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log("If randomize option is set to false, then quality option must be \'default\' or \'proof\'.");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41986__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __nested_webpack_require_41986__(548);\nvar Matrix = __nested_webpack_require_41986__(140).layoutBase.Matrix;\nvar SVD = __nested_webpack_require_41986__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(":parent");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1\'s eigenvector\n    // V2 now contains theta2\'s eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(":childless").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(":childless").length);\n    var index = 0;\n    var min = children.nodes(":childless")[0].connectedEdges().length;\n    children.nodes(":childless").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(":childless")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == "draft" || options.step == "all") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position("x"));\n        yCoords.push(cy.getElementById(key).position("y"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_55337__) => {\n\n\n\nvar impl = __nested_webpack_require_55337__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can\'t register if cytoscape unspecified\n\n  cytoscape(\'layout\', \'fcose\', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== \'undefined\') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_56127__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_56127__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can\'t be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_56127__(579);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QW1CLEdBQUcsZ0NBQW1CO0FBQ3ZEO0FBQ0EsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2UvY3l0b3NjYXBlLWZjb3NlLmpzP2I2NDciXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiY29zZS1iYXNlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImNvc2UtYmFzZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjeXRvc2NhcGVGY29zZVwiXSA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJjb3NlQmFzZVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXykge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNjU4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5cbi8vIFNpbXBsZSwgaW50ZXJuYWwgT2JqZWN0LmFzc2lnbigpIHBvbHlmaWxsIGZvciBvcHRpb25zIG9iamVjdHMgZXRjLlxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5hc3NpZ24gIT0gbnVsbCA/IE9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpIDogZnVuY3Rpb24gKHRndCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgc3JjcyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBzcmNzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHNyY3MuZm9yRWFjaChmdW5jdGlvbiAoc3JjKSB7XG4gICAgT2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gdGd0W2tdID0gc3JjW2tdO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gdGd0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU0ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfc2xpY2VkVG9BcnJheSA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9IH07IH0oKTtcblxuLypcbiAqIEF1eGlsaWFyeSBmdW5jdGlvbnNcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkxpbmtlZExpc3Q7XG5cbnZhciBhdXhpbGlhcnkgPSB7fTtcblxuLy8gZ2V0IHRoZSB0b3AgbW9zdCBub2Rlc1xuYXV4aWxpYXJ5LmdldFRvcE1vc3ROb2RlcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbm9kZXNNYXAgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVzTWFwW25vZGVzW2ldLmlkKCldID0gdHJ1ZTtcbiAgfVxuICB2YXIgcm9vdHMgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKGVsZSwgaSkge1xuICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICBlbGUgPSBpO1xuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpWzBdO1xuICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGVzTWFwW3BhcmVudC5pZCgpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50KClbMF07XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gcm9vdHM7XG59O1xuXG4vLyBmaW5kIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIGFuZCBjcmVhdGUgZHVtbXkgbm9kZXMgdGhhdCBjb25uZWN0IHRoZW1cbmF1eGlsaWFyeS5jb25uZWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIChjeSwgZWxlcywgdG9wTW9zdE5vZGVzLCBkdW1teU5vZGVzKSB7XG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICB2YXIgY3VycmVudE5laWdoYm9yID0gdm9pZCAwO1xuICB2YXIgbWluRGVncmVlTm9kZSA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZSA9IHZvaWQgMDtcblxuICB2YXIgaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdmFyIG5vZGVzQ29ubmVjdGVkVG9EdW1teSA9IFtdO1xuICB2YXIgY29tcG9uZW50cyA9IFtdO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgIHZhciBjbXB0ID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNvbXBvbmVudHMucHVzaChjbXB0KTtcblxuICAgIHZhciBjdXJyZW50Tm9kZSA9IHRvcE1vc3ROb2Rlc1swXTtcbiAgICB2YXIgY2hpbGRyZW5PZkN1cnJlbnROb2RlID0gY3kuY29sbGVjdGlvbigpO1xuICAgIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZS5tZXJnZShjdXJyZW50Tm9kZSkubWVyZ2UoY3VycmVudE5vZGUuZGVzY2VuZGFudHMoKS5pbnRlcnNlY3Rpb24oZWxlcykpO1xuICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMucHVzaChjdXJyZW50Tm9kZSk7XG5cbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgY21wdC5tZXJnZShub2RlKTtcbiAgICB9KTtcblxuICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiBfbG9vcDIoKSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JOb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIGN1cnJlbnROb2RlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAoZWxlcy5pbnRlcnNlY3Rpb24oY3VycmVudE5vZGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbmVpZ2hib3JOb2Rlcy5tZXJnZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmVpZ2hib3JOb2RlID0gbmVpZ2hib3JOb2Rlc1tpXTtcbiAgICAgICAgY3VycmVudE5laWdoYm9yID0gdG9wTW9zdE5vZGVzLmludGVyc2VjdGlvbihuZWlnaGJvck5vZGUudW5pb24obmVpZ2hib3JOb2RlLmFuY2VzdG9ycygpKSk7XG4gICAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yWzBdKSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3IudW5pb24oY3VycmVudE5laWdoYm9yLmRlc2NlbmRhbnRzKCkpO1xuXG4gICAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgICAgICAgICBpZiAodG9wTW9zdE5vZGVzLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPSAwKSB7XG4gICAgICBfbG9vcDIoKTtcbiAgICB9XG5cbiAgICBjbXB0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGVsZXMuaW50ZXJzZWN0aW9uKG5vZGUuY29ubmVjdGVkRWRnZXMoKSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAvLyBjb25uZWN0ZWRFZGdlcygpIHVzdWFsbHkgY2FjaGVkXG4gICAgICAgIGlmIChjbXB0LmhhcyhlLnNvdXJjZSgpKSAmJiBjbXB0LmhhcyhlLnRhcmdldCgpKSkge1xuICAgICAgICAgIC8vIGhhcygpIGlzIGNoZWFwXG4gICAgICAgICAgY21wdC5tZXJnZShlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAodmlzaXRlZFRvcE1vc3ROb2Rlcy5sZW5ndGggPT0gdG9wTW9zdE5vZGVzLmxlbmd0aCkge1xuICAgICAgaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghaXNDb25uZWN0ZWQgfHwgaXNDb25uZWN0ZWQgJiYgY291bnQgPiAxKSB7XG4gICAgICBtaW5EZWdyZWVOb2RlID0gdmlzaXRlZFRvcE1vc3ROb2Rlc1swXTtcbiAgICAgIG1pbkRlZ3JlZSA9IG1pbkRlZ3JlZU5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGggPCBtaW5EZWdyZWUpIHtcbiAgICAgICAgICBtaW5EZWdyZWUgPSBub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICAgIG1pbkRlZ3JlZU5vZGUgPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG5vZGVzQ29ubmVjdGVkVG9EdW1teS5wdXNoKG1pbkRlZ3JlZU5vZGUuaWQoKSk7XG4gICAgICAvLyBUTyBETzogQ2hlY2sgZWZmaWNpZW5jeSBvZiB0aGlzIHBhcnRcbiAgICAgIHZhciB0ZW1wID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgdGVtcC5tZXJnZSh2aXNpdGVkVG9wTW9zdE5vZGVzWzBdKTtcbiAgICAgIHZpc2l0ZWRUb3BNb3N0Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0ZW1wLm1lcmdlKG5vZGUpO1xuICAgICAgfSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzID0gW107XG4gICAgICB0b3BNb3N0Tm9kZXMgPSB0b3BNb3N0Tm9kZXMuZGlmZmVyZW5jZSh0ZW1wKTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9O1xuXG4gIGRvIHtcbiAgICBfbG9vcCgpO1xuICB9IHdoaWxlICghaXNDb25uZWN0ZWQpO1xuXG4gIGlmIChkdW1teU5vZGVzKSB7XG4gICAgaWYgKG5vZGVzQ29ubmVjdGVkVG9EdW1teS5sZW5ndGggPiAwKSB7XG4gICAgICBkdW1teU5vZGVzLnNldCgnZHVtbXknICsgKGR1bW15Tm9kZXMuc2l6ZSArIDEpLCBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50cztcbn07XG5cbi8vIHJlbG9jYXRlcyBjb21wb25lbnRSZXN1bHQgdG8gb3JpZ2luYWxDZW50ZXIgaWYgdGhlcmUgaXMgbm8gZml4ZWROb2RlQ29uc3RyYWludFxuYXV4aWxpYXJ5LnJlbG9jYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKG9yaWdpbmFsQ2VudGVyLCBjb21wb25lbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICB2YXIgbWluWENvb3JkID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBtYXhYQ29vcmQgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbllDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WUNvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgY3VycmVudCBib3VuZGluZyBib3hcbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBjb21wb25lbnRSZXN1bHQubm9kZUluZGV4ZXNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpO1xuXG4gICAgICAgICAgdmFyIGtleSA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyWzFdO1xuXG4gICAgICAgICAgdmFyIGN5Tm9kZSA9IG9wdGlvbnMuY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KTtcbiAgICAgICAgICBpZiAoY3lOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUJCID0gY3lOb2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICB2YXIgbGVmdFggPSBjb21wb25lbnRSZXN1bHQueENvb3Jkc1t2YWx1ZV0gLSBub2RlQkIudyAvIDI7XG4gICAgICAgICAgICB2YXIgcmlnaHRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdICsgbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHRvcFkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gLSBub2RlQkIuaCAvIDI7XG4gICAgICAgICAgICB2YXIgYm90dG9tWSA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi5oIC8gMjtcblxuICAgICAgICAgICAgaWYgKGxlZnRYIDwgbWluWENvb3JkKSBtaW5YQ29vcmQgPSBsZWZ0WDtcbiAgICAgICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICAgICAgaWYgKGJvdHRvbVkgPiBtYXhZQ29vcmQpIG1heFlDb29yZCA9IGJvdHRvbVk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmQgZGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIG9yaWdpbmFsIGNlbnRlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaWZmT25YID0gb3JpZ2luYWxDZW50ZXIueCAtIChtYXhYQ29vcmQgKyBtaW5YQ29vcmQpIC8gMjtcbiAgICAgIHZhciBkaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgY29tcG9uZW50UmVzdWx0LnhDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHggKyBkaWZmT25YO1xuICAgICAgfSk7XG4gICAgICBjb21wb25lbnRSZXN1bHQueUNvb3JkcyA9IGNvbXBvbmVudFJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICByZXR1cm4geSArIGRpZmZPblk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIHZhciBsZWZ0WCA9IG5vZGUuZ2V0UmVjdCgpLng7XG4gICAgICAgIHZhciByaWdodFggPSBub2RlLmdldFJlY3QoKS54ICsgbm9kZS5nZXRSZWN0KCkud2lkdGg7XG4gICAgICAgIHZhciB0b3BZID0gbm9kZS5nZXRSZWN0KCkueTtcbiAgICAgICAgdmFyIGJvdHRvbVkgPSBub2RlLmdldFJlY3QoKS55ICsgbm9kZS5nZXRSZWN0KCkuaGVpZ2h0O1xuXG4gICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgIGlmIChyaWdodFggPiBtYXhYQ29vcmQpIG1heFhDb29yZCA9IHJpZ2h0WDtcbiAgICAgICAgaWYgKHRvcFkgPCBtaW5ZQ29vcmQpIG1pbllDb29yZCA9IHRvcFk7XG4gICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgfSk7XG4gICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIHZhciBfZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgX2RpZmZPblkgPSBvcmlnaW5hbENlbnRlci55IC0gKG1heFlDb29yZCArIG1pbllDb29yZCkgLyAyO1xuICAgICAgLy8gbW92ZSBjb21wb25lbnQgdG8gb3JpZ2luYWwgY2VudGVyXG4gICAgICBPYmplY3Qua2V5cyhjb21wb25lbnRSZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBjb21wb25lbnRSZXN1bHRbaXRlbV07XG4gICAgICAgIG5vZGUuc2V0Q2VudGVyKG5vZGUuZ2V0Q2VudGVyWCgpICsgX2RpZmZPblgsIG5vZGUuZ2V0Q2VudGVyWSgpICsgX2RpZmZPblkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59O1xuXG5hdXhpbGlhcnkuY2FsY0JvdW5kaW5nQm94ID0gZnVuY3Rpb24gKHBhcmVudE5vZGUsIHhDb29yZHMsIHlDb29yZHMsIG5vZGVJbmRleGVzKSB7XG4gIC8vIGNhbGN1bGF0ZSBib3VuZHNcbiAgdmFyIGxlZnQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIHJpZ2h0ID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gIHZhciB0b3AgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgdmFyIGJvdHRvbSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgbm9kZUxlZnQgPSB2b2lkIDA7XG4gIHZhciBub2RlUmlnaHQgPSB2b2lkIDA7XG4gIHZhciBub2RlVG9wID0gdm9pZCAwO1xuICB2YXIgbm9kZUJvdHRvbSA9IHZvaWQgMDtcblxuICB2YXIgbm9kZXMgPSBwYXJlbnROb2RlLmRlc2NlbmRhbnRzKCkubm90KFwiOnBhcmVudFwiKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIG5vZGVMZWZ0ID0geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLndpZHRoKCkgLyAyO1xuICAgIG5vZGVSaWdodCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlVG9wID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gLSBub2RlLmhlaWdodCgpIC8gMjtcbiAgICBub2RlQm90dG9tID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKV0gKyBub2RlLmhlaWdodCgpIC8gMjtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ0JveCA9IHt9O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WCA9IGxlZnQ7XG4gIGJvdW5kaW5nQm94LnRvcExlZnRZID0gdG9wO1xuICBib3VuZGluZ0JveC53aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgYm91bmRpbmdCb3guaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICByZXR1cm4gYm91bmRpbmdCb3g7XG59O1xuXG4vLyBUaGlzIGZ1bmN0aW9uIGZpbmRzIGFuZCByZXR1cm5zIHBhcmVudCBub2RlcyB3aG9zZSBhbGwgY2hpbGRyZW4gYXJlIGhpZGRlblxuYXV4aWxpYXJ5LmNhbGNQYXJlbnRzV2l0aG91dENoaWxkcmVuID0gZnVuY3Rpb24gKGN5LCBlbGVzKSB7XG4gIHZhciBwYXJlbnRzV2l0aG91dENoaWxkcmVuID0gY3kuY29sbGVjdGlvbigpO1xuICBlbGVzLm5vZGVzKCc6cGFyZW50JykuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgdmFyIGNoZWNrID0gZmFsc2U7XG4gICAgcGFyZW50LmNoaWxkcmVuKCkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5jc3MoJ2Rpc3BsYXknKSAhPSAnbm9uZScpIHtcbiAgICAgICAgY2hlY2sgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghY2hlY2spIHtcbiAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubWVyZ2UocGFyZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJlbnRzV2l0aG91dENoaWxkcmVuO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhdXhpbGlhcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG4vKipcbiAgVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBwb3N0cHJvY2Vzc2luZyBwYXJ0IHRoYXQgYXBwbGllcyBDb1NFIGxheW91dCBvdmVyIHRoZSBzcGVjdHJhbCBsYXlvdXRcbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgQ29TRUxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTGF5b3V0O1xudmFyIENvU0VOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VOb2RlO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlBvaW50RDtcbnZhciBEaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRGltZW5zaW9uRDtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHM7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5GRExheW91dENvbnN0YW50cztcbnZhciBDb1NFQ29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLkNvU0VDb25zdGFudHM7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBjb3NlIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBjb3NlTGF5b3V0ID0gZnVuY3Rpb24gY29zZUxheW91dChvcHRpb25zLCBzcGVjdHJhbFJlc3VsdCkge1xuXG4gIHZhciBjeSA9IG9wdGlvbnMuY3k7XG4gIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcblxuICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIGlkVG9MTm9kZSA9IHt9O1xuXG4gIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbXCJub2RlSW5kZXhlc1wiXTtcbiAgICB4Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ4Q29vcmRzXCJdO1xuICAgIHlDb29yZHMgPSBzcGVjdHJhbFJlc3VsdFtcInlDb29yZHNcIl07XG4gIH1cblxuICB2YXIgaXNGbiA9IGZ1bmN0aW9uIGlzRm4oZm4pIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nO1xuICB9O1xuXG4gIHZhciBvcHRGbiA9IGZ1bmN0aW9uIG9wdEZuKG9wdCwgZWxlKSB7XG4gICAgaWYgKGlzRm4ob3B0KSkge1xuICAgICAgcmV0dXJuIG9wdChlbGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBQb3N0cHJvY2Vzc2luZyBmdW5jdGlvbnMgKioqKi9cblxuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIG5vZGVzIHRvIGNvc2Ugbm9kZXNcbiAgdmFyIHByb2Nlc3NDaGlsZHJlbkxpc3QgPSBmdW5jdGlvbiBwcm9jZXNzQ2hpbGRyZW5MaXN0KHBhcmVudCwgY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucykge1xuICAgIHZhciBzaXplID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgdGhlQ2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IG51bGw7XG4gICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuX29mX2NoaWxkcmVuID0gdGhlQ2hpbGQuY2hpbGRyZW4oKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aGVOb2RlID0gdm9pZCAwO1xuXG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoZUNoaWxkLmxheW91dERpbWVuc2lvbnMoe1xuICAgICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoZUNoaWxkLm91dGVyV2lkdGgoKSAhPSBudWxsICYmIHRoZUNoaWxkLm91dGVySGVpZ2h0KCkgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICBpZiAoIXRoZUNoaWxkLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMudyAvIDIsIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHRoZUNoaWxkLmlkKCkpXSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRoZUNoaWxkLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICBpZiAodGhlQ2hpbGQuaW50ZXJzZWN0aW9uKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4pLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHBhcmVudEluZm8udG9wTGVmdFgsIHBhcmVudEluZm8udG9wTGVmdFkpLCBuZXcgRGltZW5zaW9uRChwYXJlbnRJbmZvLndpZHRoLCBwYXJlbnRJbmZvLmhlaWdodCkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgcGFyZW50c1dpdGhvdXRDaGlsZHJlblxuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoZU5vZGUgPSBwYXJlbnQuYWRkKG5ldyBDb1NFTm9kZShsYXlvdXQuZ3JhcGhNYW5hZ2VyLCBuZXcgUG9pbnREKHRoZUNoaWxkLnBvc2l0aW9uKCd4JykgLSBkaW1lbnNpb25zLncgLyAyLCB0aGVDaGlsZC5wb3NpdGlvbigneScpIC0gZGltZW5zaW9ucy5oIC8gMiksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUodGhpcy5ncmFwaE1hbmFnZXIpKTtcbiAgICAgIH1cbiAgICAgIC8vIEF0dGFjaCBpZCB0byB0aGUgbGF5b3V0IG5vZGUgYW5kIHJlcHVsc2lvbiB2YWx1ZVxuICAgICAgdGhlTm9kZS5pZCA9IHRoZUNoaWxkLmRhdGEoXCJpZFwiKTtcbiAgICAgIHRoZU5vZGUubm9kZVJlcHVsc2lvbiA9IG9wdEZuKG9wdGlvbnMubm9kZVJlcHVsc2lvbiwgdGhlQ2hpbGQpO1xuICAgICAgLy8gQXR0YWNoIHRoZSBwYWRkaW5ncyBvZiBjeSBub2RlIHRvIGxheW91dCBub2RlXG4gICAgICB0aGVOb2RlLnBhZGRpbmdMZWZ0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nVG9wID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nUmlnaHQgPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG4gICAgICB0aGVOb2RlLnBhZGRpbmdCb3R0b20gPSBwYXJzZUludCh0aGVDaGlsZC5jc3MoJ3BhZGRpbmcnKSk7XG5cbiAgICAgIC8vQXR0YWNoIHRoZSBsYWJlbCBwcm9wZXJ0aWVzIHRvIGJvdGggY29tcG91bmQgYW5kIHNpbXBsZSBub2RlcyBpZiBsYWJlbHMgd2lsbCBiZSBpbmNsdWRlZCBpbiBub2RlIGRpbWVuc2lvbnNcbiAgICAgIC8vVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHVzZWQgd2hpbGUgdXBkYXRpbmcgYm91bmRzIG9mIGNvbXBvdW5kcyBkdXJpbmcgaXRlcmF0aW9ucyBvciB0aWxpbmdcbiAgICAgIC8vYW5kIHdpbGwgYmUgdXNlZCBmb3Igc2ltcGxlIG5vZGVzIHdoaWxlIHRyYW5zZmVycmluZyBmaW5hbCBwb3NpdGlvbnMgdG8gY3l0b3NjYXBlXG4gICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFdpZHRoID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLnc7XG4gICAgICAgIHRoZU5vZGUubGFiZWxIZWlnaHQgPSB0aGVDaGlsZC5ib3VuZGluZ0JveCh7IGluY2x1ZGVMYWJlbHM6IHRydWUsIGluY2x1ZGVOb2RlczogZmFsc2UsIGluY2x1ZGVPdmVybGF5czogZmFsc2UgfSkuaDtcbiAgICAgICAgdGhlTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC12YWxpZ25cIik7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NIb3Jpem9udGFsID0gdGhlQ2hpbGQuY3NzKFwidGV4dC1oYWxpZ25cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIE1hcCB0aGUgbGF5b3V0IG5vZGVcbiAgICAgIGlkVG9MTm9kZVt0aGVDaGlsZC5kYXRhKFwiaWRcIildID0gdGhlTm9kZTtcblxuICAgICAgaWYgKGlzTmFOKHRoZU5vZGUucmVjdC54KSkge1xuICAgICAgICB0aGVOb2RlLnJlY3QueCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueSkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnkgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGRyZW5fb2ZfY2hpbGRyZW4gIT0gbnVsbCAmJiBjaGlsZHJlbl9vZl9jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0aGVOZXdHcmFwaCA9IHZvaWQgMDtcbiAgICAgICAgdGhlTmV3R3JhcGggPSBsYXlvdXQuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKGxheW91dC5uZXdHcmFwaCgpLCB0aGVOb2RlKTtcbiAgICAgICAgcHJvY2Vzc0NoaWxkcmVuTGlzdCh0aGVOZXdHcmFwaCwgY2hpbGRyZW5fb2ZfY2hpbGRyZW4sIGxheW91dCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBlZGdlcyB0byBjb3NlIGVkZ2VzXG4gIHZhciBwcm9jZXNzRWRnZXMgPSBmdW5jdGlvbiBwcm9jZXNzRWRnZXMobGF5b3V0LCBnbSwgZWRnZXMpIHtcbiAgICB2YXIgaWRlYWxMZW5ndGhUb3RhbCA9IDA7XG4gICAgdmFyIGVkZ2VDb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgIHZhciBzb3VyY2VOb2RlID0gaWRUb0xOb2RlW2VkZ2UuZGF0YShcInNvdXJjZVwiKV07XG4gICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJ0YXJnZXRcIildO1xuICAgICAgaWYgKHNvdXJjZU5vZGUgJiYgdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlICE9PSB0YXJnZXROb2RlICYmIHNvdXJjZU5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHRhcmdldE5vZGUpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHZhciBlMSA9IGdtLmFkZChsYXlvdXQubmV3RWRnZSgpLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICAgICAgZTEuaWQgPSBlZGdlLmlkKCk7XG4gICAgICAgIGUxLmlkZWFsTGVuZ3RoID0gb3B0Rm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgsIGVkZ2UpO1xuICAgICAgICBlMS5lZGdlRWxhc3RpY2l0eSA9IG9wdEZuKG9wdGlvbnMuZWRnZUVsYXN0aWNpdHksIGVkZ2UpO1xuICAgICAgICBpZGVhbExlbmd0aFRvdGFsICs9IGUxLmlkZWFsTGVuZ3RoO1xuICAgICAgICBlZGdlQ291bnQrKztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gd2UgbmVlZCB0byB1cGRhdGUgdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50IHdpdGggdGhlIGF2Zy4gaWRlYWwgbGVuZ3RoIHZhbHVlIGFmdGVyIHByb2Nlc3NpbmcgZWRnZXNcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIHVzZSBvdGhlciBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoICE9IG51bGwpIHtcbiAgICAgIGlmIChlZGdlQ291bnQgPiAwKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gaWRlYWxMZW5ndGhUb3RhbCAvIGVkZ2VDb3VudDtlbHNlIGlmICghaXNGbihvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCkpIC8vIGluIGNhc2UgdGhlcmUgaXMgbm8gZWRnZSwgYnV0IG9wdGlvbiBnaXZlcyBhIHZhbHVlIHRvIHVzZVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGg7ZWxzZSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UgYW5kIHdlIGNhbm5vdCBnZXQgYSB2YWx1ZSBmcm9tIG9wdGlvbiAoYmVjYXVzZSBpdCdzIGEgZnVuY3Rpb24pXG4gICAgICAgIENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbiAgICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZXNlIGNvbnN0YW50IHZhbHVlcyBiYXNlZCBvbiB0aGUgaWRlYWwgZWRnZSBsZW5ndGggY29uc3RhbnRcbiAgICAgIENvU0VDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwLjA7XG4gICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfUkFESUFMX1NFUEFSQVRJT04gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgY29uc3RyYWludHMgdG8gY29zZSBsYXlvdXRcbiAgdmFyIHByb2Nlc3NDb25zdHJhaW50cyA9IGZ1bmN0aW9uIHByb2Nlc3NDb25zdHJhaW50cyhsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgZml4ZWRcbiAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJmaXhlZE5vZGVDb25zdHJhaW50XCJdID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgYWxpZ25lZFxuICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcImFsaWdubWVudENvbnN0cmFpbnRcIl0gPSBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICAgIC8vIGdldCBub2RlcyB0byBiZSByZWxhdGl2ZWx5IHBsYWNlZFxuICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wicmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgfVxuICB9O1xuXG4gIC8qKioqIEFwcGx5IHBvc3Rwcm9jZXNzaW5nICoqKiovXG4gIGlmIChvcHRpb25zLm5lc3RpbmdGYWN0b3IgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IG9wdGlvbnMubmVzdGluZ0ZhY3RvcjtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eTtcbiAgaWYgKG9wdGlvbnMubnVtSXRlciAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlMgPSBvcHRpb25zLm51bUl0ZXI7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlSYW5nZSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2U7XG4gIGlmIChvcHRpb25zLmdyYXZpdHlDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSCA9IG9wdGlvbnMuZ3Jhdml0eUNvbXBvdW5kO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZCAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gb3B0aW9ucy5ncmF2aXR5UmFuZ2VDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWwgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IG9wdGlvbnMuaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw7XG5cbiAgaWYgKG9wdGlvbnMudGlsaW5nQ29tcGFyZUJ5ICE9IG51bGwpIENvU0VDb25zdGFudHMuVElMSU5HX0NPTVBBUkVfQlkgPSBvcHRpb25zLnRpbGluZ0NvbXBhcmVCeTtcblxuICBpZiAob3B0aW9ucy5xdWFsaXR5ID09ICdwcm9vZicpIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMjtlbHNlIExheW91dENvbnN0YW50cy5RVUFMSVRZID0gMDtcblxuICBDb1NFQ29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IEZETGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVscztcbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBDb1NFQ29uc3RhbnRzLkFOSU1BVEUgPSBGRExheW91dENvbnN0YW50cy5BTklNQVRFID0gTGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPSBvcHRpb25zLmFuaW1hdGU7XG4gIENvU0VDb25zdGFudHMuVElMRSA9IG9wdGlvbnMudGlsZTtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19WRVJUSUNBTCA9IHR5cGVvZiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ1ZlcnRpY2FsO1xuICBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwuY2FsbCgpIDogb3B0aW9ucy50aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDtcblxuICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSB0cnVlO1xuICBDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwgPSAhb3B0aW9ucy5yYW5kb21pemU7XG4gIExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTID0gb3B0aW9ucy51bmlmb3JtTm9kZURpbWVuc2lvbnM7XG5cbiAgLy8gVGhpcyBwYXJ0IGlzIGZvciBkZWJ1Zy9kZW1vIHB1cnBvc2VcbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcInRyYW5zZm9ybWVkXCIpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJlbmZvcmNlZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiY29zZVwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiYWxsXCIpIHtcbiAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSB0cnVlO2Vsc2UgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IGZhbHNlO1xuICAgIENvU0VDb25zdGFudHMuRU5GT1JDRV9DT05TVFJBSU5UUyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICBDb1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IHRydWU7XG4gIH1cblxuICB2YXIgY29zZUxheW91dCA9IG5ldyBDb1NFTGF5b3V0KCk7XG4gIHZhciBnbSA9IGNvc2VMYXlvdXQubmV3R3JhcGhNYW5hZ2VyKCk7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuTGlzdChnbS5hZGRSb290KCksIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBjb3NlTGF5b3V0LCBvcHRpb25zKTtcbiAgcHJvY2Vzc0VkZ2VzKGNvc2VMYXlvdXQsIGdtLCBlZGdlcyk7XG4gIHByb2Nlc3NDb25zdHJhaW50cyhjb3NlTGF5b3V0LCBvcHRpb25zKTtcblxuICBjb3NlTGF5b3V0LnJ1bkxheW91dCgpO1xuXG4gIHJldHVybiBpZFRvTE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY29zZUxheW91dDogY29zZUxheW91dCB9O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjEyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZmNvc2UgbGF5b3V0IGFsZ29yaXRobVxuKi9cblxudmFyIGFzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oNjU4KTtcbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjU3KSxcbiAgICBzcGVjdHJhbExheW91dCA9IF9yZXF1aXJlLnNwZWN0cmFsTGF5b3V0O1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpLFxuICAgIGNvc2VMYXlvdXQgPSBfcmVxdWlyZTIuY29zZUxheW91dDtcblxudmFyIGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG5cbiAgLy8gJ2RyYWZ0JywgJ2RlZmF1bHQnIG9yICdwcm9vZicgXG4gIC8vIC0gJ2RyYWZ0JyBvbmx5IGFwcGxpZXMgc3BlY3RyYWwgbGF5b3V0IFxuICAvLyAtICdkZWZhdWx0JyBpbXByb3ZlcyB0aGUgcXVhbGl0eSB3aXRoIHN1YnNlcXVlbnQgQ29TRSBsYXlvdXQgKGZhc3QgY29vbGluZyByYXRlKVxuICAvLyAtICdwcm9vZicgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChzbG93IGNvb2xpbmcgcmF0ZSkgXG4gIHF1YWxpdHk6IFwiZGVmYXVsdFwiLFxuICAvLyBVc2UgcmFuZG9tIG5vZGUgcG9zaXRpb25zIGF0IGJlZ2lubmluZyBvZiBsYXlvdXRcbiAgLy8gaWYgdGhpcyBpcyBzZXQgdG8gZmFsc2UsIHRoZW4gcXVhbGl0eSBvcHRpb24gbXVzdCBiZSBcInByb29mXCJcbiAgcmFuZG9taXplOiB0cnVlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCB0byBhbmltYXRlIHRoZSBsYXlvdXRcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgLy8gRHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiAxMDAwLFxuICAvLyBFYXNpbmcgb2YgYW5pbWF0aW9uLCBpZiBlbmFibGVkXG4gIGFuaW1hdGlvbkVhc2luZzogdW5kZWZpbmVkLFxuICAvLyBGaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSByZXBvc2l0aW9uZWQgbm9kZXNcbiAgZml0OiB0cnVlLFxuICAvLyBQYWRkaW5nIGFyb3VuZCBsYXlvdXRcbiAgcGFkZGluZzogMzAsXG4gIC8vIFdoZXRoZXIgdG8gaW5jbHVkZSBsYWJlbHMgaW4gbm9kZSBkaW1lbnNpb25zLiBWYWxpZCBpbiBcInByb29mXCIgcXVhbGl0eVxuICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIG9yIG5vdCBzaW1wbGUgbm9kZXMgKG5vbi1jb21wb3VuZCBub2RlcykgYXJlIG9mIHVuaWZvcm0gZGltZW5zaW9uc1xuICB1bmlmb3JtTm9kZURpbWVuc2lvbnM6IGZhbHNlLFxuICAvLyBXaGV0aGVyIHRvIHBhY2sgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgLSB2YWxpZCBvbmx5IGlmIHJhbmRvbWl6ZTogdHJ1ZVxuICBwYWNrQ29tcG9uZW50czogdHJ1ZSxcbiAgLy8gTGF5b3V0IHN0ZXAgLSBhbGwsIHRyYW5zZm9ybWVkLCBlbmZvcmNlZCwgY29zZSAtIGZvciBkZWJ1ZyBwdXJwb3NlIG9ubHlcbiAgc3RlcDogXCJhbGxcIixcblxuICAvKiBzcGVjdHJhbCBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIEZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICBzYW1wbGluZ1R5cGU6IHRydWUsXG4gIC8vIFNhbXBsZSBzaXplIHRvIGNvbnN0cnVjdCBkaXN0YW5jZSBtYXRyaXhcbiAgc2FtcGxlU2l6ZTogMjUsXG4gIC8vIFNlcGFyYXRpb24gYW1vdW50IGJldHdlZW4gbm9kZXNcbiAgbm9kZVNlcGFyYXRpb246IDc1LFxuICAvLyBQb3dlciBpdGVyYXRpb24gdG9sZXJhbmNlXG4gIHBpVG9sOiAwLjAwMDAwMDEsXG5cbiAgLyogQ29TRSBsYXlvdXQgb3B0aW9ucyAqL1xuXG4gIC8vIE5vZGUgcmVwdWxzaW9uIChub24gb3ZlcmxhcHBpbmcpIG11bHRpcGxpZXJcbiAgbm9kZVJlcHVsc2lvbjogZnVuY3Rpb24gbm9kZVJlcHVsc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIDQ1MDA7XG4gIH0sXG4gIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICBpZGVhbEVkZ2VMZW5ndGg6IGZ1bmN0aW9uIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgcmV0dXJuIDUwO1xuICB9LFxuICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgZWRnZUVsYXN0aWNpdHk6IGZ1bmN0aW9uIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICByZXR1cm4gMC40NTtcbiAgfSxcbiAgLy8gTmVzdGluZyBmYWN0b3IgKG11bHRpcGxpZXIpIHRvIGNvbXB1dGUgaWRlYWwgZWRnZSBsZW5ndGggZm9yIG5lc3RlZCBlZGdlc1xuICBuZXN0aW5nRmFjdG9yOiAwLjEsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KVxuICBncmF2aXR5OiAwLjI1LFxuICAvLyBNYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIHRvIHBlcmZvcm1cbiAgbnVtSXRlcjogMjUwMCxcbiAgLy8gRm9yIGVuYWJsaW5nIHRpbGluZ1xuICB0aWxlOiB0cnVlLFxuICAvLyBUaGUgZnVuY3Rpb24gdGhhdCBzcGVjaWZpZXMgdGhlIGNyaXRlcmlhIGZvciBjb21wYXJpbmcgbm9kZXMgd2hpbGUgc29ydGluZyB0aGVtIGR1cmluZyB0aWxpbmcgb3BlcmF0aW9uLlxuICAvLyBUYWtlcyB0aGUgbm9kZSBpZCBhcyBhIHBhcmFtZXRlciBhbmQgdGhlIGRlZmF1bHQgdGlsaW5nIG9wZXJhdGlvbiBpcyBwZXJmb21lZCB3aGVuIHRoaXMgb3B0aW9uIGlzIG5vdCBzZXQuXG4gIHRpbGluZ0NvbXBhcmVCeTogdW5kZWZpbmVkLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIHZlcnRpY2FsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nVmVydGljYWw6IDEwLFxuICAvLyBSZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgdGhlIGhvcml6b250YWwgc3BhY2UgdG8gcHV0IGJldHdlZW4gdGhlIHplcm8gZGVncmVlIG1lbWJlcnMgZHVyaW5nIHRoZSB0aWxpbmcgb3BlcmF0aW9uKGNhbiBhbHNvIGJlIGEgZnVuY3Rpb24pXG4gIHRpbGluZ1BhZGRpbmdIb3Jpem9udGFsOiAxMCxcbiAgLy8gR3Jhdml0eSByYW5nZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eVJhbmdlQ29tcG91bmQ6IDEuNSxcbiAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpIGZvciBjb21wb3VuZHNcbiAgZ3Jhdml0eUNvbXBvdW5kOiAxLjAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KVxuICBncmF2aXR5UmFuZ2U6IDMuOCxcbiAgLy8gSW5pdGlhbCBjb29saW5nIGZhY3RvciBmb3IgaW5jcmVtZW50YWwgbGF5b3V0ICBcbiAgaW5pdGlhbEVuZXJneU9uSW5jcmVtZW50YWw6IDAuMyxcblxuICAvKiBjb25zdHJhaW50IG9wdGlvbnMgKi9cblxuICAvLyBGaXggcmVxdWlyZWQgbm9kZXMgdG8gcHJlZGVmaW5lZCBwb3NpdGlvbnNcbiAgLy8gW3tub2RlSWQ6ICduMScsIHBvc2l0aW9uOiB7eDogMTAwLCB5OiAyMDB9LCB7Li4ufV1cbiAgZml4ZWROb2RlQ29uc3RyYWludDogdW5kZWZpbmVkLFxuICAvLyBBbGlnbiByZXF1aXJlZCBub2RlcyBpbiB2ZXJ0aWNhbC9ob3Jpem9udGFsIGRpcmVjdGlvblxuICAvLyB7dmVydGljYWw6IFtbJ24xJywgJ24yJyldLCBbJ24zJywgJ240J11dLCBob3Jpem9udGFsOiBbJ24yJywgJ240J119XG4gIGFsaWdubWVudENvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gUGxhY2UgdHdvIG5vZGVzIHJlbGF0aXZlbHkgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb24gXG4gIC8vIFt7dG9wOiAnbjEnLCBib3R0b206ICduMicsIGdhcDogMTAwfSwge2xlZnQ6ICduMycsIHJpZ2h0OiAnbjQnLCBnYXA6IDc1fV1cbiAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG5cbiAgLyogbGF5b3V0IGV2ZW50IGNhbGxiYWNrcyAqL1xuICByZWFkeTogZnVuY3Rpb24gcmVhZHkoKSB7fSwgLy8gb24gbGF5b3V0cmVhZHlcbiAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHt9IC8vIG9uIGxheW91dHN0b3Bcbn0pO1xuXG52YXIgTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYXlvdXQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXQpO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGF5b3V0LCBbe1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG5cbiAgICAgIHZhciBzcGVjdHJhbFJlc3VsdCA9IFtdO1xuICAgICAgdmFyIHhDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgeUNvb3JkcyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb3NlUmVzdWx0ID0gW107XG4gICAgICB2YXIgY29tcG9uZW50cyA9IHZvaWQgMDtcbiAgICAgIHZhciBjb21wb25lbnRDZW50ZXJzID0gW107XG5cbiAgICAgIC8vIGJhc2ljIHZhbGlkaXR5IGNoZWNrIGZvciBjb25zdHJhaW50IGlucHV0cyBcbiAgICAgIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkgfHwgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwubGVuZ3RoID09IDApKSB7XG4gICAgICAgICAgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCAmJiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50Lmxlbmd0aCA9PSAwKSkge1xuICAgICAgICBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYW55IGNvbnN0cmFpbnQgZXhpc3RzLCBzZXQgc29tZSBvcHRpb25zXG4gICAgICB2YXIgY29uc3RyYWludEV4aXN0ID0gb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50IHx8IG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludCB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDtcbiAgICAgIGlmIChjb25zdHJhaW50RXhpc3QpIHtcbiAgICAgICAgLy8gY29uc3RyYWludHMgd29yayB3aXRoIHRoZXNlIG9wdGlvbnNcbiAgICAgICAgb3B0aW9ucy50aWxlID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMucGFja0NvbXBvbmVudHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjaWRlIGNvbXBvbmVudCBwYWNraW5nIGlzIGVuYWJsZWQgb3Igbm90XG4gICAgICB2YXIgbGF5VXRpbCA9IHZvaWQgMDtcbiAgICAgIHZhciBwYWNraW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgaWYgKGN5LmxheW91dFV0aWxpdGllcyAmJiBvcHRpb25zLnBhY2tDb21wb25lbnRzKSB7XG4gICAgICAgIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoXCJnZXRcIik7XG4gICAgICAgIGlmICghbGF5VXRpbCkgbGF5VXRpbCA9IGN5LmxheW91dFV0aWxpdGllcygpO1xuICAgICAgICBwYWNraW5nRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVzLm5vZGVzKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiBwYWNraW5nIGlzIG5vdCBlbmFibGVkLCBwZXJmb3JtIGxheW91dCBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgICAgaWYgKCFwYWNraW5nRW5hYmxlZCkge1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJcbiAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBvcHRpb25zLmVsZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBib3VuZGluZ0JveC54MSArIGJvdW5kaW5nQm94LncgLyAyLCB5OiBib3VuZGluZ0JveC55MSArIGJvdW5kaW5nQm94LmggLyAyIH0pO1xuICAgICAgICAgIC8vIGFwcGx5IHNwZWN0cmFsIGxheW91dFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpO1xuICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhcHBseSBjb3NlIGxheW91dCBhcyBwb3N0cHJvY2Vzc2luZ1xuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbMF0pKTtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBjb3NlUmVzdWx0WzBdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzWzBdLCBzcGVjdHJhbFJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwYWNraW5nIGlzIGVuYWJsZWRcbiAgICAgICAgICB2YXIgdG9wTW9zdE5vZGVzID0gYXV4LmdldFRvcE1vc3ROb2RlcyhvcHRpb25zLmVsZXMubm9kZXMoKSk7XG4gICAgICAgICAgY29tcG9uZW50cyA9IGF1eC5jb25uZWN0Q29tcG9uZW50cyhjeSwgb3B0aW9ucy5lbGVzLCB0b3BNb3N0Tm9kZXMpO1xuICAgICAgICAgIC8vIHN0b3JlIGNvbXBvbmVudCBjZW50ZXJzXG4gICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveCA9IGNvbXBvbmVudC5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vc2VuZCBlYWNoIGNvbXBvbmVudCB0byBzcGVjdHJhbCBsYXlvdXQgaWYgcmFuZG9taXplZFxuICAgICAgICAgIGlmIChvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lbGVzID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgICAgdmFyIHRvQmVUaWxlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGlsZSkge1xuICAgICAgICAgICAgICAvLyBiZWhhdmUgbm9kZXMgdG8gYmUgdGlsZWQgYXMgb25lIGNvbXBvbmVudFxuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIHZhciBfeENvb3JkcyA9IFtdO1xuICAgICAgICAgICAgICB2YXIgX3lDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgdmFyIHRlbXBTcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiBfeENvb3JkcywgeUNvb3JkczogX3lDb29yZHMgfTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ZXNUb0JlRGVsZXRlZCA9IFtdO1xuICAgICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50LmVkZ2VzKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9CZVRpbGVkTm9kZXMubWVyZ2UoY29tcG9uZW50Lm5vZGVzKClbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNQYXJlbnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC5ub2RlSW5kZXhlcy5zZXQoY29tcG9uZW50Lm5vZGVzKClbaV0uaWQoKSwgY291bnQrKyk7XG4gICAgICAgICAgICAgICAgICAgICAgdGVtcFNwZWN0cmFsUmVzdWx0LnhDb29yZHMucHVzaChjb21wb25lbnQubm9kZXMoKVswXS5wb3NpdGlvbigpLngpO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC55Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpbmRleGVzVG9CZURlbGV0ZWQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHRvQmVUaWxlZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2JvdW5kaW5nQm94ID0gdG9CZVRpbGVkTm9kZXMuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnB1c2goeyB4OiBfYm91bmRpbmdCb3gueDEgKyBfYm91bmRpbmdCb3gudyAvIDIsIHk6IF9ib3VuZGluZ0JveC55MSArIF9ib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzLnB1c2godG9CZVRpbGVkTm9kZXMpO1xuICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2godGVtcFNwZWN0cmFsUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaW5kZXhlc1RvQmVEZWxldGVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuc3BsaWNlKGluZGV4ZXNUb0JlRGVsZXRlZFtpXSwgMSk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRDZW50ZXJzLnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICAvLyBzZW5kIGVhY2ggY29tcG9uZW50IHRvIGNvc2UgbGF5b3V0XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgY29zZVJlc3VsdC5wdXNoKGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdKSk7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgY29zZVJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgYXV4LnJlbG9jYXRlQ29tcG9uZW50KGNvbXBvbmVudENlbnRlcnNbaW5kZXhdLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBhY2tpbmdcbiAgICAgICAgICB2YXIgY29tcG9uZW50c0V2YWx1YXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgc3ViZ3JhcGhzID0gW107XG4gICAgICAgICAgICB2YXIgaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUluZGV4ZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZUluZGV4ZXMgPSBzcGVjdHJhbFJlc3VsdFtpbmRleF0ubm9kZUluZGV4ZXM7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViZ3JhcGggPSB7fTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5ub3QoaGlkZGVuRWxlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBub2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQobm9kZS5pZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS53IC8gMiwgeTogc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbbm9kZUluZGV4XSAtIG5vZGUuYm91bmRpbmdib3goKS5oIC8gMiwgd2lkdGg6IG5vZGUuYm91bmRpbmdib3goKS53LCBoZWlnaHQ6IG5vZGUuYm91bmRpbmdib3goKS5oIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChub2RlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2Rlcy5wdXNoKHsgeDogcGFyZW50SW5mby50b3BMZWZ0WCwgeTogcGFyZW50SW5mby50b3BMZWZ0WSwgd2lkdGg6IHBhcmVudEluZm8ud2lkdGgsIGhlaWdodDogcGFyZW50SW5mby5oZWlnaHQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0TGVmdCgpLCB5OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldFRvcCgpLCB3aWR0aDogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRXaWR0aCgpLCBoZWlnaHQ6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0SGVpZ2h0KCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlZGdlLnRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiICYmIHRhcmdldC5jc3MoXCJkaXNwbGF5XCIpICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZU5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChzb3VyY2UuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldE5vZGVJbmRleCA9IG5vZGVJbmRleGVzLmdldCh0YXJnZXQuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZUNlbnRlciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveChzb3VyY2UsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2gocGFyZW50SW5mby50b3BMZWZ0WCArIHBhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFkgKyBwYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3NvdXJjZU5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3godGFyZ2V0LCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRYICsgX3BhcmVudEluZm8ud2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKF9wYXJlbnRJbmZvLnRvcExlZnRZICsgX3BhcmVudEluZm8uaGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHNbdGFyZ2V0Tm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLmVkZ2VzLnB1c2goeyBzdGFydFg6IHNvdXJjZUNlbnRlclswXSwgc3RhcnRZOiBzb3VyY2VDZW50ZXJbMV0sIGVuZFg6IHRhcmdldENlbnRlclswXSwgZW5kWTogdGFyZ2V0Q2VudGVyWzFdIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0gJiYgY29zZVJlc3VsdFtpbmRleF1bdGFyZ2V0LmlkKCldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWCgpLCBzdGFydFk6IGNvc2VSZXN1bHRbaW5kZXhdW3NvdXJjZS5pZCgpXS5nZXRDZW50ZXJZKCksIGVuZFg6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJYKCksIGVuZFk6IGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXS5nZXRDZW50ZXJZKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmdyYXBoLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIHN1YmdyYXBocy5wdXNoKHN1YmdyYXBoKTtcbiAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHNFdmFsdWF0ZWQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNoaWZ0UmVzdWx0ID0gbGF5VXRpbC5wYWNrQ29tcG9uZW50cyhzdWJncmFwaHMsIG9wdGlvbnMucmFuZG9taXplKS5zaGlmdHM7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1hDb29yZHMgPSByZXN1bHQueENvb3Jkcy5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgc2hpZnRSZXN1bHRbaW5kZXhdLmR4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdZQ29vcmRzID0gcmVzdWx0LnlDb29yZHMubWFwKGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geSArIHNoaWZ0UmVzdWx0W2luZGV4XS5keTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQueENvb3JkcyA9IG5ld1hDb29yZHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnlDb29yZHMgPSBuZXdZQ29vcmRzO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmZvckVhY2goZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29zZVJlc3VsdFtpbmRleF0pLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgIHZhciBub2RlUmVjdGFuZ2xlID0gY29zZVJlc3VsdFtpbmRleF1baXRlbV07XG4gICAgICAgICAgICAgICAgICBub2RlUmVjdGFuZ2xlLnNldENlbnRlcihub2RlUmVjdGFuZ2xlLmdldENlbnRlclgoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHgsIG5vZGVSZWN0YW5nbGUuZ2V0Q2VudGVyWSgpICsgc2hpZnRSZXN1bHRbX2NvdW50XS5keSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX2NvdW50Kys7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBnZXQgZWFjaCBlbGVtZW50J3MgY2FsY3VsYXRlZCBwb3NpdGlvblxuICAgICAgdmFyIGdldFBvc2l0aW9ucyA9IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhlbGUsIGkpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRlZmF1bHRcIiB8fCBvcHRpb25zLnF1YWxpdHkgPT0gXCJwcm9vZlwiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBlbGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGVsZSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwb3MgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIG5vZGUgPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRoZUlkID0gZWxlLmRhdGEoJ2lkJyk7XG4gICAgICAgICAgY29zZVJlc3VsdC5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICh0aGVJZCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgcG9zID0geyB4OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJYKCksIHk6IHJlc3VsdFt0aGVJZF0uZ2V0UmVjdCgpLmdldENlbnRlclkoKSB9O1xuICAgICAgICAgICAgICBub2RlID0gcmVzdWx0W3RoZUlkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxhYmVsV2lkdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggKz0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueCAtPSBub2RlLmxhYmVsV2lkdGggLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSArPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgICAgICAgIHBvcy55IC09IG5vZGUubGFiZWxIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPT0gdW5kZWZpbmVkKSBwb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogcG9zLngsXG4gICAgICAgICAgICB5OiBwb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3MgPSB2b2lkIDA7XG4gICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX3BvcyA9IHsgeDogcmVzdWx0LnhDb29yZHNbaW5kZXhdLCB5OiByZXN1bHQueUNvb3Jkc1tpbmRleF0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoX3BvcyA9PSB1bmRlZmluZWQpIF9wb3MgPSB7IHg6IGVsZS5wb3NpdGlvbihcInhcIiksIHk6IGVsZS5wb3NpdGlvbihcInlcIikgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeDogX3Bvcy54LFxuICAgICAgICAgICAgeTogX3Bvcy55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gcXVhbGl0eSA9IFwiZHJhZnRcIiBhbmQgcmFuZG9taXplID0gZmFsc2UgYXJlIGNvbnRyYWRpY3RpdmUgc28gaW4gdGhhdCBjYXNlIHBvc2l0aW9ucyBkb24ndCBjaGFuZ2VcbiAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIiB8fCBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgICAvLyB0cmFuc2ZlciBjYWxjdWxhdGVkIHBvc2l0aW9ucyB0byBub2RlcyAocG9zaXRpb25zIG9mIG9ubHkgc2ltcGxlIG5vZGVzIGFyZSBldmFsdWF0ZWQsIGNvbXBvdW5kcyBhcmUgcG9zaXRpb25lZCBhdXRvbWF0aWNhbGx5KVxuICAgICAgICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGF1eC5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbihjeSwgZWxlcyk7XG4gICAgICAgIHZhciBfaGlkZGVuRWxlcyA9IGVsZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUpIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmNzcygnZGlzcGxheScpID09ICdub25lJztcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuZWxlcyA9IGVsZXMubm90KF9oaWRkZW5FbGVzKTtcblxuICAgICAgICBlbGVzLm5vZGVzKCkubm90KFwiOnBhcmVudFwiKS5ub3QoX2hpZGRlbkVsZXMpLmxheW91dFBvc2l0aW9ucyhsYXlvdXQsIG9wdGlvbnMsIGdldFBvc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKHBhcmVudHNXaXRob3V0Q2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICBlbGUucG9zaXRpb24oZ2V0UG9zaXRpb25zKGVsZSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIklmIHJhbmRvbWl6ZSBvcHRpb24gaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgJ2RlZmF1bHQnIG9yICdwcm9vZicuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMYXlvdXQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3BlY3RyYWwgbGF5b3V0IHRoYXQgaXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhdXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0OCk7XG52YXIgTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTWF0cml4O1xudmFyIFNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLlNWRDtcblxuLy8gbWFpbiBmdW5jdGlvbiB0aGF0IHNwZWN0cmFsIGxheW91dCBpcyBwcm9jZXNzZWRcbnZhciBzcGVjdHJhbExheW91dCA9IGZ1bmN0aW9uIHNwZWN0cmFsTGF5b3V0KG9wdGlvbnMpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgcGFyZW50Tm9kZXMgPSBlbGVzLm5vZGVzKFwiOnBhcmVudFwiKTtcblxuICB2YXIgZHVtbXlOb2RlcyA9IG5ldyBNYXAoKTsgLy8gbWFwIHRvIGtlZXAgZHVtbXkgbm9kZXMgYW5kIHRoZWlyIG5laWdoYm9yc1xuICB2YXIgbm9kZUluZGV4ZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGluZGV4ZXMgdG8gbm9kZXNcbiAgdmFyIHBhcmVudENoaWxkTWFwID0gbmV3IE1hcCgpOyAvLyBtYXBwaW5nIGJ0dy4gY29tcG91bmQgYW5kIGl0cyByZXByZXNlbnRhdGl2ZSBub2RlIFxuICB2YXIgYWxsTm9kZXNOZWlnaGJvcmhvb2QgPSBbXTsgLy8gYXJyYXkgdG8ga2VlcCBuZWlnaGJvcmhvb2Qgb2YgYWxsIG5vZGVzXG4gIHZhciB4Q29vcmRzID0gW107XG4gIHZhciB5Q29vcmRzID0gW107XG5cbiAgdmFyIHNhbXBsZXNDb2x1bW4gPSBbXTsgLy8gc2FtcGxlZCB2ZXJ0aWNlc1xuICB2YXIgbWluRGlzdGFuY2VzQ29sdW1uID0gW107XG4gIHZhciBDID0gW107IC8vIGNvbHVtbiBzYW1wbGluZyBtYXRyaXhcbiAgdmFyIFBISSA9IFtdOyAvLyBpbnRlcnNlY3Rpb24gb2YgY29sdW1uIGFuZCByb3cgc2FtcGxpbmcgbWF0cmljZXMgXG4gIHZhciBJTlYgPSBbXTsgLy8gaW52ZXJzZSBvZiBQSEkgXG5cbiAgdmFyIGZpcnN0U2FtcGxlID0gdm9pZCAwOyAvLyB0aGUgZmlyc3Qgc2FtcGxlZCBub2RlXG4gIHZhciBub2RlU2l6ZSA9IHZvaWQgMDtcblxuICB2YXIgaW5maW5pdHkgPSAxMDAwMDAwMDA7XG4gIHZhciBzbWFsbCA9IDAuMDAwMDAwMDAxO1xuXG4gIHZhciBwaVRvbCA9IG9wdGlvbnMucGlUb2w7XG4gIHZhciBzYW1wbGluZ1R5cGUgPSBvcHRpb25zLnNhbXBsaW5nVHlwZTsgLy8gZmFsc2UgZm9yIHJhbmRvbSwgdHJ1ZSBmb3IgZ3JlZWR5XG4gIHZhciBub2RlU2VwYXJhdGlvbiA9IG9wdGlvbnMubm9kZVNlcGFyYXRpb247XG4gIHZhciBzYW1wbGVTaXplID0gdm9pZCAwO1xuXG4gIC8qKioqIFNwZWN0cmFsLXByZXByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgLyoqKiogU3BlY3RyYWwgbGF5b3V0IGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8vIGRldGVybWluZSB3aGljaCBjb2x1bW5zIHRvIGJlIHNhbXBsZWRcbiAgdmFyIHJhbmRvbVNhbXBsZUNSID0gZnVuY3Rpb24gcmFuZG9tU2FtcGxlQ1IoKSB7XG4gICAgdmFyIHNhbXBsZSA9IDA7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgZmxhZyA9IGZhbHNlO1xuXG4gICAgd2hpbGUgKGNvdW50IDwgc2FtcGxlU2l6ZSkge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuXG4gICAgICBmbGFnID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKHNhbXBsZXNDb2x1bW5baV0gPT0gc2FtcGxlKSB7XG4gICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFmbGFnKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bY291bnRdID0gc2FtcGxlO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHRha2VzIHRoZSBpbmRleCBvZiB0aGUgbm9kZShwaXZvdCkgdG8gaW5pdGlhdGUgQkZTIGFzIGEgcGFyYW1ldGVyXG4gIHZhciBCRlMgPSBmdW5jdGlvbiBCRlMocGl2b3QsIGluZGV4LCBzYW1wbGluZ01ldGhvZCkge1xuICAgIHZhciBwYXRoID0gW107IC8vIHRoZSBmcm9udCBvZiB0aGUgcGF0aFxuICAgIHZhciBmcm9udCA9IDA7IC8vIHRoZSBiYWNrIG9mIHRoZSBwYXRoXG4gICAgdmFyIGJhY2sgPSAwO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgdGVtcCA9IHZvaWQgMDtcbiAgICB2YXIgZGlzdGFuY2UgPSBbXTtcblxuICAgIHZhciBtYXhfZGlzdCA9IDA7IC8vIHRoZSBmdXJ0aGVzdCBub2RlIHRvIGJlIHJldHVybmVkXG4gICAgdmFyIG1heF9pbmQgPSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBkaXN0YW5jZVtpXSA9IGluZmluaXR5O1xuICAgIH1cblxuICAgIHBhdGhbYmFja10gPSBwaXZvdDtcbiAgICBkaXN0YW5jZVtwaXZvdF0gPSAwO1xuXG4gICAgd2hpbGUgKGJhY2sgPj0gZnJvbnQpIHtcbiAgICAgIGN1cnJlbnQgPSBwYXRoW2Zyb250KytdO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGFsbE5vZGVzTmVpZ2hib3Job29kW2N1cnJlbnRdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5laWdoYm9ycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdGVtcCA9IG5vZGVJbmRleGVzLmdldChuZWlnaGJvcnNbX2ldKTtcbiAgICAgICAgaWYgKGRpc3RhbmNlW3RlbXBdID09IGluZmluaXR5KSB7XG4gICAgICAgICAgZGlzdGFuY2VbdGVtcF0gPSBkaXN0YW5jZVtjdXJyZW50XSArIDE7XG4gICAgICAgICAgcGF0aFsrK2JhY2tdID0gdGVtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgQ1tjdXJyZW50XVtpbmRleF0gPSBkaXN0YW5jZVtjdXJyZW50XSAqIG5vZGVTZXBhcmF0aW9uO1xuICAgIH1cblxuICAgIGlmIChzYW1wbGluZ01ldGhvZCkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZVNpemU7IF9pMisrKSB7XG4gICAgICAgIGlmIChDW19pMl1baW5kZXhdIDwgbWluRGlzdGFuY2VzQ29sdW1uW19pMl0pIG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdID0gQ1tfaTJdW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZVNpemU7IF9pMysrKSB7XG4gICAgICAgIGlmIChtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXSA+IG1heF9kaXN0KSB7XG4gICAgICAgICAgbWF4X2Rpc3QgPSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kzXTtcbiAgICAgICAgICBtYXhfaW5kID0gX2kzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhfaW5kO1xuICB9O1xuXG4gIC8vIGFwcGx5IEJGUyB0byBhbGwgbm9kZXMgb3Igc2VsZWN0ZWQgc2FtcGxlc1xuICB2YXIgYWxsQkZTID0gZnVuY3Rpb24gYWxsQkZTKHNhbXBsaW5nTWV0aG9kKSB7XG5cbiAgICB2YXIgc2FtcGxlID0gdm9pZCAwO1xuXG4gICAgaWYgKCFzYW1wbGluZ01ldGhvZCkge1xuICAgICAgcmFuZG9tU2FtcGxlQ1IoKTtcblxuICAgICAgLy8gY2FsbCBCRlNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICAgIEJGUyhzYW1wbGVzQ29sdW1uW2ldLCBpLCBzYW1wbGluZ01ldGhvZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzYW1wbGUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBub2RlU2l6ZSk7XG4gICAgICBmaXJzdFNhbXBsZSA9IHNhbXBsZTtcblxuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgbm9kZVNpemU7IF9pNCsrKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlc0NvbHVtbltfaTRdID0gaW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IHNhbXBsZVNpemU7IF9pNSsrKSB7XG4gICAgICAgIHNhbXBsZXNDb2x1bW5bX2k1XSA9IHNhbXBsZTtcbiAgICAgICAgc2FtcGxlID0gQkZTKHNhbXBsZSwgX2k1LCBzYW1wbGluZ01ldGhvZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSB0aGUgc3F1YXJlZCBkaXN0YW5jZXMgZm9yIENcbiAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBub2RlU2l6ZTsgX2k2KyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIENbX2k2XVtqXSAqPSBDW19pNl1bal07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9ybSBQSElcbiAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzYW1wbGVTaXplOyBfaTcrKykge1xuICAgICAgUEhJW19pN10gPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBzYW1wbGVTaXplOyBfaTgrKykge1xuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHNhbXBsZVNpemU7IF9qKyspIHtcbiAgICAgICAgUEhJW19pOF1bX2pdID0gQ1tzYW1wbGVzQ29sdW1uW19qXV1bX2k4XTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcGVyZm9ybSB0aGUgU1ZEIGFsZ29yaXRobSBhbmQgYXBwbHkgYSByZWd1bGFyaXphdGlvbiBzdGVwXG4gIHZhciBzYW1wbGUgPSBmdW5jdGlvbiBzYW1wbGUoKSB7XG5cbiAgICB2YXIgU1ZEUmVzdWx0ID0gU1ZELnN2ZChQSEkpO1xuXG4gICAgdmFyIGFfcSA9IFNWRFJlc3VsdC5TO1xuICAgIHZhciBhX3UgPSBTVkRSZXN1bHQuVTtcbiAgICB2YXIgYV92ID0gU1ZEUmVzdWx0LlY7XG5cbiAgICB2YXIgbWF4X3MgPSBhX3FbMF0gKiBhX3FbMF0gKiBhX3FbMF07XG5cbiAgICB2YXIgYV9TaWcgPSBbXTtcblxuICAgIC8vICByZWd1bGFyaXphdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2FtcGxlU2l6ZTsgaSsrKSB7XG4gICAgICBhX1NpZ1tpXSA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzYW1wbGVTaXplOyBqKyspIHtcbiAgICAgICAgYV9TaWdbaV1bal0gPSAwO1xuICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgYV9TaWdbaV1bal0gPSBhX3FbaV0gLyAoYV9xW2ldICogYV9xW2ldICsgbWF4X3MgLyAoYV9xW2ldICogYV9xW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBJTlYgPSBNYXRyaXgubXVsdE1hdChNYXRyaXgubXVsdE1hdChhX3YsIGFfU2lnKSwgTWF0cml4LnRyYW5zcG9zZShhX3UpKTtcbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgZmluYWwgY29vcmRpbmF0ZXMgXG4gIHZhciBwb3dlckl0ZXJhdGlvbiA9IGZ1bmN0aW9uIHBvd2VySXRlcmF0aW9uKCkge1xuICAgIC8vIHR3byBsYXJnZXN0IGVpZ2VudmFsdWVzXG4gICAgdmFyIHRoZXRhMSA9IHZvaWQgMDtcbiAgICB2YXIgdGhldGEyID0gdm9pZCAwO1xuXG4gICAgLy8gaW5pdGlhbCBndWVzc2VzIGZvciBlaWdlbnZlY3RvcnNcbiAgICB2YXIgWTEgPSBbXTtcbiAgICB2YXIgWTIgPSBbXTtcblxuICAgIHZhciBWMSA9IFtdO1xuICAgIHZhciBWMiA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlU2l6ZTsgaSsrKSB7XG4gICAgICBZMVtpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgICBZMltpXSA9IE1hdGgucmFuZG9tKCk7XG4gICAgfVxuXG4gICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcbiAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICAvLyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbXByb3ZlbWVudCByYXRpbyBpbiBwb3dlciBpdGVyYXRpb25cbiAgICB2YXIgY3VycmVudCA9IHNtYWxsO1xuICAgIHZhciBwcmV2aW91cyA9IHNtYWxsO1xuXG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY291bnQrKztcblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgbm9kZVNpemU7IF9pOSsrKSB7XG4gICAgICAgIFYxW19pOV0gPSBZMVtfaTldO1xuICAgICAgfVxuXG4gICAgICBZMSA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjEpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMSA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG4gICAgICBZMSA9IE1hdHJpeC5ub3JtYWxpemUoWTEpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjEsIFkxKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IG5vZGVTaXplOyBfaTEwKyspIHtcbiAgICAgIFYxW19pMTBdID0gWTFbX2kxMF07XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZpb3VzID0gc21hbGw7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pMTEgPSAwOyBfaTExIDwgbm9kZVNpemU7IF9pMTErKykge1xuICAgICAgICBWMltfaTExXSA9IFkyW19pMTFdO1xuICAgICAgfVxuXG4gICAgICBWMiA9IE1hdHJpeC5taW51c09wKFYyLCBNYXRyaXgubXVsdENvbnMoVjEsIE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBWMikpKTtcbiAgICAgIFkyID0gTWF0cml4Lm11bHRHYW1tYShNYXRyaXgubXVsdEwoTWF0cml4Lm11bHRHYW1tYShWMiksIEMsIElOVikpO1xuICAgICAgdGhldGEyID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcbiAgICAgIFkyID0gTWF0cml4Lm5vcm1hbGl6ZShZMik7XG5cbiAgICAgIGN1cnJlbnQgPSBNYXRyaXguZG90UHJvZHVjdChWMiwgWTIpO1xuXG4gICAgICB0ZW1wID0gTWF0aC5hYnMoY3VycmVudCAvIHByZXZpb3VzKTtcblxuICAgICAgaWYgKHRlbXAgPD0gMSArIHBpVG9sICYmIHRlbXAgPj0gMSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgbm9kZVNpemU7IF9pMTIrKykge1xuICAgICAgVjJbX2kxMl0gPSBZMltfaTEyXTtcbiAgICB9XG5cbiAgICAvLyB0aGV0YTEgbm93IGNvbnRhaW5zIGRvbWluYW50IGVpZ2VudmFsdWVcbiAgICAvLyB0aGV0YTIgbm93IGNvbnRhaW5zIHRoZSBzZWNvbmQtbGFyZ2VzdCBlaWdlbnZhbHVlXG4gICAgLy8gVjEgbm93IGNvbnRhaW5zIHRoZXRhMSdzIGVpZ2VudmVjdG9yXG4gICAgLy8gVjIgbm93IGNvbnRhaW5zIHRoZXRhMidzIGVpZ2VudmVjdG9yXG5cbiAgICAvL3BvcHVsYXRlIHRoZSB0d28gdmVjdG9yc1xuICAgIHhDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjEsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTEpKSk7XG4gICAgeUNvb3JkcyA9IE1hdHJpeC5tdWx0Q29ucyhWMiwgTWF0aC5zcXJ0KE1hdGguYWJzKHRoZXRhMikpKTtcbiAgfTtcblxuICAvKioqKiBQcmVwYXJhdGlvbiBmb3Igc3BlY3RyYWwgbGF5b3V0IChQcmVwcm9jZXNzaW5nKSAqKioqL1xuXG4gIC8vIGNvbm5lY3QgZGlzY29ubmVjdGVkIGNvbXBvbmVudHMgKGZpcnN0IHRvcCBsZXZlbCwgdGhlbiBpbnNpZGUgb2YgZWFjaCBjb21wb3VuZCBub2RlKVxuICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMobm9kZXMpLCBkdW1teU5vZGVzKTtcblxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIGVsZXMsIGF1eC5nZXRUb3BNb3N0Tm9kZXMoZWxlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKSwgZHVtbXlOb2Rlcyk7XG4gIH0pO1xuXG4gIC8vIGFzc2lnbiBpbmRleGVzIHRvIG5vZGVzIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFub2Rlc1tpXS5pc1BhcmVudCgpKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZXNbaV0uaWQoKSwgaW5kZXgrKyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIG5vZGVJbmRleGVzLnNldChrZXksIGluZGV4KyspO1xuICAgIH1cblxuICAgIC8vIGluc3RhbnRpYXRlIHRoZSBuZWlnaGJvcmhvb2QgbWF0cml4XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX2kxMyA9IDA7IF9pMTMgPCBub2RlSW5kZXhlcy5zaXplOyBfaTEzKyspIHtcbiAgICBhbGxOb2Rlc05laWdoYm9yaG9vZFtfaTEzXSA9IFtdO1xuICB9XG5cbiAgLy8gZm9ybSBhIHBhcmVudC1jaGlsZCBtYXAgdG8ga2VlcCByZXByZXNlbnRhdGl2ZSBub2RlIG9mIGVhY2ggY29tcG91bmQgbm9kZSAgXG4gIHBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGVsZS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcblxuICAgIC8vICAgICAgbGV0IHJhbmRvbSA9IDA7XG4gICAgd2hpbGUgKGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5sZW5ndGggPT0gMCkge1xuICAgICAgLy8gICAgICAgIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoaWxkcmVuLm5vZGVzKCkubGVuZ3RoKTsgLy8gaWYgYWxsIGNoaWxkcmVuIGFyZSBjb21wb3VuZCB0aGVuIHByb2NlZWQgcmFuZG9tbHlcbiAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW4ubm9kZXMoKVswXS5jaGlsZHJlbigpLmludGVyc2VjdGlvbihlbGVzKTtcbiAgICB9XG4gICAgLy8gIHNlbGVjdCB0aGUgcmVwcmVzZW50YXRpdmUgbm9kZSAtIHdlIGNhbiBhcHBseSBkaWZmZXJlbnQgbWV0aG9kcyBoZXJlXG4gICAgLy8gICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBtaW4gPSBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbMF0uY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmZvckVhY2goZnVuY3Rpb24gKGVsZTIsIGkpIHtcbiAgICAgIGlmIChlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGVsZTIuY29ubmVjdGVkRWRnZXMoKS5sZW5ndGg7XG4gICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwYXJlbnRDaGlsZE1hcC5zZXQoZWxlLmlkKCksIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKVtpbmRleF0uaWQoKSk7XG4gIH0pO1xuXG4gIC8vIGFkZCBuZWlnaGJvcmhvb2QgcmVsYXRpb25zIChmaXJzdCByZWFsLCB0aGVuIGR1bW15IG5vZGVzKVxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgZWxlSW5kZXggPSB2b2lkIDA7XG5cbiAgICBpZiAoZWxlLmlzUGFyZW50KCkpIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KHBhcmVudENoaWxkTWFwLmdldChlbGUuaWQoKSkpO2Vsc2UgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoZWxlLmlkKCkpO1xuXG4gICAgZWxlLm5laWdoYm9yaG9vZCgpLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGVsZS5lZGdlc1dpdGgobm9kZSkpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKG5vZGUuaXNQYXJlbnQoKSkgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gocGFyZW50Q2hpbGRNYXAuZ2V0KG5vZGUuaWQoKSkpO2Vsc2UgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2gobm9kZS5pZCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2tleSkge1xuICAgIHZhciBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChfa2V5KTtcbiAgICB2YXIgZGlzY29ubmVjdGVkSWQgPSB2b2lkIDA7XG4gICAgZHVtbXlOb2Rlcy5nZXQoX2tleSkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChjeS5nZXRFbGVtZW50QnlJZChpZCkuaXNQYXJlbnQoKSkgZGlzY29ubmVjdGVkSWQgPSBwYXJlbnRDaGlsZE1hcC5nZXQoaWQpO2Vsc2UgZGlzY29ubmVjdGVkSWQgPSBpZDtcblxuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbZWxlSW5kZXhdLnB1c2goZGlzY29ubmVjdGVkSWQpO1xuICAgICAgYWxsTm9kZXNOZWlnaGJvcmhvb2Rbbm9kZUluZGV4ZXMuZ2V0KGRpc2Nvbm5lY3RlZElkKV0ucHVzaChfa2V5KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvcjIgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gZHVtbXlOb2Rlcy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWUpIHtcbiAgICAgIHZhciBfa2V5ID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICBfbG9vcChfa2V5KTtcbiAgICB9XG5cbiAgICAvLyBub2RlU2l6ZSBub3cgb25seSBjb25zaWRlcnMgdGhlIHNpemUgb2YgdHJhbnNmb3JtZWQgZ3JhcGhcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yMikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbm9kZVNpemUgPSBub2RlSW5kZXhlcy5zaXplO1xuXG4gIHZhciBzcGVjdHJhbFJlc3VsdCA9IHZvaWQgMDtcblxuICAvLyBJZiBudW1iZXIgb2Ygbm9kZXMgaW4gdHJhbnNmb3JtZWQgZ3JhcGggaXMgMSBvciAyLCBlaXRoZXIgU1ZEIG9yIHBvd2VySXRlcmF0aW9uIGNhdXNlcyBwcm9ibGVtXG4gIC8vIFNvIHNraXAgc3BlY3RyYWwgYW5kIGxheW91dCB0aGUgZ3JhcGggd2l0aCBjb3NlXG4gIGlmIChub2RlU2l6ZSA+IDIpIHtcbiAgICAvLyBpZiAjIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIHNtYWxsZXIgdGhhbiBzYW1wbGUgc2l6ZSxcbiAgICAvLyB0aGVuIHVzZSAjIG9mIG5vZGVzIGFzIHNhbXBsZSBzaXplXG4gICAgc2FtcGxlU2l6ZSA9IG5vZGVTaXplIDwgb3B0aW9ucy5zYW1wbGVTaXplID8gbm9kZVNpemUgOiBvcHRpb25zLnNhbXBsZVNpemU7XG5cbiAgICAvLyBpbnN0YW50aWF0ZXMgdGhlIHBhcnRpYWwgbWF0cmljZXMgdGhhdCB3aWxsIGJlIHVzZWQgaW4gc3BlY3RyYWwgbGF5b3V0XG4gICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBub2RlU2l6ZTsgX2kxNCsrKSB7XG4gICAgICBDW19pMTRdID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIF9pMTUgPSAwOyBfaTE1IDwgc2FtcGxlU2l6ZTsgX2kxNSsrKSB7XG4gICAgICBJTlZbX2kxNV0gPSBbXTtcbiAgICB9XG5cbiAgICAvKioqKiBBcHBseSBzcGVjdHJhbCBsYXlvdXQgKioqKi9cblxuICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiIHx8IG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgICBhbGxCRlMoc2FtcGxpbmdUeXBlKTtcbiAgICAgIHNhbXBsZSgpO1xuICAgICAgcG93ZXJJdGVyYXRpb24oKTtcblxuICAgICAgc3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogeENvb3JkcywgeUNvb3JkczogeUNvb3JkcyB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlSW5kZXhlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICAgIHhDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieFwiKSk7XG4gICAgICAgIHlDb29yZHMucHVzaChjeS5nZXRFbGVtZW50QnlJZChrZXkpLnBvc2l0aW9uKFwieVwiKSk7XG4gICAgICB9KTtcbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvciA9IG5vZGVJbmRleGVzLmtleXMoKTtcbiAgICB2YXIgZmlyc3ROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICB2YXIgZmlyc3ROb2RlUG9zID0gZmlyc3ROb2RlLnBvc2l0aW9uKCk7XG4gICAgdmFyIGZpcnN0Tm9kZVdpZHRoID0gZmlyc3ROb2RlLm91dGVyV2lkdGgoKTtcbiAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLngpO1xuICAgIHlDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueSk7XG4gICAgaWYgKG5vZGVTaXplID09IDIpIHtcbiAgICAgIHZhciBzZWNvbmROb2RlID0gY3kuZ2V0RWxlbWVudEJ5SWQoaXRlcmF0b3IubmV4dCgpLnZhbHVlKTtcbiAgICAgIHZhciBzZWNvbmROb2RlV2lkdGggPSBzZWNvbmROb2RlLm91dGVyV2lkdGgoKTtcbiAgICAgIHhDb29yZHMucHVzaChmaXJzdE5vZGVQb3MueCArIGZpcnN0Tm9kZVdpZHRoIC8gMiArIHNlY29uZE5vZGVXaWR0aCAvIDIgKyBvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCk7XG4gICAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIH1cblxuICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICByZXR1cm4gc3BlY3RyYWxSZXN1bHQ7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBzcGVjdHJhbExheW91dDogc3BlY3RyYWxMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBpbXBsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTIpO1xuXG4vLyByZWdpc3RlcnMgdGhlIGV4dGVuc2lvbiBvbiBhIGN5dG9zY2FwZSBsaWIgcmVmXG52YXIgcmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihjeXRvc2NhcGUpIHtcbiAgaWYgKCFjeXRvc2NhcGUpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gY2FuJ3QgcmVnaXN0ZXIgaWYgY3l0b3NjYXBlIHVuc3BlY2lmaWVkXG5cbiAgY3l0b3NjYXBlKCdsYXlvdXQnLCAnZmNvc2UnLCBpbXBsKTsgLy8gcmVnaXN0ZXIgd2l0aCBjeXRvc2NhcGUuanNcbn07XG5cbmlmICh0eXBlb2YgY3l0b3NjYXBlICE9PSAndW5kZWZpbmVkJykge1xuICAvLyBleHBvc2UgdG8gZ2xvYmFsIGN5dG9zY2FwZSAoaS5lLiB3aW5kb3cuY3l0b3NjYXBlKVxuICByZWdpc3RlcihjeXRvc2NhcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZ2lzdGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18xNDBfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzkpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26527\n')},41709:function(module,__unused_webpack_exports,__webpack_require__){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(1917));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t"use strict";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_630__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_630__(551);\ncoseBase.CoSEConstants = __nested_webpack_require_630__(806);\ncoseBase.CoSEEdge = __nested_webpack_require_630__(767);\ncoseBase.CoSEGraph = __nested_webpack_require_630__(880);\ncoseBase.CoSEGraphManager = __nested_webpack_require_630__(578);\ncoseBase.CoSELayout = __nested_webpack_require_630__(765);\ncoseBase.CoSENode = __nested_webpack_require_630__(991);\ncoseBase.ConstraintHandler = __nested_webpack_require_630__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1167__) => {\n\n\n\nvar FDLayoutConstants = __nested_webpack_require_1167__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2468__) => {\n\n\n\nvar FDLayoutEdge = __nested_webpack_require_2468__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2879__) => {\n\n\n\nvar LGraph = __nested_webpack_require_2879__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3264__) => {\n\n\n\nvar LGraphManager = __nested_webpack_require_3264__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3683__) => {\n\n\n\nvar FDLayout = __nested_webpack_require_3683__(551).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_3683__(578);\nvar CoSEGraph = __nested_webpack_require_3683__(880);\nvar CoSENode = __nested_webpack_require_3683__(991);\nvar CoSEEdge = __nested_webpack_require_3683__(767);\nvar CoSEConstants = __nested_webpack_require_3683__(806);\nvar ConstraintHandler = __nested_webpack_require_3683__(902);\nvar FDLayoutConstants = __nested_webpack_require_3683__(551).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_3683__(551).LayoutConstants;\nvar Point = __nested_webpack_require_3683__(551).Point;\nvar PointD = __nested_webpack_require_3683__(551).PointD;\nvar DimensionD = __nested_webpack_require_3683__(551).DimensionD;\nvar Layout = __nested_webpack_require_3683__(551).Layout;\nvar Integer = __nested_webpack_require_3683__(551).Integer;\nvar IGeometry = __nested_webpack_require_3683__(551).IGeometry;\nvar LGraph = __nested_webpack_require_3683__(551).LGraph;\nvar Transform = __nested_webpack_require_3683__(551).Transform;\nvar LinkedList = __nested_webpack_require_3683__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - "draft"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - "default"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is \'during\' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === \'during\') {\n    this.emit(\'layoutstarted\');\n  } else {\n    // If aminate option is \'during\' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set("dummy" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, "dummy" + i);\n            self.dummyToNodeForVerticalAlignment.get("dummy" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add("dummy" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set("dummy" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, "dummy" + i);\n            self.dummyToNodeForHorizontalAlignment.get("dummy" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add("dummy" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don\'t back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id\'s\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === "undefined") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = "DummyCompound_" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == "left") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == "center" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == "right") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == "top") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == "center" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == "bottom") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == "left") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == "center" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == "right") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == "top") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == "center" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == "bottom") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_74190__) => {\n\n\n\nvar FDLayoutNode = __nested_webpack_require_74190__(551).FDLayoutNode;\nvar IMath = __nested_webpack_require_74190__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_77514__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __nested_webpack_require_77514__(806);\nvar LinkedList = __nested_webpack_require_77514__(551).LinkedList;\nvar Matrix = __nested_webpack_require_77514__(551).Matrix;\nvar SVD = __nested_webpack_require_77514__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: "horizontal" or "vertical", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == "horizontal") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == "horizontal") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == "horizontal") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == "horizontal") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == "horizontal") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn\'t sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, \'reflectOnX\', \'reflectOnY\' or \'reflectOnBoth\' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: "horizontal" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: "horizontal" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: "vertical" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: "vertical" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn\'t dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == "horizontal") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, "horizontal");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, "vertical");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A\'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B\'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A\'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A\'B) = USV\', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU\'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set("dummy" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, "dummy" + _i11);\n                dummyToNodeForVerticalAlignment.get("dummy" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add("dummy" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set("dummy" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set("dummy" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, "dummy" + _i12);\n                dummyToNodeForHorizontalAlignment.get("dummy" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add("dummy" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set("dummy" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent["direction"] == "horizontal") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, "horizontal", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, "vertical", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_117795__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_117795__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can\'t be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_117795__(45);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE3MDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLElBQXlEO0FBQzdELDJCQUEyQixtQkFBTyxDQUFDLElBQWE7QUFDaEQsTUFBTSxFQUsyQztBQUNqRCxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsOEJBQW1COzs7O0FBSTdEOztBQUVBLHNCQUFzQiw4QkFBbUI7QUFDekMseUJBQXlCLDhCQUFtQjtBQUM1QyxvQkFBb0IsOEJBQW1CO0FBQ3ZDLHFCQUFxQiw4QkFBbUI7QUFDeEMsNEJBQTRCLDhCQUFtQjtBQUMvQyxzQkFBc0IsOEJBQW1CO0FBQ3pDLG9CQUFvQiw4QkFBbUI7QUFDdkMsNkJBQTZCLDhCQUFtQjs7QUFFaEQ7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0Qsd0JBQXdCLCtCQUFtQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELG1CQUFtQiwrQkFBbUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7OztBQUk3RCxhQUFhLCtCQUFtQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELG9CQUFvQiwrQkFBbUI7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7OztBQUk3RCxlQUFlLCtCQUFtQjtBQUNsQyx1QkFBdUIsK0JBQW1CO0FBQzFDLGdCQUFnQiwrQkFBbUI7QUFDbkMsZUFBZSwrQkFBbUI7QUFDbEMsZUFBZSwrQkFBbUI7QUFDbEMsb0JBQW9CLCtCQUFtQjtBQUN2Qyx3QkFBd0IsK0JBQW1CO0FBQzNDLHdCQUF3QiwrQkFBbUI7QUFDM0Msc0JBQXNCLCtCQUFtQjtBQUN6QyxZQUFZLCtCQUFtQjtBQUMvQixhQUFhLCtCQUFtQjtBQUNoQyxpQkFBaUIsK0JBQW1CO0FBQ3BDLGFBQWEsK0JBQW1CO0FBQ2hDLGNBQWMsK0JBQW1CO0FBQ2pDLGdCQUFnQiwrQkFBbUI7QUFDbkMsYUFBYSwrQkFBbUI7QUFDaEMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxpQkFBaUIsK0JBQW1COztBQUVwQztBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LO0FBQ25LO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhCQUE4QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUEsNEVBQTRFLHlDQUF5QztBQUNySCw2RUFBNkUsdUNBQXVDO0FBQ3BILFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMkNBQTJDO0FBQ3BILDRFQUE0RSxxQ0FBcUM7QUFDakg7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLDRDQUE0QztBQUM1QywwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQ0FBa0M7QUFDeEQ7QUFDQSx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFDQUFxQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0NBQW9DO0FBQzFEO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1Q0FBdUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sc0JBQXNCLHdDQUF3QztBQUM5RDtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwwQkFBMEI7QUFDMUIsMkJBQTJCOztBQUUzQix1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6Qyw4QkFBOEI7QUFDOUIsb0NBQW9DOztBQUVwQzs7QUFFQSxrRUFBa0U7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELG1FQUFtRTs7QUFFbkUsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsbUNBQW1DO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQiwrQkFBK0I7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3Qzs7QUFFeEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDOztBQUVBLHdCQUF3QjtBQUN4Qix3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGtCQUFr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QUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUZBQXlGLG1FQUFtRTtBQUM1Sjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVGQUF1RixtRUFBbUU7QUFDMUo7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQix3QkFBd0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQSxPQUFPOztBQUVQLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpQ0FBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUFtQixHQUFHLGlDQUFtQjtBQUN2RDtBQUNBLGlCQUFpQiwwQkFBbUI7QUFDcEMsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzPzIzMGYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU1MV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA0NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpO1xuY29zZUJhc2UuQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbmNvc2VCYXNlLkNvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xuY29zZUJhc2UuQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbmNvc2VCYXNlLkNvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NSk7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkxKTtcbmNvc2VCYXNlLkNvbnN0cmFpbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvc2VCYXNlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gdHJ1ZTsgLy8gdGhpcyBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIGlmIHRoZXJlIHdpbGwgYmUgYSBjb25zdHJhaW50XG4vLyBUaGlzIGNvbnN0YW50IGlzIGZvciBkaWZmZXJlbnRpYXRpbmcgd2hldGhlciBhY3R1YWwgbGF5b3V0IGFsZ29yaXRobSB0aGF0IHVzZXMgY29zZS1iYXNlIHdhbnRzIHRvIGFwcGx5IG9ubHkgaW5jcmVtZW50YWwgbGF5b3V0IG9yIFxuLy8gYW4gaW5jcmVtZW50YWwgbGF5b3V0IG9uIHRvcCBvZiBhIHJhbmRvbWl6ZWQgbGF5b3V0LiBJZiBpdCBpcyBvbmx5IGluY3JlbWVudGFsIGxheW91dCwgdGhlbiB0aGlzIGNvbnN0YW50IHNob3VsZCBiZSB0cnVlLlxuQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTEdyYXBoO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGgocGFyZW50LCBncmFwaE1nciwgdkdyYXBoKSB7XG4gIExHcmFwaC5jYWxsKHRoaXMsIHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCk7XG59XG5cbkNvU0VHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGgpIHtcbiAgQ29TRUdyYXBoW3Byb3BdID0gTEdyYXBoW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaE1hbmFnZXI7XG5cbmZ1bmN0aW9uIENvU0VHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaE1hbmFnZXIuY2FsbCh0aGlzLCBsYXlvdXQpO1xufVxuXG5Db1NFR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoTWFuYWdlci5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhNYW5hZ2VyKSB7XG4gIENvU0VHcmFwaE1hbmFnZXJbcHJvcF0gPSBMR3JhcGhNYW5hZ2VyW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXQ7XG52YXIgQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4MCk7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG52YXIgQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2Nyk7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbnZhciBDb25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlBvaW50O1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5EaW1lbnNpb25EO1xudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MYXlvdXQ7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JR2VvbWV0cnk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuVHJhbnNmb3JtO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcblxuZnVuY3Rpb24gQ29TRUxheW91dCgpIHtcbiAgRkRMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvQmVUaWxlZCA9IHt9OyAvLyBNZW1vcml6ZSBpZiBhIG5vZGUgaXMgdG8gYmUgdGlsZWQgb3IgaXMgdGlsZWRcbiAgdGhpcy5jb25zdHJhaW50cyA9IHt9OyAvLyBrZWVwIGxheW91dCBjb25zdHJhaW50c1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRyZWUgcmVkdWN0aW9uIHN1cHBvcnRcbiAgICB0aGlzLnBydW5lZE5vZGVzQWxsID0gW107XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzR3Jvd3RoRmluaXNoZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLy8gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgQ29TRSByZWxhdGVkIHBhcmFtZXRlcnMgdXNlZCBieSBzcHJpbmcgZW1iZWRkZXIuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIEZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIuY2FsbCh0aGlzKTtcblxuICAvLyB2YXJpYWJsZXMgZm9yIGNvb2xpbmdcbiAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICB0aGlzLm1heENvb2xpbmdDeWNsZSA9IHRoaXMubWF4SXRlcmF0aW9ucyAvIEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRDtcbiAgdGhpcy5maW5hbFRlbXBlcmF0dXJlID0gMC4wNDtcbiAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSAxO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIGlmIChjcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzKCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHJldHVybiB0aGlzLmNsYXNzaWNMYXlvdXQoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsYXNzaWNMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubm9kZXNXaXRoR3Jhdml0eSA9IHRoaXMuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbih0aGlzLm5vZGVzV2l0aEdyYXZpdHkpO1xuICB0aGlzLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB0aGlzLmNhbGNJZGVhbEVkZ2VMZW5ndGhzKCk7XG5cbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdmFyIGZvcmVzdCA9IHRoaXMuZ2V0RmxhdEZvcmVzdCgpO1xuXG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBmbGF0IGFuZCBhIGZvcmVzdFxuICAgIGlmIChmb3Jlc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFkaWFsbHkoZm9yZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBub3QgZmxhdCBvciBhIGZvcmVzdFxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIHdoZW4gaW5jcmVtZW50YWwgbW9kZSBpcyBub3QgZW5hYmxlZCBhbmQgZ3JhcGggaXMgbm90IGEgZm9yZXN0IFxuICAgICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KCk7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwpIHtcbiAgICAgIC8vIFJlZHVjZSB0aGUgdHJlZXMgaW4gaW5jcmVtZW50YWwgbW9kZSBpZiBvbmx5IHRoaXMgY29uc3RhbnQgaXMgc2V0IHRvIHRydWUgXG4gICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIENvbnN0cmFpbnRIYW5kbGVyLmhhbmRsZUNvbnN0cmFpbnRzKHRoaXMpO1xuICAgIHRoaXMuaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMoKTtcbiAgfVxuXG4gIHRoaXMuaW5pdFNwcmluZ0VtYmVkZGVyKCk7XG4gIGlmIChDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCkge1xuICAgIHRoaXMucnVuU3ByaW5nRW1iZWRkZXIoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMjtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMrKztcbiAgfVxuICAvLyBPcGVyYXRpb25zIGFmdGVyIGdyb3d0aCBpcyBmaW5pc2hlZFxuICBpZiAodGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwpIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgLyAyICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO2Vsc2UgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucysrO1xuICB9XG5cbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzVHJlZUdyb3dpbmcgfHwgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNHcm93dGhGaW5pc2hlZDtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMDtcbiAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIHRoaXMuY2FsY1NwcmluZ0ZvcmNlcygpO1xuICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZXMoZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzKCk7XG4gIHRoaXMubW92ZU5vZGVzKCk7XG4gIHRoaXMuYW5pbWF0ZSgpO1xuXG4gIHJldHVybiBmYWxzZTsgLy8gTGF5b3V0IGlzIG5vdCBlbmRlZCB5ZXQgcmV0dXJuIGZhbHNlXG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRQb3NpdGlvbnNEYXRhID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICB2YXIgcERhdGEgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWN0ID0gYWxsTm9kZXNbaV0ucmVjdDtcbiAgICB2YXIgaWQgPSBhbGxOb2Rlc1tpXS5pZDtcbiAgICBwRGF0YVtpZF0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICB4OiByZWN0LmdldENlbnRlclgoKSxcbiAgICAgIHk6IHJlY3QuZ2V0Q2VudGVyWSgpLFxuICAgICAgdzogcmVjdC53aWR0aCxcbiAgICAgIGg6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBwRGF0YTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJ1blNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgPSAyNTtcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2Q7XG4gIHZhciBsYXlvdXRFbmRlZCA9IGZhbHNlO1xuXG4gIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHNpZ25hbCB0aGF0IGxheW91dCBpcyBzdXBwb3NlZCB0byBzdGFydCBpdGVyYXRpbmdcbiAgaWYgKEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgdGhpcy5lbWl0KCdsYXlvdXRzdGFydGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgdGljaygpIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIGluZGV4LmpzXG4gICAgd2hpbGUgKCFsYXlvdXRFbmRlZCkge1xuICAgICAgbGF5b3V0RW5kZWQgPSB0aGlzLnRpY2soKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gb3ZlcnJpZGVzIG1vdmVOb2RlcyBtZXRob2QgaW4gRkRMYXlvdXRcbkNvU0VMYXlvdXQucHJvdG90eXBlLm1vdmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIG5vZGU7XG5cbiAgLy8gY2FsY3VsYXRlIGRpc3BsYWNlbWVudCBmb3IgZWFjaCBub2RlIFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQoKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbnN0cmFpbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy51cGRhdGVEaXNwbGFjZW1lbnRzKCk7XG4gIH1cblxuICAvLyBtb3ZlIGVhY2ggbm9kZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cmFpbnQgcmVsYXRlZCBtZXRob2RzOiBpbml0Q29uc3RyYWludFZhcmlhYmxlcyBhbmQgdXBkYXRlRGlzcGxhY2VtZW50c1xuXG4vLyBpbml0aWFsaXplIGNvbnN0cmFpbnQgcmVsYXRlZCB2YXJpYWJsZXNcbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRDb25zdHJhaW50VmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZml4ZWROb2RlU2V0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gZmlsbCBpZFRvTm9kZU1hcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB0aGlzLmlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBmaXhlZCBub2RlIHdlaWdodCBmb3IgZ2l2ZW4gY29tcG91bmQgbm9kZVxuICB2YXIgY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChjb21wb3VuZE5vZGUpIHtcbiAgICB2YXIgbm9kZXMgPSBjb21wb3VuZE5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZml4ZWROb2RlV2VpZ2h0O1xuICB9O1xuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICAvLyBmaWxsIGZpeGVkTm9kZVNldFxuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgc2VsZi5maXhlZE5vZGVTZXQuYWRkKG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgfSk7XG5cbiAgICAvLyBhc3NpZ24gZml4ZWQgbm9kZSB3ZWlnaHRzIHRvIGNvbXBvdW5kcyBpZiB0aGV5IGNvbnRhaW4gZml4ZWQgbm9kZXNcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBub2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgICAgaWYgKGZpeGVkTm9kZVdlaWdodCA+IDApIHtcbiAgICAgICAgICBub2RlLmZpeGVkTm9kZVdlaWdodCA9IGZpeGVkTm9kZVdlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHZhciBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzXG4gICAgdGhpcy5maXhlZE5vZGVTZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W2ldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG5cbiAgICAgIHRoaXMuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgaiwgeCwgaTtcbiAgICAgICAgZm9yIChpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAyICogYXJyYXkubGVuZ3RoIC8gMzsgaS0tKSB7XG4gICAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgIHggPSBhcnJheVtpXTtcbiAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICAgIGFycmF5W2pdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbCA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAvLyBmaWxsIGFycmF5cyBhbmQgbWFwc1xuICAgICAgdGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgdmFyIG5vZGVJZExlZnQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmxlZnQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5sZWZ0KSA6IGNvbnN0cmFpbnQubGVmdDtcbiAgICAgICAgICB2YXIgbm9kZUlkUmlnaHQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnJpZ2h0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIDogY29uc3RyYWludC5yaWdodDtcblxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmluY2x1ZGVzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRMZWZ0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkTGVmdCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZExlZnQpWzBdKS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRMZWZ0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5wdXNoKG5vZGVJZFJpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZFJpZ2h0KSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZFJpZ2h0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZFJpZ2h0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkTGVmdCkucHVzaCh7IHJpZ2h0OiBub2RlSWRSaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZFJpZ2h0KS5wdXNoKHsgbGVmdDogbm9kZUlkTGVmdCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZUlkVG9wID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnRvcCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQudG9wKSA6IGNvbnN0cmFpbnQudG9wO1xuICAgICAgICAgIHZhciBub2RlSWRCb3R0b20gPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQuYm90dG9tKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5ib3R0b20pIDogY29uc3RyYWludC5ib3R0b207XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZFRvcCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRUb3ApWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRUb3ApLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5pbmNsdWRlcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLnB1c2gobm9kZUlkQm90dG9tKTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZEJvdHRvbSlbMF0pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZEJvdHRvbSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkVG9wKS5wdXNoKHsgYm90dG9tOiBub2RlSWRCb3R0b20sIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkQm90dG9tKS5wdXNoKHsgdG9wOiBub2RlSWRUb3AsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcbiAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcblxuICAgICAgLy8gY29uc3RydWN0IHN1YmdyYXBocyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG4gICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhsZWZ0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KGxlZnQpLnB1c2gocmlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQobGVmdCwgW3JpZ2h0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMocmlnaHQpKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5nZXQocmlnaHQpLnB1c2gobGVmdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChyaWdodCwgW2xlZnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgYm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKHRvcCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQodG9wKS5wdXNoKGJvdHRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQodG9wLCBbYm90dG9tXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKGJvdHRvbSkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQoYm90dG9tKS5wdXNoKHRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYm90dG9tLCBbdG9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZnVuY3Rpb24gdG8gY29uc3RydWN0IGNvbXBvbmVudHMgZnJvbSBhIGdpdmVuIGdyYXBoIFxuICAgICAgLy8gYWxzbyByZXR1cm5zIGFuIGFycmF5IHRoYXQga2VlcHMgd2hldGhlciBlYWNoIGNvbXBvbmVudCBjb250YWlucyBmaXhlZCBub2RlXG4gICAgICB2YXIgY29uc3RydWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudHMoZ3JhcGgsIGZpeGVkTm9kZXMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBbXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBrZXk7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZFtjb3VudF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIGlzRml4ZWQ6IGlzRml4ZWQgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHRPbkhvcml6b250YWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25Ib3Jpem9udGFsLCBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsID0gcmVzdWx0T25Ib3Jpem9udGFsLmNvbXBvbmVudHM7XG4gICAgICB0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5pc0ZpeGVkO1xuICAgICAgdmFyIHJlc3VsdE9uVmVydGljYWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25WZXJ0aWNhbCwgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbCk7XG4gICAgICB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5pc0ZpeGVkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyBub2RlIGRpc3BsYWNlbWVudHMgYmFzZWQgb24gY29uc3RyYWludHNcbkNvU0VMYXlvdXQucHJvdG90eXBlLnVwZGF0ZURpc3BsYWNlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgdmFyIGZpeGVkTm9kZSA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgdmFyIGFsbFZlcnRpY2FsQWxpZ25tZW50cyA9IHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLmZpeGVkTm9kZVNldC5oYXMoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFggKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WCA9IHRvdGFsRGlzcGxhY2VtZW50WCAvIGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudFg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICB2YXIgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFkgKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnRZID0gdG90YWxEaXNwbGFjZW1lbnRZIC8gYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50WTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuXG4gICAgaWYgKENvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMpIHtcbiAgICAgIC8vIHNodWZmbGUgYXJyYXkgdG8gcmFuZG9taXplIG5vZGUgcHJvY2Vzc2luZyBvcmRlclxuICAgICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgICB0aGlzLnNodWZmbGUodGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsKTtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yaWdodCkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5yaWdodCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5sZWZ0KSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZCwgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgaWYgKCFzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICB2YXIgZGlzcGxhY2VtZW50ID0gMDtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm90dG9tKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoY29uc3RyYWludC5ib3R0b20pIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCAtPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQudG9wKSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgKyBkaXNwbGFjZW1lbnQpO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWRDb21wb25lbnRzT25Ib3Jpem9udGFsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSk7XG4gICAgICAgICAgICAgIHN1bSArPSBhY3R1YWxOb2Rlcy5sZW5ndGggKiB0aGlzLmlkVG9Ob2RlTWFwLmdldChhY3R1YWxOb2Rlc1swXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQgKz0gYWN0dWFsTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VtICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnQgPSBzdW0gLyBjb3VudDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFggPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tcG9uZW50c09uVmVydGljYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uVmVydGljYWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uVmVydGljYWxbaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHZhciBhY3R1YWxOb2RlcyA9IHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICAgIGNvbXBvdW5kTm9kZS5zZXRDZW50ZXIodGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWCwgdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucmVwb3B1bGF0ZUNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29tcG91bmRPcmRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsQ29tcG91bmROb2RlID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIHZhciBpZCA9IGxDb21wb3VuZE5vZGUuaWQ7XG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdMZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IGxDb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcDtcblxuICAgIHRoaXMuYWRqdXN0TG9jYXRpb25zKHRoaXMudGlsZWRNZW1iZXJQYWNrW2lkXSwgbENvbXBvdW5kTm9kZS5yZWN0LngsIGxDb21wb3VuZE5vZGUucmVjdC55LCBob3Jpem9udGFsTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbiwgbGFiZWxNYXJnaW5MZWZ0LCBsYWJlbE1hcmdpblRvcCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrO1xuXG4gIE9iamVjdC5rZXlzKHRpbGVkUGFjaykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY29tcG91bmROb2RlID0gc2VsZi5pZFRvRHVtbXlOb2RlW2lkXTsgLy8gR2V0IHRoZSBkdW1teSBjb21wb3VuZCBieSBpdHMgaWRcbiAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdDtcbiAgICB2YXIgbGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbiwgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQsIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3ApIHtcbiAgeCArPSBjb21wb3VuZEhvcml6b250YWxNYXJnaW4gKyBjb21wb3VuZExhYmVsTWFyZ2luTGVmdDtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpblRvcDtcblxuICB2YXIgbGVmdCA9IHg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tpXTtcbiAgICB4ID0gbGVmdDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbG5vZGUgPSByb3dbal07XG5cbiAgICAgIGxub2RlLnJlY3QueCA9IHg7IC8vICsgbG5vZGUucmVjdC53aWR0aCAvIDI7XG4gICAgICBsbm9kZS5yZWN0LnkgPSB5OyAvLyArIGxub2RlLnJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgeCArPSBsbm9kZS5yZWN0LndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgICBpZiAobG5vZGUucmVjdC5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IGxub2RlLnJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIHkgKz0gbWF4SGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZUNvbXBvdW5kTWVtYmVycyA9IGZ1bmN0aW9uIChjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudGlsZWRNZW1iZXJQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXMoY2hpbGRHcmFwaE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAvLyBHZXQgdGhlIGNvbXBvdW5kIG5vZGVcbiAgICB2YXIgY29tcG91bmROb2RlID0gaWRUb05vZGVbaWRdO1xuXG4gICAgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoY2hpbGRHcmFwaE1hcFtpZF0sIGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdCArIGNvbXBvdW5kTm9kZS5wYWRkaW5nUmlnaHQpO1xuXG4gICAgY29tcG91bmROb2RlLnJlY3Qud2lkdGggPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5jZW50ZXJYLCBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCkge1xuICB2YXIgaG9yaXpvbnRhbE9yZyA9IHRoaXMudGlsZU5vZGVzQnlGYXZvcmluZ0RpbShub2RlcywgbWluV2lkdGgsIHRydWUpO1xuICB2YXIgdmVydGljYWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCBmYWxzZSk7XG5cbiAgdmFyIGhvcml6b250YWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8oaG9yaXpvbnRhbE9yZyk7XG4gIHZhciB2ZXJ0aWNhbFJhdGlvID0gdGhpcy5nZXRPcmdSYXRpbyh2ZXJ0aWNhbE9yZyk7XG4gIHZhciBiZXN0T3JnO1xuXG4gIC8vIHRoZSBiZXN0IHJhdGlvIGlzIHRoZSBvbmUgdGhhdCBpcyBjbG9zZXIgdG8gMSBzaW5jZSB0aGUgcmF0aW9zIGFyZSBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgLy8gYW5kIHRoZSBiZXN0IG9yZ2FuaXphdGlvbiBpcyB0aGUgb25lIHRoYXQgaGFzIHRoZSBiZXN0IHJhdGlvXG4gIGlmICh2ZXJ0aWNhbFJhdGlvIDwgaG9yaXpvbnRhbFJhdGlvKSB7XG4gICAgYmVzdE9yZyA9IHZlcnRpY2FsT3JnO1xuICB9IGVsc2Uge1xuICAgIGJlc3RPcmcgPSBob3Jpem9udGFsT3JnO1xuICB9XG5cbiAgcmV0dXJuIGJlc3RPcmc7XG59O1xuXG4vLyBnZXQgdGhlIHdpZHRoL2hlaWdodCByYXRpbyBvZiB0aGUgb3JnYW5pemF0aW9uIHRoYXQgaXMgbm9ybWFsaXplZCBzbyB0aGF0IGl0IHdpbGwgbm90IGJlIGxlc3MgdGhhbiAxXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRPcmdSYXRpbyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgLy8gZ2V0IGRpbWVuc2lvbnMgYW5kIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbCByYXRpb1xuICB2YXIgd2lkdGggPSBvcmdhbml6YXRpb24ud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBvcmdhbml6YXRpb24uaGVpZ2h0O1xuICB2YXIgcmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblxuICAvLyBpZiB0aGUgaW5pdGlhbCByYXRpbyBpcyBsZXNzIHRoZW4gMSB0aGVuIGludmVyc2UgaXRcbiAgaWYgKHJhdGlvIDwgMSkge1xuICAgIHJhdGlvID0gMSAvIHJhdGlvO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBub3JtYWxpemVkIHJhdGlvXG4gIHJldHVybiByYXRpbztcbn07XG5cbi8qXG4gKiBDYWxjdWxhdGVzIHRoZSBpZGVhbCB3aWR0aCBmb3IgdGhlIHJvd3MuIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdFxuICogZWFjaCBub2RlIGhhcyB0aGUgc2FtZSBzaXplcyBhbmQgY2FsY3VsYXRlcyB0aGUgaWRlYWwgcm93IHdpZHRoIHRoYXRcbiAqIGFwcHJveGltYXRlcyBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCBhY2NvcmRpbmdseS4gSG93ZXZlciwgc2luY2Ugbm9kZXMgd291bGRcbiAqIGhhdmUgZGlmZmVyZW50IHNpemVzIHNvbWUgcm93cyB3b3VsZCBoYXZlIGRpZmZlcmVudCBzaXplcyBhbmQgdGhlIHJlc3VsdGluZ1xuICogc2hhcGUgd291bGQgbm90IGJlIGFuIGV4YWN0IHNxdWFyZS5cbiAqL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY0lkZWFsUm93V2lkdGggPSBmdW5jdGlvbiAobWVtYmVycywgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIC8vIFRvIGFwcHJveGltYXRlIGEgc3F1YXJlIHNoYXBlZCBjb21wbGV4IHdlIG5lZWQgdG8gbWFrZSBjb21wbGV4IHdpZHRoIGVxdWFsIHRvIGNvbXBsZXggaGVpZ2h0LlxuICAvLyBUbyBhY2hpZXZlIHRoaXMgd2UgbmVlZCB0byBzb2x2ZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHN5c3RlbSBmb3IgaGM6XG4gIC8vICh4ICsgYngpICogaGMgLSBieCA9ICh5ICsgYnkpICogdmMgLSBieSwgaGMgKiB2YyA9IG5cbiAgLy8gd2hlcmUgeCBpcyB0aGUgYXZhcmFnZSB3aWR0aCBvZiB0aGUgbm9kZXMsIHkgaXMgdGhlIGF2YXJhZ2UgaGVpZ2h0IG9mIG5vZGVzXG4gIC8vIGJ4IGFuZCBieSBhcmUgdGhlIGJ1ZmZlciBzaXplcyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zIGFjY29yZGluZ2x5LFxuICAvLyBoYyBhbmQgdmMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zXG4gIC8vIG4gaXMgbnVtYmVyIG9mIG1lbWJlcnMuXG5cbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcblxuICAvLyBudW1iZXIgb2YgbWVtYmVyc1xuICB2YXIgbWVtYmVyc1NpemUgPSBtZW1iZXJzLmxlbmd0aDtcblxuICAvLyBzdW0gb2YgdGhlIHdpZHRoIG9mIGFsbCBtZW1iZXJzXG4gIHZhciB0b3RhbFdpZHRoID0gMDtcblxuICAvLyBzdW0gb2YgdGhlIGhlaWdodCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuXG4gIHZhciBtYXhXaWR0aCA9IDA7XG5cbiAgLy8gdHJhdmVyc2UgYWxsIG1lbWJlcnMgdG8gY2FsY3VsYXRlIHRvdGFsIHdpZHRoIGFuZCB0b3RhbCBoZWlnaHQgYW5kIGdldCB0aGUgbWF4aW11bSBtZW1iZXJzIHdpZHRoXG4gIG1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHRvdGFsV2lkdGggKz0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIHRvdGFsSGVpZ2h0ICs9IG5vZGUuZ2V0SGVpZ2h0KCk7XG5cbiAgICBpZiAobm9kZS5nZXRXaWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIG1heFdpZHRoID0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYXZlcmFnZSB3aWR0aCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZVdpZHRoID0gdG90YWxXaWR0aCAvIG1lbWJlcnNTaXplO1xuXG4gIC8vIGF2ZXJhZ2UgaGVpZ2h0IG9mIHRoZSBtZW1iZXJzXG4gIHZhciBhdmVyYWdlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2aW5nIHRoZSBpbml0aWFsIGVxdWF0aW9uIHN5c3RlbSBmb3IgdGhlIGhjIHlpZWxkcyB0aGUgZm9sbG93aW5nIHNlY29uZCBkZWdyZWUgZXF1YXRpb246XG4gIC8vIGhjXjIgKiAoeCtieCkgKyBoYyAqIChieSAtIGJ4KSAtIG4gKiAoeSArIGJ5KSA9IDBcblxuICAvLyB0aGUgZGVsdGEgdmFsdWUgdG8gc29sdmUgdGhlIGVxdWF0aW9uIGFib3ZlIGZvciBoY1xuICB2YXIgZGVsdGEgPSBNYXRoLnBvdyh2ZXJ0aWNhbFBhZGRpbmcgLSBob3Jpem9udGFsUGFkZGluZywgMikgKyA0ICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSAqIChhdmVyYWdlSGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nKSAqIG1lbWJlcnNTaXplO1xuXG4gIC8vIHNvbHZlIHRoZSBlcXVhdGlvbiB1c2luZyBkZWx0YSB2YWx1ZSB0byBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgY291bnRcbiAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gYW4gaWRlYWwgcm93XG4gIHZhciBob3Jpem9udGFsQ291bnREb3VibGUgPSAoaG9yaXpvbnRhbFBhZGRpbmcgLSB2ZXJ0aWNhbFBhZGRpbmcgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSk7XG4gIC8vIHJvdW5kIHRoZSBjYWxjdWxhdGVkIGhvcml6b250YWwgY291bnQgdXAgb3IgZG93biBhY2NvcmRpbmcgdG8gdGhlIGZhdm9yZWQgZGltZW5zaW9uXG4gIHZhciBob3Jpem9udGFsQ291bnQ7XG5cbiAgaWYgKGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguY2VpbChob3Jpem9udGFsQ291bnREb3VibGUpO1xuICAgIC8vIGlmIGhvcml6b250YWxDb3VudCBjb3VudCBpcyBub3QgYSBmbG9hdCB2YWx1ZSB0aGVuIGJvdGggb2Ygcm91bmRpbmcgdG8gZmxvb3IgYW5kIGNlaWxcbiAgICAvLyB3aWxsIHlpZWxkIHRoZSBzYW1lIHZhbHVlcy4gSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhlIHNhbWUgY2FsY3VsYXRpb24gdHJ5IGdvaW5nIHVwXG4gICAgLy8gd2hpbGUgZmF2b3JpbmcgaG9yaXpvbnRhbCBkaW1lbnNpb24gaW4gc3VjaCBjYXNlc1xuICAgIGlmIChob3Jpem9udGFsQ291bnQgPT0gaG9yaXpvbnRhbENvdW50RG91YmxlKSB7XG4gICAgICBob3Jpem9udGFsQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaG9yaXpvbnRhbENvdW50ID0gTWF0aC5mbG9vcihob3Jpem9udGFsQ291bnREb3VibGUpO1xuICB9XG5cbiAgLy8gaWRlYWwgd2lkdGggdG8gYmUgY2FsY3VsYXRlZFxuICB2YXIgaWRlYWxXaWR0aCA9IGhvcml6b250YWxDb3VudCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgLSBob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBpZiBtYXggd2lkdGggaXMgYmlnZ2VyIHRoYW4gY2FsY3VsYXRlZCBpZGVhbCB3aWR0aCByZXNldCBpZGVhbCB3aWR0aCB0byBpdFxuICBpZiAobWF4V2lkdGggPiBpZGVhbFdpZHRoKSB7XG4gICAgaWRlYWxXaWR0aCA9IG1heFdpZHRoO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBsZWZ0LXJpZ2h0IG1hcmdpbnMgdG8gdGhlIGlkZWFsIHJvdyB3aWR0aFxuICBpZGVhbFdpZHRoICs9IGhvcml6b250YWxQYWRkaW5nICogMjtcblxuICAvLyByZXR1cm4gdGhlIGlkZWFsIHJvdyB3aWR0aDFcbiAgcmV0dXJuIGlkZWFsV2lkdGg7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlTm9kZXNCeUZhdm9yaW5nRGltID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCwgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG4gIHZhciB0aWxpbmdDb21wYXJlQnkgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19DT01QQVJFX0JZO1xuICB2YXIgb3JnYW5pemF0aW9uID0ge1xuICAgIHJvd3M6IFtdLFxuICAgIHJvd1dpZHRoOiBbXSxcbiAgICByb3dIZWlnaHQ6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogbWluV2lkdGgsIC8vIGFzc3VtZSBtaW5IZWlnaHQgZXF1YWxzIHRvIG1pbldpZHRoXG4gICAgdmVydGljYWxQYWRkaW5nOiB2ZXJ0aWNhbFBhZGRpbmcsXG4gICAgaG9yaXpvbnRhbFBhZGRpbmc6IGhvcml6b250YWxQYWRkaW5nLFxuICAgIGNlbnRlclg6IDAsXG4gICAgY2VudGVyWTogMFxuICB9O1xuXG4gIGlmICh0aWxpbmdDb21wYXJlQnkpIHtcbiAgICBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCA9IHRoaXMuY2FsY0lkZWFsUm93V2lkdGgobm9kZXMsIGZhdm9ySG9yaXpvbnRhbERpbSk7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZUFyZWEgPSBmdW5jdGlvbiBnZXROb2RlQXJlYShuKSB7XG4gICAgcmV0dXJuIG4ucmVjdC53aWR0aCAqIG4ucmVjdC5oZWlnaHQ7XG4gIH07XG5cbiAgdmFyIGFyZWFDb21wYXJlRmNuID0gZnVuY3Rpb24gYXJlYUNvbXBhcmVGY24objEsIG4yKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBcmVhKG4yKSAtIGdldE5vZGVBcmVhKG4xKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBub2RlcyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHRoZWlyIGFyZWFzXG4gIG5vZGVzLnNvcnQoZnVuY3Rpb24gKG4xLCBuMikge1xuICAgIHZhciBjbXBCeSA9IGFyZWFDb21wYXJlRmNuO1xuICAgIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgY21wQnkgPSB0aWxpbmdDb21wYXJlQnk7XG4gICAgICByZXR1cm4gY21wQnkobjEuaWQsIG4yLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcEJ5KG4xLCBuMik7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IGNhbGN1bGF0ZSBjb21wb3VuZCBjZW50ZXJcbiAgdmFyIHN1bUNlbnRlclggPSAwO1xuICB2YXIgc3VtQ2VudGVyWSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIHN1bUNlbnRlclggKz0gbE5vZGUuZ2V0Q2VudGVyWCgpO1xuICAgIHN1bUNlbnRlclkgKz0gbE5vZGUuZ2V0Q2VudGVyWSgpO1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmNlbnRlclggPSBzdW1DZW50ZXJYIC8gbm9kZXMubGVuZ3RoO1xuICBvcmdhbml6YXRpb24uY2VudGVyWSA9IHN1bUNlbnRlclkgLyBub2Rlcy5sZW5ndGg7XG5cbiAgLy8gQ3JlYXRlIHRoZSBvcmdhbml6YXRpb24gLT4gdGlsZSBtZW1iZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgMCwgbWluV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jYW5BZGRIb3Jpem9udGFsKG9yZ2FuaXphdGlvbiwgbE5vZGUucmVjdC53aWR0aCwgbE5vZGUucmVjdC5oZWlnaHQpKSB7XG4gICAgICB2YXIgcm93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgICByb3dJbmRleCA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgcm93SW5kZXgsIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgLy8gaWYgdGhlcmUgaXMgYW4gaWRlYWwgcm93IHdpZHRoIHNwZWNpZmllZCB1c2UgaXQgaW5zdGVhZCBvZiBjaGVja2luZyB0aGUgYXNwZWN0IHJhdGlvXG4gIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgIHZhciBsYXN0Um93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0Um93V2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdFJvd0luZGV4XTtcblxuICAgIC8vIGNoZWNrIGFuZCByZXR1cm4gaWYgaWRlYWwgcm93IHdpZHRoIHdpbGwgYmUgZXhjZWVkIGlmIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSByb3dcbiAgICByZXR1cm4gbGFzdFJvd1dpZHRoICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyA8PSBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aDtcbiAgfVxuXG4gIHZhciBzcmkgPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcblxuICBpZiAoc3JpIDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1pbiA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtzcmldO1xuXG4gIGlmIChtaW4gKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgKyBleHRyYVdpZHRoIDw9IG9yZ2FuaXphdGlvbi53aWR0aCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGhEaWZmID0gMDtcblxuICAvLyBBZGRpbmcgdG8gYW4gZXhpc3Rpbmcgcm93XG4gIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV0gPCBleHRyYUhlaWdodCkge1xuICAgIGlmIChzcmkgPiAwKSBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZyAtIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXTtcbiAgfVxuXG4gIHZhciBhZGRfdG9fcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gbWluID49IGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyAobWluICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgLy8gQWRkaW5nIGEgbmV3IHJvdyBmb3IgdGhpcyBub2RlXG4gIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB2YXIgYWRkX25ld19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCBleHRyYVdpZHRoKSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIGV4dHJhV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIGlmIChhZGRfbmV3X3Jvd19yYXRpbyA8IDEpIGFkZF9uZXdfcm93X3JhdGlvID0gMSAvIGFkZF9uZXdfcm93X3JhdGlvO1xuXG4gIGlmIChhZGRfdG9fcm93X3JhdGlvIDwgMSkgYWRkX3RvX3Jvd19yYXRpbyA9IDEgLyBhZGRfdG9fcm93X3JhdGlvO1xuXG4gIHJldHVybiBhZGRfdG9fcm93X3JhdGlvIDwgYWRkX25ld19yb3dfcmF0aW87XG59O1xuXG4vL0lmIG1vdmluZyB0aGUgbGFzdCBub2RlIGZyb20gdGhlIGxvbmdlc3Qgcm93IGFuZCBhZGRpbmcgaXQgdG8gdGhlIGxhc3Rcbi8vcm93IG1ha2VzIHRoZSBib3VuZGluZyBib3ggc21hbGxlciwgZG8gaXQuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5zaGlmdFRvTGFzdFJvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIGxvbmdlc3QgPSB0aGlzLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICB2YXIgbGFzdCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5sZW5ndGggLSAxO1xuICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbbG9uZ2VzdF07XG4gIHZhciBub2RlID0gcm93W3Jvdy5sZW5ndGggLSAxXTtcblxuICB2YXIgZGlmZiA9IG5vZGUud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIG9uIHRoZSBsYXN0IHJvd1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID4gZGlmZiAmJiBsb25nZXN0ICE9IGxhc3QpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9uZ2VzdCByb3dcbiAgICByb3cuc3BsaWNlKC0xLCAxKTtcblxuICAgIC8vIFB1c2ggaXQgdG8gdGhlIGxhc3Qgcm93XG4gICAgb3JnYW5pemF0aW9uLnJvd3NbbGFzdF0ucHVzaChub2RlKTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSAtIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdICsgZGlmZjtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaW5zdGFuY2UuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbildO1xuXG4gICAgLy8gVXBkYXRlIGhlaWdodHMgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgIHZhciBtYXhIZWlnaHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocm93W2ldLmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gcm93W2ldLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKGxvbmdlc3QgPiAwKSBtYXhIZWlnaHQgKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBwcmV2VG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gPSBtYXhIZWlnaHQ7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPCBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcpIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPSBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgZmluYWxUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuICAgIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZmluYWxUb3RhbCAtIHByZXZUb3RhbDtcblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUHJlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgLy8gRmluZCB6ZXJvIGRlZ3JlZSBub2RlcyBhbmQgY3JlYXRlIGEgY29tcG91bmQgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICAvLyBUaWxlIGFuZCBjbGVhciBjaGlsZHJlbiBvZiBlYWNoIGNvbXBvdW5kXG4gICAgdGhpcy5jbGVhckNvbXBvdW5kcygpO1xuICAgIC8vIFNlcGFyYXRlbHkgdGlsZSBhbmQgY2xlYXIgemVybyBkZWdyZWUgbm9kZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIHRoaXMucmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgdGhpcy5yZXBvcHVsYXRlQ29tcG91bmRzKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBUcmVlIFJlZHVjdGlvbiBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVkdWNlIHRyZWVzIFxuQ29TRUxheW91dC5wcm90b3R5cGUucmVkdWNlVHJlZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcnVuZWROb2Rlc0FsbCA9IFtdO1xuICB2YXIgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgdmFyIG5vZGU7XG5cbiAgd2hpbGUgKGNvbnRhaW5zTGVhZikge1xuICAgIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gICAgdmFyIHBydW5lZE5vZGVzSW5TdGVwVGVtcCA9IFtdO1xuICAgIGNvbnRhaW5zTGVhZiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSAmJiAhbm9kZS5nZXRFZGdlcygpWzBdLmlzSW50ZXJHcmFwaCAmJiBub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAgICAgdmFyIG90aGVyRW5kID0gbm9kZS5nZXRFZGdlcygpWzBdLmdldE90aGVyRW5kKG5vZGUpO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVBvc2l0aW9uID0gbmV3IERpbWVuc2lvbkQobm9kZS5nZXRDZW50ZXJYKCkgLSBvdGhlckVuZC5nZXRDZW50ZXJYKCksIG5vZGUuZ2V0Q2VudGVyWSgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCksIHJlbGF0aXZlUG9zaXRpb25dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCldKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlRGF0YVszXS5nZXRXaWR0aCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSArIG5vZGVEYXRhWzNdLmdldEhlaWdodCgpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhcnRHcmlkWCA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRYO1xuICAgIHZhciBmaW5pc2hHcmlkWCA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWDtcbiAgICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICAgIHZhciBmaW5pc2hHcmlkWSA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWTtcblxuICAgIHZhciB1cE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICAgIHZhciByaWdodE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGxlZnROb2RlQ291bnQgPSAwO1xuICAgIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gICAgaWYgKHN0YXJ0R3JpZFkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzFdICs9IHRoaXMuZ3JpZFtmaW5pc2hHcmlkWCArIDFdW2ldLmxlbmd0aCArIHRoaXMuZ3JpZFtmaW5pc2hHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbmlzaEdyaWRZIDwgdGhpcy5ncmlkWzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbMl0gKz0gdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZICsgMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRHcmlkWCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRZOyBpIDw9IGZpbmlzaEdyaWRZOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtaW5Db3VudDtcbiAgICB2YXIgbWluSW5kZXg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zW2pdIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGNvbnRyb2xSZWdpb25zW2pdO1xuICAgICAgICBtaW5Db3VudCA9IDE7XG4gICAgICAgIG1pbkluZGV4ID0gajtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbal0gPT0gbWluKSB7XG4gICAgICAgIG1pbkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSAyICYmIG1pbiA9PSAwKSB7XG4gICAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMik7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gNCAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSByYW5kb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDApIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICB9IGVsc2UgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDEpIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VMYXlvdXQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JTWF0aDtcblxuZnVuY3Rpb24gQ29TRU5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgRkRMYXlvdXROb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0Tm9kZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dE5vZGUpIHtcbiAgQ29TRU5vZGVbcHJvcF0gPSBGRExheW91dE5vZGVbcHJvcF07XG59XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcbiAgLy8gdGhpcyBjaGVjayBpcyBmb3IgY29tcG91bmQgbm9kZXMgdGhhdCBjb250YWluIGZpeGVkIG5vZGVzXG4gIGlmICh0aGlzLmdldENoaWxkKCkgIT0gbnVsbCAmJiB0aGlzLmZpeGVkTm9kZVdlaWdodCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLmZpeGVkTm9kZVdlaWdodDtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VYICsgdGhpcy5yZXB1bHNpb25Gb3JjZVggKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYKSAvIHRoaXMubm9PZkNoaWxkcmVuO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWSArIHRoaXMucmVwdWxzaW9uRm9yY2VZICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFkpO1xuICB9XG5cbiAgLy8gbm9uLWVtcHR5IGNvbXBvdW5kIG5vZGUsIHByb3BvZ2F0ZSBtb3ZlbWVudCB0byBjaGlsZHJlbiBhcyB3ZWxsXG4gIGlmICh0aGlzLmNoaWxkICYmIHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZFgsIGRZKSB7XG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICB2YXIgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WCArPSBkWDtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WSArPSBkWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKGRYLCBkWSk7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuXG4gIC8vIGEgc2ltcGxlIG5vZGUgb3IgYW4gZW1wdHkgY29tcG91bmQgbm9kZSwgbW92ZSBpdFxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsIHx8IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICAgIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByZWQxID0gZnVuY3Rpb24gKHByZWQxKSB7XG4gIHRoaXMucHJlZDEgPSBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQxO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldFByZWQyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJlZDI7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0UHJvY2Vzc2VkID0gZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xuICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5pc1Byb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByb2Nlc3NlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRU5vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MaW5rZWRMaXN0O1xudmFyIE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5NYXRyaXg7XG52YXIgU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlNWRDtcblxuZnVuY3Rpb24gQ29uc3RyYWludEhhbmRsZXIoKSB7fVxuXG5Db25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgLy8gIGxldCBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBnZXQgY29uc3RyYWludHMgZnJvbSBsYXlvdXRcbiAgdmFyIGNvbnN0cmFpbnRzID0ge307XG4gIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludDtcbiAgY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCA9IGxheW91dC5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50O1xuICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuXG4gIHZhciBpZFRvTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpO1xuICB2YXIgeENvb3JkcyA9IFtdO1xuICB2YXIgeUNvb3JkcyA9IFtdO1xuXG4gIHZhciBhbGxOb2RlcyA9IGxheW91dC5nZXRBbGxOb2RlcygpO1xuICB2YXIgaW5kZXggPSAwO1xuICAvLyBmaWxsIGluZGV4IG1hcCBhbmQgY29vcmRpbmF0ZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZS5pZCwgaW5kZXgrKyk7XG4gICAgICB4Q29vcmRzLnB1c2gobm9kZS5nZXRDZW50ZXJYKCkpO1xuICAgICAgeUNvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWSgpKTtcbiAgICAgIGlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSBleGlzdHMgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgd2l0aG91dCBnYXAgdmFsdWUsIHNldCBpdCB0byBkZWZhdWx0IFxuICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmICghY29uc3RyYWludC5nYXAgJiYgY29uc3RyYWludC5nYXAgIT0gMCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5sZWZ0KS5nZXRXaWR0aCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnJpZ2h0KS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdHJhaW50LmdhcCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnRvcCkuZ2V0SGVpZ2h0KCkgLyAyICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qIGF1eGlsaWFyeSBmdW5jdGlvbnMgKi9cblxuICAvLyBjYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb3NpdGlvbiBvYmplY3RzXG4gIHZhciBjYWxjdWxhdGVQb3NpdGlvbkRpZmYgPSBmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zMSwgcG9zMikge1xuICAgIHJldHVybiB7IHg6IHBvczEueCAtIHBvczIueCwgeTogcG9zMS55IC0gcG9zMi55IH07XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIG5vZGVzXG4gIHZhciBjYWxjdWxhdGVBdmdQb3NpdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKG5vZGVJZFNldCkge1xuICAgIHZhciB4UG9zU3VtID0gMDtcbiAgICB2YXIgeVBvc1N1bSA9IDA7XG4gICAgbm9kZUlkU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgeFBvc1N1bSArPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgIHlQb3NTdW0gKz0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB4OiB4UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUsIHk6IHlQb3NTdW0gLyBub2RlSWRTZXQuc2l6ZSB9O1xuICB9O1xuXG4gIC8vIGZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHRoZSBub2RlcyBpbiBhIGdpdmVuIGdyYXBoIGFjY29yZGluZyB0byByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIHRha2VzIHRoZSBmaXhlZCBub2RlcyBhbmQgYWxpZ25tZW50IGNvbnN0cmFpbnRzIGludG8gYWNjb3VudFxuICAvLyBncmFwaDogZGFnIHRvIGJlIGV2YWx1YXRlZCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIsIFxuICAvLyBmaXhlZE5vZGVzOiBzZXQgb2YgZml4ZWQgbm9kZXMgdG8gY29uc2lkZXIgZHVyaW5nIGV2YWx1YXRpb24sIGR1bW15UG9zaXRpb25zOiBhcHByb3ByaWF0ZSBjb29yZGluYXRlcyBvZiB0aGUgZHVtbXkgbm9kZXMgIFxuICB2YXIgZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZ3JhcGgsIGRpcmVjdGlvbiwgZml4ZWROb2RlcywgZHVtbXlQb3NpdGlvbnMsIGNvbXBvbmVudFNvdXJjZXMpIHtcblxuICAgIC8vIGZpbmQgdW5pb24gb2YgdHdvIHNldHNcbiAgICBmdW5jdGlvbiBzZXRVbmlvbihzZXRBLCBzZXRCKSB7XG4gICAgICB2YXIgdW5pb24gPSBuZXcgU2V0KHNldEEpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHNldEJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHVuaW9uLmFkZChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmlvbjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICB2YXIgaW5EZWdyZWVzID0gbmV3IE1hcCgpO1xuXG4gICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaW5EZWdyZWVzLnNldChrZXksIDApO1xuICAgIH0pO1xuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgIGluRGVncmVlcy5zZXQoYWRqYWNlbnQuaWQsIGluRGVncmVlcy5nZXQoYWRqYWNlbnQuaWQpICsgMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBwb3NpdGlvbk1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHBvc2l0aW9uIGZvciBlYWNoIG5vZGVcbiAgICB2YXIgcGFzdE1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHByZWRlY2Vzc29ycyhwYXN0KSBvZiBhIG5vZGVcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIGluRGVncmVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICBxdWV1ZS5wdXNoKGtleSk7XG4gICAgICAgIGlmICghZml4ZWROb2Rlcykge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgICAgcGFzdE1hcC5zZXQoa2V5LCBuZXcgU2V0KFtrZXldKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhbGlnbiBzb3VyY2VzIG9mIGVhY2ggY29tcG9uZW50IGluIGVuZm9yY2VtZW50IHBoYXNlXG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIGNvbXBvbmVudFNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBmaXhlZElkcyA9IFtdO1xuICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGZpeGVkSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZml4ZWRJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgZml4ZWRJZHMuZm9yRWFjaChmdW5jdGlvbiAoZml4ZWRJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoZml4ZWRJZCwgbm9kZUluZGV4ZXMuaGFzKGZpeGVkSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoZml4ZWRJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGZpeGVkSWQpKTtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25NYXAuZ2V0KGZpeGVkSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gZml4ZWRJZHMubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBfcG9zaXRpb24gKz0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBfcG9zaXRpb24gLyBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIF9wb3NpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgIG5laWdoYm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChuZWlnaGJvcikge1xuICAgICAgICBpZiAocG9zaXRpb25NYXAuZ2V0KG5laWdoYm9yLmlkKSA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICBpZiAoZml4ZWROb2RlcyAmJiBmaXhlZE5vZGVzLmhhcyhuZWlnaGJvci5pZCkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gbm9kZUluZGV4ZXMuaGFzKG5laWdoYm9yLmlkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5laWdoYm9yLmlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChuZWlnaGJvci5pZCwgZml4ZWRQb3NpdGlvbik7IC8vIFRPRE86IG1heSBkbyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgICAgICBpZiAoZml4ZWRQb3NpdGlvbiA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwIC0gZml4ZWRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgcGFzdE1hcC5nZXQoY3VycmVudE5vZGUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIHBvc2l0aW9uTWFwLmdldChub2RlSWQpIC0gZGlmZik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbkRlZ3JlZXMuc2V0KG5laWdoYm9yLmlkLCBpbkRlZ3JlZXMuZ2V0KG5laWdoYm9yLmlkKSAtIDEpO1xuICAgICAgICBpZiAoaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgPT0gMCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgICAgcGFzdE1hcC5zZXQobmVpZ2hib3IuaWQsIHNldFVuaW9uKHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKSwgcGFzdE1hcC5nZXQobmVpZ2hib3IuaWQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuXG4gICAgLy8gcmVhZGp1c3QgcG9zaXRpb24gb2YgdGhlIG5vZGVzIGFmdGVyIGVuZm9yY2VtZW50XG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIC8vIGZpbmQgaW5kZWdyZWUgY291bnQgZm9yIGVhY2ggbm9kZVxuICAgICAgdmFyIHNpbmtOb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBzaW5rTm9kZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgIHBhc3RNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoc2lua05vZGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGlzRml4ZWRDb21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0ZpeGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaXNFeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGV4aXN0QXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGFzKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKVswXSkpIHtcbiAgICAgICAgICAgICAgICBpc0V4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGlzdEF0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0V4aXN0KSB7XG4gICAgICAgICAgICAgIF9jb21wb25lbnRzLnB1c2gobmV3IFNldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudHNbZXhpc3RBdF0uYWRkKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF9jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1pbkJlZm9yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1pbkFmdGVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QmVmb3JlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QWZ0ZXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHBvc0JlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvc0FmdGVyID0gcG9zaXRpb25NYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlIDwgbWluQmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1pbkJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NCZWZvcmUgPiBtYXhCZWZvcmUpIHtcbiAgICAgICAgICAgICAgbWF4QmVmb3JlID0gcG9zQmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc0FmdGVyIDwgbWluQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbWluQWZ0ZXIgPSBwb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA+IG1heEFmdGVyKSB7XG4gICAgICAgICAgICAgIG1heEFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IChtaW5CZWZvcmUgKyBtYXhCZWZvcmUpIC8gMiAtIChtaW5BZnRlciArIG1heEFmdGVyKSAvIDI7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9ub2RlSWQgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChfbm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQoX25vZGVJZCkgKyBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uTWFwO1xuICB9O1xuXG4gIC8vIGZpbmQgdHJhbnNmb3JtYXRpb24gYmFzZWQgb24gcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgaWYgdGhlcmUgYXJlIGJvdGggYWxpZ25tZW50IGFuZCByZWwuIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICAvLyBvciBpZiB0aGVyZSBhcmUgb25seSByZWwuIHBsYWNlbWVudCBjb250cmFpbnRzIHdoZXJlIHRoZSBsYXJnZXN0IGNvbXBvbmVudCBpc24ndCBzdWZmaWNpZW50bHkgbGFyZ2VcbiAgdmFyIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50ID0gZnVuY3Rpb24gYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQocmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50cykge1xuICAgIC8vIHZhcmlhYmxlcyB0byBjb3VudCB2b3Rlc1xuICAgIHZhciByZWZsZWN0T25ZID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWSA9IDA7XG4gICAgdmFyIHJlZmxlY3RPblggPSAwLFxuICAgICAgICBub3RSZWZsZWN0T25YID0gMDtcblxuICAgIHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmxlZnQpXSAtIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQucmlnaHQpXSA+PSAwID8gcmVmbGVjdE9uWSsrIDogbm90UmVmbGVjdE9uWSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC50b3ApXSAtIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKV0gPj0gMCA/IHJlZmxlY3RPblgrKyA6IG5vdFJlZmxlY3RPblgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSAmJiByZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVJbmRleGVzLnNpemU7IF9pKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaV0gPSAtMSAqIHhDb29yZHNbX2ldO1xuICAgICAgICB5Q29vcmRzW19pXSA9IC0xICogeUNvb3Jkc1tfaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kyKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaTJdID0gLTEgKiB4Q29vcmRzW19pMl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kzKyspIHtcbiAgICAgICAgeUNvb3Jkc1tfaTNdID0gLTEgKiB5Q29vcmRzW19pM107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGZpbmQgd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzIGluIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGZpbmRDb21wb25lbnRzID0gZnVuY3Rpb24gZmluZENvbXBvbmVudHMoZ3JhcGgpIHtcbiAgICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiBkYWdcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XSA9IFtdO1xuICAgICAgICB2YXIgX2N1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICBxdWV1ZS5wdXNoKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIHZpc2l0ZWQuYWRkKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goX2N1cnJlbnROb2RlKTtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICBfY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoX2N1cnJlbnROb2RlKTtcbiAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHVuZGlyZWN0ZWQgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvVW5kaXJlY3RlZCA9IGZ1bmN0aW9uIGRhZ1RvVW5kaXJlY3RlZChkYWcpIHtcbiAgICB2YXIgdW5kaXJlY3RlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB1bmRpcmVjdGVkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICB1bmRpcmVjdGVkLmdldChrZXkpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICB1bmRpcmVjdGVkLmdldChhZGphY2VudC5pZCkucHVzaCh7IGlkOiBrZXksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVuZGlyZWN0ZWQ7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHJldmVyc2VkIChkaXJlY3Rpb25zIGludmVydGVkKSB2ZXJzaW9uIG9mIGdpdmVuIGRhZ1xuICB2YXIgZGFnVG9SZXZlcnNlZCA9IGZ1bmN0aW9uIGRhZ1RvUmV2ZXJzZWQoZGFnKSB7XG4gICAgdmFyIHJldmVyc2VkID0gbmV3IE1hcCgpO1xuXG4gICAgZGFnLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldmVyc2VkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICByZXZlcnNlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXZlcnNlZDtcbiAgfTtcblxuICAvKioqKiAgYXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGluaXRpYWwgZHJhZnQgbGF5b3V0IHRvIGJldHRlciBhbGlnbiB3aXRoIGNvbnN0cmFpbmVkIG5vZGVzICoqKiovXG4gIC8vIHNvbHZlIHRoZSBPcnRob2dvbmFsIFByb2NydXN0ZWFuIFByb2JsZW0gdG8gcm90YXRlIGFuZC9vciByZWZsZWN0IGluaXRpYWwgZHJhZnQgbGF5b3V0XG4gIC8vIGhlcmUgd2UgZm9sbG93IHRoZSBzb2x1dGlvbiBpbiBDaGFwdGVyIDIwLjIgb2YgQm9yZywgSS4gJiBHcm9lbmVuLCBQLiAoMjAwNSkgTW9kZXJuIE11bHRpZGltZW5zaW9uYWwgU2NhbGluZzogVGhlb3J5IGFuZCBBcHBsaWNhdGlvbnMgXG5cbiAgLyogY29uc3RydWN0IHNvdXJjZSBhbmQgdGFyZ2V0IGNvbmZpZ3VyYXRpb25zICovXG5cbiAgdmFyIHRhcmdldE1hdHJpeCA9IFtdOyAvLyBBIC0gdGFyZ2V0IGNvbmZpZ3VyYXRpb25cbiAgdmFyIHNvdXJjZU1hdHJpeCA9IFtdOyAvLyBCIC0gc291cmNlIGNvbmZpZ3VyYXRpb24gXG4gIHZhciBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gZmFsc2U7IC8vIGZhbHNlIGZvciBubyB0cmFuc2Zvcm1hdGlvbiwgdHJ1ZSBmb3Igc3RhbmRhcnQgKFByb2NydXN0ZXMpIHRyYW5zZm9ybWF0aW9uIChyb3RhdGlvbiBhbmQvb3IgcmVmbGVjdGlvbilcbiAgdmFyIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7IC8vIGZhbHNlL3RydWUgZm9yIHJlZmxlY3Rpb24gY2hlY2ssICdyZWZsZWN0T25YJywgJ3JlZmxlY3RPblknIG9yICdyZWZsZWN0T25Cb3RoJyBmb3IgcmVmbGVjdGlvbiB0eXBlIGlmIG5lY2Vzc2FyeVxuICB2YXIgZml4ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRhZyA9IG5ldyBNYXAoKTsgLy8gYWRqYWNlbmN5IGxpc3QgdG8ga2VlcCBkaXJlY3RlZCBhY3ljbGljIGdyYXBoIChkYWcpIHRoYXQgY29uc2lzdHMgb2YgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIHZhciBkYWdVbmRpcmVjdGVkID0gbmV3IE1hcCgpOyAvLyB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICB2YXIgY29tcG9uZW50cyA9IFtdOyAvLyB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHNcblxuICAvLyBmaWxsIGZpeGVkTm9kZXMgY29sbGVjdGlvbiB0byB1c2UgbGF0ZXJcbiAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICBmaXhlZE5vZGVzLmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY29uc3RydWN0IGRhZyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIC8vIGNvbnN0cnVjdCBib3RoIGRpcmVjdGVkIGFuZCB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQubGVmdCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQubGVmdCkucHVzaCh7IGlkOiBjb25zdHJhaW50LnJpZ2h0LCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5sZWZ0LCBbeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYWcuaGFzKGNvbnN0cmFpbnQucmlnaHQpKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LnJpZ2h0LCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQudG9wKSkge1xuICAgICAgICAgIGRhZy5nZXQoY29uc3RyYWludC50b3ApLnB1c2goeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC50b3AsIFt7IGlkOiBjb25zdHJhaW50LmJvdHRvbSwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LmJvdHRvbSkpIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQuYm90dG9tLCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRhZ1VuZGlyZWN0ZWQgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnKTtcbiAgICBjb21wb25lbnRzID0gZmluZENvbXBvbmVudHMoZGFnVW5kaXJlY3RlZCk7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORykge1xuICAgIC8vIGZpcnN0IGNoZWNrIGZpeGVkIG5vZGUgY29uc3RyYWludFxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSwgaSkge1xuICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbbm9kZURhdGEucG9zaXRpb24ueCwgbm9kZURhdGEucG9zaXRpb24ueV07XG4gICAgICAgIHNvdXJjZU1hdHJpeFtpXSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV1dO1xuICAgICAgfSk7XG4gICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoZW4gY2hlY2sgYWxpZ25tZW50IGNvbnN0cmFpbnRcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKF9pNCkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25bX2k0XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHRhcmdldE1hdHJpeFtjb3VudF0gPSBbeFBvcywgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBzb3VyY2VNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdmVydGljYWxBbGlnbi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICBfbG9vcDIoX2k0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKF9pNSkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBhbGlnbm1lbnRTZXQuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaXhlZE5vZGVzLmhhcyh4KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5zaXplID4gMCkgeVBvcyA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGludGVyc2VjdGlvbi52YWx1ZXMoKS5uZXh0KCkudmFsdWUpXTtlbHNlIHlQb3MgPSBjYWxjdWxhdGVBdmdQb3NpdGlvbihhbGlnbm1lbnRTZXQpLnk7XG5cbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5UG9zXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGhvcml6b250YWxBbGlnbi5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgICBfbG9vcDMoX2k1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgICAgIHJlZmxlY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgLy8gZmluYWxseSBjaGVjayByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludFxuICAgICAgLy8gZmluZCBsYXJnZXN0IGNvbXBvbmVudCBpbiBkYWdcbiAgICAgIHZhciBsYXJnZXN0Q29tcG9uZW50U2l6ZSA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudEluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICBpZiAoY29tcG9uZW50c1tfaTZdLmxlbmd0aCA+IGxhcmdlc3RDb21wb25lbnRTaXplKSB7XG4gICAgICAgICAgbGFyZ2VzdENvbXBvbmVudFNpemUgPSBjb21wb25lbnRzW19pNl0ubGVuZ3RoO1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IF9pNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3QgZG9taW5hbnQsIHRoZW4gdGFrZSB0aGUgdm90ZXMgZm9yIHJlZmxlY3Rpb25cbiAgICAgIGlmIChsYXJnZXN0Q29tcG9uZW50U2l6ZSA8IGRhZ1VuZGlyZWN0ZWQuc2l6ZSAvIDIpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICByZWZsZWN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhcmdlc3QgY29tcG9uZW50IGZvciB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc3ViZ3JhcGhzIGluIHRoZSBsYXJnZXN0IGNvbXBvbmVudFxuICAgICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICBkYWcuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgICAgIGlmIChhZGphY2VudC5kaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IGxlZnQ6IG5vZGVJZCwgcmlnaHQ6IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25WZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQobm9kZUlkKS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uVmVydGljYWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYWRqYWNlbnQuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudC5wdXNoKHsgdG9wOiBub2RlSWQsIGJvdHRvbTogYWRqYWNlbnQuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50KTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHN1YmdyYXBoc1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBIb3Jpem9udGFsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChzdWJHcmFwaE9uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIpO1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQsIGkpIHtcbiAgICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBIb3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVswXSA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBWZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0cmFuc2Zvcm1hdGlvbiBpcyByZXF1aXJlZCwgdGhlbiBjYWxjdWxhdGUgYW5kIGFwcGx5IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgIGlmIChzdGFuZGFyZFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAvKiBjYWxjdWxhdGUgdHJhbnNmb3JtYXRpb24gbWF0cml4ICovXG4gICAgICB2YXIgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGFyZ2V0TWF0cml4VHJhbnNwb3NlID0gTWF0cml4LnRyYW5zcG9zZSh0YXJnZXRNYXRyaXgpOyAvLyBBJ1xuICAgICAgdmFyIHNvdXJjZU1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4KTsgLy8gQidcblxuICAgICAgLy8gY2VudHJhbGl6ZSB0cmFuc3Bvc2UgbWF0cmljZXNcbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHRhcmdldE1hdHJpeFRyYW5zcG9zZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgIHRhcmdldE1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYSh0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICAgIHNvdXJjZU1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYShzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIGFjdHVhbCBjYWxjdWxhdGlvbiBmb3IgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICB2YXIgdGVtcE1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KHRhcmdldE1hdHJpeFRyYW5zcG9zZSwgTWF0cml4LnRyYW5zcG9zZShzb3VyY2VNYXRyaXhUcmFuc3Bvc2UpKTsgLy8gdGVtcE1hdHJpeCA9IEEnQlxuICAgICAgdmFyIFNWRFJlc3VsdCA9IFNWRC5zdmQodGVtcE1hdHJpeCk7IC8vIFNWRChBJ0IpID0gVVNWJywgc3ZkIGZ1bmN0aW9uIHJldHVybnMgVSwgUyBhbmQgViBcbiAgICAgIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gTWF0cml4Lm11bHRNYXQoU1ZEUmVzdWx0LlYsIE1hdHJpeC50cmFuc3Bvc2UoU1ZEUmVzdWx0LlUpKTsgLy8gdHJhbnNmb3JtYXRpb25NYXRyaXggPSBUID0gVlUnXG5cbiAgICAgIC8qIGFwcGx5IGZvdW5kIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBvYnRhaW4gZmluYWwgZHJhZnQgbGF5b3V0ICovXG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBub2RlSW5kZXhlcy5zaXplOyBfaTgrKykge1xuICAgICAgICB2YXIgdGVtcDEgPSBbeENvb3Jkc1tfaThdLCB5Q29vcmRzW19pOF1dO1xuICAgICAgICB2YXIgdGVtcDIgPSBbdHJhbnNmb3JtYXRpb25NYXRyaXhbMF1bMF0sIHRyYW5zZm9ybWF0aW9uTWF0cml4WzFdWzBdXTtcbiAgICAgICAgdmFyIHRlbXAzID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzFdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVsxXV07XG4gICAgICAgIHhDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMik7XG4gICAgICAgIHlDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGxpZWQgb25seSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgZXhpc3RcbiAgICAgIGlmIChyZWZsZWN0aW9uVHlwZSkge1xuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMpIHtcbiAgICAvKioqKiAgZW5mb3JjZSBjb25zdHJhaW50cyBvbiB0aGUgdHJhbnNmb3JtZWQgZHJhZnQgbGF5b3V0ICoqKiovXG5cbiAgICAvKiBmaXJzdCBlbmZvcmNlIGZpeGVkIG5vZGUgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdHJhbnNsYXRpb25BbW91bnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdmFyIHBvc0luVGhlb3J5ID0geyB4OiB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeTogeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gfTtcbiAgICAgICAgdmFyIHBvc0Rlc2lyZWQgPSBub2RlRGF0YS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvc0RpZmYgPSBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zRGVzaXJlZCwgcG9zSW5UaGVvcnkpO1xuICAgICAgICB0cmFuc2xhdGlvbkFtb3VudC54ICs9IHBvc0RpZmYueDtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueSArPSBwb3NEaWZmLnk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnggLz0gY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGg7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC55IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuXG4gICAgICB4Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHhDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueDtcbiAgICAgIH0pO1xuXG4gICAgICB5Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHlDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICAgIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gPSBub2RlRGF0YS5wb3NpdGlvbi55O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogdGhlbiBlbmZvcmNlIGFsaWdubWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHhBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChfaTkpIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHhBbGlnbltfaTldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB4UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHhQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgeEFsaWduLmxlbmd0aDsgX2k5KyspIHtcbiAgICAgICAgICBfbG9vcDQoX2k5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgeUFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoX2kxMCkge1xuICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgeUFsaWduW19pMTBdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHlQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCB5QWxpZ24ubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgICBfbG9vcDUoX2kxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBmaW5hbGx5IGVuZm9yY2UgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBmaXhlZE5vZGVzT25Ib3Jpem9udGFsID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uVmVydGljYWwgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzICAgICAgXG4gICAgICAgIGZpeGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNiA9IGZ1bmN0aW9uIF9sb29wNihfaTExKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIFtdKTtcbiAgICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbX2kxMV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBfaTExKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIF9pMTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHZlcnRpY2FsQWxpZ25tZW50W19pMTFdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCB2ZXJ0aWNhbEFsaWdubWVudC5sZW5ndGg7IF9pMTErKykge1xuICAgICAgICAgICAgICBfbG9vcDYoX2kxMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3A3ID0gZnVuY3Rpb24gX2xvb3A3KF9pMTIpIHtcbiAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCBbXSk7XG4gICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnRbX2kxMl0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMikucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgX2kxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChob3Jpem9udGFsQWxpZ25tZW50W19pMTJdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICAgICAgICAgIF9sb29wNyhfaTEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGFncyAoc3ViZ3JhcGhzKSBmcm9tIG92ZXJhbGwgZGFnXG4gICAgICAgIHZhciBkYWdPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkYWdPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHZhciBfbG9vcDggPSBmdW5jdGlvbiBfbG9vcDgobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhZGphY2VudFtcImRpcmVjdGlvblwiXSA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBzb3VyY2VJZCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHsgaWQ6IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPbkhvcml6b250YWwuaGFzKHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uSG9yaXpvbnRhbC5oYXModGFyZ2V0Tm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgOiBub2RlSWQ7XG4gICAgICAgICAgICAgIGlmIChub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPblZlcnRpY2FsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLmdldChzb3VyY2VJZCkucHVzaCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uVmVydGljYWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQodGFyZ2V0Tm9kZS5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGRhZy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOChub2RlSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpbmQgc291cmNlIG5vZGVzIG9mIGVhY2ggY29tcG9uZW50IGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3NcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPbkhvcml6b250YWwgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPblZlcnRpY2FsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IGZpbmRDb21wb25lbnRzKHVuZGlyZWN0ZWRPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uVmVydGljYWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uSG9yaXpvbnRhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHJldmVyc2VkRGFnT25WZXJ0aWNhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsID0gW107XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNPbkhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdID0gW107XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKHJldmVyc2VkRGFnT25Ib3Jpem9udGFsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50c09uVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uVmVydGljYWwuZ2V0KG5vZGVJZCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50U291cmNlc09uVmVydGljYWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25Ib3Jpem9udGFsLCBcImhvcml6b250YWxcIiwgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCwgZHVtbXlQb3NpdGlvbnNGb3JWZXJ0aWNhbEFsaWdubWVudCwgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciBwb3NpdGlvbk1hcFZlcnRpY2FsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChkYWdPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIsIGZpeGVkTm9kZXNPblZlcnRpY2FsLCBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsKTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBiYXNlZCBvbiByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgX2xvb3A5ID0gZnVuY3Rpb24gX2xvb3A5KGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9sb29wMTAgPSBmdW5jdGlvbiBfbG9vcDEwKGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IHBvc2l0aW9uTWFwVmVydGljYWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDEwKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIG5ldyBjb29yZGluYXRlcyB0byBub2RlcyBhZnRlciBjb25zdHJhaW50IGhhbmRsaW5nXG4gIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgYWxsTm9kZXMubGVuZ3RoOyBfaTEzKyspIHtcbiAgICB2YXIgX25vZGUgPSBhbGxOb2Rlc1tfaTEzXTtcbiAgICBpZiAoX25vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBfbm9kZS5zZXRDZW50ZXIoeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnRIYW5kbGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41709\n')},1917:function(module){eval('(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module[\'default\']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, \'a\', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = "";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 28);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n"use strict";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw "Node is not incident with this edge";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n"use strict";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(5);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw "assert failed";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw "Incorrect edge source!";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw "Incorrect edge source and/or target";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw "Incorrect incidency!";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw "assert failed";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw "assert failed";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth) {\n        if (this.labelPosHorizontal == "left") {\n          this.rect.x -= this.labelWidth;\n          this.setWidth(width + this.labelWidth);\n        } else if (this.labelPosHorizontal == "center" && this.labelWidth > width) {\n          this.rect.x -= (this.labelWidth - width) / 2;\n          this.setWidth(this.labelWidth);\n        } else if (this.labelPosHorizontal == "right") {\n          this.setWidth(width + this.labelWidth);\n        }\n      }\n\n      if (this.labelHeight) {\n        if (this.labelPosVertical == "top") {\n          this.rect.y -= this.labelHeight;\n          this.setHeight(height + this.labelHeight);\n        } else if (this.labelPosVertical == "center" && this.labelHeight > height) {\n          this.rect.y -= (this.labelHeight - height) / 2;\n          this.setHeight(this.labelHeight);\n        } else if (this.labelPosVertical == "bottom") {\n          this.setHeight(height + this.labelHeight);\n        }\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw "assert failed";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_17290__) {\n\n"use strict";\n\n\nvar LayoutConstants = __nested_webpack_require_17290__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_19670__) {\n\n"use strict";\n\n\nvar LGraphObject = __nested_webpack_require_19670__(2);\nvar Integer = __nested_webpack_require_19670__(10);\nvar LayoutConstants = __nested_webpack_require_19670__(0);\nvar LGraphManager = __nested_webpack_require_19670__(7);\nvar LNode = __nested_webpack_require_19670__(3);\nvar LEdge = __nested_webpack_require_19670__(1);\nvar RectangleD = __nested_webpack_require_19670__(13);\nvar Point = __nested_webpack_require_19670__(12);\nvar LinkedList = __nested_webpack_require_19670__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw "Graph has no graph mgr!";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw "Node already in graph!";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw "Source or target not in graph!";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw "Both owners must be this graph!";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw "Node is null!";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw "Owner graph is invalid!";\n    }\n    if (this.graphManager == null) {\n      throw "Owner graph manager is invalid!";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw "Node not in owner node list!";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw "Edge is null!";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw "Source and/or target is null!";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw "Source and/or target owner is invalid!";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw "Source and/or target doesn\'t know this edge!";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw "Not in owner\'s edge list!";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw "assert failed";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_29738__) {\n\n"use strict";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_29738__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_29738__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of \'instanceof\' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw "Graph is null!";\n    }\n    if (parentNode == null) {\n      throw "Parent node is null!";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw "Graph already in this graph mgr!";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw "Already has a parent!";\n    }\n    if (parentNode.child != null) {\n      throw "Already has a child!";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw "Source not in this graph mgr!";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw "Target not in this graph mgr!";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw "Edge already in inter-graph edge list!";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw "Edge source and/or target is null!";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw "Edge already in source and/or target incidency list!";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw "Graph not in this graph mgr";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw "Invalid parent node!";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw "Edge is null!";\n    }\n    if (!edge.isInterGraph) {\n      throw "Not an inter-graph edge!";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw "Source and/or target is null!";\n    }\n\n    // remove edge from source and target nodes\' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw "Source and/or target doesn\'t know this edge!";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager\'s inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw "Edge owner graph or owner graph manager is null!";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw "Not in owner graph manager\'s edge list!";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw "assert failed";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw "Root not in this graph mgr!";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode("Root node");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw "assert failed";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw "assert failed";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw "assert failed";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n  var edgesToRemove = [];\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      edgesToRemove.push(edge);\n    }\n  }\n\n  // Remove invalid edges from graph manager\n  for (var i = 0; i < edgesToRemove.length; i++) {\n    this.remove(edgesToRemove[i]);\n  }\n\n  // Invalid edges are cleared, so return false\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_41052__) {\n\n"use strict";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_41052__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw "assert failed";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA\'s and rectB\'s diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n/**\n * This method checks and calculates the intersection of \n * a line segment and a circle.\n */\nIGeometry.findCircleLineIntersections = function (Ex, Ey, Lx, Ly, Cx, Cy, r) {\n\n  // E is the starting point of the ray,\n  // L is the end point of the ray,\n  // C is the center of sphere you\'re testing against\n  // r is the radius of that sphere\n\n  // Compute:\n  // d = L - E ( Direction vector of ray, from start to end )\n  // f = E - C ( Vector from center sphere to ray start )\n\n  // Then the intersection is found by..\n  // P = E + t * d\n  // This is a parametric equation:\n  // Px = Ex + tdx\n  // Py = Ey + tdy\n\n  // get a, b, c values\n  var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n  var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n  var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n\n  // get discriminant\n  var disc = b * b - 4 * a * c;\n  if (disc >= 0) {\n    // insert into quadratic formula\n    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var intersections = null;\n    if (t1 >= 0 && t1 <= 1) {\n      // t1 is the intersection, and it\'s closer than t2\n      // (since t1 uses -b - discriminant)\n      // Impale, Poke\n      return [t1];\n    }\n\n    // here t1 didn\'t intersect so we are either started\n    // inside the sphere or completely past it\n    if (t2 >= 0 && t2 <= 1) {\n      // ExitWound\n      return [t2];\n    }\n\n    return intersections;\n  } else return null;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: "size",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: "insertBefore",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: "insertAfter",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: "insertNodeBefore",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: "insertNodeAfter",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: "push",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: "unshift",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: "remove",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: "pop",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: "popNode",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: "shift",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: "shiftNode",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: "get_object_at",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: "set_object_at",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == \'number\' && typeof y == \'number\' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == \'Point\' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == \'Point\' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == \'number\' && typeof y == \'number\' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == "Point") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + "[x=" + this.x + ",y=" + this.y + "]";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return "Object#" + id + "";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === "undefined" ? "undefined" : _typeof(arg);\n  return arg == null || type != "object" && type != "function";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_66321__) {\n\n"use strict";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_66321__(0);\nvar LGraphManager = __nested_webpack_require_66321__(7);\nvar LNode = __nested_webpack_require_66321__(3);\nvar LEdge = __nested_webpack_require_66321__(1);\nvar LGraph = __nested_webpack_require_66321__(6);\nvar PointD = __nested_webpack_require_66321__(5);\nvar Transform = __nested_webpack_require_66321__(17);\nvar Emitter = __nested_webpack_require_66321__(29);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === \'during\') {\n    // If this is a \'during\' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : "Should not be called on sub-layout!";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven\'t previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint\'s location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_84109__) {\n\n"use strict";\n\n\nvar PointD = __nested_webpack_require_84109__(5);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_86996__) {\n\n"use strict";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_86996__(15);\nvar FDLayoutConstants = __nested_webpack_require_86996__(4);\nvar LayoutConstants = __nested_webpack_require_86996__(0);\nvar IGeometry = __nested_webpack_require_86996__(8);\nvar IMath = __nested_webpack_require_86996__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var originalIdealLength;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    originalIdealLength = edge.idealLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  // Reassign this attribute by using new constant value\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = edge.edgeElasticity * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      // Here we use half of the nodes\' repulsion values for backward compatibility\n      repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_103214__) {\n\n"use strict";\n\n\nvar LEdge = __nested_webpack_require_103214__(1);\nvar FDLayoutConstants = __nested_webpack_require_103214__(4);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n\n  // Ideal length and elasticity value for this edge\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_103820__) {\n\n"use strict";\n\n\nvar LNode = __nested_webpack_require_103820__(3);\nvar FDLayoutConstants = __nested_webpack_require_103820__(4);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n\n  // Repulsion value of this node\n  this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_105759__) {\n\n"use strict";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_105759__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_106487__) {\n\n"use strict";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_106487__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\n// Some matrix (1d and 2d array) operations\nfunction Matrix() {}\n\n/**\n * matrix multiplication\n * array1, array2 and result are 2d arrays\n */\nMatrix.multMat = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array2[0].length; j++) {\n      result[i][j] = 0;\n      for (var k = 0; k < array1[0].length; k++) {\n        result[i][j] += array1[i][k] * array2[k][j];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * matrix transpose\n * array and result are 2d arrays\n */\nMatrix.transpose = function (array) {\n  var result = [];\n\n  for (var i = 0; i < array[0].length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array.length; j++) {\n      result[i][j] = array[j][i];\n    }\n  }\n\n  return result;\n};\n\n/**\n * multiply array with constant\n * array and result are 1d arrays\n */\nMatrix.multCons = function (array, constant) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] * constant;\n  }\n\n  return result;\n};\n\n/**\n * substract two arrays\n * array1, array2 and result are 1d arrays\n */\nMatrix.minusOp = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = array1[i] - array2[i];\n  }\n\n  return result;\n};\n\n/**\n * dot product of two arrays with same size\n * array1 and array2 are 1d arrays\n */\nMatrix.dotProduct = function (array1, array2) {\n  var product = 0;\n\n  for (var i = 0; i < array1.length; i++) {\n    product += array1[i] * array2[i];\n  }\n\n  return product;\n};\n\n/**\n * magnitude of an array\n * array is 1d array\n */\nMatrix.mag = function (array) {\n  return Math.sqrt(this.dotProduct(array, array));\n};\n\n/**\n * normalization of an array\n * array and result are 1d array\n */\nMatrix.normalize = function (array) {\n  var result = [];\n  var magnitude = this.mag(array);\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] / magnitude;\n  }\n\n  return result;\n};\n\n/**\n * multiply an array with centering matrix\n * array and result are 1d array\n */\nMatrix.multGamma = function (array) {\n  var result = [];\n  var sum = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n\n  sum *= -1 / array.length;\n\n  for (var _i = 0; _i < array.length; _i++) {\n    result[_i] = sum + array[_i];\n  }\n  return result;\n};\n\n/**\n * a special matrix multiplication\n * result = 0.5 * C * INV * C^T * array\n * array and result are 1d, C and INV are 2d arrays\n */\nMatrix.multL = function (array, C, INV) {\n  var result = [];\n  var temp1 = [];\n  var temp2 = [];\n\n  // multiply by C^T\n  for (var i = 0; i < C[0].length; i++) {\n    var sum = 0;\n    for (var j = 0; j < C.length; j++) {\n      sum += -0.5 * C[j][i] * array[j];\n    }\n    temp1[i] = sum;\n  }\n  // multiply the result by INV\n  for (var _i2 = 0; _i2 < INV.length; _i2++) {\n    var _sum = 0;\n    for (var _j = 0; _j < INV.length; _j++) {\n      _sum += INV[_i2][_j] * temp1[_j];\n    }\n    temp2[_i2] = _sum;\n  }\n  // multiply the result by C\n  for (var _i3 = 0; _i3 < C.length; _i3++) {\n    var _sum2 = 0;\n    for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n      _sum2 += C[_i3][_j2] * temp2[_j2];\n    }\n    result[_i3] = _sum2;\n  }\n\n  return result;\n};\n\nmodule.exports = Matrix;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_111039__) {\n\n"use strict";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare\'s partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_111039__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: \'_quicksort\',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: \'_partition\',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: \'_get\',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: \'_set\',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: \'_swap\',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: \'_defaultCompareFunction\',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\n// Singular Value Decomposition implementation\nfunction SVD() {};\n\n/* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS\n   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.\n   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.\n   An object that includes singular value components is created for return. \n   The types of input parameters of the hypot function are removed. \n   let is used instead of var for the variable initialization.\n*/\n/*\n                               Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      "License" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      "Licensor" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      "Legal Entity" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      "control" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      "You" (or "Your") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      "Source" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      "Object" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      "Work" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      "Derivative Works" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      "Contribution" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, "submitted"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as "Not a Contribution."\n\n      "Contributor" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a "NOTICE" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an "AS IS" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets "{}"\n      replaced with your own identifying information. (Don\'t include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same "printed page" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the "License");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an "AS IS" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nSVD.svd = function (A) {\n  this.U = null;\n  this.V = null;\n  this.s = null;\n  this.m = 0;\n  this.n = 0;\n  this.m = A.length;\n  this.n = A[0].length;\n  var nu = Math.min(this.m, this.n);\n  this.s = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(Math.min(this.m + 1, this.n));\n  this.U = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.m, nu]);\n  this.V = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.n, this.n]);\n  var e = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.n);\n  var work = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.m);\n  var wantu = true;\n  var wantv = true;\n  var nct = Math.min(this.m - 1, this.n);\n  var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n  for (var k = 0; k < Math.max(nct, nrt); k++) {\n    if (k < nct) {\n      this.s[k] = 0;\n      for (var i = k; i < this.m; i++) {\n        this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n      }\n      ;\n      if (this.s[k] !== 0.0) {\n        if (A[k][k] < 0.0) {\n          this.s[k] = -this.s[k];\n        }\n        for (var _i = k; _i < this.m; _i++) {\n          A[_i][k] /= this.s[k];\n        }\n        ;\n        A[k][k] += 1.0;\n      }\n      this.s[k] = -this.s[k];\n    }\n    for (var j = k + 1; j < this.n; j++) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k < nct, this.s[k] !== 0.0)) {\n        var t = 0;\n        for (var _i2 = k; _i2 < this.m; _i2++) {\n          t += A[_i2][k] * A[_i2][j];\n        }\n        ;\n        t = -t / A[k][k];\n        for (var _i3 = k; _i3 < this.m; _i3++) {\n          A[_i3][j] += t * A[_i3][k];\n        }\n        ;\n      }\n      e[j] = A[k][j];\n    }\n    ;\n    if (function (lhs, rhs) {\n      return lhs && rhs;\n    }(wantu, k < nct)) {\n      for (var _i4 = k; _i4 < this.m; _i4++) {\n        this.U[_i4][k] = A[_i4][k];\n      }\n      ;\n    }\n    if (k < nrt) {\n      e[k] = 0;\n      for (var _i5 = k + 1; _i5 < this.n; _i5++) {\n        e[k] = SVD.hypot(e[k], e[_i5]);\n      }\n      ;\n      if (e[k] !== 0.0) {\n        if (e[k + 1] < 0.0) {\n          e[k] = -e[k];\n        }\n        for (var _i6 = k + 1; _i6 < this.n; _i6++) {\n          e[_i6] /= e[k];\n        }\n        ;\n        e[k + 1] += 1.0;\n      }\n      e[k] = -e[k];\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k + 1 < this.m, e[k] !== 0.0)) {\n        for (var _i7 = k + 1; _i7 < this.m; _i7++) {\n          work[_i7] = 0.0;\n        }\n        ;\n        for (var _j = k + 1; _j < this.n; _j++) {\n          for (var _i8 = k + 1; _i8 < this.m; _i8++) {\n            work[_i8] += e[_j] * A[_i8][_j];\n          }\n          ;\n        }\n        ;\n        for (var _j2 = k + 1; _j2 < this.n; _j2++) {\n          var _t = -e[_j2] / e[k + 1];\n          for (var _i9 = k + 1; _i9 < this.m; _i9++) {\n            A[_i9][_j2] += _t * work[_i9];\n          }\n          ;\n        }\n        ;\n      }\n      if (wantv) {\n        for (var _i10 = k + 1; _i10 < this.n; _i10++) {\n          this.V[_i10][k] = e[_i10];\n        };\n      }\n    }\n  };\n  var p = Math.min(this.n, this.m + 1);\n  if (nct < this.n) {\n    this.s[nct] = A[nct][nct];\n  }\n  if (this.m < p) {\n    this.s[p - 1] = 0.0;\n  }\n  if (nrt + 1 < p) {\n    e[nrt] = A[nrt][p - 1];\n  }\n  e[p - 1] = 0.0;\n  if (wantu) {\n    for (var _j3 = nct; _j3 < nu; _j3++) {\n      for (var _i11 = 0; _i11 < this.m; _i11++) {\n        this.U[_i11][_j3] = 0.0;\n      }\n      ;\n      this.U[_j3][_j3] = 1.0;\n    };\n    for (var _k = nct - 1; _k >= 0; _k--) {\n      if (this.s[_k] !== 0.0) {\n        for (var _j4 = _k + 1; _j4 < nu; _j4++) {\n          var _t2 = 0;\n          for (var _i12 = _k; _i12 < this.m; _i12++) {\n            _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n          };\n          _t2 = -_t2 / this.U[_k][_k];\n          for (var _i13 = _k; _i13 < this.m; _i13++) {\n            this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n          };\n        };\n        for (var _i14 = _k; _i14 < this.m; _i14++) {\n          this.U[_i14][_k] = -this.U[_i14][_k];\n        };\n        this.U[_k][_k] = 1.0 + this.U[_k][_k];\n        for (var _i15 = 0; _i15 < _k - 1; _i15++) {\n          this.U[_i15][_k] = 0.0;\n        };\n      } else {\n        for (var _i16 = 0; _i16 < this.m; _i16++) {\n          this.U[_i16][_k] = 0.0;\n        };\n        this.U[_k][_k] = 1.0;\n      }\n    };\n  }\n  if (wantv) {\n    for (var _k2 = this.n - 1; _k2 >= 0; _k2--) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(_k2 < nrt, e[_k2] !== 0.0)) {\n        for (var _j5 = _k2 + 1; _j5 < nu; _j5++) {\n          var _t3 = 0;\n          for (var _i17 = _k2 + 1; _i17 < this.n; _i17++) {\n            _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n          };\n          _t3 = -_t3 / this.V[_k2 + 1][_k2];\n          for (var _i18 = _k2 + 1; _i18 < this.n; _i18++) {\n            this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n          };\n        };\n      }\n      for (var _i19 = 0; _i19 < this.n; _i19++) {\n        this.V[_i19][_k2] = 0.0;\n      };\n      this.V[_k2][_k2] = 1.0;\n    };\n  }\n  var pp = p - 1;\n  var iter = 0;\n  var eps = Math.pow(2.0, -52.0);\n  var tiny = Math.pow(2.0, -966.0);\n  while (p > 0) {\n    var _k3 = void 0;\n    var kase = void 0;\n    for (_k3 = p - 2; _k3 >= -1; _k3--) {\n      if (_k3 === -1) {\n        break;\n      }\n      if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n        e[_k3] = 0.0;\n        break;\n      }\n    };\n    if (_k3 === p - 2) {\n      kase = 4;\n    } else {\n      var ks = void 0;\n      for (ks = p - 1; ks >= _k3; ks--) {\n        if (ks === _k3) {\n          break;\n        }\n        var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);\n        if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n          this.s[ks] = 0.0;\n          break;\n        }\n      };\n      if (ks === _k3) {\n        kase = 3;\n      } else if (ks === p - 1) {\n        kase = 1;\n      } else {\n        kase = 2;\n        _k3 = ks;\n      }\n    }\n    _k3++;\n    switch (kase) {\n      case 1:\n        {\n          var f = e[p - 2];\n          e[p - 2] = 0.0;\n          for (var _j6 = p - 2; _j6 >= _k3; _j6--) {\n            var _t5 = SVD.hypot(this.s[_j6], f);\n            var cs = this.s[_j6] / _t5;\n            var sn = f / _t5;\n            this.s[_j6] = _t5;\n            if (_j6 !== _k3) {\n              f = -sn * e[_j6 - 1];\n              e[_j6 - 1] = cs * e[_j6 - 1];\n            }\n            if (wantv) {\n              for (var _i20 = 0; _i20 < this.n; _i20++) {\n                _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                this.V[_i20][_j6] = _t5;\n              };\n            }\n          };\n        };\n        break;\n      case 2:\n        {\n          var _f = e[_k3 - 1];\n          e[_k3 - 1] = 0.0;\n          for (var _j7 = _k3; _j7 < p; _j7++) {\n            var _t6 = SVD.hypot(this.s[_j7], _f);\n            var _cs = this.s[_j7] / _t6;\n            var _sn = _f / _t6;\n            this.s[_j7] = _t6;\n            _f = -_sn * e[_j7];\n            e[_j7] = _cs * e[_j7];\n            if (wantu) {\n              for (var _i21 = 0; _i21 < this.m; _i21++) {\n                _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                this.U[_i21][_j7] = _t6;\n              };\n            }\n          };\n        };\n        break;\n      case 3:\n        {\n          var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n          var sp = this.s[p - 1] / scale;\n          var spm1 = this.s[p - 2] / scale;\n          var epm1 = e[p - 2] / scale;\n          var sk = this.s[_k3] / scale;\n          var ek = e[_k3] / scale;\n          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n          var c = sp * epm1 * (sp * epm1);\n          var shift = 0.0;\n          if (function (lhs, rhs) {\n            return lhs || rhs;\n          }(b !== 0.0, c !== 0.0)) {\n            shift = Math.sqrt(b * b + c);\n            if (b < 0.0) {\n              shift = -shift;\n            }\n            shift = c / (b + shift);\n          }\n          var _f2 = (sk + sp) * (sk - sp) + shift;\n          var g = sk * ek;\n          for (var _j8 = _k3; _j8 < p - 1; _j8++) {\n            var _t7 = SVD.hypot(_f2, g);\n            var _cs2 = _f2 / _t7;\n            var _sn2 = g / _t7;\n            if (_j8 !== _k3) {\n              e[_j8 - 1] = _t7;\n            }\n            _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n            e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n            g = _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n            if (wantv) {\n              for (var _i22 = 0; _i22 < this.n; _i22++) {\n                _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8] = _t7;\n              };\n            }\n            _t7 = SVD.hypot(_f2, g);\n            _cs2 = _f2 / _t7;\n            _sn2 = g / _t7;\n            this.s[_j8] = _t7;\n            _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n            g = _sn2 * e[_j8 + 1];\n            e[_j8 + 1] = _cs2 * e[_j8 + 1];\n            if (wantu && _j8 < this.m - 1) {\n              for (var _i23 = 0; _i23 < this.m; _i23++) {\n                _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8] = _t7;\n              };\n            }\n          };\n          e[p - 2] = _f2;\n          iter = iter + 1;\n        };\n        break;\n      case 4:\n        {\n          if (this.s[_k3] <= 0.0) {\n            this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;\n            if (wantv) {\n              for (var _i24 = 0; _i24 <= pp; _i24++) {\n                this.V[_i24][_k3] = -this.V[_i24][_k3];\n              };\n            }\n          }\n          while (_k3 < pp) {\n            if (this.s[_k3] >= this.s[_k3 + 1]) {\n              break;\n            }\n            var _t8 = this.s[_k3];\n            this.s[_k3] = this.s[_k3 + 1];\n            this.s[_k3 + 1] = _t8;\n            if (wantv && _k3 < this.n - 1) {\n              for (var _i25 = 0; _i25 < this.n; _i25++) {\n                _t8 = this.V[_i25][_k3 + 1];\n                this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                this.V[_i25][_k3] = _t8;\n              };\n            }\n            if (wantu && _k3 < this.m - 1) {\n              for (var _i26 = 0; _i26 < this.m; _i26++) {\n                _t8 = this.U[_i26][_k3 + 1];\n                this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                this.U[_i26][_k3] = _t8;\n              };\n            }\n            _k3++;\n          };\n          iter = 0;\n          p--;\n        };\n        break;\n    }\n  };\n  var result = { U: this.U, V: this.V, S: this.s };\n  return result;\n};\n\n// sqrt(a^2 + b^2) without under/overflow.\nSVD.hypot = function (a, b) {\n  var r = void 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    r = Math.abs(a) * Math.sqrt(1 + r * r);\n  } else if (b != 0) {\n    r = a / b;\n    r = Math.abs(b) * Math.sqrt(1 + r * r);\n  } else {\n    r = 0.0;\n  }\n  return r;\n};\n\nmodule.exports = SVD;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: "getScore",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: "getAlignments",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: "computeGrids",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: "alignmentTraceback",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: "",\n                seq2: ""\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: \'-\' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: \'-\' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: "getAllIndexes",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: "arrayAllMaxIndexes",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __nested_webpack_require_145732__) {\n\n"use strict";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_145732__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_145732__(4);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_145732__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_145732__(20);\nlayoutBase.DimensionD = __nested_webpack_require_145732__(21);\nlayoutBase.HashMap = __nested_webpack_require_145732__(22);\nlayoutBase.HashSet = __nested_webpack_require_145732__(23);\nlayoutBase.IGeometry = __nested_webpack_require_145732__(8);\nlayoutBase.IMath = __nested_webpack_require_145732__(9);\nlayoutBase.Integer = __nested_webpack_require_145732__(10);\nlayoutBase.Point = __nested_webpack_require_145732__(12);\nlayoutBase.PointD = __nested_webpack_require_145732__(5);\nlayoutBase.RandomSeed = __nested_webpack_require_145732__(16);\nlayoutBase.RectangleD = __nested_webpack_require_145732__(13);\nlayoutBase.Transform = __nested_webpack_require_145732__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_145732__(14);\nlayoutBase.Quicksort = __nested_webpack_require_145732__(25);\nlayoutBase.LinkedList = __nested_webpack_require_145732__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_145732__(2);\nlayoutBase.LGraph = __nested_webpack_require_145732__(6);\nlayoutBase.LEdge = __nested_webpack_require_145732__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_145732__(7);\nlayoutBase.LNode = __nested_webpack_require_145732__(3);\nlayoutBase.Layout = __nested_webpack_require_145732__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_145732__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_145732__(27);\nlayoutBase.Matrix = __nested_webpack_require_145732__(24);\nlayoutBase.SVD = __nested_webpack_require_145732__(26);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n"use strict";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0EsWUFBWSxnQ0FBbUI7O0FBRS9CO0FBQ0EsV0FBVyxnQ0FBbUIsS0FBSztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksZ0NBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLHFHQUFxRyxxQkFBcUIsbUJBQW1COztBQUU3STs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSxtQ0FBbUMsMEJBQTBCLDBDQUEwQyxnQkFBZ0IsT0FBTyxvQkFBb0IsZUFBZSxPQUFPOztBQUV4SyxzQkFBc0IsZ0NBQW1CO0FBQ3pDLG9CQUFvQixnQ0FBbUI7QUFDdkMsWUFBWSxnQ0FBbUI7QUFDL0IsWUFBWSxnQ0FBbUI7QUFDL0IsYUFBYSxnQ0FBbUI7QUFDaEMsYUFBYSxnQ0FBbUI7QUFDaEMsZ0JBQWdCLGdDQUFtQjtBQUNuQyxjQUFjLGdDQUFtQjs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSxhQUFhLGdDQUFtQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBLG1DQUFtQywwQkFBMEIsMENBQTBDLGdCQUFnQixPQUFPLG9CQUFvQixlQUFlLE9BQU87O0FBRXhLLGFBQWEsZ0NBQW1CO0FBQ2hDLHdCQUF3QixnQ0FBbUI7QUFDM0Msc0JBQXNCLGdDQUFtQjtBQUN6QyxnQkFBZ0IsZ0NBQW1CO0FBQ25DLFlBQVksZ0NBQW1COztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLG1CQUFtQjtBQUNuQzs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0Isb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGNBQWM7QUFDckMseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHVCQUF1QjtBQUMxRCxxQ0FBcUMsdUJBQXVCO0FBQzVEO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsWUFBWSxpQ0FBbUI7QUFDL0Isd0JBQXdCLGlDQUFtQjs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBLFlBQVksaUNBQW1CO0FBQy9CLHdCQUF3QixpQ0FBbUI7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOzs7QUFHQSx3QkFBd0IsaUNBQW1COztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBLHdCQUF3QixpQ0FBbUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBOztBQUVBOztBQUVBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7O0FBR0EsaUNBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELCtEQUErRCx5REFBeUQscUVBQXFFLDZEQUE2RCx3QkFBd0I7O0FBRWpqQixrREFBa0QsMENBQTBDOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlDQUFtQjs7QUFFcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVEOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRkFBaUY7QUFDakY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0Msc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQyxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUEsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLG1JQUFtSTs7QUFFbkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSx5RkFBeUY7QUFDekY7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUNBQW1CO0FBQ3pDLCtCQUErQixpQ0FBbUI7QUFDbEQsMEJBQTBCLGlDQUFtQjtBQUM3QywwQkFBMEIsaUNBQW1CO0FBQzdDLHdCQUF3QixpQ0FBbUI7QUFDM0MscUJBQXFCLGlDQUFtQjtBQUN4QyxxQkFBcUIsaUNBQW1CO0FBQ3hDLHVCQUF1QixpQ0FBbUI7QUFDMUMsbUJBQW1CLGlDQUFtQjtBQUN0QyxxQkFBcUIsaUNBQW1CO0FBQ3hDLG1CQUFtQixpQ0FBbUI7QUFDdEMsb0JBQW9CLGlDQUFtQjtBQUN2Qyx3QkFBd0IsaUNBQW1CO0FBQzNDLHdCQUF3QixpQ0FBbUI7QUFDM0MsdUJBQXVCLGlDQUFtQjtBQUMxQywrQkFBK0IsaUNBQW1CO0FBQ2xELHVCQUF1QixpQ0FBbUI7QUFDMUMsd0JBQXdCLGlDQUFtQjtBQUMzQywwQkFBMEIsaUNBQW1CO0FBQzdDLG9CQUFvQixpQ0FBbUI7QUFDdkMsbUJBQW1CLGlDQUFtQjtBQUN0QywyQkFBMkIsaUNBQW1CO0FBQzlDLG1CQUFtQixpQ0FBbUI7QUFDdEMsb0JBQW9CLGlDQUFtQjtBQUN2Qyw2QkFBNkIsaUNBQW1CO0FBQ2hELDZCQUE2QixpQ0FBbUI7QUFDaEQsb0JBQW9CLGlDQUFtQjtBQUN2QyxpQkFBaUIsaUNBQW1COztBQUVwQzs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jeXRvc2NhcGUtZmNvc2Uvbm9kZV9tb2R1bGVzL2xheW91dC1iYXNlL2xheW91dC1iYXNlLmpzP2EzOTIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJsYXlvdXRCYXNlXCJdID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGlkZW50aXR5IGZ1bmN0aW9uIGZvciBjYWxsaW5nIGhhcm1vbnkgaW1wb3J0cyB3aXRoIHRoZSBjb3JyZWN0IGNvbnRleHRcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjgpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vKipcclxuICogTGF5b3V0IFF1YWxpdHk6IDA6ZHJhZnQsIDE6ZGVmYXVsdCwgMjpwcm9vZlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5RVUFMSVRZID0gMTtcblxuLyoqXHJcbiAqIERlZmF1bHQgcGFyYW1ldGVyc1xyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQgPSBmYWxzZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUID0gdHJ1ZTtcbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EID0gNTA7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IGZhbHNlO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogR2VuZXJhbCBvdGhlciBjb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKlxyXG4gKiBNYXJnaW5zIG9mIGEgZ3JhcGggdG8gYmUgYXBwbGllZCBvbiBib3VkaW5nIHJlY3RhbmdsZSBvZiBpdHMgY29udGVudHMuIFdlXHJcbiAqIGFzc3VtZSBtYXJnaW5zIG9uIGFsbCBmb3VyIHNpZGVzIHRvIGJlIHVuaWZvcm0uXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOID0gMTU7XG5cbi8qXHJcbiAqIFdoZXRoZXIgdG8gY29uc2lkZXIgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucyBvciBub3RcclxuICovXG5MYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gZmFsc2U7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogRGVmYXVsdCBkaW1lbnNpb24gb2YgYSBub24tY29tcG91bmQgbm9kZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfSEFMRl9TSVpFID0gTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX1NJWkUgLyAyO1xuXG4vKlxyXG4gKiBFbXB0eSBjb21wb3VuZCBub2RlIHNpemUuIFdoZW4gYSBjb21wb3VuZCBub2RlIGlzIGVtcHR5LCBpdHMgYm90aFxyXG4gKiBkaW1lbnNpb25zIHNob3VsZCBiZSBvZiB0aGlzIHZhbHVlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkUgPSA0MDtcblxuLypcclxuICogTWluaW11bSBsZW5ndGggdGhhdCBhbiBlZGdlIHNob3VsZCB0YWtlIGR1cmluZyBsYXlvdXRcclxuICovXG5MYXlvdXRDb25zdGFudHMuTUlOX0VER0VfTEVOR1RIID0gMTtcblxuLypcclxuICogV29ybGQgYm91bmRhcmllcyB0aGF0IGxheW91dCBvcGVyYXRlcyBvblxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSA9IDEwMDAwMDA7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCByYW5kb20gcG9zaXRpb25pbmcgY2FuIGJlIHBlcmZvcm1lZCB3aXRoXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgLyAxMDAwO1xuXG4vKlxyXG4gKiBDb29yZGluYXRlcyBvZiB0aGUgd29ybGQgY2VudGVyXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YID0gMTIwMDtcbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSA9IDkwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBMYXlvdXRDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xudmFyIElNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuZnVuY3Rpb24gTEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExHcmFwaE9iamVjdC5jYWxsKHRoaXMsIHZFZGdlKTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZhbHNlO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZFZGdlO1xuICB0aGlzLmJlbmRwb2ludHMgPSBbXTtcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5MRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExHcmFwaE9iamVjdCkge1xuICBMRWRnZVtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc291cmNlO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzSW50ZXJHcmFwaCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNJbnRlckdyYXBoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0O1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldEJlbmRwb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJlbmRwb2ludHM7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0TGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0U291cmNlSW5MY2EgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZUluTGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFRhcmdldEluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50YXJnZXRJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICh0aGlzLnNvdXJjZSA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnRhcmdldDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhcmdldCA9PT0gbm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIk5vZGUgaXMgbm90IGluY2lkZW50IHdpdGggdGhpcyBlZGdlXCI7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRPdGhlckVuZEluR3JhcGggPSBmdW5jdGlvbiAobm9kZSwgZ3JhcGgpIHtcbiAgdmFyIG90aGVyRW5kID0gdGhpcy5nZXRPdGhlckVuZChub2RlKTtcbiAgdmFyIHJvb3QgPSBncmFwaC5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSBncmFwaCkge1xuICAgICAgcmV0dXJuIG90aGVyRW5kO1xuICAgIH1cblxuICAgIGlmIChvdGhlckVuZC5nZXRPd25lcigpID09IHJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG90aGVyRW5kID0gb3RoZXJFbmQuZ2V0T3duZXIoKS5nZXRQYXJlbnQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsaXBQb2ludENvb3JkaW5hdGVzID0gbmV3IEFycmF5KDQpO1xuXG4gIHRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0ID0gSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbih0aGlzLnRhcmdldC5nZXRSZWN0KCksIHRoaXMuc291cmNlLmdldFJlY3QoKSwgY2xpcFBvaW50Q29vcmRpbmF0ZXMpO1xuXG4gIGlmICghdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICB0aGlzLmxlbmd0aFggPSBjbGlwUG9pbnRDb29yZGluYXRlc1swXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzJdO1xuICAgIHRoaXMubGVuZ3RoWSA9IGNsaXBQb2ludENvb3JkaW5hdGVzWzFdIC0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbM107XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhYKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFkpIDwgMS4wKSB7XG4gICAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhYICogdGhpcy5sZW5ndGhYICsgdGhpcy5sZW5ndGhZICogdGhpcy5sZW5ndGhZKTtcbiAgfVxufTtcblxuTEVkZ2UucHJvdG90eXBlLnVwZGF0ZUxlbmd0aFNpbXBsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5sZW5ndGhYID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWCgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWCgpO1xuICB0aGlzLmxlbmd0aFkgPSB0aGlzLnRhcmdldC5nZXRDZW50ZXJZKCkgLSB0aGlzLnNvdXJjZS5nZXRDZW50ZXJZKCk7XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFggPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgIHRoaXMubGVuZ3RoWSA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhZKTtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTEdyYXBoT2JqZWN0KHZHcmFwaE9iamVjdCkge1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZHcmFwaE9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTEdyYXBoT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbnZhciBJbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIExOb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMSA6IExOb2RlKExHcmFwaE1hbmFnZXIgZ20sIFBvaW50IGxvYywgRGltZW5zaW9uIHNpemUsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKHNpemUgPT0gbnVsbCAmJiB2Tm9kZSA9PSBudWxsKSB7XG4gICAgdk5vZGUgPSBsb2M7XG4gIH1cblxuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2Tm9kZSk7XG5cbiAgLy9BbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvciAyIDogTE5vZGUoTGF5b3V0IGxheW91dCwgT2JqZWN0IHZOb2RlKVxuICBpZiAoZ20uZ3JhcGhNYW5hZ2VyICE9IG51bGwpIGdtID0gZ20uZ3JhcGhNYW5hZ2VyO1xuXG4gIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IEludGVnZXIuTUlOX1ZBTFVFO1xuICB0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnZHcmFwaE9iamVjdCA9IHZOb2RlO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG5cbiAgaWYgKHNpemUgIT0gbnVsbCAmJiBsb2MgIT0gbnVsbCkgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQobG9jLngsIGxvYy55LCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7ZWxzZSB0aGlzLnJlY3QgPSBuZXcgUmVjdGFuZ2xlRCgpO1xufVxuXG5MTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTE5vZGVbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZWRnZXM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAvLyAgaWYgKHRoaXMub3duZXIgIT0gbnVsbCkge1xuICAvLyAgICBpZiAoISh0aGlzLm93bmVyID09IG51bGwgfHwgdGhpcy5vd25lci5nZXROb2RlcygpLmluZGV4T2YodGhpcykgPiAtMSkpIHtcbiAgLy8gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgLy8gICAgfVxuICAvLyAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldFdpZHRoID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gIHRoaXMucmVjdC53aWR0aCA9IHdpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICB0aGlzLnJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aCAvIDIsIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodCAvIDIpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFBvaW50RCh0aGlzLnJlY3QueCwgdGhpcy5yZWN0LnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFJlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoICsgdGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGhhbGYgdGhlIGRpYWdvbmFsIGxlbmd0aCBvZiB0aGlzIG5vZGUuXG4gKi9cbkxOb2RlLnByb3RvdHlwZS5nZXRIYWxmVGhlRGlhZ29uYWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5yZWN0LmhlaWdodCAqIHRoaXMucmVjdC5oZWlnaHQgKyB0aGlzLnJlY3Qud2lkdGggKiB0aGlzLnJlY3Qud2lkdGgpIC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRSZWN0ID0gZnVuY3Rpb24gKHVwcGVyTGVmdCwgZGltZW5zaW9uKSB7XG4gIHRoaXMucmVjdC54ID0gdXBwZXJMZWZ0Lng7XG4gIHRoaXMucmVjdC55ID0gdXBwZXJMZWZ0Lnk7XG4gIHRoaXMucmVjdC53aWR0aCA9IGRpbWVuc2lvbi53aWR0aDtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGRpbWVuc2lvbi5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0Q2VudGVyID0gZnVuY3Rpb24gKGN4LCBjeSkge1xuICB0aGlzLnJlY3QueCA9IGN4IC0gdGhpcy5yZWN0LndpZHRoIC8gMjtcbiAgdGhpcy5yZWN0LnkgPSBjeSAtIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdGhpcy5yZWN0LnggPSB4O1xuICB0aGlzLnJlY3QueSA9IHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUubW92ZUJ5ID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnJlY3QueCArPSBkeDtcbiAgdGhpcy5yZWN0LnkgKz0gZHk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZUxpc3RUb05vZGUgPSBmdW5jdGlvbiAodG8pIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gdG8pIHtcbiAgICAgIGlmIChlZGdlLnNvdXJjZSAhPSBzZWxmKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSFcIjtcblxuICAgICAgZWRnZUxpc3QucHVzaChlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRFZGdlc0JldHdlZW4gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgdmFyIGVkZ2VMaXN0ID0gW107XG4gIHZhciBlZGdlO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZSA9PSBzZWxmIHx8IGVkZ2UudGFyZ2V0ID09IHNlbGYpKSB0aHJvdyBcIkluY29ycmVjdCBlZGdlIHNvdXJjZSBhbmQvb3IgdGFyZ2V0XCI7XG5cbiAgICBpZiAoZWRnZS50YXJnZXQgPT0gb3RoZXIgfHwgZWRnZS5zb3VyY2UgPT0gb3RoZXIpIHtcbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5laWdoYm9ycyA9IG5ldyBTZXQoKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2Uuc291cmNlID09IHNlbGYpIHtcbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS50YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWRnZS50YXJnZXQgIT0gc2VsZikge1xuICAgICAgICB0aHJvdyBcIkluY29ycmVjdCBpbmNpZGVuY3khXCI7XG4gICAgICB9XG5cbiAgICAgIG5laWdoYm9ycy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn07XG5cbkxOb2RlLnByb3RvdHlwZS53aXRoQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3aXRoTmVpZ2hib3JzTGlzdCA9IG5ldyBTZXQoKTtcbiAgdmFyIGNoaWxkTm9kZTtcbiAgdmFyIGNoaWxkcmVuO1xuXG4gIHdpdGhOZWlnaGJvcnNMaXN0LmFkZCh0aGlzKTtcblxuICBpZiAodGhpcy5jaGlsZCAhPSBudWxsKSB7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5jaGlsZC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkTm9kZSA9IG5vZGVzW2ldO1xuICAgICAgY2hpbGRyZW4gPSBjaGlsZE5vZGUud2l0aENoaWxkcmVuKCk7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHdpdGhOZWlnaGJvcnNMaXN0LmFkZChub2RlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aXRoTmVpZ2hib3JzTGlzdDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXROb09mQ2hpbGRyZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub09mQ2hpbGRyZW4gPSAwO1xuICB2YXIgY2hpbGROb2RlO1xuXG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9IGVsc2Uge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcblxuICAgICAgbm9PZkNoaWxkcmVuICs9IGNoaWxkTm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH1cblxuICBpZiAobm9PZkNoaWxkcmVuID09IDApIHtcbiAgICBub09mQ2hpbGRyZW4gPSAxO1xuICB9XG4gIHJldHVybiBub09mQ2hpbGRyZW47XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmNoaWxkID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplID0gKHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSB0aGlzLmNoaWxkLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gICAgdGhpcy5yZWN0LndpZHRoID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICAgIHRoaXMucmVjdC5oZWlnaHQgPSB0aGlzLmVzdGltYXRlZFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2NhdHRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmRvbUNlbnRlclg7XG4gIHZhciByYW5kb21DZW50ZXJZO1xuXG4gIHZhciBtaW5YID0gLUxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICB2YXIgbWF4WCA9IExheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZO1xuICByYW5kb21DZW50ZXJYID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9YICsgUmFuZG9tU2VlZC5uZXh0RG91YmxlKCkgKiAobWF4WCAtIG1pblgpICsgbWluWDtcblxuICB2YXIgbWluWSA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFkgPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWSA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWSArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFkgLSBtaW5ZKSArIG1pblk7XG5cbiAgdGhpcy5yZWN0LnggPSByYW5kb21DZW50ZXJYO1xuICB0aGlzLnJlY3QueSA9IHJhbmRvbUNlbnRlclk7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICBpZiAodGhpcy5nZXRDaGlsZCgpLmdldE5vZGVzKCkubGVuZ3RoICE9IDApIHtcbiAgICAvLyB3cmFwIHRoZSBjaGlsZHJlbiBub2RlcyBieSByZS1hcnJhbmdpbmcgdGhlIGJvdW5kYXJpZXNcbiAgICB2YXIgY2hpbGRHcmFwaCA9IHRoaXMuZ2V0Q2hpbGQoKTtcbiAgICBjaGlsZEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcblxuICAgIHRoaXMucmVjdC54ID0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yZWN0LnkgPSBjaGlsZEdyYXBoLmdldFRvcCgpO1xuXG4gICAgdGhpcy5zZXRXaWR0aChjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKSk7XG4gICAgdGhpcy5zZXRIZWlnaHQoY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCkpO1xuXG4gICAgLy8gVXBkYXRlIGNvbXBvdW5kIGJvdW5kcyBjb25zaWRlcmluZyBpdHMgbGFiZWwgcHJvcGVydGllcyAgICBcbiAgICBpZiAoTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUykge1xuXG4gICAgICB2YXIgd2lkdGggPSBjaGlsZEdyYXBoLmdldFJpZ2h0KCkgLSBjaGlsZEdyYXBoLmdldExlZnQoKTtcbiAgICAgIHZhciBoZWlnaHQgPSBjaGlsZEdyYXBoLmdldEJvdHRvbSgpIC0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgICAgaWYgKHRoaXMubGFiZWxXaWR0aCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueCAtPSB0aGlzLmxhYmVsV2lkdGg7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCArIHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiB0aGlzLmxhYmVsV2lkdGggPiB3aWR0aCkge1xuICAgICAgICAgIHRoaXMucmVjdC54IC09ICh0aGlzLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoICsgdGhpcy5sYWJlbFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAodGhpcy5sYWJlbFBvc1ZlcnRpY2FsID09IFwidG9wXCIpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSB0aGlzLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCArIHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImNlbnRlclwiICYmIHRoaXMubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueSAtPSAodGhpcy5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcImJvdHRvbVwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0ICsgdGhpcy5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmluY2x1c2lvblRyZWVEZXB0aCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmluY2x1c2lvblRyZWVEZXB0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgdmFyIGxlZnQgPSB0aGlzLnJlY3QueDtcblxuICBpZiAobGVmdCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIGxlZnQgPSBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH0gZWxzZSBpZiAobGVmdCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciB0b3AgPSB0aGlzLnJlY3QueTtcblxuICBpZiAodG9wID4gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKHRvcCA8IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICB0b3AgPSAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9XG5cbiAgdmFyIGxlZnRUb3AgPSBuZXcgUG9pbnREKGxlZnQsIHRvcCk7XG4gIHZhciB2TGVmdFRvcCA9IHRyYW5zLmludmVyc2VUcmFuc2Zvcm1Qb2ludChsZWZ0VG9wKTtcblxuICB0aGlzLnNldExvY2F0aW9uKHZMZWZ0VG9wLngsIHZMZWZ0VG9wLnkpO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC54ICsgdGhpcy5yZWN0LndpZHRoO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC55ICsgdGhpcy5yZWN0LmhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLm93bmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLm93bmVyLmdldFBhcmVudCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMTm9kZTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5mdW5jdGlvbiBGRExheW91dENvbnN0YW50cygpIHt9XG5cbi8vRkRMYXlvdXRDb25zdGFudHMgaW5oZXJpdHMgc3RhdGljIHByb3BzIGluIExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXRDb25zdGFudHMpIHtcbiAgRkRMYXlvdXRDb25zdGFudHNbcHJvcF0gPSBMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gMjUwMDtcblxuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IDUwO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEggPSAwLjQ1O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEggPSA0NTAwLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSAwLjQ7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSAxLjA7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gMy44O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDEuNTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX0lERUFMX0VER0VfTEVOR1RIX0NBTENVTEFUSU9OID0gdHJ1ZTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMID0gMC4zO1xuRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiA9IDAuMzM7XG5GRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQgPSAxMDAwO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUID0gNTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCA9IDEwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMICogMztcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuQ09OVkVSR0VOQ0VfQ0hFQ0tfUEVSSU9EID0gMTAwO1xuRkRMYXlvdXRDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IDAuMTtcbkZETGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5GRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9IDEwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUG9pbnREKHgsIHkpIHtcbiAgaWYgKHggPT0gbnVsbCAmJiB5ID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG59XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5nZXREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHB0KSB7XG4gIHJldHVybiBuZXcgRGltZW5zaW9uRCh0aGlzLnggLSBwdC54LCB0aGlzLnkgLSBwdC55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnRELnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiAoZGltKSB7XG4gIHRoaXMueCArPSBkaW0ud2lkdGg7XG4gIHRoaXMueSArPSBkaW0uaGVpZ2h0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnREO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBSZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbnZhciBMaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbmZ1bmN0aW9uIExHcmFwaChwYXJlbnQsIG9iajIsIHZHcmFwaCkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2R3JhcGgpO1xuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5tYXJnaW4gPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFQSF9NQVJHSU47XG4gIHRoaXMuZWRnZXMgPSBbXTtcbiAgdGhpcy5ub2RlcyA9IFtdO1xuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuXG4gIGlmIChvYmoyICE9IG51bGwgJiYgb2JqMiBpbnN0YW5jZW9mIExHcmFwaE1hbmFnZXIpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajI7XG4gIH0gZWxzZSBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMYXlvdXQpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlciA9IG9iajIuZ3JhcGhNYW5hZ2VyO1xuICB9XG59XG5cbkxHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaE9iamVjdC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEdyYXBoW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlcjtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wYXJlbnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlZnQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yaWdodDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0VG9wID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50b3A7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEJvdHRvbSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYm90dG9tO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuaXNDb25uZWN0ZWQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmoxLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIGlmIChzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgdmFyIG5ld05vZGUgPSBvYmoxO1xuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGhhcyBubyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE5vZGVzKCkuaW5kZXhPZihuZXdOb2RlKSA+IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgYWxyZWFkeSBpbiBncmFwaCFcIjtcbiAgICB9XG4gICAgbmV3Tm9kZS5vd25lciA9IHRoaXM7XG4gICAgdGhpcy5nZXROb2RlcygpLnB1c2gobmV3Tm9kZSk7XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV3RWRnZSA9IG9iajE7XG4gICAgaWYgKCEodGhpcy5nZXROb2RlcygpLmluZGV4T2Yoc291cmNlTm9kZSkgPiAtMSAmJiB0aGlzLmdldE5vZGVzKCkuaW5kZXhPZih0YXJnZXROb2RlKSA+IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugb3IgdGFyZ2V0IG5vdCBpbiBncmFwaCFcIjtcbiAgICB9XG5cbiAgICBpZiAoIShzb3VyY2VOb2RlLm93bmVyID09IHRhcmdldE5vZGUub3duZXIgJiYgc291cmNlTm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJCb3RoIG93bmVycyBtdXN0IGJlIHRoaXMgZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZU5vZGUub3duZXIgIT0gdGFyZ2V0Tm9kZS5vd25lcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gc2V0IHNvdXJjZSBhbmQgdGFyZ2V0XG4gICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgIC8vIHNldCBhcyBpbnRyYS1ncmFwaCBlZGdlXG4gICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSBmYWxzZTtcblxuICAgIC8vIGFkZCB0byBncmFwaCBlZGdlIGxpc3RcbiAgICB0aGlzLmdldEVkZ2VzKCkucHVzaChuZXdFZGdlKTtcblxuICAgIC8vIGFkZCB0byBpbmNpZGVuY3kgbGlzdHNcbiAgICBzb3VyY2VOb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPSBzb3VyY2VOb2RlKSB7XG4gICAgICB0YXJnZXROb2RlLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0VkZ2U7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgbm9kZSA9IG9iajtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJOb2RlIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKG5vZGUub3duZXIgIT0gbnVsbCAmJiBub2RlLm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLmdyYXBoTWFuYWdlciA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIk93bmVyIGdyYXBoIG1hbmFnZXIgaXMgaW52YWxpZCFcIjtcbiAgICB9XG4gICAgLy8gcmVtb3ZlIGluY2lkZW50IGVkZ2VzIGZpcnN0IChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBub2RlLmVkZ2VzLnNsaWNlKCk7XG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG5cbiAgICAgIGlmIChlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnNvdXJjZS5vd25lci5yZW1vdmUoZWRnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHRoZSBub2RlIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMubm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm9kZSBub3QgaW4gb3duZXIgbm9kZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIHRoaXMubm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIHZhciBlZGdlID0gb2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmICghKGVkZ2Uuc291cmNlLm93bmVyICE9IG51bGwgJiYgZWRnZS50YXJnZXQub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lciA9PSB0aGlzICYmIGVkZ2UudGFyZ2V0Lm93bmVyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IG93bmVyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICB2YXIgdGFyZ2V0SW5kZXggPSBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGlmICghKHNvdXJjZUluZGV4ID4gLTEgJiYgdGFyZ2V0SW5kZXggPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIGFuZC9vciB0YXJnZXQgZG9lc24ndCBrbm93IHRoaXMgZWRnZSFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2Uoc291cmNlSW5kZXgsIDEpO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ICE9IGVkZ2Uuc291cmNlKSB7XG4gICAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UodGFyZ2V0SW5kZXgsIDEpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoaW5kZXggPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyJ3MgZWRnZSBsaXN0IVwiO1xuICAgIH1cblxuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEVkZ2VzKCkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVMZWZ0VG9wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdG9wID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG4gIH1cblxuICAvLyBEbyB3ZSBoYXZlIGFueSBub2RlcyBpbiB0aGlzIGdyYXBoP1xuICBpZiAodG9wID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQgIT0gdW5kZWZpbmVkKSB7XG4gICAgbWFyZ2luID0gbm9kZXNbMF0uZ2V0UGFyZW50KCkucGFkZGluZ0xlZnQ7XG4gIH0gZWxzZSB7XG4gICAgbWFyZ2luID0gdGhpcy5tYXJnaW47XG4gIH1cblxuICB0aGlzLmxlZnQgPSBsZWZ0IC0gbWFyZ2luO1xuICB0aGlzLnRvcCA9IHRvcCAtIG1hcmdpbjtcblxuICAvLyBBcHBseSB0aGUgbWFyZ2lucyBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLmxlZnQsIHRoaXMudG9wKTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlQm91bmRzID0gZnVuY3Rpb24gKHJlY3Vyc2l2ZSkge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcbiAgdmFyIG1hcmdpbjtcblxuICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzO1xuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChyZWN1cnNpdmUgJiYgbE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgfVxuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcbiAgaWYgKGxlZnQgPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aGlzLmxlZnQgPSB0aGlzLnBhcmVudC5nZXRMZWZ0KCk7XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucGFyZW50LmdldFJpZ2h0KCk7XG4gICAgdGhpcy50b3AgPSB0aGlzLnBhcmVudC5nZXRUb3AoKTtcbiAgICB0aGlzLmJvdHRvbSA9IHRoaXMucGFyZW50LmdldEJvdHRvbSgpO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gYm91bmRpbmdSZWN0LnggLSBtYXJnaW47XG4gIHRoaXMucmlnaHQgPSBib3VuZGluZ1JlY3QueCArIGJvdW5kaW5nUmVjdC53aWR0aCArIG1hcmdpbjtcbiAgdGhpcy50b3AgPSBib3VuZGluZ1JlY3QueSAtIG1hcmdpbjtcbiAgdGhpcy5ib3R0b20gPSBib3VuZGluZ1JlY3QueSArIGJvdW5kaW5nUmVjdC5oZWlnaHQgKyBtYXJnaW47XG59O1xuXG5MR3JhcGguY2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsZWZ0ID0gSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciByaWdodCA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgYm90dG9tID0gLUludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZUxlZnQ7XG4gIHZhciBub2RlUmlnaHQ7XG4gIHZhciBub2RlVG9wO1xuICB2YXIgbm9kZUJvdHRvbTtcblxuICB2YXIgcyA9IG5vZGVzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBsTm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGVMZWZ0ID0gbE5vZGUuZ2V0TGVmdCgpO1xuICAgIG5vZGVSaWdodCA9IGxOb2RlLmdldFJpZ2h0KCk7XG4gICAgbm9kZVRvcCA9IGxOb2RlLmdldFRvcCgpO1xuICAgIG5vZGVCb3R0b20gPSBsTm9kZS5nZXRCb3R0b20oKTtcblxuICAgIGlmIChsZWZ0ID4gbm9kZUxlZnQpIHtcbiAgICAgIGxlZnQgPSBub2RlTGVmdDtcbiAgICB9XG5cbiAgICBpZiAocmlnaHQgPCBub2RlUmlnaHQpIHtcbiAgICAgIHJpZ2h0ID0gbm9kZVJpZ2h0O1xuICAgIH1cblxuICAgIGlmICh0b3AgPiBub2RlVG9wKSB7XG4gICAgICB0b3AgPSBub2RlVG9wO1xuICAgIH1cblxuICAgIGlmIChib3R0b20gPCBub2RlQm90dG9tKSB7XG4gICAgICBib3R0b20gPSBub2RlQm90dG9tO1xuICAgIH1cbiAgfVxuXG4gIHZhciBib3VuZGluZ1JlY3QgPSBuZXcgUmVjdGFuZ2xlRChsZWZ0LCB0b3AsIHJpZ2h0IC0gbGVmdCwgYm90dG9tIC0gdG9wKTtcblxuICByZXR1cm4gYm91bmRpbmdSZWN0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRJbmNsdXNpb25UcmVlRGVwdGggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzID09IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKTtcbiAgfVxufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5lc3RpbWF0ZWRTaXplID09IEludGVnZXIuTUlOX1ZBTFVFKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuY2FsY0VzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBzaXplICs9IGxOb2RlLmNhbGNFc3RpbWF0ZWRTaXplKCk7XG4gIH1cblxuICBpZiAoc2l6ZSA9PSAwKSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gTGF5b3V0Q29uc3RhbnRzLkVNUFRZX0NPTVBPVU5EX05PREVfU0laRTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVzdGltYXRlZFNpemUgPSBzaXplIC8gTWF0aC5zcXJ0KHRoaXMubm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUNvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudE5vZGUgPSB0aGlzLm5vZGVzWzBdO1xuICB2YXIgbmVpZ2hib3JFZGdlcztcbiAgdmFyIGN1cnJlbnROZWlnaGJvcjtcbiAgdmFyIGNoaWxkcmVuT2ZOb2RlID0gY3VycmVudE5vZGUud2l0aENoaWxkcmVuKCk7XG4gIGNoaWxkcmVuT2ZOb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICB9KTtcblxuICB3aGlsZSAocXVldWUubGVuZ3RoICE9PSAwKSB7XG4gICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IG5laWdoYm9yRWRnZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbmVpZ2hib3JFZGdlID0gbmVpZ2hib3JFZGdlc1tpXTtcbiAgICAgIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZS5nZXRPdGhlckVuZEluR3JhcGgoY3VycmVudE5vZGUsIHRoaXMpO1xuXG4gICAgICAvLyBBZGQgdW52aXNpdGVkIG5laWdoYm9ycyB0byB0aGUgbGlzdCB0byB2aXNpdFxuICAgICAgaWYgKGN1cnJlbnROZWlnaGJvciAhPSBudWxsICYmICF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbk9mTmVpZ2hib3IgPSBjdXJyZW50TmVpZ2hib3Iud2l0aENoaWxkcmVuKCk7XG5cbiAgICAgICAgY2hpbGRyZW5PZk5laWdoYm9yLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKG5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cbiAgaWYgKHZpc2l0ZWQuc2l6ZSA+PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgIHZhciBub09mVmlzaXRlZEluVGhpc0dyYXBoID0gMDtcblxuICAgIHZpc2l0ZWQuZm9yRWFjaChmdW5jdGlvbiAodmlzaXRlZE5vZGUpIHtcbiAgICAgIGlmICh2aXNpdGVkTm9kZS5vd25lciA9PSBzZWxmKSB7XG4gICAgICAgIG5vT2ZWaXNpdGVkSW5UaGlzR3JhcGgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChub09mVmlzaXRlZEluVGhpc0dyYXBoID09IHRoaXMubm9kZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaDtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIExHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7IC8vIEl0IG1heSBiZSBiZXR0ZXIgdG8gaW5pdGlsaXplIHRoaXMgb3V0IG9mIHRoaXMgZnVuY3Rpb24gYnV0IGl0IGdpdmVzIGFuIGVycm9yIChSaWdodC1oYW5kIHNpZGUgb2YgJ2luc3RhbmNlb2YnIGlzIG5vdCBjYWxsYWJsZSkgbm93LlxuICB0aGlzLmxheW91dCA9IGxheW91dDtcblxuICB0aGlzLmdyYXBocyA9IFtdO1xuICB0aGlzLmVkZ2VzID0gW107XG59XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZ3JhcGggPSB0aGlzLmxheW91dC5uZXdHcmFwaCgpO1xuICB2YXIgbm5vZGUgPSB0aGlzLmxheW91dC5uZXdOb2RlKG51bGwpO1xuICB2YXIgcm9vdCA9IHRoaXMuYWRkKG5ncmFwaCwgbm5vZGUpO1xuICB0aGlzLnNldFJvb3RHcmFwaChyb290KTtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld0dyYXBoLCBwYXJlbnROb2RlLCBuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKSB7XG4gIC8vdGhlcmUgYXJlIGp1c3QgMiBwYXJhbWV0ZXJzIGFyZSBwYXNzZWQgdGhlbiBpdCBhZGRzIGFuIExHcmFwaCBlbHNlIGl0IGFkZHMgYW4gTEVkZ2VcbiAgaWYgKG5ld0VkZ2UgPT0gbnVsbCAmJiBzb3VyY2VOb2RlID09IG51bGwgJiYgdGFyZ2V0Tm9kZSA9PSBudWxsKSB7XG4gICAgaWYgKG5ld0dyYXBoID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiR3JhcGggaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJQYXJlbnQgbm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaHMuaW5kZXhPZihuZXdHcmFwaCkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBhbHJlYWR5IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cblxuICAgIHRoaXMuZ3JhcGhzLnB1c2gobmV3R3JhcGgpO1xuXG4gICAgaWYgKG5ld0dyYXBoLnBhcmVudCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgcGFyZW50IVwiO1xuICAgIH1cbiAgICBpZiAocGFyZW50Tm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkFscmVhZHkgaGFzIGEgY2hpbGQhXCI7XG4gICAgfVxuXG4gICAgbmV3R3JhcGgucGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlLmNoaWxkID0gbmV3R3JhcGg7XG5cbiAgICByZXR1cm4gbmV3R3JhcGg7XG4gIH0gZWxzZSB7XG4gICAgLy9jaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBwYXJhbWV0ZXJzXG4gICAgdGFyZ2V0Tm9kZSA9IG5ld0VkZ2U7XG4gICAgc291cmNlTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgbmV3RWRnZSA9IG5ld0dyYXBoO1xuICAgIHZhciBzb3VyY2VHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcbiAgICB2YXIgdGFyZ2V0R3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICBpZiAoIShzb3VyY2VHcmFwaCAhPSBudWxsICYmIHNvdXJjZUdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuICAgIGlmICghKHRhcmdldEdyYXBoICE9IG51bGwgJiYgdGFyZ2V0R3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiVGFyZ2V0IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlR3JhcGggPT0gdGFyZ2V0R3JhcGgpIHtcbiAgICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG4gICAgICByZXR1cm4gc291cmNlR3JhcGguYWRkKG5ld0VkZ2UsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IHRydWU7XG5cbiAgICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgICAgbmV3RWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgbmV3RWRnZS50YXJnZXQgPSB0YXJnZXROb2RlO1xuXG4gICAgICAvLyBhZGQgZWRnZSB0byBpbnRlci1ncmFwaCBlZGdlIGxpc3RcbiAgICAgIGlmICh0aGlzLmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPiAtMSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBpbnRlci1ncmFwaCBlZGdlIGxpc3QhXCI7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gc291cmNlIGFuZCB0YXJnZXQgaW5jaWRlbmN5IGxpc3RzXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZSAhPSBudWxsICYmIG5ld0VkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShuZXdFZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xICYmIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YobmV3RWRnZSkgPT0gLTEpKSB7XG4gICAgICAgIHRocm93IFwiRWRnZSBhbHJlYWR5IGluIHNvdXJjZSBhbmQvb3IgdGFyZ2V0IGluY2lkZW5jeSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICBuZXdFZGdlLnNvdXJjZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgbmV3RWRnZS50YXJnZXQuZWRnZXMucHVzaChuZXdFZGdlKTtcblxuICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobE9iaikge1xuICBpZiAobE9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IGxPYmo7XG4gICAgaWYgKGdyYXBoLmdldEdyYXBoTWFuYWdlcigpICE9IHRoaXMpIHtcbiAgICAgIHRocm93IFwiR3JhcGggbm90IGluIHRoaXMgZ3JhcGggbWdyXCI7XG4gICAgfVxuICAgIGlmICghKGdyYXBoID09IHRoaXMucm9vdEdyYXBoIHx8IGdyYXBoLnBhcmVudCAhPSBudWxsICYmIGdyYXBoLnBhcmVudC5ncmFwaE1hbmFnZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBwYXJlbnQgbm9kZSFcIjtcbiAgICB9XG5cbiAgICAvLyBmaXJzdCB0aGUgZWRnZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgZWRnZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgZWRnZXNUb0JlUmVtb3ZlZCA9IGVkZ2VzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldEVkZ2VzKCkpO1xuXG4gICAgdmFyIGVkZ2U7XG4gICAgdmFyIHMgPSBlZGdlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgZWRnZSA9IGVkZ2VzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiB0aGUgbm9kZXMgKG1ha2UgYSBjb3B5IHRvIGRvIGl0IHNhZmVseSlcbiAgICB2YXIgbm9kZXNUb0JlUmVtb3ZlZCA9IFtdO1xuXG4gICAgbm9kZXNUb0JlUmVtb3ZlZCA9IG5vZGVzVG9CZVJlbW92ZWQuY29uY2F0KGdyYXBoLmdldE5vZGVzKCkpO1xuXG4gICAgdmFyIG5vZGU7XG4gICAgcyA9IG5vZGVzVG9CZVJlbW92ZWQubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNUb0JlUmVtb3ZlZFtpXTtcbiAgICAgIGdyYXBoLnJlbW92ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiBncmFwaCBpcyB0aGUgcm9vdFxuICAgIGlmIChncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgdGhpcy5zZXRSb290R3JhcGgobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gbm93IHJlbW92ZSB0aGUgZ3JhcGggaXRzZWxmXG4gICAgdmFyIGluZGV4ID0gdGhpcy5ncmFwaHMuaW5kZXhPZihncmFwaCk7XG4gICAgdGhpcy5ncmFwaHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIGFsc28gcmVzZXQgdGhlIHBhcmVudCBvZiB0aGUgZ3JhcGhcbiAgICBncmFwaC5wYXJlbnQgPSBudWxsO1xuICB9IGVsc2UgaWYgKGxPYmogaW5zdGFuY2VvZiBMRWRnZSkge1xuICAgIGVkZ2UgPSBsT2JqO1xuICAgIGlmIChlZGdlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiRWRnZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIWVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICB0aHJvdyBcIk5vdCBhbiBpbnRlci1ncmFwaCBlZGdlIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZSAhPSBudWxsICYmIGVkZ2UudGFyZ2V0ICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGlzIG51bGwhXCI7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBzb3VyY2UgYW5kIHRhcmdldCBub2RlcycgaW5jaWRlbmN5IGxpc3RzXG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xICYmIGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSkgIT0gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIGluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnRhcmdldC5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgLy8gcmVtb3ZlIGVkZ2UgZnJvbSBvd25lciBncmFwaCBtYW5hZ2VyJ3MgaW50ZXItZ3JhcGggZWRnZSBsaXN0XG5cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpICE9IG51bGwpKSB7XG4gICAgICB0aHJvdyBcIkVkZ2Ugb3duZXIgZ3JhcGggb3Igb3duZXIgZ3JhcGggbWFuYWdlciBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKSA9PSAtMSkge1xuICAgICAgdGhyb3cgXCJOb3QgaW4gb3duZXIgZ3JhcGggbWFuYWdlcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5pbmRleE9mKGVkZ2UpO1xuICAgIGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yb290R3JhcGgudXBkYXRlQm91bmRzKHRydWUpO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0R3JhcGhzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaHM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXMgPT0gbnVsbCkge1xuICAgIHZhciBub2RlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZUxpc3QgPSBub2RlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICB0aGlzLmFsbE5vZGVzID0gbm9kZUxpc3Q7XG4gIH1cbiAgcmV0dXJuIHRoaXMuYWxsTm9kZXM7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbE5vZGVzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsRWRnZXMgPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5nZXRBbGxFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYWxsRWRnZXMgPT0gbnVsbCkge1xuICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLmdldEdyYXBocygpO1xuICAgIHZhciBzID0gZ3JhcGhzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQoZ3JhcGhzW2ldLmdldEVkZ2VzKCkpO1xuICAgIH1cblxuICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHRoaXMuZWRnZXMpO1xuXG4gICAgdGhpcy5hbGxFZGdlcyA9IGVkZ2VMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbEVkZ2VzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAobm9kZUxpc3QpIHtcbiAgaWYgKHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gIT0gbnVsbCkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IG5vZGVMaXN0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucm9vdEdyYXBoO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuc2V0Um9vdEdyYXBoID0gZnVuY3Rpb24gKGdyYXBoKSB7XG4gIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgdGhyb3cgXCJSb290IG5vdCBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgfVxuXG4gIHRoaXMucm9vdEdyYXBoID0gZ3JhcGg7XG4gIC8vIHJvb3QgZ3JhcGggbXVzdCBoYXZlIGEgcm9vdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdCBmb3IgY29udmVuaWVuY2VcbiAgaWYgKGdyYXBoLnBhcmVudCA9PSBudWxsKSB7XG4gICAgZ3JhcGgucGFyZW50ID0gdGhpcy5sYXlvdXQubmV3Tm9kZShcIlJvb3Qgbm9kZVwiKTtcbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0TGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXQ7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pc09uZUFuY2VzdG9yT2ZPdGhlciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKCEoZmlyc3ROb2RlICE9IG51bGwgJiYgc2Vjb25kTm9kZSAhPSBudWxsKSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG5cbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSXMgc2Vjb25kIG5vZGUgYW4gYW5jZXN0b3Igb2YgdGhlIGZpcnN0IG9uZT9cbiAgdmFyIG93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcbiAgdmFyIHBhcmVudE5vZGU7XG5cbiAgZG8ge1xuICAgIHBhcmVudE5vZGUgPSBvd25lckdyYXBoLmdldFBhcmVudCgpO1xuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuICAvLyBJcyBmaXJzdCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBzZWNvbmQgb25lP1xuICBvd25lckdyYXBoID0gc2Vjb25kTm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IGZpcnN0Tm9kZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb3duZXJHcmFwaCA9IHBhcmVudE5vZGUuZ2V0T3duZXIoKTtcbiAgICBpZiAob3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlO1xuICB2YXIgc291cmNlTm9kZTtcbiAgdmFyIHRhcmdldE5vZGU7XG4gIHZhciBzb3VyY2VBbmNlc3RvckdyYXBoO1xuICB2YXIgdGFyZ2V0QW5jZXN0b3JHcmFwaDtcblxuICB2YXIgZWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBzID0gZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIHNvdXJjZU5vZGUgPSBlZGdlLnNvdXJjZTtcbiAgICB0YXJnZXROb2RlID0gZWRnZS50YXJnZXQ7XG4gICAgZWRnZS5sY2EgPSBudWxsO1xuICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VOb2RlO1xuICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuXG4gICAgaWYgKHNvdXJjZU5vZGUgPT0gdGFyZ2V0Tm9kZSkge1xuICAgICAgZWRnZS5sY2EgPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuXG4gICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXROb2RlO1xuICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IHRhcmdldE5vZGUuZ2V0T3duZXIoKTtcblxuICAgICAgd2hpbGUgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRhcmdldEFuY2VzdG9yR3JhcGggPT0gc291cmNlQW5jZXN0b3JHcmFwaCkge1xuICAgICAgICAgIGVkZ2UubGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHRoaXMucm9vdEdyYXBoKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWRnZS5sY2EgIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGVkZ2UudGFyZ2V0SW5MY2EgPSB0YXJnZXRBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICB0YXJnZXRBbmNlc3RvckdyYXBoID0gZWRnZS50YXJnZXRJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc291cmNlQW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgICAgZWRnZS5zb3VyY2VJbkxjYSA9IHNvdXJjZUFuY2VzdG9yR3JhcGguZ2V0UGFyZW50KCk7XG4gICAgICAgIHNvdXJjZUFuY2VzdG9yR3JhcGggPSBlZGdlLnNvdXJjZUluTGNhLmdldE93bmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UubGNhID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuY2FsY0xvd2VzdENvbW1vbkFuY2VzdG9yID0gZnVuY3Rpb24gKGZpcnN0Tm9kZSwgc2Vjb25kTm9kZSkge1xuICBpZiAoZmlyc3ROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICByZXR1cm4gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIH1cbiAgdmFyIGZpcnN0T3duZXJHcmFwaCA9IGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuXG4gIGRvIHtcbiAgICBpZiAoZmlyc3RPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgc2Vjb25kT3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWNvbmRPd25lckdyYXBoID09IGZpcnN0T3duZXJHcmFwaCkge1xuICAgICAgICByZXR1cm4gc2Vjb25kT3duZXJHcmFwaDtcbiAgICAgIH1cbiAgICAgIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmRPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE93bmVyR3JhcGguZ2V0UGFyZW50KCkuZ2V0T3duZXIoKTtcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmV0dXJuIGZpcnN0T3duZXJHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzID0gZnVuY3Rpb24gKGdyYXBoLCBkZXB0aCkge1xuICBpZiAoZ3JhcGggPT0gbnVsbCAmJiBkZXB0aCA9PSBudWxsKSB7XG4gICAgZ3JhcGggPSB0aGlzLnJvb3RHcmFwaDtcbiAgICBkZXB0aCA9IDE7XG4gIH1cbiAgdmFyIG5vZGU7XG5cbiAgdmFyIG5vZGVzID0gZ3JhcGguZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgIG5vZGUuaW5jbHVzaW9uVHJlZURlcHRoID0gZGVwdGg7XG5cbiAgICBpZiAobm9kZS5jaGlsZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKG5vZGUuY2hpbGQsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5pbmNsdWRlc0ludmFsaWRFZGdlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIGVkZ2VzVG9SZW1vdmUgPSBbXTtcblxuICB2YXIgcyA9IHRoaXMuZWRnZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIGVkZ2UgPSB0aGlzLmVkZ2VzW2ldO1xuXG4gICAgaWYgKHRoaXMuaXNPbmVBbmNlc3Rvck9mT3RoZXIoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KSkge1xuICAgICAgZWRnZXNUb1JlbW92ZS5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBpbnZhbGlkIGVkZ2VzIGZyb20gZ3JhcGggbWFuYWdlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VzVG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJlbW92ZShlZGdlc1RvUmVtb3ZlW2ldKTtcbiAgfVxuXG4gIC8vIEludmFsaWQgZWRnZXMgYXJlIGNsZWFyZWQsIHNvIHJldHVybiBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgbWFpbnRhaW5zIGEgbGlzdCBvZiBzdGF0aWMgZ2VvbWV0cnkgcmVsYXRlZCB1dGlsaXR5IG1ldGhvZHMuXG4gKlxuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuZnVuY3Rpb24gSUdlb21ldHJ5KCkge31cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzICpoYWxmKiB0aGUgYW1vdW50IGluIHggYW5kIHkgZGlyZWN0aW9ucyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIG5lZWRlZCB0byBzZXBhcmF0ZSB0aGVtIGtlZXBpbmcgdGhlaXIgcmVzcGVjdGl2ZVxuICogcG9zaXRpb25pbmcsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IGFycmF5LiBBbiBpbnB1dFxuICogc2VwYXJhdGlvbiBidWZmZXIgYWRkZWQgdG8gdGhlIGFtb3VudCBpbiBib3RoIGRpcmVjdGlvbnMuIFdlIGFzc3VtZSB0aGF0XG4gKiB0aGUgdHdvIHJlY3RhbmdsZXMgZG8gaW50ZXJzZWN0LlxuICovXG5JR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBzZXBhcmF0aW9uQnVmZmVyKSB7XG4gIGlmICghcmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHZhciBkaXJlY3Rpb25zID0gbmV3IEFycmF5KDIpO1xuXG4gIHRoaXMuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKTtcblxuICBvdmVybGFwQW1vdW50WzBdID0gTWF0aC5taW4ocmVjdEEuZ2V0UmlnaHQoKSwgcmVjdEIuZ2V0UmlnaHQoKSkgLSBNYXRoLm1heChyZWN0QS54LCByZWN0Qi54KTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IE1hdGgubWluKHJlY3RBLmdldEJvdHRvbSgpLCByZWN0Qi5nZXRCb3R0b20oKSkgLSBNYXRoLm1heChyZWN0QS55LCByZWN0Qi55KTtcblxuICAvLyB1cGRhdGUgdGhlIG92ZXJsYXBwaW5nIGFtb3VudHMgZm9yIHRoZSBmb2xsb3dpbmcgY2FzZXM6XG4gIGlmIChyZWN0QS5nZXRYKCkgPD0gcmVjdEIuZ2V0WCgpICYmIHJlY3RBLmdldFJpZ2h0KCkgPj0gcmVjdEIuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4xOlxuICAgICpcbiAgICAqIHJlY3RBXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QlxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRYKCkgLSByZWN0QS5nZXRYKCksIHJlY3RBLmdldFJpZ2h0KCkgLSByZWN0Qi5nZXRSaWdodCgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRYKCkgPD0gcmVjdEEuZ2V0WCgpICYmIHJlY3RCLmdldFJpZ2h0KCkgPj0gcmVjdEEuZ2V0UmlnaHQoKSkge1xuICAgIC8qIENhc2UgeC4yOlxuICAgICpcbiAgICAqIHJlY3RCXG4gICAgKiBcdHwgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgX19fX19fX19fICAgICAgfFxuICAgICogXHR8ICAgICAgICB8ICAgICAgIHwgICAgICB8XG4gICAgKiBcdHxfX19fX19fX3xfX19fX19ffF9fX19fX3xcbiAgICAqIFx0XHRcdCB8ICAgICAgIHxcbiAgICAqICAgICAgICAgICB8ICAgICAgIHxcbiAgICAqICAgICAgICByZWN0QVxuICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFswXSArPSBNYXRoLm1pbihyZWN0QS5nZXRYKCkgLSByZWN0Qi5nZXRYKCksIHJlY3RCLmdldFJpZ2h0KCkgLSByZWN0QS5nZXRSaWdodCgpKTtcbiAgfVxuICBpZiAocmVjdEEuZ2V0WSgpIDw9IHJlY3RCLmdldFkoKSAmJiByZWN0QS5nZXRCb3R0b20oKSA+PSByZWN0Qi5nZXRCb3R0b20oKSkge1xuICAgIC8qIENhc2UgeS4xOlxuICAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RBXG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICBfX19fX198X19fXyAgcmVjdEJcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgICAgICAgfCAgICB8XG4gICAgICogICBfX19fX198X19fX3xcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxcbiAgICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICAqXG4gICAgICovXG4gICAgb3ZlcmxhcEFtb3VudFsxXSArPSBNYXRoLm1pbihyZWN0Qi5nZXRZKCkgLSByZWN0QS5nZXRZKCksIHJlY3RBLmdldEJvdHRvbSgpIC0gcmVjdEIuZ2V0Qm90dG9tKCkpO1xuICB9IGVsc2UgaWYgKHJlY3RCLmdldFkoKSA8PSByZWN0QS5nZXRZKCkgJiYgcmVjdEIuZ2V0Qm90dG9tKCkgPj0gcmVjdEEuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMjpcbiAgICAqICAgICAgICAgIF9fX19fX19fIHJlY3RCXG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICBfX19fX198X19fXyAgcmVjdEFcbiAgICAqICAgICAgICAgfCAgICB8XG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICBfX19fX198X19fX3xcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxfX19fX19fX1xuICAgICpcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WSgpIC0gcmVjdEIuZ2V0WSgpLCByZWN0Qi5nZXRCb3R0b20oKSAtIHJlY3RBLmdldEJvdHRvbSgpKTtcbiAgfVxuXG4gIC8vIGZpbmQgc2xvcGUgb2YgdGhlIGxpbmUgcGFzc2VzIHR3byBjZW50ZXJzXG4gIHZhciBzbG9wZSA9IE1hdGguYWJzKChyZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCkpIC8gKHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKSkpO1xuICAvLyBpZiBjZW50ZXJzIGFyZSBvdmVybGFwcGVkXG4gIGlmIChyZWN0Qi5nZXRDZW50ZXJZKCkgPT09IHJlY3RBLmdldENlbnRlclkoKSAmJiByZWN0Qi5nZXRDZW50ZXJYKCkgPT09IHJlY3RBLmdldENlbnRlclgoKSkge1xuICAgIC8vIGFzc3VtZSB0aGUgc2xvcGUgaXMgMSAoNDUgZGVncmVlKVxuICAgIHNsb3BlID0gMS4wO1xuICB9XG5cbiAgdmFyIG1vdmVCeVkgPSBzbG9wZSAqIG92ZXJsYXBBbW91bnRbMF07XG4gIHZhciBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFsxXSAvIHNsb3BlO1xuICBpZiAob3ZlcmxhcEFtb3VudFswXSA8IG1vdmVCeVgpIHtcbiAgICBtb3ZlQnlYID0gb3ZlcmxhcEFtb3VudFswXTtcbiAgfSBlbHNlIHtcbiAgICBtb3ZlQnlZID0gb3ZlcmxhcEFtb3VudFsxXTtcbiAgfVxuICAvLyByZXR1cm4gaGFsZiB0aGUgYW1vdW50IHNvIHRoYXQgaWYgZWFjaCByZWN0YW5nbGUgaXMgbW92ZWQgYnkgdGhlc2VcbiAgLy8gYW1vdW50cyBpbiBvcHBvc2l0ZSBkaXJlY3Rpb25zLCBvdmVybGFwIHdpbGwgYmUgcmVzb2x2ZWRcbiAgb3ZlcmxhcEFtb3VudFswXSA9IC0xICogZGlyZWN0aW9uc1swXSAqIChtb3ZlQnlYIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xuICBvdmVybGFwQW1vdW50WzFdID0gLTEgKiBkaXJlY3Rpb25zWzFdICogKG1vdmVCeVkgLyAyICsgc2VwYXJhdGlvbkJ1ZmZlcik7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGRlY2lkZXMgdGhlIHNlcGFyYXRpb24gZGlyZWN0aW9uIG9mIG92ZXJsYXBwaW5nIG5vZGVzXG4gKlxuICogaWYgZGlyZWN0aW9uc1swXSA9IC0xLCB0aGVuIHJlY3RBIGdvZXMgbGVmdFxuICogaWYgZGlyZWN0aW9uc1swXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgcmlnaHRcbiAqIGlmIGRpcmVjdGlvbnNbMV0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIHVwXG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gMSwgIHRoZW4gcmVjdEEgZ29lcyBkb3duXG4gKi9cbklHZW9tZXRyeS5kZWNpZGVEaXJlY3Rpb25zRm9yT3ZlcmxhcHBpbmdOb2RlcyA9IGZ1bmN0aW9uIChyZWN0QSwgcmVjdEIsIGRpcmVjdGlvbnMpIHtcbiAgaWYgKHJlY3RBLmdldENlbnRlclgoKSA8IHJlY3RCLmdldENlbnRlclgoKSkge1xuICAgIGRpcmVjdGlvbnNbMF0gPSAtMTtcbiAgfSBlbHNlIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gMTtcbiAgfVxuXG4gIGlmIChyZWN0QS5nZXRDZW50ZXJZKCkgPCByZWN0Qi5nZXRDZW50ZXJZKCkpIHtcbiAgICBkaXJlY3Rpb25zWzFdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IDE7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIChjbGlwcGluZykgcG9pbnRzIG9mIHRoZSB0d29cbiAqIGlucHV0IHJlY3RhbmdsZXMgd2l0aCBsaW5lIHNlZ21lbnQgZGVmaW5lZCBieSB0aGUgY2VudGVycyBvZiB0aGVzZSB0d29cbiAqIHJlY3RhbmdsZXMuIFRoZSBjbGlwcGluZyBwb2ludHMgYXJlIHNhdmVkIGluIHRoZSBpbnB1dCBkb3VibGUgYXJyYXkgYW5kXG4gKiB3aGV0aGVyIG9yIG5vdCB0aGUgdHdvIHJlY3RhbmdsZXMgb3ZlcmxhcCBpcyByZXR1cm5lZC5cbiAqL1xuSUdlb21ldHJ5LmdldEludGVyc2VjdGlvbjIgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCByZXN1bHQpIHtcbiAgLy9yZXN1bHRbMC0xXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RBLCByZXN1bHRbMi0zXSB3aWxsIGNvbnRhaW4gY2xpcFBvaW50IG9mIHJlY3RCXG4gIHZhciBwMXggPSByZWN0QS5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMXkgPSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gIHZhciBwMnggPSByZWN0Qi5nZXRDZW50ZXJYKCk7XG4gIHZhciBwMnkgPSByZWN0Qi5nZXRDZW50ZXJZKCk7XG5cbiAgLy9pZiB0d28gcmVjdGFuZ2xlcyBpbnRlcnNlY3QsIHRoZW4gY2xpcHBpbmcgcG9pbnRzIGFyZSBjZW50ZXJzXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkge1xuICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEFcbiAgdmFyIHRvcExlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIHRvcExlZnRBeSA9IHJlY3RBLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QXggPSByZWN0QS5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEF4ID0gcmVjdEEuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEF5ID0gcmVjdEEuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEEgPSByZWN0QS5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRBID0gcmVjdEEuZ2V0SGVpZ2h0SGFsZigpO1xuICAvL3ZhcmlhYmxlcyBmb3IgcmVjdEJcbiAgdmFyIHRvcExlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIHRvcExlZnRCeSA9IHJlY3RCLmdldFkoKTtcbiAgdmFyIHRvcFJpZ2h0QnggPSByZWN0Qi5nZXRSaWdodCgpO1xuICB2YXIgYm90dG9tTGVmdEJ4ID0gcmVjdEIuZ2V0WCgpO1xuICB2YXIgYm90dG9tTGVmdEJ5ID0gcmVjdEIuZ2V0Qm90dG9tKCk7XG4gIHZhciBib3R0b21SaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGhhbGZXaWR0aEIgPSByZWN0Qi5nZXRXaWR0aEhhbGYoKTtcbiAgdmFyIGhhbGZIZWlnaHRCID0gcmVjdEIuZ2V0SGVpZ2h0SGFsZigpO1xuXG4gIC8vZmxhZyB3aGV0aGVyIGNsaXBwaW5nIHBvaW50cyBhcmUgZm91bmRcbiAgdmFyIGNsaXBQb2ludEFGb3VuZCA9IGZhbHNlO1xuICB2YXIgY2xpcFBvaW50QkZvdW5kID0gZmFsc2U7XG5cbiAgLy8gbGluZSBpcyB2ZXJ0aWNhbFxuICBpZiAocDF4ID09PSBwMngpIHtcbiAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChwMXkgPCBwMnkpIHtcbiAgICAgIHJlc3VsdFswXSA9IHAxeDtcbiAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9ub3QgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIC8vIGxpbmUgaXMgaG9yaXpvbnRhbFxuICBlbHNlIGlmIChwMXkgPT09IHAyeSkge1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgIHJlc3VsdFsxXSA9IHAxeTtcbiAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHAxeCA8IHAyeCkge1xuICAgICAgICByZXN1bHRbMF0gPSB0b3BSaWdodEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgcmVzdWx0WzNdID0gcDJ5O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL25vdCB2YWxpZCBsaW5lLCByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9zbG9wZXMgb2YgcmVjdEEncyBhbmQgcmVjdEIncyBkaWFnb25hbHNcbiAgICAgIHZhciBzbG9wZUEgPSByZWN0QS5oZWlnaHQgLyByZWN0QS53aWR0aDtcbiAgICAgIHZhciBzbG9wZUIgPSByZWN0Qi5oZWlnaHQgLyByZWN0Qi53aWR0aDtcblxuICAgICAgLy9zbG9wZSBvZiBsaW5lIGJldHdlZW4gY2VudGVyIG9mIHJlY3RBIGFuZCBjZW50ZXIgb2YgcmVjdEJcbiAgICAgIHZhciBzbG9wZVByaW1lID0gKHAyeSAtIHAxeSkgLyAocDJ4IC0gcDF4KTtcbiAgICAgIHZhciBjYXJkaW5hbERpcmVjdGlvbkEgPSB2b2lkIDA7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25CID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEF5ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ4ID0gdm9pZCAwO1xuICAgICAgdmFyIHRlbXBQb2ludEJ5ID0gdm9pZCAwO1xuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUFcbiAgICAgIGlmICgtc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUEgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcExlZnRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vZGV0ZXJtaW5lIHdoZXRoZXIgY2xpcHBpbmcgcG9pbnQgaXMgdGhlIGNvcm5lciBvZiBub2RlQlxuICAgICAgaWYgKC1zbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbUxlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSBib3R0b21MZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSB0b3BSaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNsb3BlQiA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDJ4ID4gcDF4KSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wTGVmdEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IHRvcExlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9pZiBib3RoIGNsaXBwaW5nIHBvaW50cyBhcmUgY29ybmVyc1xuICAgICAgaWYgKGNsaXBQb2ludEFGb3VuZCAmJiBjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSBDYXJkaW5hbCBEaXJlY3Rpb24gb2YgcmVjdGFuZ2xlc1xuICAgICAgaWYgKHAxeCA+IHAyeCkge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDQpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwMXkgPiBwMnkpIHtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkEgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUEsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oLXNsb3BlQiwgc2xvcGVQcmltZSwgMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbihzbG9wZUEsIHNsb3BlUHJpbWUsIDIpO1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVCLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9jYWxjdWxhdGUgY2xpcHBpbmcgUG9pbnQgaWYgaXQgaXMgbm90IGZvdW5kIGJlZm9yZVxuICAgICAgaWYgKCFjbGlwUG9pbnRBRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkEpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHRvcExlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgLWhhbGZIZWlnaHRBIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IGJvdHRvbVJpZ2h0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIGhhbGZXaWR0aEEgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEF5ID0gYm90dG9tTGVmdEF5O1xuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBwMXggKyBoYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21MZWZ0QXg7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IHAxeSArIC1oYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGlwUG9pbnRCRm91bmQpIHtcbiAgICAgICAgc3dpdGNoIChjYXJkaW5hbERpcmVjdGlvbkIpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHRvcExlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgLWhhbGZIZWlnaHRCIC8gc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IGJvdHRvbVJpZ2h0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIGhhbGZXaWR0aEIgKiBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ5ID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBwMnggKyBoYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IHAyeSArIC1oYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGluIHdoaWNoIGNhcmRpbmFsIGRpcmVjdGlvbiBkb2VzIGlucHV0IHBvaW50IHN0YXlzXG4gKiAxOiBOb3J0aFxuICogMjogRWFzdFxuICogMzogU291dGhcbiAqIDQ6IFdlc3RcbiAqL1xuSUdlb21ldHJ5LmdldENhcmRpbmFsRGlyZWN0aW9uID0gZnVuY3Rpb24gKHNsb3BlLCBzbG9wZVByaW1lLCBsaW5lKSB7XG4gIGlmIChzbG9wZSA+IHNsb3BlUHJpbWUpIHtcbiAgICByZXR1cm4gbGluZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMSArIGxpbmUgJSA0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIGxpbmVzIGRlZmluZWQgYnlcbiAqIHBvaW50IHBhaXJzIChzMSxzMikgYW5kIChmMSxmMikuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoczEsIHMyLCBmMSwgZjIpIHtcbiAgaWYgKGYyID09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb24yKHMxLCBzMiwgZjEpO1xuICB9XG5cbiAgdmFyIHgxID0gczEueDtcbiAgdmFyIHkxID0gczEueTtcbiAgdmFyIHgyID0gczIueDtcbiAgdmFyIHkyID0gczIueTtcbiAgdmFyIHgzID0gZjEueDtcbiAgdmFyIHkzID0gZjEueTtcbiAgdmFyIHg0ID0gZjIueDtcbiAgdmFyIHk0ID0gZjIueTtcbiAgdmFyIHggPSB2b2lkIDAsXG4gICAgICB5ID0gdm9pZCAwOyAvLyBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgdmFyIGExID0gdm9pZCAwLFxuICAgICAgYTIgPSB2b2lkIDAsXG4gICAgICBiMSA9IHZvaWQgMCxcbiAgICAgIGIyID0gdm9pZCAwLFxuICAgICAgYzEgPSB2b2lkIDAsXG4gICAgICBjMiA9IHZvaWQgMDsgLy8gY29lZmZpY2llbnRzIG9mIGxpbmUgZXFucy5cbiAgdmFyIGRlbm9tID0gdm9pZCAwO1xuXG4gIGExID0geTIgLSB5MTtcbiAgYjEgPSB4MSAtIHgyO1xuICBjMSA9IHgyICogeTEgLSB4MSAqIHkyOyAvLyB7IGExKnggKyBiMSp5ICsgYzEgPSAwIGlzIGxpbmUgMSB9XG5cbiAgYTIgPSB5NCAtIHkzO1xuICBiMiA9IHgzIC0geDQ7XG4gIGMyID0geDQgKiB5MyAtIHgzICogeTQ7IC8vIHsgYTIqeCArIGIyKnkgKyBjMiA9IDAgaXMgbGluZSAyIH1cblxuICBkZW5vbSA9IGExICogYjIgLSBhMiAqIGIxO1xuXG4gIGlmIChkZW5vbSA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgeCA9IChiMSAqIGMyIC0gYjIgKiBjMSkgLyBkZW5vbTtcbiAgeSA9IChhMiAqIGMxIC0gYTEgKiBjMikgLyBkZW5vbTtcblxuICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBmaW5kcyBhbmQgcmV0dXJucyB0aGUgYW5nbGUgb2YgdGhlIHZlY3RvciBmcm9tIHRoZSArIHgtYXhpc1xuICogaW4gY2xvY2t3aXNlIGRpcmVjdGlvbiAoY29tcGF0aWJsZSB3LyBKYXZhIGNvb3JkaW5hdGUgc3lzdGVtISkuXG4gKi9cbklHZW9tZXRyeS5hbmdsZU9mVmVjdG9yID0gZnVuY3Rpb24gKEN4LCBDeSwgTngsIE55KSB7XG4gIHZhciBDX2FuZ2xlID0gdm9pZCAwO1xuXG4gIGlmIChDeCAhPT0gTngpIHtcbiAgICBDX2FuZ2xlID0gTWF0aC5hdGFuKChOeSAtIEN5KSAvIChOeCAtIEN4KSk7XG5cbiAgICBpZiAoTnggPCBDeCkge1xuICAgICAgQ19hbmdsZSArPSBNYXRoLlBJO1xuICAgIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgICAgQ19hbmdsZSArPSB0aGlzLlRXT19QSTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoTnkgPCBDeSkge1xuICAgIENfYW5nbGUgPSB0aGlzLk9ORV9BTkRfSEFMRl9QSTsgLy8gMjcwIGRlZ3JlZXNcbiAgfSBlbHNlIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5IQUxGX1BJOyAvLyA5MCBkZWdyZWVzXG4gIH1cblxuICByZXR1cm4gQ19hbmdsZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHR3byBsaW5lIHNlZ21lbnRzIChvbmUgd2l0aCBwb2ludFxuICogcDEgYW5kIHAyLCB0aGUgb3RoZXIgd2l0aCBwb2ludCBwMyBhbmQgcDQpIGludGVyc2VjdCBhdCBhIHBvaW50IG90aGVyXG4gKiB0aGFuIHRoZXNlIHBvaW50cy5cbiAqL1xuSUdlb21ldHJ5LmRvSW50ZXJzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHZhciBhID0gcDEueDtcbiAgdmFyIGIgPSBwMS55O1xuICB2YXIgYyA9IHAyLng7XG4gIHZhciBkID0gcDIueTtcbiAgdmFyIHAgPSBwMy54O1xuICB2YXIgcSA9IHAzLnk7XG4gIHZhciByID0gcDQueDtcbiAgdmFyIHMgPSBwNC55O1xuICB2YXIgZGV0ID0gKGMgLSBhKSAqIChzIC0gcSkgLSAociAtIHApICogKGQgLSBiKTtcblxuICBpZiAoZGV0ID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBsYW1iZGEgPSAoKHMgLSBxKSAqIChyIC0gYSkgKyAocCAtIHIpICogKHMgLSBiKSkgLyBkZXQ7XG4gICAgdmFyIGdhbW1hID0gKChiIC0gZCkgKiAociAtIGEpICsgKGMgLSBhKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHJldHVybiAwIDwgbGFtYmRhICYmIGxhbWJkYSA8IDEgJiYgMCA8IGdhbW1hICYmIGdhbW1hIDwgMTtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjaGVja3MgYW5kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiBcbiAqIGEgbGluZSBzZWdtZW50IGFuZCBhIGNpcmNsZS5cbiAqL1xuSUdlb21ldHJ5LmZpbmRDaXJjbGVMaW5lSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIChFeCwgRXksIEx4LCBMeSwgQ3gsIEN5LCByKSB7XG5cbiAgLy8gRSBpcyB0aGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIHJheSxcbiAgLy8gTCBpcyB0aGUgZW5kIHBvaW50IG9mIHRoZSByYXksXG4gIC8vIEMgaXMgdGhlIGNlbnRlciBvZiBzcGhlcmUgeW91J3JlIHRlc3RpbmcgYWdhaW5zdFxuICAvLyByIGlzIHRoZSByYWRpdXMgb2YgdGhhdCBzcGhlcmVcblxuICAvLyBDb21wdXRlOlxuICAvLyBkID0gTCAtIEUgKCBEaXJlY3Rpb24gdmVjdG9yIG9mIHJheSwgZnJvbSBzdGFydCB0byBlbmQgKVxuICAvLyBmID0gRSAtIEMgKCBWZWN0b3IgZnJvbSBjZW50ZXIgc3BoZXJlIHRvIHJheSBzdGFydCApXG5cbiAgLy8gVGhlbiB0aGUgaW50ZXJzZWN0aW9uIGlzIGZvdW5kIGJ5Li5cbiAgLy8gUCA9IEUgKyB0ICogZFxuICAvLyBUaGlzIGlzIGEgcGFyYW1ldHJpYyBlcXVhdGlvbjpcbiAgLy8gUHggPSBFeCArIHRkeFxuICAvLyBQeSA9IEV5ICsgdGR5XG5cbiAgLy8gZ2V0IGEsIGIsIGMgdmFsdWVzXG4gIHZhciBhID0gKEx4IC0gRXgpICogKEx4IC0gRXgpICsgKEx5IC0gRXkpICogKEx5IC0gRXkpO1xuICB2YXIgYiA9IDIgKiAoKEV4IC0gQ3gpICogKEx4IC0gRXgpICsgKEV5IC0gQ3kpICogKEx5IC0gRXkpKTtcbiAgdmFyIGMgPSAoRXggLSBDeCkgKiAoRXggLSBDeCkgKyAoRXkgLSBDeSkgKiAoRXkgLSBDeSkgLSByICogcjtcblxuICAvLyBnZXQgZGlzY3JpbWluYW50XG4gIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG4gIGlmIChkaXNjID49IDApIHtcbiAgICAvLyBpbnNlcnQgaW50byBxdWFkcmF0aWMgZm9ybXVsYVxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChiICogYiAtIDQgKiBhICogYykpIC8gKDIgKiBhKTtcbiAgICB2YXIgdDIgPSAoLWIgLSBNYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvICgyICogYSk7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBudWxsO1xuICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgIC8vIHQxIGlzIHRoZSBpbnRlcnNlY3Rpb24sIGFuZCBpdCdzIGNsb3NlciB0aGFuIHQyXG4gICAgICAvLyAoc2luY2UgdDEgdXNlcyAtYiAtIGRpc2NyaW1pbmFudClcbiAgICAgIC8vIEltcGFsZSwgUG9rZVxuICAgICAgcmV0dXJuIFt0MV07XG4gICAgfVxuXG4gICAgLy8gaGVyZSB0MSBkaWRuJ3QgaW50ZXJzZWN0IHNvIHdlIGFyZSBlaXRoZXIgc3RhcnRlZFxuICAgIC8vIGluc2lkZSB0aGUgc3BoZXJlIG9yIGNvbXBsZXRlbHkgcGFzdCBpdFxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIC8vIEV4aXRXb3VuZFxuICAgICAgcmV0dXJuIFt0Ml07XG4gICAgfVxuXG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH0gZWxzZSByZXR1cm4gbnVsbDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBDbGFzcyBDb25zdGFudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqIFNvbWUgdXNlZnVsIHByZS1jYWxjdWxhdGVkIGNvbnN0YW50c1xuICovXG5JR2VvbWV0cnkuSEFMRl9QSSA9IDAuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuT05FX0FORF9IQUxGX1BJID0gMS41ICogTWF0aC5QSTtcbklHZW9tZXRyeS5UV09fUEkgPSAyLjAgKiBNYXRoLlBJO1xuSUdlb21ldHJ5LlRIUkVFX1BJID0gMy4wICogTWF0aC5QSTtcblxubW9kdWxlLmV4cG9ydHMgPSBJR2VvbWV0cnk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBJTWF0aCgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgc2lnbiBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbklNYXRoLnNpZ24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlID4gMCkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuSU1hdGguZmxvb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguY2VpbCh2YWx1ZSkgOiBNYXRoLmZsb29yKHZhbHVlKTtcbn07XG5cbklNYXRoLmNlaWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIDwgMCA/IE1hdGguZmxvb3IodmFsdWUpIDogTWF0aC5jZWlsKHZhbHVlKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSU1hdGg7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSW50ZWdlcigpIHt9XG5cbkludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbkludGVnZXIuTUlOX1ZBTFVFID0gLTIxNDc0ODM2NDg7XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgbm9kZUZyb20gPSBmdW5jdGlvbiBub2RlRnJvbSh2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIG5leHQ6IG51bGwsIHByZXY6IG51bGwgfTtcbn07XG5cbnZhciBhZGQgPSBmdW5jdGlvbiBhZGQocHJldiwgbm9kZSwgbmV4dCwgbGlzdCkge1xuICBpZiAocHJldiAhPT0gbnVsbCkge1xuICAgIHByZXYubmV4dCA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC5oZWFkID0gbm9kZTtcbiAgfVxuXG4gIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgbmV4dC5wcmV2ID0gbm9kZTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LnRhaWwgPSBub2RlO1xuICB9XG5cbiAgbm9kZS5wcmV2ID0gcHJldjtcbiAgbm9kZS5uZXh0ID0gbmV4dDtcblxuICBsaXN0Lmxlbmd0aCsrO1xuXG4gIHJldHVybiBub2RlO1xufTtcblxudmFyIF9yZW1vdmUgPSBmdW5jdGlvbiBfcmVtb3ZlKG5vZGUsIGxpc3QpIHtcbiAgdmFyIHByZXYgPSBub2RlLnByZXYsXG4gICAgICBuZXh0ID0gbm9kZS5uZXh0O1xuXG5cbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5leHQ7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IHByZXY7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gcHJldjtcbiAgfVxuXG4gIG5vZGUucHJldiA9IG5vZGUubmV4dCA9IG51bGw7XG5cbiAgbGlzdC5sZW5ndGgtLTtcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMaW5rZWRMaXN0KHZhbHMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtlZExpc3QpO1xuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcblxuICAgIGlmICh2YWxzICE9IG51bGwpIHtcbiAgICAgIHZhbHMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gX3RoaXMucHVzaCh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rZWRMaXN0LCBbe1xuICAgIGtleTogXCJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRCZWZvcmUodmFsLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLnByZXYsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluc2VydEFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZSwgbm9kZUZyb20odmFsKSwgb3RoZXJOb2RlLm5leHQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQmVmb3JlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVCZWZvcmUobmV3Tm9kZSwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBuZXdOb2RlLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnROb2RlQWZ0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZUFmdGVyKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5ld05vZGUsIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHZhbCkge1xuICAgICAgcmV0dXJuIGFkZCh0aGlzLnRhaWwsIG5vZGVGcm9tKHZhbCksIG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodmFsKSB7XG4gICAgICByZXR1cm4gYWRkKG51bGwsIG5vZGVGcm9tKHZhbCksIHRoaXMuaGVhZCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUobm9kZSwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3AoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLnRhaWwsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKHRoaXMuaGVhZCwgdGhpcykudmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdE5vZGUoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRfb2JqZWN0X2F0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldF9vYmplY3RfYXQoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKGluZGV4IDw9IHRoaXMubGVuZ3RoKCkpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuaGVhZDtcbiAgICAgICAgd2hpbGUgKGkgPCBpbmRleCkge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGlua2VkTGlzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5rZWRMaXN0O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qXHJcbiAqVGhpcyBjbGFzcyBpcyB0aGUgamF2YXNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9pbnQuamF2YSBjbGFzcyBpbiBqZGtcclxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5LCBwKSB7XG4gIHRoaXMueCA9IG51bGw7XG4gIHRoaXMueSA9IG51bGw7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0gZWxzZSBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMueCA9IHAueDtcbiAgICB0aGlzLnkgPSBwLnk7XG4gIH1cbn1cblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLngsIHRoaXMueSk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcCkge1xuICBpZiAoeC5jb25zdHJ1Y3Rvci5uYW1lID09ICdQb2ludCcgJiYgeSA9PSBudWxsICYmIHAgPT0gbnVsbCkge1xuICAgIHAgPSB4O1xuICAgIHRoaXMuc2V0TG9jYXRpb24ocC54LCBwLnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHAgPT0gbnVsbCkge1xuICAgIC8vaWYgYm90aCBwYXJhbWV0ZXJzIGFyZSBpbnRlZ2VyIGp1c3QgbW92ZSAoeCx5KSBsb2NhdGlvblxuICAgIGlmIChwYXJzZUludCh4KSA9PSB4ICYmIHBhcnNlSW50KHkpID09IHkpIHtcbiAgICAgIHRoaXMubW92ZSh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcih4ICsgMC41KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IoeSArIDAuNSk7XG4gICAgfVxuICB9XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGR4LCBkeSkge1xuICB0aGlzLnggKz0gZHg7XG4gIHRoaXMueSArPSBkeTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmouY29uc3RydWN0b3IubmFtZSA9PSBcIlBvaW50XCIpIHtcbiAgICB2YXIgcHQgPSBvYmo7XG4gICAgcmV0dXJuIHRoaXMueCA9PSBwdC54ICYmIHRoaXMueSA9PSBwdC55O1xuICB9XG4gIHJldHVybiB0aGlzID09IG9iajtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCgpLmNvbnN0cnVjdG9yLm5hbWUgKyBcIlt4PVwiICsgdGhpcy54ICsgXCIseT1cIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSZWN0YW5nbGVEKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcblxuICBpZiAoeCAhPSBudWxsICYmIHkgIT0gbnVsbCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufVxuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WCA9IGZ1bmN0aW9uICh4KSB7XG4gIHRoaXMueCA9IHg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0WSA9IGZ1bmN0aW9uICh5KSB7XG4gIHRoaXMueSA9IHk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoYSkge1xuICBpZiAodGhpcy5nZXRSaWdodCgpIDwgYS54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuZ2V0Qm90dG9tKCkgPCBhLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoYS5nZXRSaWdodCgpIDwgdGhpcy54KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0Qm90dG9tKCkgPCB0aGlzLnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldENlbnRlclggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFgoKSArIHRoaXMud2lkdGg7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0WSgpICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRXaWR0aEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoIC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldEhlaWdodEhhbGYgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodCAvIDI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY3RhbmdsZUQ7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBVbmlxdWVJREdlbmVyZXRvcigpIHt9XG5cblVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCA9IDA7XG5cblVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAoVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUob2JqKSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgaWYgKG9iai51bmlxdWVJRCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG9iai51bmlxdWVJRDtcbiAgfVxuICBvYmoudW5pcXVlSUQgPSBVbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcoKTtcbiAgVW5pcXVlSURHZW5lcmV0b3IubGFzdElEKys7XG4gIHJldHVybiBvYmoudW5pcXVlSUQ7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5nZXRTdHJpbmcgPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGlkID09IG51bGwpIGlkID0gVW5pcXVlSURHZW5lcmV0b3IubGFzdElEO1xuICByZXR1cm4gXCJPYmplY3QjXCIgKyBpZCArIFwiXCI7XG59O1xuXG5VbmlxdWVJREdlbmVyZXRvci5pc1ByaW1pdGl2ZSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgYXJnID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoYXJnKTtcbiAgcmV0dXJuIGFyZyA9PSBudWxsIHx8IHR5cGUgIT0gXCJvYmplY3RcIiAmJiB0eXBlICE9IFwiZnVuY3Rpb25cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVW5pcXVlSURHZW5lcmV0b3I7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIFRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xudmFyIEVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcblxuZnVuY3Rpb24gTGF5b3V0KGlzUmVtb3RlVXNlKSB7XG4gIEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICAvL0xheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcbiAgdGhpcy5sYXlvdXRRdWFsaXR5ID0gTGF5b3V0Q29uc3RhbnRzLlFVQUxJVFk7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGNyZWF0ZSBiZW5kcG9pbnRzIGFzIG5lZWRlZCBvciBub3RcbiAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgLy9XaGV0aGVyIGxheW91dCBzaG91bGQgYmUgaW5jcmVtZW50YWwgb3Igbm90XG4gIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgZnJvbSBiZWZvcmUgdG8gYWZ0ZXIgbGF5b3V0IG5vZGUgcG9zaXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAvL1doZXRoZXIgd2UgYW5pbWF0ZSB0aGUgbGF5b3V0IHByb2Nlc3Mgb3Igbm90XG4gIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gIC8vTnVtYmVyIGl0ZXJhdGlvbnMgdGhhdCBzaG91bGQgYmUgZG9uZSBiZXR3ZWVuIHR3byBzdWNjZXNzaXZlIGFuaW1hdGlvbnNcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAvKipcclxuICAgKiBXaGV0aGVyIG9yIG5vdCBsZWFmIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIHNpemVzLiBXaGVuXHJcbiAgICogdGhleSBhcmUsIGJvdGggc3ByaW5nIGFuZCByZXB1bHNpb24gZm9yY2VzIGJldHdlZW4gdHdvIGxlYWYgbm9kZXMgY2FuIGJlXHJcbiAgICogY2FsY3VsYXRlZCB3aXRob3V0IHRoZSBleHBlbnNpdmUgY2xpcHBpbmcgcG9pbnQgY2FsY3VsYXRpb25zLCByZXN1bHRpbmdcclxuICAgKiBpbiBtYWpvciBzcGVlZC11cC5cclxuICAgKi9cbiAgdGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX1VOSUZPUk1fTEVBRl9OT0RFX1NJWkVTO1xuICAvKipcclxuICAgKiBUaGlzIGlzIHVzZWQgZm9yIGNyZWF0aW9uIG9mIGJlbmRwb2ludHMgYnkgdXNpbmcgZHVtbXkgbm9kZXMgYW5kIGVkZ2VzLlxyXG4gICAqIE1hcHMgYW4gTEVkZ2UgdG8gaXRzIGR1bW15IGJlbmRwb2ludCBwYXRoLlxyXG4gICAqL1xuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuICB0aGlzLmlzU3ViTGF5b3V0ID0gZmFsc2U7XG4gIHRoaXMuaXNSZW1vdGVVc2UgPSBmYWxzZTtcblxuICBpZiAoaXNSZW1vdGVVc2UgIT0gbnVsbCkge1xuICAgIHRoaXMuaXNSZW1vdGVVc2UgPSBpc1JlbW90ZVVzZTtcbiAgfVxufVxuXG5MYXlvdXQuUkFORE9NX1NFRUQgPSAxO1xuXG5MYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFbWl0dGVyLnByb3RvdHlwZSk7XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IExHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3R3JhcGggPSBmdW5jdGlvbiAodkdyYXBoKSB7XG4gIHJldHVybiBuZXcgTEdyYXBoKG51bGwsIHRoaXMuZ3JhcGhNYW5hZ2VyLCB2R3JhcGgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdOb2RlID0gZnVuY3Rpb24gKHZOb2RlKSB7XG4gIHJldHVybiBuZXcgTE5vZGUodGhpcy5ncmFwaE1hbmFnZXIsIHZOb2RlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IExFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuY2hlY2tMYXlvdXRTdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpID09IG51bGwgfHwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCkubGVuZ3RoID09IDAgfHwgdGhpcy5ncmFwaE1hbmFnZXIuaW5jbHVkZXNJbnZhbGlkRWRnZSgpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5ydW5MYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaXNMYXlvdXRGaW5pc2hlZCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRpbGluZ1ByZUxheW91dCkge1xuICAgIHRoaXMudGlsaW5nUHJlTGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmluaXRQYXJhbWV0ZXJzKCk7XG4gIHZhciBpc0xheW91dFN1Y2Nlc3NmdWxsO1xuXG4gIGlmICh0aGlzLmNoZWNrTGF5b3V0U3VjY2VzcygpKSB7XG4gICAgaXNMYXlvdXRTdWNjZXNzZnVsbCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaWYgKExheW91dENvbnN0YW50cy5BTklNQVRFID09PSAnZHVyaW5nJykge1xuICAgIC8vIElmIHRoaXMgaXMgYSAnZHVyaW5nJyBsYXlvdXQgYW5pbWF0aW9uLiBMYXlvdXQgaXMgbm90IGZpbmlzaGVkIHlldC4gXG4gICAgLy8gV2UgbmVlZCB0byBwZXJmb3JtIHRoZXNlIGluIGluZGV4LmpzIHdoZW4gbGF5b3V0IGlzIHJlYWxseSBmaW5pc2hlZC5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNMYXlvdXRTdWNjZXNzZnVsbCkge1xuICAgIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgICAgdGhpcy5kb1Bvc3RMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50aWxpbmdQb3N0TGF5b3V0KSB7XG4gICAgdGhpcy50aWxpbmdQb3N0TGF5b3V0KCk7XG4gIH1cblxuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSB0cnVlO1xuXG4gIHJldHVybiBpc0xheW91dFN1Y2Nlc3NmdWxsO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIHBlcmZvcm1zIHRoZSBvcGVyYXRpb25zIHJlcXVpcmVkIGFmdGVyIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmRvUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgLy9hc3NlcnQgIWlzU3ViTGF5b3V0IDogXCJTaG91bGQgbm90IGJlIGNhbGxlZCBvbiBzdWItbGF5b3V0IVwiO1xuICAvLyBQcm9wYWdhdGUgZ2VvbWV0cmljIGNoYW5nZXMgdG8gdi1sZXZlbCBvYmplY3RzXG4gIGlmICghdGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIHRoaXMudHJhbnNmb3JtKCk7XG4gIH1cbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBnZW9tZXRyeSBvZiB0aGUgdGFyZ2V0IGdyYXBoIGFjY29yZGluZyB0b1xyXG4gKiBjYWxjdWxhdGVkIGxheW91dC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLnVwZGF0ZTIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHVwZGF0ZSBiZW5kIHBvaW50c1xuICBpZiAodGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMoKTtcblxuICAgIC8vIHJlc2V0IGFsbCBlZGdlcywgc2luY2UgdGhlIHRvcG9sb2d5IGhhcyBjaGFuZ2VkXG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBlZGdlLCBub2RlIGFuZCByb290IHVwZGF0ZXMgaWYgbGF5b3V0IGlzIG5vdCBjYWxsZWRcbiAgLy8gcmVtb3RlbHlcbiAgaWYgKCF0aGlzLmlzUmVtb3RlVXNlKSB7XG4gICAgLy8gdXBkYXRlIGFsbCBlZGdlc1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBhbGxFZGdlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShlZGdlKTtcbiAgICB9XG5cbiAgICAvLyByZWN1cnNpdmVseSB1cGRhdGUgbm9kZXNcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAvLyAgICAgIHRoaXMudXBkYXRlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSByb290IGdyYXBoXG4gICAgdGhpcy51cGRhdGUodGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRoaXMudXBkYXRlMigpO1xuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBvYmo7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAvLyBzaW5jZSBub2RlIGlzIGNvbXBvdW5kLCByZWN1cnNpdmVseSB1cGRhdGUgY2hpbGQgbm9kZXNcbiAgICAgIHZhciBub2RlcyA9IG5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGUobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBsLWxldmVsIG5vZGUgaXMgYXNzb2NpYXRlZCB3aXRoIGEgdi1sZXZlbCBncmFwaCBvYmplY3QsXG4gICAgLy8gdGhlbiBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIHYtbGV2ZWwgbm9kZSBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG4gICAgaWYgKG5vZGUudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2Tm9kZSA9IG5vZGUudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZOb2RlLnVwZGF0ZShub2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBlZGdlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIGVkZ2UgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGVkZ2UudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2RWRnZSA9IGVkZ2UudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZFZGdlLnVwZGF0ZShlZGdlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEdyYXBoKSB7XG4gICAgdmFyIGdyYXBoID0gb2JqO1xuICAgIC8vIGlmIHRoZSBsLWxldmVsIGdyYXBoIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG9iamVjdCBpbXBsZW1lbnRzIHRoZVxuICAgIC8vIGludGVyZmFjZSBVcGRhdGFibGUuXG5cbiAgICBpZiAoZ3JhcGgudkdyYXBoT2JqZWN0ICE9IG51bGwpIHtcbiAgICAgIC8vIGNhc3QgdG8gVXBkYXRhYmxlIHdpdGhvdXQgYW55IHR5cGUgY2hlY2tcbiAgICAgIHZhciB2R3JhcGggPSBncmFwaC52R3JhcGhPYmplY3Q7XG5cbiAgICAgIC8vIGNhbGwgdGhlIHVwZGF0ZSBtZXRob2Qgb2YgdGhlIGludGVyZmFjZVxuICAgICAgdkdyYXBoLnVwZGF0ZShncmFwaCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgYWxsIGxheW91dCBwYXJhbWV0ZXJzIHRvIGRlZmF1bHQgdmFsdWVzXHJcbiAqIGRldGVybWluZWQgYXQgY29tcGlsZSB0aW1lLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1N1YkxheW91dCkge1xuICAgIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAgIHRoaXMuYW5pbWF0aW9uRHVyaW5nTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX0RVUklOR19MQVlPVVQ7XG4gICAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fUEVSSU9EO1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fT05fTEFZT1VUO1xuICAgIHRoaXMuaW5jcmVtZW50YWwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTDtcbiAgICB0aGlzLmNyZWF0ZUJlbmRzQXNOZWVkZWQgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEO1xuICAgIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgfVxuXG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCkge1xuICAgIHRoaXMuYW5pbWF0aW9uT25MYXlvdXQgPSBmYWxzZTtcbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAobmV3TGVmdFRvcCkge1xuICBpZiAobmV3TGVmdFRvcCA9PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnRyYW5zZm9ybShuZXcgUG9pbnREKDAsIDApKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgYSB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgKGZyb20gRWNsaXBzZSB0byBsYXlvdXQpLiBXaGVuIGFuXG4gICAgLy8gaW52ZXJzZSB0cmFuc2Zvcm0gaXMgYXBwbGllZCwgd2UgZ2V0IHVwcGVyLWxlZnQgY29vcmRpbmF0ZSBvZiB0aGVcbiAgICAvLyBkcmF3aW5nIG9yIHRoZSByb290IGdyYXBoIGF0IGdpdmVuIGlucHV0IGNvb3JkaW5hdGUgKHNvbWUgbWFyZ2luc1xuICAgIC8vIGFscmVhZHkgaW5jbHVkZWQgaW4gY2FsY3VsYXRpb24gb2YgbGVmdC10b3ApLlxuXG4gICAgdmFyIHRyYW5zID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgIHZhciBsZWZ0VG9wID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLnVwZGF0ZUxlZnRUb3AoKTtcblxuICAgIGlmIChsZWZ0VG9wICE9IG51bGwpIHtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWChuZXdMZWZ0VG9wLngpO1xuICAgICAgdHJhbnMuc2V0V29ybGRPcmdZKG5ld0xlZnRUb3AueSk7XG5cbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1gobGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldERldmljZU9yZ1kobGVmdFRvcC55KTtcblxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICAgICAgdmFyIG5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnRyYW5zZm9ybSh0cmFucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLnBvc2l0aW9uTm9kZXNSYW5kb21seSA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIGlmIChncmFwaCA9PSB1bmRlZmluZWQpIHtcbiAgICAvL2Fzc2VydCAhdGhpcy5pbmNyZW1lbnRhbDtcbiAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seSh0aGlzLmdldEdyYXBoTWFuYWdlcigpLmdldFJvb3QoKSk7XG4gICAgdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkudXBkYXRlQm91bmRzKHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsTm9kZTtcbiAgICB2YXIgY2hpbGRHcmFwaDtcblxuICAgIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkR3JhcGggPSBsTm9kZS5nZXRDaGlsZCgpO1xuXG4gICAgICBpZiAoY2hpbGRHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRHcmFwaC5nZXROb2RlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGxOb2RlLnNjYXR0ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KGNoaWxkR3JhcGgpO1xuICAgICAgICBsTm9kZS51cGRhdGVCb3VuZHMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbGlzdCBvZiB0cmVlcyB3aGVyZSBlYWNoIHRyZWUgaXMgcmVwcmVzZW50ZWQgYXMgYVxyXG4gKiBsaXN0IG9mIGwtbm9kZXMuIFRoZSBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2Ygc2l6ZSAwIHdoZW46XHJcbiAqIC0gVGhlIGdyYXBoIGlzIG5vdCBmbGF0IG9yXHJcbiAqIC0gT25lIG9mIHRoZSBjb21wb25lbnQocykgb2YgdGhlIGdyYXBoIGlzIG5vdCBhIHRyZWUuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5nZXRGbGF0Rm9yZXN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZmxhdEZvcmVzdCA9IFtdO1xuICB2YXIgaXNGb3Jlc3QgPSB0cnVlO1xuXG4gIC8vIFF1aWNrIHJlZmVyZW5jZSBmb3IgYWxsIG5vZGVzIGluIHRoZSBncmFwaCBtYW5hZ2VyIGFzc29jaWF0ZWQgd2l0aFxuICAvLyB0aGlzIGxheW91dC4gVGhlIGxpc3Qgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkLlxuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKTtcblxuICAvLyBGaXJzdCBiZSBzdXJlIHRoYXQgdGhlIGdyYXBoIGlzIGZsYXRcbiAgdmFyIGlzRmxhdCA9IHRydWU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhbGxOb2Rlc1tpXS5nZXRDaGlsZCgpICE9IG51bGwpIHtcbiAgICAgIGlzRmxhdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybiBlbXB0eSBmb3Jlc3QgaWYgdGhlIGdyYXBoIGlzIG5vdCBmbGF0LlxuICBpZiAoIWlzRmxhdCkge1xuICAgIHJldHVybiBmbGF0Rm9yZXN0O1xuICB9XG5cbiAgLy8gUnVuIEJGUyBmb3IgZWFjaCBjb21wb25lbnQgb2YgdGhlIGdyYXBoLlxuXG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgdG9CZVZpc2l0ZWQgPSBbXTtcbiAgdmFyIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gIHZhciB1blByb2Nlc3NlZE5vZGVzID0gW107XG5cbiAgdW5Qcm9jZXNzZWROb2RlcyA9IHVuUHJvY2Vzc2VkTm9kZXMuY29uY2F0KGFsbE5vZGVzKTtcblxuICAvLyBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgZmluZHMgYSBjb21wb25lbnQgb2YgdGhlIGdyYXBoIGFuZFxuICAvLyBkZWNpZGVzIHdoZXRoZXIgaXQgaXMgYSB0cmVlIG9yIG5vdC4gSWYgaXQgaXMgYSB0cmVlLCBhZGRzIGl0IHRvIHRoZVxuICAvLyBmb3Jlc3QgYW5kIGNvbnRpbnVlZCB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudC5cblxuICB3aGlsZSAodW5Qcm9jZXNzZWROb2Rlcy5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgdG9CZVZpc2l0ZWQucHVzaCh1blByb2Nlc3NlZE5vZGVzWzBdKTtcblxuICAgIC8vIFN0YXJ0IHRoZSBCRlMuIEVhY2ggaXRlcmF0aW9uIG9mIHRoaXMgbG9vcCB2aXNpdHMgYSBub2RlIGluIGFcbiAgICAvLyBCRlMgbWFubmVyLlxuICAgIHdoaWxlICh0b0JlVmlzaXRlZC5sZW5ndGggPiAwICYmIGlzRm9yZXN0KSB7XG4gICAgICAvL3Bvb2wgb3BlcmF0aW9uXG4gICAgICB2YXIgY3VycmVudE5vZGUgPSB0b0JlVmlzaXRlZFswXTtcbiAgICAgIHRvQmVWaXNpdGVkLnNwbGljZSgwLCAxKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcblxuICAgICAgLy8gVHJhdmVyc2UgYWxsIG5laWdoYm9ycyBvZiB0aGlzIG5vZGVcbiAgICAgIHZhciBuZWlnaGJvckVkZ2VzID0gY3VycmVudE5vZGUuZ2V0RWRnZXMoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZWlnaGJvckVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2VzW2ldLmdldE90aGVyRW5kKGN1cnJlbnROb2RlKTtcblxuICAgICAgICAvLyBJZiBCRlMgaXMgbm90IGdyb3dpbmcgZnJvbSB0aGlzIG5laWdoYm9yLlxuICAgICAgICBpZiAocGFyZW50cy5nZXQoY3VycmVudE5vZGUpICE9IGN1cnJlbnROZWlnaGJvcikge1xuICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IuXG4gICAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhjdXJyZW50TmVpZ2hib3IpKSB7XG4gICAgICAgICAgICB0b0JlVmlzaXRlZC5wdXNoKGN1cnJlbnROZWlnaGJvcik7XG4gICAgICAgICAgICBwYXJlbnRzLnNldChjdXJyZW50TmVpZ2hib3IsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBwcmV2aW91c2x5IHZpc2l0ZWQgdGhpcyBuZWlnaGJvciBhbmRcbiAgICAgICAgICAvLyB0aGlzIG5laWdoYm9yIGlzIG5vdCBwYXJlbnQgb2YgY3VycmVudE5vZGUsIGdpdmVuXG4gICAgICAgICAgLy8gZ3JhcGggY29udGFpbnMgYSBjb21wb25lbnQgdGhhdCBpcyBub3QgdHJlZSwgaGVuY2VcbiAgICAgICAgICAvLyBpdCBpcyBub3QgYSBmb3Jlc3QuXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIGlzRm9yZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IGEgdHJlZS4gRW1wdHlcbiAgICAvLyBwcmV2aW91c2x5IGZvdW5kIHRyZWVzLiBUaGUgbWV0aG9kIHdpbGwgZW5kLlxuICAgIGlmICghaXNGb3Jlc3QpIHtcbiAgICAgIGZsYXRGb3Jlc3QgPSBbXTtcbiAgICB9XG4gICAgLy8gU2F2ZSBjdXJyZW50bHkgdmlzaXRlZCBub2RlcyBhcyBhIHRyZWUgaW4gb3VyIGZvcmVzdC4gUmVzZXRcbiAgICAvLyB2aXNpdGVkIGFuZCBwYXJlbnRzIGxpc3RzLiBDb250aW51ZSB3aXRoIHRoZSBuZXh0IGNvbXBvbmVudCBvZlxuICAgIC8vIHRoZSBncmFwaCwgaWYgYW55LlxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdGVtcCA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmlzaXRlZCkpO1xuICAgICAgICBmbGF0Rm9yZXN0LnB1c2godGVtcCk7XG4gICAgICAgIC8vZmxhdEZvcmVzdCA9IGZsYXRGb3Jlc3QuY29uY2F0KHRlbXApO1xuICAgICAgICAvL3VuUHJvY2Vzc2VkTm9kZXMucmVtb3ZlQWxsKHZpc2l0ZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0ZW1wW2ldO1xuICAgICAgICAgIHZhciBpbmRleCA9IHVuUHJvY2Vzc2VkTm9kZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHVuUHJvY2Vzc2VkTm9kZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcGFyZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBmbGF0Rm9yZXN0O1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgZHVtbXkgbm9kZXMgKGFuIGwtbGV2ZWwgbm9kZSB3aXRoIG1pbmltYWwgZGltZW5zaW9ucylcclxuICogZm9yIHRoZSBnaXZlbiBlZGdlIChvbmUgcGVyIGJlbmRwb2ludCkuIFRoZSBleGlzdGluZyBsLWxldmVsIHN0cnVjdHVyZVxyXG4gKiBpcyB1cGRhdGVkIGFjY29yZGluZ2x5LlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMgPSBmdW5jdGlvbiAoZWRnZSkge1xuICB2YXIgZHVtbXlOb2RlcyA9IFtdO1xuICB2YXIgcHJldiA9IGVkZ2Uuc291cmNlO1xuXG4gIHZhciBncmFwaCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvcihlZGdlLnNvdXJjZSwgZWRnZS50YXJnZXQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZS5iZW5kcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15Tm9kZSA9IHRoaXMubmV3Tm9kZShudWxsKTtcbiAgICBkdW1teU5vZGUuc2V0UmVjdChuZXcgUG9pbnQoMCwgMCksIG5ldyBEaW1lbnNpb24oMSwgMSkpO1xuXG4gICAgZ3JhcGguYWRkKGR1bW15Tm9kZSk7XG5cbiAgICAvLyBjcmVhdGUgbmV3IGR1bW15IGVkZ2UgYmV0d2VlbiBwcmV2IGFuZCBkdW1teSBub2RlXG4gICAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5hZGQoZHVtbXlFZGdlLCBwcmV2LCBkdW1teU5vZGUpO1xuXG4gICAgZHVtbXlOb2Rlcy5hZGQoZHVtbXlOb2RlKTtcbiAgICBwcmV2ID0gZHVtbXlOb2RlO1xuICB9XG5cbiAgdmFyIGR1bW15RWRnZSA9IHRoaXMubmV3RWRnZShudWxsKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZWRnZS50YXJnZXQpO1xuXG4gIHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5zZXQoZWRnZSwgZHVtbXlOb2Rlcyk7XG5cbiAgLy8gcmVtb3ZlIHJlYWwgZWRnZSBmcm9tIGdyYXBoIG1hbmFnZXIgaWYgaXQgaXMgaW50ZXItZ3JhcGhcbiAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKCkpIHtcbiAgICB0aGlzLmdyYXBoTWFuYWdlci5yZW1vdmUoZWRnZSk7XG4gIH1cbiAgLy8gZWxzZSwgcmVtb3ZlIHRoZSBlZGdlIGZyb20gdGhlIGN1cnJlbnQgZ3JhcGhcbiAgZWxzZSB7XG4gICAgICBncmFwaC5yZW1vdmUoZWRnZSk7XG4gICAgfVxuXG4gIHJldHVybiBkdW1teU5vZGVzO1xufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYmVuZHBvaW50cyBmb3IgZWRnZXMgZnJvbSB0aGUgZHVtbXkgbm9kZXNcclxuICogYXQgbC1sZXZlbC5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUJlbmRwb2ludHNGcm9tRHVtbXlOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2VzID0gW107XG4gIGVkZ2VzID0gZWRnZXMuY29uY2F0KHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbEVkZ2VzKCkpO1xuICBlZGdlcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5lZGdlVG9EdW1teU5vZGVzLmtleXMoKSkpLmNvbmNhdChlZGdlcyk7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBlZGdlcy5sZW5ndGg7IGsrKykge1xuICAgIHZhciBsRWRnZSA9IGVkZ2VzW2tdO1xuXG4gICAgaWYgKGxFZGdlLmJlbmRwb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHBhdGggPSB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuZ2V0KGxFZGdlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBkdW1teU5vZGUgPSBwYXRoW2ldO1xuICAgICAgICB2YXIgcCA9IG5ldyBQb2ludEQoZHVtbXlOb2RlLmdldENlbnRlclgoKSwgZHVtbXlOb2RlLmdldENlbnRlclkoKSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJlbmRwb2ludCdzIGxvY2F0aW9uIGFjY29yZGluZyB0byBkdW1teSBub2RlXG4gICAgICAgIHZhciBlYnAgPSBsRWRnZS5iZW5kcG9pbnRzLmdldChpKTtcbiAgICAgICAgZWJwLnggPSBwLng7XG4gICAgICAgIGVicC55ID0gcC55O1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHVtbXkgbm9kZSwgZHVtbXkgZWRnZXMgaW5jaWRlbnQgd2l0aCB0aGlzXG4gICAgICAgIC8vIGR1bW15IG5vZGUgaXMgYWxzbyByZW1vdmVkICh3aXRoaW4gdGhlIHJlbW92ZSBtZXRob2QpXG4gICAgICAgIGR1bW15Tm9kZS5nZXRPd25lcigpLnJlbW92ZShkdW1teU5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdGhlIHJlYWwgZWRnZSB0byBncmFwaFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGxFZGdlLCBsRWRnZS5zb3VyY2UsIGxFZGdlLnRhcmdldCk7XG4gICAgfVxuICB9XG59O1xuXG5MYXlvdXQudHJhbnNmb3JtID0gZnVuY3Rpb24gKHNsaWRlclZhbHVlLCBkZWZhdWx0VmFsdWUsIG1pbkRpdiwgbWF4TXVsKSB7XG4gIGlmIChtaW5EaXYgIT0gdW5kZWZpbmVkICYmIG1heE11bCAhPSB1bmRlZmluZWQpIHtcbiAgICB2YXIgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIHZhciBtaW5WYWx1ZSA9IGRlZmF1bHRWYWx1ZSAvIG1pbkRpdjtcbiAgICAgIHZhbHVlIC09IChkZWZhdWx0VmFsdWUgLSBtaW5WYWx1ZSkgLyA1MCAqICg1MCAtIHNsaWRlclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1heFZhbHVlID0gZGVmYXVsdFZhbHVlICogbWF4TXVsO1xuICAgICAgdmFsdWUgKz0gKG1heFZhbHVlIC0gZGVmYXVsdFZhbHVlKSAvIDUwICogKHNsaWRlclZhbHVlIC0gNTApO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYSwgYjtcblxuICAgIGlmIChzbGlkZXJWYWx1ZSA8PSA1MCkge1xuICAgICAgYSA9IDkuMCAqIGRlZmF1bHRWYWx1ZSAvIDUwMC4wO1xuICAgICAgYiA9IGRlZmF1bHRWYWx1ZSAvIDEwLjA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MC4wO1xuICAgICAgYiA9IC04ICogZGVmYXVsdFZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBhICogc2xpZGVyVmFsdWUgKyBiO1xuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gbm9kZXMsIGFzc3VtaW5nXHJcbiAqIHRoYXQgdGhlIGdpdmVuIG5vZGVzIGZvcm0gYSB0cmVlIGluIHRoZW1zZWx2ZXMuXHJcbiAqL1xuTGF5b3V0LmZpbmRDZW50ZXJPZlRyZWUgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgbGlzdCA9IGxpc3QuY29uY2F0KG5vZGVzKTtcblxuICB2YXIgcmVtb3ZlZE5vZGVzID0gW107XG4gIHZhciByZW1haW5pbmdEZWdyZWVzID0gbmV3IE1hcCgpO1xuICB2YXIgZm91bmRDZW50ZXIgPSBmYWxzZTtcbiAgdmFyIGNlbnRlck5vZGUgPSBudWxsO1xuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PSAxIHx8IGxpc3QubGVuZ3RoID09IDIpIHtcbiAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGxpc3RbaV07XG4gICAgdmFyIGRlZ3JlZSA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemU7XG4gICAgcmVtYWluaW5nRGVncmVlcy5zZXQobm9kZSwgbm9kZS5nZXROZWlnaGJvcnNMaXN0KCkuc2l6ZSk7XG5cbiAgICBpZiAoZGVncmVlID09IDEpIHtcbiAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0ZW1wTGlzdCA9IFtdO1xuICB0ZW1wTGlzdCA9IHRlbXBMaXN0LmNvbmNhdChyZW1vdmVkTm9kZXMpO1xuXG4gIHdoaWxlICghZm91bmRDZW50ZXIpIHtcbiAgICB2YXIgdGVtcExpc3QyID0gW107XG4gICAgdGVtcExpc3QyID0gdGVtcExpc3QyLmNvbmNhdCh0ZW1wTGlzdCk7XG4gICAgdGVtcExpc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICB2YXIgaW5kZXggPSBsaXN0LmluZGV4T2Yobm9kZSk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBsaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZWlnaGJvdXJzID0gbm9kZS5nZXROZWlnaGJvcnNMaXN0KCk7XG5cbiAgICAgIG5laWdoYm91cnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3VyKSB7XG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMuaW5kZXhPZihuZWlnaGJvdXIpIDwgMCkge1xuICAgICAgICAgIHZhciBvdGhlckRlZ3JlZSA9IHJlbWFpbmluZ0RlZ3JlZXMuZ2V0KG5laWdoYm91cik7XG4gICAgICAgICAgdmFyIG5ld0RlZ3JlZSA9IG90aGVyRGVncmVlIC0gMTtcblxuICAgICAgICAgIGlmIChuZXdEZWdyZWUgPT0gMSkge1xuICAgICAgICAgICAgdGVtcExpc3QucHVzaChuZWlnaGJvdXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5laWdoYm91ciwgbmV3RGVncmVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlZE5vZGVzID0gcmVtb3ZlZE5vZGVzLmNvbmNhdCh0ZW1wTGlzdCk7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgICBmb3VuZENlbnRlciA9IHRydWU7XG4gICAgICBjZW50ZXJOb2RlID0gbGlzdFswXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2VudGVyTm9kZTtcbn07XG5cbi8qKlxyXG4gKiBEdXJpbmcgdGhlIGNvYXJzZW5pbmcgcHJvY2VzcywgdGhpcyBsYXlvdXQgbWF5IGJlIHJlZmVyZW5jZWQgYnkgdHdvIGdyYXBoIG1hbmFnZXJzXHJcbiAqIHRoaXMgc2V0dGVyIGZ1bmN0aW9uIGdyYW50cyBhY2Nlc3MgdG8gY2hhbmdlIHRoZSBjdXJyZW50bHkgYmVpbmcgdXNlZCBncmFwaCBtYW5hZ2VyXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5zZXRHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoZ20pIHtcbiAgdGhpcy5ncmFwaE1hbmFnZXIgPSBnbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmRvbVNlZWQoKSB7fVxuLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTkzMDM3MjVcblJhbmRvbVNlZWQuc2VlZCA9IDE7XG5SYW5kb21TZWVkLnggPSAwO1xuXG5SYW5kb21TZWVkLm5leHREb3VibGUgPSBmdW5jdGlvbiAoKSB7XG4gIFJhbmRvbVNlZWQueCA9IE1hdGguc2luKFJhbmRvbVNlZWQuc2VlZCsrKSAqIDEwMDAwO1xuICByZXR1cm4gUmFuZG9tU2VlZC54IC0gTWF0aC5mbG9vcihSYW5kb21TZWVkLngpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYW5kb21TZWVkO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm0oeCwgeSkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSAwLjA7XG4gIHRoaXMubHdvcmxkT3JnWSA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWCA9IDAuMDtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IDAuMDtcbiAgdGhpcy5sd29ybGRFeHRYID0gMS4wO1xuICB0aGlzLmx3b3JsZEV4dFkgPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFggPSAxLjA7XG4gIHRoaXMubGRldmljZUV4dFkgPSAxLjA7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1ggPSBmdW5jdGlvbiAod294KSB7XG4gIHRoaXMubHdvcmxkT3JnWCA9IHdveDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZE9yZ1kgPSBmdW5jdGlvbiAod295KSB7XG4gIHRoaXMubHdvcmxkT3JnWSA9IHdveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFggPSBmdW5jdGlvbiAod2V4KSB7XG4gIHRoaXMubHdvcmxkRXh0WCA9IHdleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sd29ybGRFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRXb3JsZEV4dFkgPSBmdW5jdGlvbiAod2V5KSB7XG4gIHRoaXMubHdvcmxkRXh0WSA9IHdleTtcbn07XG5cbi8qIERldmljZSByZWxhdGVkICovXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZU9yZ1g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoZG94KSB7XG4gIHRoaXMubGRldmljZU9yZ1ggPSBkb3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1kgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKGRveSkge1xuICB0aGlzLmxkZXZpY2VPcmdZID0gZG95O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VFeHRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uIChkZXgpIHtcbiAgdGhpcy5sZGV2aWNlRXh0WCA9IGRleDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFkgPSBmdW5jdGlvbiAoZGV5KSB7XG4gIHRoaXMubGRldmljZUV4dFkgPSBkZXk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeERldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WCA9IHRoaXMubHdvcmxkRXh0WDtcbiAgaWYgKHdvcmxkRXh0WCAhPSAwLjApIHtcbiAgICB4RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWCArICh4IC0gdGhpcy5sd29ybGRPcmdYKSAqIHRoaXMubGRldmljZUV4dFggLyB3b3JsZEV4dFg7XG4gIH1cblxuICByZXR1cm4geERldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUudHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5RGV2aWNlID0gMC4wO1xuICB2YXIgd29ybGRFeHRZID0gdGhpcy5sd29ybGRFeHRZO1xuICBpZiAod29ybGRFeHRZICE9IDAuMCkge1xuICAgIHlEZXZpY2UgPSB0aGlzLmxkZXZpY2VPcmdZICsgKHkgLSB0aGlzLmx3b3JsZE9yZ1kpICogdGhpcy5sZGV2aWNlRXh0WSAvIHdvcmxkRXh0WTtcbiAgfVxuXG4gIHJldHVybiB5RGV2aWNlO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWCA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB4V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRYID0gdGhpcy5sZGV2aWNlRXh0WDtcbiAgaWYgKGRldmljZUV4dFggIT0gMC4wKSB7XG4gICAgeFdvcmxkID0gdGhpcy5sd29ybGRPcmdYICsgKHggLSB0aGlzLmxkZXZpY2VPcmdYKSAqIHRoaXMubHdvcmxkRXh0WCAvIGRldmljZUV4dFg7XG4gIH1cblxuICByZXR1cm4geFdvcmxkO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnNlVHJhbnNmb3JtWSA9IGZ1bmN0aW9uICh5KSB7XG4gIHZhciB5V29ybGQgPSAwLjA7XG4gIHZhciBkZXZpY2VFeHRZID0gdGhpcy5sZGV2aWNlRXh0WTtcbiAgaWYgKGRldmljZUV4dFkgIT0gMC4wKSB7XG4gICAgeVdvcmxkID0gdGhpcy5sd29ybGRPcmdZICsgKHkgLSB0aGlzLmxkZXZpY2VPcmdZKSAqIHRoaXMubHdvcmxkRXh0WSAvIGRldmljZUV4dFk7XG4gIH1cbiAgcmV0dXJuIHlXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gKGluUG9pbnQpIHtcbiAgdmFyIG91dFBvaW50ID0gbmV3IFBvaW50RCh0aGlzLmludmVyc2VUcmFuc2Zvcm1YKGluUG9pbnQueCksIHRoaXMuaW52ZXJzZVRyYW5zZm9ybVkoaW5Qb2ludC55KSk7XG4gIHJldHVybiBvdXRQb2ludDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0KCkge1xuICBMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTjtcbiAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEg7XG4gIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUjtcbiAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm9sZFRvdGFsRGlzcGxhY2VtZW50ID0gMC4wO1xuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBGRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUztcbn1cblxuRkRMYXlvdXQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMYXlvdXQpIHtcbiAgRkRMYXlvdXRbcHJvcF0gPSBMYXlvdXRbcHJvcF07XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgTGF5b3V0LnByb3RvdHlwZS5pbml0UGFyYW1ldGVycy5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMgPSAwO1xuICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG5cbiAgdGhpcy51c2VGUkdyaWRWYXJpYW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfUkVQVUxTSU9OX1JBTkdFX0NBTENVTEFUSU9OO1xuXG4gIHRoaXMuZ3JpZCA9IFtdO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNJZGVhbEVkZ2VMZW5ndGhzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIG9yaWdpbmFsSWRlYWxMZW5ndGg7XG4gIHZhciBsY2FEZXB0aDtcbiAgdmFyIHNvdXJjZTtcbiAgdmFyIHRhcmdldDtcbiAgdmFyIHNpemVPZlNvdXJjZUluTGNhO1xuICB2YXIgc2l6ZU9mVGFyZ2V0SW5MY2E7XG5cbiAgdmFyIGFsbEVkZ2VzID0gdGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRBbGxFZGdlcygpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuXG4gICAgb3JpZ2luYWxJZGVhbExlbmd0aCA9IGVkZ2UuaWRlYWxMZW5ndGg7XG5cbiAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgIHNvdXJjZSA9IGVkZ2UuZ2V0U291cmNlKCk7XG4gICAgICB0YXJnZXQgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gICAgICBzaXplT2ZTb3VyY2VJbkxjYSA9IGVkZ2UuZ2V0U291cmNlSW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG4gICAgICBzaXplT2ZUYXJnZXRJbkxjYSA9IGVkZ2UuZ2V0VGFyZ2V0SW5MY2EoKS5nZXRFc3RpbWF0ZWRTaXplKCk7XG5cbiAgICAgIGlmICh0aGlzLnVzZVNtYXJ0SWRlYWxFZGdlTGVuZ3RoQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgZWRnZS5pZGVhbExlbmd0aCArPSBzaXplT2ZTb3VyY2VJbkxjYSArIHNpemVPZlRhcmdldEluTGNhIC0gMiAqIExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFO1xuICAgICAgfVxuXG4gICAgICBsY2FEZXB0aCA9IGVkZ2UuZ2V0TGNhKCkuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG5cbiAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gb3JpZ2luYWxJZGVhbExlbmd0aCAqIEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgKiAoc291cmNlLmdldEluY2x1c2lvblRyZWVEZXB0aCgpICsgdGFyZ2V0LmdldEluY2x1c2lvblRyZWVEZXB0aCgpIC0gMiAqIGxjYURlcHRoKTtcbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHMgPSB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuICBpZiAodGhpcy5pbmNyZW1lbnRhbCkge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heCh0aGlzLmNvb2xpbmdGYWN0b3IgKiBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCB0aGlzLmNvb2xpbmdGYWN0b3IgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqIHRoaXMuY29vbGluZ0ZhY3RvciAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH1cbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUw7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHMgPiBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IsIDEuMCAtIChzIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAvIChGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX1VQUEVSX05PREVfTElNSVQgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpICogKDEgLSBGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IDEuMDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsQ29vbGluZ0ZhY3RvciA9IHRoaXMuY29vbGluZ0ZhY3RvcjtcbiAgICB0aGlzLm1heE5vZGVEaXNwbGFjZW1lbnQgPSBGRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlQ7XG4gIH1cblxuICB0aGlzLm1heEl0ZXJhdGlvbnMgPSBNYXRoLm1heCh0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoICogNSwgdGhpcy5tYXhJdGVyYXRpb25zKTtcblxuICAvLyBSZWFzc2lnbiB0aGlzIGF0dHJpYnV0ZSBieSB1c2luZyBuZXcgY29uc3RhbnQgdmFsdWVcbiAgdGhpcy5kaXNwbGFjZW1lbnRUaHJlc2hvbGRQZXJOb2RlID0gMy4wICogRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAvIDEwMDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudFRocmVzaG9sZCA9IHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSAqIHRoaXMuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG5cbiAgdGhpcy5yZXB1bHNpb25SYW5nZSA9IHRoaXMuY2FsY1JlcHVsc2lvblJhbmdlKCk7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxFZGdlcyA9IHRoaXMuZ2V0QWxsRWRnZXMoKTtcbiAgdmFyIGVkZ2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlZGdlID0gbEVkZ2VzW2ldO1xuXG4gICAgdGhpcy5jYWxjU3ByaW5nRm9yY2UoZWRnZSwgZWRnZS5pZGVhbExlbmd0aCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JpZFVwZGF0ZUFsbG93ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gIHZhciBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaSwgajtcbiAgdmFyIG5vZGVBLCBub2RlQjtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIHByb2Nlc3NlZE5vZGVTZXQ7XG5cbiAgaWYgKHRoaXMudXNlRlJHcmlkVmFyaWFudCkge1xuICAgIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgIH1cblxuICAgIHByb2Nlc3NlZE5vZGVTZXQgPSBuZXcgU2V0KCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIGVhY2ggbm9kZXMgYW5kIGl0cyBzdXJyb3VuZGluZ1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgICAgdGhpcy5jYWxjdWxhdGVSZXB1bHNpb25Gb3JjZU9mQU5vZGUobm9kZUEsIHByb2Nlc3NlZE5vZGVTZXQsIGdyaWRVcGRhdGVBbGxvd2VkLCBmb3JjZVRvTm9kZVN1cnJvdW5kaW5nVXBkYXRlKTtcbiAgICAgIHByb2Nlc3NlZE5vZGVTZXQuYWRkKG5vZGVBKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZUEgPSBsTm9kZXNbaV07XG5cbiAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG5vZGVCID0gbE5vZGVzW2pdO1xuXG4gICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBza2lwLlxuICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZShub2RlQSwgbm9kZUIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5jYWxjR3Jhdml0YXRpb25hbEZvcmNlKG5vZGUpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUubW92ZU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbE5vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpO1xuICB2YXIgbm9kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjU3ByaW5nRm9yY2UgPSBmdW5jdGlvbiAoZWRnZSwgaWRlYWxMZW5ndGgpIHtcbiAgdmFyIHNvdXJjZU5vZGUgPSBlZGdlLmdldFNvdXJjZSgpO1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgdmFyIGxlbmd0aDtcbiAgdmFyIHNwcmluZ0ZvcmNlO1xuICB2YXIgc3ByaW5nRm9yY2VYO1xuICB2YXIgc3ByaW5nRm9yY2VZO1xuXG4gIC8vIFVwZGF0ZSBlZGdlIGxlbmd0aFxuICBpZiAodGhpcy51bmlmb3JtTGVhZk5vZGVTaXplcyAmJiBzb3VyY2VOb2RlLmdldENoaWxkKCkgPT0gbnVsbCAmJiB0YXJnZXROb2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoU2ltcGxlKCk7XG4gIH0gZWxzZSB7XG4gICAgZWRnZS51cGRhdGVMZW5ndGgoKTtcblxuICAgIGlmIChlZGdlLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxlbmd0aCA9IGVkZ2UuZ2V0TGVuZ3RoKCk7XG5cbiAgaWYgKGxlbmd0aCA9PSAwKSByZXR1cm47XG5cbiAgLy8gQ2FsY3VsYXRlIHNwcmluZyBmb3JjZXNcbiAgc3ByaW5nRm9yY2UgPSBlZGdlLmVkZ2VFbGFzdGljaXR5ICogKGxlbmd0aCAtIGlkZWFsTGVuZ3RoKTtcblxuICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gIHNwcmluZ0ZvcmNlWCA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWCAvIGxlbmd0aCk7XG4gIHNwcmluZ0ZvcmNlWSA9IHNwcmluZ0ZvcmNlICogKGVkZ2UubGVuZ3RoWSAvIGxlbmd0aCk7XG5cbiAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSBlbmQgbm9kZXNcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVggKz0gc3ByaW5nRm9yY2VYO1xuICBzb3VyY2VOb2RlLnNwcmluZ0ZvcmNlWSArPSBzcHJpbmdGb3JjZVk7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VYIC09IHNwcmluZ0ZvcmNlWDtcbiAgdGFyZ2V0Tm9kZS5zcHJpbmdGb3JjZVkgLT0gc3ByaW5nRm9yY2VZO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25Gb3JjZSA9IGZ1bmN0aW9uIChub2RlQSwgbm9kZUIpIHtcbiAgdmFyIHJlY3RBID0gbm9kZUEuZ2V0UmVjdCgpO1xuICB2YXIgcmVjdEIgPSBub2RlQi5nZXRSZWN0KCk7XG4gIHZhciBvdmVybGFwQW1vdW50ID0gbmV3IEFycmF5KDIpO1xuICB2YXIgY2xpcFBvaW50cyA9IG5ldyBBcnJheSg0KTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGRpc3RhbmNlU3F1YXJlZDtcbiAgdmFyIGRpc3RhbmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2U7XG4gIHZhciByZXB1bHNpb25Gb3JjZVg7XG4gIHZhciByZXB1bHNpb25Gb3JjZVk7XG5cbiAgaWYgKHJlY3RBLmludGVyc2VjdHMocmVjdEIpKSAvLyB0d28gbm9kZXMgb3ZlcmxhcFxuICAgIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBzZXBhcmF0aW9uIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnNcbiAgICAgIElHZW9tZXRyeS5jYWxjU2VwYXJhdGlvbkFtb3VudChyZWN0QSwgcmVjdEIsIG92ZXJsYXBBbW91bnQsIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAyLjApO1xuXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSAyICogb3ZlcmxhcEFtb3VudFswXTtcbiAgICAgIHJlcHVsc2lvbkZvcmNlWSA9IDIgKiBvdmVybGFwQW1vdW50WzFdO1xuXG4gICAgICB2YXIgY2hpbGRyZW5Db25zdGFudCA9IG5vZGVBLm5vT2ZDaGlsZHJlbiAqIG5vZGVCLm5vT2ZDaGlsZHJlbiAvIChub2RlQS5ub09mQ2hpbGRyZW4gKyBub2RlQi5ub09mQ2hpbGRyZW4pO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2Rlc1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VYIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VZICs9IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgfSBlbHNlIC8vIG5vIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGlzdGFuY2VcblxuICAgICAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgbm9kZUEuZ2V0Q2hpbGQoKSA9PSBudWxsICYmIG5vZGVCLmdldENoaWxkKCkgPT0gbnVsbCkgLy8gc2ltcGx5IGJhc2UgcmVwdWxzaW9uIG9uIGRpc3RhbmNlIG9mIG5vZGUgY2VudGVyc1xuICAgICAgICB7XG4gICAgICAgICAgZGlzdGFuY2VYID0gcmVjdEIuZ2V0Q2VudGVyWCgpIC0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IHJlY3RCLmdldENlbnRlclkoKSAtIHJlY3RBLmdldENlbnRlclkoKTtcbiAgICAgICAgfSBlbHNlIC8vIHVzZSBjbGlwcGluZyBwb2ludHNcbiAgICAgICAge1xuICAgICAgICAgIElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24ocmVjdEEsIHJlY3RCLCBjbGlwUG9pbnRzKTtcblxuICAgICAgICAgIGRpc3RhbmNlWCA9IGNsaXBQb2ludHNbMl0gLSBjbGlwUG9pbnRzWzBdO1xuICAgICAgICAgIGRpc3RhbmNlWSA9IGNsaXBQb2ludHNbM10gLSBjbGlwUG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgIC8vIE5vIHJlcHVsc2lvbiByYW5nZS4gRlIgZ3JpZCB2YXJpYW50IHNob3VsZCB0YWtlIGNhcmUgb2YgdGhpcy5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVgpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWCA9IElNYXRoLnNpZ24oZGlzdGFuY2VYKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlWSkgPCBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QpIHtcbiAgICAgICAgZGlzdGFuY2VZID0gSU1hdGguc2lnbihkaXN0YW5jZVkpICogRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUO1xuICAgICAgfVxuXG4gICAgICBkaXN0YW5jZVNxdWFyZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQpO1xuXG4gICAgICAvLyBIZXJlIHdlIHVzZSBoYWxmIG9mIHRoZSBub2RlcycgcmVwdWxzaW9uIHZhbHVlcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgcmVwdWxzaW9uRm9yY2UgPSAobm9kZUEubm9kZVJlcHVsc2lvbiAvIDIgKyBub2RlQi5ub2RlUmVwdWxzaW9uIC8gMikgKiBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyBkaXN0YW5jZVNxdWFyZWQ7XG5cbiAgICAgIC8vIFByb2plY3QgZm9yY2Ugb250byB4IGFuZCB5IGF4ZXNcbiAgICAgIHJlcHVsc2lvbkZvcmNlWCA9IHJlcHVsc2lvbkZvcmNlICogZGlzdGFuY2VYIC8gZGlzdGFuY2U7XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWSAvIGRpc3RhbmNlO1xuXG4gICAgICAvLyBBcHBseSBmb3JjZXMgb24gdGhlIHR3byBub2RlcyAgICBcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVkgLT0gcmVwdWxzaW9uRm9yY2VZO1xuICAgICAgbm9kZUIucmVwdWxzaW9uRm9yY2VYICs9IHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSByZXB1bHNpb25Gb3JjZVk7XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2UgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgb3duZXJHcmFwaDtcbiAgdmFyIG93bmVyQ2VudGVyWDtcbiAgdmFyIG93bmVyQ2VudGVyWTtcbiAgdmFyIGRpc3RhbmNlWDtcbiAgdmFyIGRpc3RhbmNlWTtcbiAgdmFyIGFic0Rpc3RhbmNlWDtcbiAgdmFyIGFic0Rpc3RhbmNlWTtcbiAgdmFyIGVzdGltYXRlZFNpemU7XG4gIG93bmVyR3JhcGggPSBub2RlLmdldE93bmVyKCk7XG5cbiAgb3duZXJDZW50ZXJYID0gKG93bmVyR3JhcGguZ2V0UmlnaHQoKSArIG93bmVyR3JhcGguZ2V0TGVmdCgpKSAvIDI7XG4gIG93bmVyQ2VudGVyWSA9IChvd25lckdyYXBoLmdldFRvcCgpICsgb3duZXJHcmFwaC5nZXRCb3R0b20oKSkgLyAyO1xuICBkaXN0YW5jZVggPSBub2RlLmdldENlbnRlclgoKSAtIG93bmVyQ2VudGVyWDtcbiAgZGlzdGFuY2VZID0gbm9kZS5nZXRDZW50ZXJZKCkgLSBvd25lckNlbnRlclk7XG4gIGFic0Rpc3RhbmNlWCA9IE1hdGguYWJzKGRpc3RhbmNlWCkgKyBub2RlLmdldFdpZHRoKCkgLyAyO1xuICBhYnNEaXN0YW5jZVkgPSBNYXRoLmFicyhkaXN0YW5jZVkpICsgbm9kZS5nZXRIZWlnaHQoKSAvIDI7XG5cbiAgaWYgKG5vZGUuZ2V0T3duZXIoKSA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIC8vIGluIHRoZSByb290IGdyYXBoXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5ncmF2aXR5UmFuZ2VGYWN0b3I7XG5cbiAgICAgIGlmIChhYnNEaXN0YW5jZVggPiBlc3RpbWF0ZWRTaXplIHx8IGFic0Rpc3RhbmNlWSA+IGVzdGltYXRlZFNpemUpIHtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWCA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWTtcbiAgICAgIH1cbiAgICB9IGVsc2UgLy8gaW5zaWRlIGEgY29tcG91bmRcbiAgICB7XG4gICAgICBlc3RpbWF0ZWRTaXplID0gb3duZXJHcmFwaC5nZXRFc3RpbWF0ZWRTaXplKCkgKiB0aGlzLmNvbXBvdW5kR3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVggKiB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50O1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VZID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VZICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgIH1cbiAgICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaXNDb252ZXJnZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb252ZXJnZWQ7XG4gIHZhciBvc2NpbGF0aW5nID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zID4gdGhpcy5tYXhJdGVyYXRpb25zIC8gMykge1xuICAgIG9zY2lsYXRpbmcgPSBNYXRoLmFicyh0aGlzLnRvdGFsRGlzcGxhY2VtZW50IC0gdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCkgPCAyO1xuICB9XG5cbiAgY29udmVyZ2VkID0gdGhpcy50b3RhbERpc3BsYWNlbWVudCA8IHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG5cbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQ7XG5cbiAgcmV0dXJuIGNvbnZlcmdlZCB8fCBvc2NpbGF0aW5nO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCAmJiAhdGhpcy5pc1N1YkxheW91dCkge1xuICAgIGlmICh0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9PSB0aGlzLmFuaW1hdGlvblBlcmlvZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH1cbn07XG5cbi8vVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuICh3ZWlnaHQpIGZvciBhbGwgbm9kZXNcbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjTm9PZkNoaWxkcmVuRm9yQWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBub2RlO1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgbm9kZS5ub09mQ2hpbGRyZW4gPSBub2RlLmdldE5vT2ZDaGlsZHJlbigpO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogRlItR3JpZCBWYXJpYW50IFJlcHVsc2lvbiBGb3JjZSBDYWxjdWxhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNHcmlkID0gZnVuY3Rpb24gKGdyYXBoKSB7XG5cbiAgdmFyIHNpemVYID0gMDtcbiAgdmFyIHNpemVZID0gMDtcblxuICBzaXplWCA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0UmlnaHQoKSAtIGdyYXBoLmdldExlZnQoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHNpemVZID0gcGFyc2VJbnQoTWF0aC5jZWlsKChncmFwaC5nZXRCb3R0b20oKSAtIGdyYXBoLmdldFRvcCgpKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcblxuICB2YXIgZ3JpZCA9IG5ldyBBcnJheShzaXplWCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZ3JpZFtpXSA9IG5ldyBBcnJheShzaXplWSk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemVYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNpemVZOyBqKyspIHtcbiAgICAgIGdyaWRbaV1bal0gPSBuZXcgQXJyYXkoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ3JpZDtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hZGROb2RlVG9HcmlkID0gZnVuY3Rpb24gKHYsIGxlZnQsIHRvcCkge1xuXG4gIHZhciBzdGFydFggPSAwO1xuICB2YXIgZmluaXNoWCA9IDA7XG4gIHZhciBzdGFydFkgPSAwO1xuICB2YXIgZmluaXNoWSA9IDA7XG5cbiAgc3RhcnRYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hYID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkud2lkdGggKyB2LmdldFJlY3QoKS54IC0gbGVmdCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG4gIHN0YXJ0WSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBmaW5pc2hZID0gcGFyc2VJbnQoTWF0aC5mbG9vcigodi5nZXRSZWN0KCkuaGVpZ2h0ICsgdi5nZXRSZWN0KCkueSAtIHRvcCkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0WDsgaSA8PSBmaW5pc2hYOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gc3RhcnRZOyBqIDw9IGZpbmlzaFk7IGorKykge1xuICAgICAgdGhpcy5ncmlkW2ldW2pdLnB1c2godik7XG4gICAgICB2LnNldEdyaWRDb29yZGluYXRlcyhzdGFydFgsIGZpbmlzaFgsIHN0YXJ0WSwgZmluaXNoWSk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUudXBkYXRlR3JpZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGk7XG4gIHZhciBub2RlQTtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcblxuICB0aGlzLmdyaWQgPSB0aGlzLmNhbGNHcmlkKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG5cbiAgLy8gcHV0IGFsbCBub2RlcyB0byBwcm9wZXIgZ3JpZCBjZWxsc1xuICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZUEgPSBsTm9kZXNbaV07XG4gICAgdGhpcy5hZGROb2RlVG9HcmlkKG5vZGVBLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0TGVmdCgpLCB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0VG9wKCkpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlID0gZnVuY3Rpb24gKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyAlIEZETGF5b3V0Q29uc3RhbnRzLkdSSURfQ0FMQ1VMQVRJT05fQ0hFQ0tfUEVSSU9EID09IDEgJiYgZ3JpZFVwZGF0ZUFsbG93ZWQgfHwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSkge1xuICAgIHZhciBzdXJyb3VuZGluZyA9IG5ldyBTZXQoKTtcbiAgICBub2RlQS5zdXJyb3VuZGluZyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBub2RlQjtcbiAgICB2YXIgZ3JpZCA9IHRoaXMuZ3JpZDtcblxuICAgIGZvciAodmFyIGkgPSBub2RlQS5zdGFydFggLSAxOyBpIDwgbm9kZUEuZmluaXNoWCArIDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IG5vZGVBLnN0YXJ0WSAtIDE7IGogPCBub2RlQS5maW5pc2hZICsgMjsgaisrKSB7XG4gICAgICAgIGlmICghKGkgPCAwIHx8IGogPCAwIHx8IGkgPj0gZ3JpZC5sZW5ndGggfHwgaiA+PSBncmlkWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGdyaWRbaV1bal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgIG5vZGVCID0gZ3JpZFtpXVtqXVtrXTtcblxuICAgICAgICAgICAgLy8gSWYgYm90aCBub2RlcyBhcmUgbm90IG1lbWJlcnMgb2YgdGhlIHNhbWUgZ3JhcGgsIFxuICAgICAgICAgICAgLy8gb3IgYm90aCBub2RlcyBhcmUgdGhlIHNhbWUsIHNraXAuXG4gICAgICAgICAgICBpZiAobm9kZUEuZ2V0T3duZXIoKSAhPSBub2RlQi5nZXRPd25lcigpIHx8IG5vZGVBID09IG5vZGVCKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVwdWxzaW9uIGZvcmNlIGJldHdlZW5cbiAgICAgICAgICAgIC8vIG5vZGVBIGFuZCBub2RlQiBoYXMgYWxyZWFkeSBiZWVuIGNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc2VkTm9kZVNldC5oYXMobm9kZUIpICYmICFzdXJyb3VuZGluZy5oYXMobm9kZUIpKSB7XG4gICAgICAgICAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLmFicyhub2RlQS5nZXRDZW50ZXJYKCkgLSBub2RlQi5nZXRDZW50ZXJYKCkpIC0gKG5vZGVBLmdldFdpZHRoKCkgLyAyICsgbm9kZUIuZ2V0V2lkdGgoKSAvIDIpO1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VZID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWSgpIC0gbm9kZUIuZ2V0Q2VudGVyWSgpKSAtIChub2RlQS5nZXRIZWlnaHQoKSAvIDIgKyBub2RlQi5nZXRIZWlnaHQoKSAvIDIpO1xuXG4gICAgICAgICAgICAgIC8vIGlmIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIG5vZGVBIGFuZCBub2RlQiBcbiAgICAgICAgICAgICAgLy8gaXMgbGVzcyB0aGVuIGNhbGN1bGF0aW9uIHJhbmdlXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZVggPD0gdGhpcy5yZXB1bHNpb25SYW5nZSAmJiBkaXN0YW5jZVkgPD0gdGhpcy5yZXB1bHNpb25SYW5nZSkge1xuICAgICAgICAgICAgICAgIC8vdGhlbiBhZGQgbm9kZUIgdG8gc3Vycm91bmRpbmcgb2Ygbm9kZUFcbiAgICAgICAgICAgICAgICBzdXJyb3VuZGluZy5hZGQobm9kZUIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHN1cnJvdW5kaW5nKSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG5vZGVBLnN1cnJvdW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVBLnN1cnJvdW5kaW5nW2ldKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDAuMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXQ7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIEZETGF5b3V0RWRnZShzb3VyY2UsIHRhcmdldCwgdkVkZ2UpIHtcbiAgTEVkZ2UuY2FsbCh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdkVkZ2UpO1xuXG4gIC8vIElkZWFsIGxlbmd0aCBhbmQgZWxhc3RpY2l0eSB2YWx1ZSBmb3IgdGhpcyBlZGdlXG4gIHRoaXMuaWRlYWxMZW5ndGggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICB0aGlzLmVkZ2VFbGFzdGljaXR5ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9TUFJJTkdfU1RSRU5HVEg7XG59XG5cbkZETGF5b3V0RWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExFZGdlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTEVkZ2UpIHtcbiAgRkRMYXlvdXRFZGdlW3Byb3BdID0gTEVkZ2VbcHJvcF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRkRMYXlvdXRFZGdlO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBGRExheW91dE5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgLy8gYWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgaXMgaGFuZGxlZCBpbnNpZGUgTE5vZGVcbiAgTE5vZGUuY2FsbCh0aGlzLCBnbSwgbG9jLCBzaXplLCB2Tm9kZSk7XG5cbiAgLy8gUmVwdWxzaW9uIHZhbHVlIG9mIHRoaXMgbm9kZVxuICB0aGlzLm5vZGVSZXB1bHNpb24gPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX1JFUFVMU0lPTl9TVFJFTkdUSDtcblxuICAvL1NwcmluZywgcmVwdWxzaW9uIGFuZCBncmF2aXRhdGlvbmFsIGZvcmNlcyBhY3Rpbmcgb24gdGhpcyBub2RlXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICAvL0Ftb3VudCBieSB3aGljaCB0aGlzIG5vZGUgaXMgdG8gYmUgbW92ZWQgaW4gdGhpcyBpdGVyYXRpb25cbiAgdGhpcy5kaXNwbGFjZW1lbnRYID0gMDtcbiAgdGhpcy5kaXNwbGFjZW1lbnRZID0gMDtcblxuICAvL1N0YXJ0IGFuZCBmaW5pc2ggZ3JpZCBjb29yZGluYXRlcyB0aGF0IHRoaXMgbm9kZSBpcyBmYWxsZW4gaW50b1xuICB0aGlzLnN0YXJ0WCA9IDA7XG4gIHRoaXMuZmluaXNoWCA9IDA7XG4gIHRoaXMuc3RhcnRZID0gMDtcbiAgdGhpcy5maW5pc2hZID0gMDtcblxuICAvL0dlb21ldHJpYyBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gIHRoaXMuc3Vycm91bmRpbmcgPSBbXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTE5vZGUucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMTm9kZSkge1xuICBGRExheW91dE5vZGVbcHJvcF0gPSBMTm9kZVtwcm9wXTtcbn1cblxuRkRMYXlvdXROb2RlLnByb3RvdHlwZS5zZXRHcmlkQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiAoX3N0YXJ0WCwgX2ZpbmlzaFgsIF9zdGFydFksIF9maW5pc2hZKSB7XG4gIHRoaXMuc3RhcnRYID0gX3N0YXJ0WDtcbiAgdGhpcy5maW5pc2hYID0gX2ZpbmlzaFg7XG4gIHRoaXMuc3RhcnRZID0gX3N0YXJ0WTtcbiAgdGhpcy5maW5pc2hZID0gX2ZpbmlzaFk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0Tm9kZTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBEaW1lbnNpb25EKHdpZHRoLCBoZWlnaHQpIHtcbiAgdGhpcy53aWR0aCA9IDA7XG4gIHRoaXMuaGVpZ2h0ID0gMDtcbiAgaWYgKHdpZHRoICE9PSBudWxsICYmIGhlaWdodCAhPT0gbnVsbCkge1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgfVxufVxuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMud2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLndpZHRoID0gd2lkdGg7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmhlaWdodDtcbn07XG5cbkRpbWVuc2lvbkQucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERpbWVuc2lvbkQ7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hNYXAoKSB7XG4gIHRoaXMubWFwID0ge307XG4gIHRoaXMua2V5cyA9IFtdO1xufVxuXG5IYXNoTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICBpZiAoIXRoaXMuY29udGFpbnModGhlSWQpKSB7XG4gICAgdGhpcy5tYXBbdGhlSWRdID0gdmFsdWU7XG4gICAgdGhpcy5rZXlzLnB1c2goa2V5KTtcbiAgfVxufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFtrZXldICE9IG51bGw7XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKGtleSk7XG4gIHJldHVybiB0aGlzLm1hcFt0aGVJZF07XG59O1xuXG5IYXNoTWFwLnByb3RvdHlwZS5rZXlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmtleXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hNYXA7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIFVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbmZ1bmN0aW9uIEhhc2hTZXQoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59XG47XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkgdGhpcy5zZXRbdGhlSWRdID0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG9iaikge1xuICBkZWxldGUgdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV07XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZXQgPSB7fTtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdGhpcy5zZXRbVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQob2JqKV0gPT0gb2JqO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2l6ZSgpID09PSAwO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0KS5sZW5ndGg7XG59O1xuXG4vL2NvbmNhdHMgdGhpcy5zZXQgdG8gdGhlIGdpdmVuIGxpc3Rcbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbFRvID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnNldCk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpc3QucHVzaCh0aGlzLnNldFtrZXlzW2ldXSk7XG4gIH1cbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgdmFyIHMgPSBsaXN0Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgdiA9IGxpc3RbaV07XG4gICAgdGhpcy5hZGQodik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFzaFNldDtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vLyBTb21lIG1hdHJpeCAoMWQgYW5kIDJkIGFycmF5KSBvcGVyYXRpb25zXG5mdW5jdGlvbiBNYXRyaXgoKSB7fVxuXG4vKipcbiAqIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TWF0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkyWzBdLmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSAwO1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBhcnJheTFbMF0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcmVzdWx0W2ldW2pdICs9IGFycmF5MVtpXVtrXSAqIGFycmF5MltrXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogbWF0cml4IHRyYW5zcG9zZVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSBhcnJheVtqXVtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhcnJheSB3aXRoIGNvbnN0YW50XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4Lm11bHRDb25zID0gZnVuY3Rpb24gKGFycmF5LCBjb25zdGFudCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5W2ldICogY29uc3RhbnQ7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBzdWJzdHJhY3QgdHdvIGFycmF5c1xuICogYXJyYXkxLCBhcnJheTIgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlzXG4gKi9cbk1hdHJpeC5taW51c09wID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5MVtpXSAtIGFycmF5MltpXTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgd2l0aCBzYW1lIHNpemVcbiAqIGFycmF5MSBhbmQgYXJyYXkyIGFyZSAxZCBhcnJheXNcbiAqL1xuTWF0cml4LmRvdFByb2R1Y3QgPSBmdW5jdGlvbiAoYXJyYXkxLCBhcnJheTIpIHtcbiAgdmFyIHByb2R1Y3QgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgcHJvZHVjdCArPSBhcnJheTFbaV0gKiBhcnJheTJbaV07XG4gIH1cblxuICByZXR1cm4gcHJvZHVjdDtcbn07XG5cbi8qKlxuICogbWFnbml0dWRlIG9mIGFuIGFycmF5XG4gKiBhcnJheSBpcyAxZCBhcnJheVxuICovXG5NYXRyaXgubWFnID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHJldHVybiBNYXRoLnNxcnQodGhpcy5kb3RQcm9kdWN0KGFycmF5LCBhcnJheSkpO1xufTtcblxuLyoqXG4gKiBub3JtYWxpemF0aW9uIG9mIGFuIGFycmF5XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheVxuICovXG5NYXRyaXgubm9ybWFsaXplID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIG1hZ25pdHVkZSA9IHRoaXMubWFnKGFycmF5KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gYXJyYXlbaV0gLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBtdWx0aXBseSBhbiBhcnJheSB3aXRoIGNlbnRlcmluZyBtYXRyaXhcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkIGFycmF5XG4gKi9cbk1hdHJpeC5tdWx0R2FtbWEgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgc3VtID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3VtICs9IGFycmF5W2ldO1xuICB9XG5cbiAgc3VtICo9IC0xIC8gYXJyYXkubGVuZ3RoO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICByZXN1bHRbX2ldID0gc3VtICsgYXJyYXlbX2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIGEgc3BlY2lhbCBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIHJlc3VsdCA9IDAuNSAqIEMgKiBJTlYgKiBDXlQgKiBhcnJheVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQsIEMgYW5kIElOViBhcmUgMmQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0TCA9IGZ1bmN0aW9uIChhcnJheSwgQywgSU5WKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRlbXAxID0gW107XG4gIHZhciB0ZW1wMiA9IFtdO1xuXG4gIC8vIG11bHRpcGx5IGJ5IENeVFxuICBmb3IgKHZhciBpID0gMDsgaSA8IENbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3VtID0gMDtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IEMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHN1bSArPSAtMC41ICogQ1tqXVtpXSAqIGFycmF5W2pdO1xuICAgIH1cbiAgICB0ZW1wMVtpXSA9IHN1bTtcbiAgfVxuICAvLyBtdWx0aXBseSB0aGUgcmVzdWx0IGJ5IElOVlxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBJTlYubGVuZ3RoOyBfaTIrKykge1xuICAgIHZhciBfc3VtID0gMDtcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgSU5WLmxlbmd0aDsgX2orKykge1xuICAgICAgX3N1bSArPSBJTlZbX2kyXVtfal0gKiB0ZW1wMVtfal07XG4gICAgfVxuICAgIHRlbXAyW19pMl0gPSBfc3VtO1xuICB9XG4gIC8vIG11bHRpcGx5IHRoZSByZXN1bHQgYnkgQ1xuICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBDLmxlbmd0aDsgX2kzKyspIHtcbiAgICB2YXIgX3N1bTIgPSAwO1xuICAgIGZvciAodmFyIF9qMiA9IDA7IF9qMiA8IENbMF0ubGVuZ3RoOyBfajIrKykge1xuICAgICAgX3N1bTIgKz0gQ1tfaTNdW19qMl0gKiB0ZW1wMltfajJdO1xuICAgIH1cbiAgICByZXN1bHRbX2kzXSA9IF9zdW0yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4O1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogQSBjbGFzc2ljIFF1aWNrc29ydCBhbGdvcml0aG0gd2l0aCBIb2FyZSdzIHBhcnRpdGlvblxuICogLSBXb3JrcyBhbHNvIG9uIExpbmtlZExpc3Qgb2JqZWN0c1xuICpcbiAqIENvcHlyaWdodDogaS1WaXMgUmVzZWFyY2ggR3JvdXAsIEJpbGtlbnQgVW5pdmVyc2l0eSwgMjAwNyAtIHByZXNlbnRcbiAqL1xuXG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgUXVpY2tzb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1aWNrc29ydChBLCBjb21wYXJlRnVuY3Rpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1aWNrc29ydCk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmVGdW5jdGlvbiAhPT0gbnVsbCB8fCBjb21wYXJlRnVuY3Rpb24gIT09IHVuZGVmaW5lZCkgdGhpcy5jb21wYXJlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB2b2lkIDA7XG4gICAgICAgIGlmIChBIGluc3RhbmNlb2YgTGlua2VkTGlzdCkgbGVuZ3RoID0gQS5zaXplKCk7ZWxzZSBsZW5ndGggPSBBLmxlbmd0aDtcblxuICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgMCwgbGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFF1aWNrc29ydCwgW3tcbiAgICAgICAga2V5OiAnX3F1aWNrc29ydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcXVpY2tzb3J0KEEsIHAsIHIpIHtcbiAgICAgICAgICAgIGlmIChwIDwgcikge1xuICAgICAgICAgICAgICAgIHZhciBxID0gdGhpcy5fcGFydGl0aW9uKEEsIHAsIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1aWNrc29ydChBLCBwLCBxKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcSArIDEsIHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcGFydGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aXRpb24oQSwgcCwgcikge1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLl9nZXQoQSwgcCk7XG4gICAgICAgICAgICB2YXIgaSA9IHA7XG4gICAgICAgICAgICB2YXIgaiA9IHI7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih4LCB0aGlzLl9nZXQoQSwgaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgICAgICB9d2hpbGUgKHRoaXMuY29tcGFyZUZ1bmN0aW9uKHRoaXMuX2dldChBLCBpKSwgeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1pZiAoaSA8IGopIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3dhcChBLCBpLCBqKTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHJldHVybiBqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXQob2JqZWN0LCBpbmRleCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIHJldHVybiBvYmplY3QuZ2V0X29iamVjdF9hdChpbmRleCk7ZWxzZSByZXR1cm4gb2JqZWN0W2luZGV4XTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0KG9iamVjdCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTGlua2VkTGlzdCkgb2JqZWN0LnNldF9vYmplY3RfYXQoaW5kZXgsIHZhbHVlKTtlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3N3YXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3N3YXAoQSwgaSwgaikge1xuICAgICAgICAgICAgdmFyIHRlbXAgPSB0aGlzLl9nZXQoQSwgaSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaSwgdGhpcy5fZ2V0KEEsIGopKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChBLCBqLCB0ZW1wKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RlZmF1bHRDb21wYXJlRnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIgPiBhO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFF1aWNrc29ydDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWlja3NvcnQ7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbiBpbXBsZW1lbnRhdGlvblxuZnVuY3Rpb24gU1ZEKCkge307XG5cbi8qIEJlbG93IHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gKHN2ZCkgY29kZSBpbmNsdWRpbmcgaHlwb3QgZnVuY3Rpb24gaXMgYWRvcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kcmFnb25mbHktYWkvSmFtYUpTXG4gICBTb21lIGNoYW5nZXMgYXJlIGFwcGxpZWQgdG8gbWFrZSB0aGUgY29kZSBjb21wYXRpYmxlIHdpdGggdGhlIGZjb3NlIGNvZGUgYW5kIHRvIG1ha2UgaXQgaW5kZXBlbmRlbnQgZnJvbSBKYW1hLlxuICAgSW5wdXQgbWF0cml4IGlzIGNoYW5nZWQgdG8gYSAyRCBhcnJheSBpbnN0ZWFkIG9mIEphbWEgbWF0cml4LiBNYXRyaXggZGltZW5zaW9ucyBhcmUgdGFrZW4gYWNjb3JkaW5nIHRvIDJEIGFycmF5IGluc3RlYWQgb2YgdXNpbmcgSmFtYSBmdW5jdGlvbnMuXG4gICBBbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBzaW5ndWxhciB2YWx1ZSBjb21wb25lbnRzIGlzIGNyZWF0ZWQgZm9yIHJldHVybi4gXG4gICBUaGUgdHlwZXMgb2YgaW5wdXQgcGFyYW1ldGVycyBvZiB0aGUgaHlwb3QgZnVuY3Rpb24gYXJlIHJlbW92ZWQuIFxuICAgbGV0IGlzIHVzZWQgaW5zdGVhZCBvZiB2YXIgZm9yIHRoZSB2YXJpYWJsZSBpbml0aWFsaXphdGlvbi5cbiovXG4vKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFwYWNoZSBMaWNlbnNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBWZXJzaW9uIDIuMCwgSmFudWFyeSAyMDA0XG4gICAgICAgICAgICAgICAgICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvXG5cbiAgIFRFUk1TIEFORCBDT05ESVRJT05TIEZPUiBVU0UsIFJFUFJPRFVDVElPTiwgQU5EIERJU1RSSUJVVElPTlxuXG4gICAxLiBEZWZpbml0aW9ucy5cblxuICAgICAgXCJMaWNlbnNlXCIgc2hhbGwgbWVhbiB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLFxuICAgICAgYW5kIGRpc3RyaWJ1dGlvbiBhcyBkZWZpbmVkIGJ5IFNlY3Rpb25zIDEgdGhyb3VnaCA5IG9mIHRoaXMgZG9jdW1lbnQuXG5cbiAgICAgIFwiTGljZW5zb3JcIiBzaGFsbCBtZWFuIHRoZSBjb3B5cmlnaHQgb3duZXIgb3IgZW50aXR5IGF1dGhvcml6ZWQgYnlcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIgdGhhdCBpcyBncmFudGluZyB0aGUgTGljZW5zZS5cblxuICAgICAgXCJMZWdhbCBFbnRpdHlcIiBzaGFsbCBtZWFuIHRoZSB1bmlvbiBvZiB0aGUgYWN0aW5nIGVudGl0eSBhbmQgYWxsXG4gICAgICBvdGhlciBlbnRpdGllcyB0aGF0IGNvbnRyb2wsIGFyZSBjb250cm9sbGVkIGJ5LCBvciBhcmUgdW5kZXIgY29tbW9uXG4gICAgICBjb250cm9sIHdpdGggdGhhdCBlbnRpdHkuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLFxuICAgICAgXCJjb250cm9sXCIgbWVhbnMgKGkpIHRoZSBwb3dlciwgZGlyZWN0IG9yIGluZGlyZWN0LCB0byBjYXVzZSB0aGVcbiAgICAgIGRpcmVjdGlvbiBvciBtYW5hZ2VtZW50IG9mIHN1Y2ggZW50aXR5LCB3aGV0aGVyIGJ5IGNvbnRyYWN0IG9yXG4gICAgICBvdGhlcndpc2UsIG9yIChpaSkgb3duZXJzaGlwIG9mIGZpZnR5IHBlcmNlbnQgKDUwJSkgb3IgbW9yZSBvZiB0aGVcbiAgICAgIG91dHN0YW5kaW5nIHNoYXJlcywgb3IgKGlpaSkgYmVuZWZpY2lhbCBvd25lcnNoaXAgb2Ygc3VjaCBlbnRpdHkuXG5cbiAgICAgIFwiWW91XCIgKG9yIFwiWW91clwiKSBzaGFsbCBtZWFuIGFuIGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBleGVyY2lzaW5nIHBlcm1pc3Npb25zIGdyYW50ZWQgYnkgdGhpcyBMaWNlbnNlLlxuXG4gICAgICBcIlNvdXJjZVwiIGZvcm0gc2hhbGwgbWVhbiB0aGUgcHJlZmVycmVkIGZvcm0gZm9yIG1ha2luZyBtb2RpZmljYXRpb25zLFxuICAgICAgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0byBzb2Z0d2FyZSBzb3VyY2UgY29kZSwgZG9jdW1lbnRhdGlvblxuICAgICAgc291cmNlLCBhbmQgY29uZmlndXJhdGlvbiBmaWxlcy5cblxuICAgICAgXCJPYmplY3RcIiBmb3JtIHNoYWxsIG1lYW4gYW55IGZvcm0gcmVzdWx0aW5nIGZyb20gbWVjaGFuaWNhbFxuICAgICAgdHJhbnNmb3JtYXRpb24gb3IgdHJhbnNsYXRpb24gb2YgYSBTb3VyY2UgZm9ybSwgaW5jbHVkaW5nIGJ1dFxuICAgICAgbm90IGxpbWl0ZWQgdG8gY29tcGlsZWQgb2JqZWN0IGNvZGUsIGdlbmVyYXRlZCBkb2N1bWVudGF0aW9uLFxuICAgICAgYW5kIGNvbnZlcnNpb25zIHRvIG90aGVyIG1lZGlhIHR5cGVzLlxuXG4gICAgICBcIldvcmtcIiBzaGFsbCBtZWFuIHRoZSB3b3JrIG9mIGF1dGhvcnNoaXAsIHdoZXRoZXIgaW4gU291cmNlIG9yXG4gICAgICBPYmplY3QgZm9ybSwgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlIExpY2Vuc2UsIGFzIGluZGljYXRlZCBieSBhXG4gICAgICBjb3B5cmlnaHQgbm90aWNlIHRoYXQgaXMgaW5jbHVkZWQgaW4gb3IgYXR0YWNoZWQgdG8gdGhlIHdvcmtcbiAgICAgIChhbiBleGFtcGxlIGlzIHByb3ZpZGVkIGluIHRoZSBBcHBlbmRpeCBiZWxvdykuXG5cbiAgICAgIFwiRGVyaXZhdGl2ZSBXb3Jrc1wiIHNoYWxsIG1lYW4gYW55IHdvcmssIHdoZXRoZXIgaW4gU291cmNlIG9yIE9iamVjdFxuICAgICAgZm9ybSwgdGhhdCBpcyBiYXNlZCBvbiAob3IgZGVyaXZlZCBmcm9tKSB0aGUgV29yayBhbmQgZm9yIHdoaWNoIHRoZVxuICAgICAgZWRpdG9yaWFsIHJldmlzaW9ucywgYW5ub3RhdGlvbnMsIGVsYWJvcmF0aW9ucywgb3Igb3RoZXIgbW9kaWZpY2F0aW9uc1xuICAgICAgcmVwcmVzZW50LCBhcyBhIHdob2xlLCBhbiBvcmlnaW5hbCB3b3JrIG9mIGF1dGhvcnNoaXAuIEZvciB0aGUgcHVycG9zZXNcbiAgICAgIG9mIHRoaXMgTGljZW5zZSwgRGVyaXZhdGl2ZSBXb3JrcyBzaGFsbCBub3QgaW5jbHVkZSB3b3JrcyB0aGF0IHJlbWFpblxuICAgICAgc2VwYXJhYmxlIGZyb20sIG9yIG1lcmVseSBsaW5rIChvciBiaW5kIGJ5IG5hbWUpIHRvIHRoZSBpbnRlcmZhY2VzIG9mLFxuICAgICAgdGhlIFdvcmsgYW5kIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZi5cblxuICAgICAgXCJDb250cmlidXRpb25cIiBzaGFsbCBtZWFuIGFueSB3b3JrIG9mIGF1dGhvcnNoaXAsIGluY2x1ZGluZ1xuICAgICAgdGhlIG9yaWdpbmFsIHZlcnNpb24gb2YgdGhlIFdvcmsgYW5kIGFueSBtb2RpZmljYXRpb25zIG9yIGFkZGl0aW9uc1xuICAgICAgdG8gdGhhdCBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgdGhhdCBpcyBpbnRlbnRpb25hbGx5XG4gICAgICBzdWJtaXR0ZWQgdG8gTGljZW5zb3IgZm9yIGluY2x1c2lvbiBpbiB0aGUgV29yayBieSB0aGUgY29weXJpZ2h0IG93bmVyXG4gICAgICBvciBieSBhbiBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eSBhdXRob3JpemVkIHRvIHN1Ym1pdCBvbiBiZWhhbGYgb2ZcbiAgICAgIHRoZSBjb3B5cmlnaHQgb3duZXIuIEZvciB0aGUgcHVycG9zZXMgb2YgdGhpcyBkZWZpbml0aW9uLCBcInN1Ym1pdHRlZFwiXG4gICAgICBtZWFucyBhbnkgZm9ybSBvZiBlbGVjdHJvbmljLCB2ZXJiYWwsIG9yIHdyaXR0ZW4gY29tbXVuaWNhdGlvbiBzZW50XG4gICAgICB0byB0aGUgTGljZW5zb3Igb3IgaXRzIHJlcHJlc2VudGF0aXZlcywgaW5jbHVkaW5nIGJ1dCBub3QgbGltaXRlZCB0b1xuICAgICAgY29tbXVuaWNhdGlvbiBvbiBlbGVjdHJvbmljIG1haWxpbmcgbGlzdHMsIHNvdXJjZSBjb2RlIGNvbnRyb2wgc3lzdGVtcyxcbiAgICAgIGFuZCBpc3N1ZSB0cmFja2luZyBzeXN0ZW1zIHRoYXQgYXJlIG1hbmFnZWQgYnksIG9yIG9uIGJlaGFsZiBvZiwgdGhlXG4gICAgICBMaWNlbnNvciBmb3IgdGhlIHB1cnBvc2Ugb2YgZGlzY3Vzc2luZyBhbmQgaW1wcm92aW5nIHRoZSBXb3JrLCBidXRcbiAgICAgIGV4Y2x1ZGluZyBjb21tdW5pY2F0aW9uIHRoYXQgaXMgY29uc3BpY3VvdXNseSBtYXJrZWQgb3Igb3RoZXJ3aXNlXG4gICAgICBkZXNpZ25hdGVkIGluIHdyaXRpbmcgYnkgdGhlIGNvcHlyaWdodCBvd25lciBhcyBcIk5vdCBhIENvbnRyaWJ1dGlvbi5cIlxuXG4gICAgICBcIkNvbnRyaWJ1dG9yXCIgc2hhbGwgbWVhbiBMaWNlbnNvciBhbmQgYW55IGluZGl2aWR1YWwgb3IgTGVnYWwgRW50aXR5XG4gICAgICBvbiBiZWhhbGYgb2Ygd2hvbSBhIENvbnRyaWJ1dGlvbiBoYXMgYmVlbiByZWNlaXZlZCBieSBMaWNlbnNvciBhbmRcbiAgICAgIHN1YnNlcXVlbnRseSBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrLlxuXG4gICAyLiBHcmFudCBvZiBDb3B5cmlnaHQgTGljZW5zZS4gU3ViamVjdCB0byB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgZWFjaCBDb250cmlidXRvciBoZXJlYnkgZ3JhbnRzIHRvIFlvdSBhIHBlcnBldHVhbCxcbiAgICAgIHdvcmxkd2lkZSwgbm9uLWV4Y2x1c2l2ZSwgbm8tY2hhcmdlLCByb3lhbHR5LWZyZWUsIGlycmV2b2NhYmxlXG4gICAgICBjb3B5cmlnaHQgbGljZW5zZSB0byByZXByb2R1Y2UsIHByZXBhcmUgRGVyaXZhdGl2ZSBXb3JrcyBvZixcbiAgICAgIHB1YmxpY2x5IGRpc3BsYXksIHB1YmxpY2x5IHBlcmZvcm0sIHN1YmxpY2Vuc2UsIGFuZCBkaXN0cmlidXRlIHRoZVxuICAgICAgV29yayBhbmQgc3VjaCBEZXJpdmF0aXZlIFdvcmtzIGluIFNvdXJjZSBvciBPYmplY3QgZm9ybS5cblxuICAgMy4gR3JhbnQgb2YgUGF0ZW50IExpY2Vuc2UuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIGVhY2ggQ29udHJpYnV0b3IgaGVyZWJ5IGdyYW50cyB0byBZb3UgYSBwZXJwZXR1YWwsXG4gICAgICB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIG5vLWNoYXJnZSwgcm95YWx0eS1mcmVlLCBpcnJldm9jYWJsZVxuICAgICAgKGV4Y2VwdCBhcyBzdGF0ZWQgaW4gdGhpcyBzZWN0aW9uKSBwYXRlbnQgbGljZW5zZSB0byBtYWtlLCBoYXZlIG1hZGUsXG4gICAgICB1c2UsIG9mZmVyIHRvIHNlbGwsIHNlbGwsIGltcG9ydCwgYW5kIG90aGVyd2lzZSB0cmFuc2ZlciB0aGUgV29yayxcbiAgICAgIHdoZXJlIHN1Y2ggbGljZW5zZSBhcHBsaWVzIG9ubHkgdG8gdGhvc2UgcGF0ZW50IGNsYWltcyBsaWNlbnNhYmxlXG4gICAgICBieSBzdWNoIENvbnRyaWJ1dG9yIHRoYXQgYXJlIG5lY2Vzc2FyaWx5IGluZnJpbmdlZCBieSB0aGVpclxuICAgICAgQ29udHJpYnV0aW9uKHMpIGFsb25lIG9yIGJ5IGNvbWJpbmF0aW9uIG9mIHRoZWlyIENvbnRyaWJ1dGlvbihzKVxuICAgICAgd2l0aCB0aGUgV29yayB0byB3aGljaCBzdWNoIENvbnRyaWJ1dGlvbihzKSB3YXMgc3VibWl0dGVkLiBJZiBZb3VcbiAgICAgIGluc3RpdHV0ZSBwYXRlbnQgbGl0aWdhdGlvbiBhZ2FpbnN0IGFueSBlbnRpdHkgKGluY2x1ZGluZyBhXG4gICAgICBjcm9zcy1jbGFpbSBvciBjb3VudGVyY2xhaW0gaW4gYSBsYXdzdWl0KSBhbGxlZ2luZyB0aGF0IHRoZSBXb3JrXG4gICAgICBvciBhIENvbnRyaWJ1dGlvbiBpbmNvcnBvcmF0ZWQgd2l0aGluIHRoZSBXb3JrIGNvbnN0aXR1dGVzIGRpcmVjdFxuICAgICAgb3IgY29udHJpYnV0b3J5IHBhdGVudCBpbmZyaW5nZW1lbnQsIHRoZW4gYW55IHBhdGVudCBsaWNlbnNlc1xuICAgICAgZ3JhbnRlZCB0byBZb3UgdW5kZXIgdGhpcyBMaWNlbnNlIGZvciB0aGF0IFdvcmsgc2hhbGwgdGVybWluYXRlXG4gICAgICBhcyBvZiB0aGUgZGF0ZSBzdWNoIGxpdGlnYXRpb24gaXMgZmlsZWQuXG5cbiAgIDQuIFJlZGlzdHJpYnV0aW9uLiBZb3UgbWF5IHJlcHJvZHVjZSBhbmQgZGlzdHJpYnV0ZSBjb3BpZXMgb2YgdGhlXG4gICAgICBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiBpbiBhbnkgbWVkaXVtLCB3aXRoIG9yIHdpdGhvdXRcbiAgICAgIG1vZGlmaWNhdGlvbnMsIGFuZCBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0sIHByb3ZpZGVkIHRoYXQgWW91XG4gICAgICBtZWV0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICAgICAgKGEpIFlvdSBtdXN0IGdpdmUgYW55IG90aGVyIHJlY2lwaWVudHMgb2YgdGhlIFdvcmsgb3JcbiAgICAgICAgICBEZXJpdmF0aXZlIFdvcmtzIGEgY29weSBvZiB0aGlzIExpY2Vuc2U7IGFuZFxuXG4gICAgICAoYikgWW91IG11c3QgY2F1c2UgYW55IG1vZGlmaWVkIGZpbGVzIHRvIGNhcnJ5IHByb21pbmVudCBub3RpY2VzXG4gICAgICAgICAgc3RhdGluZyB0aGF0IFlvdSBjaGFuZ2VkIHRoZSBmaWxlczsgYW5kXG5cbiAgICAgIChjKSBZb3UgbXVzdCByZXRhaW4sIGluIHRoZSBTb3VyY2UgZm9ybSBvZiBhbnkgRGVyaXZhdGl2ZSBXb3Jrc1xuICAgICAgICAgIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsbCBjb3B5cmlnaHQsIHBhdGVudCwgdHJhZGVtYXJrLCBhbmRcbiAgICAgICAgICBhdHRyaWJ1dGlvbiBub3RpY2VzIGZyb20gdGhlIFNvdXJjZSBmb3JtIG9mIHRoZSBXb3JrLFxuICAgICAgICAgIGV4Y2x1ZGluZyB0aG9zZSBub3RpY2VzIHRoYXQgZG8gbm90IHBlcnRhaW4gdG8gYW55IHBhcnQgb2ZcbiAgICAgICAgICB0aGUgRGVyaXZhdGl2ZSBXb3JrczsgYW5kXG5cbiAgICAgIChkKSBJZiB0aGUgV29yayBpbmNsdWRlcyBhIFwiTk9USUNFXCIgdGV4dCBmaWxlIGFzIHBhcnQgb2YgaXRzXG4gICAgICAgICAgZGlzdHJpYnV0aW9uLCB0aGVuIGFueSBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUgbXVzdFxuICAgICAgICAgIGluY2x1ZGUgYSByZWFkYWJsZSBjb3B5IG9mIHRoZSBhdHRyaWJ1dGlvbiBub3RpY2VzIGNvbnRhaW5lZFxuICAgICAgICAgIHdpdGhpbiBzdWNoIE5PVElDRSBmaWxlLCBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdFxuICAgICAgICAgIHBlcnRhaW4gdG8gYW55IHBhcnQgb2YgdGhlIERlcml2YXRpdmUgV29ya3MsIGluIGF0IGxlYXN0IG9uZVxuICAgICAgICAgIG9mIHRoZSBmb2xsb3dpbmcgcGxhY2VzOiB3aXRoaW4gYSBOT1RJQ0UgdGV4dCBmaWxlIGRpc3RyaWJ1dGVkXG4gICAgICAgICAgYXMgcGFydCBvZiB0aGUgRGVyaXZhdGl2ZSBXb3Jrczsgd2l0aGluIHRoZSBTb3VyY2UgZm9ybSBvclxuICAgICAgICAgIGRvY3VtZW50YXRpb24sIGlmIHByb3ZpZGVkIGFsb25nIHdpdGggdGhlIERlcml2YXRpdmUgV29ya3M7IG9yLFxuICAgICAgICAgIHdpdGhpbiBhIGRpc3BsYXkgZ2VuZXJhdGVkIGJ5IHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpZiBhbmRcbiAgICAgICAgICB3aGVyZXZlciBzdWNoIHRoaXJkLXBhcnR5IG5vdGljZXMgbm9ybWFsbHkgYXBwZWFyLiBUaGUgY29udGVudHNcbiAgICAgICAgICBvZiB0aGUgTk9USUNFIGZpbGUgYXJlIGZvciBpbmZvcm1hdGlvbmFsIHB1cnBvc2VzIG9ubHkgYW5kXG4gICAgICAgICAgZG8gbm90IG1vZGlmeSB0aGUgTGljZW5zZS4gWW91IG1heSBhZGQgWW91ciBvd24gYXR0cmlidXRpb25cbiAgICAgICAgICBub3RpY2VzIHdpdGhpbiBEZXJpdmF0aXZlIFdvcmtzIHRoYXQgWW91IGRpc3RyaWJ1dGUsIGFsb25nc2lkZVxuICAgICAgICAgIG9yIGFzIGFuIGFkZGVuZHVtIHRvIHRoZSBOT1RJQ0UgdGV4dCBmcm9tIHRoZSBXb3JrLCBwcm92aWRlZFxuICAgICAgICAgIHRoYXQgc3VjaCBhZGRpdGlvbmFsIGF0dHJpYnV0aW9uIG5vdGljZXMgY2Fubm90IGJlIGNvbnN0cnVlZFxuICAgICAgICAgIGFzIG1vZGlmeWluZyB0aGUgTGljZW5zZS5cblxuICAgICAgWW91IG1heSBhZGQgWW91ciBvd24gY29weXJpZ2h0IHN0YXRlbWVudCB0byBZb3VyIG1vZGlmaWNhdGlvbnMgYW5kXG4gICAgICBtYXkgcHJvdmlkZSBhZGRpdGlvbmFsIG9yIGRpZmZlcmVudCBsaWNlbnNlIHRlcm1zIGFuZCBjb25kaXRpb25zXG4gICAgICBmb3IgdXNlLCByZXByb2R1Y3Rpb24sIG9yIGRpc3RyaWJ1dGlvbiBvZiBZb3VyIG1vZGlmaWNhdGlvbnMsIG9yXG4gICAgICBmb3IgYW55IHN1Y2ggRGVyaXZhdGl2ZSBXb3JrcyBhcyBhIHdob2xlLCBwcm92aWRlZCBZb3VyIHVzZSxcbiAgICAgIHJlcHJvZHVjdGlvbiwgYW5kIGRpc3RyaWJ1dGlvbiBvZiB0aGUgV29yayBvdGhlcndpc2UgY29tcGxpZXMgd2l0aFxuICAgICAgdGhlIGNvbmRpdGlvbnMgc3RhdGVkIGluIHRoaXMgTGljZW5zZS5cblxuICAgNS4gU3VibWlzc2lvbiBvZiBDb250cmlidXRpb25zLiBVbmxlc3MgWW91IGV4cGxpY2l0bHkgc3RhdGUgb3RoZXJ3aXNlLFxuICAgICAgYW55IENvbnRyaWJ1dGlvbiBpbnRlbnRpb25hbGx5IHN1Ym1pdHRlZCBmb3IgaW5jbHVzaW9uIGluIHRoZSBXb3JrXG4gICAgICBieSBZb3UgdG8gdGhlIExpY2Vuc29yIHNoYWxsIGJlIHVuZGVyIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCB3aXRob3V0IGFueSBhZGRpdGlvbmFsIHRlcm1zIG9yIGNvbmRpdGlvbnMuXG4gICAgICBOb3R3aXRoc3RhbmRpbmcgdGhlIGFib3ZlLCBub3RoaW5nIGhlcmVpbiBzaGFsbCBzdXBlcnNlZGUgb3IgbW9kaWZ5XG4gICAgICB0aGUgdGVybXMgb2YgYW55IHNlcGFyYXRlIGxpY2Vuc2UgYWdyZWVtZW50IHlvdSBtYXkgaGF2ZSBleGVjdXRlZFxuICAgICAgd2l0aCBMaWNlbnNvciByZWdhcmRpbmcgc3VjaCBDb250cmlidXRpb25zLlxuXG4gICA2LiBUcmFkZW1hcmtzLiBUaGlzIExpY2Vuc2UgZG9lcyBub3QgZ3JhbnQgcGVybWlzc2lvbiB0byB1c2UgdGhlIHRyYWRlXG4gICAgICBuYW1lcywgdHJhZGVtYXJrcywgc2VydmljZSBtYXJrcywgb3IgcHJvZHVjdCBuYW1lcyBvZiB0aGUgTGljZW5zb3IsXG4gICAgICBleGNlcHQgYXMgcmVxdWlyZWQgZm9yIHJlYXNvbmFibGUgYW5kIGN1c3RvbWFyeSB1c2UgaW4gZGVzY3JpYmluZyB0aGVcbiAgICAgIG9yaWdpbiBvZiB0aGUgV29yayBhbmQgcmVwcm9kdWNpbmcgdGhlIGNvbnRlbnQgb2YgdGhlIE5PVElDRSBmaWxlLlxuXG4gICA3LiBEaXNjbGFpbWVyIG9mIFdhcnJhbnR5LiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3JcbiAgICAgIGFncmVlZCB0byBpbiB3cml0aW5nLCBMaWNlbnNvciBwcm92aWRlcyB0aGUgV29yayAoYW5kIGVhY2hcbiAgICAgIENvbnRyaWJ1dG9yIHByb3ZpZGVzIGl0cyBDb250cmlidXRpb25zKSBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3JcbiAgICAgIGltcGxpZWQsIGluY2x1ZGluZywgd2l0aG91dCBsaW1pdGF0aW9uLCBhbnkgd2FycmFudGllcyBvciBjb25kaXRpb25zXG4gICAgICBvZiBUSVRMRSwgTk9OLUlORlJJTkdFTUVOVCwgTUVSQ0hBTlRBQklMSVRZLCBvciBGSVRORVNTIEZPUiBBXG4gICAgICBQQVJUSUNVTEFSIFBVUlBPU0UuIFlvdSBhcmUgc29sZWx5IHJlc3BvbnNpYmxlIGZvciBkZXRlcm1pbmluZyB0aGVcbiAgICAgIGFwcHJvcHJpYXRlbmVzcyBvZiB1c2luZyBvciByZWRpc3RyaWJ1dGluZyB0aGUgV29yayBhbmQgYXNzdW1lIGFueVxuICAgICAgcmlza3MgYXNzb2NpYXRlZCB3aXRoIFlvdXIgZXhlcmNpc2Ugb2YgcGVybWlzc2lvbnMgdW5kZXIgdGhpcyBMaWNlbnNlLlxuXG4gICA4LiBMaW1pdGF0aW9uIG9mIExpYWJpbGl0eS4gSW4gbm8gZXZlbnQgYW5kIHVuZGVyIG5vIGxlZ2FsIHRoZW9yeSxcbiAgICAgIHdoZXRoZXIgaW4gdG9ydCAoaW5jbHVkaW5nIG5lZ2xpZ2VuY2UpLCBjb250cmFjdCwgb3Igb3RoZXJ3aXNlLFxuICAgICAgdW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IChzdWNoIGFzIGRlbGliZXJhdGUgYW5kIGdyb3NzbHlcbiAgICAgIG5lZ2xpZ2VudCBhY3RzKSBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc2hhbGwgYW55IENvbnRyaWJ1dG9yIGJlXG4gICAgICBsaWFibGUgdG8gWW91IGZvciBkYW1hZ2VzLCBpbmNsdWRpbmcgYW55IGRpcmVjdCwgaW5kaXJlY3QsIHNwZWNpYWwsXG4gICAgICBpbmNpZGVudGFsLCBvciBjb25zZXF1ZW50aWFsIGRhbWFnZXMgb2YgYW55IGNoYXJhY3RlciBhcmlzaW5nIGFzIGFcbiAgICAgIHJlc3VsdCBvZiB0aGlzIExpY2Vuc2Ugb3Igb3V0IG9mIHRoZSB1c2Ugb3IgaW5hYmlsaXR5IHRvIHVzZSB0aGVcbiAgICAgIFdvcmsgKGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gZGFtYWdlcyBmb3IgbG9zcyBvZiBnb29kd2lsbCxcbiAgICAgIHdvcmsgc3RvcHBhZ2UsIGNvbXB1dGVyIGZhaWx1cmUgb3IgbWFsZnVuY3Rpb24sIG9yIGFueSBhbmQgYWxsXG4gICAgICBvdGhlciBjb21tZXJjaWFsIGRhbWFnZXMgb3IgbG9zc2VzKSwgZXZlbiBpZiBzdWNoIENvbnRyaWJ1dG9yXG4gICAgICBoYXMgYmVlbiBhZHZpc2VkIG9mIHRoZSBwb3NzaWJpbGl0eSBvZiBzdWNoIGRhbWFnZXMuXG5cbiAgIDkuIEFjY2VwdGluZyBXYXJyYW50eSBvciBBZGRpdGlvbmFsIExpYWJpbGl0eS4gV2hpbGUgcmVkaXN0cmlidXRpbmdcbiAgICAgIHRoZSBXb3JrIG9yIERlcml2YXRpdmUgV29ya3MgdGhlcmVvZiwgWW91IG1heSBjaG9vc2UgdG8gb2ZmZXIsXG4gICAgICBhbmQgY2hhcmdlIGEgZmVlIGZvciwgYWNjZXB0YW5jZSBvZiBzdXBwb3J0LCB3YXJyYW50eSwgaW5kZW1uaXR5LFxuICAgICAgb3Igb3RoZXIgbGlhYmlsaXR5IG9ibGlnYXRpb25zIGFuZC9vciByaWdodHMgY29uc2lzdGVudCB3aXRoIHRoaXNcbiAgICAgIExpY2Vuc2UuIEhvd2V2ZXIsIGluIGFjY2VwdGluZyBzdWNoIG9ibGlnYXRpb25zLCBZb3UgbWF5IGFjdCBvbmx5XG4gICAgICBvbiBZb3VyIG93biBiZWhhbGYgYW5kIG9uIFlvdXIgc29sZSByZXNwb25zaWJpbGl0eSwgbm90IG9uIGJlaGFsZlxuICAgICAgb2YgYW55IG90aGVyIENvbnRyaWJ1dG9yLCBhbmQgb25seSBpZiBZb3UgYWdyZWUgdG8gaW5kZW1uaWZ5LFxuICAgICAgZGVmZW5kLCBhbmQgaG9sZCBlYWNoIENvbnRyaWJ1dG9yIGhhcm1sZXNzIGZvciBhbnkgbGlhYmlsaXR5XG4gICAgICBpbmN1cnJlZCBieSwgb3IgY2xhaW1zIGFzc2VydGVkIGFnYWluc3QsIHN1Y2ggQ29udHJpYnV0b3IgYnkgcmVhc29uXG4gICAgICBvZiB5b3VyIGFjY2VwdGluZyBhbnkgc3VjaCB3YXJyYW50eSBvciBhZGRpdGlvbmFsIGxpYWJpbGl0eS5cblxuICAgRU5EIE9GIFRFUk1TIEFORCBDT05ESVRJT05TXG5cbiAgIEFQUEVORElYOiBIb3cgdG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yay5cblxuICAgICAgVG8gYXBwbHkgdGhlIEFwYWNoZSBMaWNlbnNlIHRvIHlvdXIgd29yaywgYXR0YWNoIHRoZSBmb2xsb3dpbmdcbiAgICAgIGJvaWxlcnBsYXRlIG5vdGljZSwgd2l0aCB0aGUgZmllbGRzIGVuY2xvc2VkIGJ5IGJyYWNrZXRzIFwie31cIlxuICAgICAgcmVwbGFjZWQgd2l0aCB5b3VyIG93biBpZGVudGlmeWluZyBpbmZvcm1hdGlvbi4gKERvbid0IGluY2x1ZGVcbiAgICAgIHRoZSBicmFja2V0cyEpICBUaGUgdGV4dCBzaG91bGQgYmUgZW5jbG9zZWQgaW4gdGhlIGFwcHJvcHJpYXRlXG4gICAgICBjb21tZW50IHN5bnRheCBmb3IgdGhlIGZpbGUgZm9ybWF0LiBXZSBhbHNvIHJlY29tbWVuZCB0aGF0IGFcbiAgICAgIGZpbGUgb3IgY2xhc3MgbmFtZSBhbmQgZGVzY3JpcHRpb24gb2YgcHVycG9zZSBiZSBpbmNsdWRlZCBvbiB0aGVcbiAgICAgIHNhbWUgXCJwcmludGVkIHBhZ2VcIiBhcyB0aGUgY29weXJpZ2h0IG5vdGljZSBmb3IgZWFzaWVyXG4gICAgICBpZGVudGlmaWNhdGlvbiB3aXRoaW4gdGhpcmQtcGFydHkgYXJjaGl2ZXMuXG5cbiAgIENvcHlyaWdodCB7eXl5eX0ge25hbWUgb2YgY29weXJpZ2h0IG93bmVyfVxuXG4gICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblNWRC5zdmQgPSBmdW5jdGlvbiAoQSkge1xuICB0aGlzLlUgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuICB0aGlzLnMgPSBudWxsO1xuICB0aGlzLm0gPSAwO1xuICB0aGlzLm4gPSAwO1xuICB0aGlzLm0gPSBBLmxlbmd0aDtcbiAgdGhpcy5uID0gQVswXS5sZW5ndGg7XG4gIHZhciBudSA9IE1hdGgubWluKHRoaXMubSwgdGhpcy5uKTtcbiAgdGhpcy5zID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KE1hdGgubWluKHRoaXMubSArIDEsIHRoaXMubikpO1xuICB0aGlzLlUgPSBmdW5jdGlvbiAoZGltcykge1xuICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGRpbXMpIHtcbiAgICAgIGlmIChkaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltc1swXTsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChhbGxvY2F0ZShkaW1zLnNsaWNlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbG9jYXRlKGRpbXMpO1xuICB9KFt0aGlzLm0sIG51XSk7XG4gIHRoaXMuViA9IGZ1bmN0aW9uIChkaW1zKSB7XG4gICAgdmFyIGFsbG9jYXRlID0gZnVuY3Rpb24gYWxsb2NhdGUoZGltcykge1xuICAgICAgaWYgKGRpbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaW1zWzBdOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5wdXNoKGFsbG9jYXRlKGRpbXMuc2xpY2UoMSkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gYWxsb2NhdGUoZGltcyk7XG4gIH0oW3RoaXMubiwgdGhpcy5uXSk7XG4gIHZhciBlID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubik7XG4gIHZhciB3b3JrID0gZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIHdoaWxlIChzLS0gPiAwKSB7XG4gICAgICBhLnB1c2goMCk7XG4gICAgfXJldHVybiBhO1xuICB9KHRoaXMubSk7XG4gIHZhciB3YW50dSA9IHRydWU7XG4gIHZhciB3YW50diA9IHRydWU7XG4gIHZhciBuY3QgPSBNYXRoLm1pbih0aGlzLm0gLSAxLCB0aGlzLm4pO1xuICB2YXIgbnJ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5uIC0gMiwgdGhpcy5tKSk7XG4gIGZvciAodmFyIGsgPSAwOyBrIDwgTWF0aC5tYXgobmN0LCBucnQpOyBrKyspIHtcbiAgICBpZiAoayA8IG5jdCkge1xuICAgICAgdGhpcy5zW2tdID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSBrOyBpIDwgdGhpcy5tOyBpKyspIHtcbiAgICAgICAgdGhpcy5zW2tdID0gU1ZELmh5cG90KHRoaXMuc1trXSwgQVtpXVtrXSk7XG4gICAgICB9XG4gICAgICA7XG4gICAgICBpZiAodGhpcy5zW2tdICE9PSAwLjApIHtcbiAgICAgICAgaWYgKEFba11ba10gPCAwLjApIHtcbiAgICAgICAgICB0aGlzLnNba10gPSAtdGhpcy5zW2tdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pID0gazsgX2kgPCB0aGlzLm07IF9pKyspIHtcbiAgICAgICAgICBBW19pXVtrXSAvPSB0aGlzLnNba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBBW2tdW2tdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc1trXSA9IC10aGlzLnNba107XG4gICAgfVxuICAgIGZvciAodmFyIGogPSBrICsgMTsgaiA8IHRoaXMubjsgaisrKSB7XG4gICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgICAgfShrIDwgbmN0LCB0aGlzLnNba10gIT09IDAuMCkpIHtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBfaTIgPSBrOyBfaTIgPCB0aGlzLm07IF9pMisrKSB7XG4gICAgICAgICAgdCArPSBBW19pMl1ba10gKiBBW19pMl1bal07XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB0ID0gLXQgLyBBW2tdW2tdO1xuICAgICAgICBmb3IgKHZhciBfaTMgPSBrOyBfaTMgPCB0aGlzLm07IF9pMysrKSB7XG4gICAgICAgICAgQVtfaTNdW2pdICs9IHQgKiBBW19pM11ba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgZVtqXSA9IEFba11bal07XG4gICAgfVxuICAgIDtcbiAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICB9KHdhbnR1LCBrIDwgbmN0KSkge1xuICAgICAgZm9yICh2YXIgX2k0ID0gazsgX2k0IDwgdGhpcy5tOyBfaTQrKykge1xuICAgICAgICB0aGlzLlVbX2k0XVtrXSA9IEFbX2k0XVtrXTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICB9XG4gICAgaWYgKGsgPCBucnQpIHtcbiAgICAgIGVba10gPSAwO1xuICAgICAgZm9yICh2YXIgX2k1ID0gayArIDE7IF9pNSA8IHRoaXMubjsgX2k1KyspIHtcbiAgICAgICAgZVtrXSA9IFNWRC5oeXBvdChlW2tdLCBlW19pNV0pO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgaWYgKGVba10gIT09IDAuMCkge1xuICAgICAgICBpZiAoZVtrICsgMV0gPCAwLjApIHtcbiAgICAgICAgICBlW2tdID0gLWVba107XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2k2ID0gayArIDE7IF9pNiA8IHRoaXMubjsgX2k2KyspIHtcbiAgICAgICAgICBlW19pNl0gLz0gZVtrXTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGVbayArIDFdICs9IDEuMDtcbiAgICAgIH1cbiAgICAgIGVba10gPSAtZVtrXTtcbiAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgICB9KGsgKyAxIDwgdGhpcy5tLCBlW2tdICE9PSAwLjApKSB7XG4gICAgICAgIGZvciAodmFyIF9pNyA9IGsgKyAxOyBfaTcgPCB0aGlzLm07IF9pNysrKSB7XG4gICAgICAgICAgd29ya1tfaTddID0gMC4wO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2ogPSBrICsgMTsgX2ogPCB0aGlzLm47IF9qKyspIHtcbiAgICAgICAgICBmb3IgKHZhciBfaTggPSBrICsgMTsgX2k4IDwgdGhpcy5tOyBfaTgrKykge1xuICAgICAgICAgICAgd29ya1tfaThdICs9IGVbX2pdICogQVtfaThdW19qXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gayArIDE7IF9qMiA8IHRoaXMubjsgX2oyKyspIHtcbiAgICAgICAgICB2YXIgX3QgPSAtZVtfajJdIC8gZVtrICsgMV07XG4gICAgICAgICAgZm9yICh2YXIgX2k5ID0gayArIDE7IF9pOSA8IHRoaXMubTsgX2k5KyspIHtcbiAgICAgICAgICAgIEFbX2k5XVtfajJdICs9IF90ICogd29ya1tfaTldO1xuICAgICAgICAgIH1cbiAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgfVxuICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgIGZvciAodmFyIF9pMTAgPSBrICsgMTsgX2kxMCA8IHRoaXMubjsgX2kxMCsrKSB7XG4gICAgICAgICAgdGhpcy5WW19pMTBdW2tdID0gZVtfaTEwXTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHZhciBwID0gTWF0aC5taW4odGhpcy5uLCB0aGlzLm0gKyAxKTtcbiAgaWYgKG5jdCA8IHRoaXMubikge1xuICAgIHRoaXMuc1tuY3RdID0gQVtuY3RdW25jdF07XG4gIH1cbiAgaWYgKHRoaXMubSA8IHApIHtcbiAgICB0aGlzLnNbcCAtIDFdID0gMC4wO1xuICB9XG4gIGlmIChucnQgKyAxIDwgcCkge1xuICAgIGVbbnJ0XSA9IEFbbnJ0XVtwIC0gMV07XG4gIH1cbiAgZVtwIC0gMV0gPSAwLjA7XG4gIGlmICh3YW50dSkge1xuICAgIGZvciAodmFyIF9qMyA9IG5jdDsgX2ozIDwgbnU7IF9qMysrKSB7XG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IHRoaXMubTsgX2kxMSsrKSB7XG4gICAgICAgIHRoaXMuVVtfaTExXVtfajNdID0gMC4wO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgdGhpcy5VW19qM11bX2ozXSA9IDEuMDtcbiAgICB9O1xuICAgIGZvciAodmFyIF9rID0gbmN0IC0gMTsgX2sgPj0gMDsgX2stLSkge1xuICAgICAgaWYgKHRoaXMuc1tfa10gIT09IDAuMCkge1xuICAgICAgICBmb3IgKHZhciBfajQgPSBfayArIDE7IF9qNCA8IG51OyBfajQrKykge1xuICAgICAgICAgIHZhciBfdDIgPSAwO1xuICAgICAgICAgIGZvciAodmFyIF9pMTIgPSBfazsgX2kxMiA8IHRoaXMubTsgX2kxMisrKSB7XG4gICAgICAgICAgICBfdDIgKz0gdGhpcy5VW19pMTJdW19rXSAqIHRoaXMuVVtfaTEyXVtfajRdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3QyID0gLV90MiAvIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICAgIGZvciAodmFyIF9pMTMgPSBfazsgX2kxMyA8IHRoaXMubTsgX2kxMysrKSB7XG4gICAgICAgICAgICB0aGlzLlVbX2kxM11bX2o0XSArPSBfdDIgKiB0aGlzLlVbX2kxM11bX2tdO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9pMTQgPSBfazsgX2kxNCA8IHRoaXMubTsgX2kxNCsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTRdW19rXSA9IC10aGlzLlVbX2kxNF1bX2tdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMCArIHRoaXMuVVtfa11bX2tdO1xuICAgICAgICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IF9rIC0gMTsgX2kxNSsrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTVdW19rXSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIF9pMTYgPSAwOyBfaTE2IDwgdGhpcy5tOyBfaTE2KyspIHtcbiAgICAgICAgICB0aGlzLlVbX2kxNl1bX2tdID0gMC4wO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLlVbX2tdW19rXSA9IDEuMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGlmICh3YW50dikge1xuICAgIGZvciAodmFyIF9rMiA9IHRoaXMubiAtIDE7IF9rMiA+PSAwOyBfazItLSkge1xuICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICAgIH0oX2syIDwgbnJ0LCBlW19rMl0gIT09IDAuMCkpIHtcbiAgICAgICAgZm9yICh2YXIgX2o1ID0gX2syICsgMTsgX2o1IDwgbnU7IF9qNSsrKSB7XG4gICAgICAgICAgdmFyIF90MyA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgX2kxNyA9IF9rMiArIDE7IF9pMTcgPCB0aGlzLm47IF9pMTcrKykge1xuICAgICAgICAgICAgX3QzICs9IHRoaXMuVltfaTE3XVtfazJdICogdGhpcy5WW19pMTddW19qNV07XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfdDMgPSAtX3QzIC8gdGhpcy5WW19rMiArIDFdW19rMl07XG4gICAgICAgICAgZm9yICh2YXIgX2kxOCA9IF9rMiArIDE7IF9pMTggPCB0aGlzLm47IF9pMTgrKykge1xuICAgICAgICAgICAgdGhpcy5WW19pMThdW19qNV0gKz0gX3QzICogdGhpcy5WW19pMThdW19rMl07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pMTkgPSAwOyBfaTE5IDwgdGhpcy5uOyBfaTE5KyspIHtcbiAgICAgICAgdGhpcy5WW19pMTldW19rMl0gPSAwLjA7XG4gICAgICB9O1xuICAgICAgdGhpcy5WW19rMl1bX2syXSA9IDEuMDtcbiAgICB9O1xuICB9XG4gIHZhciBwcCA9IHAgLSAxO1xuICB2YXIgaXRlciA9IDA7XG4gIHZhciBlcHMgPSBNYXRoLnBvdygyLjAsIC01Mi4wKTtcbiAgdmFyIHRpbnkgPSBNYXRoLnBvdygyLjAsIC05NjYuMCk7XG4gIHdoaWxlIChwID4gMCkge1xuICAgIHZhciBfazMgPSB2b2lkIDA7XG4gICAgdmFyIGthc2UgPSB2b2lkIDA7XG4gICAgZm9yIChfazMgPSBwIC0gMjsgX2szID49IC0xOyBfazMtLSkge1xuICAgICAgaWYgKF9rMyA9PT0gLTEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoZVtfazNdKSA8PSB0aW55ICsgZXBzICogKE1hdGguYWJzKHRoaXMuc1tfazNdKSArIE1hdGguYWJzKHRoaXMuc1tfazMgKyAxXSkpKSB7XG4gICAgICAgIGVbX2szXSA9IDAuMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoX2szID09PSBwIC0gMikge1xuICAgICAga2FzZSA9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrcyA9IHZvaWQgMDtcbiAgICAgIGZvciAoa3MgPSBwIC0gMTsga3MgPj0gX2szOyBrcy0tKSB7XG4gICAgICAgIGlmIChrcyA9PT0gX2szKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF90NCA9IChrcyAhPT0gcCA/IE1hdGguYWJzKGVba3NdKSA6IDAuMCkgKyAoa3MgIT09IF9rMyArIDEgPyBNYXRoLmFicyhlW2tzIC0gMV0pIDogMC4wKTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc1trc10pIDw9IHRpbnkgKyBlcHMgKiBfdDQpIHtcbiAgICAgICAgICB0aGlzLnNba3NdID0gMC4wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGtzID09PSBfazMpIHtcbiAgICAgICAga2FzZSA9IDM7XG4gICAgICB9IGVsc2UgaWYgKGtzID09PSBwIC0gMSkge1xuICAgICAgICBrYXNlID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGthc2UgPSAyO1xuICAgICAgICBfazMgPSBrcztcbiAgICAgIH1cbiAgICB9XG4gICAgX2szKys7XG4gICAgc3dpdGNoIChrYXNlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgZiA9IGVbcCAtIDJdO1xuICAgICAgICAgIGVbcCAtIDJdID0gMC4wO1xuICAgICAgICAgIGZvciAodmFyIF9qNiA9IHAgLSAyOyBfajYgPj0gX2szOyBfajYtLSkge1xuICAgICAgICAgICAgdmFyIF90NSA9IFNWRC5oeXBvdCh0aGlzLnNbX2o2XSwgZik7XG4gICAgICAgICAgICB2YXIgY3MgPSB0aGlzLnNbX2o2XSAvIF90NTtcbiAgICAgICAgICAgIHZhciBzbiA9IGYgLyBfdDU7XG4gICAgICAgICAgICB0aGlzLnNbX2o2XSA9IF90NTtcbiAgICAgICAgICAgIGlmIChfajYgIT09IF9rMykge1xuICAgICAgICAgICAgICBmID0gLXNuICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgICAgZVtfajYgLSAxXSA9IGNzICogZVtfajYgLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIwID0gMDsgX2kyMCA8IHRoaXMubjsgX2kyMCsrKSB7XG4gICAgICAgICAgICAgICAgX3Q1ID0gY3MgKiB0aGlzLlZbX2kyMF1bX2o2XSArIHNuICogdGhpcy5WW19pMjBdW3AgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMF1bcCAtIDFdID0gLXNuICogdGhpcy5WW19pMjBdW19qNl0gKyBjcyAqIHRoaXMuVltfaTIwXVtwIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjBdW19qNl0gPSBfdDU7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2YgPSBlW19rMyAtIDFdO1xuICAgICAgICAgIGVbX2szIC0gMV0gPSAwLjA7XG4gICAgICAgICAgZm9yICh2YXIgX2o3ID0gX2szOyBfajcgPCBwOyBfajcrKykge1xuICAgICAgICAgICAgdmFyIF90NiA9IFNWRC5oeXBvdCh0aGlzLnNbX2o3XSwgX2YpO1xuICAgICAgICAgICAgdmFyIF9jcyA9IHRoaXMuc1tfajddIC8gX3Q2O1xuICAgICAgICAgICAgdmFyIF9zbiA9IF9mIC8gX3Q2O1xuICAgICAgICAgICAgdGhpcy5zW19qN10gPSBfdDY7XG4gICAgICAgICAgICBfZiA9IC1fc24gKiBlW19qN107XG4gICAgICAgICAgICBlW19qN10gPSBfY3MgKiBlW19qN107XG4gICAgICAgICAgICBpZiAod2FudHUpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDA7IF9pMjEgPCB0aGlzLm07IF9pMjErKykge1xuICAgICAgICAgICAgICAgIF90NiA9IF9jcyAqIHRoaXMuVVtfaTIxXVtfajddICsgX3NuICogdGhpcy5VW19pMjFdW19rMyAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIxXVtfazMgLSAxXSA9IC1fc24gKiB0aGlzLlVbX2kyMV1bX2o3XSArIF9jcyAqIHRoaXMuVVtfaTIxXVtfazMgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyMV1bX2o3XSA9IF90NjtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGgubWF4KE1hdGguYWJzKHRoaXMuc1twIC0gMV0pLCBNYXRoLmFicyh0aGlzLnNbcCAtIDJdKSksIE1hdGguYWJzKGVbcCAtIDJdKSksIE1hdGguYWJzKHRoaXMuc1tfazNdKSksIE1hdGguYWJzKGVbX2szXSkpO1xuICAgICAgICAgIHZhciBzcCA9IHRoaXMuc1twIC0gMV0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgc3BtMSA9IHRoaXMuc1twIC0gMl0gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZXBtMSA9IGVbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIHNrID0gdGhpcy5zW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgZWsgPSBlW19rM10gLyBzY2FsZTtcbiAgICAgICAgICB2YXIgYiA9ICgoc3BtMSArIHNwKSAqIChzcG0xIC0gc3ApICsgZXBtMSAqIGVwbTEpIC8gMi4wO1xuICAgICAgICAgIHZhciBjID0gc3AgKiBlcG0xICogKHNwICogZXBtMSk7XG4gICAgICAgICAgdmFyIHNoaWZ0ID0gMC4wO1xuICAgICAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaHMgfHwgcmhzO1xuICAgICAgICAgIH0oYiAhPT0gMC4wLCBjICE9PSAwLjApKSB7XG4gICAgICAgICAgICBzaGlmdCA9IE1hdGguc3FydChiICogYiArIGMpO1xuICAgICAgICAgICAgaWYgKGIgPCAwLjApIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSAtc2hpZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGlmdCA9IGMgLyAoYiArIHNoaWZ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIF9mMiA9IChzayArIHNwKSAqIChzayAtIHNwKSArIHNoaWZ0O1xuICAgICAgICAgIHZhciBnID0gc2sgKiBlaztcbiAgICAgICAgICBmb3IgKHZhciBfajggPSBfazM7IF9qOCA8IHAgLSAxOyBfajgrKykge1xuICAgICAgICAgICAgdmFyIF90NyA9IFNWRC5oeXBvdChfZjIsIGcpO1xuICAgICAgICAgICAgdmFyIF9jczIgPSBfZjIgLyBfdDc7XG4gICAgICAgICAgICB2YXIgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICBpZiAoX2o4ICE9PSBfazMpIHtcbiAgICAgICAgICAgICAgZVtfajggLSAxXSA9IF90NztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiB0aGlzLnNbX2o4XSArIF9zbjIgKiBlW19qOF07XG4gICAgICAgICAgICBlW19qOF0gPSBfY3MyICogZVtfajhdIC0gX3NuMiAqIHRoaXMuc1tfajhdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiB0aGlzLnNbX2o4ICsgMV07XG4gICAgICAgICAgICB0aGlzLnNbX2o4ICsgMV0gPSBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR2KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjIgPSAwOyBfaTIyIDwgdGhpcy5uOyBfaTIyKyspIHtcbiAgICAgICAgICAgICAgICBfdDcgPSBfY3MyICogdGhpcy5WW19pMjJdW19qOF0gKyBfc24yICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajggKyAxXSA9IC1fc24yICogdGhpcy5WW19pMjJdW19qOF0gKyBfY3MyICogdGhpcy5WW19pMjJdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIyXVtfajhdID0gX3Q3O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3Q3ID0gU1ZELmh5cG90KF9mMiwgZyk7XG4gICAgICAgICAgICBfY3MyID0gX2YyIC8gX3Q3O1xuICAgICAgICAgICAgX3NuMiA9IGcgLyBfdDc7XG4gICAgICAgICAgICB0aGlzLnNbX2o4XSA9IF90NztcbiAgICAgICAgICAgIF9mMiA9IF9jczIgKiBlW19qOF0gKyBfc24yICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19qOCArIDFdID0gLV9zbjIgKiBlW19qOF0gKyBfY3MyICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgZyA9IF9zbjIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgZVtfajggKyAxXSA9IF9jczIgKiBlW19qOCArIDFdO1xuICAgICAgICAgICAgaWYgKHdhbnR1ICYmIF9qOCA8IHRoaXMubSAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMyA9IDA7IF9pMjMgPCB0aGlzLm07IF9pMjMrKykge1xuICAgICAgICAgICAgICAgIF90NyA9IF9jczIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9zbjIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOCArIDFdID0gLV9zbjIgKiB0aGlzLlVbX2kyM11bX2o4XSArIF9jczIgKiB0aGlzLlVbX2kyM11bX2o4ICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjNdW19qOF0gPSBfdDc7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlW3AgLSAyXSA9IF9mMjtcbiAgICAgICAgICBpdGVyID0gaXRlciArIDE7XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc1tfazNdIDw9IDAuMCkge1xuICAgICAgICAgICAgdGhpcy5zW19rM10gPSB0aGlzLnNbX2szXSA8IDAuMCA/IC10aGlzLnNbX2szXSA6IDAuMDtcbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTI0ID0gMDsgX2kyNCA8PSBwcDsgX2kyNCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjRdW19rM10gPSAtdGhpcy5WW19pMjRdW19rM107XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChfazMgPCBwcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc1tfazNdID49IHRoaXMuc1tfazMgKyAxXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfdDggPSB0aGlzLnNbX2szXTtcbiAgICAgICAgICAgIHRoaXMuc1tfazNdID0gdGhpcy5zW19rMyArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19rMyArIDFdID0gX3Q4O1xuICAgICAgICAgICAgaWYgKHdhbnR2ICYmIF9rMyA8IHRoaXMubiAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyNSA9IDA7IF9pMjUgPCB0aGlzLm47IF9pMjUrKykge1xuICAgICAgICAgICAgICAgIF90OCA9IHRoaXMuVltfaTI1XVtfazMgKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szICsgMV0gPSB0aGlzLlZbX2kyNV1bX2szXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyNV1bX2szXSA9IF90ODtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dSAmJiBfazMgPCB0aGlzLm0gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjYgPSAwOyBfaTI2IDwgdGhpcy5tOyBfaTI2KyspIHtcbiAgICAgICAgICAgICAgICBfdDggPSB0aGlzLlVbX2kyNl1bX2szICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rMyArIDFdID0gdGhpcy5VW19pMjZdW19rM107XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjZdW19rM10gPSBfdDg7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfazMrKztcbiAgICAgICAgICB9O1xuICAgICAgICAgIGl0ZXIgPSAwO1xuICAgICAgICAgIHAtLTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuICB2YXIgcmVzdWx0ID0geyBVOiB0aGlzLlUsIFY6IHRoaXMuViwgUzogdGhpcy5zIH07XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBzcXJ0KGFeMiArIGJeMikgd2l0aG91dCB1bmRlci9vdmVyZmxvdy5cblNWRC5oeXBvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHZhciByID0gdm9pZCAwO1xuICBpZiAoTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhiKSkge1xuICAgIHIgPSBiIC8gYTtcbiAgICByID0gTWF0aC5hYnMoYSkgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfSBlbHNlIGlmIChiICE9IDApIHtcbiAgICByID0gYSAvIGI7XG4gICAgciA9IE1hdGguYWJzKGIpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG4gIH0gZWxzZSB7XG4gICAgciA9IDAuMDtcbiAgfVxuICByZXR1cm4gcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU1ZEO1xuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogICBOZWVkbGVtYW4tV3Vuc2NoIGFsZ29yaXRobSBpcyBhbiBwcm9jZWR1cmUgdG8gY29tcHV0ZSB0aGUgb3B0aW1hbCBnbG9iYWwgYWxpZ25tZW50IG9mIHR3byBzdHJpbmdcbiAqICAgc2VxdWVuY2VzIGJ5IFMuQi5OZWVkbGVtYW4gYW5kIEMuRC5XdW5zY2ggKDE5NzApLlxuICpcbiAqICAgQXNpZGUgZnJvbSB0aGUgaW5wdXRzLCB5b3UgY2FuIGFzc2lnbiB0aGUgc2NvcmVzIGZvcixcbiAqICAgLSBNYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBzYW1lLlxuICogICAtIE1pc21hdGNoOiBUaGUgdHdvIGNoYXJhY3RlcnMgYXQgdGhlIGN1cnJlbnQgaW5kZXggYXJlIGRpZmZlcmVudC5cbiAqICAgLSBJbnNlcnRpb24vRGVsZXRpb24oZ2Fwcyk6IFRoZSBiZXN0IGFsaWdubWVudCBpbnZvbHZlcyBvbmUgbGV0dGVyIGFsaWduaW5nIHRvIGEgZ2FwIGluIHRoZSBvdGhlciBzdHJpbmcuXG4gKi9cblxudmFyIE5lZWRsZW1hbld1bnNjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOZWVkbGVtYW5XdW5zY2goc2VxdWVuY2UxLCBzZXF1ZW5jZTIpIHtcbiAgICAgICAgdmFyIG1hdGNoX3Njb3JlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICAgICAgICB2YXIgbWlzbWF0Y2hfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogLTE7XG4gICAgICAgIHZhciBnYXBfcGVuYWx0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogLTE7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5lZWRsZW1hbld1bnNjaCk7XG5cbiAgICAgICAgdGhpcy5zZXF1ZW5jZTEgPSBzZXF1ZW5jZTE7XG4gICAgICAgIHRoaXMuc2VxdWVuY2UyID0gc2VxdWVuY2UyO1xuICAgICAgICB0aGlzLm1hdGNoX3Njb3JlID0gbWF0Y2hfc2NvcmU7XG4gICAgICAgIHRoaXMubWlzbWF0Y2hfcGVuYWx0eSA9IG1pc21hdGNoX3BlbmFsdHk7XG4gICAgICAgIHRoaXMuZ2FwX3BlbmFsdHkgPSBnYXBfcGVuYWx0eTtcblxuICAgICAgICAvLyBKdXN0IHRoZSByZW1vdmUgcmVkdW5kYW5jeVxuICAgICAgICB0aGlzLmlNYXggPSBzZXF1ZW5jZTEubGVuZ3RoICsgMTtcbiAgICAgICAgdGhpcy5qTWF4ID0gc2VxdWVuY2UyLmxlbmd0aCArIDE7XG5cbiAgICAgICAgLy8gR3JpZCBtYXRyaXggb2Ygc2NvcmVzXG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWRbaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFtpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjZWJhY2sgbWF0cml4ICgyRCBhcnJheSwgZWFjaCBjZWxsIGlzIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzIGZvciBbYERpYWdgLCBgVXBgLCBgTGVmdGBdIHBvc2l0aW9ucylcbiAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkID0gbmV3IEFycmF5KHRoaXMuaU1heCk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmlNYXg7IF9pKyspIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV0gPSBuZXcgQXJyYXkodGhpcy5qTWF4KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHRoaXMuak1heDsgX2orKykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaV1bX2pdID0gW251bGwsIG51bGwsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGFsaWduZWQgc2VxdWVuY2VzIChyZXR1cm4gbXVsdGlwbGUgcG9zc2liaWxpdGllcylcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgLy8gRmluYWwgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgIHRoaXMuc2NvcmUgPSAtMTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGFuZCB0cmFjZWJhY2tzXG4gICAgICAgIHRoaXMuY29tcHV0ZUdyaWRzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE5lZWRsZW1hbld1bnNjaCwgW3tcbiAgICAgICAga2V5OiBcImdldFNjb3JlXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY29yZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjb3JlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiZ2V0QWxpZ25tZW50c1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxpZ25tZW50cygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWluIGR5bmFtaWMgcHJvZ3JhbW1pbmcgcHJvY2VkdXJlXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJjb21wdXRlR3JpZHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXB1dGVHcmlkcygpIHtcbiAgICAgICAgICAgIC8vIEZpbGwgaW4gdGhlIGZpcnN0IHJvd1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCB0aGlzLmpNYXg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZFswXVtqXSA9IHRoaXMuZ3JpZFswXVtqIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFswXVtqXSA9IFtmYWxzZSwgZmFsc2UsIHRydWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5pTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bMF0gPSB0aGlzLmdyaWRbaSAtIDFdWzBdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbaV1bMF0gPSBbZmFsc2UsIHRydWUsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCB0aGUgcmVzdCBvZiB0aGUgZ3JpZFxuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMTsgX2kyIDwgdGhpcy5pTWF4OyBfaTIrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9qMiA9IDE7IF9qMiA8IHRoaXMuak1heDsgX2oyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWF4IHNjb3JlKHMpIGFtb25nIFtgRGlhZ2AsIGBVcGAsIGBMZWZ0YF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpYWcgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlcXVlbmNlMVtfaTIgLSAxXSA9PT0gdGhpcy5zZXF1ZW5jZTJbX2oyIC0gMV0pIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1hdGNoX3Njb3JlO2Vsc2UgZGlhZyA9IHRoaXMuZ3JpZFtfaTIgLSAxXVtfajIgLSAxXSArIHRoaXMubWlzbWF0Y2hfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdXAgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gdGhpcy5ncmlkW19pMl1bX2oyIC0gMV0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGV4aXN0cyBtdWx0aXBsZSBtYXggdmFsdWVzLCBjYXB0dXJlIHRoZW0gZm9yIG11bHRpcGxlIHBhdGhzXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXhPZiA9IFtkaWFnLCB1cCwgbGVmdF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5hcnJheUFsbE1heEluZGV4ZXMobWF4T2YpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBHcmlkc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdyaWRbX2kyXVtfajJdID0gbWF4T2ZbaW5kaWNlc1swXV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZFtfaTJdW19qMl0gPSBbaW5kaWNlcy5pbmNsdWRlcygwKSwgaW5kaWNlcy5pbmNsdWRlcygxKSwgaW5kaWNlcy5pbmNsdWRlcygyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcGRhdGUgYWxpZ25tZW50IHNjb3JlXG4gICAgICAgICAgICB0aGlzLnNjb3JlID0gdGhpcy5ncmlkW3RoaXMuaU1heCAtIDFdW3RoaXMuak1heCAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0cyBhbGwgcG9zc2libGUgdmFsaWQgc2VxdWVuY2UgY29tYmluYXRpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJhbGlnbm1lbnRUcmFjZWJhY2tcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFsaWdubWVudFRyYWNlYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBpblByb2Nlc3NBbGlnbm1lbnRzID0gW107XG5cbiAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW3RoaXMuc2VxdWVuY2UxLmxlbmd0aCwgdGhpcy5zZXF1ZW5jZTIubGVuZ3RoXSxcbiAgICAgICAgICAgICAgICBzZXExOiBcIlwiLFxuICAgICAgICAgICAgICAgIHNlcTI6IFwiXCJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB3aGlsZSAoaW5Qcm9jZXNzQWxpZ25tZW50c1swXSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gaW5Qcm9jZXNzQWxpZ25tZW50c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IHRoaXMudHJhY2ViYWNrR3JpZFtjdXJyZW50LnBvc1swXV1bY3VycmVudC5wb3NbMV1dO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0gLSAxLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6IHRoaXMuc2VxdWVuY2UyW2N1cnJlbnQucG9zWzFdIC0gMV0gKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogdGhpcy5zZXF1ZW5jZTFbY3VycmVudC5wb3NbMF0gLSAxXSArIGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTI6ICctJyArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnNbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Qcm9jZXNzQWxpZ25tZW50cy5wdXNoKHsgcG9zOiBbY3VycmVudC5wb3NbMF0sIGN1cnJlbnQucG9zWzFdIC0gMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXExOiAnLScgKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LnBvc1swXSA9PT0gMCAmJiBjdXJyZW50LnBvc1sxXSA9PT0gMCkgdGhpcy5hbGlnbm1lbnRzLnB1c2goeyBzZXF1ZW5jZTE6IGN1cnJlbnQuc2VxMSxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyOiBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpZ25tZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhlbHBlciBGdW5jdGlvbnNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsbEluZGV4ZXNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbEluZGV4ZXMoYXJyLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVzID0gW10sXG4gICAgICAgICAgICAgICAgaSA9IC0xO1xuICAgICAgICAgICAgd2hpbGUgKChpID0gYXJyLmluZGV4T2YodmFsLCBpICsgMSkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleGVzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYXJyYXlBbGxNYXhJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheUFsbE1heEluZGV4ZXMoYXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFsbEluZGV4ZXMoYXJyYXksIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5KSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTmVlZGxlbWFuV3Vuc2NoO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5lZWRsZW1hbld1bnNjaDtcblxuLyoqKi8gfSksXG4vKiAyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgbGF5b3V0QmFzZSA9IGZ1bmN0aW9uIGxheW91dEJhc2UoKSB7XG4gIHJldHVybjtcbn07XG5cbmxheW91dEJhc2UuRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcbmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xubGF5b3V0QmFzZS5GRExheW91dEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcbmxheW91dEJhc2UuRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5sYXlvdXRCYXNlLkRpbWVuc2lvbkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcbmxheW91dEJhc2UuSGFzaE1hcCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xubGF5b3V0QmFzZS5IYXNoU2V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5sYXlvdXRCYXNlLklHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5sYXlvdXRCYXNlLklNYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbmxheW91dEJhc2UuSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xubGF5b3V0QmFzZS5Qb2ludCA9IF9fd2VicGFja19yZXF1aXJlX18oMTIpO1xubGF5b3V0QmFzZS5Qb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xubGF5b3V0QmFzZS5SYW5kb21TZWVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5sYXlvdXRCYXNlLlJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbmxheW91dEJhc2UuVHJhbnNmb3JtID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5sYXlvdXRCYXNlLlVuaXF1ZUlER2VuZXJldG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5sYXlvdXRCYXNlLlF1aWNrc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xubGF5b3V0QmFzZS5MaW5rZWRMaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5sYXlvdXRCYXNlLkxHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5sYXlvdXRCYXNlLkxFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbmxheW91dEJhc2UuTEdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5sYXlvdXRCYXNlLkxOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbmxheW91dEJhc2UuTGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5sYXlvdXRCYXNlLkxheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5sYXlvdXRCYXNlLk5lZWRsZW1hbld1bnNjaCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xubGF5b3V0QmFzZS5NYXRyaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KTtcbmxheW91dEJhc2UuU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbm1vZHVsZS5leHBvcnRzID0gbGF5b3V0QmFzZTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBFbWl0dGVyKCkge1xuICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG52YXIgcCA9IEVtaXR0ZXIucHJvdG90eXBlO1xuXG5wLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xuICB0aGlzLmxpc3RlbmVycy5wdXNoKHtcbiAgICBldmVudDogZXZlbnQsXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gIH0pO1xufTtcblxucC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGwuZXZlbnQgPT09IGV2ZW50ICYmIGwuY2FsbGJhY2sgPT09IGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG59O1xuXG5wLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsID0gdGhpcy5saXN0ZW5lcnNbaV07XG5cbiAgICBpZiAoZXZlbnQgPT09IGwuZXZlbnQpIHtcbiAgICAgIGwuY2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1917\n')},83175:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: () => (/* binding */ diagram)\n/* harmony export */ });\n/* harmony import */ var _chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64532);\n/* harmony import */ var _chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10483);\n/* harmony import */ var _chunk_TMUBEWPD_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(63933);\n/* harmony import */ var _chunk_KFBOBJHC_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(98160);\n/* harmony import */ var _chunk_7DKRZKHE_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8159);\n/* harmony import */ var _chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(77286);\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10009);\n/* harmony import */ var _mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(78731);\n/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(90165);\n/* harmony import */ var cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26527);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(20007);\n\n\n\n\n\n\n\n\n// src/diagrams/architecture/architectureParser.ts\n\n\n// src/diagrams/architecture/architectureTypes.ts\nvar ArchitectureDirectionName = {\n  L: "left",\n  R: "right",\n  T: "top",\n  B: "bottom"\n};\nvar ArchitectureDirectionArrow = {\n  L: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((scale) => `${scale},${scale / 2} 0,${scale} 0,0`, "L"),\n  R: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((scale) => `0,${scale / 2} ${scale},0 ${scale},${scale}`, "R"),\n  T: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((scale) => `0,0 ${scale},0 ${scale / 2},${scale}`, "T"),\n  B: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((scale) => `${scale / 2},0 ${scale},${scale} 0,${scale}`, "B")\n};\nvar ArchitectureDirectionArrowShift = {\n  L: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((orig, arrowSize) => orig - arrowSize + 2, "L"),\n  R: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((orig, _arrowSize) => orig - 2, "R"),\n  T: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((orig, arrowSize) => orig - arrowSize + 2, "T"),\n  B: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((orig, _arrowSize) => orig - 2, "B")\n};\nvar getOppositeArchitectureDirection = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  if (isArchitectureDirectionX(x)) {\n    return x === "L" ? "R" : "L";\n  } else {\n    return x === "T" ? "B" : "T";\n  }\n}, "getOppositeArchitectureDirection");\nvar isArchitectureDirection = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  const temp = x;\n  return temp === "L" || temp === "R" || temp === "T" || temp === "B";\n}, "isArchitectureDirection");\nvar isArchitectureDirectionX = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  const temp = x;\n  return temp === "L" || temp === "R";\n}, "isArchitectureDirectionX");\nvar isArchitectureDirectionY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  const temp = x;\n  return temp === "T" || temp === "B";\n}, "isArchitectureDirectionY");\nvar isArchitectureDirectionXY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(a, b) {\n  const aX_bY = isArchitectureDirectionX(a) && isArchitectureDirectionY(b);\n  const aY_bX = isArchitectureDirectionY(a) && isArchitectureDirectionX(b);\n  return aX_bY || aY_bX;\n}, "isArchitectureDirectionXY");\nvar isArchitecturePairXY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  const aX_bY = isArchitectureDirectionX(lhs) && isArchitectureDirectionY(rhs);\n  const aY_bX = isArchitectureDirectionY(lhs) && isArchitectureDirectionX(rhs);\n  return aX_bY || aY_bX;\n}, "isArchitecturePairXY");\nvar isValidArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  return x !== "LL" && x !== "RR" && x !== "TT" && x !== "BB";\n}, "isValidArchitectureDirectionPair");\nvar getArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(sourceDir, targetDir) {\n  const pair = `${sourceDir}${targetDir}`;\n  return isValidArchitectureDirectionPair(pair) ? pair : void 0;\n}, "getArchitectureDirectionPair");\nvar shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function([x, y], pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  if (isArchitectureDirectionX(lhs)) {\n    if (isArchitectureDirectionY(rhs)) {\n      return [x + (lhs === "L" ? -1 : 1), y + (rhs === "T" ? 1 : -1)];\n    } else {\n      return [x + (lhs === "L" ? -1 : 1), y];\n    }\n  } else {\n    if (isArchitectureDirectionX(rhs)) {\n      return [x + (rhs === "L" ? 1 : -1), y + (lhs === "T" ? 1 : -1)];\n    } else {\n      return [x, y + (lhs === "T" ? 1 : -1)];\n    }\n  }\n}, "shiftPositionByArchitectureDirectionPair");\nvar getArchitectureDirectionXYFactors = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(pair) {\n  if (pair === "LT" || pair === "TL") {\n    return [1, 1];\n  } else if (pair === "BL" || pair === "LB") {\n    return [1, -1];\n  } else if (pair === "BR" || pair === "RB") {\n    return [-1, -1];\n  } else {\n    return [-1, 1];\n  }\n}, "getArchitectureDirectionXYFactors");\nvar isArchitectureService = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  const temp = x;\n  return temp.type === "service";\n}, "isArchitectureService");\nvar isArchitectureJunction = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(x) {\n  const temp = x;\n  return temp.type === "junction";\n}, "isArchitectureJunction");\nvar edgeData = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((edge) => {\n  return edge.data();\n}, "edgeData");\nvar nodeData = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((node) => {\n  return node.data();\n}, "nodeData");\n\n// src/diagrams/architecture/architectureDb.ts\nvar DEFAULT_ARCHITECTURE_CONFIG = _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .defaultConfig_default */ .UI.architecture;\nvar state = new _chunk_KFBOBJHC_mjs__WEBPACK_IMPORTED_MODULE_3__/* .ImperativeState */ .m(() => ({\n  nodes: {},\n  groups: {},\n  edges: [],\n  registeredIds: {},\n  config: DEFAULT_ARCHITECTURE_CONFIG,\n  dataStructures: void 0,\n  elements: {}\n}));\nvar clear2 = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => {\n  state.reset();\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .clear */ .IU)();\n}, "clear");\nvar addService = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function({\n  id,\n  icon,\n  in: parent,\n  title,\n  iconText\n}) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The service [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The service [${id}]\'s parent does not exist. Please make sure the parent is created before this service`\n      );\n    }\n    if (state.records.registeredIds[parent] === "node") {\n      throw new Error(`The service [${id}]\'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = "node";\n  state.records.nodes[id] = {\n    id,\n    type: "service",\n    icon,\n    iconText,\n    title,\n    edges: [],\n    in: parent\n  };\n}, "addService");\nvar getServices = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => Object.values(state.records.nodes).filter(isArchitectureService), "getServices");\nvar addJunction = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function({ id, in: parent }) {\n  state.records.registeredIds[id] = "node";\n  state.records.nodes[id] = {\n    id,\n    type: "junction",\n    edges: [],\n    in: parent\n  };\n}, "addJunction");\nvar getJunctions = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => Object.values(state.records.nodes).filter(isArchitectureJunction), "getJunctions");\nvar getNodes = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => Object.values(state.records.nodes), "getNodes");\nvar getNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((id) => state.records.nodes[id], "getNode");\nvar addGroup = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function({ id, icon, in: parent, title }) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The group [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The group [${id}]\'s parent does not exist. Please make sure the parent is created before this group`\n      );\n    }\n    if (state.records.registeredIds[parent] === "node") {\n      throw new Error(`The group [${id}]\'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = "group";\n  state.records.groups[id] = {\n    id,\n    icon,\n    title,\n    in: parent\n  };\n}, "addGroup");\nvar getGroups = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => {\n  return Object.values(state.records.groups);\n}, "getGroups");\nvar addEdge = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function({\n  lhsId,\n  rhsId,\n  lhsDir,\n  rhsDir,\n  lhsInto,\n  rhsInto,\n  lhsGroup,\n  rhsGroup,\n  title\n}) {\n  if (!isArchitectureDirection(lhsDir)) {\n    throw new Error(\n      `Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`\n    );\n  }\n  if (!isArchitectureDirection(rhsDir)) {\n    throw new Error(\n      `Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`\n    );\n  }\n  if (state.records.nodes[lhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  if (state.records.nodes[rhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  const lhsGroupId = state.records.nodes[lhsId].in;\n  const rhsGroupId = state.records.nodes[rhsId].in;\n  if (lhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  if (rhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  const edge = {\n    lhsId,\n    lhsDir,\n    lhsInto,\n    lhsGroup,\n    rhsId,\n    rhsDir,\n    rhsInto,\n    rhsGroup,\n    title\n  };\n  state.records.edges.push(edge);\n  if (state.records.nodes[lhsId] && state.records.nodes[rhsId]) {\n    state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n    state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n  }\n}, "addEdge");\nvar getEdges = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => state.records.edges, "getEdges");\nvar getDataStructures = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(() => {\n  if (state.records.dataStructures === void 0) {\n    const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service]) => {\n      prevOuter[id] = service.edges.reduce((prevInner, edge) => {\n        if (edge.lhsId === id) {\n          const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);\n          if (pair) {\n            prevInner[pair] = edge.rhsId;\n          }\n        } else {\n          const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);\n          if (pair) {\n            prevInner[pair] = edge.lhsId;\n          }\n        }\n        return prevInner;\n      }, {});\n      return prevOuter;\n    }, {});\n    const firstId = Object.keys(adjList)[0];\n    const visited = { [firstId]: 1 };\n    const notVisited = Object.keys(adjList).reduce(\n      (prev, id) => id === firstId ? prev : { ...prev, [id]: 1 },\n      {}\n    );\n    const BFS = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((startingId) => {\n      const spatialMap = { [startingId]: [0, 0] };\n      const queue = [startingId];\n      while (queue.length > 0) {\n        const id = queue.shift();\n        if (id) {\n          visited[id] = 1;\n          delete notVisited[id];\n          const adj = adjList[id];\n          const [posX, posY] = spatialMap[id];\n          Object.entries(adj).forEach(([dir, rhsId]) => {\n            if (!visited[rhsId]) {\n              spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair(\n                [posX, posY],\n                dir\n              );\n              queue.push(rhsId);\n            }\n          });\n        }\n      }\n      return spatialMap;\n    }, "BFS");\n    const spatialMaps = [BFS(firstId)];\n    while (Object.keys(notVisited).length > 0) {\n      spatialMaps.push(BFS(Object.keys(notVisited)[0]));\n    }\n    state.records.dataStructures = {\n      adjList,\n      spatialMaps\n    };\n  }\n  return state.records.dataStructures;\n}, "getDataStructures");\nvar setElementForId = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((id, element) => {\n  state.records.elements[id] = element;\n}, "setElementForId");\nvar getElementById = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((id) => state.records.elements[id], "getElementById");\nvar db = {\n  clear: clear2,\n  setDiagramTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .setDiagramTitle */ .ke,\n  getDiagramTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getDiagramTitle */ .ab,\n  setAccTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .setAccTitle */ .SV,\n  getAccTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getAccTitle */ .iN,\n  setAccDescription: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .setAccDescription */ .EI,\n  getAccDescription: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getAccDescription */ .m7,\n  addService,\n  getServices,\n  addJunction,\n  getJunctions,\n  getNodes,\n  getNode,\n  addGroup,\n  getGroups,\n  addEdge,\n  getEdges,\n  setElementForId,\n  getElementById,\n  getDataStructures\n};\nfunction getConfigField(field) {\n  const arch = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getConfig2 */ .D7)().architecture;\n  if (arch?.[field]) {\n    return arch[field];\n  }\n  return DEFAULT_ARCHITECTURE_CONFIG[field];\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(getConfigField, "getConfigField");\n\n// src/diagrams/architecture/architectureParser.ts\nvar populateDb = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((ast, db2) => {\n  (0,_chunk_TMUBEWPD_mjs__WEBPACK_IMPORTED_MODULE_2__/* .populateCommonDb */ .S)(ast, db2);\n  ast.groups.map(db2.addGroup);\n  ast.services.map((service) => db2.addService({ ...service, type: "service" }));\n  ast.junctions.map((service) => db2.addJunction({ ...service, type: "junction" }));\n  ast.edges.map(db2.addEdge);\n}, "populateDb");\nvar parser = {\n  parse: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(async (input) => {\n    const ast = await (0,_mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__/* .parse */ .qg)("architecture", input);\n    _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .log */ .Rm.debug(ast);\n    populateDb(ast, db);\n  }, "parse")\n};\n\n// src/diagrams/architecture/architectureStyles.ts\nvar getStyles = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((options) => `\n  .edge {\n    stroke-width: ${options.archEdgeWidth};\n    stroke: ${options.archEdgeColor};\n    fill: none;\n  }\n\n  .arrow {\n    fill: ${options.archEdgeArrowColor};\n  }\n\n  .node-bkg {\n    fill: none;\n    stroke: ${options.archGroupBorderColor};\n    stroke-width: ${options.archGroupBorderWidth};\n    stroke-dasharray: 8;\n  }\n  .node-icon-text {\n    display: flex; \n    align-items: center;\n  }\n  \n  .node-icon-text > div {\n    color: #fff;\n    margin: 1px;\n    height: fit-content;\n    text-align: center;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n  }\n`, "getStyles");\nvar architectureStyles_default = getStyles;\n\n// src/diagrams/architecture/architectureRenderer.ts\n\n\n\n\n// src/diagrams/architecture/architectureIcons.ts\nvar wrapIcon = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((icon) => {\n  return `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${icon}</g>`;\n}, "wrapIcon");\nvar architectureIcons = {\n  prefix: "mermaid-architecture",\n  height: 80,\n  width: 80,\n  icons: {\n    database: {\n      body: wrapIcon(\n        \'<path id="b" data-name="4" d="m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="c" data-name="3" d="m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="d" data-name="2" d="m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse id="e" data-name="1" cx="40" cy="22.14" rx="20" ry="7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="20" y1="57.86" x2="20" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="60" y1="57.86" x2="60" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>\'\n      )\n    },\n    server: {\n      body: wrapIcon(\n        \'<rect x="17.5" y="17.5" width="45" height="45" rx="2" ry="2" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="32.5" x2="62.5" y2="32.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="47.5" x2="62.5" y2="47.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><g><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g>\'\n      )\n    },\n    disk: {\n      body: wrapIcon(\n        \'<rect x="20" y="15" width="40" height="50" rx="1" ry="1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="14" ry="14.58" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="4" ry="4.17" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z" style="fill: #fff; stroke-width: 0px;"/>\'\n      )\n    },\n    internet: {\n      body: wrapIcon(\n        \'<circle cx="40" cy="40" r="22.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="40" y1="17.5" x2="40" y2="62.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="40" x2="62.5" y2="40" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="30.1" x2="60.25" y2="30.1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="49.9" x2="60.25" y2="49.9" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>\'\n      )\n    },\n    cloud: {\n      body: wrapIcon(\n        \'<path d="m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>\'\n      )\n    },\n    unknown: _chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__/* .unknownIcon */ .Gc,\n    blank: {\n      body: wrapIcon("")\n    }\n  }\n};\n\n// src/diagrams/architecture/svgDraw.ts\nvar drawEdges = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(async function(edgesEl, cy) {\n  const padding = getConfigField("padding");\n  const iconSize = getConfigField("iconSize");\n  const halfIconSize = iconSize / 2;\n  const arrowSize = iconSize / 6;\n  const halfArrowSize = arrowSize / 2;\n  await Promise.all(\n    cy.edges().map(async (edge) => {\n      const {\n        source,\n        sourceDir,\n        sourceArrow,\n        sourceGroup,\n        target,\n        targetDir,\n        targetArrow,\n        targetGroup,\n        label\n      } = edgeData(edge);\n      let { x: startX, y: startY } = edge[0].sourceEndpoint();\n      const { x: midX, y: midY } = edge[0].midpoint();\n      let { x: endX, y: endY } = edge[0].targetEndpoint();\n      const groupEdgeShift = padding + 4;\n      if (sourceGroup) {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === "L" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          startY += sourceDir === "T" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (targetGroup) {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === "L" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          endY += targetDir === "T" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (!sourceGroup && db.getNode(source)?.type === "junction") {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === "L" ? halfIconSize : -halfIconSize;\n        } else {\n          startY += sourceDir === "T" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (!targetGroup && db.getNode(target)?.type === "junction") {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === "L" ? halfIconSize : -halfIconSize;\n        } else {\n          endY += targetDir === "T" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (edge[0]._private.rscratch) {\n        const g = edgesEl.insert("g");\n        g.insert("path").attr("d", `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr("class", "edge");\n        if (sourceArrow) {\n          const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;\n          g.insert("polygon").attr("points", ArchitectureDirectionArrow[sourceDir](arrowSize)).attr("transform", `translate(${xShift},${yShift})`).attr("class", "arrow");\n        }\n        if (targetArrow) {\n          const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;\n          g.insert("polygon").attr("points", ArchitectureDirectionArrow[targetDir](arrowSize)).attr("transform", `translate(${xShift},${yShift})`).attr("class", "arrow");\n        }\n        if (label) {\n          const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? "X" : "Y" : "XY";\n          let width = 0;\n          if (axis === "X") {\n            width = Math.abs(startX - endX);\n          } else if (axis === "Y") {\n            width = Math.abs(startY - endY) / 1.5;\n          } else {\n            width = Math.abs(startX - endX) / 2;\n          }\n          const textElem = g.append("g");\n          await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__/* .createText */ .GZ)(\n            textElem,\n            label,\n            {\n              useHtmlLabels: false,\n              width,\n              classes: "architecture-service-label"\n            },\n            (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getConfig2 */ .D7)()\n          );\n          textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle");\n          if (axis === "X") {\n            textElem.attr("transform", "translate(" + midX + ", " + midY + ")");\n          } else if (axis === "Y") {\n            textElem.attr("transform", "translate(" + midX + ", " + midY + ") rotate(-90)");\n          } else if (axis === "XY") {\n            const pair = getArchitectureDirectionPair(sourceDir, targetDir);\n            if (pair && isArchitecturePairXY(pair)) {\n              const bboxOrig = textElem.node().getBoundingClientRect();\n              const [x, y] = getArchitectureDirectionXYFactors(pair);\n              textElem.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * x * y * 45})`);\n              const bboxNew = textElem.node().getBoundingClientRect();\n              textElem.attr(\n                "transform",\n                `\n                translate(${midX}, ${midY - bboxOrig.height / 2})\n                translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})\n                rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})\n              `\n              );\n            }\n          }\n        }\n      }\n    })\n  );\n}, "drawEdges");\nvar drawGroups = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(async function(groupsEl, cy) {\n  const padding = getConfigField("padding");\n  const groupIconSize = padding * 0.75;\n  const fontSize = getConfigField("fontSize");\n  const iconSize = getConfigField("iconSize");\n  const halfIconSize = iconSize / 2;\n  await Promise.all(\n    cy.nodes().map(async (node) => {\n      const data = nodeData(node);\n      if (data.type === "group") {\n        const { h, w, x1, y1 } = node.boundingBox();\n        groupsEl.append("rect").attr("x", x1 + halfIconSize).attr("y", y1 + halfIconSize).attr("width", w).attr("height", h).attr("class", "node-bkg");\n        const groupLabelContainer = groupsEl.append("g");\n        let shiftedX1 = x1;\n        let shiftedY1 = y1;\n        if (data.icon) {\n          const bkgElem = groupLabelContainer.append("g");\n          bkgElem.html(\n            `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getIconSVG */ .WY)(data.icon, { height: groupIconSize, width: groupIconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n          );\n          bkgElem.attr(\n            "transform",\n            "translate(" + (shiftedX1 + halfIconSize + 1) + ", " + (shiftedY1 + halfIconSize + 1) + ")"\n          );\n          shiftedX1 += groupIconSize;\n          shiftedY1 += fontSize / 2 - 1 - 2;\n        }\n        if (data.label) {\n          const textElem = groupLabelContainer.append("g");\n          await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__/* .createText */ .GZ)(\n            textElem,\n            data.label,\n            {\n              useHtmlLabels: false,\n              width: w,\n              classes: "architecture-service-label"\n            },\n            (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getConfig2 */ .D7)()\n          );\n          textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start");\n          textElem.attr(\n            "transform",\n            "translate(" + (shiftedX1 + halfIconSize + 4) + ", " + (shiftedY1 + halfIconSize + 2) + ")"\n          );\n        }\n      }\n    })\n  );\n}, "drawGroups");\nvar drawServices = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(async function(db2, elem, services) {\n  for (const service of services) {\n    const serviceElem = elem.append("g");\n    const iconSize = getConfigField("iconSize");\n    if (service.title) {\n      const textElem = serviceElem.append("g");\n      await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__/* .createText */ .GZ)(\n        textElem,\n        service.title,\n        {\n          useHtmlLabels: false,\n          width: iconSize * 1.5,\n          classes: "architecture-service-label"\n        },\n        (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .getConfig2 */ .D7)()\n      );\n      textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle");\n      textElem.attr("transform", "translate(" + iconSize / 2 + ", " + iconSize + ")");\n    }\n    const bkgElem = serviceElem.append("g");\n    if (service.icon) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getIconSVG */ .WY)(service.icon, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n    } else if (service.iconText) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__/* .getIconSVG */ .WY)("blank", { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n      const textElemContainer = bkgElem.append("g");\n      const fo = textElemContainer.append("foreignObject").attr("width", iconSize).attr("height", iconSize);\n      const divElem = fo.append("div").attr("class", "node-icon-text").attr("style", `height: ${iconSize}px;`).append("div").html(service.iconText);\n      const fontSize = parseInt(\n        window.getComputedStyle(divElem.node(), null).getPropertyValue("font-size").replace(/\\D/g, "")\n      ) ?? 16;\n      divElem.attr("style", `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);\n    } else {\n      bkgElem.append("path").attr("class", "node-bkg").attr("id", "node-" + service.id).attr(\n        "d",\n        `M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`\n      );\n    }\n    serviceElem.attr("class", "architecture-service");\n    const { width, height } = serviceElem._groups[0][0].getBBox();\n    service.width = width;\n    service.height = height;\n    db2.setElementForId(service.id, serviceElem);\n  }\n  return 0;\n}, "drawServices");\nvar drawJunctions = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(function(db2, elem, junctions) {\n  junctions.forEach((junction) => {\n    const junctionElem = elem.append("g");\n    const iconSize = getConfigField("iconSize");\n    const bkgElem = junctionElem.append("g");\n    bkgElem.append("rect").attr("id", "node-" + junction.id).attr("fill-opacity", "0").attr("width", iconSize).attr("height", iconSize);\n    junctionElem.attr("class", "architecture-junction");\n    const { width, height } = junctionElem._groups[0][0].getBBox();\n    junctionElem.width = width;\n    junctionElem.height = height;\n    db2.setElementForId(junction.id, junctionElem);\n  });\n}, "drawJunctions");\n\n// src/diagrams/architecture/architectureRenderer.ts\n(0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__/* .registerIconPacks */ .pC)([\n  {\n    name: architectureIcons.prefix,\n    icons: architectureIcons\n  }\n]);\ncytoscape__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A.use(cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__);\nfunction addServices(services, cy) {\n  services.forEach((service) => {\n    cy.add({\n      group: "nodes",\n      data: {\n        type: "service",\n        id: service.id,\n        icon: service.icon,\n        label: service.title,\n        parent: service.in,\n        width: getConfigField("iconSize"),\n        height: getConfigField("iconSize")\n      },\n      classes: "node-service"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(addServices, "addServices");\nfunction addJunctions(junctions, cy) {\n  junctions.forEach((junction) => {\n    cy.add({\n      group: "nodes",\n      data: {\n        type: "junction",\n        id: junction.id,\n        parent: junction.in,\n        width: getConfigField("iconSize"),\n        height: getConfigField("iconSize")\n      },\n      classes: "node-junction"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(addJunctions, "addJunctions");\nfunction positionNodes(db2, cy) {\n  cy.nodes().map((node) => {\n    const data = nodeData(node);\n    if (data.type === "group") {\n      return;\n    }\n    data.x = node.position().x;\n    data.y = node.position().y;\n    const nodeElem = db2.getElementById(data.id);\n    nodeElem.attr("transform", "translate(" + (data.x || 0) + "," + (data.y || 0) + ")");\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(positionNodes, "positionNodes");\nfunction addGroups(groups, cy) {\n  groups.forEach((group) => {\n    cy.add({\n      group: "nodes",\n      data: {\n        type: "group",\n        id: group.id,\n        icon: group.icon,\n        label: group.title,\n        parent: group.in\n      },\n      classes: "node-group"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(addGroups, "addGroups");\nfunction addEdges(edges, cy) {\n  edges.forEach((parsedEdge) => {\n    const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;\n    const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? "segments" : "straight";\n    const edge = {\n      id: `${lhsId}-${rhsId}`,\n      label: title,\n      source: lhsId,\n      sourceDir: lhsDir,\n      sourceArrow: lhsInto,\n      sourceGroup: lhsGroup,\n      sourceEndpoint: lhsDir === "L" ? "0 50%" : lhsDir === "R" ? "100% 50%" : lhsDir === "T" ? "50% 0" : "50% 100%",\n      target: rhsId,\n      targetDir: rhsDir,\n      targetArrow: rhsInto,\n      targetGroup: rhsGroup,\n      targetEndpoint: rhsDir === "L" ? "0 50%" : rhsDir === "R" ? "100% 50%" : rhsDir === "T" ? "50% 0" : "50% 100%"\n    };\n    cy.add({\n      group: "edges",\n      data: edge,\n      classes: edgeType\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(addEdges, "addEdges");\nfunction getAlignments(spatialMaps) {\n  const alignments = spatialMaps.map((spatialMap) => {\n    const horizontalAlignments = {};\n    const verticalAlignments = {};\n    Object.entries(spatialMap).forEach(([id, [x, y]]) => {\n      if (!horizontalAlignments[y]) {\n        horizontalAlignments[y] = [];\n      }\n      if (!verticalAlignments[x]) {\n        verticalAlignments[x] = [];\n      }\n      horizontalAlignments[y].push(id);\n      verticalAlignments[x].push(id);\n    });\n    return {\n      horiz: Object.values(horizontalAlignments).filter((arr) => arr.length > 1),\n      vert: Object.values(verticalAlignments).filter((arr) => arr.length > 1)\n    };\n  });\n  const [horizontal, vertical] = alignments.reduce(\n    ([prevHoriz, prevVert], { horiz, vert }) => {\n      return [\n        [...prevHoriz, ...horiz],\n        [...prevVert, ...vert]\n      ];\n    },\n    [[], []]\n  );\n  return {\n    horizontal,\n    vertical\n  };\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(getAlignments, "getAlignments");\nfunction getRelativeConstraints(spatialMaps) {\n  const relativeConstraints = [];\n  const posToStr = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((pos) => `${pos[0]},${pos[1]}`, "posToStr");\n  const strToPos = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)((pos) => pos.split(",").map((p) => parseInt(p)), "strToPos");\n  spatialMaps.forEach((spatialMap) => {\n    const invSpatialMap = Object.fromEntries(\n      Object.entries(spatialMap).map(([id, pos]) => [posToStr(pos), id])\n    );\n    const queue = [posToStr([0, 0])];\n    const visited = {};\n    const directions = {\n      L: [-1, 0],\n      R: [1, 0],\n      T: [0, 1],\n      B: [0, -1]\n    };\n    while (queue.length > 0) {\n      const curr = queue.shift();\n      if (curr) {\n        visited[curr] = 1;\n        const currId = invSpatialMap[curr];\n        if (currId) {\n          const currPos = strToPos(curr);\n          Object.entries(directions).forEach(([dir, shift]) => {\n            const newPos = posToStr([currPos[0] + shift[0], currPos[1] + shift[1]]);\n            const newId = invSpatialMap[newPos];\n            if (newId && !visited[newPos]) {\n              queue.push(newPos);\n              relativeConstraints.push({\n                [ArchitectureDirectionName[dir]]: newId,\n                [ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,\n                gap: 1.5 * getConfigField("iconSize")\n              });\n            }\n          });\n        }\n      }\n    }\n  });\n  return relativeConstraints;\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(getRelativeConstraints, "getRelativeConstraints");\nfunction layoutArchitecture(services, junctions, groups, edges, { spatialMaps }) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_10__/* .select */ .Ltv)("body").append("div").attr("id", "cy").attr("style", "display:none");\n    const cy = (0,cytoscape__WEBPACK_IMPORTED_MODULE_8__/* ["default"] */ .A)({\n      container: document.getElementById("cy"),\n      style: [\n        {\n          selector: "edge",\n          style: {\n            "curve-style": "straight",\n            label: "data(label)",\n            "source-endpoint": "data(sourceEndpoint)",\n            "target-endpoint": "data(targetEndpoint)"\n          }\n        },\n        {\n          selector: "edge.segments",\n          style: {\n            "curve-style": "segments",\n            "segment-weights": "0",\n            "segment-distances": [0.5],\n            // @ts-ignore Incorrect library types\n            "edge-distances": "endpoints",\n            "source-endpoint": "data(sourceEndpoint)",\n            "target-endpoint": "data(targetEndpoint)"\n          }\n        },\n        {\n          selector: "node",\n          style: {\n            // @ts-ignore Incorrect library types\n            "compound-sizing-wrt-labels": "include"\n          }\n        },\n        {\n          selector: "node[label]",\n          style: {\n            "text-valign": "bottom",\n            "text-halign": "center",\n            "font-size": `${getConfigField("fontSize")}px`\n          }\n        },\n        {\n          selector: ".node-service",\n          style: {\n            label: "data(label)",\n            width: "data(width)",\n            height: "data(height)"\n          }\n        },\n        {\n          selector: ".node-junction",\n          style: {\n            width: "data(width)",\n            height: "data(height)"\n          }\n        },\n        {\n          selector: ".node-group",\n          style: {\n            // @ts-ignore Incorrect library types\n            padding: `${getConfigField("padding")}px`\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addGroups(groups, cy);\n    addServices(services, cy);\n    addJunctions(junctions, cy);\n    addEdges(edges, cy);\n    const alignmentConstraint = getAlignments(spatialMaps);\n    const relativePlacementConstraint = getRelativeConstraints(spatialMaps);\n    const layout = cy.layout({\n      name: "fcose",\n      quality: "proof",\n      styleEnabled: false,\n      animate: false,\n      nodeDimensionsIncludeLabels: false,\n      // Adjust the edge parameters if it passes through the border of a group\n      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67\n      idealEdgeLength(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 1.5 * getConfigField("iconSize") : 0.5 * getConfigField("iconSize");\n        return elasticity;\n      },\n      edgeElasticity(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 0.45 : 1e-3;\n        return elasticity;\n      },\n      alignmentConstraint,\n      relativePlacementConstraint\n    });\n    layout.one("layoutstop", () => {\n      function getSegmentWeights(source, target, pointX, pointY) {\n        let W, D;\n        const { x: sX, y: sY } = source;\n        const { x: tX, y: tY } = target;\n        D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));\n        W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));\n        const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));\n        W = W / distAB;\n        let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);\n        switch (true) {\n          case delta1 >= 0:\n            delta1 = 1;\n            break;\n          case delta1 < 0:\n            delta1 = -1;\n            break;\n        }\n        let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);\n        switch (true) {\n          case delta2 >= 0:\n            delta2 = 1;\n            break;\n          case delta2 < 0:\n            delta2 = -1;\n            break;\n        }\n        D = Math.abs(D) * delta1;\n        W = W * delta2;\n        return {\n          distances: D,\n          weights: W\n        };\n      }\n      (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(getSegmentWeights, "getSegmentWeights");\n      cy.startBatch();\n      for (const edge of Object.values(cy.edges())) {\n        if (edge.data?.()) {\n          const { x: sX, y: sY } = edge.source().position();\n          const { x: tX, y: tY } = edge.target().position();\n          if (sX !== tX && sY !== tY) {\n            const sEP = edge.sourceEndpoint();\n            const tEP = edge.targetEndpoint();\n            const { sourceDir } = edgeData(edge);\n            const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [sEP.x, tEP.y] : [tEP.x, sEP.y];\n            const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);\n            edge.style("segment-distances", distances);\n            edge.style("segment-weights", weights);\n          }\n        }\n      }\n      cy.endBatch();\n      layout.run();\n    });\n    layout.run();\n    cy.ready((e) => {\n      _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .log */ .Rm.info("Ready", e);\n      resolve(cy);\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(layoutArchitecture, "layoutArchitecture");\nvar draw = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .__name */ .K2)(async (text, id, _version, diagObj) => {\n  const db2 = diagObj.db;\n  const services = db2.getServices();\n  const junctions = db2.getJunctions();\n  const groups = db2.getGroups();\n  const edges = db2.getEdges();\n  const ds = db2.getDataStructures();\n  const svg = (0,_chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_5__/* .selectSvgElement */ .D)(id);\n  const edgesElem = svg.append("g");\n  edgesElem.attr("class", "architecture-edges");\n  const servicesElem = svg.append("g");\n  servicesElem.attr("class", "architecture-services");\n  const groupElem = svg.append("g");\n  groupElem.attr("class", "architecture-groups");\n  await drawServices(db2, servicesElem, services);\n  drawJunctions(db2, servicesElem, junctions);\n  const cy = await layoutArchitecture(services, junctions, groups, edges, ds);\n  await drawEdges(edgesElem, cy);\n  await drawGroups(groupElem, cy);\n  positionNodes(db2, cy);\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__/* .setupGraphViewbox */ .ot)(void 0, svg, getConfigField("padding"), getConfigField("useMaxWidth"));\n}, "draw");\nvar renderer = { draw };\n\n// src/diagrams/architecture/architectureDiagram.ts\nvar diagram = {\n  parser,\n  db,\n  renderer,\n  styles: architectureStyles_default\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jaHVua3MvbWVybWFpZC5jb3JlL2FyY2hpdGVjdHVyZURpYWdyYW0tVVlONk1CUEQubWpzPzliYmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZ2V0SWNvblNWRyxcbiAgcmVnaXN0ZXJJY29uUGFja3MsXG4gIHVua25vd25JY29uXG59IGZyb20gXCIuL2NodW5rLU9QTzRJVTQyLm1qc1wiO1xuaW1wb3J0IHtcbiAgY3JlYXRlVGV4dFxufSBmcm9tIFwiLi9jaHVuay02Sk9TNzREUy5tanNcIjtcbmltcG9ydCB7XG4gIHBvcHVsYXRlQ29tbW9uRGJcbn0gZnJvbSBcIi4vY2h1bmstVE1VQkVXUEQubWpzXCI7XG5pbXBvcnQge1xuICBJbXBlcmF0aXZlU3RhdGVcbn0gZnJvbSBcIi4vY2h1bmstS0ZCT0JKSEMubWpzXCI7XG5pbXBvcnQgXCIuL2NodW5rLTdES1JaS0hFLm1qc1wiO1xuaW1wb3J0IHtcbiAgc2VsZWN0U3ZnRWxlbWVudFxufSBmcm9tIFwiLi9jaHVuay1FSjRaV1hHTC5tanNcIjtcbmltcG9ydCB7XG4gIF9fbmFtZSxcbiAgY2xlYXIsXG4gIGRlZmF1bHRDb25maWdfZGVmYXVsdCxcbiAgZ2V0QWNjRGVzY3JpcHRpb24sXG4gIGdldEFjY1RpdGxlLFxuICBnZXRDb25maWcyIGFzIGdldENvbmZpZyxcbiAgZ2V0RGlhZ3JhbVRpdGxlLFxuICBsb2csXG4gIHNldEFjY0Rlc2NyaXB0aW9uLFxuICBzZXRBY2NUaXRsZSxcbiAgc2V0RGlhZ3JhbVRpdGxlLFxuICBzZXR1cEdyYXBoVmlld2JveFxufSBmcm9tIFwiLi9jaHVuay02REJGRkhJUC5tanNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVQYXJzZXIudHNcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIkBtZXJtYWlkLWpzL3BhcnNlclwiO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVR5cGVzLnRzXG52YXIgQXJjaGl0ZWN0dXJlRGlyZWN0aW9uTmFtZSA9IHtcbiAgTDogXCJsZWZ0XCIsXG4gIFI6IFwicmlnaHRcIixcbiAgVDogXCJ0b3BcIixcbiAgQjogXCJib3R0b21cIlxufTtcbnZhciBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvdyA9IHtcbiAgTDogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2NhbGUpID0+IGAke3NjYWxlfSwke3NjYWxlIC8gMn0gMCwke3NjYWxlfSAwLDBgLCBcIkxcIiksXG4gIFI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNjYWxlKSA9PiBgMCwke3NjYWxlIC8gMn0gJHtzY2FsZX0sMCAke3NjYWxlfSwke3NjYWxlfWAsIFwiUlwiKSxcbiAgVDogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2NhbGUpID0+IGAwLDAgJHtzY2FsZX0sMCAke3NjYWxlIC8gMn0sJHtzY2FsZX1gLCBcIlRcIiksXG4gIEI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHNjYWxlKSA9PiBgJHtzY2FsZSAvIDJ9LDAgJHtzY2FsZX0sJHtzY2FsZX0gMCwke3NjYWxlfWAsIFwiQlwiKVxufTtcbnZhciBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1NoaWZ0ID0ge1xuICBMOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcmlnLCBhcnJvd1NpemUpID0+IG9yaWcgLSBhcnJvd1NpemUgKyAyLCBcIkxcIiksXG4gIFI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9yaWcsIF9hcnJvd1NpemUpID0+IG9yaWcgLSAyLCBcIlJcIiksXG4gIFQ6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9yaWcsIGFycm93U2l6ZSkgPT4gb3JpZyAtIGFycm93U2l6ZSArIDIsIFwiVFwiKSxcbiAgQjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3JpZywgX2Fycm93U2l6ZSkgPT4gb3JpZyAtIDIsIFwiQlwiKVxufTtcbnZhciBnZXRPcHBvc2l0ZUFyY2hpdGVjdHVyZURpcmVjdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHgpKSB7XG4gICAgcmV0dXJuIHggPT09IFwiTFwiID8gXCJSXCIgOiBcIkxcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCA9PT0gXCJUXCIgPyBcIkJcIiA6IFwiVFwiO1xuICB9XG59LCBcImdldE9wcG9zaXRlQXJjaGl0ZWN0dXJlRGlyZWN0aW9uXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGNvbnN0IHRlbXAgPSB4O1xuICByZXR1cm4gdGVtcCA9PT0gXCJMXCIgfHwgdGVtcCA9PT0gXCJSXCIgfHwgdGVtcCA9PT0gXCJUXCIgfHwgdGVtcCA9PT0gXCJCXCI7XG59LCBcImlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBjb25zdCB0ZW1wID0geDtcbiAgcmV0dXJuIHRlbXAgPT09IFwiTFwiIHx8IHRlbXAgPT09IFwiUlwiO1xufSwgXCJpc0FyY2hpdGVjdHVyZURpcmVjdGlvblhcIik7XG52YXIgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGNvbnN0IHRlbXAgPSB4O1xuICByZXR1cm4gdGVtcCA9PT0gXCJUXCIgfHwgdGVtcCA9PT0gXCJCXCI7XG59LCBcImlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWVwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblhZID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihhLCBiKSB7XG4gIGNvbnN0IGFYX2JZID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKGEpICYmIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShiKTtcbiAgY29uc3QgYVlfYlggPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkoYSkgJiYgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKGIpO1xuICByZXR1cm4gYVhfYlkgfHwgYVlfYlg7XG59LCBcImlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFlcIik7XG52YXIgaXNBcmNoaXRlY3R1cmVQYWlyWFkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHBhaXIpIHtcbiAgY29uc3QgbGhzID0gcGFpclswXTtcbiAgY29uc3QgcmhzID0gcGFpclsxXTtcbiAgY29uc3QgYVhfYlkgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgobGhzKSAmJiBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkocmhzKTtcbiAgY29uc3QgYVlfYlggPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkobGhzKSAmJiBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgocmhzKTtcbiAgcmV0dXJuIGFYX2JZIHx8IGFZX2JYO1xufSwgXCJpc0FyY2hpdGVjdHVyZVBhaXJYWVwiKTtcbnZhciBpc1ZhbGlkQXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCAhPT0gXCJMTFwiICYmIHggIT09IFwiUlJcIiAmJiB4ICE9PSBcIlRUXCIgJiYgeCAhPT0gXCJCQlwiO1xufSwgXCJpc1ZhbGlkQXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpclwiKTtcbnZhciBnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihzb3VyY2VEaXIsIHRhcmdldERpcikge1xuICBjb25zdCBwYWlyID0gYCR7c291cmNlRGlyfSR7dGFyZ2V0RGlyfWA7XG4gIHJldHVybiBpc1ZhbGlkQXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpcihwYWlyKSA/IHBhaXIgOiB2b2lkIDA7XG59LCBcImdldEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXJcIik7XG52YXIgc2hpZnRQb3NpdGlvbkJ5QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oW3gsIHldLCBwYWlyKSB7XG4gIGNvbnN0IGxocyA9IHBhaXJbMF07XG4gIGNvbnN0IHJocyA9IHBhaXJbMV07XG4gIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgobGhzKSkge1xuICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkocmhzKSkge1xuICAgICAgcmV0dXJuIFt4ICsgKGxocyA9PT0gXCJMXCIgPyAtMSA6IDEpLCB5ICsgKHJocyA9PT0gXCJUXCIgPyAxIDogLTEpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt4ICsgKGxocyA9PT0gXCJMXCIgPyAtMSA6IDEpLCB5XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChyaHMpKSB7XG4gICAgICByZXR1cm4gW3ggKyAocmhzID09PSBcIkxcIiA/IDEgOiAtMSksIHkgKyAobGhzID09PSBcIlRcIiA/IDEgOiAtMSldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3gsIHkgKyAobGhzID09PSBcIlRcIiA/IDEgOiAtMSldO1xuICAgIH1cbiAgfVxufSwgXCJzaGlmdFBvc2l0aW9uQnlBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyXCIpO1xudmFyIGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblhZRmFjdG9ycyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24ocGFpcikge1xuICBpZiAocGFpciA9PT0gXCJMVFwiIHx8IHBhaXIgPT09IFwiVExcIikge1xuICAgIHJldHVybiBbMSwgMV07XG4gIH0gZWxzZSBpZiAocGFpciA9PT0gXCJCTFwiIHx8IHBhaXIgPT09IFwiTEJcIikge1xuICAgIHJldHVybiBbMSwgLTFdO1xuICB9IGVsc2UgaWYgKHBhaXIgPT09IFwiQlJcIiB8fCBwYWlyID09PSBcIlJCXCIpIHtcbiAgICByZXR1cm4gWy0xLCAtMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFstMSwgMV07XG4gIH1cbn0sIFwiZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFlGYWN0b3JzXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlU2VydmljZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeCkge1xuICBjb25zdCB0ZW1wID0geDtcbiAgcmV0dXJuIHRlbXAudHlwZSA9PT0gXCJzZXJ2aWNlXCI7XG59LCBcImlzQXJjaGl0ZWN0dXJlU2VydmljZVwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZUp1bmN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGNvbnN0IHRlbXAgPSB4O1xuICByZXR1cm4gdGVtcC50eXBlID09PSBcImp1bmN0aW9uXCI7XG59LCBcImlzQXJjaGl0ZWN0dXJlSnVuY3Rpb25cIik7XG52YXIgZWRnZURhdGEgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChlZGdlKSA9PiB7XG4gIHJldHVybiBlZGdlLmRhdGEoKTtcbn0sIFwiZWRnZURhdGFcIik7XG52YXIgbm9kZURhdGEgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChub2RlKSA9PiB7XG4gIHJldHVybiBub2RlLmRhdGEoKTtcbn0sIFwibm9kZURhdGFcIik7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlRGIudHNcbnZhciBERUZBVUxUX0FSQ0hJVEVDVFVSRV9DT05GSUcgPSBkZWZhdWx0Q29uZmlnX2RlZmF1bHQuYXJjaGl0ZWN0dXJlO1xudmFyIHN0YXRlID0gbmV3IEltcGVyYXRpdmVTdGF0ZSgoKSA9PiAoe1xuICBub2Rlczoge30sXG4gIGdyb3Vwczoge30sXG4gIGVkZ2VzOiBbXSxcbiAgcmVnaXN0ZXJlZElkczoge30sXG4gIGNvbmZpZzogREVGQVVMVF9BUkNISVRFQ1RVUkVfQ09ORklHLFxuICBkYXRhU3RydWN0dXJlczogdm9pZCAwLFxuICBlbGVtZW50czoge31cbn0pKTtcbnZhciBjbGVhcjIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgc3RhdGUucmVzZXQoKTtcbiAgY2xlYXIoKTtcbn0sIFwiY2xlYXJcIik7XG52YXIgYWRkU2VydmljZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oe1xuICBpZCxcbiAgaWNvbixcbiAgaW46IHBhcmVudCxcbiAgdGl0bGUsXG4gIGljb25UZXh0XG59KSB7XG4gIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIHNlcnZpY2UgaWQgWyR7aWR9XSBpcyBhbHJlYWR5IGluIHVzZSBieSBhbm90aGVyICR7c3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXX1gXG4gICAgKTtcbiAgfVxuICBpZiAocGFyZW50ICE9PSB2b2lkIDApIHtcbiAgICBpZiAoaWQgPT09IHBhcmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VydmljZSBbJHtpZH1dIGNhbm5vdCBiZSBwbGFjZWQgd2l0aGluIGl0c2VsZmApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW3BhcmVudF0gPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIHNlcnZpY2UgWyR7aWR9XSdzIHBhcmVudCBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgcGFyZW50IGlzIGNyZWF0ZWQgYmVmb3JlIHRoaXMgc2VydmljZWBcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbcGFyZW50XSA9PT0gXCJub2RlXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgWyR7aWR9XSdzIHBhcmVudCBpcyBub3QgYSBncm91cGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdID0gXCJub2RlXCI7XG4gIHN0YXRlLnJlY29yZHMubm9kZXNbaWRdID0ge1xuICAgIGlkLFxuICAgIHR5cGU6IFwic2VydmljZVwiLFxuICAgIGljb24sXG4gICAgaWNvblRleHQsXG4gICAgdGl0bGUsXG4gICAgZWRnZXM6IFtdLFxuICAgIGluOiBwYXJlbnRcbiAgfTtcbn0sIFwiYWRkU2VydmljZVwiKTtcbnZhciBnZXRTZXJ2aWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gT2JqZWN0LnZhbHVlcyhzdGF0ZS5yZWNvcmRzLm5vZGVzKS5maWx0ZXIoaXNBcmNoaXRlY3R1cmVTZXJ2aWNlKSwgXCJnZXRTZXJ2aWNlc1wiKTtcbnZhciBhZGRKdW5jdGlvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeyBpZCwgaW46IHBhcmVudCB9KSB7XG4gIHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF0gPSBcIm5vZGVcIjtcbiAgc3RhdGUucmVjb3Jkcy5ub2Rlc1tpZF0gPSB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJqdW5jdGlvblwiLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBpbjogcGFyZW50XG4gIH07XG59LCBcImFkZEp1bmN0aW9uXCIpO1xudmFyIGdldEp1bmN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gT2JqZWN0LnZhbHVlcyhzdGF0ZS5yZWNvcmRzLm5vZGVzKS5maWx0ZXIoaXNBcmNoaXRlY3R1cmVKdW5jdGlvbiksIFwiZ2V0SnVuY3Rpb25zXCIpO1xudmFyIGdldE5vZGVzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBPYmplY3QudmFsdWVzKHN0YXRlLnJlY29yZHMubm9kZXMpLCBcImdldE5vZGVzXCIpO1xudmFyIGdldE5vZGUgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpZCkgPT4gc3RhdGUucmVjb3Jkcy5ub2Rlc1tpZF0sIFwiZ2V0Tm9kZVwiKTtcbnZhciBhZGRHcm91cCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24oeyBpZCwgaWNvbiwgaW46IHBhcmVudCwgdGl0bGUgfSkge1xuICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXSAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBncm91cCBpZCBbJHtpZH1dIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgJHtzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdfWBcbiAgICApO1xuICB9XG4gIGlmIChwYXJlbnQgIT09IHZvaWQgMCkge1xuICAgIGlmIChpZCA9PT0gcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBncm91cCBbJHtpZH1dIGNhbm5vdCBiZSBwbGFjZWQgd2l0aGluIGl0c2VsZmApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW3BhcmVudF0gPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlIGdyb3VwIFske2lkfV0ncyBwYXJlbnQgZG9lcyBub3QgZXhpc3QuIFBsZWFzZSBtYWtlIHN1cmUgdGhlIHBhcmVudCBpcyBjcmVhdGVkIGJlZm9yZSB0aGlzIGdyb3VwYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1twYXJlbnRdID09PSBcIm5vZGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZ3JvdXAgWyR7aWR9XSdzIHBhcmVudCBpcyBub3QgYSBncm91cGApO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdID0gXCJncm91cFwiO1xuICBzdGF0ZS5yZWNvcmRzLmdyb3Vwc1tpZF0gPSB7XG4gICAgaWQsXG4gICAgaWNvbixcbiAgICB0aXRsZSxcbiAgICBpbjogcGFyZW50XG4gIH07XG59LCBcImFkZEdyb3VwXCIpO1xudmFyIGdldEdyb3VwcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhzdGF0ZS5yZWNvcmRzLmdyb3Vwcyk7XG59LCBcImdldEdyb3Vwc1wiKTtcbnZhciBhZGRFZGdlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih7XG4gIGxoc0lkLFxuICByaHNJZCxcbiAgbGhzRGlyLFxuICByaHNEaXIsXG4gIGxoc0ludG8sXG4gIHJoc0ludG8sXG4gIGxoc0dyb3VwLFxuICByaHNHcm91cCxcbiAgdGl0bGVcbn0pIHtcbiAgaWYgKCFpc0FyY2hpdGVjdHVyZURpcmVjdGlvbihsaHNEaXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEludmFsaWQgZGlyZWN0aW9uIGdpdmVuIGZvciBsZWZ0IGhhbmQgc2lkZSBvZiBlZGdlICR7bGhzSWR9LS0ke3Joc0lkfS4gRXhwZWN0ZWQgKEwsUixULEIpIGdvdCAke2xoc0Rpcn1gXG4gICAgKTtcbiAgfVxuICBpZiAoIWlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uKHJoc0RpcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkaXJlY3Rpb24gZ2l2ZW4gZm9yIHJpZ2h0IGhhbmQgc2lkZSBvZiBlZGdlICR7bGhzSWR9LS0ke3Joc0lkfS4gRXhwZWN0ZWQgKEwsUixULEIpIGdvdCAke3Joc0Rpcn1gXG4gICAgKTtcbiAgfVxuICBpZiAoc3RhdGUucmVjb3Jkcy5ub2Rlc1tsaHNJZF0gPT09IHZvaWQgMCAmJiBzdGF0ZS5yZWNvcmRzLmdyb3Vwc1tsaHNJZF0gPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgbGVmdC1oYW5kIGlkIFske2xoc0lkfV0gZG9lcyBub3QgeWV0IGV4aXN0LiBQbGVhc2UgY3JlYXRlIHRoZSBzZXJ2aWNlL2dyb3VwIGJlZm9yZSBkZWNsYXJpbmcgYW4gZWRnZSB0byBpdC5gXG4gICAgKTtcbiAgfVxuICBpZiAoc3RhdGUucmVjb3Jkcy5ub2Rlc1tyaHNJZF0gPT09IHZvaWQgMCAmJiBzdGF0ZS5yZWNvcmRzLmdyb3Vwc1tsaHNJZF0gPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgcmlnaHQtaGFuZCBpZCBbJHtyaHNJZH1dIGRvZXMgbm90IHlldCBleGlzdC4gUGxlYXNlIGNyZWF0ZSB0aGUgc2VydmljZS9ncm91cCBiZWZvcmUgZGVjbGFyaW5nIGFuIGVkZ2UgdG8gaXQuYFxuICAgICk7XG4gIH1cbiAgY29uc3QgbGhzR3JvdXBJZCA9IHN0YXRlLnJlY29yZHMubm9kZXNbbGhzSWRdLmluO1xuICBjb25zdCByaHNHcm91cElkID0gc3RhdGUucmVjb3Jkcy5ub2Rlc1tyaHNJZF0uaW47XG4gIGlmIChsaHNHcm91cCAmJiBsaHNHcm91cElkICYmIHJoc0dyb3VwSWQgJiYgbGhzR3JvdXBJZCA9PSByaHNHcm91cElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBsZWZ0LWhhbmQgaWQgWyR7bGhzSWR9XSBpcyBtb2RpZmllZCB0byB0cmF2ZXJzZSB0aGUgZ3JvdXAgYm91bmRhcnksIGJ1dCB0aGUgZWRnZSBkb2VzIG5vdCBwYXNzIHRocm91Z2ggdHdvIGdyb3Vwcy5gXG4gICAgKTtcbiAgfVxuICBpZiAocmhzR3JvdXAgJiYgbGhzR3JvdXBJZCAmJiByaHNHcm91cElkICYmIGxoc0dyb3VwSWQgPT0gcmhzR3JvdXBJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgcmlnaHQtaGFuZCBpZCBbJHtyaHNJZH1dIGlzIG1vZGlmaWVkIHRvIHRyYXZlcnNlIHRoZSBncm91cCBib3VuZGFyeSwgYnV0IHRoZSBlZGdlIGRvZXMgbm90IHBhc3MgdGhyb3VnaCB0d28gZ3JvdXBzLmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGVkZ2UgPSB7XG4gICAgbGhzSWQsXG4gICAgbGhzRGlyLFxuICAgIGxoc0ludG8sXG4gICAgbGhzR3JvdXAsXG4gICAgcmhzSWQsXG4gICAgcmhzRGlyLFxuICAgIHJoc0ludG8sXG4gICAgcmhzR3JvdXAsXG4gICAgdGl0bGVcbiAgfTtcbiAgc3RhdGUucmVjb3Jkcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICBpZiAoc3RhdGUucmVjb3Jkcy5ub2Rlc1tsaHNJZF0gJiYgc3RhdGUucmVjb3Jkcy5ub2Rlc1tyaHNJZF0pIHtcbiAgICBzdGF0ZS5yZWNvcmRzLm5vZGVzW2xoc0lkXS5lZGdlcy5wdXNoKHN0YXRlLnJlY29yZHMuZWRnZXNbc3RhdGUucmVjb3Jkcy5lZGdlcy5sZW5ndGggLSAxXSk7XG4gICAgc3RhdGUucmVjb3Jkcy5ub2Rlc1tyaHNJZF0uZWRnZXMucHVzaChzdGF0ZS5yZWNvcmRzLmVkZ2VzW3N0YXRlLnJlY29yZHMuZWRnZXMubGVuZ3RoIC0gMV0pO1xuICB9XG59LCBcImFkZEVkZ2VcIik7XG52YXIgZ2V0RWRnZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHN0YXRlLnJlY29yZHMuZWRnZXMsIFwiZ2V0RWRnZXNcIik7XG52YXIgZ2V0RGF0YVN0cnVjdHVyZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IHtcbiAgaWYgKHN0YXRlLnJlY29yZHMuZGF0YVN0cnVjdHVyZXMgPT09IHZvaWQgMCkge1xuICAgIGNvbnN0IGFkakxpc3QgPSBPYmplY3QuZW50cmllcyhzdGF0ZS5yZWNvcmRzLm5vZGVzKS5yZWR1Y2UoKHByZXZPdXRlciwgW2lkLCBzZXJ2aWNlXSkgPT4ge1xuICAgICAgcHJldk91dGVyW2lkXSA9IHNlcnZpY2UuZWRnZXMucmVkdWNlKChwcmV2SW5uZXIsIGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UubGhzSWQgPT09IGlkKSB7XG4gICAgICAgICAgY29uc3QgcGFpciA9IGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIoZWRnZS5saHNEaXIsIGVkZ2UucmhzRGlyKTtcbiAgICAgICAgICBpZiAocGFpcikge1xuICAgICAgICAgICAgcHJldklubmVyW3BhaXJdID0gZWRnZS5yaHNJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFpciA9IGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIoZWRnZS5yaHNEaXIsIGVkZ2UubGhzRGlyKTtcbiAgICAgICAgICBpZiAocGFpcikge1xuICAgICAgICAgICAgcHJldklubmVyW3BhaXJdID0gZWRnZS5saHNJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZJbm5lcjtcbiAgICAgIH0sIHt9KTtcbiAgICAgIHJldHVybiBwcmV2T3V0ZXI7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGZpcnN0SWQgPSBPYmplY3Qua2V5cyhhZGpMaXN0KVswXTtcbiAgICBjb25zdCB2aXNpdGVkID0geyBbZmlyc3RJZF06IDEgfTtcbiAgICBjb25zdCBub3RWaXNpdGVkID0gT2JqZWN0LmtleXMoYWRqTGlzdCkucmVkdWNlKFxuICAgICAgKHByZXYsIGlkKSA9PiBpZCA9PT0gZmlyc3RJZCA/IHByZXYgOiB7IC4uLnByZXYsIFtpZF06IDEgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBjb25zdCBCRlMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzdGFydGluZ0lkKSA9PiB7XG4gICAgICBjb25zdCBzcGF0aWFsTWFwID0geyBbc3RhcnRpbmdJZF06IFswLCAwXSB9O1xuICAgICAgY29uc3QgcXVldWUgPSBbc3RhcnRpbmdJZF07XG4gICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBpZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIHZpc2l0ZWRbaWRdID0gMTtcbiAgICAgICAgICBkZWxldGUgbm90VmlzaXRlZFtpZF07XG4gICAgICAgICAgY29uc3QgYWRqID0gYWRqTGlzdFtpZF07XG4gICAgICAgICAgY29uc3QgW3Bvc1gsIHBvc1ldID0gc3BhdGlhbE1hcFtpZF07XG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoYWRqKS5mb3JFYWNoKChbZGlyLCByaHNJZF0pID0+IHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZFtyaHNJZF0pIHtcbiAgICAgICAgICAgICAgc3BhdGlhbE1hcFtyaHNJZF0gPSBzaGlmdFBvc2l0aW9uQnlBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyKFxuICAgICAgICAgICAgICAgIFtwb3NYLCBwb3NZXSxcbiAgICAgICAgICAgICAgICBkaXJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcXVldWUucHVzaChyaHNJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGF0aWFsTWFwO1xuICAgIH0sIFwiQkZTXCIpO1xuICAgIGNvbnN0IHNwYXRpYWxNYXBzID0gW0JGUyhmaXJzdElkKV07XG4gICAgd2hpbGUgKE9iamVjdC5rZXlzKG5vdFZpc2l0ZWQpLmxlbmd0aCA+IDApIHtcbiAgICAgIHNwYXRpYWxNYXBzLnB1c2goQkZTKE9iamVjdC5rZXlzKG5vdFZpc2l0ZWQpWzBdKSk7XG4gICAgfVxuICAgIHN0YXRlLnJlY29yZHMuZGF0YVN0cnVjdHVyZXMgPSB7XG4gICAgICBhZGpMaXN0LFxuICAgICAgc3BhdGlhbE1hcHNcbiAgICB9O1xuICB9XG4gIHJldHVybiBzdGF0ZS5yZWNvcmRzLmRhdGFTdHJ1Y3R1cmVzO1xufSwgXCJnZXREYXRhU3RydWN0dXJlc1wiKTtcbnZhciBzZXRFbGVtZW50Rm9ySWQgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChpZCwgZWxlbWVudCkgPT4ge1xuICBzdGF0ZS5yZWNvcmRzLmVsZW1lbnRzW2lkXSA9IGVsZW1lbnQ7XG59LCBcInNldEVsZW1lbnRGb3JJZFwiKTtcbnZhciBnZXRFbGVtZW50QnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGlkKSA9PiBzdGF0ZS5yZWNvcmRzLmVsZW1lbnRzW2lkXSwgXCJnZXRFbGVtZW50QnlJZFwiKTtcbnZhciBkYiA9IHtcbiAgY2xlYXI6IGNsZWFyMixcbiAgc2V0RGlhZ3JhbVRpdGxlLFxuICBnZXREaWFncmFtVGl0bGUsXG4gIHNldEFjY1RpdGxlLFxuICBnZXRBY2NUaXRsZSxcbiAgc2V0QWNjRGVzY3JpcHRpb24sXG4gIGdldEFjY0Rlc2NyaXB0aW9uLFxuICBhZGRTZXJ2aWNlLFxuICBnZXRTZXJ2aWNlcyxcbiAgYWRkSnVuY3Rpb24sXG4gIGdldEp1bmN0aW9ucyxcbiAgZ2V0Tm9kZXMsXG4gIGdldE5vZGUsXG4gIGFkZEdyb3VwLFxuICBnZXRHcm91cHMsXG4gIGFkZEVkZ2UsXG4gIGdldEVkZ2VzLFxuICBzZXRFbGVtZW50Rm9ySWQsXG4gIGdldEVsZW1lbnRCeUlkLFxuICBnZXREYXRhU3RydWN0dXJlc1xufTtcbmZ1bmN0aW9uIGdldENvbmZpZ0ZpZWxkKGZpZWxkKSB7XG4gIGNvbnN0IGFyY2ggPSBnZXRDb25maWcoKS5hcmNoaXRlY3R1cmU7XG4gIGlmIChhcmNoPy5bZmllbGRdKSB7XG4gICAgcmV0dXJuIGFyY2hbZmllbGRdO1xuICB9XG4gIHJldHVybiBERUZBVUxUX0FSQ0hJVEVDVFVSRV9DT05GSUdbZmllbGRdO1xufVxuX19uYW1lKGdldENvbmZpZ0ZpZWxkLCBcImdldENvbmZpZ0ZpZWxkXCIpO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVBhcnNlci50c1xudmFyIHBvcHVsYXRlRGIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChhc3QsIGRiMikgPT4ge1xuICBwb3B1bGF0ZUNvbW1vbkRiKGFzdCwgZGIyKTtcbiAgYXN0Lmdyb3Vwcy5tYXAoZGIyLmFkZEdyb3VwKTtcbiAgYXN0LnNlcnZpY2VzLm1hcCgoc2VydmljZSkgPT4gZGIyLmFkZFNlcnZpY2UoeyAuLi5zZXJ2aWNlLCB0eXBlOiBcInNlcnZpY2VcIiB9KSk7XG4gIGFzdC5qdW5jdGlvbnMubWFwKChzZXJ2aWNlKSA9PiBkYjIuYWRkSnVuY3Rpb24oeyAuLi5zZXJ2aWNlLCB0eXBlOiBcImp1bmN0aW9uXCIgfSkpO1xuICBhc3QuZWRnZXMubWFwKGRiMi5hZGRFZGdlKTtcbn0sIFwicG9wdWxhdGVEYlwiKTtcbnZhciBwYXJzZXIgPSB7XG4gIHBhcnNlOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IGFzdCA9IGF3YWl0IHBhcnNlKFwiYXJjaGl0ZWN0dXJlXCIsIGlucHV0KTtcbiAgICBsb2cuZGVidWcoYXN0KTtcbiAgICBwb3B1bGF0ZURiKGFzdCwgZGIpO1xuICB9LCBcInBhcnNlXCIpXG59O1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVN0eWxlcy50c1xudmFyIGdldFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9wdGlvbnMpID0+IGBcbiAgLmVkZ2Uge1xuICAgIHN0cm9rZS13aWR0aDogJHtvcHRpb25zLmFyY2hFZGdlV2lkdGh9O1xuICAgIHN0cm9rZTogJHtvcHRpb25zLmFyY2hFZGdlQ29sb3J9O1xuICAgIGZpbGw6IG5vbmU7XG4gIH1cblxuICAuYXJyb3cge1xuICAgIGZpbGw6ICR7b3B0aW9ucy5hcmNoRWRnZUFycm93Q29sb3J9O1xuICB9XG5cbiAgLm5vZGUtYmtnIHtcbiAgICBmaWxsOiBub25lO1xuICAgIHN0cm9rZTogJHtvcHRpb25zLmFyY2hHcm91cEJvcmRlckNvbG9yfTtcbiAgICBzdHJva2Utd2lkdGg6ICR7b3B0aW9ucy5hcmNoR3JvdXBCb3JkZXJXaWR0aH07XG4gICAgc3Ryb2tlLWRhc2hhcnJheTogODtcbiAgfVxuICAubm9kZS1pY29uLXRleHQge1xuICAgIGRpc3BsYXk6IGZsZXg7IFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgXG4gIC5ub2RlLWljb24tdGV4dCA+IGRpdiB7XG4gICAgY29sb3I6ICNmZmY7XG4gICAgbWFyZ2luOiAxcHg7XG4gICAgaGVpZ2h0OiBmaXQtY29udGVudDtcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xuICB9XG5gLCBcImdldFN0eWxlc1wiKTtcbnZhciBhcmNoaXRlY3R1cmVTdHlsZXNfZGVmYXVsdCA9IGdldFN0eWxlcztcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVSZW5kZXJlci50c1xuaW1wb3J0IGN5dG9zY2FwZSBmcm9tIFwiY3l0b3NjYXBlXCI7XG5pbXBvcnQgZmNvc2UgZnJvbSBcImN5dG9zY2FwZS1mY29zZVwiO1xuaW1wb3J0IHsgc2VsZWN0IH0gZnJvbSBcImQzXCI7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlSWNvbnMudHNcbnZhciB3cmFwSWNvbiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGljb24pID0+IHtcbiAgcmV0dXJuIGA8Zz48cmVjdCB3aWR0aD1cIjgwXCIgaGVpZ2h0PVwiODBcIiBzdHlsZT1cImZpbGw6ICMwODdlYmY7IHN0cm9rZS13aWR0aDogMHB4O1wiLz4ke2ljb259PC9nPmA7XG59LCBcIndyYXBJY29uXCIpO1xudmFyIGFyY2hpdGVjdHVyZUljb25zID0ge1xuICBwcmVmaXg6IFwibWVybWFpZC1hcmNoaXRlY3R1cmVcIixcbiAgaGVpZ2h0OiA4MCxcbiAgd2lkdGg6IDgwLFxuICBpY29uczoge1xuICAgIGRhdGFiYXNlOiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcbiAgICAgICAgJzxwYXRoIGlkPVwiYlwiIGRhdGEtbmFtZT1cIjRcIiBkPVwibTIwLDU3Ljg2YzAsMy45NCw4Ljk1LDcuMTQsMjAsNy4xNHMyMC0zLjIsMjAtNy4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48cGF0aCBpZD1cImNcIiBkYXRhLW5hbWU9XCIzXCIgZD1cIm0yMCw0NS45NWMwLDMuOTQsOC45NSw3LjE0LDIwLDcuMTRzMjAtMy4yLDIwLTcuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PHBhdGggaWQ9XCJkXCIgZGF0YS1uYW1lPVwiMlwiIGQ9XCJtMjAsMzQuMDVjMCwzLjk0LDguOTUsNy4xNCwyMCw3LjE0czIwLTMuMiwyMC03LjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGlkPVwiZVwiIGRhdGEtbmFtZT1cIjFcIiBjeD1cIjQwXCIgY3k9XCIyMi4xNFwiIHJ4PVwiMjBcIiByeT1cIjcuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIyMFwiIHkxPVwiNTcuODZcIiB4Mj1cIjIwXCIgeTI9XCIyMi4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjYwXCIgeTE9XCI1Ny44NlwiIHgyPVwiNjBcIiB5Mj1cIjIyLjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPidcbiAgICAgIClcbiAgICB9LFxuICAgIHNlcnZlcjoge1xuICAgICAgYm9keTogd3JhcEljb24oXG4gICAgICAgICc8cmVjdCB4PVwiMTcuNVwiIHk9XCIxNy41XCIgd2lkdGg9XCI0NVwiIGhlaWdodD1cIjQ1XCIgcng9XCIyXCIgcnk9XCIyXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMTcuNVwiIHkxPVwiMzIuNVwiIHgyPVwiNjIuNVwiIHkyPVwiMzIuNVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjE3LjVcIiB5MT1cIjQ3LjVcIiB4Mj1cIjYyLjVcIiB5Mj1cIjQ3LjVcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGc+PHBhdGggZD1cIm01Ni4yNSwyNWMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZS13aWR0aDogMHB4O1wiLz48cGF0aCBkPVwibTU2LjI1LDI1YzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz48Zz48cGF0aCBkPVwibTU2LjI1LDQwYzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlLXdpZHRoOiAwcHg7XCIvPjxwYXRoIGQ9XCJtNTYuMjUsNDBjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPjxnPjxwYXRoIGQ9XCJtNTYuMjUsNTVjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2Utd2lkdGg6IDBweDtcIi8+PHBhdGggZD1cIm01Ni4yNSw1NWMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+PGc+PGNpcmNsZSBjeD1cIjMyLjVcIiBjeT1cIjI1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyNy41XCIgY3k9XCIyNVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjIuNVwiIGN5PVwiMjVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPjxnPjxjaXJjbGUgY3g9XCIzMi41XCIgY3k9XCI0MFwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjcuNVwiIGN5PVwiNDBcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjIyLjVcIiBjeT1cIjQwXCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz48Zz48Y2lyY2xlIGN4PVwiMzIuNVwiIGN5PVwiNTVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjI3LjVcIiBjeT1cIjU1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyMi41XCIgY3k9XCI1NVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+J1xuICAgICAgKVxuICAgIH0sXG4gICAgZGlzazoge1xuICAgICAgYm9keTogd3JhcEljb24oXG4gICAgICAgICc8cmVjdCB4PVwiMjBcIiB5PVwiMTVcIiB3aWR0aD1cIjQwXCIgaGVpZ2h0PVwiNTBcIiByeD1cIjFcIiByeT1cIjFcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCIyNFwiIGN5PVwiMTkuMTdcIiByeD1cIi44XCIgcnk9XCIuODNcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCI1NlwiIGN5PVwiMTkuMTdcIiByeD1cIi44XCIgcnk9XCIuODNcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCIyNFwiIGN5PVwiNjAuODNcIiByeD1cIi44XCIgcnk9XCIuODNcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCI1NlwiIGN5PVwiNjAuODNcIiByeD1cIi44XCIgcnk9XCIuODNcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgY3g9XCI0MFwiIGN5PVwiMzMuNzVcIiByeD1cIjE0XCIgcnk9XCIxNC41OFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjQwXCIgY3k9XCIzMy43NVwiIHJ4PVwiNFwiIHJ5PVwiNC4xN1wiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48cGF0aCBkPVwibTM3LjUxLDQyLjUybC00LjgzLDEzLjIyYy0uMjYuNzEtMS4xLDEuMDItMS43Ni42NGwtNC4xOC0yLjQyYy0uNjYtLjM4LS44MS0xLjI2LS4zMy0xLjg0bDkuMDEtMTAuOGMuODgtMS4wNSwyLjU2LS4wOCwyLjA5LDEuMlpcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZS13aWR0aDogMHB4O1wiLz4nXG4gICAgICApXG4gICAgfSxcbiAgICBpbnRlcm5ldDoge1xuICAgICAgYm9keTogd3JhcEljb24oXG4gICAgICAgICc8Y2lyY2xlIGN4PVwiNDBcIiBjeT1cIjQwXCIgcj1cIjIyLjVcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCI0MFwiIHkxPVwiMTcuNVwiIHgyPVwiNDBcIiB5Mj1cIjYyLjVcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIxNy41XCIgeTE9XCI0MFwiIHgyPVwiNjIuNVwiIHkyPVwiNDBcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PHBhdGggZD1cIm0zOS45OSwxNy41MWMtMTUuMjgsMTEuMS0xNS4yOCwzMy44OCwwLDQ0Ljk4XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxwYXRoIGQ9XCJtNDAuMDEsMTcuNTFjMTUuMjgsMTEuMSwxNS4yOCwzMy44OCwwLDQ0Ljk4XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMTkuNzVcIiB5MT1cIjMwLjFcIiB4Mj1cIjYwLjI1XCIgeTI9XCIzMC4xXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMTkuNzVcIiB5MT1cIjQ5LjlcIiB4Mj1cIjYwLjI1XCIgeTI9XCI0OS45XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPidcbiAgICAgIClcbiAgICB9LFxuICAgIGNsb3VkOiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcbiAgICAgICAgJzxwYXRoIGQ9XCJtNjUsNDcuNWMwLDIuNzYtMi4yNCw1LTUsNUgyMGMtMi43NiwwLTUtMi4yNC01LTUsMC0xLjg3LDEuMDMtMy41MSwyLjU2LTQuMzYtLjA0LS4yMS0uMDYtLjQyLS4wNi0uNjQsMC0yLjYsMi40OC00Ljc0LDUuNjUtNC45NywxLjY1LTQuNTEsNi4zNC03Ljc2LDExLjg1LTcuNzYuODYsMCwxLjY5LjA4LDIuNS4yMywyLjA5LTEuNTcsNC42OS0yLjUsNy41LTIuNSw2LjEsMCwxMS4xOSw0LjM4LDEyLjI4LDEwLjE3LDIuMTQuNTYsMy43MiwyLjUxLDMuNzIsNC44MywwLC4wMywwLC4wNy0uMDEuMSwyLjI5LjQ2LDQuMDEsMi40OCw0LjAxLDQuOVpcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+J1xuICAgICAgKVxuICAgIH0sXG4gICAgdW5rbm93bjogdW5rbm93bkljb24sXG4gICAgYmxhbms6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFwiXCIpXG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL3N2Z0RyYXcudHNcbnZhciBkcmF3RWRnZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jIGZ1bmN0aW9uKGVkZ2VzRWwsIGN5KSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBnZXRDb25maWdGaWVsZChcInBhZGRpbmdcIik7XG4gIGNvbnN0IGljb25TaXplID0gZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKTtcbiAgY29uc3QgaGFsZkljb25TaXplID0gaWNvblNpemUgLyAyO1xuICBjb25zdCBhcnJvd1NpemUgPSBpY29uU2l6ZSAvIDY7XG4gIGNvbnN0IGhhbGZBcnJvd1NpemUgPSBhcnJvd1NpemUgLyAyO1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBjeS5lZGdlcygpLm1hcChhc3luYyAoZWRnZSkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHNvdXJjZURpcixcbiAgICAgICAgc291cmNlQXJyb3csXG4gICAgICAgIHNvdXJjZUdyb3VwLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHRhcmdldERpcixcbiAgICAgICAgdGFyZ2V0QXJyb3csXG4gICAgICAgIHRhcmdldEdyb3VwLFxuICAgICAgICBsYWJlbFxuICAgICAgfSA9IGVkZ2VEYXRhKGVkZ2UpO1xuICAgICAgbGV0IHsgeDogc3RhcnRYLCB5OiBzdGFydFkgfSA9IGVkZ2VbMF0uc291cmNlRW5kcG9pbnQoKTtcbiAgICAgIGNvbnN0IHsgeDogbWlkWCwgeTogbWlkWSB9ID0gZWRnZVswXS5taWRwb2ludCgpO1xuICAgICAgbGV0IHsgeDogZW5kWCwgeTogZW5kWSB9ID0gZWRnZVswXS50YXJnZXRFbmRwb2ludCgpO1xuICAgICAgY29uc3QgZ3JvdXBFZGdlU2hpZnQgPSBwYWRkaW5nICsgNDtcbiAgICAgIGlmIChzb3VyY2VHcm91cCkge1xuICAgICAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHNvdXJjZURpcikpIHtcbiAgICAgICAgICBzdGFydFggKz0gc291cmNlRGlyID09PSBcIkxcIiA/IC1ncm91cEVkZ2VTaGlmdCA6IGdyb3VwRWRnZVNoaWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0WSArPSBzb3VyY2VEaXIgPT09IFwiVFwiID8gLWdyb3VwRWRnZVNoaWZ0IDogZ3JvdXBFZGdlU2hpZnQgKyAxODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRhcmdldEdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgodGFyZ2V0RGlyKSkge1xuICAgICAgICAgIGVuZFggKz0gdGFyZ2V0RGlyID09PSBcIkxcIiA/IC1ncm91cEVkZ2VTaGlmdCA6IGdyb3VwRWRnZVNoaWZ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZFkgKz0gdGFyZ2V0RGlyID09PSBcIlRcIiA/IC1ncm91cEVkZ2VTaGlmdCA6IGdyb3VwRWRnZVNoaWZ0ICsgMTg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlR3JvdXAgJiYgZGIuZ2V0Tm9kZShzb3VyY2UpPy50eXBlID09PSBcImp1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChzb3VyY2VEaXIpKSB7XG4gICAgICAgICAgc3RhcnRYICs9IHNvdXJjZURpciA9PT0gXCJMXCIgPyBoYWxmSWNvblNpemUgOiAtaGFsZkljb25TaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXJ0WSArPSBzb3VyY2VEaXIgPT09IFwiVFwiID8gaGFsZkljb25TaXplIDogLWhhbGZJY29uU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0YXJnZXRHcm91cCAmJiBkYi5nZXROb2RlKHRhcmdldCk/LnR5cGUgPT09IFwianVuY3Rpb25cIikge1xuICAgICAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHRhcmdldERpcikpIHtcbiAgICAgICAgICBlbmRYICs9IHRhcmdldERpciA9PT0gXCJMXCIgPyBoYWxmSWNvblNpemUgOiAtaGFsZkljb25TaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZFkgKz0gdGFyZ2V0RGlyID09PSBcIlRcIiA/IGhhbGZJY29uU2l6ZSA6IC1oYWxmSWNvblNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlZGdlWzBdLl9wcml2YXRlLnJzY3JhdGNoKSB7XG4gICAgICAgIGNvbnN0IGcgPSBlZGdlc0VsLmluc2VydChcImdcIik7XG4gICAgICAgIGcuaW5zZXJ0KFwicGF0aFwiKS5hdHRyKFwiZFwiLCBgTSAke3N0YXJ0WH0sJHtzdGFydFl9IEwgJHttaWRYfSwke21pZFl9IEwke2VuZFh9LCR7ZW5kWX0gYCkuYXR0cihcImNsYXNzXCIsIFwiZWRnZVwiKTtcbiAgICAgICAgaWYgKHNvdXJjZUFycm93KSB7XG4gICAgICAgICAgY29uc3QgeFNoaWZ0ID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHNvdXJjZURpcikgPyBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1NoaWZ0W3NvdXJjZURpcl0oc3RhcnRYLCBhcnJvd1NpemUpIDogc3RhcnRYIC0gaGFsZkFycm93U2l6ZTtcbiAgICAgICAgICBjb25zdCB5U2hpZnQgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkoc291cmNlRGlyKSA/IEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93U2hpZnRbc291cmNlRGlyXShzdGFydFksIGFycm93U2l6ZSkgOiBzdGFydFkgLSBoYWxmQXJyb3dTaXplO1xuICAgICAgICAgIGcuaW5zZXJ0KFwicG9seWdvblwiKS5hdHRyKFwicG9pbnRzXCIsIEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93W3NvdXJjZURpcl0oYXJyb3dTaXplKSkuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eFNoaWZ0fSwke3lTaGlmdH0pYCkuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldEFycm93KSB7XG4gICAgICAgICAgY29uc3QgeFNoaWZ0ID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHRhcmdldERpcikgPyBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1NoaWZ0W3RhcmdldERpcl0oZW5kWCwgYXJyb3dTaXplKSA6IGVuZFggLSBoYWxmQXJyb3dTaXplO1xuICAgICAgICAgIGNvbnN0IHlTaGlmdCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWSh0YXJnZXREaXIpID8gQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dTaGlmdFt0YXJnZXREaXJdKGVuZFksIGFycm93U2l6ZSkgOiBlbmRZIC0gaGFsZkFycm93U2l6ZTtcbiAgICAgICAgICBnLmluc2VydChcInBvbHlnb25cIikuYXR0cihcInBvaW50c1wiLCBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1t0YXJnZXREaXJdKGFycm93U2l6ZSkpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3hTaGlmdH0sJHt5U2hpZnR9KWApLmF0dHIoXCJjbGFzc1wiLCBcImFycm93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSAhaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWShzb3VyY2VEaXIsIHRhcmdldERpcikgPyBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoc291cmNlRGlyKSA/IFwiWFwiIDogXCJZXCIgOiBcIlhZXCI7XG4gICAgICAgICAgbGV0IHdpZHRoID0gMDtcbiAgICAgICAgICBpZiAoYXhpcyA9PT0gXCJYXCIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5hYnMoc3RhcnRYIC0gZW5kWCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSBcIllcIikge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLmFicyhzdGFydFkgLSBlbmRZKSAvIDEuNTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLmFicyhzdGFydFggLSBlbmRYKSAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRleHRFbGVtID0gZy5hcHBlbmQoXCJnXCIpO1xuICAgICAgICAgIGF3YWl0IGNyZWF0ZVRleHQoXG4gICAgICAgICAgICB0ZXh0RWxlbSxcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB1c2VIdG1sTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgIGNsYXNzZXM6IFwiYXJjaGl0ZWN0dXJlLXNlcnZpY2UtbGFiZWxcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldENvbmZpZygpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFwiZHlcIiwgXCIxZW1cIikuYXR0cihcImFsaWdubWVudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xuICAgICAgICAgIGlmIChheGlzID09PSBcIlhcIikge1xuICAgICAgICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1pZFggKyBcIiwgXCIgKyBtaWRZICsgXCIpXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gXCJZXCIpIHtcbiAgICAgICAgICAgIHRleHRFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtaWRYICsgXCIsIFwiICsgbWlkWSArIFwiKSByb3RhdGUoLTkwKVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09IFwiWFlcIikge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIoc291cmNlRGlyLCB0YXJnZXREaXIpO1xuICAgICAgICAgICAgaWYgKHBhaXIgJiYgaXNBcmNoaXRlY3R1cmVQYWlyWFkocGFpcikpIHtcbiAgICAgICAgICAgICAgY29uc3QgYmJveE9yaWcgPSB0ZXh0RWxlbS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblhZRmFjdG9ycyhwYWlyKTtcbiAgICAgICAgICAgICAgdGV4dEVsZW0uYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwiYXV0b1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsIGByb3RhdGUoJHstMSAqIHggKiB5ICogNDV9KWApO1xuICAgICAgICAgICAgICBjb25zdCBiYm94TmV3ID0gdGV4dEVsZW0ubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFxuICAgICAgICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSgke21pZFh9LCAke21pZFkgLSBiYm94T3JpZy5oZWlnaHQgLyAyfSlcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGUoJHt4ICogYmJveE5ldy53aWR0aCAvIDJ9LCAke3kgKiBiYm94TmV3LmhlaWdodCAvIDJ9KVxuICAgICAgICAgICAgICAgIHJvdGF0ZSgkey0xICogeCAqIHkgKiA0NX0sIDAsICR7YmJveE9yaWcuaGVpZ2h0IC8gMn0pXG4gICAgICAgICAgICAgIGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufSwgXCJkcmF3RWRnZXNcIik7XG52YXIgZHJhd0dyb3VwcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24oZ3JvdXBzRWwsIGN5KSB7XG4gIGNvbnN0IHBhZGRpbmcgPSBnZXRDb25maWdGaWVsZChcInBhZGRpbmdcIik7XG4gIGNvbnN0IGdyb3VwSWNvblNpemUgPSBwYWRkaW5nICogMC43NTtcbiAgY29uc3QgZm9udFNpemUgPSBnZXRDb25maWdGaWVsZChcImZvbnRTaXplXCIpO1xuICBjb25zdCBpY29uU2l6ZSA9IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIik7XG4gIGNvbnN0IGhhbGZJY29uU2l6ZSA9IGljb25TaXplIC8gMjtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgY3kubm9kZXMoKS5tYXAoYXN5bmMgKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBub2RlRGF0YShub2RlKTtcbiAgICAgIGlmIChkYXRhLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgICBjb25zdCB7IGgsIHcsIHgxLCB5MSB9ID0gbm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICBncm91cHNFbC5hcHBlbmQoXCJyZWN0XCIpLmF0dHIoXCJ4XCIsIHgxICsgaGFsZkljb25TaXplKS5hdHRyKFwieVwiLCB5MSArIGhhbGZJY29uU2l6ZSkuYXR0cihcIndpZHRoXCIsIHcpLmF0dHIoXCJoZWlnaHRcIiwgaCkuYXR0cihcImNsYXNzXCIsIFwibm9kZS1ia2dcIik7XG4gICAgICAgIGNvbnN0IGdyb3VwTGFiZWxDb250YWluZXIgPSBncm91cHNFbC5hcHBlbmQoXCJnXCIpO1xuICAgICAgICBsZXQgc2hpZnRlZFgxID0geDE7XG4gICAgICAgIGxldCBzaGlmdGVkWTEgPSB5MTtcbiAgICAgICAgaWYgKGRhdGEuaWNvbikge1xuICAgICAgICAgIGNvbnN0IGJrZ0VsZW0gPSBncm91cExhYmVsQ29udGFpbmVyLmFwcGVuZChcImdcIik7XG4gICAgICAgICAgYmtnRWxlbS5odG1sKFxuICAgICAgICAgICAgYDxnPiR7YXdhaXQgZ2V0SWNvblNWRyhkYXRhLmljb24sIHsgaGVpZ2h0OiBncm91cEljb25TaXplLCB3aWR0aDogZ3JvdXBJY29uU2l6ZSwgZmFsbGJhY2tQcmVmaXg6IGFyY2hpdGVjdHVyZUljb25zLnByZWZpeCB9KX08L2c+YFxuICAgICAgICAgICk7XG4gICAgICAgICAgYmtnRWxlbS5hdHRyKFxuICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgIFwidHJhbnNsYXRlKFwiICsgKHNoaWZ0ZWRYMSArIGhhbGZJY29uU2l6ZSArIDEpICsgXCIsIFwiICsgKHNoaWZ0ZWRZMSArIGhhbGZJY29uU2l6ZSArIDEpICsgXCIpXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIHNoaWZ0ZWRYMSArPSBncm91cEljb25TaXplO1xuICAgICAgICAgIHNoaWZ0ZWRZMSArPSBmb250U2l6ZSAvIDIgLSAxIC0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5sYWJlbCkge1xuICAgICAgICAgIGNvbnN0IHRleHRFbGVtID0gZ3JvdXBMYWJlbENvbnRhaW5lci5hcHBlbmQoXCJnXCIpO1xuICAgICAgICAgIGF3YWl0IGNyZWF0ZVRleHQoXG4gICAgICAgICAgICB0ZXh0RWxlbSxcbiAgICAgICAgICAgIGRhdGEubGFiZWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZUh0bWxMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgICB3aWR0aDogdyxcbiAgICAgICAgICAgICAgY2xhc3NlczogXCJhcmNoaXRlY3R1cmUtc2VydmljZS1sYWJlbFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29uZmlnKClcbiAgICAgICAgICApO1xuICAgICAgICAgIHRleHRFbGVtLmF0dHIoXCJkeVwiLCBcIjFlbVwiKS5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcInN0YXJ0XCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xuICAgICAgICAgIHRleHRFbGVtLmF0dHIoXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoc2hpZnRlZFgxICsgaGFsZkljb25TaXplICsgNCkgKyBcIiwgXCIgKyAoc2hpZnRlZFkxICsgaGFsZkljb25TaXplICsgMikgKyBcIilcIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufSwgXCJkcmF3R3JvdXBzXCIpO1xudmFyIGRyYXdTZXJ2aWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24oZGIyLCBlbGVtLCBzZXJ2aWNlcykge1xuICBmb3IgKGNvbnN0IHNlcnZpY2Ugb2Ygc2VydmljZXMpIHtcbiAgICBjb25zdCBzZXJ2aWNlRWxlbSA9IGVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICBjb25zdCBpY29uU2l6ZSA9IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIik7XG4gICAgaWYgKHNlcnZpY2UudGl0bGUpIHtcbiAgICAgIGNvbnN0IHRleHRFbGVtID0gc2VydmljZUVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICAgIGF3YWl0IGNyZWF0ZVRleHQoXG4gICAgICAgIHRleHRFbGVtLFxuICAgICAgICBzZXJ2aWNlLnRpdGxlLFxuICAgICAgICB7XG4gICAgICAgICAgdXNlSHRtbExhYmVsczogZmFsc2UsXG4gICAgICAgICAgd2lkdGg6IGljb25TaXplICogMS41LFxuICAgICAgICAgIGNsYXNzZXM6IFwiYXJjaGl0ZWN0dXJlLXNlcnZpY2UtbGFiZWxcIlxuICAgICAgICB9LFxuICAgICAgICBnZXRDb25maWcoKVxuICAgICAgKTtcbiAgICAgIHRleHRFbGVtLmF0dHIoXCJkeVwiLCBcIjFlbVwiKS5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICB0ZXh0RWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgaWNvblNpemUgLyAyICsgXCIsIFwiICsgaWNvblNpemUgKyBcIilcIik7XG4gICAgfVxuICAgIGNvbnN0IGJrZ0VsZW0gPSBzZXJ2aWNlRWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgIGlmIChzZXJ2aWNlLmljb24pIHtcbiAgICAgIGJrZ0VsZW0uaHRtbChcbiAgICAgICAgYDxnPiR7YXdhaXQgZ2V0SWNvblNWRyhzZXJ2aWNlLmljb24sIHsgaGVpZ2h0OiBpY29uU2l6ZSwgd2lkdGg6IGljb25TaXplLCBmYWxsYmFja1ByZWZpeDogYXJjaGl0ZWN0dXJlSWNvbnMucHJlZml4IH0pfTwvZz5gXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoc2VydmljZS5pY29uVGV4dCkge1xuICAgICAgYmtnRWxlbS5odG1sKFxuICAgICAgICBgPGc+JHthd2FpdCBnZXRJY29uU1ZHKFwiYmxhbmtcIiwgeyBoZWlnaHQ6IGljb25TaXplLCB3aWR0aDogaWNvblNpemUsIGZhbGxiYWNrUHJlZml4OiBhcmNoaXRlY3R1cmVJY29ucy5wcmVmaXggfSl9PC9nPmBcbiAgICAgICk7XG4gICAgICBjb25zdCB0ZXh0RWxlbUNvbnRhaW5lciA9IGJrZ0VsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICAgIGNvbnN0IGZvID0gdGV4dEVsZW1Db250YWluZXIuYXBwZW5kKFwiZm9yZWlnbk9iamVjdFwiKS5hdHRyKFwid2lkdGhcIiwgaWNvblNpemUpLmF0dHIoXCJoZWlnaHRcIiwgaWNvblNpemUpO1xuICAgICAgY29uc3QgZGl2RWxlbSA9IGZvLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWljb24tdGV4dFwiKS5hdHRyKFwic3R5bGVcIiwgYGhlaWdodDogJHtpY29uU2l6ZX1weDtgKS5hcHBlbmQoXCJkaXZcIikuaHRtbChzZXJ2aWNlLmljb25UZXh0KTtcbiAgICAgIGNvbnN0IGZvbnRTaXplID0gcGFyc2VJbnQoXG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdkVsZW0ubm9kZSgpLCBudWxsKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZm9udC1zaXplXCIpLnJlcGxhY2UoL1xcRC9nLCBcIlwiKVxuICAgICAgKSA/PyAxNjtcbiAgICAgIGRpdkVsZW0uYXR0cihcInN0eWxlXCIsIGAtd2Via2l0LWxpbmUtY2xhbXA6ICR7TWF0aC5mbG9vcigoaWNvblNpemUgLSAyKSAvIGZvbnRTaXplKX07YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJrZ0VsZW0uYXBwZW5kKFwicGF0aFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZ1wiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsgc2VydmljZS5pZCkuYXR0cihcbiAgICAgICAgXCJkXCIsXG4gICAgICAgIGBNMCAke2ljb25TaXplfSB2JHstaWNvblNpemV9IHEwLC01IDUsLTUgaCR7aWNvblNpemV9IHE1LDAgNSw1IHYke2ljb25TaXplfSBIMCBaYFxuICAgICAgKTtcbiAgICB9XG4gICAgc2VydmljZUVsZW0uYXR0cihcImNsYXNzXCIsIFwiYXJjaGl0ZWN0dXJlLXNlcnZpY2VcIik7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBzZXJ2aWNlRWxlbS5fZ3JvdXBzWzBdWzBdLmdldEJCb3goKTtcbiAgICBzZXJ2aWNlLndpZHRoID0gd2lkdGg7XG4gICAgc2VydmljZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgZGIyLnNldEVsZW1lbnRGb3JJZChzZXJ2aWNlLmlkLCBzZXJ2aWNlRWxlbSk7XG4gIH1cbiAgcmV0dXJuIDA7XG59LCBcImRyYXdTZXJ2aWNlc1wiKTtcbnZhciBkcmF3SnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihkYjIsIGVsZW0sIGp1bmN0aW9ucykge1xuICBqdW5jdGlvbnMuZm9yRWFjaCgoanVuY3Rpb24pID0+IHtcbiAgICBjb25zdCBqdW5jdGlvbkVsZW0gPSBlbGVtLmFwcGVuZChcImdcIik7XG4gICAgY29uc3QgaWNvblNpemUgPSBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICAgIGNvbnN0IGJrZ0VsZW0gPSBqdW5jdGlvbkVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICBia2dFbGVtLmFwcGVuZChcInJlY3RcIikuYXR0cihcImlkXCIsIFwibm9kZS1cIiArIGp1bmN0aW9uLmlkKS5hdHRyKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKS5hdHRyKFwid2lkdGhcIiwgaWNvblNpemUpLmF0dHIoXCJoZWlnaHRcIiwgaWNvblNpemUpO1xuICAgIGp1bmN0aW9uRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJhcmNoaXRlY3R1cmUtanVuY3Rpb25cIik7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBqdW5jdGlvbkVsZW0uX2dyb3Vwc1swXVswXS5nZXRCQm94KCk7XG4gICAganVuY3Rpb25FbGVtLndpZHRoID0gd2lkdGg7XG4gICAganVuY3Rpb25FbGVtLmhlaWdodCA9IGhlaWdodDtcbiAgICBkYjIuc2V0RWxlbWVudEZvcklkKGp1bmN0aW9uLmlkLCBqdW5jdGlvbkVsZW0pO1xuICB9KTtcbn0sIFwiZHJhd0p1bmN0aW9uc1wiKTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVSZW5kZXJlci50c1xucmVnaXN0ZXJJY29uUGFja3MoW1xuICB7XG4gICAgbmFtZTogYXJjaGl0ZWN0dXJlSWNvbnMucHJlZml4LFxuICAgIGljb25zOiBhcmNoaXRlY3R1cmVJY29uc1xuICB9XG5dKTtcbmN5dG9zY2FwZS51c2UoZmNvc2UpO1xuZnVuY3Rpb24gYWRkU2VydmljZXMoc2VydmljZXMsIGN5KSB7XG4gIHNlcnZpY2VzLmZvckVhY2goKHNlcnZpY2UpID0+IHtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6IFwibm9kZXNcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJzZXJ2aWNlXCIsXG4gICAgICAgIGlkOiBzZXJ2aWNlLmlkLFxuICAgICAgICBpY29uOiBzZXJ2aWNlLmljb24sXG4gICAgICAgIGxhYmVsOiBzZXJ2aWNlLnRpdGxlLFxuICAgICAgICBwYXJlbnQ6IHNlcnZpY2UuaW4sXG4gICAgICAgIHdpZHRoOiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpLFxuICAgICAgICBoZWlnaHQ6IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIilcbiAgICAgIH0sXG4gICAgICBjbGFzc2VzOiBcIm5vZGUtc2VydmljZVwiXG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGFkZFNlcnZpY2VzLCBcImFkZFNlcnZpY2VzXCIpO1xuZnVuY3Rpb24gYWRkSnVuY3Rpb25zKGp1bmN0aW9ucywgY3kpIHtcbiAganVuY3Rpb25zLmZvckVhY2goKGp1bmN0aW9uKSA9PiB7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiBcIm5vZGVzXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwianVuY3Rpb25cIixcbiAgICAgICAgaWQ6IGp1bmN0aW9uLmlkLFxuICAgICAgICBwYXJlbnQ6IGp1bmN0aW9uLmluLFxuICAgICAgICB3aWR0aDogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKSxcbiAgICAgICAgaGVpZ2h0OiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpXG4gICAgICB9LFxuICAgICAgY2xhc3NlczogXCJub2RlLWp1bmN0aW9uXCJcbiAgICB9KTtcbiAgfSk7XG59XG5fX25hbWUoYWRkSnVuY3Rpb25zLCBcImFkZEp1bmN0aW9uc1wiKTtcbmZ1bmN0aW9uIHBvc2l0aW9uTm9kZXMoZGIyLCBjeSkge1xuICBjeS5ub2RlcygpLm1hcCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBub2RlRGF0YShub2RlKTtcbiAgICBpZiAoZGF0YS50eXBlID09PSBcImdyb3VwXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGF0YS54ID0gbm9kZS5wb3NpdGlvbigpLng7XG4gICAgZGF0YS55ID0gbm9kZS5wb3NpdGlvbigpLnk7XG4gICAgY29uc3Qgbm9kZUVsZW0gPSBkYjIuZ2V0RWxlbWVudEJ5SWQoZGF0YS5pZCk7XG4gICAgbm9kZUVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIChkYXRhLnggfHwgMCkgKyBcIixcIiArIChkYXRhLnkgfHwgMCkgKyBcIilcIik7XG4gIH0pO1xufVxuX19uYW1lKHBvc2l0aW9uTm9kZXMsIFwicG9zaXRpb25Ob2Rlc1wiKTtcbmZ1bmN0aW9uIGFkZEdyb3Vwcyhncm91cHMsIGN5KSB7XG4gIGdyb3Vwcy5mb3JFYWNoKChncm91cCkgPT4ge1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogXCJub2Rlc1wiLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiBcImdyb3VwXCIsXG4gICAgICAgIGlkOiBncm91cC5pZCxcbiAgICAgICAgaWNvbjogZ3JvdXAuaWNvbixcbiAgICAgICAgbGFiZWw6IGdyb3VwLnRpdGxlLFxuICAgICAgICBwYXJlbnQ6IGdyb3VwLmluXG4gICAgICB9LFxuICAgICAgY2xhc3NlczogXCJub2RlLWdyb3VwXCJcbiAgICB9KTtcbiAgfSk7XG59XG5fX25hbWUoYWRkR3JvdXBzLCBcImFkZEdyb3Vwc1wiKTtcbmZ1bmN0aW9uIGFkZEVkZ2VzKGVkZ2VzLCBjeSkge1xuICBlZGdlcy5mb3JFYWNoKChwYXJzZWRFZGdlKSA9PiB7XG4gICAgY29uc3QgeyBsaHNJZCwgcmhzSWQsIGxoc0ludG8sIGxoc0dyb3VwLCByaHNJbnRvLCBsaHNEaXIsIHJoc0RpciwgcmhzR3JvdXAsIHRpdGxlIH0gPSBwYXJzZWRFZGdlO1xuICAgIGNvbnN0IGVkZ2VUeXBlID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWShwYXJzZWRFZGdlLmxoc0RpciwgcGFyc2VkRWRnZS5yaHNEaXIpID8gXCJzZWdtZW50c1wiIDogXCJzdHJhaWdodFwiO1xuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICBpZDogYCR7bGhzSWR9LSR7cmhzSWR9YCxcbiAgICAgIGxhYmVsOiB0aXRsZSxcbiAgICAgIHNvdXJjZTogbGhzSWQsXG4gICAgICBzb3VyY2VEaXI6IGxoc0RpcixcbiAgICAgIHNvdXJjZUFycm93OiBsaHNJbnRvLFxuICAgICAgc291cmNlR3JvdXA6IGxoc0dyb3VwLFxuICAgICAgc291cmNlRW5kcG9pbnQ6IGxoc0RpciA9PT0gXCJMXCIgPyBcIjAgNTAlXCIgOiBsaHNEaXIgPT09IFwiUlwiID8gXCIxMDAlIDUwJVwiIDogbGhzRGlyID09PSBcIlRcIiA/IFwiNTAlIDBcIiA6IFwiNTAlIDEwMCVcIixcbiAgICAgIHRhcmdldDogcmhzSWQsXG4gICAgICB0YXJnZXREaXI6IHJoc0RpcixcbiAgICAgIHRhcmdldEFycm93OiByaHNJbnRvLFxuICAgICAgdGFyZ2V0R3JvdXA6IHJoc0dyb3VwLFxuICAgICAgdGFyZ2V0RW5kcG9pbnQ6IHJoc0RpciA9PT0gXCJMXCIgPyBcIjAgNTAlXCIgOiByaHNEaXIgPT09IFwiUlwiID8gXCIxMDAlIDUwJVwiIDogcmhzRGlyID09PSBcIlRcIiA/IFwiNTAlIDBcIiA6IFwiNTAlIDEwMCVcIlxuICAgIH07XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiBcImVkZ2VzXCIsXG4gICAgICBkYXRhOiBlZGdlLFxuICAgICAgY2xhc3NlczogZWRnZVR5cGVcbiAgICB9KTtcbiAgfSk7XG59XG5fX25hbWUoYWRkRWRnZXMsIFwiYWRkRWRnZXNcIik7XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRzKHNwYXRpYWxNYXBzKSB7XG4gIGNvbnN0IGFsaWdubWVudHMgPSBzcGF0aWFsTWFwcy5tYXAoKHNwYXRpYWxNYXApID0+IHtcbiAgICBjb25zdCBob3Jpem9udGFsQWxpZ25tZW50cyA9IHt9O1xuICAgIGNvbnN0IHZlcnRpY2FsQWxpZ25tZW50cyA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKHNwYXRpYWxNYXApLmZvckVhY2goKFtpZCwgW3gsIHldXSkgPT4ge1xuICAgICAgaWYgKCFob3Jpem9udGFsQWxpZ25tZW50c1t5XSkge1xuICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50c1t5XSA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCF2ZXJ0aWNhbEFsaWdubWVudHNbeF0pIHtcbiAgICAgICAgdmVydGljYWxBbGlnbm1lbnRzW3hdID0gW107XG4gICAgICB9XG4gICAgICBob3Jpem9udGFsQWxpZ25tZW50c1t5XS5wdXNoKGlkKTtcbiAgICAgIHZlcnRpY2FsQWxpZ25tZW50c1t4XS5wdXNoKGlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgaG9yaXo6IE9iamVjdC52YWx1ZXMoaG9yaXpvbnRhbEFsaWdubWVudHMpLmZpbHRlcigoYXJyKSA9PiBhcnIubGVuZ3RoID4gMSksXG4gICAgICB2ZXJ0OiBPYmplY3QudmFsdWVzKHZlcnRpY2FsQWxpZ25tZW50cykuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGggPiAxKVxuICAgIH07XG4gIH0pO1xuICBjb25zdCBbaG9yaXpvbnRhbCwgdmVydGljYWxdID0gYWxpZ25tZW50cy5yZWR1Y2UoXG4gICAgKFtwcmV2SG9yaXosIHByZXZWZXJ0XSwgeyBob3JpeiwgdmVydCB9KSA9PiB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbLi4ucHJldkhvcml6LCAuLi5ob3Jpel0sXG4gICAgICAgIFsuLi5wcmV2VmVydCwgLi4udmVydF1cbiAgICAgIF07XG4gICAgfSxcbiAgICBbW10sIFtdXVxuICApO1xuICByZXR1cm4ge1xuICAgIGhvcml6b250YWwsXG4gICAgdmVydGljYWxcbiAgfTtcbn1cbl9fbmFtZShnZXRBbGlnbm1lbnRzLCBcImdldEFsaWdubWVudHNcIik7XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZUNvbnN0cmFpbnRzKHNwYXRpYWxNYXBzKSB7XG4gIGNvbnN0IHJlbGF0aXZlQ29uc3RyYWludHMgPSBbXTtcbiAgY29uc3QgcG9zVG9TdHIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChwb3MpID0+IGAke3Bvc1swXX0sJHtwb3NbMV19YCwgXCJwb3NUb1N0clwiKTtcbiAgY29uc3Qgc3RyVG9Qb3MgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKChwb3MpID0+IHBvcy5zcGxpdChcIixcIikubWFwKChwKSA9PiBwYXJzZUludChwKSksIFwic3RyVG9Qb3NcIik7XG4gIHNwYXRpYWxNYXBzLmZvckVhY2goKHNwYXRpYWxNYXApID0+IHtcbiAgICBjb25zdCBpbnZTcGF0aWFsTWFwID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoc3BhdGlhbE1hcCkubWFwKChbaWQsIHBvc10pID0+IFtwb3NUb1N0cihwb3MpLCBpZF0pXG4gICAgKTtcbiAgICBjb25zdCBxdWV1ZSA9IFtwb3NUb1N0cihbMCwgMF0pXTtcbiAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgY29uc3QgZGlyZWN0aW9ucyA9IHtcbiAgICAgIEw6IFstMSwgMF0sXG4gICAgICBSOiBbMSwgMF0sXG4gICAgICBUOiBbMCwgMV0sXG4gICAgICBCOiBbMCwgLTFdXG4gICAgfTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY3VyciA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoY3Vycikge1xuICAgICAgICB2aXNpdGVkW2N1cnJdID0gMTtcbiAgICAgICAgY29uc3QgY3VycklkID0gaW52U3BhdGlhbE1hcFtjdXJyXTtcbiAgICAgICAgaWYgKGN1cnJJZCkge1xuICAgICAgICAgIGNvbnN0IGN1cnJQb3MgPSBzdHJUb1BvcyhjdXJyKTtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhkaXJlY3Rpb25zKS5mb3JFYWNoKChbZGlyLCBzaGlmdF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1BvcyA9IHBvc1RvU3RyKFtjdXJyUG9zWzBdICsgc2hpZnRbMF0sIGN1cnJQb3NbMV0gKyBzaGlmdFsxXV0pO1xuICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBpbnZTcGF0aWFsTWFwW25ld1Bvc107XG4gICAgICAgICAgICBpZiAobmV3SWQgJiYgIXZpc2l0ZWRbbmV3UG9zXSkge1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5ld1Bvcyk7XG4gICAgICAgICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgW0FyY2hpdGVjdHVyZURpcmVjdGlvbk5hbWVbZGlyXV06IG5ld0lkLFxuICAgICAgICAgICAgICAgIFtBcmNoaXRlY3R1cmVEaXJlY3Rpb25OYW1lW2dldE9wcG9zaXRlQXJjaGl0ZWN0dXJlRGlyZWN0aW9uKGRpcildXTogY3VycklkLFxuICAgICAgICAgICAgICAgIGdhcDogMS41ICogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZWxhdGl2ZUNvbnN0cmFpbnRzO1xufVxuX19uYW1lKGdldFJlbGF0aXZlQ29uc3RyYWludHMsIFwiZ2V0UmVsYXRpdmVDb25zdHJhaW50c1wiKTtcbmZ1bmN0aW9uIGxheW91dEFyY2hpdGVjdHVyZShzZXJ2aWNlcywganVuY3Rpb25zLCBncm91cHMsIGVkZ2VzLCB7IHNwYXRpYWxNYXBzIH0pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgcmVuZGVyRWwgPSBzZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcImRpdlwiKS5hdHRyKFwiaWRcIiwgXCJjeVwiKS5hdHRyKFwic3R5bGVcIiwgXCJkaXNwbGF5Om5vbmVcIik7XG4gICAgY29uc3QgY3kgPSBjeXRvc2NhcGUoe1xuICAgICAgY29udGFpbmVyOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN5XCIpLFxuICAgICAgc3R5bGU6IFtcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcImVkZ2VcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJjdXJ2ZS1zdHlsZVwiOiBcInN0cmFpZ2h0XCIsXG4gICAgICAgICAgICBsYWJlbDogXCJkYXRhKGxhYmVsKVwiLFxuICAgICAgICAgICAgXCJzb3VyY2UtZW5kcG9pbnRcIjogXCJkYXRhKHNvdXJjZUVuZHBvaW50KVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXQtZW5kcG9pbnRcIjogXCJkYXRhKHRhcmdldEVuZHBvaW50KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiZWRnZS5zZWdtZW50c1wiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBcImN1cnZlLXN0eWxlXCI6IFwic2VnbWVudHNcIixcbiAgICAgICAgICAgIFwic2VnbWVudC13ZWlnaHRzXCI6IFwiMFwiLFxuICAgICAgICAgICAgXCJzZWdtZW50LWRpc3RhbmNlc1wiOiBbMC41XSxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgSW5jb3JyZWN0IGxpYnJhcnkgdHlwZXNcbiAgICAgICAgICAgIFwiZWRnZS1kaXN0YW5jZXNcIjogXCJlbmRwb2ludHNcIixcbiAgICAgICAgICAgIFwic291cmNlLWVuZHBvaW50XCI6IFwiZGF0YShzb3VyY2VFbmRwb2ludClcIixcbiAgICAgICAgICAgIFwidGFyZ2V0LWVuZHBvaW50XCI6IFwiZGF0YSh0YXJnZXRFbmRwb2ludClcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcIm5vZGVcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBJbmNvcnJlY3QgbGlicmFyeSB0eXBlc1xuICAgICAgICAgICAgXCJjb21wb3VuZC1zaXppbmctd3J0LWxhYmVsc1wiOiBcImluY2x1ZGVcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcIm5vZGVbbGFiZWxdXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwidGV4dC12YWxpZ25cIjogXCJib3R0b21cIixcbiAgICAgICAgICAgIFwidGV4dC1oYWxpZ25cIjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIFwiZm9udC1zaXplXCI6IGAke2dldENvbmZpZ0ZpZWxkKFwiZm9udFNpemVcIil9cHhgXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiLm5vZGUtc2VydmljZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBsYWJlbDogXCJkYXRhKGxhYmVsKVwiLFxuICAgICAgICAgICAgd2lkdGg6IFwiZGF0YSh3aWR0aClcIixcbiAgICAgICAgICAgIGhlaWdodDogXCJkYXRhKGhlaWdodClcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcIi5ub2RlLWp1bmN0aW9uXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBcImRhdGEod2lkdGgpXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IFwiZGF0YShoZWlnaHQpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCIubm9kZS1ncm91cFwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIEluY29ycmVjdCBsaWJyYXJ5IHR5cGVzXG4gICAgICAgICAgICBwYWRkaW5nOiBgJHtnZXRDb25maWdGaWVsZChcInBhZGRpbmdcIil9cHhgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gICAgcmVuZGVyRWwucmVtb3ZlKCk7XG4gICAgYWRkR3JvdXBzKGdyb3VwcywgY3kpO1xuICAgIGFkZFNlcnZpY2VzKHNlcnZpY2VzLCBjeSk7XG4gICAgYWRkSnVuY3Rpb25zKGp1bmN0aW9ucywgY3kpO1xuICAgIGFkZEVkZ2VzKGVkZ2VzLCBjeSk7XG4gICAgY29uc3QgYWxpZ25tZW50Q29uc3RyYWludCA9IGdldEFsaWdubWVudHMoc3BhdGlhbE1hcHMpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCA9IGdldFJlbGF0aXZlQ29uc3RyYWludHMoc3BhdGlhbE1hcHMpO1xuICAgIGNvbnN0IGxheW91dCA9IGN5LmxheW91dCh7XG4gICAgICBuYW1lOiBcImZjb3NlXCIsXG4gICAgICBxdWFsaXR5OiBcInByb29mXCIsXG4gICAgICBzdHlsZUVuYWJsZWQ6IGZhbHNlLFxuICAgICAgYW5pbWF0ZTogZmFsc2UsXG4gICAgICBub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM6IGZhbHNlLFxuICAgICAgLy8gQWRqdXN0IHRoZSBlZGdlIHBhcmFtZXRlcnMgaWYgaXQgcGFzc2VzIHRocm91Z2ggdGhlIGJvcmRlciBvZiBhIGdyb3VwXG4gICAgICAvLyBIYWNreSBmaXggZm9yOiBodHRwczovL2dpdGh1Yi5jb20vaVZpcy1hdC1CaWxrZW50L2N5dG9zY2FwZS5qcy1mY29zZS9pc3N1ZXMvNjdcbiAgICAgIGlkZWFsRWRnZUxlbmd0aChlZGdlKSB7XG4gICAgICAgIGNvbnN0IFtub2RlQSwgbm9kZUJdID0gZWRnZS5jb25uZWN0ZWROb2RlcygpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QSB9ID0gbm9kZURhdGEobm9kZUEpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QiB9ID0gbm9kZURhdGEobm9kZUIpO1xuICAgICAgICBjb25zdCBlbGFzdGljaXR5ID0gcGFyZW50QSA9PT0gcGFyZW50QiA/IDEuNSAqIGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIikgOiAwLjUgKiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICAgICAgICByZXR1cm4gZWxhc3RpY2l0eTtcbiAgICAgIH0sXG4gICAgICBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgICAgIGNvbnN0IFtub2RlQSwgbm9kZUJdID0gZWRnZS5jb25uZWN0ZWROb2RlcygpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QSB9ID0gbm9kZURhdGEobm9kZUEpO1xuICAgICAgICBjb25zdCB7IHBhcmVudDogcGFyZW50QiB9ID0gbm9kZURhdGEobm9kZUIpO1xuICAgICAgICBjb25zdCBlbGFzdGljaXR5ID0gcGFyZW50QSA9PT0gcGFyZW50QiA/IDAuNDUgOiAxZS0zO1xuICAgICAgICByZXR1cm4gZWxhc3RpY2l0eTtcbiAgICAgIH0sXG4gICAgICBhbGlnbm1lbnRDb25zdHJhaW50LFxuICAgICAgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50XG4gICAgfSk7XG4gICAgbGF5b3V0Lm9uZShcImxheW91dHN0b3BcIiwgKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gZ2V0U2VnbWVudFdlaWdodHMoc291cmNlLCB0YXJnZXQsIHBvaW50WCwgcG9pbnRZKSB7XG4gICAgICAgIGxldCBXLCBEO1xuICAgICAgICBjb25zdCB7IHg6IHNYLCB5OiBzWSB9ID0gc291cmNlO1xuICAgICAgICBjb25zdCB7IHg6IHRYLCB5OiB0WSB9ID0gdGFyZ2V0O1xuICAgICAgICBEID0gKHBvaW50WSAtIHNZICsgKHNYIC0gcG9pbnRYKSAqIChzWSAtIHRZKSAvIChzWCAtIHRYKSkgLyBNYXRoLnNxcnQoMSArIE1hdGgucG93KChzWSAtIHRZKSAvIChzWCAtIHRYKSwgMikpO1xuICAgICAgICBXID0gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WSAtIHNZLCAyKSArIE1hdGgucG93KHBvaW50WCAtIHNYLCAyKSAtIE1hdGgucG93KEQsIDIpKTtcbiAgICAgICAgY29uc3QgZGlzdEFCID0gTWF0aC5zcXJ0KE1hdGgucG93KHRYIC0gc1gsIDIpICsgTWF0aC5wb3codFkgLSBzWSwgMikpO1xuICAgICAgICBXID0gVyAvIGRpc3RBQjtcbiAgICAgICAgbGV0IGRlbHRhMSA9ICh0WCAtIHNYKSAqIChwb2ludFkgLSBzWSkgLSAodFkgLSBzWSkgKiAocG9pbnRYIC0gc1gpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGRlbHRhMSA+PSAwOlxuICAgICAgICAgICAgZGVsdGExID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZGVsdGExIDwgMDpcbiAgICAgICAgICAgIGRlbHRhMSA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlbHRhMiA9ICh0WCAtIHNYKSAqIChwb2ludFggLSBzWCkgKyAodFkgLSBzWSkgKiAocG9pbnRZIC0gc1kpO1xuICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICBjYXNlIGRlbHRhMiA+PSAwOlxuICAgICAgICAgICAgZGVsdGEyID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZGVsdGEyIDwgMDpcbiAgICAgICAgICAgIGRlbHRhMiA9IC0xO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgRCA9IE1hdGguYWJzKEQpICogZGVsdGExO1xuICAgICAgICBXID0gVyAqIGRlbHRhMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXN0YW5jZXM6IEQsXG4gICAgICAgICAgd2VpZ2h0czogV1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgX19uYW1lKGdldFNlZ21lbnRXZWlnaHRzLCBcImdldFNlZ21lbnRXZWlnaHRzXCIpO1xuICAgICAgY3kuc3RhcnRCYXRjaCgpO1xuICAgICAgZm9yIChjb25zdCBlZGdlIG9mIE9iamVjdC52YWx1ZXMoY3kuZWRnZXMoKSkpIHtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YT8uKCkpIHtcbiAgICAgICAgICBjb25zdCB7IHg6IHNYLCB5OiBzWSB9ID0gZWRnZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgICAgICAgIGNvbnN0IHsgeDogdFgsIHk6IHRZIH0gPSBlZGdlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG4gICAgICAgICAgaWYgKHNYICE9PSB0WCAmJiBzWSAhPT0gdFkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNFUCA9IGVkZ2Uuc291cmNlRW5kcG9pbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHRFUCA9IGVkZ2UudGFyZ2V0RW5kcG9pbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlRGlyIH0gPSBlZGdlRGF0YShlZGdlKTtcbiAgICAgICAgICAgIGNvbnN0IFtwb2ludFgsIHBvaW50WV0gPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkoc291cmNlRGlyKSA/IFtzRVAueCwgdEVQLnldIDogW3RFUC54LCBzRVAueV07XG4gICAgICAgICAgICBjb25zdCB7IHdlaWdodHMsIGRpc3RhbmNlcyB9ID0gZ2V0U2VnbWVudFdlaWdodHMoc0VQLCB0RVAsIHBvaW50WCwgcG9pbnRZKTtcbiAgICAgICAgICAgIGVkZ2Uuc3R5bGUoXCJzZWdtZW50LWRpc3RhbmNlc1wiLCBkaXN0YW5jZXMpO1xuICAgICAgICAgICAgZWRnZS5zdHlsZShcInNlZ21lbnQtd2VpZ2h0c1wiLCB3ZWlnaHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN5LmVuZEJhdGNoKCk7XG4gICAgICBsYXlvdXQucnVuKCk7XG4gICAgfSk7XG4gICAgbGF5b3V0LnJ1bigpO1xuICAgIGN5LnJlYWR5KChlKSA9PiB7XG4gICAgICBsb2cuaW5mbyhcIlJlYWR5XCIsIGUpO1xuICAgICAgcmVzb2x2ZShjeSk7XG4gICAgfSk7XG4gIH0pO1xufVxuX19uYW1lKGxheW91dEFyY2hpdGVjdHVyZSwgXCJsYXlvdXRBcmNoaXRlY3R1cmVcIik7XG52YXIgZHJhdyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKHRleHQsIGlkLCBfdmVyc2lvbiwgZGlhZ09iaikgPT4ge1xuICBjb25zdCBkYjIgPSBkaWFnT2JqLmRiO1xuICBjb25zdCBzZXJ2aWNlcyA9IGRiMi5nZXRTZXJ2aWNlcygpO1xuICBjb25zdCBqdW5jdGlvbnMgPSBkYjIuZ2V0SnVuY3Rpb25zKCk7XG4gIGNvbnN0IGdyb3VwcyA9IGRiMi5nZXRHcm91cHMoKTtcbiAgY29uc3QgZWRnZXMgPSBkYjIuZ2V0RWRnZXMoKTtcbiAgY29uc3QgZHMgPSBkYjIuZ2V0RGF0YVN0cnVjdHVyZXMoKTtcbiAgY29uc3Qgc3ZnID0gc2VsZWN0U3ZnRWxlbWVudChpZCk7XG4gIGNvbnN0IGVkZ2VzRWxlbSA9IHN2Zy5hcHBlbmQoXCJnXCIpO1xuICBlZGdlc0VsZW0uYXR0cihcImNsYXNzXCIsIFwiYXJjaGl0ZWN0dXJlLWVkZ2VzXCIpO1xuICBjb25zdCBzZXJ2aWNlc0VsZW0gPSBzdmcuYXBwZW5kKFwiZ1wiKTtcbiAgc2VydmljZXNFbGVtLmF0dHIoXCJjbGFzc1wiLCBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlc1wiKTtcbiAgY29uc3QgZ3JvdXBFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIGdyb3VwRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJhcmNoaXRlY3R1cmUtZ3JvdXBzXCIpO1xuICBhd2FpdCBkcmF3U2VydmljZXMoZGIyLCBzZXJ2aWNlc0VsZW0sIHNlcnZpY2VzKTtcbiAgZHJhd0p1bmN0aW9ucyhkYjIsIHNlcnZpY2VzRWxlbSwganVuY3Rpb25zKTtcbiAgY29uc3QgY3kgPSBhd2FpdCBsYXlvdXRBcmNoaXRlY3R1cmUoc2VydmljZXMsIGp1bmN0aW9ucywgZ3JvdXBzLCBlZGdlcywgZHMpO1xuICBhd2FpdCBkcmF3RWRnZXMoZWRnZXNFbGVtLCBjeSk7XG4gIGF3YWl0IGRyYXdHcm91cHMoZ3JvdXBFbGVtLCBjeSk7XG4gIHBvc2l0aW9uTm9kZXMoZGIyLCBjeSk7XG4gIHNldHVwR3JhcGhWaWV3Ym94KHZvaWQgMCwgc3ZnLCBnZXRDb25maWdGaWVsZChcInBhZGRpbmdcIiksIGdldENvbmZpZ0ZpZWxkKFwidXNlTWF4V2lkdGhcIikpO1xufSwgXCJkcmF3XCIpO1xudmFyIHJlbmRlcmVyID0geyBkcmF3IH07XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlRGlhZ3JhbS50c1xudmFyIGRpYWdyYW0gPSB7XG4gIHBhcnNlcixcbiAgZGIsXG4gIHJlbmRlcmVyLFxuICBzdHlsZXM6IGFyY2hpdGVjdHVyZVN0eWxlc19kZWZhdWx0XG59O1xuZXhwb3J0IHtcbiAgZGlhZ3JhbVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///83175\n')},98160:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   m: () => (/* binding */ ImperativeState)\n/* harmony export */ });\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10009);\n\n\n// src/utils/imperativeState.ts\nvar ImperativeState = class {\n  /**\n   * @param init - Function that creates the default state.\n   */\n  constructor(init) {\n    this.init = init;\n    this.records = this.init();\n  }\n  static {\n    (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "ImperativeState");\n  }\n  reset() {\n    this.records = this.init();\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgxNjAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUU4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFFQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstS0ZCT0JKSEMubWpzP2VjMWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLTZEQkZGSElQLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvaW1wZXJhdGl2ZVN0YXRlLnRzXG52YXIgSW1wZXJhdGl2ZVN0YXRlID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGluaXQgLSBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGRlZmF1bHQgc3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkltcGVyYXRpdmVTdGF0ZVwiKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgSW1wZXJhdGl2ZVN0YXRlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98160\n')},63933:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ populateCommonDb)\n/* harmony export */ });\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10009);\n\n\n// src/diagrams/common/populateCommonDb.ts\nfunction populateCommonDb(ast, db) {\n  if (ast.accDescr) {\n    db.setAccDescription?.(ast.accDescr);\n  }\n  if (ast.accTitle) {\n    db.setAccTitle?.(ast.accTitle);\n  }\n  if (ast.title) {\n    db.setDiagramTitle?.(ast.title);\n  }\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(populateCommonDb, "populateCommonDb");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjM5MzMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUU4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQU07O0FBSUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jaHVua3MvbWVybWFpZC5jb3JlL2NodW5rLVRNVUJFV1BELm1qcz81MDZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIF9fbmFtZVxufSBmcm9tIFwiLi9jaHVuay02REJGRkhJUC5tanNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL2NvbW1vbi9wb3B1bGF0ZUNvbW1vbkRiLnRzXG5mdW5jdGlvbiBwb3B1bGF0ZUNvbW1vbkRiKGFzdCwgZGIpIHtcbiAgaWYgKGFzdC5hY2NEZXNjcikge1xuICAgIGRiLnNldEFjY0Rlc2NyaXB0aW9uPy4oYXN0LmFjY0Rlc2NyKTtcbiAgfVxuICBpZiAoYXN0LmFjY1RpdGxlKSB7XG4gICAgZGIuc2V0QWNjVGl0bGU/Lihhc3QuYWNjVGl0bGUpO1xuICB9XG4gIGlmIChhc3QudGl0bGUpIHtcbiAgICBkYi5zZXREaWFncmFtVGl0bGU/Lihhc3QudGl0bGUpO1xuICB9XG59XG5fX25hbWUocG9wdWxhdGVDb21tb25EYiwgXCJwb3B1bGF0ZUNvbW1vbkRiXCIpO1xuXG5leHBvcnQge1xuICBwb3B1bGF0ZUNvbW1vbkRiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63933\n')}}]);