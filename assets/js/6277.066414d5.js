(self.webpackChunkregal_ui_docs=self.webpackChunkregal_ui_docs||[]).push([[6277],{99320:function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(13534), __webpack_require__(44318), __webpack_require__(92802)) :\n    0;\n})(this, (function (exports, setArray, sourcemapCodec, traceMapping) { 'use strict';\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n\n    const NO_NAME = -1;\n    /**\n     * Provides the state to generate a sourcemap.\n     */\n    class GenMapping {\n        constructor({ file, sourceRoot } = {}) {\n            this._names = new setArray.SetArray();\n            this._sources = new setArray.SetArray();\n            this._sourcesContent = [];\n            this._mappings = [];\n            this.file = file;\n            this.sourceRoot = sourceRoot;\n            this._ignoreList = new setArray.SetArray();\n        }\n    }\n    /**\n     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n     * with public access modifiers.\n     */\n    function cast(map) {\n        return map;\n    }\n    function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    }\n    function addMapping(map, mapping) {\n        return addMappingInternal(false, map, mapping);\n    }\n    /**\n     * Same as `addSegment`, but will only add the segment if it generates useful information in the\n     * resulting map. This only works correctly if segments are added **in order**, meaning you should\n     * not add a segment with a lower generated line/column than one that came before.\n     */\n    const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n    };\n    /**\n     * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n     * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n     * not add a mapping with a lower generated line/column than one that came before.\n     */\n    const maybeAddMapping = (map, mapping) => {\n        return addMappingInternal(true, map, mapping);\n    };\n    /**\n     * Adds/removes the content of the source file to the source map.\n     */\n    function setSourceContent(map, source, content) {\n        const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n        const index = setArray.put(sources, source);\n        sourcesContent[index] = content;\n    }\n    function setIgnore(map, source, ignore = true) {\n        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n        const index = setArray.put(sources, source);\n        if (index === sourcesContent.length)\n            sourcesContent[index] = null;\n        if (ignore)\n            setArray.put(ignoreList, index);\n        else\n            setArray.remove(ignoreList, index);\n    }\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function toDecodedMap(map) {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);\n        removeEmptyFinalLines(mappings);\n        return {\n            version: 3,\n            file: map.file || undefined,\n            names: names.array,\n            sourceRoot: map.sourceRoot || undefined,\n            sources: sources.array,\n            sourcesContent,\n            mappings,\n            ignoreList: ignoreList.array,\n        };\n    }\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function toEncodedMap(map) {\n        const decoded = toDecodedMap(map);\n        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });\n    }\n    /**\n     * Constructs a new GenMapping, using the already present mappings of the input.\n     */\n    function fromMap(input) {\n        const map = new traceMapping.TraceMap(input);\n        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n        putAll(cast(gen)._names, map.names);\n        putAll(cast(gen)._sources, map.sources);\n        cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n        cast(gen)._mappings = traceMapping.decodedMappings(map);\n        if (map.ignoreList)\n            putAll(cast(gen)._ignoreList, map.ignoreList);\n        return gen;\n    }\n    /**\n     * Returns an array of high-level mapping objects for every recorded segment, which could then be\n     * passed to the `source-map` library.\n     */\n    function allMappings(map) {\n        const out = [];\n        const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n        for (let i = 0; i < mappings.length; i++) {\n            const line = mappings[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generated = { line: i + 1, column: seg[COLUMN] };\n                let source = undefined;\n                let original = undefined;\n                let name = undefined;\n                if (seg.length !== 1) {\n                    source = sources.array[seg[SOURCES_INDEX]];\n                    original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                    if (seg.length === 5)\n                        name = names.array[seg[NAMES_INDEX]];\n                }\n                out.push({ generated, source, original, name });\n            }\n        }\n        return out;\n    }\n    // This split declaration is only so that terser can elminiate the static initialization block.\n    function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);\n        const line = getLine(mappings, genLine);\n        const index = getColumnIndex(line, genColumn);\n        if (!source) {\n            if (skipable && skipSourceless(line, index))\n                return;\n            return insert(line, index, [genColumn]);\n        }\n        const sourcesIndex = setArray.put(sources, source);\n        const namesIndex = name ? setArray.put(names, name) : NO_NAME;\n        if (sourcesIndex === sourcesContent.length)\n            sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n        if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n            return;\n        }\n        return insert(line, index, name\n            ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n            : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n    }\n    function getLine(mappings, index) {\n        for (let i = mappings.length; i <= index; i++) {\n            mappings[i] = [];\n        }\n        return mappings[index];\n    }\n    function getColumnIndex(line, genColumn) {\n        let index = line.length;\n        for (let i = index - 1; i >= 0; index = i--) {\n            const current = line[i];\n            if (genColumn >= current[COLUMN])\n                break;\n        }\n        return index;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    function removeEmptyFinalLines(mappings) {\n        const { length } = mappings;\n        let len = length;\n        for (let i = len - 1; i >= 0; len = i, i--) {\n            if (mappings[i].length > 0)\n                break;\n        }\n        if (len < length)\n            mappings.length = len;\n    }\n    function putAll(setarr, array) {\n        for (let i = 0; i < array.length; i++)\n            setArray.put(setarr, array[i]);\n    }\n    function skipSourceless(line, index) {\n        // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n        // doesn't generate any useful information.\n        if (index === 0)\n            return true;\n        const prev = line[index - 1];\n        // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n        // genrate any new information. Else, this segment will end the source/named segment and point to\n        // a sourceless position, which is useful.\n        return prev.length === 1;\n    }\n    function skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n        // A source/named segment at the start of a line gives position at that genColumn\n        if (index === 0)\n            return false;\n        const prev = line[index - 1];\n        // If the previous segment is sourceless, then we're transitioning to a source.\n        if (prev.length === 1)\n            return false;\n        // If the previous segment maps to the exact same source position, then this segment doesn't\n        // provide any new position information.\n        return (sourcesIndex === prev[SOURCES_INDEX] &&\n            sourceLine === prev[SOURCE_LINE] &&\n            sourceColumn === prev[SOURCE_COLUMN] &&\n            namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n    }\n    function addMappingInternal(skipable, map, mapping) {\n        const { generated, source, original, name, content } = mapping;\n        if (!source) {\n            return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n        }\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n    }\n\n    exports.GenMapping = GenMapping;\n    exports.addMapping = addMapping;\n    exports.addSegment = addSegment;\n    exports.allMappings = allMappings;\n    exports.fromMap = fromMap;\n    exports.maybeAddMapping = maybeAddMapping;\n    exports.maybeAddSegment = maybeAddSegment;\n    exports.setIgnore = setIgnore;\n    exports.setSourceContent = setSourceContent;\n    exports.toDecodedMap = toDecodedMap;\n    exports.toEncodedMap = toEncodedMap;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=gen-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkzMjAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLEtBQXVCLEdBQUcsbUJBQU8sQ0FBQyxLQUE2QixHQUFHLG1CQUFPLENBQUMsS0FBMkI7QUFDak0sSUFBSSxDQUN3SztBQUM1SyxDQUFDLHNFQUFzRTs7QUFFdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQixJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEVBQThFO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1IQUFtSDtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYyxtREFBbUQ7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRDQUE0QztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUF3RDtBQUN4RSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBGQUEwRjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkNBQTZDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEUsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9nZW4tbWFwcGluZy9kaXN0L2dlbi1tYXBwaW5nLnVtZC5qcz8xN2RlIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdAanJpZGdld2VsbC9zZXQtYXJyYXknKSwgcmVxdWlyZSgnQGpyaWRnZXdlbGwvc291cmNlbWFwLWNvZGVjJyksIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcnKSkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnQGpyaWRnZXdlbGwvc2V0LWFycmF5JywgJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYycsICdAanJpZGdld2VsbC90cmFjZS1tYXBwaW5nJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5nZW5NYXBwaW5nID0ge30sIGdsb2JhbC5zZXRBcnJheSwgZ2xvYmFsLnNvdXJjZW1hcENvZGVjLCBnbG9iYWwudHJhY2VNYXBwaW5nKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHNldEFycmF5LCBzb3VyY2VtYXBDb2RlYywgdHJhY2VNYXBwaW5nKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGNvbnN0IENPTFVNTiA9IDA7XG4gICAgY29uc3QgU09VUkNFU19JTkRFWCA9IDE7XG4gICAgY29uc3QgU09VUkNFX0xJTkUgPSAyO1xuICAgIGNvbnN0IFNPVVJDRV9DT0xVTU4gPSAzO1xuICAgIGNvbnN0IE5BTUVTX0lOREVYID0gNDtcblxuICAgIGNvbnN0IE5PX05BTUUgPSAtMTtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgc3RhdGUgdG8gZ2VuZXJhdGUgYSBzb3VyY2VtYXAuXG4gICAgICovXG4gICAgY2xhc3MgR2VuTWFwcGluZyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHsgZmlsZSwgc291cmNlUm9vdCB9ID0ge30pIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWVzID0gbmV3IHNldEFycmF5LlNldEFycmF5KCk7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzID0gbmV3IHNldEFycmF5LlNldEFycmF5KCk7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWFwcGluZ3MgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgICAgICAgICAgdGhpcy5faWdub3JlTGlzdCA9IG5ldyBzZXRBcnJheS5TZXRBcnJheSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGVzY3JpcHQgZG9lc24ndCBhbGxvdyBmcmllbmQgYWNjZXNzIHRvIHByaXZhdGUgZmllbGRzLCBzbyB0aGlzIGp1c3QgY2FzdHMgdGhlIG1hcCBpbnRvIGEgdHlwZVxuICAgICAqIHdpdGggcHVibGljIGFjY2VzcyBtb2RpZmllcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdChtYXApIHtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkU2VnbWVudChtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChmYWxzZSwgbWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkTWFwcGluZyhtYXAsIG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIGFkZE1hcHBpbmdJbnRlcm5hbChmYWxzZSwgbWFwLCBtYXBwaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2FtZSBhcyBgYWRkU2VnbWVudGAsIGJ1dCB3aWxsIG9ubHkgYWRkIHRoZSBzZWdtZW50IGlmIGl0IGdlbmVyYXRlcyB1c2VmdWwgaW5mb3JtYXRpb24gaW4gdGhlXG4gICAgICogcmVzdWx0aW5nIG1hcC4gVGhpcyBvbmx5IHdvcmtzIGNvcnJlY3RseSBpZiBzZWdtZW50cyBhcmUgYWRkZWQgKippbiBvcmRlcioqLCBtZWFuaW5nIHlvdSBzaG91bGRcbiAgICAgKiBub3QgYWRkIGEgc2VnbWVudCB3aXRoIGEgbG93ZXIgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHRoYW4gb25lIHRoYXQgY2FtZSBiZWZvcmUuXG4gICAgICovXG4gICAgY29uc3QgbWF5YmVBZGRTZWdtZW50ID0gKG1hcCwgZ2VuTGluZSwgZ2VuQ29sdW1uLCBzb3VyY2UsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZSwgY29udGVudCkgPT4ge1xuICAgICAgICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKHRydWUsIG1hcCwgZ2VuTGluZSwgZ2VuQ29sdW1uLCBzb3VyY2UsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZSwgY29udGVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBhZGRNYXBwaW5nYCwgYnV0IHdpbGwgb25seSBhZGQgdGhlIG1hcHBpbmcgaWYgaXQgZ2VuZXJhdGVzIHVzZWZ1bCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAgICAgKiByZXN1bHRpbmcgbWFwLiBUaGlzIG9ubHkgd29ya3MgY29ycmVjdGx5IGlmIG1hcHBpbmdzIGFyZSBhZGRlZCAqKmluIG9yZGVyKiosIG1lYW5pbmcgeW91IHNob3VsZFxuICAgICAqIG5vdCBhZGQgYSBtYXBwaW5nIHdpdGggYSBsb3dlciBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gdGhhbiBvbmUgdGhhdCBjYW1lIGJlZm9yZS5cbiAgICAgKi9cbiAgICBjb25zdCBtYXliZUFkZE1hcHBpbmcgPSAobWFwLCBtYXBwaW5nKSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRNYXBwaW5nSW50ZXJuYWwodHJ1ZSwgbWFwLCBtYXBwaW5nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMvcmVtb3ZlcyB0aGUgY29udGVudCBvZiB0aGUgc291cmNlIGZpbGUgdG8gdGhlIHNvdXJjZSBtYXAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0U291cmNlQ29udGVudChtYXAsIHNvdXJjZSwgY29udGVudCkge1xuICAgICAgICBjb25zdCB7IF9zb3VyY2VzOiBzb3VyY2VzLCBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50IH0gPSBjYXN0KG1hcCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gc2V0QXJyYXkucHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldElnbm9yZShtYXAsIHNvdXJjZSwgaWdub3JlID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IF9zb3VyY2VzOiBzb3VyY2VzLCBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50LCBfaWdub3JlTGlzdDogaWdub3JlTGlzdCB9ID0gY2FzdChtYXApO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNldEFycmF5LnB1dChzb3VyY2VzLCBzb3VyY2UpO1xuICAgICAgICBpZiAoaW5kZXggPT09IHNvdXJjZXNDb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50W2luZGV4XSA9IG51bGw7XG4gICAgICAgIGlmIChpZ25vcmUpXG4gICAgICAgICAgICBzZXRBcnJheS5wdXQoaWdub3JlTGlzdCwgaW5kZXgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRBcnJheS5yZW1vdmUoaWdub3JlTGlzdCwgaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc291cmNlbWFwIG9iamVjdCAod2l0aCBkZWNvZGVkIG1hcHBpbmdzKSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIGxpYnJhcnkgdGhhdCBleHBlY3RzXG4gICAgICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRGVjb2RlZE1hcChtYXApIHtcbiAgICAgICAgY29uc3QgeyBfbWFwcGluZ3M6IG1hcHBpbmdzLCBfc291cmNlczogc291cmNlcywgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCwgX25hbWVzOiBuYW1lcywgX2lnbm9yZUxpc3Q6IGlnbm9yZUxpc3QsIH0gPSBjYXN0KG1hcCk7XG4gICAgICAgIHJlbW92ZUVtcHR5RmluYWxMaW5lcyhtYXBwaW5ncyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICAgICAgZmlsZTogbWFwLmZpbGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgbmFtZXM6IG5hbWVzLmFycmF5LFxuICAgICAgICAgICAgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc291cmNlczogc291cmNlcy5hcnJheSxcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LFxuICAgICAgICAgICAgbWFwcGluZ3MsXG4gICAgICAgICAgICBpZ25vcmVMaXN0OiBpZ25vcmVMaXN0LmFycmF5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc291cmNlbWFwIG9iamVjdCAod2l0aCBlbmNvZGVkIG1hcHBpbmdzKSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIGxpYnJhcnkgdGhhdCBleHBlY3RzXG4gICAgICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvRW5jb2RlZE1hcChtYXApIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IHRvRGVjb2RlZE1hcChtYXApO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWNvZGVkKSwgeyBtYXBwaW5nczogc291cmNlbWFwQ29kZWMuZW5jb2RlKGRlY29kZWQubWFwcGluZ3MpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEdlbk1hcHBpbmcsIHVzaW5nIHRoZSBhbHJlYWR5IHByZXNlbnQgbWFwcGluZ3Mgb2YgdGhlIGlucHV0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21NYXAoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IHRyYWNlTWFwcGluZy5UcmFjZU1hcChpbnB1dCk7XG4gICAgICAgIGNvbnN0IGdlbiA9IG5ldyBHZW5NYXBwaW5nKHsgZmlsZTogbWFwLmZpbGUsIHNvdXJjZVJvb3Q6IG1hcC5zb3VyY2VSb290IH0pO1xuICAgICAgICBwdXRBbGwoY2FzdChnZW4pLl9uYW1lcywgbWFwLm5hbWVzKTtcbiAgICAgICAgcHV0QWxsKGNhc3QoZ2VuKS5fc291cmNlcywgbWFwLnNvdXJjZXMpO1xuICAgICAgICBjYXN0KGdlbikuX3NvdXJjZXNDb250ZW50ID0gbWFwLnNvdXJjZXNDb250ZW50IHx8IG1hcC5zb3VyY2VzLm1hcCgoKSA9PiBudWxsKTtcbiAgICAgICAgY2FzdChnZW4pLl9tYXBwaW5ncyA9IHRyYWNlTWFwcGluZy5kZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgICAgICAgaWYgKG1hcC5pZ25vcmVMaXN0KVxuICAgICAgICAgICAgcHV0QWxsKGNhc3QoZ2VuKS5faWdub3JlTGlzdCwgbWFwLmlnbm9yZUxpc3QpO1xuICAgICAgICByZXR1cm4gZ2VuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGhpZ2gtbGV2ZWwgbWFwcGluZyBvYmplY3RzIGZvciBldmVyeSByZWNvcmRlZCBzZWdtZW50LCB3aGljaCBjb3VsZCB0aGVuIGJlXG4gICAgICogcGFzc2VkIHRvIHRoZSBgc291cmNlLW1hcGAgbGlicmFyeS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhbGxNYXBwaW5ncyhtYXApIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIGNvbnN0IHsgX21hcHBpbmdzOiBtYXBwaW5ncywgX3NvdXJjZXM6IHNvdXJjZXMsIF9uYW1lczogbmFtZXMgfSA9IGNhc3QobWFwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IG1hcHBpbmdzW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSB7IGxpbmU6IGkgKyAxLCBjb2x1bW46IHNlZ1tDT0xVTU5dIH07XG4gICAgICAgICAgICAgICAgbGV0IHNvdXJjZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgb3JpZ2luYWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gc291cmNlcy5hcnJheVtzZWdbU09VUkNFU19JTkRFWF1dO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbCA9IHsgbGluZTogc2VnW1NPVVJDRV9MSU5FXSArIDEsIGNvbHVtbjogc2VnW1NPVVJDRV9DT0xVTU5dIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoID09PSA1KVxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWVzLmFycmF5W3NlZ1tOQU1FU19JTkRFWF1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvdXQucHVzaCh7IGdlbmVyYXRlZCwgc291cmNlLCBvcmlnaW5hbCwgbmFtZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvLyBUaGlzIHNwbGl0IGRlY2xhcmF0aW9uIGlzIG9ubHkgc28gdGhhdCB0ZXJzZXIgY2FuIGVsbWluaWF0ZSB0aGUgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrLlxuICAgIGZ1bmN0aW9uIGFkZFNlZ21lbnRJbnRlcm5hbChza2lwYWJsZSwgbWFwLCBnZW5MaW5lLCBnZW5Db2x1bW4sIHNvdXJjZSwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgX21hcHBpbmdzOiBtYXBwaW5ncywgX3NvdXJjZXM6IHNvdXJjZXMsIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsIF9uYW1lczogbmFtZXMsIH0gPSBjYXN0KG1hcCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBnZXRMaW5lKG1hcHBpbmdzLCBnZW5MaW5lKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRDb2x1bW5JbmRleChsaW5lLCBnZW5Db2x1bW4pO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2VsZXNzKGxpbmUsIGluZGV4KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0KGxpbmUsIGluZGV4LCBbZ2VuQ29sdW1uXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlc0luZGV4ID0gc2V0QXJyYXkucHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IG5hbWVzSW5kZXggPSBuYW1lID8gc2V0QXJyYXkucHV0KG5hbWVzLCBuYW1lKSA6IE5PX05BTUU7XG4gICAgICAgIGlmIChzb3VyY2VzSW5kZXggPT09IHNvdXJjZXNDb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHNvdXJjZXNDb250ZW50W3NvdXJjZXNJbmRleF0gPSBjb250ZW50ICE9PSBudWxsICYmIGNvbnRlbnQgIT09IHZvaWQgMCA/IGNvbnRlbnQgOiBudWxsO1xuICAgICAgICBpZiAoc2tpcGFibGUgJiYgc2tpcFNvdXJjZShsaW5lLCBpbmRleCwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc2VydChsaW5lLCBpbmRleCwgbmFtZVxuICAgICAgICAgICAgPyBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleF1cbiAgICAgICAgICAgIDogW2dlbkNvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW5dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TGluZShtYXBwaW5ncywgaW5kZXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hcHBpbmdzLmxlbmd0aDsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICBtYXBwaW5nc1tpXSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwaW5nc1tpbmRleF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbHVtbkluZGV4KGxpbmUsIGdlbkNvbHVtbikge1xuICAgICAgICBsZXQgaW5kZXggPSBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpbmRleCA9IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGxpbmVbaV07XG4gICAgICAgICAgICBpZiAoZ2VuQ29sdW1uID49IGN1cnJlbnRbQ09MVU1OXSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhcnJheS5sZW5ndGg7IGkgPiBpbmRleDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlRW1wdHlGaW5hbExpbmVzKG1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBtYXBwaW5ncztcbiAgICAgICAgbGV0IGxlbiA9IGxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgbGVuID0gaSwgaS0tKSB7XG4gICAgICAgICAgICBpZiAobWFwcGluZ3NbaV0ubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuIDwgbGVuZ3RoKVxuICAgICAgICAgICAgbWFwcGluZ3MubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwdXRBbGwoc2V0YXJyLCBhcnJheSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2V0QXJyYXkucHV0KHNldGFyciwgYXJyYXlbaV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2lwU291cmNlbGVzcyhsaW5lLCBpbmRleCkge1xuICAgICAgICAvLyBUaGUgc3RhcnQgb2YgYSBsaW5lIGlzIGFscmVhZHkgc291cmNlbGVzcywgc28gYWRkaW5nIGEgc291cmNlbGVzcyBzZWdtZW50IHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgICAgLy8gZG9lc24ndCBnZW5lcmF0ZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uLlxuICAgICAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHNlZ21lbnQgaXMgYWxzbyBzb3VyY2VsZXNzLCB0aGVuIGFkZGluZyBhbm90aGVyIHNvdXJjZWxlc3Mgc2VnbWVudCBkb2Vzbid0XG4gICAgICAgIC8vIGdlbnJhdGUgYW55IG5ldyBpbmZvcm1hdGlvbi4gRWxzZSwgdGhpcyBzZWdtZW50IHdpbGwgZW5kIHRoZSBzb3VyY2UvbmFtZWQgc2VnbWVudCBhbmQgcG9pbnQgdG9cbiAgICAgICAgLy8gYSBzb3VyY2VsZXNzIHBvc2l0aW9uLCB3aGljaCBpcyB1c2VmdWwuXG4gICAgICAgIHJldHVybiBwcmV2Lmxlbmd0aCA9PT0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2tpcFNvdXJjZShsaW5lLCBpbmRleCwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXgpIHtcbiAgICAgICAgLy8gQSBzb3VyY2UvbmFtZWQgc2VnbWVudCBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lIGdpdmVzIHBvc2l0aW9uIGF0IHRoYXQgZ2VuQ29sdW1uXG4gICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgcHJldiA9IGxpbmVbaW5kZXggLSAxXTtcbiAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzIHNlZ21lbnQgaXMgc291cmNlbGVzcywgdGhlbiB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvIGEgc291cmNlLlxuICAgICAgICBpZiAocHJldi5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBzZWdtZW50IG1hcHMgdG8gdGhlIGV4YWN0IHNhbWUgc291cmNlIHBvc2l0aW9uLCB0aGVuIHRoaXMgc2VnbWVudCBkb2Vzbid0XG4gICAgICAgIC8vIHByb3ZpZGUgYW55IG5ldyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICAgICAgcmV0dXJuIChzb3VyY2VzSW5kZXggPT09IHByZXZbU09VUkNFU19JTkRFWF0gJiZcbiAgICAgICAgICAgIHNvdXJjZUxpbmUgPT09IHByZXZbU09VUkNFX0xJTkVdICYmXG4gICAgICAgICAgICBzb3VyY2VDb2x1bW4gPT09IHByZXZbU09VUkNFX0NPTFVNTl0gJiZcbiAgICAgICAgICAgIG5hbWVzSW5kZXggPT09IChwcmV2Lmxlbmd0aCA9PT0gNSA/IHByZXZbTkFNRVNfSU5ERVhdIDogTk9fTkFNRSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRNYXBwaW5nSW50ZXJuYWwoc2tpcGFibGUsIG1hcCwgbWFwcGluZykge1xuICAgICAgICBjb25zdCB7IGdlbmVyYXRlZCwgc291cmNlLCBvcmlnaW5hbCwgbmFtZSwgY29udGVudCB9ID0gbWFwcGluZztcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGRTZWdtZW50SW50ZXJuYWwoc2tpcGFibGUsIG1hcCwgZ2VuZXJhdGVkLmxpbmUgLSAxLCBnZW5lcmF0ZWQuY29sdW1uLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKHNraXBhYmxlLCBtYXAsIGdlbmVyYXRlZC5saW5lIC0gMSwgZ2VuZXJhdGVkLmNvbHVtbiwgc291cmNlLCBvcmlnaW5hbC5saW5lIC0gMSwgb3JpZ2luYWwuY29sdW1uLCBuYW1lLCBjb250ZW50KTtcbiAgICB9XG5cbiAgICBleHBvcnRzLkdlbk1hcHBpbmcgPSBHZW5NYXBwaW5nO1xuICAgIGV4cG9ydHMuYWRkTWFwcGluZyA9IGFkZE1hcHBpbmc7XG4gICAgZXhwb3J0cy5hZGRTZWdtZW50ID0gYWRkU2VnbWVudDtcbiAgICBleHBvcnRzLmFsbE1hcHBpbmdzID0gYWxsTWFwcGluZ3M7XG4gICAgZXhwb3J0cy5mcm9tTWFwID0gZnJvbU1hcDtcbiAgICBleHBvcnRzLm1heWJlQWRkTWFwcGluZyA9IG1heWJlQWRkTWFwcGluZztcbiAgICBleHBvcnRzLm1heWJlQWRkU2VnbWVudCA9IG1heWJlQWRkU2VnbWVudDtcbiAgICBleHBvcnRzLnNldElnbm9yZSA9IHNldElnbm9yZTtcbiAgICBleHBvcnRzLnNldFNvdXJjZUNvbnRlbnQgPSBzZXRTb3VyY2VDb250ZW50O1xuICAgIGV4cG9ydHMudG9EZWNvZGVkTWFwID0gdG9EZWNvZGVkTWFwO1xuICAgIGV4cG9ydHMudG9FbmNvZGVkTWFwID0gdG9FbmNvZGVkTWFwO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2VuLW1hcHBpbmcudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99320\n")},4424:function(module){eval("(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n})(this, (function () { 'use strict';\n\n    // Matches the scheme of a URL, eg \"http://\"\n    const schemeRegex = /^[\\w+.-]+:\\/\\//;\n    /**\n     * Matches the parts of a URL:\n     * 1. Scheme, including \":\", guaranteed.\n     * 2. User/password, including \"@\", optional.\n     * 3. Host, guaranteed.\n     * 4. Port, including \":\", optional.\n     * 5. Path, including \"/\", optional.\n     * 6. Query, including \"?\", optional.\n     * 7. Hash, including \"#\", optional.\n     */\n    const urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n    /**\n     * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n     * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n     *\n     * 1. Host, optional.\n     * 2. Path, which may include \"/\", guaranteed.\n     * 3. Query, including \"?\", optional.\n     * 4. Hash, including \"#\", optional.\n     */\n    const fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n    function isAbsoluteUrl(input) {\n        return schemeRegex.test(input);\n    }\n    function isSchemeRelativeUrl(input) {\n        return input.startsWith('//');\n    }\n    function isAbsolutePath(input) {\n        return input.startsWith('/');\n    }\n    function isFileUrl(input) {\n        return input.startsWith('file:');\n    }\n    function isRelative(input) {\n        return /^[.?#]/.test(input);\n    }\n    function parseAbsoluteUrl(input) {\n        const match = urlRegex.exec(input);\n        return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n    }\n    function parseFileUrl(input) {\n        const match = fileRegex.exec(input);\n        const path = match[2];\n        return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n    }\n    function makeUrl(scheme, user, host, port, path, query, hash) {\n        return {\n            scheme,\n            user,\n            host,\n            port,\n            path,\n            query,\n            hash,\n            type: 7 /* Absolute */,\n        };\n    }\n    function parseUrl(input) {\n        if (isSchemeRelativeUrl(input)) {\n            const url = parseAbsoluteUrl('http:' + input);\n            url.scheme = '';\n            url.type = 6 /* SchemeRelative */;\n            return url;\n        }\n        if (isAbsolutePath(input)) {\n            const url = parseAbsoluteUrl('http://foo.com' + input);\n            url.scheme = '';\n            url.host = '';\n            url.type = 5 /* AbsolutePath */;\n            return url;\n        }\n        if (isFileUrl(input))\n            return parseFileUrl(input);\n        if (isAbsoluteUrl(input))\n            return parseAbsoluteUrl(input);\n        const url = parseAbsoluteUrl('http://foo.com/' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = input\n            ? input.startsWith('?')\n                ? 3 /* Query */\n                : input.startsWith('#')\n                    ? 2 /* Hash */\n                    : 4 /* RelativePath */\n            : 1 /* Empty */;\n        return url;\n    }\n    function stripPathFilename(path) {\n        // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n        // paths. It's not a file, so we can't strip it.\n        if (path.endsWith('/..'))\n            return path;\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n    function mergePaths(url, base) {\n        normalizePath(base, base.type);\n        // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n        // path).\n        if (url.path === '/') {\n            url.path = base.path;\n        }\n        else {\n            // Resolution happens relative to the base path's directory, not the file.\n            url.path = stripPathFilename(base.path) + url.path;\n        }\n    }\n    /**\n     * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n     * \"foo/.\". We need to normalize to a standard representation.\n     */\n    function normalizePath(url, type) {\n        const rel = type <= 4 /* RelativePath */;\n        const pieces = url.path.split('/');\n        // We need to preserve the first piece always, so that we output a leading slash. The item at\n        // pieces[0] is an empty string.\n        let pointer = 1;\n        // Positive is the number of real directories we've output, used for popping a parent directory.\n        // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n        let positive = 0;\n        // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n        // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n        // real directory, we won't need to append, unless the other conditions happen again.\n        let addTrailingSlash = false;\n        for (let i = 1; i < pieces.length; i++) {\n            const piece = pieces[i];\n            // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n            if (!piece) {\n                addTrailingSlash = true;\n                continue;\n            }\n            // If we encounter a real directory, then we don't need to append anymore.\n            addTrailingSlash = false;\n            // A current directory, which we can always drop.\n            if (piece === '.')\n                continue;\n            // A parent directory, we need to see if there are any real directories we can pop. Else, we\n            // have an excess of parents, and we'll need to keep the \"..\".\n            if (piece === '..') {\n                if (positive) {\n                    addTrailingSlash = true;\n                    positive--;\n                    pointer--;\n                }\n                else if (rel) {\n                    // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                    // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                    pieces[pointer++] = piece;\n                }\n                continue;\n            }\n            // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n            // any popped or dropped directories.\n            pieces[pointer++] = piece;\n            positive++;\n        }\n        let path = '';\n        for (let i = 1; i < pointer; i++) {\n            path += '/' + pieces[i];\n        }\n        if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n            path += '/';\n        }\n        url.path = path;\n    }\n    /**\n     * Attempts to resolve `input` URL/path relative to `base`.\n     */\n    function resolve(input, base) {\n        if (!input && !base)\n            return '';\n        const url = parseUrl(input);\n        let inputType = url.type;\n        if (base && inputType !== 7 /* Absolute */) {\n            const baseUrl = parseUrl(base);\n            const baseType = baseUrl.type;\n            switch (inputType) {\n                case 1 /* Empty */:\n                    url.hash = baseUrl.hash;\n                // fall through\n                case 2 /* Hash */:\n                    url.query = baseUrl.query;\n                // fall through\n                case 3 /* Query */:\n                case 4 /* RelativePath */:\n                    mergePaths(url, baseUrl);\n                // fall through\n                case 5 /* AbsolutePath */:\n                    // The host, user, and port are joined, you can't copy one without the others.\n                    url.user = baseUrl.user;\n                    url.host = baseUrl.host;\n                    url.port = baseUrl.port;\n                // fall through\n                case 6 /* SchemeRelative */:\n                    // The input doesn't have a schema at least, so we need to copy at least that over.\n                    url.scheme = baseUrl.scheme;\n            }\n            if (baseType > inputType)\n                inputType = baseType;\n        }\n        normalizePath(url, inputType);\n        const queryHash = url.query + url.hash;\n        switch (inputType) {\n            // This is impossible, because of the empty checks at the start of the function.\n            // case UrlType.Empty:\n            case 2 /* Hash */:\n            case 3 /* Query */:\n                return queryHash;\n            case 4 /* RelativePath */: {\n                // The first char is always a \"/\", and we need it to be relative.\n                const path = url.path.slice(1);\n                if (!path)\n                    return queryHash || '.';\n                if (isRelative(base || input) && !isRelative(path)) {\n                    // If base started with a leading \".\", or there is no base and input started with a \".\",\n                    // then we need to ensure that the relative path starts with a \".\". We don't know if\n                    // relative starts with a \"..\", though, so check before prepending.\n                    return './' + path + queryHash;\n                }\n                return path + queryHash;\n            }\n            case 5 /* AbsolutePath */:\n                return url.path + queryHash;\n            default:\n                return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n        }\n    }\n\n    return resolve;\n\n}));\n//# sourceMappingURL=resolve-uri.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQyNC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUN5RztBQUM3RyxDQUFDLHVCQUF1Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmkvZGlzdC9yZXNvbHZlLXVyaS51bWQuanM/OTk2YSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5yZXNvbHZlVVJJID0gZmFjdG9yeSgpKTtcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8vIE1hdGNoZXMgdGhlIHNjaGVtZSBvZiBhIFVSTCwgZWcgXCJodHRwOi8vXCJcbiAgICBjb25zdCBzY2hlbWVSZWdleCA9IC9eW1xcdysuLV0rOlxcL1xcLy87XG4gICAgLyoqXG4gICAgICogTWF0Y2hlcyB0aGUgcGFydHMgb2YgYSBVUkw6XG4gICAgICogMS4gU2NoZW1lLCBpbmNsdWRpbmcgXCI6XCIsIGd1YXJhbnRlZWQuXG4gICAgICogMi4gVXNlci9wYXNzd29yZCwgaW5jbHVkaW5nIFwiQFwiLCBvcHRpb25hbC5cbiAgICAgKiAzLiBIb3N0LCBndWFyYW50ZWVkLlxuICAgICAqIDQuIFBvcnQsIGluY2x1ZGluZyBcIjpcIiwgb3B0aW9uYWwuXG4gICAgICogNS4gUGF0aCwgaW5jbHVkaW5nIFwiL1wiLCBvcHRpb25hbC5cbiAgICAgKiA2LiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA3LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IHVybFJlZ2V4ID0gL14oW1xcdysuLV0rOilcXC9cXC8oW15ALyM/XSpAKT8oW146LyM/XSopKDpcXGQrKT8oXFwvW14jP10qKT8oXFw/W14jXSopPygjLiopPy87XG4gICAgLyoqXG4gICAgICogRmlsZSBVUkxzIGFyZSB3ZWlyZC4gVGhleSBkb250JyBuZWVkIHRoZSByZWd1bGFyIGAvL2AgaW4gdGhlIHNjaGVtZSwgdGhleSBtYXkgb3IgbWF5IG5vdCBzdGFydFxuICAgICAqIHdpdGggYSBsZWFkaW5nIGAvYCwgdGhleSBjYW4gaGF2ZSBhIGRvbWFpbiAoYnV0IG9ubHkgaWYgdGhleSBkb24ndCBzdGFydCB3aXRoIGEgV2luZG93cyBkcml2ZSkuXG4gICAgICpcbiAgICAgKiAxLiBIb3N0LCBvcHRpb25hbC5cbiAgICAgKiAyLiBQYXRoLCB3aGljaCBtYXkgaW5jbHVkZSBcIi9cIiwgZ3VhcmFudGVlZC5cbiAgICAgKiAzLiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAgICAgKiA0LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIGNvbnN0IGZpbGVSZWdleCA9IC9eZmlsZTooPzpcXC9cXC8oKD8hW2Etel06KVteLyM/XSopPyk/KFxcLz9bXiM/XSopKFxcP1teI10qKT8oIy4qKT8vaTtcbiAgICBmdW5jdGlvbiBpc0Fic29sdXRlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzY2hlbWVSZWdleC50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTY2hlbWVSZWxhdGl2ZVVybChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnLy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNGaWxlVXJsKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCdmaWxlOicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc1JlbGF0aXZlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAvXlsuPyNdLy50ZXN0KGlucHV0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybFJlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgICAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZpbGVVcmwoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBtYXRjaFsyXTtcbiAgICAgICAgcmV0dXJuIG1ha2VVcmwoJ2ZpbGU6JywgJycsIG1hdGNoWzFdIHx8ICcnLCAnJywgaXNBYnNvbHV0ZVBhdGgocGF0aCkgPyBwYXRoIDogJy8nICsgcGF0aCwgbWF0Y2hbM10gfHwgJycsIG1hdGNoWzRdIHx8ICcnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVVybChzY2hlbWUsIHVzZXIsIGhvc3QsIHBvcnQsIHBhdGgsIHF1ZXJ5LCBoYXNoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzY2hlbWUsXG4gICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBoYXNoLFxuICAgICAgICAgICAgdHlwZTogNyAvKiBBYnNvbHV0ZSAqLyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVcmwoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlzU2NoZW1lUmVsYXRpdmVVcmwoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgICAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDYgLyogU2NoZW1lUmVsYXRpdmUgKi87XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Fic29sdXRlUGF0aChpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICAgICAgICB1cmwudHlwZSA9IDUgLyogQWJzb2x1dGVQYXRoICovO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZpbGVVcmwoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZVVybChpbnB1dCkpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tLycgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSBpbnB1dFxuICAgICAgICAgICAgPyBpbnB1dC5zdGFydHNXaXRoKCc/JylcbiAgICAgICAgICAgICAgICA/IDMgLyogUXVlcnkgKi9cbiAgICAgICAgICAgICAgICA6IGlucHV0LnN0YXJ0c1dpdGgoJyMnKVxuICAgICAgICAgICAgICAgICAgICA/IDIgLyogSGFzaCAqL1xuICAgICAgICAgICAgICAgICAgICA6IDQgLyogUmVsYXRpdmVQYXRoICovXG4gICAgICAgICAgICA6IDEgLyogRW1wdHkgKi87XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0cmlwUGF0aEZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgLy8gSWYgYSBwYXRoIGVuZHMgd2l0aCBhIHBhcmVudCBkaXJlY3RvcnkgXCIuLlwiLCB0aGVuIGl0J3MgYSByZWxhdGl2ZSBwYXRoIHdpdGggZXhjZXNzIHBhcmVudFxuICAgICAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy8uLicpKVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBpbmRleCArIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgICAgICBub3JtYWxpemVQYXRoKGJhc2UsIGJhc2UudHlwZSk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIGp1c3QgYSBcIi9cIiwgdGhlbiBpdCB3YXMgYW4gZW1wdHkgcGF0aCB0byBiZWdpbiB3aXRoIChyZW1lbWJlciwgd2UncmUgYSByZWxhdGl2ZVxuICAgICAgICAvLyBwYXRoKS5cbiAgICAgICAgaWYgKHVybC5wYXRoID09PSAnLycpIHtcbiAgICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzb2x1dGlvbiBoYXBwZW5zIHJlbGF0aXZlIHRvIHRoZSBiYXNlIHBhdGgncyBkaXJlY3RvcnksIG5vdCB0aGUgZmlsZS5cbiAgICAgICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIGNhbiBoYXZlIGVtcHR5IGRpcmVjdG9yaWVzIFwiLy9cIiwgdW5uZWVkZWQgcGFyZW50cyBcImZvby8uLlwiLCBvciBjdXJyZW50IGRpcmVjdG9yeVxuICAgICAqIFwiZm9vLy5cIi4gV2UgbmVlZCB0byBub3JtYWxpemUgdG8gYSBzdGFuZGFyZCByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVQYXRoKHVybCwgdHlwZSkge1xuICAgICAgICBjb25zdCByZWwgPSB0eXBlIDw9IDQgLyogUmVsYXRpdmVQYXRoICovO1xuICAgICAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIHByZXNlcnZlIHRoZSBmaXJzdCBwaWVjZSBhbHdheXMsIHNvIHRoYXQgd2Ugb3V0cHV0IGEgbGVhZGluZyBzbGFzaC4gVGhlIGl0ZW0gYXRcbiAgICAgICAgLy8gcGllY2VzWzBdIGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgICAgICAvLyBQb3NpdGl2ZSBpcyB0aGUgbnVtYmVyIG9mIHJlYWwgZGlyZWN0b3JpZXMgd2UndmUgb3V0cHV0LCB1c2VkIGZvciBwb3BwaW5nIGEgcGFyZW50IGRpcmVjdG9yeS5cbiAgICAgICAgLy8gRWcsIFwiZm9vL2Jhci8uLlwiIHdpbGwgaGF2ZSBhIHBvc2l0aXZlIDIsIGFuZCB3ZSBjYW4gZGVjcmVtZW50IHRvIGJlIGxlZnQgd2l0aCBqdXN0IFwiZm9vXCIuXG4gICAgICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8ga2VlcCBhIHRyYWlsaW5nIHNsYXNoIGlmIHdlIGVuY291bnRlciBhbiBlbXB0eSBkaXJlY3RvcnkgKGVnLCBzcGxpdHRpbmcgXCJmb28vXCIgd2lsbFxuICAgICAgICAvLyBnZW5lcmF0ZSBgW1wiZm9vXCIsIFwiXCJdYCBwaWVjZXMpLiBBbmQsIGlmIHdlIHBvcCBhIHBhcmVudCBkaXJlY3RvcnkuIEJ1dCBvbmNlIHdlIGVuY291bnRlciBhXG4gICAgICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICAgICAgbGV0IGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAgICAgLy8gQW4gZW1wdHkgZGlyZWN0b3J5LCBjb3VsZCBiZSBhIHRyYWlsaW5nIHNsYXNoLCBvciBqdXN0IGEgZG91YmxlIFwiLy9cIiBpbiB0aGUgcGF0aC5cbiAgICAgICAgICAgIGlmICghcGllY2UpIHtcbiAgICAgICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBBIGN1cnJlbnQgZGlyZWN0b3J5LCB3aGljaCB3ZSBjYW4gYWx3YXlzIGRyb3AuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEEgcGFyZW50IGRpcmVjdG9yeSwgd2UgbmVlZCB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSByZWFsIGRpcmVjdG9yaWVzIHdlIGNhbiBwb3AuIEVsc2UsIHdlXG4gICAgICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgICAgICBpZiAocGllY2UgPT09ICcuLicpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlLS07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGluIGEgcmVsYXRpdmVQYXRoLCB0aGVuIHdlIG5lZWQgdG8ga2VlcCB0aGUgZXhjZXNzIHBhcmVudHMuIEVsc2UsIGluIGFuIGFic29sdXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGVuY291bnRlcmVkIGEgcmVhbCBkaXJlY3RvcnkuIE1vdmUgaXQgdG8gdGhlIG5leHQgaW5zZXJ0aW9uIHBvaW50ZXIsIHdoaWNoIGFjY291bnRzIGZvclxuICAgICAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICAgICAgcGllY2VzW3BvaW50ZXIrK10gPSBwaWVjZTtcbiAgICAgICAgICAgIHBvc2l0aXZlKys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludGVyOyBpKyspIHtcbiAgICAgICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGF0aCB8fCAoYWRkVHJhaWxpbmdTbGFzaCAmJiAhcGF0aC5lbmRzV2l0aCgnLy4uJykpKSB7XG4gICAgICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgICAgfVxuICAgICAgICB1cmwucGF0aCA9IHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHJlc29sdmUgYGlucHV0YCBVUkwvcGF0aCByZWxhdGl2ZSB0byBgYmFzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpbnB1dCwgYmFzZSkge1xuICAgICAgICBpZiAoIWlucHV0ICYmICFiYXNlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZVVybChpbnB1dCk7XG4gICAgICAgIGxldCBpbnB1dFR5cGUgPSB1cmwudHlwZTtcbiAgICAgICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSA3IC8qIEFic29sdXRlICovKSB7XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gcGFyc2VVcmwoYmFzZSk7XG4gICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IGJhc2VVcmwudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIEVtcHR5ICovOlxuICAgICAgICAgICAgICAgICAgICB1cmwuaGFzaCA9IGJhc2VVcmwuaGFzaDtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZVVybC5xdWVyeTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIDMgLyogUXVlcnkgKi86XG4gICAgICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzpcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgICAgICB1cmwudXNlciA9IGJhc2VVcmwudXNlcjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlVXJsLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgNiAvKiBTY2hlbWVSZWxhdGl2ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2VVcmwuc2NoZW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgICAgIGlucHV0VHlwZSA9IGJhc2VUeXBlO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgICAgICBjb25zdCBxdWVyeUhhc2ggPSB1cmwucXVlcnkgKyB1cmwuaGFzaDtcbiAgICAgICAgc3dpdGNoIChpbnB1dFR5cGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAgICAvLyBjYXNlIFVybFR5cGUuRW1wdHk6XG4gICAgICAgICAgICBjYXNlIDIgLyogSGFzaCAqLzpcbiAgICAgICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoO1xuICAgICAgICAgICAgY2FzZSA0IC8qIFJlbGF0aXZlUGF0aCAqLzoge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gdXJsLnBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxhdGl2ZShiYXNlIHx8IGlucHV0KSAmJiAhaXNSZWxhdGl2ZShwYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBiYXNlIHN0YXJ0ZWQgd2l0aCBhIGxlYWRpbmcgXCIuXCIsIG9yIHRoZXJlIGlzIG5vIGJhc2UgYW5kIGlucHV0IHN0YXJ0ZWQgd2l0aCBhIFwiLlwiLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgICAgICAvLyByZWxhdGl2ZSBzdGFydHMgd2l0aCBhIFwiLi5cIiwgdGhvdWdoLCBzbyBjaGVjayBiZWZvcmUgcHJlcGVuZGluZy5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuLycgKyBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybC5wYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXNvbHZlO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLXVyaS51bWQuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4424\n")},13534:function(__unused_webpack_module,exports){eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    /**\n     * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n     * index of the `key` in the backing array.\n     *\n     * This is designed to allow synchronizing a second array with the contents of the backing array,\n     * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n     * and there are never duplicates.\n     */\n    class SetArray {\n        constructor() {\n            this._indexes = { __proto__: null };\n            this.array = [];\n        }\n    }\n    /**\n     * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n     * with public access modifiers.\n     */\n    function cast(set) {\n        return set;\n    }\n    /**\n     * Gets the index associated with `key` in the backing array, if it is already present.\n     */\n    function get(setarr, key) {\n        return cast(setarr)._indexes[key];\n    }\n    /**\n     * Puts `key` into the backing array, if it is not already present. Returns\n     * the index of the `key` in the backing array.\n     */\n    function put(setarr, key) {\n        // The key may or may not be present. If it is present, it's a number.\n        const index = get(setarr, key);\n        if (index !== undefined)\n            return index;\n        const { array, _indexes: indexes } = cast(setarr);\n        const length = array.push(key);\n        return (indexes[key] = length - 1);\n    }\n    /**\n     * Pops the last added item out of the SetArray.\n     */\n    function pop(setarr) {\n        const { array, _indexes: indexes } = cast(setarr);\n        if (array.length === 0)\n            return;\n        const last = array.pop();\n        indexes[last] = undefined;\n    }\n    /**\n     * Removes the key, if it exists in the set.\n     */\n    function remove(setarr, key) {\n        const index = get(setarr, key);\n        if (index === undefined)\n            return;\n        const { array, _indexes: indexes } = cast(setarr);\n        for (let i = index + 1; i < array.length; i++) {\n            const k = array[i];\n            array[i - 1] = k;\n            indexes[k]--;\n        }\n        indexes[key] = undefined;\n        array.pop();\n    }\n\n    exports.SetArray = SetArray;\n    exports.get = get;\n    exports.pop = pop;\n    exports.put = put;\n    exports.remove = remove;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=set-array.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1MzQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDeUc7QUFDN0csQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQyxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbURBQW1ELGFBQWE7O0FBRWhFLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvc2V0LWFycmF5L2Rpc3Qvc2V0LWFycmF5LnVtZC5qcz9jZTdmIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuc2V0QXJyYXkgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKlxuICAgICAqIFNldEFycmF5IGFjdHMgbGlrZSBhIGBTZXRgIChhbGxvd2luZyBvbmx5IG9uZSBvY2N1cnJlbmNlIG9mIGEgc3RyaW5nIGBrZXlgKSwgYnV0IHByb3ZpZGVzIHRoZVxuICAgICAqIGluZGV4IG9mIHRoZSBga2V5YCBpbiB0aGUgYmFja2luZyBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZGVzaWduZWQgdG8gYWxsb3cgc3luY2hyb25pemluZyBhIHNlY29uZCBhcnJheSB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgYmFja2luZyBhcnJheSxcbiAgICAgKiBsaWtlIGhvdyBpbiBhIHNvdXJjZW1hcCBgc291cmNlc0NvbnRlbnRbaV1gIGlzIHRoZSBzb3VyY2UgY29udGVudCBhc3NvY2lhdGVkIHdpdGggYHNvdXJjZVtpXWAsXG4gICAgICogYW5kIHRoZXJlIGFyZSBuZXZlciBkdXBsaWNhdGVzLlxuICAgICAqL1xuICAgIGNsYXNzIFNldEFycmF5IHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRleGVzID0geyBfX3Byb3RvX186IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlc2NyaXB0IGRvZXNuJ3QgYWxsb3cgZnJpZW5kIGFjY2VzcyB0byBwcml2YXRlIGZpZWxkcywgc28gdGhpcyBqdXN0IGNhc3RzIHRoZSBzZXQgaW50byBhIHR5cGVcbiAgICAgKiB3aXRoIHB1YmxpYyBhY2Nlc3MgbW9kaWZpZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3Qoc2V0KSB7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGluZGV4IGFzc29jaWF0ZWQgd2l0aCBga2V5YCBpbiB0aGUgYmFja2luZyBhcnJheSwgaWYgaXQgaXMgYWxyZWFkeSBwcmVzZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldChzZXRhcnIsIGtleSkge1xuICAgICAgICByZXR1cm4gY2FzdChzZXRhcnIpLl9pbmRleGVzW2tleV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1dHMgYGtleWAgaW50byB0aGUgYmFja2luZyBhcnJheSwgaWYgaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudC4gUmV0dXJuc1xuICAgICAqIHRoZSBpbmRleCBvZiB0aGUgYGtleWAgaW4gdGhlIGJhY2tpbmcgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHV0KHNldGFyciwga2V5KSB7XG4gICAgICAgIC8vIFRoZSBrZXkgbWF5IG9yIG1heSBub3QgYmUgcHJlc2VudC4gSWYgaXQgaXMgcHJlc2VudCwgaXQncyBhIG51bWJlci5cbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXQoc2V0YXJyLCBrZXkpO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgY29uc3QgeyBhcnJheSwgX2luZGV4ZXM6IGluZGV4ZXMgfSA9IGNhc3Qoc2V0YXJyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXkucHVzaChrZXkpO1xuICAgICAgICByZXR1cm4gKGluZGV4ZXNba2V5XSA9IGxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3BzIHRoZSBsYXN0IGFkZGVkIGl0ZW0gb3V0IG9mIHRoZSBTZXRBcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwb3Aoc2V0YXJyKSB7XG4gICAgICAgIGNvbnN0IHsgYXJyYXksIF9pbmRleGVzOiBpbmRleGVzIH0gPSBjYXN0KHNldGFycik7XG4gICAgICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGxhc3QgPSBhcnJheS5wb3AoKTtcbiAgICAgICAgaW5kZXhlc1tsYXN0XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUga2V5LCBpZiBpdCBleGlzdHMgaW4gdGhlIHNldC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZW1vdmUoc2V0YXJyLCBrZXkpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXQoc2V0YXJyLCBrZXkpO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhcnJheSwgX2luZGV4ZXM6IGluZGV4ZXMgfSA9IGNhc3Qoc2V0YXJyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gYXJyYXlbaV07XG4gICAgICAgICAgICBhcnJheVtpIC0gMV0gPSBrO1xuICAgICAgICAgICAgaW5kZXhlc1trXS0tO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ZXNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgYXJyYXkucG9wKCk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5TZXRBcnJheSA9IFNldEFycmF5O1xuICAgIGV4cG9ydHMuZ2V0ID0gZ2V0O1xuICAgIGV4cG9ydHMucG9wID0gcG9wO1xuICAgIGV4cG9ydHMucHV0ID0gcHV0O1xuICAgIGV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0LWFycmF5LnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13534\n")},44318:function(__unused_webpack_module,exports){eval("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    const comma = ','.charCodeAt(0);\n    const semicolon = ';'.charCodeAt(0);\n    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const intToChar = new Uint8Array(64); // 64 possible chars.\n    const charToInt = new Uint8Array(128); // z is 122 in ASCII\n    for (let i = 0; i < chars.length; i++) {\n        const c = chars.charCodeAt(i);\n        intToChar[i] = c;\n        charToInt[c] = i;\n    }\n    // Provide a fallback for older environments.\n    const td = typeof TextDecoder !== 'undefined'\n        ? /* #__PURE__ */ new TextDecoder()\n        : typeof Buffer !== 'undefined'\n            ? {\n                decode(buf) {\n                    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                    return out.toString();\n                },\n            }\n            : {\n                decode(buf) {\n                    let out = '';\n                    for (let i = 0; i < buf.length; i++) {\n                        out += String.fromCharCode(buf[i]);\n                    }\n                    return out;\n                },\n            };\n    function decode(mappings) {\n        const state = new Int32Array(5);\n        const decoded = [];\n        let index = 0;\n        do {\n            const semi = indexOf(mappings, index);\n            const line = [];\n            let sorted = true;\n            let lastCol = 0;\n            state[0] = 0;\n            for (let i = index; i < semi; i++) {\n                let seg;\n                i = decodeInteger(mappings, i, state, 0); // genColumn\n                const col = state[0];\n                if (col < lastCol)\n                    sorted = false;\n                lastCol = col;\n                if (hasMoreVlq(mappings, i, semi)) {\n                    i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n                    i = decodeInteger(mappings, i, state, 2); // sourceLine\n                    i = decodeInteger(mappings, i, state, 3); // sourceColumn\n                    if (hasMoreVlq(mappings, i, semi)) {\n                        i = decodeInteger(mappings, i, state, 4); // namesIndex\n                        seg = [col, state[1], state[2], state[3], state[4]];\n                    }\n                    else {\n                        seg = [col, state[1], state[2], state[3]];\n                    }\n                }\n                else {\n                    seg = [col];\n                }\n                line.push(seg);\n            }\n            if (!sorted)\n                sort(line);\n            decoded.push(line);\n            index = semi + 1;\n        } while (index <= mappings.length);\n        return decoded;\n    }\n    function indexOf(mappings, index) {\n        const idx = mappings.indexOf(';', index);\n        return idx === -1 ? mappings.length : idx;\n    }\n    function decodeInteger(mappings, pos, state, j) {\n        let value = 0;\n        let shift = 0;\n        let integer = 0;\n        do {\n            const c = mappings.charCodeAt(pos++);\n            integer = charToInt[c];\n            value |= (integer & 31) << shift;\n            shift += 5;\n        } while (integer & 32);\n        const shouldNegate = value & 1;\n        value >>>= 1;\n        if (shouldNegate) {\n            value = -0x80000000 | -value;\n        }\n        state[j] += value;\n        return pos;\n    }\n    function hasMoreVlq(mappings, i, length) {\n        if (i >= length)\n            return false;\n        return mappings.charCodeAt(i) !== comma;\n    }\n    function sort(line) {\n        line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[0] - b[0];\n    }\n    function encode(decoded) {\n        const state = new Int32Array(5);\n        const bufLength = 1024 * 16;\n        const subLength = bufLength - 36;\n        const buf = new Uint8Array(bufLength);\n        const sub = buf.subarray(0, subLength);\n        let pos = 0;\n        let out = '';\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            if (i > 0) {\n                if (pos === bufLength) {\n                    out += td.decode(buf);\n                    pos = 0;\n                }\n                buf[pos++] = semicolon;\n            }\n            if (line.length === 0)\n                continue;\n            state[0] = 0;\n            for (let j = 0; j < line.length; j++) {\n                const segment = line[j];\n                // We can push up to 5 ints, each int can take at most 7 chars, and we\n                // may push a comma.\n                if (pos > subLength) {\n                    out += td.decode(sub);\n                    buf.copyWithin(0, subLength, pos);\n                    pos -= subLength;\n                }\n                if (j > 0)\n                    buf[pos++] = comma;\n                pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n                if (segment.length === 1)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n                pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n                pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n                if (segment.length === 4)\n                    continue;\n                pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n            }\n        }\n        return out + td.decode(buf.subarray(0, pos));\n    }\n    function encodeInteger(buf, pos, state, segment, j) {\n        const next = segment[j];\n        let num = next - state[j];\n        state[j] = next;\n        num = num < 0 ? (-num << 1) | 1 : num << 1;\n        do {\n            let clamped = num & 0b011111;\n            num >>>= 5;\n            if (num > 0)\n                clamped |= 0b100000;\n            buf[pos++] = intToChar[clamped];\n        } while (num > 0);\n        return pos;\n    }\n\n    exports.decode = decode;\n    exports.encode = encode;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=sourcemap-codec.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQzMTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTREO0FBQ2hFLElBQUksQ0FDK0c7QUFDbkgsQ0FBQyw4QkFBOEI7O0FBRS9CO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMENBQTBDO0FBQzFDLDJDQUEyQztBQUMzQyxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDhEQUE4RDtBQUM5RCw4REFBOEQ7QUFDOUQ7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSxrRUFBa0U7QUFDbEUsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtREFBbUQsYUFBYTs7QUFFaEUsQ0FBQztBQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMudW1kLmpzP2E4NWMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBmYWN0b3J5KGdsb2JhbC5zb3VyY2VtYXBDb2RlYyA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgY29uc3QgY29tbWEgPSAnLCcuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBzZW1pY29sb24gPSAnOycuY2hhckNvZGVBdCgwKTtcbiAgICBjb25zdCBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbiAgICBjb25zdCBpbnRUb0NoYXIgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIDY0IHBvc3NpYmxlIGNoYXJzLlxuICAgIGNvbnN0IGNoYXJUb0ludCA9IG5ldyBVaW50OEFycmF5KDEyOCk7IC8vIHogaXMgMTIyIGluIEFTQ0lJXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0gY2hhcnMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaW50VG9DaGFyW2ldID0gYztcbiAgICAgICAgY2hhclRvSW50W2NdID0gaTtcbiAgICB9XG4gICAgLy8gUHJvdmlkZSBhIGZhbGxiYWNrIGZvciBvbGRlciBlbnZpcm9ubWVudHMuXG4gICAgY29uc3QgdGQgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gLyogI19fUFVSRV9fICovIG5ldyBUZXh0RGVjb2RlcigpXG4gICAgICAgIDogdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIGRlY29kZShidWYpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gQnVmZmVyLmZyb20oYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBkZWNvZGUoYnVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICBmdW5jdGlvbiBkZWNvZGUobWFwcGluZ3MpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBzZW1pID0gaW5kZXhPZihtYXBwaW5ncywgaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IFtdO1xuICAgICAgICAgICAgbGV0IHNvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBsZXQgbGFzdENvbCA9IDA7XG4gICAgICAgICAgICBzdGF0ZVswXSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCBzZW1pOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc2VnO1xuICAgICAgICAgICAgICAgIGkgPSBkZWNvZGVJbnRlZ2VyKG1hcHBpbmdzLCBpLCBzdGF0ZSwgMCk7IC8vIGdlbkNvbHVtblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHN0YXRlWzBdO1xuICAgICAgICAgICAgICAgIGlmIChjb2wgPCBsYXN0Q29sKVxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsYXN0Q29sID0gY29sO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNb3JlVmxxKG1hcHBpbmdzLCBpLCBzZW1pKSkge1xuICAgICAgICAgICAgICAgICAgICBpID0gZGVjb2RlSW50ZWdlcihtYXBwaW5ncywgaSwgc3RhdGUsIDEpOyAvLyBzb3VyY2VzSW5kZXhcbiAgICAgICAgICAgICAgICAgICAgaSA9IGRlY29kZUludGVnZXIobWFwcGluZ3MsIGksIHN0YXRlLCAyKTsgLy8gc291cmNlTGluZVxuICAgICAgICAgICAgICAgICAgICBpID0gZGVjb2RlSW50ZWdlcihtYXBwaW5ncywgaSwgc3RhdGUsIDMpOyAvLyBzb3VyY2VDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc01vcmVWbHEobWFwcGluZ3MsIGksIHNlbWkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gZGVjb2RlSW50ZWdlcihtYXBwaW5ncywgaSwgc3RhdGUsIDQpOyAvLyBuYW1lc0luZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcgPSBbY29sLCBzdGF0ZVsxXSwgc3RhdGVbMl0sIHN0YXRlWzNdLCBzdGF0ZVs0XV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcgPSBbY29sLCBzdGF0ZVsxXSwgc3RhdGVbMl0sIHN0YXRlWzNdXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnID0gW2NvbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpbmUucHVzaChzZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzb3J0ZWQpXG4gICAgICAgICAgICAgICAgc29ydChsaW5lKTtcbiAgICAgICAgICAgIGRlY29kZWQucHVzaChsaW5lKTtcbiAgICAgICAgICAgIGluZGV4ID0gc2VtaSArIDE7XG4gICAgICAgIH0gd2hpbGUgKGluZGV4IDw9IG1hcHBpbmdzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbmRleE9mKG1hcHBpbmdzLCBpbmRleCkge1xuICAgICAgICBjb25zdCBpZHggPSBtYXBwaW5ncy5pbmRleE9mKCc7JywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gaWR4ID09PSAtMSA/IG1hcHBpbmdzLmxlbmd0aCA6IGlkeDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlSW50ZWdlcihtYXBwaW5ncywgcG9zLCBzdGF0ZSwgaikge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICBsZXQgaW50ZWdlciA9IDA7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBtYXBwaW5ncy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICAgICAgICAgIGludGVnZXIgPSBjaGFyVG9JbnRbY107XG4gICAgICAgICAgICB2YWx1ZSB8PSAoaW50ZWdlciAmIDMxKSA8PCBzaGlmdDtcbiAgICAgICAgICAgIHNoaWZ0ICs9IDU7XG4gICAgICAgIH0gd2hpbGUgKGludGVnZXIgJiAzMik7XG4gICAgICAgIGNvbnN0IHNob3VsZE5lZ2F0ZSA9IHZhbHVlICYgMTtcbiAgICAgICAgdmFsdWUgPj4+PSAxO1xuICAgICAgICBpZiAoc2hvdWxkTmVnYXRlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IC0weDgwMDAwMDAwIHwgLXZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlW2pdICs9IHZhbHVlO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYXNNb3JlVmxxKG1hcHBpbmdzLCBpLCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gbWFwcGluZ3MuY2hhckNvZGVBdChpKSAhPT0gY29tbWE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNvcnQobGluZSkge1xuICAgICAgICBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzb3J0Q29tcGFyYXRvcihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhWzBdIC0gYlswXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKGRlY29kZWQpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBuZXcgSW50MzJBcnJheSg1KTtcbiAgICAgICAgY29uc3QgYnVmTGVuZ3RoID0gMTAyNCAqIDE2O1xuICAgICAgICBjb25zdCBzdWJMZW5ndGggPSBidWZMZW5ndGggLSAzNjtcbiAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmTGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc3ViID0gYnVmLnN1YmFycmF5KDAsIHN1Ykxlbmd0aCk7XG4gICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zID09PSBidWZMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9IHRkLmRlY29kZShidWYpO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZbcG9zKytdID0gc2VtaWNvbG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgc3RhdGVbMF0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IGxpbmVbal07XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIHB1c2ggdXAgdG8gNSBpbnRzLCBlYWNoIGludCBjYW4gdGFrZSBhdCBtb3N0IDcgY2hhcnMsIGFuZCB3ZVxuICAgICAgICAgICAgICAgIC8vIG1heSBwdXNoIGEgY29tbWEuXG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IHN1Ykxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gdGQuZGVjb2RlKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5jb3B5V2l0aGluKDAsIHN1Ykxlbmd0aCwgcG9zKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zIC09IHN1Ykxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPiAwKVxuICAgICAgICAgICAgICAgICAgICBidWZbcG9zKytdID0gY29tbWE7XG4gICAgICAgICAgICAgICAgcG9zID0gZW5jb2RlSW50ZWdlcihidWYsIHBvcywgc3RhdGUsIHNlZ21lbnQsIDApOyAvLyBnZW5Db2x1bW5cbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IGVuY29kZUludGVnZXIoYnVmLCBwb3MsIHN0YXRlLCBzZWdtZW50LCAxKTsgLy8gc291cmNlc0luZGV4XG4gICAgICAgICAgICAgICAgcG9zID0gZW5jb2RlSW50ZWdlcihidWYsIHBvcywgc3RhdGUsIHNlZ21lbnQsIDIpOyAvLyBzb3VyY2VMaW5lXG4gICAgICAgICAgICAgICAgcG9zID0gZW5jb2RlSW50ZWdlcihidWYsIHBvcywgc3RhdGUsIHNlZ21lbnQsIDMpOyAvLyBzb3VyY2VDb2x1bW5cbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPT09IDQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHBvcyA9IGVuY29kZUludGVnZXIoYnVmLCBwb3MsIHN0YXRlLCBzZWdtZW50LCA0KTsgLy8gbmFtZXNJbmRleFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQgKyB0ZC5kZWNvZGUoYnVmLnN1YmFycmF5KDAsIHBvcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVJbnRlZ2VyKGJ1ZiwgcG9zLCBzdGF0ZSwgc2VnbWVudCwgaikge1xuICAgICAgICBjb25zdCBuZXh0ID0gc2VnbWVudFtqXTtcbiAgICAgICAgbGV0IG51bSA9IG5leHQgLSBzdGF0ZVtqXTtcbiAgICAgICAgc3RhdGVbal0gPSBuZXh0O1xuICAgICAgICBudW0gPSBudW0gPCAwID8gKC1udW0gPDwgMSkgfCAxIDogbnVtIDw8IDE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGxldCBjbGFtcGVkID0gbnVtICYgMGIwMTExMTE7XG4gICAgICAgICAgICBudW0gPj4+PSA1O1xuICAgICAgICAgICAgaWYgKG51bSA+IDApXG4gICAgICAgICAgICAgICAgY2xhbXBlZCB8PSAwYjEwMDAwMDtcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSBpbnRUb0NoYXJbY2xhbXBlZF07XG4gICAgICAgIH0gd2hpbGUgKG51bSA+IDApO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuICAgIGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuICAgIGV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c291cmNlbWFwLWNvZGVjLnVtZC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44318\n")},92802:function(__unused_webpack_module,exports,__webpack_require__){eval("(function (global, factory) {\n     true ? factory(exports, __webpack_require__(44318), __webpack_require__(4424)) :\n    0;\n})(this, (function (exports, sourcemapCodec, resolveUri) { 'use strict';\n\n    function resolve(input, base) {\n        // The base is always treated as a directory, if it's not empty.\n        // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n        // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n        if (base && !base.endsWith('/'))\n            base += '/';\n        return resolveUri(input, base);\n    }\n\n    /**\n     * Removes everything after the last \"/\", but leaves the slash.\n     */\n    function stripFilename(path) {\n        if (!path)\n            return '';\n        const index = path.lastIndexOf('/');\n        return path.slice(0, index + 1);\n    }\n\n    const COLUMN = 0;\n    const SOURCES_INDEX = 1;\n    const SOURCE_LINE = 2;\n    const SOURCE_COLUMN = 3;\n    const NAMES_INDEX = 4;\n    const REV_GENERATED_LINE = 1;\n    const REV_GENERATED_COLUMN = 2;\n\n    function maybeSort(mappings, owned) {\n        const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n        if (unsortedIndex === mappings.length)\n            return mappings;\n        // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n        // not, we do not want to modify the consumer's input array.\n        if (!owned)\n            mappings = mappings.slice();\n        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n            mappings[i] = sortSegments(mappings[i], owned);\n        }\n        return mappings;\n    }\n    function nextUnsortedSegmentLine(mappings, start) {\n        for (let i = start; i < mappings.length; i++) {\n            if (!isSorted(mappings[i]))\n                return i;\n        }\n        return mappings.length;\n    }\n    function isSorted(line) {\n        for (let j = 1; j < line.length; j++) {\n            if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function sortSegments(line, owned) {\n        if (!owned)\n            line = line.slice();\n        return line.sort(sortComparator);\n    }\n    function sortComparator(a, b) {\n        return a[COLUMN] - b[COLUMN];\n    }\n\n    let found = false;\n    /**\n     * A binary search implementation that returns the index if a match is found.\n     * If no match is found, then the left-index (the index associated with the item that comes just\n     * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n     * the next index:\n     *\n     * ```js\n     * const array = [1, 3];\n     * const needle = 2;\n     * const index = binarySearch(array, needle, (item, needle) => item - needle);\n     *\n     * assert.equal(index, 0);\n     * array.splice(index + 1, 0, needle);\n     * assert.deepEqual(array, [1, 2, 3]);\n     * ```\n     */\n    function binarySearch(haystack, needle, low, high) {\n        while (low <= high) {\n            const mid = low + ((high - low) >> 1);\n            const cmp = haystack[mid][COLUMN] - needle;\n            if (cmp === 0) {\n                found = true;\n                return mid;\n            }\n            if (cmp < 0) {\n                low = mid + 1;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        found = false;\n        return low - 1;\n    }\n    function upperBound(haystack, needle, index) {\n        for (let i = index + 1; i < haystack.length; index = i++) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function lowerBound(haystack, needle, index) {\n        for (let i = index - 1; i >= 0; index = i--) {\n            if (haystack[i][COLUMN] !== needle)\n                break;\n        }\n        return index;\n    }\n    function memoizedState() {\n        return {\n            lastKey: -1,\n            lastNeedle: -1,\n            lastIndex: -1,\n        };\n    }\n    /**\n     * This overly complicated beast is just to record the last tested line/column and the resulting\n     * index, allowing us to skip a few tests if mappings are monotonically increasing.\n     */\n    function memoizedBinarySearch(haystack, needle, state, key) {\n        const { lastKey, lastNeedle, lastIndex } = state;\n        let low = 0;\n        let high = haystack.length - 1;\n        if (key === lastKey) {\n            if (needle === lastNeedle) {\n                found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n                return lastIndex;\n            }\n            if (needle >= lastNeedle) {\n                // lastIndex may be -1 if the previous needle was not found.\n                low = lastIndex === -1 ? 0 : lastIndex;\n            }\n            else {\n                high = lastIndex;\n            }\n        }\n        state.lastKey = key;\n        state.lastNeedle = needle;\n        return (state.lastIndex = binarySearch(haystack, needle, low, high));\n    }\n\n    // Rebuilds the original source files, with mappings that are ordered by source line/column instead\n    // of generated line/column.\n    function buildBySources(decoded, memos) {\n        const sources = memos.map(buildNullArray);\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                if (seg.length === 1)\n                    continue;\n                const sourceIndex = seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                const originalSource = sources[sourceIndex];\n                const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n                const memo = memos[sourceIndex];\n                // The binary search either found a match, or it found the left-index just before where the\n                // segment should go. Either way, we want to insert after that. And there may be multiple\n                // generated segments associated with an original location, so there may need to move several\n                // indexes before we find where we need to insert.\n                let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n                memo.lastIndex = ++index;\n                insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n            }\n        }\n        return sources;\n    }\n    function insert(array, index, value) {\n        for (let i = array.length; i > index; i--) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    // Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n    // a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n    // Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n    // the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n    // order when iterating with for-in.\n    function buildNullArray() {\n        return { __proto__: null };\n    }\n\n    const AnyMap = function (map, mapUrl) {\n        const parsed = parse(map);\n        if (!('sections' in parsed)) {\n            return new TraceMap(parsed, mapUrl);\n        }\n        const mappings = [];\n        const sources = [];\n        const sourcesContent = [];\n        const names = [];\n        const ignoreList = [];\n        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n        const joined = {\n            version: 3,\n            file: parsed.file,\n            names,\n            sources,\n            sourcesContent,\n            mappings,\n            ignoreList,\n        };\n        return presortedDecodedMap(joined);\n    };\n    function parse(map) {\n        return typeof map === 'string' ? JSON.parse(map) : map;\n    }\n    function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n        const { sections } = input;\n        for (let i = 0; i < sections.length; i++) {\n            const { map, offset } = sections[i];\n            let sl = stopLine;\n            let sc = stopColumn;\n            if (i + 1 < sections.length) {\n                const nextOffset = sections[i + 1].offset;\n                sl = Math.min(stopLine, lineOffset + nextOffset.line);\n                if (sl === stopLine) {\n                    sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n                }\n                else if (sl < stopLine) {\n                    sc = columnOffset + nextOffset.column;\n                }\n            }\n            addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n        }\n    }\n    function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n        const parsed = parse(input);\n        if ('sections' in parsed)\n            return recurse(...arguments);\n        const map = new TraceMap(parsed, mapUrl);\n        const sourcesOffset = sources.length;\n        const namesOffset = names.length;\n        const decoded = decodedMappings(map);\n        const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n        append(sources, resolvedSources);\n        append(names, map.names);\n        if (contents)\n            append(sourcesContent, contents);\n        else\n            for (let i = 0; i < resolvedSources.length; i++)\n                sourcesContent.push(null);\n        if (ignores)\n            for (let i = 0; i < ignores.length; i++)\n                ignoreList.push(ignores[i] + sourcesOffset);\n        for (let i = 0; i < decoded.length; i++) {\n            const lineI = lineOffset + i;\n            // We can only add so many lines before we step into the range that the next section's map\n            // controls. When we get to the last line, then we'll start checking the segments to see if\n            // they've crossed into the column range. But it may not have any columns that overstep, so we\n            // still need to check that we don't overstep lines, too.\n            if (lineI > stopLine)\n                return;\n            // The out line may already exist in mappings (if we're continuing the line started by a\n            // previous section). Or, we may have jumped ahead several lines to start this section.\n            const out = getLine(mappings, lineI);\n            // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n            // map can be multiple lines), it doesn't.\n            const cOffset = i === 0 ? columnOffset : 0;\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const column = cOffset + seg[COLUMN];\n                // If this segment steps into the column range that the next section's map controls, we need\n                // to stop early.\n                if (lineI === stopLine && column >= stopColumn)\n                    return;\n                if (seg.length === 1) {\n                    out.push([column]);\n                    continue;\n                }\n                const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n                const sourceLine = seg[SOURCE_LINE];\n                const sourceColumn = seg[SOURCE_COLUMN];\n                out.push(seg.length === 4\n                    ? [column, sourcesIndex, sourceLine, sourceColumn]\n                    : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n            }\n        }\n    }\n    function append(arr, other) {\n        for (let i = 0; i < other.length; i++)\n            arr.push(other[i]);\n    }\n    function getLine(arr, index) {\n        for (let i = arr.length; i <= index; i++)\n            arr[i] = [];\n        return arr[index];\n    }\n\n    const LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\n    const COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\n    const LEAST_UPPER_BOUND = -1;\n    const GREATEST_LOWER_BOUND = 1;\n    class TraceMap {\n        constructor(map, mapUrl) {\n            const isString = typeof map === 'string';\n            if (!isString && map._decodedMemo)\n                return map;\n            const parsed = (isString ? JSON.parse(map) : map);\n            const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n            this.version = version;\n            this.file = file;\n            this.names = names || [];\n            this.sourceRoot = sourceRoot;\n            this.sources = sources;\n            this.sourcesContent = sourcesContent;\n            this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n            const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n            this.resolvedSources = sources.map((s) => resolve(s || '', from));\n            const { mappings } = parsed;\n            if (typeof mappings === 'string') {\n                this._encoded = mappings;\n                this._decoded = undefined;\n            }\n            else {\n                this._encoded = undefined;\n                this._decoded = maybeSort(mappings, isString);\n            }\n            this._decodedMemo = memoizedState();\n            this._bySources = undefined;\n            this._bySourceMemos = undefined;\n        }\n    }\n    /**\n     * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n     * with public access modifiers.\n     */\n    function cast(map) {\n        return map;\n    }\n    /**\n     * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n     */\n    function encodedMappings(map) {\n        var _a;\n        var _b;\n        return ((_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = sourcemapCodec.encode(cast(map)._decoded)));\n    }\n    /**\n     * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n     */\n    function decodedMappings(map) {\n        var _a;\n        return ((_a = cast(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast(map)._encoded)));\n    }\n    /**\n     * A low-level API to find the segment associated with a generated line/column (think, from a\n     * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n     */\n    function traceSegment(map, line, column) {\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return null;\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n        return index === -1 ? null : segments[index];\n    }\n    /**\n     * A higher-level API to find the source/line/column associated with a generated line/column\n     * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n     * `source-map` library.\n     */\n    function originalPositionFor(map, needle) {\n        let { line, column, bias } = needle;\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const decoded = decodedMappings(map);\n        // It's common for parent source maps to have pointers to lines that have no\n        // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n        if (line >= decoded.length)\n            return OMapping(null, null, null, null);\n        const segments = decoded[line];\n        const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n        if (index === -1)\n            return OMapping(null, null, null, null);\n        const segment = segments[index];\n        if (segment.length === 1)\n            return OMapping(null, null, null, null);\n        const { names, resolvedSources } = map;\n        return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n    }\n    /**\n     * Finds the generated line/column position of the provided source/line/column source position.\n     */\n    function generatedPositionFor(map, needle) {\n        const { source, line, column, bias } = needle;\n        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n    }\n    /**\n     * Finds all generated line/column positions of the provided source/line/column source position.\n     */\n    function allGeneratedPositionsFor(map, needle) {\n        const { source, line, column, bias } = needle;\n        // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n    }\n    /**\n     * Iterates each mapping in generated position order.\n     */\n    function eachMapping(map, cb) {\n        const decoded = decodedMappings(map);\n        const { names, resolvedSources } = map;\n        for (let i = 0; i < decoded.length; i++) {\n            const line = decoded[i];\n            for (let j = 0; j < line.length; j++) {\n                const seg = line[j];\n                const generatedLine = i + 1;\n                const generatedColumn = seg[0];\n                let source = null;\n                let originalLine = null;\n                let originalColumn = null;\n                let name = null;\n                if (seg.length !== 1) {\n                    source = resolvedSources[seg[1]];\n                    originalLine = seg[2] + 1;\n                    originalColumn = seg[3];\n                }\n                if (seg.length === 5)\n                    name = names[seg[4]];\n                cb({\n                    generatedLine,\n                    generatedColumn,\n                    source,\n                    originalLine,\n                    originalColumn,\n                    name,\n                });\n            }\n        }\n    }\n    function sourceIndex(map, source) {\n        const { sources, resolvedSources } = map;\n        let index = sources.indexOf(source);\n        if (index === -1)\n            index = resolvedSources.indexOf(source);\n        return index;\n    }\n    /**\n     * Retrieves the source content for a particular source, if its found. Returns null if not.\n     */\n    function sourceContentFor(map, source) {\n        const { sourcesContent } = map;\n        if (sourcesContent == null)\n            return null;\n        const index = sourceIndex(map, source);\n        return index === -1 ? null : sourcesContent[index];\n    }\n    /**\n     * Determines if the source is marked to ignore by the source map.\n     */\n    function isIgnored(map, source) {\n        const { ignoreList } = map;\n        if (ignoreList == null)\n            return false;\n        const index = sourceIndex(map, source);\n        return index === -1 ? false : ignoreList.includes(index);\n    }\n    /**\n     * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n     * maps.\n     */\n    function presortedDecodedMap(map, mapUrl) {\n        const tracer = new TraceMap(clone(map, []), mapUrl);\n        cast(tracer)._decoded = map.mappings;\n        return tracer;\n    }\n    /**\n     * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function decodedMap(map) {\n        return clone(map, decodedMappings(map));\n    }\n    /**\n     * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n     * a sourcemap, or to JSON.stringify.\n     */\n    function encodedMap(map) {\n        return clone(map, encodedMappings(map));\n    }\n    function clone(map, mappings) {\n        return {\n            version: map.version,\n            file: map.file,\n            names: map.names,\n            sourceRoot: map.sourceRoot,\n            sources: map.sources,\n            sourcesContent: map.sourcesContent,\n            mappings,\n            ignoreList: map.ignoreList || map.x_google_ignoreList,\n        };\n    }\n    function OMapping(source, line, column, name) {\n        return { source, line, column, name };\n    }\n    function GMapping(line, column) {\n        return { line, column };\n    }\n    function traceSegmentInternal(segments, memo, line, column, bias) {\n        let index = memoizedBinarySearch(segments, column, memo, line);\n        if (found) {\n            index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n        }\n        else if (bias === LEAST_UPPER_BOUND)\n            index++;\n        if (index === -1 || index === segments.length)\n            return -1;\n        return index;\n    }\n    function sliceGeneratedPositions(segments, memo, line, column, bias) {\n        let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n        // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n        // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n        // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n        // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n        // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n        // match LEAST_UPPER_BOUND.\n        if (!found && bias === LEAST_UPPER_BOUND)\n            min++;\n        if (min === -1 || min === segments.length)\n            return [];\n        // We may have found the segment that started at an earlier column. If this is the case, then we\n        // need to slice all generated segments that match _that_ column, because all such segments span\n        // to our desired column.\n        const matchedColumn = found ? column : segments[min][COLUMN];\n        // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n        if (!found)\n            min = lowerBound(segments, matchedColumn, min);\n        const max = upperBound(segments, matchedColumn, min);\n        const result = [];\n        for (; min <= max; min++) {\n            const segment = segments[min];\n            result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n        }\n        return result;\n    }\n    function generatedPosition(map, source, line, column, bias, all) {\n        var _a;\n        line--;\n        if (line < 0)\n            throw new Error(LINE_GTR_ZERO);\n        if (column < 0)\n            throw new Error(COL_GTR_EQ_ZERO);\n        const { sources, resolvedSources } = map;\n        let sourceIndex = sources.indexOf(source);\n        if (sourceIndex === -1)\n            sourceIndex = resolvedSources.indexOf(source);\n        if (sourceIndex === -1)\n            return all ? [] : GMapping(null, null);\n        const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));\n        const segments = generated[sourceIndex][line];\n        if (segments == null)\n            return all ? [] : GMapping(null, null);\n        const memo = cast(map)._bySourceMemos[sourceIndex];\n        if (all)\n            return sliceGeneratedPositions(segments, memo, line, column, bias);\n        const index = traceSegmentInternal(segments, memo, line, column, bias);\n        if (index === -1)\n            return GMapping(null, null);\n        const segment = segments[index];\n        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n    }\n\n    exports.AnyMap = AnyMap;\n    exports.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND;\n    exports.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND;\n    exports.TraceMap = TraceMap;\n    exports.allGeneratedPositionsFor = allGeneratedPositionsFor;\n    exports.decodedMap = decodedMap;\n    exports.decodedMappings = decodedMappings;\n    exports.eachMapping = eachMapping;\n    exports.encodedMap = encodedMap;\n    exports.encodedMappings = encodedMappings;\n    exports.generatedPositionFor = generatedPositionFor;\n    exports.isIgnored = isIgnored;\n    exports.originalPositionFor = originalPositionFor;\n    exports.presortedDecodedMap = presortedDecodedMap;\n    exports.sourceContentFor = sourceContentFor;\n    exports.traceSegment = traceSegment;\n\n}));\n//# sourceMappingURL=trace-mapping.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI4MDIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxJQUFJLEtBQTRELG9CQUFvQixtQkFBTyxDQUFDLEtBQTZCLEdBQUcsbUJBQU8sQ0FBQyxJQUF5QjtBQUM3SixJQUFJLENBQ3VKO0FBQzNKLENBQUMsMERBQTBEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQix3QkFBd0IscUJBQXFCO0FBQzdDLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNERBQTREO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZy9kaXN0L3RyYWNlLW1hcHBpbmcudW1kLmpzPzc3ODQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYycpLCByZXF1aXJlKCdAanJpZGdld2VsbC9yZXNvbHZlLXVyaScpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMnLCAnQGpyaWRnZXdlbGwvcmVzb2x2ZS11cmknXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLnRyYWNlTWFwcGluZyA9IHt9LCBnbG9iYWwuc291cmNlbWFwQ29kZWMsIGdsb2JhbC5yZXNvbHZlVVJJKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsIHNvdXJjZW1hcENvZGVjLCByZXNvbHZlVXJpKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIGZ1bmN0aW9uIHJlc29sdmUoaW5wdXQsIGJhc2UpIHtcbiAgICAgICAgLy8gVGhlIGJhc2UgaXMgYWx3YXlzIHRyZWF0ZWQgYXMgYSBkaXJlY3RvcnksIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2Jsb2IvOGNiM2VlNTcvbGliL3V0aWwuanMjTDMyN1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi9kYTRhZGJiMy90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9kZXZ0b29scy9mcm9udF9lbmQvc2RrL1NvdXJjZU1hcC5qcyNMNDAwLUw0MDFcbiAgICAgICAgaWYgKGJhc2UgJiYgIWJhc2UuZW5kc1dpdGgoJy8nKSlcbiAgICAgICAgICAgIGJhc2UgKz0gJy8nO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVVyaShpbnB1dCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVyeXRoaW5nIGFmdGVyIHRoZSBsYXN0IFwiL1wiLCBidXQgbGVhdmVzIHRoZSBzbGFzaC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpcEZpbGVuYW1lKHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBpbmRleCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgaW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICBjb25zdCBDT0xVTU4gPSAwO1xuICAgIGNvbnN0IFNPVVJDRVNfSU5ERVggPSAxO1xuICAgIGNvbnN0IFNPVVJDRV9MSU5FID0gMjtcbiAgICBjb25zdCBTT1VSQ0VfQ09MVU1OID0gMztcbiAgICBjb25zdCBOQU1FU19JTkRFWCA9IDQ7XG4gICAgY29uc3QgUkVWX0dFTkVSQVRFRF9MSU5FID0gMTtcbiAgICBjb25zdCBSRVZfR0VORVJBVEVEX0NPTFVNTiA9IDI7XG5cbiAgICBmdW5jdGlvbiBtYXliZVNvcnQobWFwcGluZ3MsIG93bmVkKSB7XG4gICAgICAgIGNvbnN0IHVuc29ydGVkSW5kZXggPSBuZXh0VW5zb3J0ZWRTZWdtZW50TGluZShtYXBwaW5ncywgMCk7XG4gICAgICAgIGlmICh1bnNvcnRlZEluZGV4ID09PSBtYXBwaW5ncy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbWFwcGluZ3M7XG4gICAgICAgIC8vIElmIHdlIG93biB0aGUgYXJyYXkgKG1lYW5pbmcgd2UgcGFyc2VkIGl0IGZyb20gSlNPTiksIHRoZW4gd2UncmUgZnJlZSB0byBkaXJlY3RseSBtdXRhdGUgaXQuIElmXG4gICAgICAgIC8vIG5vdCwgd2UgZG8gbm90IHdhbnQgdG8gbW9kaWZ5IHRoZSBjb25zdW1lcidzIGlucHV0IGFycmF5LlxuICAgICAgICBpZiAoIW93bmVkKVxuICAgICAgICAgICAgbWFwcGluZ3MgPSBtYXBwaW5ncy5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gdW5zb3J0ZWRJbmRleDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCBpICsgMSkpIHtcbiAgICAgICAgICAgIG1hcHBpbmdzW2ldID0gc29ydFNlZ21lbnRzKG1hcHBpbmdzW2ldLCBvd25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcHBpbmdzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZXh0VW5zb3J0ZWRTZWdtZW50TGluZShtYXBwaW5ncywgc3RhcnQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghaXNTb3J0ZWQobWFwcGluZ3NbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXBwaW5ncy5sZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzU29ydGVkKGxpbmUpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobGluZVtqXVtDT0xVTU5dIDwgbGluZVtqIC0gMV1bQ09MVU1OXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29ydFNlZ21lbnRzKGxpbmUsIG93bmVkKSB7XG4gICAgICAgIGlmICghb3duZWQpXG4gICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gbGluZS5zb3J0KHNvcnRDb21wYXJhdG9yKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICAgICAgICByZXR1cm4gYVtDT0xVTU5dIC0gYltDT0xVTU5dO1xuICAgIH1cblxuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEEgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbiB0aGF0IHJldHVybnMgdGhlIGluZGV4IGlmIGEgbWF0Y2ggaXMgZm91bmQuXG4gICAgICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHRoZW4gdGhlIGxlZnQtaW5kZXggKHRoZSBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0gdGhhdCBjb21lcyBqdXN0XG4gICAgICogYmVmb3JlIHRoZSBkZXNpcmVkIGluZGV4KSBpcyByZXR1cm5lZC4gVG8gbWFpbnRhaW4gcHJvcGVyIHNvcnQgb3JkZXIsIGEgc3BsaWNlIHdvdWxkIGhhcHBlbiBhdFxuICAgICAqIHRoZSBuZXh0IGluZGV4OlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBhcnJheSA9IFsxLCAzXTtcbiAgICAgKiBjb25zdCBuZWVkbGUgPSAyO1xuICAgICAqIGNvbnN0IGluZGV4ID0gYmluYXJ5U2VhcmNoKGFycmF5LCBuZWVkbGUsIChpdGVtLCBuZWVkbGUpID0+IGl0ZW0gLSBuZWVkbGUpO1xuICAgICAqXG4gICAgICogYXNzZXJ0LmVxdWFsKGluZGV4LCAwKTtcbiAgICAgKiBhcnJheS5zcGxpY2UoaW5kZXggKyAxLCAwLCBuZWVkbGUpO1xuICAgICAqIGFzc2VydC5kZWVwRXF1YWwoYXJyYXksIFsxLCAyLCAzXSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGxvdywgaGlnaCkge1xuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgICAgICBjb25zdCBjbXAgPSBoYXlzdGFja1ttaWRdW0NPTFVNTl0gLSBuZWVkbGU7XG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gbG93IC0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBwZXJCb3VuZChoYXlzdGFjaywgbmVlZGxlLCBpbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpbmRleCA9IGkrKykge1xuICAgICAgICAgICAgaWYgKGhheXN0YWNrW2ldW0NPTFVNTl0gIT09IG5lZWRsZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvd2VyQm91bmQoaGF5c3RhY2ssIG5lZWRsZSwgaW5kZXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpbmRleCA9IGktLSkge1xuICAgICAgICAgICAgaWYgKGhheXN0YWNrW2ldW0NPTFVNTl0gIT09IG5lZWRsZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lbW9pemVkU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXN0S2V5OiAtMSxcbiAgICAgICAgICAgIGxhc3ROZWVkbGU6IC0xLFxuICAgICAgICAgICAgbGFzdEluZGV4OiAtMSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBvdmVybHkgY29tcGxpY2F0ZWQgYmVhc3QgaXMganVzdCB0byByZWNvcmQgdGhlIGxhc3QgdGVzdGVkIGxpbmUvY29sdW1uIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgICogaW5kZXgsIGFsbG93aW5nIHVzIHRvIHNraXAgYSBmZXcgdGVzdHMgaWYgbWFwcGluZ3MgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplZEJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBzdGF0ZSwga2V5KSB7XG4gICAgICAgIGNvbnN0IHsgbGFzdEtleSwgbGFzdE5lZWRsZSwgbGFzdEluZGV4IH0gPSBzdGF0ZTtcbiAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgIGxldCBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGtleSA9PT0gbGFzdEtleSkge1xuICAgICAgICAgICAgaWYgKG5lZWRsZSA9PT0gbGFzdE5lZWRsZSkge1xuICAgICAgICAgICAgICAgIGZvdW5kID0gbGFzdEluZGV4ICE9PSAtMSAmJiBoYXlzdGFja1tsYXN0SW5kZXhdW0NPTFVNTl0gPT09IG5lZWRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRsZSA+PSBsYXN0TmVlZGxlKSB7XG4gICAgICAgICAgICAgICAgLy8gbGFzdEluZGV4IG1heSBiZSAtMSBpZiB0aGUgcHJldmlvdXMgbmVlZGxlIHdhcyBub3QgZm91bmQuXG4gICAgICAgICAgICAgICAgbG93ID0gbGFzdEluZGV4ID09PSAtMSA/IDAgOiBsYXN0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxhc3RLZXkgPSBrZXk7XG4gICAgICAgIHN0YXRlLmxhc3ROZWVkbGUgPSBuZWVkbGU7XG4gICAgICAgIHJldHVybiAoc3RhdGUubGFzdEluZGV4ID0gYmluYXJ5U2VhcmNoKGhheXN0YWNrLCBuZWVkbGUsIGxvdywgaGlnaCkpO1xuICAgIH1cblxuICAgIC8vIFJlYnVpbGRzIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMsIHdpdGggbWFwcGluZ3MgdGhhdCBhcmUgb3JkZXJlZCBieSBzb3VyY2UgbGluZS9jb2x1bW4gaW5zdGVhZFxuICAgIC8vIG9mIGdlbmVyYXRlZCBsaW5lL2NvbHVtbi5cbiAgICBmdW5jdGlvbiBidWlsZEJ5U291cmNlcyhkZWNvZGVkLCBtZW1vcykge1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gbWVtb3MubWFwKGJ1aWxkTnVsbEFycmF5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUluZGV4ID0gc2VnW1NPVVJDRVNfSU5ERVhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxpbmUgPSBzZWdbU09VUkNFX0xJTkVdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbiA9IHNlZ1tTT1VSQ0VfQ09MVU1OXTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFNvdXJjZSA9IHNvdXJjZXNbc291cmNlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IChvcmlnaW5hbFNvdXJjZVtzb3VyY2VMaW5lXSB8fCAob3JpZ2luYWxTb3VyY2Vbc291cmNlTGluZV0gPSBbXSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lbW8gPSBtZW1vc1tzb3VyY2VJbmRleF07XG4gICAgICAgICAgICAgICAgLy8gVGhlIGJpbmFyeSBzZWFyY2ggZWl0aGVyIGZvdW5kIGEgbWF0Y2gsIG9yIGl0IGZvdW5kIHRoZSBsZWZ0LWluZGV4IGp1c3QgYmVmb3JlIHdoZXJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlZ21lbnQgc2hvdWxkIGdvLiBFaXRoZXIgd2F5LCB3ZSB3YW50IHRvIGluc2VydCBhZnRlciB0aGF0LiBBbmQgdGhlcmUgbWF5IGJlIG11bHRpcGxlXG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIHNlZ21lbnRzIGFzc29jaWF0ZWQgd2l0aCBhbiBvcmlnaW5hbCBsb2NhdGlvbiwgc28gdGhlcmUgbWF5IG5lZWQgdG8gbW92ZSBzZXZlcmFsXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhlcyBiZWZvcmUgd2UgZmluZCB3aGVyZSB3ZSBuZWVkIHRvIGluc2VydC5cbiAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSB1cHBlckJvdW5kKG9yaWdpbmFsTGluZSwgc291cmNlQ29sdW1uLCBtZW1vaXplZEJpbmFyeVNlYXJjaChvcmlnaW5hbExpbmUsIHNvdXJjZUNvbHVtbiwgbWVtbywgc291cmNlTGluZSkpO1xuICAgICAgICAgICAgICAgIG1lbW8ubGFzdEluZGV4ID0gKytpbmRleDtcbiAgICAgICAgICAgICAgICBpbnNlcnQob3JpZ2luYWxMaW5lLCBpbmRleCwgW3NvdXJjZUNvbHVtbiwgaSwgc2VnW0NPTFVNTl1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc291cmNlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aDsgaSA+IGluZGV4OyBpLS0pIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gYXJyYXlbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBOdWxsIGFycmF5cyBhbGxvdyB1cyB0byB1c2Ugb3JkZXJlZCBpbmRleCBrZXlzIHdpdGhvdXQgYWN0dWFsbHkgYWxsb2NhdGluZyBjb250aWd1b3VzIG1lbW9yeSBsaWtlXG4gICAgLy8gYSByZWFsIGFycmF5LiBXZSB1c2UgYSBudWxsLXByb3RvdHlwZSBvYmplY3QgdG8gYXZvaWQgcHJvdG90eXBlIHBvbGx1dGlvbiBhbmQgZGVvcHRpbWl6YXRpb25zLlxuICAgIC8vIE51bWVyaWMgcHJvcGVydGllcyBvbiBvYmplY3RzIGFyZSBtYWdpY2FsbHkgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgZW5naW5lIHJlZ2FyZGxlc3Mgb2ZcbiAgICAvLyB0aGUgaW5zZXJ0aW9uIG9yZGVyLiBTbywgYnkgc2V0dGluZyBhbnkgbnVtZXJpYyBrZXlzLCBldmVuIG91dCBvZiBvcmRlciwgd2UnbGwgZ2V0IGFzY2VuZGluZ1xuICAgIC8vIG9yZGVyIHdoZW4gaXRlcmF0aW5nIHdpdGggZm9yLWluLlxuICAgIGZ1bmN0aW9uIGJ1aWxkTnVsbEFycmF5KCkge1xuICAgICAgICByZXR1cm4geyBfX3Byb3RvX186IG51bGwgfTtcbiAgICB9XG5cbiAgICBjb25zdCBBbnlNYXAgPSBmdW5jdGlvbiAobWFwLCBtYXBVcmwpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UobWFwKTtcbiAgICAgICAgaWYgKCEoJ3NlY3Rpb25zJyBpbiBwYXJzZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRyYWNlTWFwKHBhcnNlZCwgbWFwVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXBwaW5ncyA9IFtdO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgIGNvbnN0IHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIGNvbnN0IG5hbWVzID0gW107XG4gICAgICAgIGNvbnN0IGlnbm9yZUxpc3QgPSBbXTtcbiAgICAgICAgcmVjdXJzZShwYXJzZWQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgMCwgMCwgSW5maW5pdHksIEluZmluaXR5KTtcbiAgICAgICAgY29uc3Qgam9pbmVkID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMyxcbiAgICAgICAgICAgIGZpbGU6IHBhcnNlZC5maWxlLFxuICAgICAgICAgICAgbmFtZXMsXG4gICAgICAgICAgICBzb3VyY2VzLFxuICAgICAgICAgICAgc291cmNlc0NvbnRlbnQsXG4gICAgICAgICAgICBtYXBwaW5ncyxcbiAgICAgICAgICAgIGlnbm9yZUxpc3QsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcmVzb3J0ZWREZWNvZGVkTWFwKGpvaW5lZCk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBwYXJzZShtYXApIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtYXAgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShtYXApIDogbWFwO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZWN1cnNlKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgICAgICAgY29uc3QgeyBzZWN0aW9ucyB9ID0gaW5wdXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFwLCBvZmZzZXQgfSA9IHNlY3Rpb25zW2ldO1xuICAgICAgICAgICAgbGV0IHNsID0gc3RvcExpbmU7XG4gICAgICAgICAgICBsZXQgc2MgPSBzdG9wQ29sdW1uO1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dE9mZnNldCA9IHNlY3Rpb25zW2kgKyAxXS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2wgPSBNYXRoLm1pbihzdG9wTGluZSwgbGluZU9mZnNldCArIG5leHRPZmZzZXQubGluZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNsID09PSBzdG9wTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBzYyA9IE1hdGgubWluKHN0b3BDb2x1bW4sIGNvbHVtbk9mZnNldCArIG5leHRPZmZzZXQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2wgPCBzdG9wTGluZSkge1xuICAgICAgICAgICAgICAgICAgICBzYyA9IGNvbHVtbk9mZnNldCArIG5leHRPZmZzZXQuY29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlY3Rpb24obWFwLCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQgKyBvZmZzZXQubGluZSwgY29sdW1uT2Zmc2V0ICsgb2Zmc2V0LmNvbHVtbiwgc2wsIHNjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRTZWN0aW9uKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoJ3NlY3Rpb25zJyBpbiBwYXJzZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVjdXJzZSguLi5hcmd1bWVudHMpO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgVHJhY2VNYXAocGFyc2VkLCBtYXBVcmwpO1xuICAgICAgICBjb25zdCBzb3VyY2VzT2Zmc2V0ID0gc291cmNlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG5hbWVzT2Zmc2V0ID0gbmFtZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWRTb3VyY2VzLCBzb3VyY2VzQ29udGVudDogY29udGVudHMsIGlnbm9yZUxpc3Q6IGlnbm9yZXMgfSA9IG1hcDtcbiAgICAgICAgYXBwZW5kKHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyk7XG4gICAgICAgIGFwcGVuZChuYW1lcywgbWFwLm5hbWVzKTtcbiAgICAgICAgaWYgKGNvbnRlbnRzKVxuICAgICAgICAgICAgYXBwZW5kKHNvdXJjZXNDb250ZW50LCBjb250ZW50cyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRTb3VyY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHNvdXJjZXNDb250ZW50LnB1c2gobnVsbCk7XG4gICAgICAgIGlmIChpZ25vcmVzKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlnbm9yZUxpc3QucHVzaChpZ25vcmVzW2ldICsgc291cmNlc09mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUkgPSBsaW5lT2Zmc2V0ICsgaTtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBvbmx5IGFkZCBzbyBtYW55IGxpbmVzIGJlZm9yZSB3ZSBzdGVwIGludG8gdGhlIHJhbmdlIHRoYXQgdGhlIG5leHQgc2VjdGlvbidzIG1hcFxuICAgICAgICAgICAgLy8gY29udHJvbHMuIFdoZW4gd2UgZ2V0IHRvIHRoZSBsYXN0IGxpbmUsIHRoZW4gd2UnbGwgc3RhcnQgY2hlY2tpbmcgdGhlIHNlZ21lbnRzIHRvIHNlZSBpZlxuICAgICAgICAgICAgLy8gdGhleSd2ZSBjcm9zc2VkIGludG8gdGhlIGNvbHVtbiByYW5nZS4gQnV0IGl0IG1heSBub3QgaGF2ZSBhbnkgY29sdW1ucyB0aGF0IG92ZXJzdGVwLCBzbyB3ZVxuICAgICAgICAgICAgLy8gc3RpbGwgbmVlZCB0byBjaGVjayB0aGF0IHdlIGRvbid0IG92ZXJzdGVwIGxpbmVzLCB0b28uXG4gICAgICAgICAgICBpZiAobGluZUkgPiBzdG9wTGluZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUaGUgb3V0IGxpbmUgbWF5IGFscmVhZHkgZXhpc3QgaW4gbWFwcGluZ3MgKGlmIHdlJ3JlIGNvbnRpbnVpbmcgdGhlIGxpbmUgc3RhcnRlZCBieSBhXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBzZWN0aW9uKS4gT3IsIHdlIG1heSBoYXZlIGp1bXBlZCBhaGVhZCBzZXZlcmFsIGxpbmVzIHRvIHN0YXJ0IHRoaXMgc2VjdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGdldExpbmUobWFwcGluZ3MsIGxpbmVJKTtcbiAgICAgICAgICAgIC8vIE9uIHRoZSAwdGggbG9vcCwgdGhlIHNlY3Rpb24ncyBjb2x1bW4gb2Zmc2V0IHNoaWZ0cyB1cyBmb3J3YXJkLiBPbiBhbGwgb3RoZXIgbGluZXMgKHNpbmNlIHRoZVxuICAgICAgICAgICAgLy8gbWFwIGNhbiBiZSBtdWx0aXBsZSBsaW5lcyksIGl0IGRvZXNuJ3QuXG4gICAgICAgICAgICBjb25zdCBjT2Zmc2V0ID0gaSA9PT0gMCA/IGNvbHVtbk9mZnNldCA6IDA7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZGVjb2RlZFtpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gY09mZnNldCArIHNlZ1tDT0xVTU5dO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgc2VnbWVudCBzdGVwcyBpbnRvIHRoZSBjb2x1bW4gcmFuZ2UgdGhhdCB0aGUgbmV4dCBzZWN0aW9uJ3MgbWFwIGNvbnRyb2xzLCB3ZSBuZWVkXG4gICAgICAgICAgICAgICAgLy8gdG8gc3RvcCBlYXJseS5cbiAgICAgICAgICAgICAgICBpZiAobGluZUkgPT09IHN0b3BMaW5lICYmIGNvbHVtbiA+PSBzdG9wQ29sdW1uKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW2NvbHVtbl0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlc0luZGV4ID0gc291cmNlc09mZnNldCArIHNlZ1tTT1VSQ0VTX0lOREVYXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gc2VnW1NPVVJDRV9MSU5FXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VDb2x1bW4gPSBzZWdbU09VUkNFX0NPTFVNTl07XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goc2VnLmxlbmd0aCA9PT0gNFxuICAgICAgICAgICAgICAgICAgICA/IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uXVxuICAgICAgICAgICAgICAgICAgICA6IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc09mZnNldCArIHNlZ1tOQU1FU19JTkRFWF1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBlbmQoYXJyLCBvdGhlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgYXJyLnB1c2gob3RoZXJbaV0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRMaW5lKGFyciwgaW5kZXgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGg7IGkgPD0gaW5kZXg7IGkrKylcbiAgICAgICAgICAgIGFycltpXSA9IFtdO1xuICAgICAgICByZXR1cm4gYXJyW2luZGV4XTtcbiAgICB9XG5cbiAgICBjb25zdCBMSU5FX0dUUl9aRVJPID0gJ2BsaW5lYCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIChsaW5lcyBzdGFydCBhdCBsaW5lIDEpJztcbiAgICBjb25zdCBDT0xfR1RSX0VRX1pFUk8gPSAnYGNvbHVtbmAgbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCAoY29sdW1ucyBzdGFydCBhdCBjb2x1bW4gMCknO1xuICAgIGNvbnN0IExFQVNUX1VQUEVSX0JPVU5EID0gLTE7XG4gICAgY29uc3QgR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuICAgIGNsYXNzIFRyYWNlTWFwIHtcbiAgICAgICAgY29uc3RydWN0b3IobWFwLCBtYXBVcmwpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIG1hcCA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICBpZiAoIWlzU3RyaW5nICYmIG1hcC5fZGVjb2RlZE1lbW8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IChpc1N0cmluZyA/IEpTT04ucGFyc2UobWFwKSA6IG1hcCk7XG4gICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIGZpbGUsIG5hbWVzLCBzb3VyY2VSb290LCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCB9ID0gcGFyc2VkO1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gbmFtZXMgfHwgW107XG4gICAgICAgICAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICAgICAgICAgIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlTGlzdCA9IHBhcnNlZC5pZ25vcmVMaXN0IHx8IHBhcnNlZC54X2dvb2dsZV9pZ25vcmVMaXN0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKHNvdXJjZVJvb3QgfHwgJycsIHN0cmlwRmlsZW5hbWUobWFwVXJsKSk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkU291cmNlcyA9IHNvdXJjZXMubWFwKChzKSA9PiByZXNvbHZlKHMgfHwgJycsIGZyb20pKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFwcGluZ3MgfSA9IHBhcnNlZDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWFwcGluZ3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlZCA9IG1hcHBpbmdzO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY29kZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY29kZWQgPSBtYXliZVNvcnQobWFwcGluZ3MsIGlzU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlY29kZWRNZW1vID0gbWVtb2l6ZWRTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fYnlTb3VyY2VzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fYnlTb3VyY2VNZW1vcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlc2NyaXB0IGRvZXNuJ3QgYWxsb3cgZnJpZW5kIGFjY2VzcyB0byBwcml2YXRlIGZpZWxkcywgc28gdGhpcyBqdXN0IGNhc3RzIHRoZSBtYXAgaW50byBhIHR5cGVcbiAgICAgKiB3aXRoIHB1YmxpYyBhY2Nlc3MgbW9kaWZpZXJzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3QobWFwKSB7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVuY29kZWQgKFZMUSBzdHJpbmcpIGZvcm0gb2YgdGhlIFNvdXJjZU1hcCdzIG1hcHBpbmdzIGZpZWxkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHJldHVybiAoKF9hID0gKF9iID0gY2FzdChtYXApKS5fZW5jb2RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iLl9lbmNvZGVkID0gc291cmNlbWFwQ29kZWMuZW5jb2RlKGNhc3QobWFwKS5fZGVjb2RlZCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVjb2RlZCAoYXJyYXkgb2YgbGluZXMgb2Ygc2VnbWVudHMpIGZvcm0gb2YgdGhlIFNvdXJjZU1hcCdzIG1hcHBpbmdzIGZpZWxkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IGNhc3QobWFwKSkuX2RlY29kZWQgfHwgKF9hLl9kZWNvZGVkID0gc291cmNlbWFwQ29kZWMuZGVjb2RlKGNhc3QobWFwKS5fZW5jb2RlZCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsb3ctbGV2ZWwgQVBJIHRvIGZpbmQgdGhlIHNlZ21lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2VuZXJhdGVkIGxpbmUvY29sdW1uICh0aGluaywgZnJvbSBhXG4gICAgICogc3RhY2sgdHJhY2UpLiBMaW5lIGFuZCBjb2x1bW4gaGVyZSBhcmUgMC1iYXNlZCwgdW5saWtlIGBvcmlnaW5hbFBvc2l0aW9uRm9yYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFjZVNlZ21lbnQobWFwLCBsaW5lLCBjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICAgICAgICAvLyBJdCdzIGNvbW1vbiBmb3IgcGFyZW50IHNvdXJjZSBtYXBzIHRvIGhhdmUgcG9pbnRlcnMgdG8gbGluZXMgdGhhdCBoYXZlIG5vXG4gICAgICAgIC8vIG1hcHBpbmcgKGxpa2UgYSBcIi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSBhdCB0aGUgZW5kIG9mIHRoZSBjaGlsZCBmaWxlLlxuICAgICAgICBpZiAobGluZSA+PSBkZWNvZGVkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IGRlY29kZWRbbGluZV07XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIGNhc3QobWFwKS5fZGVjb2RlZE1lbW8sIGxpbmUsIGNvbHVtbiwgR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHNlZ21lbnRzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoaWdoZXItbGV2ZWwgQVBJIHRvIGZpbmQgdGhlIHNvdXJjZS9saW5lL2NvbHVtbiBhc3NvY2lhdGVkIHdpdGggYSBnZW5lcmF0ZWQgbGluZS9jb2x1bW5cbiAgICAgKiAodGhpbmssIGZyb20gYSBzdGFjayB0cmFjZSkuIExpbmUgaXMgMS1iYXNlZCwgYnV0IGNvbHVtbiBpcyAwLWJhc2VkLCBkdWUgdG8gbGVnYWN5IGJlaGF2aW9yIGluXG4gICAgICogYHNvdXJjZS1tYXBgIGxpYnJhcnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JpZ2luYWxQb3NpdGlvbkZvcihtYXAsIG5lZWRsZSkge1xuICAgICAgICBsZXQgeyBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgICAgICAgbGluZS0tO1xuICAgICAgICBpZiAobGluZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTElORV9HVFJfWkVSTyk7XG4gICAgICAgIGlmIChjb2x1bW4gPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPTF9HVFJfRVFfWkVSTyk7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgICAgICAgLy8gSXQncyBjb21tb24gZm9yIHBhcmVudCBzb3VyY2UgbWFwcyB0byBoYXZlIHBvaW50ZXJzIHRvIGxpbmVzIHRoYXQgaGF2ZSBub1xuICAgICAgICAvLyBtYXBwaW5nIChsaWtlIGEgXCIvLyMgc291cmNlTWFwcGluZ1VSTD1cIikgYXQgdGhlIGVuZCBvZiB0aGUgY2hpbGQgZmlsZS5cbiAgICAgICAgaWYgKGxpbmUgPj0gZGVjb2RlZC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gZGVjb2RlZFtsaW5lXTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0cmFjZVNlZ21lbnRJbnRlcm5hbChzZWdtZW50cywgY2FzdChtYXApLl9kZWNvZGVkTWVtbywgbGluZSwgY29sdW1uLCBiaWFzIHx8IEdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBPTWFwcGluZyhudWxsLCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIE9NYXBwaW5nKG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCB7IG5hbWVzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgICAgICAgcmV0dXJuIE9NYXBwaW5nKHJlc29sdmVkU291cmNlc1tzZWdtZW50W1NPVVJDRVNfSU5ERVhdXSwgc2VnbWVudFtTT1VSQ0VfTElORV0gKyAxLCBzZWdtZW50W1NPVVJDRV9DT0xVTU5dLCBzZWdtZW50Lmxlbmd0aCA9PT0gNSA/IG5hbWVzW3NlZ21lbnRbTkFNRVNfSU5ERVhdXSA6IG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBzb3VyY2UvbGluZS9jb2x1bW4gc291cmNlIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uRm9yKG1hcCwgbmVlZGxlKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFBvc2l0aW9uKG1hcCwgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfHwgR1JFQVRFU1RfTE9XRVJfQk9VTkQsIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBwb3NpdGlvbnMgb2YgdGhlIHByb3ZpZGVkIHNvdXJjZS9saW5lL2NvbHVtbiBzb3VyY2UgcG9zaXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKG1hcCwgbmVlZGxlKSB7XG4gICAgICAgIGNvbnN0IHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgICAgICAgLy8gU291cmNlTWFwQ29uc3VtZXIgdXNlcyBMRUFTVF9VUFBFUl9CT1VORCBmb3Igc29tZSByZWFzb24sIHNvIHdlIGZvbGxvdyBzdWl0LlxuICAgICAgICByZXR1cm4gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBMRUFTVF9VUFBFUl9CT1VORCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIGVhY2ggbWFwcGluZyBpbiBnZW5lcmF0ZWQgcG9zaXRpb24gb3JkZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZWFjaE1hcHBpbmcobWFwLCBjYikge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgICAgIGNvbnN0IHsgbmFtZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRMaW5lID0gaSArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkQ29sdW1uID0gc2VnWzBdO1xuICAgICAgICAgICAgICAgIGxldCBzb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbExpbmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBvcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc29sdmVkU291cmNlc1tzZWdbMV1dO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmUgPSBzZWdbMl0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbENvbHVtbiA9IHNlZ1szXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tzZWdbNF1dO1xuICAgICAgICAgICAgICAgIGNiKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkTGluZSxcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc291cmNlSW5kZXgobWFwLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgICAgICAgbGV0IGluZGV4ID0gc291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICBpbmRleCA9IHJlc29sdmVkU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBwYXJ0aWN1bGFyIHNvdXJjZSwgaWYgaXRzIGZvdW5kLiBSZXR1cm5zIG51bGwgaWYgbm90LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvdXJjZUNvbnRlbnRGb3IobWFwLCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2VzQ29udGVudCB9ID0gbWFwO1xuICAgICAgICBpZiAoc291cmNlc0NvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCBpbmRleCA9IHNvdXJjZUluZGV4KG1hcCwgc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBzb3VyY2VzQ29udGVudFtpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHNvdXJjZSBpcyBtYXJrZWQgdG8gaWdub3JlIGJ5IHRoZSBzb3VyY2UgbWFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSWdub3JlZChtYXAsIHNvdXJjZSkge1xuICAgICAgICBjb25zdCB7IGlnbm9yZUxpc3QgfSA9IG1hcDtcbiAgICAgICAgaWYgKGlnbm9yZUxpc3QgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gLTEgPyBmYWxzZSA6IGlnbm9yZUxpc3QuaW5jbHVkZXMoaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciB0aGF0IHNraXBzIHNvcnRpbmcgb2YgdGhlIGlucHV0IG1hcCdzIG1hcHBpbmdzIGFycmF5LCB3aGljaCBjYW4gYmUgZXhwZW5zaXZlIGZvciBsYXJnZXJcbiAgICAgKiBtYXBzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXNvcnRlZERlY29kZWRNYXAobWFwLCBtYXBVcmwpIHtcbiAgICAgICAgY29uc3QgdHJhY2VyID0gbmV3IFRyYWNlTWFwKGNsb25lKG1hcCwgW10pLCBtYXBVcmwpO1xuICAgICAgICBjYXN0KHRyYWNlcikuX2RlY29kZWQgPSBtYXAubWFwcGluZ3M7XG4gICAgICAgIHJldHVybiB0cmFjZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzb3VyY2VtYXAgb2JqZWN0ICh3aXRoIGRlY29kZWQgbWFwcGluZ3MpIHN1aXRhYmxlIGZvciBwYXNzaW5nIHRvIGEgbGlicmFyeSB0aGF0IGV4cGVjdHNcbiAgICAgKiBhIHNvdXJjZW1hcCwgb3IgdG8gSlNPTi5zdHJpbmdpZnkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjb2RlZE1hcChtYXApIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKG1hcCwgZGVjb2RlZE1hcHBpbmdzKG1hcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc291cmNlbWFwIG9iamVjdCAod2l0aCBlbmNvZGVkIG1hcHBpbmdzKSBzdWl0YWJsZSBmb3IgcGFzc2luZyB0byBhIGxpYnJhcnkgdGhhdCBleHBlY3RzXG4gICAgICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuY29kZWRNYXAobWFwKSB7XG4gICAgICAgIHJldHVybiBjbG9uZShtYXAsIGVuY29kZWRNYXBwaW5ncyhtYXApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmUobWFwLCBtYXBwaW5ncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogbWFwLnZlcnNpb24sXG4gICAgICAgICAgICBmaWxlOiBtYXAuZmlsZSxcbiAgICAgICAgICAgIG5hbWVzOiBtYXAubmFtZXMsXG4gICAgICAgICAgICBzb3VyY2VSb290OiBtYXAuc291cmNlUm9vdCxcbiAgICAgICAgICAgIHNvdXJjZXM6IG1hcC5zb3VyY2VzLFxuICAgICAgICAgICAgc291cmNlc0NvbnRlbnQ6IG1hcC5zb3VyY2VzQ29udGVudCxcbiAgICAgICAgICAgIG1hcHBpbmdzLFxuICAgICAgICAgICAgaWdub3JlTGlzdDogbWFwLmlnbm9yZUxpc3QgfHwgbWFwLnhfZ29vZ2xlX2lnbm9yZUxpc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIE9NYXBwaW5nKHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdNYXBwaW5nKGxpbmUsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcykge1xuICAgICAgICBsZXQgaW5kZXggPSBtZW1vaXplZEJpbmFyeVNlYXJjaChzZWdtZW50cywgY29sdW1uLCBtZW1vLCBsaW5lKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBpbmRleCA9IChiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORCA/IHVwcGVyQm91bmQgOiBsb3dlckJvdW5kKShzZWdtZW50cywgY29sdW1uLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQpXG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2xpY2VHZW5lcmF0ZWRQb3NpdGlvbnMoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcykge1xuICAgICAgICBsZXQgbWluID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgR1JFQVRFU1RfTE9XRVJfQk9VTkQpO1xuICAgICAgICAvLyBXZSBpZ25vcmVkIHRoZSBiaWFzIHdoZW4gdHJhY2luZyB0aGUgc2VnbWVudCBzbyB0aGF0IHdlJ3JlIGd1YXJuYXRlZWQgdG8gZmluZCB0aGUgZmlyc3QgKGluXG4gICAgICAgIC8vIGluc2VydGlvbiBvcmRlcikgc2VnbWVudCB0aGF0IG1hdGNoZWQuIEV2ZW4gaWYgd2UgZGlkIHJlc3BlY3QgdGhlIGJpYXMgd2hlbiB0cmFjaW5nLCB3ZSB3b3VsZFxuICAgICAgICAvLyBzdGlsbCBuZWVkIHRvIGNhbGwgYGxvd2VyQm91bmQoKWAgdG8gZmluZCB0aGUgZmlyc3Qgc2VnbWVudCwgd2hpY2ggaXMgc2xvd2VyIHRoYW4ganVzdCBsb29raW5nXG4gICAgICAgIC8vIGZvciB0aGUgR1JFQVRFU1RfTE9XRVJfQk9VTkQgdG8gYmVnaW4gd2l0aC4gVGhlIG9ubHkgZGlmZmVyZW5jZSB0aGF0IG1hdHRlcnMgZm9yIHVzIGlzIHdoZW4gdGhlXG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2ggZGlkbid0IG1hdGNoLCBpbiB3aGljaCBjYXNlIEdSRUFURVNUX0xPV0VSX0JPVU5EIGp1c3QgbmVlZHMgdG8gaW5jcmVtZW50IHRvXG4gICAgICAgIC8vIG1hdGNoIExFQVNUX1VQUEVSX0JPVU5ELlxuICAgICAgICBpZiAoIWZvdW5kICYmIGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EKVxuICAgICAgICAgICAgbWluKys7XG4gICAgICAgIGlmIChtaW4gPT09IC0xIHx8IG1pbiA9PT0gc2VnbWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAvLyBXZSBtYXkgaGF2ZSBmb3VuZCB0aGUgc2VnbWVudCB0aGF0IHN0YXJ0ZWQgYXQgYW4gZWFybGllciBjb2x1bW4uIElmIHRoaXMgaXMgdGhlIGNhc2UsIHRoZW4gd2VcbiAgICAgICAgLy8gbmVlZCB0byBzbGljZSBhbGwgZ2VuZXJhdGVkIHNlZ21lbnRzIHRoYXQgbWF0Y2ggX3RoYXRfIGNvbHVtbiwgYmVjYXVzZSBhbGwgc3VjaCBzZWdtZW50cyBzcGFuXG4gICAgICAgIC8vIHRvIG91ciBkZXNpcmVkIGNvbHVtbi5cbiAgICAgICAgY29uc3QgbWF0Y2hlZENvbHVtbiA9IGZvdW5kID8gY29sdW1uIDogc2VnbWVudHNbbWluXVtDT0xVTU5dO1xuICAgICAgICAvLyBUaGUgYmluYXJ5IHNlYXJjaCBpcyBub3QgZ3VhcmFudGVlZCB0byBmaW5kIHRoZSBsb3dlciBib3VuZCB3aGVuIGEgbWF0Y2ggd2Fzbid0IGZvdW5kLlxuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgbWluID0gbG93ZXJCb3VuZChzZWdtZW50cywgbWF0Y2hlZENvbHVtbiwgbWluKTtcbiAgICAgICAgY29uc3QgbWF4ID0gdXBwZXJCb3VuZChzZWdtZW50cywgbWF0Y2hlZENvbHVtbiwgbWluKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoOyBtaW4gPD0gbWF4OyBtaW4rKykge1xuICAgICAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW21pbl07XG4gICAgICAgICAgICByZXN1bHQucHVzaChHTWFwcGluZyhzZWdtZW50W1JFVl9HRU5FUkFURURfTElORV0gKyAxLCBzZWdtZW50W1JFVl9HRU5FUkFURURfQ09MVU1OXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uKG1hcCwgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMsIGFsbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxpbmUtLTtcbiAgICAgICAgaWYgKGxpbmUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKExJTkVfR1RSX1pFUk8pO1xuICAgICAgICBpZiAoY29sdW1uIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihDT0xfR1RSX0VRX1pFUk8pO1xuICAgICAgICBjb25zdCB7IHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICAgICAgICBsZXQgc291cmNlSW5kZXggPSBzb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHNvdXJjZUluZGV4ID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZUluZGV4ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiBhbGwgPyBbXSA6IEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSAoKF9hID0gY2FzdChtYXApKS5fYnlTb3VyY2VzIHx8IChfYS5fYnlTb3VyY2VzID0gYnVpbGRCeVNvdXJjZXMoZGVjb2RlZE1hcHBpbmdzKG1hcCksIChjYXN0KG1hcCkuX2J5U291cmNlTWVtb3MgPSBzb3VyY2VzLm1hcChtZW1vaXplZFN0YXRlKSkpKSk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gZ2VuZXJhdGVkW3NvdXJjZUluZGV4XVtsaW5lXTtcbiAgICAgICAgaWYgKHNlZ21lbnRzID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gYWxsID8gW10gOiBHTWFwcGluZyhudWxsLCBudWxsKTtcbiAgICAgICAgY29uc3QgbWVtbyA9IGNhc3QobWFwKS5fYnlTb3VyY2VNZW1vc1tzb3VyY2VJbmRleF07XG4gICAgICAgIGlmIChhbGwpXG4gICAgICAgICAgICByZXR1cm4gc2xpY2VHZW5lcmF0ZWRQb3NpdGlvbnMoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgICAgIHJldHVybiBHTWFwcGluZyhzZWdtZW50W1JFVl9HRU5FUkFURURfTElORV0gKyAxLCBzZWdtZW50W1JFVl9HRU5FUkFURURfQ09MVU1OXSk7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5BbnlNYXAgPSBBbnlNYXA7XG4gICAgZXhwb3J0cy5HUkVBVEVTVF9MT1dFUl9CT1VORCA9IEdSRUFURVNUX0xPV0VSX0JPVU5EO1xuICAgIGV4cG9ydHMuTEVBU1RfVVBQRVJfQk9VTkQgPSBMRUFTVF9VUFBFUl9CT1VORDtcbiAgICBleHBvcnRzLlRyYWNlTWFwID0gVHJhY2VNYXA7XG4gICAgZXhwb3J0cy5hbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IgPSBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3I7XG4gICAgZXhwb3J0cy5kZWNvZGVkTWFwID0gZGVjb2RlZE1hcDtcbiAgICBleHBvcnRzLmRlY29kZWRNYXBwaW5ncyA9IGRlY29kZWRNYXBwaW5ncztcbiAgICBleHBvcnRzLmVhY2hNYXBwaW5nID0gZWFjaE1hcHBpbmc7XG4gICAgZXhwb3J0cy5lbmNvZGVkTWFwID0gZW5jb2RlZE1hcDtcbiAgICBleHBvcnRzLmVuY29kZWRNYXBwaW5ncyA9IGVuY29kZWRNYXBwaW5ncztcbiAgICBleHBvcnRzLmdlbmVyYXRlZFBvc2l0aW9uRm9yID0gZ2VuZXJhdGVkUG9zaXRpb25Gb3I7XG4gICAgZXhwb3J0cy5pc0lnbm9yZWQgPSBpc0lnbm9yZWQ7XG4gICAgZXhwb3J0cy5vcmlnaW5hbFBvc2l0aW9uRm9yID0gb3JpZ2luYWxQb3NpdGlvbkZvcjtcbiAgICBleHBvcnRzLnByZXNvcnRlZERlY29kZWRNYXAgPSBwcmVzb3J0ZWREZWNvZGVkTWFwO1xuICAgIGV4cG9ydHMuc291cmNlQ29udGVudEZvciA9IHNvdXJjZUNvbnRlbnRGb3I7XG4gICAgZXhwb3J0cy50cmFjZVNlZ21lbnQgPSB0cmFjZVNlZ21lbnQ7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLW1hcHBpbmcudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///92802\n")},78478:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ BrowserOnly)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(96540);\n/* harmony import */ var _docusaurus_useIsBrowser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92303);\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74848);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */// Similar comp to the one described here:\n// https://www.joshwcomeau.com/react/the-perils-of-rehydration/#abstractions\nfunction BrowserOnly(_ref){let{children,fallback}=_ref;const isBrowser=(0,_docusaurus_useIsBrowser__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)();if(isBrowser){if(typeof children!=='function'&&\"production\"==='development'){}return/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment,{children:children?.()});}return fallback??null;}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg0NzguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBR0E7QUFDQTtBQUNlLFFBQVMsQ0FBQU8sV0FBV0EsQ0FBQUMsSUFBQSxDQUEwQixJQUF6QixDQUFFQyxRQUFRLENBQUVDLFFBQVUsQ0FBQyxDQUFBRixJQUFBLENBQ3ZELEtBQU0sQ0FBQUcsU0FBUyxDQUFHVCw2RUFBWSxDQUFDLENBQUMsQ0FDaEMsR0FBSVMsU0FBUyxDQUFFLENBQ1gsR0FBSSxNQUFPLENBQUFGLFFBQVEsR0FBSyxVQUFVLEVBQzlCRyxZQUFvQixHQUFLLGFBQWEsQ0FBRSxFQUk1QyxtQkFBT04sc0RBQUEsQ0FBQUYsdURBQUEsRUFBQUssUUFBQSxDQUFHQSxRQUFRLEdBQUcsQ0FBQyxDQUFHLENBQUMsQ0FDOUIsQ0FDQSxNQUFPLENBQUFDLFFBQVEsRUFBSSxJQUFJLENBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy9jb3JlL2xpYi9jbGllbnQvZXhwb3J0cy9Ccm93c2VyT25seS5qcz9jOGMyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBSZWFjdCwgeyBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VJc0Jyb3dzZXIgZnJvbSAnQGRvY3VzYXVydXMvdXNlSXNCcm93c2VyJztcbi8vIFNpbWlsYXIgY29tcCB0byB0aGUgb25lIGRlc2NyaWJlZCBoZXJlOlxuLy8gaHR0cHM6Ly93d3cuam9zaHdjb21lYXUuY29tL3JlYWN0L3RoZS1wZXJpbHMtb2YtcmVoeWRyYXRpb24vI2Fic3RyYWN0aW9uc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnJvd3Nlck9ubHkoeyBjaGlsZHJlbiwgZmFsbGJhY2ssIH0pIHtcbiAgICBjb25zdCBpc0Jyb3dzZXIgPSB1c2VJc0Jyb3dzZXIoKTtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERvY3VzYXVydXMgZXJyb3I6IFRoZSBjaGlsZHJlbiBvZiA8QnJvd3Nlck9ubHk+IG11c3QgYmUgYSBcInJlbmRlciBmdW5jdGlvblwiLCBlLmcuIDxCcm93c2VyT25seT57KCkgPT4gPHNwYW4+e3dpbmRvdy5sb2NhdGlvbi5ocmVmfTwvc3Bhbj59PC9Ccm93c2VyT25seT4uXG5DdXJyZW50IHR5cGU6ICR7aXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gJ1JlYWN0IGVsZW1lbnQnIDogdHlwZW9mIGNoaWxkcmVufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiA8PntjaGlsZHJlbj8uKCl9PC8+O1xuICAgIH1cbiAgICByZXR1cm4gZmFsbGJhY2sgPz8gbnVsbDtcbn1cbiJdLCJuYW1lcyI6WyJSZWFjdCIsImlzVmFsaWRFbGVtZW50IiwidXNlSXNCcm93c2VyIiwiRnJhZ21lbnQiLCJfRnJhZ21lbnQiLCJqc3giLCJfanN4IiwiQnJvd3Nlck9ubHkiLCJfcmVmIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsImlzQnJvd3NlciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78478\n")}}]);