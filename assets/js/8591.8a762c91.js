(self.webpackChunkregal_ui_docs=self.webpackChunkregal_ui_docs||[]).push([[8591],{64498:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nmodule.exports = __webpack_require__(75275);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ0OTguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsMkNBQTZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9hdXRvY29tcGxldGUuanMvaW5kZXguanM/NGM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvc3RhbmRhbG9uZS8nKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///64498\n")},60819:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _ = __webpack_require__(16220);\n\nvar css = {\n  wrapper: {\n    position: 'relative',\n    display: 'inline-block'\n  },\n  hint: {\n    position: 'absolute',\n    top: '0',\n    left: '0',\n    borderColor: 'transparent',\n    boxShadow: 'none',\n    // #741: fix hint opacity issue on iOS\n    opacity: '1'\n  },\n  input: {\n    position: 'relative',\n    verticalAlign: 'top',\n    backgroundColor: 'transparent'\n  },\n  inputWithNoHint: {\n    position: 'relative',\n    verticalAlign: 'top'\n  },\n  dropdown: {\n    position: 'absolute',\n    top: '100%',\n    left: '0',\n    zIndex: '100',\n    display: 'none'\n  },\n  suggestions: {\n    display: 'block'\n  },\n  suggestion: {\n    whiteSpace: 'nowrap',\n    cursor: 'pointer'\n  },\n  suggestionChild: {\n    whiteSpace: 'normal'\n  },\n  ltr: {\n    left: '0',\n    right: 'auto'\n  },\n  rtl: {\n    left: 'auto',\n    right: '0'\n  },\n  defaultClasses: {\n    root: 'algolia-autocomplete',\n    prefix: 'aa',\n    noPrefix: false,\n    dropdownMenu: 'dropdown-menu',\n    input: 'input',\n    hint: 'hint',\n    suggestions: 'suggestions',\n    suggestion: 'suggestion',\n    cursor: 'cursor',\n    dataset: 'dataset',\n    empty: 'empty'\n  },\n  // will be merged with the default ones if appendTo is used\n  appendTo: {\n    wrapper: {\n      position: 'absolute',\n      zIndex: '100',\n      display: 'none'\n    },\n    input: {},\n    inputWithNoHint: {},\n    dropdown: {\n      display: 'block'\n    }\n  }\n};\n\n// ie specific styling\nif (_.isMsie()) {\n  // ie6-8 (and 9?) doesn't fire hover and click events for elements with\n  // transparent backgrounds, for a workaround, use 1x1 transparent gif\n  _.mixin(css.input, {\n    backgroundImage: 'url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)'\n  });\n}\n\n// ie7 and under specific styling\nif (_.isMsie() && _.isMsie() <= 7) {\n  // if someone can tell me why this is necessary to align\n  // the hint with the query in ie7, i'll send you $5 - @JakeHarding\n  _.mixin(css.input, {marginTop: '-1px'});\n}\n\nmodule.exports = css;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA4MTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLEtBQW9COztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4Qzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9hdXRvY29tcGxldGUvY3NzLmpzPzBhOGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscy5qcycpO1xuXG52YXIgY3NzID0ge1xuICB3cmFwcGVyOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgfSxcbiAgaGludDoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzAnLFxuICAgIGxlZnQ6ICcwJyxcbiAgICBib3JkZXJDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3hTaGFkb3c6ICdub25lJyxcbiAgICAvLyAjNzQxOiBmaXggaGludCBvcGFjaXR5IGlzc3VlIG9uIGlPU1xuICAgIG9wYWNpdHk6ICcxJ1xuICB9LFxuICBpbnB1dDoge1xuICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xuICB9LFxuICBpbnB1dFdpdGhOb0hpbnQ6IHtcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJ1xuICB9LFxuICBkcm9wZG93bjoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJzEwMCUnLFxuICAgIGxlZnQ6ICcwJyxcbiAgICB6SW5kZXg6ICcxMDAnLFxuICAgIGRpc3BsYXk6ICdub25lJ1xuICB9LFxuICBzdWdnZXN0aW9uczoge1xuICAgIGRpc3BsYXk6ICdibG9jaydcbiAgfSxcbiAgc3VnZ2VzdGlvbjoge1xuICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gIH0sXG4gIHN1Z2dlc3Rpb25DaGlsZDoge1xuICAgIHdoaXRlU3BhY2U6ICdub3JtYWwnXG4gIH0sXG4gIGx0cjoge1xuICAgIGxlZnQ6ICcwJyxcbiAgICByaWdodDogJ2F1dG8nXG4gIH0sXG4gIHJ0bDoge1xuICAgIGxlZnQ6ICdhdXRvJyxcbiAgICByaWdodDogJzAnXG4gIH0sXG4gIGRlZmF1bHRDbGFzc2VzOiB7XG4gICAgcm9vdDogJ2FsZ29saWEtYXV0b2NvbXBsZXRlJyxcbiAgICBwcmVmaXg6ICdhYScsXG4gICAgbm9QcmVmaXg6IGZhbHNlLFxuICAgIGRyb3Bkb3duTWVudTogJ2Ryb3Bkb3duLW1lbnUnLFxuICAgIGlucHV0OiAnaW5wdXQnLFxuICAgIGhpbnQ6ICdoaW50JyxcbiAgICBzdWdnZXN0aW9uczogJ3N1Z2dlc3Rpb25zJyxcbiAgICBzdWdnZXN0aW9uOiAnc3VnZ2VzdGlvbicsXG4gICAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgICBkYXRhc2V0OiAnZGF0YXNldCcsXG4gICAgZW1wdHk6ICdlbXB0eSdcbiAgfSxcbiAgLy8gd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdCBvbmVzIGlmIGFwcGVuZFRvIGlzIHVzZWRcbiAgYXBwZW5kVG86IHtcbiAgICB3cmFwcGVyOiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHpJbmRleDogJzEwMCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICB9LFxuICAgIGlucHV0OiB7fSxcbiAgICBpbnB1dFdpdGhOb0hpbnQ6IHt9LFxuICAgIGRyb3Bkb3duOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9XG59O1xuXG4vLyBpZSBzcGVjaWZpYyBzdHlsaW5nXG5pZiAoXy5pc01zaWUoKSkge1xuICAvLyBpZTYtOCAoYW5kIDk/KSBkb2Vzbid0IGZpcmUgaG92ZXIgYW5kIGNsaWNrIGV2ZW50cyBmb3IgZWxlbWVudHMgd2l0aFxuICAvLyB0cmFuc3BhcmVudCBiYWNrZ3JvdW5kcywgZm9yIGEgd29ya2Fyb3VuZCwgdXNlIDF4MSB0cmFuc3BhcmVudCBnaWZcbiAgXy5taXhpbihjc3MuaW5wdXQsIHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6ICd1cmwoZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3KSdcbiAgfSk7XG59XG5cbi8vIGllNyBhbmQgdW5kZXIgc3BlY2lmaWMgc3R5bGluZ1xuaWYgKF8uaXNNc2llKCkgJiYgXy5pc01zaWUoKSA8PSA3KSB7XG4gIC8vIGlmIHNvbWVvbmUgY2FuIHRlbGwgbWUgd2h5IHRoaXMgaXMgbmVjZXNzYXJ5IHRvIGFsaWduXG4gIC8vIHRoZSBoaW50IHdpdGggdGhlIHF1ZXJ5IGluIGllNywgaSdsbCBzZW5kIHlvdSAkNSAtIEBKYWtlSGFyZGluZ1xuICBfLm1peGluKGNzcy5pbnB1dCwge21hcmdpblRvcDogJy0xcHgnfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3NzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///60819\n")},99324:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar datasetKey = 'aaDataset';\nvar valueKey = 'aaValue';\nvar datumKey = 'aaDatum';\n\nvar _ = __webpack_require__(16220);\nvar DOM = __webpack_require__(71337);\nvar html = __webpack_require__(74499);\nvar css = __webpack_require__(60819);\nvar EventEmitter = __webpack_require__(31805);\n\n// constructor\n// -----------\n\nfunction Dataset(o) {\n  o = o || {};\n  o.templates = o.templates || {};\n\n  if (!o.source) {\n    _.error('missing source');\n  }\n\n  if (o.name && !isValidName(o.name)) {\n    _.error('invalid dataset name: ' + o.name);\n  }\n\n  // tracks the last query the dataset was updated for\n  this.query = null;\n  this._isEmpty = true;\n\n  this.highlight = !!o.highlight;\n  this.name = typeof o.name === 'undefined' || o.name === null ? _.getUniqueId() : o.name;\n\n  this.source = o.source;\n  this.displayFn = getDisplayFn(o.display || o.displayKey);\n\n  this.debounce = o.debounce;\n\n  this.cache = o.cache !== false;\n\n  this.templates = getTemplates(o.templates, this.displayFn);\n\n  this.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});\n  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});\n  this.cssClasses.prefix =\n    o.cssClasses.formattedPrefix || _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);\n\n  var clazz = _.className(this.cssClasses.prefix, this.cssClasses.dataset);\n  this.$el = o.$menu && o.$menu.find(clazz + '-' + this.name).length > 0 ?\n    DOM.element(o.$menu.find(clazz + '-' + this.name)[0]) :\n    DOM.element(\n      html.dataset.replace('%CLASS%', this.name)\n        .replace('%PREFIX%', this.cssClasses.prefix)\n        .replace('%DATASET%', this.cssClasses.dataset)\n    );\n\n  this.$menu = o.$menu;\n  this.clearCachedSuggestions();\n}\n\n// static methods\n// --------------\n\nDataset.extractDatasetName = function extractDatasetName(el) {\n  return DOM.element(el).data(datasetKey);\n};\n\nDataset.extractValue = function extractValue(el) {\n  return DOM.element(el).data(valueKey);\n};\n\nDataset.extractDatum = function extractDatum(el) {\n  var datum = DOM.element(el).data(datumKey);\n  if (typeof datum === 'string') {\n    // Zepto has an automatic deserialization of the\n    // JSON encoded data attribute\n    datum = JSON.parse(datum);\n  }\n  return datum;\n};\n\n// instance methods\n// ----------------\n\n_.mixin(Dataset.prototype, EventEmitter, {\n\n  // ### private\n\n  _render: function render(query, suggestions) {\n    if (!this.$el) {\n      return;\n    }\n    var that = this;\n\n    var hasSuggestions;\n    var renderArgs = [].slice.call(arguments, 2);\n    this.$el.empty();\n\n    hasSuggestions = suggestions && suggestions.length;\n    this._isEmpty = !hasSuggestions;\n\n    if (!hasSuggestions && this.templates.empty) {\n      this.$el\n        .html(getEmptyHtml.apply(this, renderArgs))\n        .prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null)\n        .append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);\n    } else if (hasSuggestions) {\n      this.$el\n        .html(getSuggestionsHtml.apply(this, renderArgs))\n        .prepend(that.templates.header ? getHeaderHtml.apply(this, renderArgs) : null)\n        .append(that.templates.footer ? getFooterHtml.apply(this, renderArgs) : null);\n    } else if (suggestions && !Array.isArray(suggestions)) {\n      throw new TypeError('suggestions must be an array');\n    }\n\n    if (this.$menu) {\n      this.$menu.addClass(\n        this.cssClasses.prefix + (hasSuggestions ? 'with' : 'without') + '-' + this.name\n      ).removeClass(\n        this.cssClasses.prefix + (hasSuggestions ? 'without' : 'with') + '-' + this.name\n      );\n    }\n\n    this.trigger('rendered', query);\n\n    function getEmptyHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{query: query, isEmpty: true}].concat(args);\n      return that.templates.empty.apply(this, args);\n    }\n\n    function getSuggestionsHtml() {\n      var args = [].slice.call(arguments, 0);\n      var $suggestions;\n      var nodes;\n      var self = this;\n\n      var suggestionsHtml = html.suggestions.\n        replace('%PREFIX%', this.cssClasses.prefix).\n        replace('%SUGGESTIONS%', this.cssClasses.suggestions);\n      $suggestions = DOM\n        .element(suggestionsHtml)\n        .css(this.css.suggestions);\n\n      // jQuery#append doesn't support arrays as the first argument\n      // until version 1.8, see http://bugs.jquery.com/ticket/11231\n      nodes = _.map(suggestions, getSuggestionNode);\n      $suggestions.append.apply($suggestions, nodes);\n\n      return $suggestions;\n\n      function getSuggestionNode(suggestion) {\n        var $el;\n\n        var suggestionHtml = html.suggestion.\n          replace('%PREFIX%', self.cssClasses.prefix).\n          replace('%SUGGESTION%', self.cssClasses.suggestion);\n        $el = DOM.element(suggestionHtml)\n          .attr({\n            role: 'option',\n            id: ['option', Math.floor(Math.random() * 100000000)].join('-')\n          })\n          .append(that.templates.suggestion.apply(this, [suggestion].concat(args)));\n\n        $el.data(datasetKey, that.name);\n        $el.data(valueKey, that.displayFn(suggestion) || undefined); // this led to undefined return value\n        $el.data(datumKey, JSON.stringify(suggestion));\n        $el.children().each(function() { DOM.element(this).css(self.css.suggestionChild); });\n\n        return $el;\n      }\n    }\n\n    function getHeaderHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{query: query, isEmpty: !hasSuggestions}].concat(args);\n      return that.templates.header.apply(this, args);\n    }\n\n    function getFooterHtml() {\n      var args = [].slice.call(arguments, 0);\n      args = [{query: query, isEmpty: !hasSuggestions}].concat(args);\n      return that.templates.footer.apply(this, args);\n    }\n  },\n\n  // ### public\n\n  getRoot: function getRoot() {\n    return this.$el;\n  },\n\n  update: function update(query) {\n    function handleSuggestions(suggestions) {\n      // if the update has been canceled or if the query has changed\n      // do not render the suggestions as they've become outdated\n      if (!this.canceled && query === this.query) {\n        // concat all the other arguments that could have been passed\n        // to the render function, and forward them to _render\n        var extraArgs = [].slice.call(arguments, 1);\n        this.cacheSuggestions(query, suggestions, extraArgs);\n        this._render.apply(this, [query, suggestions].concat(extraArgs));\n      }\n    }\n\n    this.query = query;\n    this.canceled = false;\n\n    if (this.shouldFetchFromCache(query)) {\n      handleSuggestions.apply(this, [this.cachedSuggestions].concat(this.cachedRenderExtraArgs));\n    } else {\n      var that = this;\n      var execSource = function() {\n        // When the call is debounced the condition avoid to do a useless\n        // request with the last character when the input has been cleared\n        if (!that.canceled) {\n          that.source(query, handleSuggestions.bind(that));\n        }\n      };\n\n      if (this.debounce) {\n        var later = function() {\n          that.debounceTimeout = null;\n          execSource();\n        };\n        clearTimeout(this.debounceTimeout);\n        this.debounceTimeout = setTimeout(later, this.debounce);\n      } else {\n        execSource();\n      }\n    }\n  },\n\n  cacheSuggestions: function cacheSuggestions(query, suggestions, extraArgs) {\n    this.cachedQuery = query;\n    this.cachedSuggestions = suggestions;\n    this.cachedRenderExtraArgs = extraArgs;\n  },\n\n  shouldFetchFromCache: function shouldFetchFromCache(query) {\n    return this.cache &&\n      this.cachedQuery === query &&\n      this.cachedSuggestions &&\n      this.cachedSuggestions.length;\n  },\n\n  clearCachedSuggestions: function clearCachedSuggestions() {\n    delete this.cachedQuery;\n    delete this.cachedSuggestions;\n    delete this.cachedRenderExtraArgs;\n  },\n\n  cancel: function cancel() {\n    this.canceled = true;\n  },\n\n  clear: function clear() {\n    if (this.$el) {\n      this.cancel();\n      this.$el.empty();\n      this.trigger('rendered', '');\n    }\n  },\n\n  isEmpty: function isEmpty() {\n    return this._isEmpty;\n  },\n\n  destroy: function destroy() {\n    this.clearCachedSuggestions();\n    this.$el = null;\n  }\n});\n\n// helper functions\n// ----------------\n\nfunction getDisplayFn(display) {\n  display = display || 'value';\n\n  return _.isFunction(display) ? display : displayFn;\n\n  function displayFn(obj) {\n    return obj[display];\n  }\n}\n\nfunction getTemplates(templates, displayFn) {\n  return {\n    empty: templates.empty && _.templatify(templates.empty),\n    header: templates.header && _.templatify(templates.header),\n    footer: templates.footer && _.templatify(templates.footer),\n    suggestion: templates.suggestion || suggestionTemplate\n  };\n\n  function suggestionTemplate(context) {\n    return '<p>' + displayFn(context) + '</p>';\n  }\n}\n\nfunction isValidName(str) {\n  // dashes, underscores, letters, and numbers\n  return (/^[_a-zA-Z0-9-]+$/).test(str);\n}\n\nmodule.exports = Dataset;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkzMjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBLFFBQVEsbUJBQU8sQ0FBQyxLQUFvQjtBQUNwQyxVQUFVLG1CQUFPLENBQUMsS0FBa0I7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLEtBQVc7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLEtBQVU7QUFDNUIsbUJBQW1CLG1CQUFPLENBQUMsS0FBb0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSx1QkFBdUIscUNBQXFDO0FBQzVELDZDQUE2Qyx3Q0FBd0M7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLHlDQUF5QyxrREFBa0Q7O0FBRTNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1Q0FBdUM7QUFDdEQ7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvYXV0b2NvbXBsZXRlL2RhdGFzZXQuanM/NWRjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBkYXRhc2V0S2V5ID0gJ2FhRGF0YXNldCc7XG52YXIgdmFsdWVLZXkgPSAnYWFWYWx1ZSc7XG52YXIgZGF0dW1LZXkgPSAnYWFEYXR1bSc7XG5cbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzLmpzJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbS5qcycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL2h0bWwuanMnKTtcbnZhciBjc3MgPSByZXF1aXJlKCcuL2Nzcy5qcycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vZXZlbnRfZW1pdHRlci5qcycpO1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gRGF0YXNldChvKSB7XG4gIG8gPSBvIHx8IHt9O1xuICBvLnRlbXBsYXRlcyA9IG8udGVtcGxhdGVzIHx8IHt9O1xuXG4gIGlmICghby5zb3VyY2UpIHtcbiAgICBfLmVycm9yKCdtaXNzaW5nIHNvdXJjZScpO1xuICB9XG5cbiAgaWYgKG8ubmFtZSAmJiAhaXNWYWxpZE5hbWUoby5uYW1lKSkge1xuICAgIF8uZXJyb3IoJ2ludmFsaWQgZGF0YXNldCBuYW1lOiAnICsgby5uYW1lKTtcbiAgfVxuXG4gIC8vIHRyYWNrcyB0aGUgbGFzdCBxdWVyeSB0aGUgZGF0YXNldCB3YXMgdXBkYXRlZCBmb3JcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMuX2lzRW1wdHkgPSB0cnVlO1xuXG4gIHRoaXMuaGlnaGxpZ2h0ID0gISFvLmhpZ2hsaWdodDtcbiAgdGhpcy5uYW1lID0gdHlwZW9mIG8ubmFtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgby5uYW1lID09PSBudWxsID8gXy5nZXRVbmlxdWVJZCgpIDogby5uYW1lO1xuXG4gIHRoaXMuc291cmNlID0gby5zb3VyY2U7XG4gIHRoaXMuZGlzcGxheUZuID0gZ2V0RGlzcGxheUZuKG8uZGlzcGxheSB8fCBvLmRpc3BsYXlLZXkpO1xuXG4gIHRoaXMuZGVib3VuY2UgPSBvLmRlYm91bmNlO1xuXG4gIHRoaXMuY2FjaGUgPSBvLmNhY2hlICE9PSBmYWxzZTtcblxuICB0aGlzLnRlbXBsYXRlcyA9IGdldFRlbXBsYXRlcyhvLnRlbXBsYXRlcywgdGhpcy5kaXNwbGF5Rm4pO1xuXG4gIHRoaXMuY3NzID0gXy5taXhpbih7fSwgY3NzLCBvLmFwcGVuZFRvID8gY3NzLmFwcGVuZFRvIDoge30pO1xuICB0aGlzLmNzc0NsYXNzZXMgPSBvLmNzc0NsYXNzZXMgPSBfLm1peGluKHt9LCBjc3MuZGVmYXVsdENsYXNzZXMsIG8uY3NzQ2xhc3NlcyB8fCB7fSk7XG4gIHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXggPVxuICAgIG8uY3NzQ2xhc3Nlcy5mb3JtYXR0ZWRQcmVmaXggfHwgXy5mb3JtYXRQcmVmaXgodGhpcy5jc3NDbGFzc2VzLnByZWZpeCwgdGhpcy5jc3NDbGFzc2VzLm5vUHJlZml4KTtcblxuICB2YXIgY2xhenogPSBfLmNsYXNzTmFtZSh0aGlzLmNzc0NsYXNzZXMucHJlZml4LCB0aGlzLmNzc0NsYXNzZXMuZGF0YXNldCk7XG4gIHRoaXMuJGVsID0gby4kbWVudSAmJiBvLiRtZW51LmZpbmQoY2xhenogKyAnLScgKyB0aGlzLm5hbWUpLmxlbmd0aCA+IDAgP1xuICAgIERPTS5lbGVtZW50KG8uJG1lbnUuZmluZChjbGF6eiArICctJyArIHRoaXMubmFtZSlbMF0pIDpcbiAgICBET00uZWxlbWVudChcbiAgICAgIGh0bWwuZGF0YXNldC5yZXBsYWNlKCclQ0xBU1MlJywgdGhpcy5uYW1lKVxuICAgICAgICAucmVwbGFjZSgnJVBSRUZJWCUnLCB0aGlzLmNzc0NsYXNzZXMucHJlZml4KVxuICAgICAgICAucmVwbGFjZSgnJURBVEFTRVQlJywgdGhpcy5jc3NDbGFzc2VzLmRhdGFzZXQpXG4gICAgKTtcblxuICB0aGlzLiRtZW51ID0gby4kbWVudTtcbiAgdGhpcy5jbGVhckNhY2hlZFN1Z2dlc3Rpb25zKCk7XG59XG5cbi8vIHN0YXRpYyBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG5EYXRhc2V0LmV4dHJhY3REYXRhc2V0TmFtZSA9IGZ1bmN0aW9uIGV4dHJhY3REYXRhc2V0TmFtZShlbCkge1xuICByZXR1cm4gRE9NLmVsZW1lbnQoZWwpLmRhdGEoZGF0YXNldEtleSk7XG59O1xuXG5EYXRhc2V0LmV4dHJhY3RWYWx1ZSA9IGZ1bmN0aW9uIGV4dHJhY3RWYWx1ZShlbCkge1xuICByZXR1cm4gRE9NLmVsZW1lbnQoZWwpLmRhdGEodmFsdWVLZXkpO1xufTtcblxuRGF0YXNldC5leHRyYWN0RGF0dW0gPSBmdW5jdGlvbiBleHRyYWN0RGF0dW0oZWwpIHtcbiAgdmFyIGRhdHVtID0gRE9NLmVsZW1lbnQoZWwpLmRhdGEoZGF0dW1LZXkpO1xuICBpZiAodHlwZW9mIGRhdHVtID09PSAnc3RyaW5nJykge1xuICAgIC8vIFplcHRvIGhhcyBhbiBhdXRvbWF0aWMgZGVzZXJpYWxpemF0aW9uIG9mIHRoZVxuICAgIC8vIEpTT04gZW5jb2RlZCBkYXRhIGF0dHJpYnV0ZVxuICAgIGRhdHVtID0gSlNPTi5wYXJzZShkYXR1bSk7XG4gIH1cbiAgcmV0dXJuIGRhdHVtO1xufTtcblxuLy8gaW5zdGFuY2UgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG5fLm1peGluKERhdGFzZXQucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIsIHtcblxuICAvLyAjIyMgcHJpdmF0ZVxuXG4gIF9yZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihxdWVyeSwgc3VnZ2VzdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMuJGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHZhciBoYXNTdWdnZXN0aW9ucztcbiAgICB2YXIgcmVuZGVyQXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xuXG4gICAgaGFzU3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucyAmJiBzdWdnZXN0aW9ucy5sZW5ndGg7XG4gICAgdGhpcy5faXNFbXB0eSA9ICFoYXNTdWdnZXN0aW9ucztcblxuICAgIGlmICghaGFzU3VnZ2VzdGlvbnMgJiYgdGhpcy50ZW1wbGF0ZXMuZW1wdHkpIHtcbiAgICAgIHRoaXMuJGVsXG4gICAgICAgIC5odG1sKGdldEVtcHR5SHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSlcbiAgICAgICAgLnByZXBlbmQodGhhdC50ZW1wbGF0ZXMuaGVhZGVyID8gZ2V0SGVhZGVySHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSA6IG51bGwpXG4gICAgICAgIC5hcHBlbmQodGhhdC50ZW1wbGF0ZXMuZm9vdGVyID8gZ2V0Rm9vdGVySHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSA6IG51bGwpO1xuICAgIH0gZWxzZSBpZiAoaGFzU3VnZ2VzdGlvbnMpIHtcbiAgICAgIHRoaXMuJGVsXG4gICAgICAgIC5odG1sKGdldFN1Z2dlc3Rpb25zSHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSlcbiAgICAgICAgLnByZXBlbmQodGhhdC50ZW1wbGF0ZXMuaGVhZGVyID8gZ2V0SGVhZGVySHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSA6IG51bGwpXG4gICAgICAgIC5hcHBlbmQodGhhdC50ZW1wbGF0ZXMuZm9vdGVyID8gZ2V0Rm9vdGVySHRtbC5hcHBseSh0aGlzLCByZW5kZXJBcmdzKSA6IG51bGwpO1xuICAgIH0gZWxzZSBpZiAoc3VnZ2VzdGlvbnMgJiYgIUFycmF5LmlzQXJyYXkoc3VnZ2VzdGlvbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdWdnZXN0aW9ucyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJG1lbnUpIHtcbiAgICAgIHRoaXMuJG1lbnUuYWRkQ2xhc3MoXG4gICAgICAgIHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXggKyAoaGFzU3VnZ2VzdGlvbnMgPyAnd2l0aCcgOiAnd2l0aG91dCcpICsgJy0nICsgdGhpcy5uYW1lXG4gICAgICApLnJlbW92ZUNsYXNzKFxuICAgICAgICB0aGlzLmNzc0NsYXNzZXMucHJlZml4ICsgKGhhc1N1Z2dlc3Rpb25zID8gJ3dpdGhvdXQnIDogJ3dpdGgnKSArICctJyArIHRoaXMubmFtZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3JlbmRlcmVkJywgcXVlcnkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RW1wdHlIdG1sKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICBhcmdzID0gW3txdWVyeTogcXVlcnksIGlzRW1wdHk6IHRydWV9XS5jb25jYXQoYXJncyk7XG4gICAgICByZXR1cm4gdGhhdC50ZW1wbGF0ZXMuZW1wdHkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbnNIdG1sKCkge1xuICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICB2YXIgJHN1Z2dlc3Rpb25zO1xuICAgICAgdmFyIG5vZGVzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgc3VnZ2VzdGlvbnNIdG1sID0gaHRtbC5zdWdnZXN0aW9ucy5cbiAgICAgICAgcmVwbGFjZSgnJVBSRUZJWCUnLCB0aGlzLmNzc0NsYXNzZXMucHJlZml4KS5cbiAgICAgICAgcmVwbGFjZSgnJVNVR0dFU1RJT05TJScsIHRoaXMuY3NzQ2xhc3Nlcy5zdWdnZXN0aW9ucyk7XG4gICAgICAkc3VnZ2VzdGlvbnMgPSBET01cbiAgICAgICAgLmVsZW1lbnQoc3VnZ2VzdGlvbnNIdG1sKVxuICAgICAgICAuY3NzKHRoaXMuY3NzLnN1Z2dlc3Rpb25zKTtcblxuICAgICAgLy8galF1ZXJ5I2FwcGVuZCBkb2Vzbid0IHN1cHBvcnQgYXJyYXlzIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgICAgLy8gdW50aWwgdmVyc2lvbiAxLjgsIHNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMTIzMVxuICAgICAgbm9kZXMgPSBfLm1hcChzdWdnZXN0aW9ucywgZ2V0U3VnZ2VzdGlvbk5vZGUpO1xuICAgICAgJHN1Z2dlc3Rpb25zLmFwcGVuZC5hcHBseSgkc3VnZ2VzdGlvbnMsIG5vZGVzKTtcblxuICAgICAgcmV0dXJuICRzdWdnZXN0aW9ucztcblxuICAgICAgZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbk5vZGUoc3VnZ2VzdGlvbikge1xuICAgICAgICB2YXIgJGVsO1xuXG4gICAgICAgIHZhciBzdWdnZXN0aW9uSHRtbCA9IGh0bWwuc3VnZ2VzdGlvbi5cbiAgICAgICAgICByZXBsYWNlKCclUFJFRklYJScsIHNlbGYuY3NzQ2xhc3Nlcy5wcmVmaXgpLlxuICAgICAgICAgIHJlcGxhY2UoJyVTVUdHRVNUSU9OJScsIHNlbGYuY3NzQ2xhc3Nlcy5zdWdnZXN0aW9uKTtcbiAgICAgICAgJGVsID0gRE9NLmVsZW1lbnQoc3VnZ2VzdGlvbkh0bWwpXG4gICAgICAgICAgLmF0dHIoe1xuICAgICAgICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICAgICAgICBpZDogWydvcHRpb24nLCBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDAwMDApXS5qb2luKCctJylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5hcHBlbmQodGhhdC50ZW1wbGF0ZXMuc3VnZ2VzdGlvbi5hcHBseSh0aGlzLCBbc3VnZ2VzdGlvbl0uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICAgICAgJGVsLmRhdGEoZGF0YXNldEtleSwgdGhhdC5uYW1lKTtcbiAgICAgICAgJGVsLmRhdGEodmFsdWVLZXksIHRoYXQuZGlzcGxheUZuKHN1Z2dlc3Rpb24pIHx8IHVuZGVmaW5lZCk7IC8vIHRoaXMgbGVkIHRvIHVuZGVmaW5lZCByZXR1cm4gdmFsdWVcbiAgICAgICAgJGVsLmRhdGEoZGF0dW1LZXksIEpTT04uc3RyaW5naWZ5KHN1Z2dlc3Rpb24pKTtcbiAgICAgICAgJGVsLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbigpIHsgRE9NLmVsZW1lbnQodGhpcykuY3NzKHNlbGYuY3NzLnN1Z2dlc3Rpb25DaGlsZCk7IH0pO1xuXG4gICAgICAgIHJldHVybiAkZWw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SGVhZGVySHRtbCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgYXJncyA9IFt7cXVlcnk6IHF1ZXJ5LCBpc0VtcHR5OiAhaGFzU3VnZ2VzdGlvbnN9XS5jb25jYXQoYXJncyk7XG4gICAgICByZXR1cm4gdGhhdC50ZW1wbGF0ZXMuaGVhZGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZvb3Rlckh0bWwoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgIGFyZ3MgPSBbe3F1ZXJ5OiBxdWVyeSwgaXNFbXB0eTogIWhhc1N1Z2dlc3Rpb25zfV0uY29uY2F0KGFyZ3MpO1xuICAgICAgcmV0dXJuIHRoYXQudGVtcGxhdGVzLmZvb3Rlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gIyMjIHB1YmxpY1xuXG4gIGdldFJvb3Q6IGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuJGVsO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKHF1ZXJ5KSB7XG4gICAgZnVuY3Rpb24gaGFuZGxlU3VnZ2VzdGlvbnMoc3VnZ2VzdGlvbnMpIHtcbiAgICAgIC8vIGlmIHRoZSB1cGRhdGUgaGFzIGJlZW4gY2FuY2VsZWQgb3IgaWYgdGhlIHF1ZXJ5IGhhcyBjaGFuZ2VkXG4gICAgICAvLyBkbyBub3QgcmVuZGVyIHRoZSBzdWdnZXN0aW9ucyBhcyB0aGV5J3ZlIGJlY29tZSBvdXRkYXRlZFxuICAgICAgaWYgKCF0aGlzLmNhbmNlbGVkICYmIHF1ZXJ5ID09PSB0aGlzLnF1ZXJ5KSB7XG4gICAgICAgIC8vIGNvbmNhdCBhbGwgdGhlIG90aGVyIGFyZ3VtZW50cyB0aGF0IGNvdWxkIGhhdmUgYmVlbiBwYXNzZWRcbiAgICAgICAgLy8gdG8gdGhlIHJlbmRlciBmdW5jdGlvbiwgYW5kIGZvcndhcmQgdGhlbSB0byBfcmVuZGVyXG4gICAgICAgIHZhciBleHRyYUFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIHRoaXMuY2FjaGVTdWdnZXN0aW9ucyhxdWVyeSwgc3VnZ2VzdGlvbnMsIGV4dHJhQXJncyk7XG4gICAgICAgIHRoaXMuX3JlbmRlci5hcHBseSh0aGlzLCBbcXVlcnksIHN1Z2dlc3Rpb25zXS5jb25jYXQoZXh0cmFBcmdzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuY2FuY2VsZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLnNob3VsZEZldGNoRnJvbUNhY2hlKHF1ZXJ5KSkge1xuICAgICAgaGFuZGxlU3VnZ2VzdGlvbnMuYXBwbHkodGhpcywgW3RoaXMuY2FjaGVkU3VnZ2VzdGlvbnNdLmNvbmNhdCh0aGlzLmNhY2hlZFJlbmRlckV4dHJhQXJncykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIgZXhlY1NvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBXaGVuIHRoZSBjYWxsIGlzIGRlYm91bmNlZCB0aGUgY29uZGl0aW9uIGF2b2lkIHRvIGRvIGEgdXNlbGVzc1xuICAgICAgICAvLyByZXF1ZXN0IHdpdGggdGhlIGxhc3QgY2hhcmFjdGVyIHdoZW4gdGhlIGlucHV0IGhhcyBiZWVuIGNsZWFyZWRcbiAgICAgICAgaWYgKCF0aGF0LmNhbmNlbGVkKSB7XG4gICAgICAgICAgdGhhdC5zb3VyY2UocXVlcnksIGhhbmRsZVN1Z2dlc3Rpb25zLmJpbmQodGhhdCkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5kZWJvdW5jZSkge1xuICAgICAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGF0LmRlYm91bmNlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgZXhlY1NvdXJjZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmRlYm91bmNlVGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHRoaXMuZGVib3VuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhlY1NvdXJjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBjYWNoZVN1Z2dlc3Rpb25zOiBmdW5jdGlvbiBjYWNoZVN1Z2dlc3Rpb25zKHF1ZXJ5LCBzdWdnZXN0aW9ucywgZXh0cmFBcmdzKSB7XG4gICAgdGhpcy5jYWNoZWRRdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuY2FjaGVkU3VnZ2VzdGlvbnMgPSBzdWdnZXN0aW9ucztcbiAgICB0aGlzLmNhY2hlZFJlbmRlckV4dHJhQXJncyA9IGV4dHJhQXJncztcbiAgfSxcblxuICBzaG91bGRGZXRjaEZyb21DYWNoZTogZnVuY3Rpb24gc2hvdWxkRmV0Y2hGcm9tQ2FjaGUocXVlcnkpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZSAmJlxuICAgICAgdGhpcy5jYWNoZWRRdWVyeSA9PT0gcXVlcnkgJiZcbiAgICAgIHRoaXMuY2FjaGVkU3VnZ2VzdGlvbnMgJiZcbiAgICAgIHRoaXMuY2FjaGVkU3VnZ2VzdGlvbnMubGVuZ3RoO1xuICB9LFxuXG4gIGNsZWFyQ2FjaGVkU3VnZ2VzdGlvbnM6IGZ1bmN0aW9uIGNsZWFyQ2FjaGVkU3VnZ2VzdGlvbnMoKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVkUXVlcnk7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVkU3VnZ2VzdGlvbnM7XG4gICAgZGVsZXRlIHRoaXMuY2FjaGVkUmVuZGVyRXh0cmFBcmdzO1xuICB9LFxuXG4gIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHRoaXMuY2FuY2VsZWQgPSB0cnVlO1xuICB9LFxuXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBpZiAodGhpcy4kZWwpIHtcbiAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICB0aGlzLiRlbC5lbXB0eSgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdyZW5kZXJlZCcsICcnKTtcbiAgICB9XG4gIH0sXG5cbiAgaXNFbXB0eTogZnVuY3Rpb24gaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNFbXB0eTtcbiAgfSxcblxuICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJDYWNoZWRTdWdnZXN0aW9ucygpO1xuICAgIHRoaXMuJGVsID0gbnVsbDtcbiAgfVxufSk7XG5cbi8vIGhlbHBlciBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZ2V0RGlzcGxheUZuKGRpc3BsYXkpIHtcbiAgZGlzcGxheSA9IGRpc3BsYXkgfHwgJ3ZhbHVlJztcblxuICByZXR1cm4gXy5pc0Z1bmN0aW9uKGRpc3BsYXkpID8gZGlzcGxheSA6IGRpc3BsYXlGbjtcblxuICBmdW5jdGlvbiBkaXNwbGF5Rm4ob2JqKSB7XG4gICAgcmV0dXJuIG9ialtkaXNwbGF5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUZW1wbGF0ZXModGVtcGxhdGVzLCBkaXNwbGF5Rm4pIHtcbiAgcmV0dXJuIHtcbiAgICBlbXB0eTogdGVtcGxhdGVzLmVtcHR5ICYmIF8udGVtcGxhdGlmeSh0ZW1wbGF0ZXMuZW1wdHkpLFxuICAgIGhlYWRlcjogdGVtcGxhdGVzLmhlYWRlciAmJiBfLnRlbXBsYXRpZnkodGVtcGxhdGVzLmhlYWRlciksXG4gICAgZm9vdGVyOiB0ZW1wbGF0ZXMuZm9vdGVyICYmIF8udGVtcGxhdGlmeSh0ZW1wbGF0ZXMuZm9vdGVyKSxcbiAgICBzdWdnZXN0aW9uOiB0ZW1wbGF0ZXMuc3VnZ2VzdGlvbiB8fCBzdWdnZXN0aW9uVGVtcGxhdGVcbiAgfTtcblxuICBmdW5jdGlvbiBzdWdnZXN0aW9uVGVtcGxhdGUoY29udGV4dCkge1xuICAgIHJldHVybiAnPHA+JyArIGRpc3BsYXlGbihjb250ZXh0KSArICc8L3A+JztcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkTmFtZShzdHIpIHtcbiAgLy8gZGFzaGVzLCB1bmRlcnNjb3JlcywgbGV0dGVycywgYW5kIG51bWJlcnNcbiAgcmV0dXJuICgvXltfYS16QS1aMC05LV0rJC8pLnRlc3Qoc3RyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhc2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99324\n")},82731:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _ = __webpack_require__(16220);\nvar DOM = __webpack_require__(71337);\nvar EventEmitter = __webpack_require__(31805);\nvar Dataset = __webpack_require__(99324);\nvar css = __webpack_require__(60819);\n\n// constructor\n// -----------\n\nfunction Dropdown(o) {\n  var that = this;\n  var onSuggestionClick;\n  var onSuggestionMouseEnter;\n  var onSuggestionMouseLeave;\n\n  o = o || {};\n\n  if (!o.menu) {\n    _.error('menu is required');\n  }\n\n  if (!_.isArray(o.datasets) && !_.isObject(o.datasets)) {\n    _.error('1 or more datasets required');\n  }\n  if (!o.datasets) {\n    _.error('datasets is required');\n  }\n\n  this.isOpen = false;\n  this.isEmpty = true;\n  this.minLength = o.minLength || 0;\n  this.templates = {};\n  this.appendTo = o.appendTo || false;\n  this.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});\n  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});\n  this.cssClasses.prefix =\n    o.cssClasses.formattedPrefix || _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);\n\n  // bound functions\n  onSuggestionClick = _.bind(this._onSuggestionClick, this);\n  onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);\n  onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);\n\n  var cssClass = _.className(this.cssClasses.prefix, this.cssClasses.suggestion);\n  this.$menu = DOM.element(o.menu)\n    .on('mouseenter.aa', cssClass, onSuggestionMouseEnter)\n    .on('mouseleave.aa', cssClass, onSuggestionMouseLeave)\n    .on('click.aa', cssClass, onSuggestionClick);\n\n  this.$container = o.appendTo ? o.wrapper : this.$menu;\n\n  if (o.templates && o.templates.header) {\n    this.templates.header = _.templatify(o.templates.header);\n    this.$menu.prepend(this.templates.header());\n  }\n\n  if (o.templates && o.templates.empty) {\n    this.templates.empty = _.templatify(o.templates.empty);\n    this.$empty = DOM.element('<div class=\"' +\n      _.className(this.cssClasses.prefix, this.cssClasses.empty, true) + '\">' +\n      '</div>');\n    this.$menu.append(this.$empty);\n    this.$empty.hide();\n  }\n\n  this.datasets = _.map(o.datasets, function(oDataset) {\n    return initializeDataset(that.$menu, oDataset, o.cssClasses);\n  });\n  _.each(this.datasets, function(dataset) {\n    var root = dataset.getRoot();\n    if (root && root.parent().length === 0) {\n      that.$menu.append(root);\n    }\n    dataset.onSync('rendered', that._onRendered, that);\n  });\n\n  if (o.templates && o.templates.footer) {\n    this.templates.footer = _.templatify(o.templates.footer);\n    this.$menu.append(this.templates.footer());\n  }\n\n  var self = this;\n  DOM.element(window).resize(function() {\n    self._redraw();\n  });\n}\n\n// instance methods\n// ----------------\n\n_.mixin(Dropdown.prototype, EventEmitter, {\n\n  // ### private\n\n  _onSuggestionClick: function onSuggestionClick($e) {\n    this.trigger('suggestionClicked', DOM.element($e.currentTarget));\n  },\n\n  _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {\n    var elt = DOM.element($e.currentTarget);\n    if (elt.hasClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))) {\n      // we're already on the cursor\n      // => we're probably entering it again after leaving it for a nested div\n      return;\n    }\n    this._removeCursor();\n\n    // Fixes iOS double tap behaviour, by modifying the DOM right before the\n    // native href clicks happens, iOS will requires another tap to follow\n    // a suggestion that has an <a href> element inside\n    // https://www.google.com/search?q=ios+double+tap+bug+href\n    var suggestion = this;\n    setTimeout(function() {\n      // this exact line, when inside the main loop, will trigger a double tap bug\n      // on iOS devices\n      suggestion._setCursor(elt, false);\n    }, 0);\n  },\n\n  _onSuggestionMouseLeave: function onSuggestionMouseLeave($e) {\n    // $e.relatedTarget is the `EventTarget` the pointing device entered to\n    if ($e.relatedTarget) {\n      var elt = DOM.element($e.relatedTarget);\n      if (elt.closest('.' + _.className(this.cssClasses.prefix, this.cssClasses.cursor, true)).length > 0) {\n        // our father is a cursor\n        // => it means we're just leaving the suggestion for a nested div\n        return;\n      }\n    }\n    this._removeCursor();\n    this.trigger('cursorRemoved');\n  },\n\n  _onRendered: function onRendered(e, query) {\n    this.isEmpty = _.every(this.datasets, isDatasetEmpty);\n\n    if (this.isEmpty) {\n      if (query.length >= this.minLength) {\n        this.trigger('empty');\n      }\n\n      if (this.$empty) {\n        if (query.length < this.minLength) {\n          this._hide();\n        } else {\n          var html = this.templates.empty({\n            query: this.datasets[0] && this.datasets[0].query\n          });\n          this.$empty.html(html);\n          this.$empty.show();\n          this._show();\n        }\n      } else if (_.any(this.datasets, hasEmptyTemplate)) {\n        if (query.length < this.minLength) {\n          this._hide();\n        } else {\n          this._show();\n        }\n      } else {\n        this._hide();\n      }\n    } else if (this.isOpen) {\n      if (this.$empty) {\n        this.$empty.empty();\n        this.$empty.hide();\n      }\n\n      if (query.length >= this.minLength) {\n        this._show();\n      } else {\n        this._hide();\n      }\n    }\n\n    this.trigger('datasetRendered');\n\n    function isDatasetEmpty(dataset) {\n      return dataset.isEmpty();\n    }\n\n    function hasEmptyTemplate(dataset) {\n      return dataset.templates && dataset.templates.empty;\n    }\n  },\n\n  _hide: function() {\n    this.$container.hide();\n  },\n\n  _show: function() {\n    // can't use jQuery#show because $menu is a span element we want\n    // display: block; not dislay: inline;\n    this.$container.css('display', 'block');\n\n    this._redraw();\n\n    this.trigger('shown');\n  },\n\n  _redraw: function redraw() {\n    if (!this.isOpen || !this.appendTo) return;\n\n    this.trigger('redrawn');\n  },\n\n  _getSuggestions: function getSuggestions() {\n    return this.$menu.find(_.className(this.cssClasses.prefix, this.cssClasses.suggestion));\n  },\n\n  _getCursor: function getCursor() {\n    return this.$menu.find(_.className(this.cssClasses.prefix, this.cssClasses.cursor)).first();\n  },\n\n  _setCursor: function setCursor($el, updateInput) {\n    $el.first()\n      .addClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))\n      .attr('aria-selected', 'true');\n    this.trigger('cursorMoved', updateInput);\n  },\n\n  _removeCursor: function removeCursor() {\n    this._getCursor()\n      .removeClass(_.className(this.cssClasses.prefix, this.cssClasses.cursor, true))\n      .removeAttr('aria-selected');\n  },\n\n  _moveCursor: function moveCursor(increment) {\n    var $suggestions;\n    var $oldCursor;\n    var newCursorIndex;\n    var $newCursor;\n\n    if (!this.isOpen) {\n      return;\n    }\n\n    $oldCursor = this._getCursor();\n    $suggestions = this._getSuggestions();\n\n    this._removeCursor();\n\n    // shifting before and after modulo to deal with -1 index\n    newCursorIndex = $suggestions.index($oldCursor) + increment;\n    newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;\n\n    if (newCursorIndex === -1) {\n      this.trigger('cursorRemoved');\n\n      return;\n    } else if (newCursorIndex < -1) {\n      newCursorIndex = $suggestions.length - 1;\n    }\n\n    this._setCursor($newCursor = $suggestions.eq(newCursorIndex), true);\n\n    // in the case of scrollable overflow\n    // make sure the cursor is visible in the menu\n    this._ensureVisible($newCursor);\n  },\n\n  _ensureVisible: function ensureVisible($el) {\n    var elTop;\n    var elBottom;\n    var menuScrollTop;\n    var menuHeight;\n\n    elTop = $el.position().top;\n    elBottom = elTop + $el.height() +\n      parseInt($el.css('margin-top'), 10) +\n      parseInt($el.css('margin-bottom'), 10);\n    menuScrollTop = this.$menu.scrollTop();\n    menuHeight = this.$menu.height() +\n      parseInt(this.$menu.css('padding-top'), 10) +\n      parseInt(this.$menu.css('padding-bottom'), 10);\n\n    if (elTop < 0) {\n      this.$menu.scrollTop(menuScrollTop + elTop);\n    } else if (menuHeight < elBottom) {\n      this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));\n    }\n  },\n\n  // ### public\n\n  close: function close() {\n    if (this.isOpen) {\n      this.isOpen = false;\n\n      this._removeCursor();\n      this._hide();\n\n      this.trigger('closed');\n    }\n  },\n\n  open: function open() {\n    if (!this.isOpen) {\n      this.isOpen = true;\n\n      if (!this.isEmpty) {\n        this._show();\n      }\n\n      this.trigger('opened');\n    }\n  },\n\n  setLanguageDirection: function setLanguageDirection(dir) {\n    this.$menu.css(dir === 'ltr' ? this.css.ltr : this.css.rtl);\n  },\n\n  moveCursorUp: function moveCursorUp() {\n    this._moveCursor(-1);\n  },\n\n  moveCursorDown: function moveCursorDown() {\n    this._moveCursor(+1);\n  },\n\n  getDatumForSuggestion: function getDatumForSuggestion($el) {\n    var datum = null;\n\n    if ($el.length) {\n      datum = {\n        raw: Dataset.extractDatum($el),\n        value: Dataset.extractValue($el),\n        datasetName: Dataset.extractDatasetName($el)\n      };\n    }\n\n    return datum;\n  },\n\n  getCurrentCursor: function getCurrentCursor() {\n    return this._getCursor().first();\n  },\n\n  getDatumForCursor: function getDatumForCursor() {\n    return this.getDatumForSuggestion(this._getCursor().first());\n  },\n\n  getDatumForTopSuggestion: function getDatumForTopSuggestion() {\n    return this.getDatumForSuggestion(this._getSuggestions().first());\n  },\n\n  cursorTopSuggestion: function cursorTopSuggestion() {\n    this._setCursor(this._getSuggestions().first(), false);\n  },\n\n  update: function update(query) {\n    _.each(this.datasets, updateDataset);\n\n    function updateDataset(dataset) {\n      dataset.update(query);\n    }\n  },\n\n  empty: function empty() {\n    _.each(this.datasets, clearDataset);\n    this.isEmpty = true;\n\n    function clearDataset(dataset) {\n      dataset.clear();\n    }\n  },\n\n  isVisible: function isVisible() {\n    return this.isOpen && !this.isEmpty;\n  },\n\n  destroy: function destroy() {\n    this.$menu.off('.aa');\n\n    this.$menu = null;\n\n    _.each(this.datasets, destroyDataset);\n\n    function destroyDataset(dataset) {\n      dataset.destroy();\n    }\n  }\n});\n\n// helper functions\n// ----------------\nDropdown.Dataset = Dataset;\n\nfunction initializeDataset($menu, oDataset, cssClasses) {\n  return new Dropdown.Dataset(_.mixin({$menu: $menu, cssClasses: cssClasses}, oDataset));\n}\n\nmodule.exports = Dropdown;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI3MzEuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxLQUFrQjtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyxLQUFvQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsS0FBYztBQUNwQyxVQUFVLG1CQUFPLENBQUMsS0FBVTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQ0FBcUM7QUFDNUQsNkNBQTZDLHdDQUF3QztBQUNyRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvYXV0b2NvbXBsZXRlL2Ryb3Bkb3duLmpzP2IzNjAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscy5qcycpO1xudmFyIERPTSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9kb20uanMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50X2VtaXR0ZXIuanMnKTtcbnZhciBEYXRhc2V0ID0gcmVxdWlyZSgnLi9kYXRhc2V0LmpzJyk7XG52YXIgY3NzID0gcmVxdWlyZSgnLi9jc3MuanMnKTtcblxuLy8gY29uc3RydWN0b3Jcbi8vIC0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIERyb3Bkb3duKG8pIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgb25TdWdnZXN0aW9uQ2xpY2s7XG4gIHZhciBvblN1Z2dlc3Rpb25Nb3VzZUVudGVyO1xuICB2YXIgb25TdWdnZXN0aW9uTW91c2VMZWF2ZTtcblxuICBvID0gbyB8fCB7fTtcblxuICBpZiAoIW8ubWVudSkge1xuICAgIF8uZXJyb3IoJ21lbnUgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghXy5pc0FycmF5KG8uZGF0YXNldHMpICYmICFfLmlzT2JqZWN0KG8uZGF0YXNldHMpKSB7XG4gICAgXy5lcnJvcignMSBvciBtb3JlIGRhdGFzZXRzIHJlcXVpcmVkJyk7XG4gIH1cbiAgaWYgKCFvLmRhdGFzZXRzKSB7XG4gICAgXy5lcnJvcignZGF0YXNldHMgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gIHRoaXMuaXNFbXB0eSA9IHRydWU7XG4gIHRoaXMubWluTGVuZ3RoID0gby5taW5MZW5ndGggfHwgMDtcbiAgdGhpcy50ZW1wbGF0ZXMgPSB7fTtcbiAgdGhpcy5hcHBlbmRUbyA9IG8uYXBwZW5kVG8gfHwgZmFsc2U7XG4gIHRoaXMuY3NzID0gXy5taXhpbih7fSwgY3NzLCBvLmFwcGVuZFRvID8gY3NzLmFwcGVuZFRvIDoge30pO1xuICB0aGlzLmNzc0NsYXNzZXMgPSBvLmNzc0NsYXNzZXMgPSBfLm1peGluKHt9LCBjc3MuZGVmYXVsdENsYXNzZXMsIG8uY3NzQ2xhc3NlcyB8fCB7fSk7XG4gIHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXggPVxuICAgIG8uY3NzQ2xhc3Nlcy5mb3JtYXR0ZWRQcmVmaXggfHwgXy5mb3JtYXRQcmVmaXgodGhpcy5jc3NDbGFzc2VzLnByZWZpeCwgdGhpcy5jc3NDbGFzc2VzLm5vUHJlZml4KTtcblxuICAvLyBib3VuZCBmdW5jdGlvbnNcbiAgb25TdWdnZXN0aW9uQ2xpY2sgPSBfLmJpbmQodGhpcy5fb25TdWdnZXN0aW9uQ2xpY2ssIHRoaXMpO1xuICBvblN1Z2dlc3Rpb25Nb3VzZUVudGVyID0gXy5iaW5kKHRoaXMuX29uU3VnZ2VzdGlvbk1vdXNlRW50ZXIsIHRoaXMpO1xuICBvblN1Z2dlc3Rpb25Nb3VzZUxlYXZlID0gXy5iaW5kKHRoaXMuX29uU3VnZ2VzdGlvbk1vdXNlTGVhdmUsIHRoaXMpO1xuXG4gIHZhciBjc3NDbGFzcyA9IF8uY2xhc3NOYW1lKHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXgsIHRoaXMuY3NzQ2xhc3Nlcy5zdWdnZXN0aW9uKTtcbiAgdGhpcy4kbWVudSA9IERPTS5lbGVtZW50KG8ubWVudSlcbiAgICAub24oJ21vdXNlZW50ZXIuYWEnLCBjc3NDbGFzcywgb25TdWdnZXN0aW9uTW91c2VFbnRlcilcbiAgICAub24oJ21vdXNlbGVhdmUuYWEnLCBjc3NDbGFzcywgb25TdWdnZXN0aW9uTW91c2VMZWF2ZSlcbiAgICAub24oJ2NsaWNrLmFhJywgY3NzQ2xhc3MsIG9uU3VnZ2VzdGlvbkNsaWNrKTtcblxuICB0aGlzLiRjb250YWluZXIgPSBvLmFwcGVuZFRvID8gby53cmFwcGVyIDogdGhpcy4kbWVudTtcblxuICBpZiAoby50ZW1wbGF0ZXMgJiYgby50ZW1wbGF0ZXMuaGVhZGVyKSB7XG4gICAgdGhpcy50ZW1wbGF0ZXMuaGVhZGVyID0gXy50ZW1wbGF0aWZ5KG8udGVtcGxhdGVzLmhlYWRlcik7XG4gICAgdGhpcy4kbWVudS5wcmVwZW5kKHRoaXMudGVtcGxhdGVzLmhlYWRlcigpKTtcbiAgfVxuXG4gIGlmIChvLnRlbXBsYXRlcyAmJiBvLnRlbXBsYXRlcy5lbXB0eSkge1xuICAgIHRoaXMudGVtcGxhdGVzLmVtcHR5ID0gXy50ZW1wbGF0aWZ5KG8udGVtcGxhdGVzLmVtcHR5KTtcbiAgICB0aGlzLiRlbXB0eSA9IERPTS5lbGVtZW50KCc8ZGl2IGNsYXNzPVwiJyArXG4gICAgICBfLmNsYXNzTmFtZSh0aGlzLmNzc0NsYXNzZXMucHJlZml4LCB0aGlzLmNzc0NsYXNzZXMuZW1wdHksIHRydWUpICsgJ1wiPicgK1xuICAgICAgJzwvZGl2PicpO1xuICAgIHRoaXMuJG1lbnUuYXBwZW5kKHRoaXMuJGVtcHR5KTtcbiAgICB0aGlzLiRlbXB0eS5oaWRlKCk7XG4gIH1cblxuICB0aGlzLmRhdGFzZXRzID0gXy5tYXAoby5kYXRhc2V0cywgZnVuY3Rpb24ob0RhdGFzZXQpIHtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZURhdGFzZXQodGhhdC4kbWVudSwgb0RhdGFzZXQsIG8uY3NzQ2xhc3Nlcyk7XG4gIH0pO1xuICBfLmVhY2godGhpcy5kYXRhc2V0cywgZnVuY3Rpb24oZGF0YXNldCkge1xuICAgIHZhciByb290ID0gZGF0YXNldC5nZXRSb290KCk7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5wYXJlbnQoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoYXQuJG1lbnUuYXBwZW5kKHJvb3QpO1xuICAgIH1cbiAgICBkYXRhc2V0Lm9uU3luYygncmVuZGVyZWQnLCB0aGF0Ll9vblJlbmRlcmVkLCB0aGF0KTtcbiAgfSk7XG5cbiAgaWYgKG8udGVtcGxhdGVzICYmIG8udGVtcGxhdGVzLmZvb3Rlcikge1xuICAgIHRoaXMudGVtcGxhdGVzLmZvb3RlciA9IF8udGVtcGxhdGlmeShvLnRlbXBsYXRlcy5mb290ZXIpO1xuICAgIHRoaXMuJG1lbnUuYXBwZW5kKHRoaXMudGVtcGxhdGVzLmZvb3RlcigpKTtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgRE9NLmVsZW1lbnQod2luZG93KS5yZXNpemUoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fcmVkcmF3KCk7XG4gIH0pO1xufVxuXG4vLyBpbnN0YW5jZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG5cbl8ubWl4aW4oRHJvcGRvd24ucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIsIHtcblxuICAvLyAjIyMgcHJpdmF0ZVxuXG4gIF9vblN1Z2dlc3Rpb25DbGljazogZnVuY3Rpb24gb25TdWdnZXN0aW9uQ2xpY2soJGUpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ3N1Z2dlc3Rpb25DbGlja2VkJywgRE9NLmVsZW1lbnQoJGUuY3VycmVudFRhcmdldCkpO1xuICB9LFxuXG4gIF9vblN1Z2dlc3Rpb25Nb3VzZUVudGVyOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25Nb3VzZUVudGVyKCRlKSB7XG4gICAgdmFyIGVsdCA9IERPTS5lbGVtZW50KCRlLmN1cnJlbnRUYXJnZXQpO1xuICAgIGlmIChlbHQuaGFzQ2xhc3MoXy5jbGFzc05hbWUodGhpcy5jc3NDbGFzc2VzLnByZWZpeCwgdGhpcy5jc3NDbGFzc2VzLmN1cnNvciwgdHJ1ZSkpKSB7XG4gICAgICAvLyB3ZSdyZSBhbHJlYWR5IG9uIHRoZSBjdXJzb3JcbiAgICAgIC8vID0+IHdlJ3JlIHByb2JhYmx5IGVudGVyaW5nIGl0IGFnYWluIGFmdGVyIGxlYXZpbmcgaXQgZm9yIGEgbmVzdGVkIGRpdlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVDdXJzb3IoKTtcblxuICAgIC8vIEZpeGVzIGlPUyBkb3VibGUgdGFwIGJlaGF2aW91ciwgYnkgbW9kaWZ5aW5nIHRoZSBET00gcmlnaHQgYmVmb3JlIHRoZVxuICAgIC8vIG5hdGl2ZSBocmVmIGNsaWNrcyBoYXBwZW5zLCBpT1Mgd2lsbCByZXF1aXJlcyBhbm90aGVyIHRhcCB0byBmb2xsb3dcbiAgICAvLyBhIHN1Z2dlc3Rpb24gdGhhdCBoYXMgYW4gPGEgaHJlZj4gZWxlbWVudCBpbnNpZGVcbiAgICAvLyBodHRwczovL3d3dy5nb29nbGUuY29tL3NlYXJjaD9xPWlvcytkb3VibGUrdGFwK2J1ZytocmVmXG4gICAgdmFyIHN1Z2dlc3Rpb24gPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyB0aGlzIGV4YWN0IGxpbmUsIHdoZW4gaW5zaWRlIHRoZSBtYWluIGxvb3AsIHdpbGwgdHJpZ2dlciBhIGRvdWJsZSB0YXAgYnVnXG4gICAgICAvLyBvbiBpT1MgZGV2aWNlc1xuICAgICAgc3VnZ2VzdGlvbi5fc2V0Q3Vyc29yKGVsdCwgZmFsc2UpO1xuICAgIH0sIDApO1xuICB9LFxuXG4gIF9vblN1Z2dlc3Rpb25Nb3VzZUxlYXZlOiBmdW5jdGlvbiBvblN1Z2dlc3Rpb25Nb3VzZUxlYXZlKCRlKSB7XG4gICAgLy8gJGUucmVsYXRlZFRhcmdldCBpcyB0aGUgYEV2ZW50VGFyZ2V0YCB0aGUgcG9pbnRpbmcgZGV2aWNlIGVudGVyZWQgdG9cbiAgICBpZiAoJGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIGVsdCA9IERPTS5lbGVtZW50KCRlLnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgaWYgKGVsdC5jbG9zZXN0KCcuJyArIF8uY2xhc3NOYW1lKHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXgsIHRoaXMuY3NzQ2xhc3Nlcy5jdXJzb3IsIHRydWUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIG91ciBmYXRoZXIgaXMgYSBjdXJzb3JcbiAgICAgICAgLy8gPT4gaXQgbWVhbnMgd2UncmUganVzdCBsZWF2aW5nIHRoZSBzdWdnZXN0aW9uIGZvciBhIG5lc3RlZCBkaXZcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVDdXJzb3IoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2N1cnNvclJlbW92ZWQnKTtcbiAgfSxcblxuICBfb25SZW5kZXJlZDogZnVuY3Rpb24gb25SZW5kZXJlZChlLCBxdWVyeSkge1xuICAgIHRoaXMuaXNFbXB0eSA9IF8uZXZlcnkodGhpcy5kYXRhc2V0cywgaXNEYXRhc2V0RW1wdHkpO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VtcHR5Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiRlbXB0eSkge1xuICAgICAgICBpZiAocXVlcnkubGVuZ3RoIDwgdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9oaWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGh0bWwgPSB0aGlzLnRlbXBsYXRlcy5lbXB0eSh7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5kYXRhc2V0c1swXSAmJiB0aGlzLmRhdGFzZXRzWzBdLnF1ZXJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy4kZW1wdHkuaHRtbChodG1sKTtcbiAgICAgICAgICB0aGlzLiRlbXB0eS5zaG93KCk7XG4gICAgICAgICAgdGhpcy5fc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF8uYW55KHRoaXMuZGF0YXNldHMsIGhhc0VtcHR5VGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChxdWVyeS5sZW5ndGggPCB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICBpZiAodGhpcy4kZW1wdHkpIHtcbiAgICAgICAgdGhpcy4kZW1wdHkuZW1wdHkoKTtcbiAgICAgICAgdGhpcy4kZW1wdHkuaGlkZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX3Nob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2hpZGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGFzZXRSZW5kZXJlZCcpO1xuXG4gICAgZnVuY3Rpb24gaXNEYXRhc2V0RW1wdHkoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQuaXNFbXB0eSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0VtcHR5VGVtcGxhdGUoZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGRhdGFzZXQudGVtcGxhdGVzICYmIGRhdGFzZXQudGVtcGxhdGVzLmVtcHR5O1xuICAgIH1cbiAgfSxcblxuICBfaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kY29udGFpbmVyLmhpZGUoKTtcbiAgfSxcblxuICBfc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgLy8gY2FuJ3QgdXNlIGpRdWVyeSNzaG93IGJlY2F1c2UgJG1lbnUgaXMgYSBzcGFuIGVsZW1lbnQgd2Ugd2FudFxuICAgIC8vIGRpc3BsYXk6IGJsb2NrOyBub3QgZGlzbGF5OiBpbmxpbmU7XG4gICAgdGhpcy4kY29udGFpbmVyLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuXG4gICAgdGhpcy5fcmVkcmF3KCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Nob3duJyk7XG4gIH0sXG5cbiAgX3JlZHJhdzogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgIGlmICghdGhpcy5pc09wZW4gfHwgIXRoaXMuYXBwZW5kVG8pIHJldHVybjtcblxuICAgIHRoaXMudHJpZ2dlcigncmVkcmF3bicpO1xuICB9LFxuXG4gIF9nZXRTdWdnZXN0aW9uczogZnVuY3Rpb24gZ2V0U3VnZ2VzdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuJG1lbnUuZmluZChfLmNsYXNzTmFtZSh0aGlzLmNzc0NsYXNzZXMucHJlZml4LCB0aGlzLmNzc0NsYXNzZXMuc3VnZ2VzdGlvbikpO1xuICB9LFxuXG4gIF9nZXRDdXJzb3I6IGZ1bmN0aW9uIGdldEN1cnNvcigpIHtcbiAgICByZXR1cm4gdGhpcy4kbWVudS5maW5kKF8uY2xhc3NOYW1lKHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXgsIHRoaXMuY3NzQ2xhc3Nlcy5jdXJzb3IpKS5maXJzdCgpO1xuICB9LFxuXG4gIF9zZXRDdXJzb3I6IGZ1bmN0aW9uIHNldEN1cnNvcigkZWwsIHVwZGF0ZUlucHV0KSB7XG4gICAgJGVsLmZpcnN0KClcbiAgICAgIC5hZGRDbGFzcyhfLmNsYXNzTmFtZSh0aGlzLmNzc0NsYXNzZXMucHJlZml4LCB0aGlzLmNzc0NsYXNzZXMuY3Vyc29yLCB0cnVlKSlcbiAgICAgIC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2N1cnNvck1vdmVkJywgdXBkYXRlSW5wdXQpO1xuICB9LFxuXG4gIF9yZW1vdmVDdXJzb3I6IGZ1bmN0aW9uIHJlbW92ZUN1cnNvcigpIHtcbiAgICB0aGlzLl9nZXRDdXJzb3IoKVxuICAgICAgLnJlbW92ZUNsYXNzKF8uY2xhc3NOYW1lKHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXgsIHRoaXMuY3NzQ2xhc3Nlcy5jdXJzb3IsIHRydWUpKVxuICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgfSxcblxuICBfbW92ZUN1cnNvcjogZnVuY3Rpb24gbW92ZUN1cnNvcihpbmNyZW1lbnQpIHtcbiAgICB2YXIgJHN1Z2dlc3Rpb25zO1xuICAgIHZhciAkb2xkQ3Vyc29yO1xuICAgIHZhciBuZXdDdXJzb3JJbmRleDtcbiAgICB2YXIgJG5ld0N1cnNvcjtcblxuICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAkb2xkQ3Vyc29yID0gdGhpcy5fZ2V0Q3Vyc29yKCk7XG4gICAgJHN1Z2dlc3Rpb25zID0gdGhpcy5fZ2V0U3VnZ2VzdGlvbnMoKTtcblxuICAgIHRoaXMuX3JlbW92ZUN1cnNvcigpO1xuXG4gICAgLy8gc2hpZnRpbmcgYmVmb3JlIGFuZCBhZnRlciBtb2R1bG8gdG8gZGVhbCB3aXRoIC0xIGluZGV4XG4gICAgbmV3Q3Vyc29ySW5kZXggPSAkc3VnZ2VzdGlvbnMuaW5kZXgoJG9sZEN1cnNvcikgKyBpbmNyZW1lbnQ7XG4gICAgbmV3Q3Vyc29ySW5kZXggPSAobmV3Q3Vyc29ySW5kZXggKyAxKSAlICgkc3VnZ2VzdGlvbnMubGVuZ3RoICsgMSkgLSAxO1xuXG4gICAgaWYgKG5ld0N1cnNvckluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCdjdXJzb3JSZW1vdmVkJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKG5ld0N1cnNvckluZGV4IDwgLTEpIHtcbiAgICAgIG5ld0N1cnNvckluZGV4ID0gJHN1Z2dlc3Rpb25zLmxlbmd0aCAtIDE7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0Q3Vyc29yKCRuZXdDdXJzb3IgPSAkc3VnZ2VzdGlvbnMuZXEobmV3Q3Vyc29ySW5kZXgpLCB0cnVlKTtcblxuICAgIC8vIGluIHRoZSBjYXNlIG9mIHNjcm9sbGFibGUgb3ZlcmZsb3dcbiAgICAvLyBtYWtlIHN1cmUgdGhlIGN1cnNvciBpcyB2aXNpYmxlIGluIHRoZSBtZW51XG4gICAgdGhpcy5fZW5zdXJlVmlzaWJsZSgkbmV3Q3Vyc29yKTtcbiAgfSxcblxuICBfZW5zdXJlVmlzaWJsZTogZnVuY3Rpb24gZW5zdXJlVmlzaWJsZSgkZWwpIHtcbiAgICB2YXIgZWxUb3A7XG4gICAgdmFyIGVsQm90dG9tO1xuICAgIHZhciBtZW51U2Nyb2xsVG9wO1xuICAgIHZhciBtZW51SGVpZ2h0O1xuXG4gICAgZWxUb3AgPSAkZWwucG9zaXRpb24oKS50b3A7XG4gICAgZWxCb3R0b20gPSBlbFRvcCArICRlbC5oZWlnaHQoKSArXG4gICAgICBwYXJzZUludCgkZWwuY3NzKCdtYXJnaW4tdG9wJyksIDEwKSArXG4gICAgICBwYXJzZUludCgkZWwuY3NzKCdtYXJnaW4tYm90dG9tJyksIDEwKTtcbiAgICBtZW51U2Nyb2xsVG9wID0gdGhpcy4kbWVudS5zY3JvbGxUb3AoKTtcbiAgICBtZW51SGVpZ2h0ID0gdGhpcy4kbWVudS5oZWlnaHQoKSArXG4gICAgICBwYXJzZUludCh0aGlzLiRtZW51LmNzcygncGFkZGluZy10b3AnKSwgMTApICtcbiAgICAgIHBhcnNlSW50KHRoaXMuJG1lbnUuY3NzKCdwYWRkaW5nLWJvdHRvbScpLCAxMCk7XG5cbiAgICBpZiAoZWxUb3AgPCAwKSB7XG4gICAgICB0aGlzLiRtZW51LnNjcm9sbFRvcChtZW51U2Nyb2xsVG9wICsgZWxUb3ApO1xuICAgIH0gZWxzZSBpZiAobWVudUhlaWdodCA8IGVsQm90dG9tKSB7XG4gICAgICB0aGlzLiRtZW51LnNjcm9sbFRvcChtZW51U2Nyb2xsVG9wICsgKGVsQm90dG9tIC0gbWVudUhlaWdodCkpO1xuICAgIH1cbiAgfSxcblxuICAvLyAjIyMgcHVibGljXG5cbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgdGhpcy5fcmVtb3ZlQ3Vyc29yKCk7XG4gICAgICB0aGlzLl9oaWRlKCk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcignY2xvc2VkJyk7XG4gICAgfVxuICB9LFxuXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuXG4gICAgICBpZiAoIXRoaXMuaXNFbXB0eSkge1xuICAgICAgICB0aGlzLl9zaG93KCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJpZ2dlcignb3BlbmVkJyk7XG4gICAgfVxuICB9LFxuXG4gIHNldExhbmd1YWdlRGlyZWN0aW9uOiBmdW5jdGlvbiBzZXRMYW5ndWFnZURpcmVjdGlvbihkaXIpIHtcbiAgICB0aGlzLiRtZW51LmNzcyhkaXIgPT09ICdsdHInID8gdGhpcy5jc3MubHRyIDogdGhpcy5jc3MucnRsKTtcbiAgfSxcblxuICBtb3ZlQ3Vyc29yVXA6IGZ1bmN0aW9uIG1vdmVDdXJzb3JVcCgpIHtcbiAgICB0aGlzLl9tb3ZlQ3Vyc29yKC0xKTtcbiAgfSxcblxuICBtb3ZlQ3Vyc29yRG93bjogZnVuY3Rpb24gbW92ZUN1cnNvckRvd24oKSB7XG4gICAgdGhpcy5fbW92ZUN1cnNvcigrMSk7XG4gIH0sXG5cbiAgZ2V0RGF0dW1Gb3JTdWdnZXN0aW9uOiBmdW5jdGlvbiBnZXREYXR1bUZvclN1Z2dlc3Rpb24oJGVsKSB7XG4gICAgdmFyIGRhdHVtID0gbnVsbDtcblxuICAgIGlmICgkZWwubGVuZ3RoKSB7XG4gICAgICBkYXR1bSA9IHtcbiAgICAgICAgcmF3OiBEYXRhc2V0LmV4dHJhY3REYXR1bSgkZWwpLFxuICAgICAgICB2YWx1ZTogRGF0YXNldC5leHRyYWN0VmFsdWUoJGVsKSxcbiAgICAgICAgZGF0YXNldE5hbWU6IERhdGFzZXQuZXh0cmFjdERhdGFzZXROYW1lKCRlbClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdHVtO1xuICB9LFxuXG4gIGdldEN1cnJlbnRDdXJzb3I6IGZ1bmN0aW9uIGdldEN1cnJlbnRDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEN1cnNvcigpLmZpcnN0KCk7XG4gIH0sXG5cbiAgZ2V0RGF0dW1Gb3JDdXJzb3I6IGZ1bmN0aW9uIGdldERhdHVtRm9yQ3Vyc29yKCkge1xuICAgIHJldHVybiB0aGlzLmdldERhdHVtRm9yU3VnZ2VzdGlvbih0aGlzLl9nZXRDdXJzb3IoKS5maXJzdCgpKTtcbiAgfSxcblxuICBnZXREYXR1bUZvclRvcFN1Z2dlc3Rpb246IGZ1bmN0aW9uIGdldERhdHVtRm9yVG9wU3VnZ2VzdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXR1bUZvclN1Z2dlc3Rpb24odGhpcy5fZ2V0U3VnZ2VzdGlvbnMoKS5maXJzdCgpKTtcbiAgfSxcblxuICBjdXJzb3JUb3BTdWdnZXN0aW9uOiBmdW5jdGlvbiBjdXJzb3JUb3BTdWdnZXN0aW9uKCkge1xuICAgIHRoaXMuX3NldEN1cnNvcih0aGlzLl9nZXRTdWdnZXN0aW9ucygpLmZpcnN0KCksIGZhbHNlKTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShxdWVyeSkge1xuICAgIF8uZWFjaCh0aGlzLmRhdGFzZXRzLCB1cGRhdGVEYXRhc2V0KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGFzZXQoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC51cGRhdGUocXVlcnkpO1xuICAgIH1cbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgXy5lYWNoKHRoaXMuZGF0YXNldHMsIGNsZWFyRGF0YXNldCk7XG4gICAgdGhpcy5pc0VtcHR5ID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIGNsZWFyRGF0YXNldChkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIGlzVmlzaWJsZTogZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3BlbiAmJiAhdGhpcy5pc0VtcHR5O1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kbWVudS5vZmYoJy5hYScpO1xuXG4gICAgdGhpcy4kbWVudSA9IG51bGw7XG5cbiAgICBfLmVhY2godGhpcy5kYXRhc2V0cywgZGVzdHJveURhdGFzZXQpO1xuXG4gICAgZnVuY3Rpb24gZGVzdHJveURhdGFzZXQoZGF0YXNldCkge1xuICAgICAgZGF0YXNldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59KTtcblxuLy8gaGVscGVyIGZ1bmN0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLVxuRHJvcGRvd24uRGF0YXNldCA9IERhdGFzZXQ7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVEYXRhc2V0KCRtZW51LCBvRGF0YXNldCwgY3NzQ2xhc3Nlcykge1xuICByZXR1cm4gbmV3IERyb3Bkb3duLkRhdGFzZXQoXy5taXhpbih7JG1lbnU6ICRtZW51LCBjc3NDbGFzc2VzOiBjc3NDbGFzc2VzfSwgb0RhdGFzZXQpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEcm9wZG93bjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///82731\n")},94045:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar namespace = 'autocomplete:';\n\nvar _ = __webpack_require__(16220);\nvar DOM = __webpack_require__(71337);\n\n// constructor\n// -----------\n\nfunction EventBus(o) {\n  if (!o || !o.el) {\n    _.error('EventBus initialized without el');\n  }\n\n  this.$el = DOM.element(o.el);\n}\n\n// instance methods\n// ----------------\n\n_.mixin(EventBus.prototype, {\n\n  // ### public\n\n  trigger: function(type, suggestion, dataset, context) {\n    var event = _.Event(namespace + type);\n    this.$el.trigger(event, [suggestion, dataset, context]);\n    return event;\n  }\n});\n\nmodule.exports = EventBus;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQwNDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxLQUFrQjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvYXV0b2NvbXBsZXRlL2V2ZW50X2J1cy5qcz9lYjFkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIG5hbWVzcGFjZSA9ICdhdXRvY29tcGxldGU6JztcblxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMuanMnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi9jb21tb24vZG9tLmpzJyk7XG5cbi8vIGNvbnN0cnVjdG9yXG4vLyAtLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBFdmVudEJ1cyhvKSB7XG4gIGlmICghbyB8fCAhby5lbCkge1xuICAgIF8uZXJyb3IoJ0V2ZW50QnVzIGluaXRpYWxpemVkIHdpdGhvdXQgZWwnKTtcbiAgfVxuXG4gIHRoaXMuJGVsID0gRE9NLmVsZW1lbnQoby5lbCk7XG59XG5cbi8vIGluc3RhbmNlIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS1cblxuXy5taXhpbihFdmVudEJ1cy5wcm90b3R5cGUsIHtcblxuICAvLyAjIyMgcHVibGljXG5cbiAgdHJpZ2dlcjogZnVuY3Rpb24odHlwZSwgc3VnZ2VzdGlvbiwgZGF0YXNldCwgY29udGV4dCkge1xuICAgIHZhciBldmVudCA9IF8uRXZlbnQobmFtZXNwYWNlICsgdHlwZSk7XG4gICAgdGhpcy4kZWwudHJpZ2dlcihldmVudCwgW3N1Z2dlc3Rpb24sIGRhdGFzZXQsIGNvbnRleHRdKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50QnVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///94045\n")},31805:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar immediate = __webpack_require__(90874);\nvar splitter = /\\s+/;\n\nmodule.exports = {\n  onSync: onSync,\n  onAsync: onAsync,\n  off: off,\n  trigger: trigger\n};\n\nfunction on(method, types, cb, context) {\n  var type;\n\n  if (!cb) {\n    return this;\n  }\n\n  types = types.split(splitter);\n  cb = context ? bindContext(cb, context) : cb;\n\n  this._callbacks = this._callbacks || {};\n\n  while (type = types.shift()) {\n    this._callbacks[type] = this._callbacks[type] || {sync: [], async: []};\n    this._callbacks[type][method].push(cb);\n  }\n\n  return this;\n}\n\nfunction onAsync(types, cb, context) {\n  return on.call(this, 'async', types, cb, context);\n}\n\nfunction onSync(types, cb, context) {\n  return on.call(this, 'sync', types, cb, context);\n}\n\nfunction off(types) {\n  var type;\n\n  if (!this._callbacks) {\n    return this;\n  }\n\n  types = types.split(splitter);\n\n  while (type = types.shift()) {\n    delete this._callbacks[type];\n  }\n\n  return this;\n}\n\nfunction trigger(types) {\n  var type;\n  var callbacks;\n  var args;\n  var syncFlush;\n  var asyncFlush;\n\n  if (!this._callbacks) {\n    return this;\n  }\n\n  types = types.split(splitter);\n  args = [].slice.call(arguments, 1);\n\n  while ((type = types.shift()) && (callbacks = this._callbacks[type])) { // eslint-disable-line\n    syncFlush = getFlush(callbacks.sync, this, [type].concat(args));\n    asyncFlush = getFlush(callbacks.async, this, [type].concat(args));\n\n    if (syncFlush()) {\n      immediate(asyncFlush);\n    }\n  }\n\n  return this;\n}\n\nfunction getFlush(callbacks, context, args) {\n  return flush;\n\n  function flush() {\n    var cancelled;\n\n    for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {\n      // only cancel if the callback explicitly returns false\n      cancelled = callbacks[i].apply(context, args) === false;\n    }\n\n    return !cancelled;\n  }\n}\n\nfunction bindContext(fn, context) {\n  return fn.bind ?\n    fn.bind(context) :\n    function() { fn.apply(context, [].slice.call(arguments, 0)); };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE4MDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsS0FBVztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEVBQTBFO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLHVCQUF1QjtBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9hdXRvY29tcGxldGUvZXZlbnRfZW1pdHRlci5qcz82NzY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGltbWVkaWF0ZSA9IHJlcXVpcmUoJ2ltbWVkaWF0ZScpO1xudmFyIHNwbGl0dGVyID0gL1xccysvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgb25TeW5jOiBvblN5bmMsXG4gIG9uQXN5bmM6IG9uQXN5bmMsXG4gIG9mZjogb2ZmLFxuICB0cmlnZ2VyOiB0cmlnZ2VyXG59O1xuXG5mdW5jdGlvbiBvbihtZXRob2QsIHR5cGVzLCBjYiwgY29udGV4dCkge1xuICB2YXIgdHlwZTtcblxuICBpZiAoIWNiKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0eXBlcyA9IHR5cGVzLnNwbGl0KHNwbGl0dGVyKTtcbiAgY2IgPSBjb250ZXh0ID8gYmluZENvbnRleHQoY2IsIGNvbnRleHQpIDogY2I7XG5cbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIHdoaWxlICh0eXBlID0gdHlwZXMuc2hpZnQoKSkge1xuICAgIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSA9IHRoaXMuX2NhbGxiYWNrc1t0eXBlXSB8fCB7c3luYzogW10sIGFzeW5jOiBbXX07XG4gICAgdGhpcy5fY2FsbGJhY2tzW3R5cGVdW21ldGhvZF0ucHVzaChjYik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gb25Bc3luYyh0eXBlcywgY2IsIGNvbnRleHQpIHtcbiAgcmV0dXJuIG9uLmNhbGwodGhpcywgJ2FzeW5jJywgdHlwZXMsIGNiLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gb25TeW5jKHR5cGVzLCBjYiwgY29udGV4dCkge1xuICByZXR1cm4gb24uY2FsbCh0aGlzLCAnc3luYycsIHR5cGVzLCBjYiwgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG9mZih0eXBlcykge1xuICB2YXIgdHlwZTtcblxuICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHlwZXMgPSB0eXBlcy5zcGxpdChzcGxpdHRlcik7XG5cbiAgd2hpbGUgKHR5cGUgPSB0eXBlcy5zaGlmdCgpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyKHR5cGVzKSB7XG4gIHZhciB0eXBlO1xuICB2YXIgY2FsbGJhY2tzO1xuICB2YXIgYXJncztcbiAgdmFyIHN5bmNGbHVzaDtcbiAgdmFyIGFzeW5jRmx1c2g7XG5cbiAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHR5cGVzID0gdHlwZXMuc3BsaXQoc3BsaXR0ZXIpO1xuICBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIHdoaWxlICgodHlwZSA9IHR5cGVzLnNoaWZ0KCkpICYmIChjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbdHlwZV0pKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBzeW5jRmx1c2ggPSBnZXRGbHVzaChjYWxsYmFja3Muc3luYywgdGhpcywgW3R5cGVdLmNvbmNhdChhcmdzKSk7XG4gICAgYXN5bmNGbHVzaCA9IGdldEZsdXNoKGNhbGxiYWNrcy5hc3luYywgdGhpcywgW3R5cGVdLmNvbmNhdChhcmdzKSk7XG5cbiAgICBpZiAoc3luY0ZsdXNoKCkpIHtcbiAgICAgIGltbWVkaWF0ZShhc3luY0ZsdXNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZ2V0Rmx1c2goY2FsbGJhY2tzLCBjb250ZXh0LCBhcmdzKSB7XG4gIHJldHVybiBmbHVzaDtcblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB2YXIgY2FuY2VsbGVkO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7ICFjYW5jZWxsZWQgJiYgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBvbmx5IGNhbmNlbCBpZiB0aGUgY2FsbGJhY2sgZXhwbGljaXRseSByZXR1cm5zIGZhbHNlXG4gICAgICBjYW5jZWxsZWQgPSBjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dCwgYXJncykgPT09IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiAhY2FuY2VsbGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRDb250ZXh0KGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBmbi5iaW5kID9cbiAgICBmbi5iaW5kKGNvbnRleHQpIDpcbiAgICBmdW5jdGlvbigpIHsgZm4uYXBwbHkoY29udGV4dCwgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApKTsgfTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31805\n")},74499:module=>{"use strict";eval("\n\nmodule.exports = {\n  wrapper: '<span class=\"%ROOT%\"></span>',\n  dropdown: '<span class=\"%PREFIX%%DROPDOWN_MENU%\"></span>',\n  dataset: '<div class=\"%PREFIX%%DATASET%-%CLASS%\"></div>',\n  suggestions: '<span class=\"%PREFIX%%SUGGESTIONS%\"></span>',\n  suggestion: '<div class=\"%PREFIX%%SUGGESTION%\"></div>'\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ0OTkuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvYXV0b2NvbXBsZXRlL2h0bWwuanM/ZDc3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3cmFwcGVyOiAnPHNwYW4gY2xhc3M9XCIlUk9PVCVcIj48L3NwYW4+JyxcbiAgZHJvcGRvd246ICc8c3BhbiBjbGFzcz1cIiVQUkVGSVglJURST1BET1dOX01FTlUlXCI+PC9zcGFuPicsXG4gIGRhdGFzZXQ6ICc8ZGl2IGNsYXNzPVwiJVBSRUZJWCUlREFUQVNFVCUtJUNMQVNTJVwiPjwvZGl2PicsXG4gIHN1Z2dlc3Rpb25zOiAnPHNwYW4gY2xhc3M9XCIlUFJFRklYJSVTVUdHRVNUSU9OUyVcIj48L3NwYW4+JyxcbiAgc3VnZ2VzdGlvbjogJzxkaXYgY2xhc3M9XCIlUFJFRklYJSVTVUdHRVNUSU9OJVwiPjwvZGl2Pidcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74499\n")},97748:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar specialKeyCodeMap;\n\nspecialKeyCodeMap = {\n  9: 'tab',\n  27: 'esc',\n  37: 'left',\n  39: 'right',\n  13: 'enter',\n  38: 'up',\n  40: 'down'\n};\n\nvar _ = __webpack_require__(16220);\nvar DOM = __webpack_require__(71337);\nvar EventEmitter = __webpack_require__(31805);\n\n// constructor\n// -----------\n\nfunction Input(o) {\n  var that = this;\n  var onBlur;\n  var onFocus;\n  var onKeydown;\n  var onInput;\n\n  o = o || {};\n\n  if (!o.input) {\n    _.error('input is missing');\n  }\n\n  // bound functions\n  onBlur = _.bind(this._onBlur, this);\n  onFocus = _.bind(this._onFocus, this);\n  onKeydown = _.bind(this._onKeydown, this);\n  onInput = _.bind(this._onInput, this);\n\n  this.$hint = DOM.element(o.hint);\n  this.$input = DOM.element(o.input)\n    .on('blur.aa', onBlur)\n    .on('focus.aa', onFocus)\n    .on('keydown.aa', onKeydown);\n\n  // if no hint, noop all the hint related functions\n  if (this.$hint.length === 0) {\n    this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;\n  }\n\n  // ie7 and ie8 don't support the input event\n  // ie9 doesn't fire the input event when characters are removed\n  // not sure if ie10 is compatible\n  if (!_.isMsie()) {\n    this.$input.on('input.aa', onInput);\n  } else {\n    this.$input.on('keydown.aa keypress.aa cut.aa paste.aa', function($e) {\n      // if a special key triggered this, ignore it\n      if (specialKeyCodeMap[$e.which || $e.keyCode]) {\n        return;\n      }\n\n      // give the browser a chance to update the value of the input\n      // before checking to see if the query changed\n      _.defer(_.bind(that._onInput, that, $e));\n    });\n  }\n\n  // the query defaults to whatever the value of the input is\n  // on initialization, it'll most likely be an empty string\n  this.query = this.$input.val();\n\n  // helps with calculating the width of the input's value\n  this.$overflowHelper = buildOverflowHelper(this.$input);\n}\n\n// static methods\n// --------------\n\nInput.normalizeQuery = function(str) {\n  // strips leading whitespace and condenses all whitespace\n  return (str || '').replace(/^\\s*/g, '').replace(/\\s{2,}/g, ' ');\n};\n\n// instance methods\n// ----------------\n\n_.mixin(Input.prototype, EventEmitter, {\n\n  // ### private\n\n  _onBlur: function onBlur() {\n    this.resetInputValue();\n    this.$input.removeAttr('aria-activedescendant');\n    this.trigger('blurred');\n  },\n\n  _onFocus: function onFocus() {\n    this.trigger('focused');\n  },\n\n  _onKeydown: function onKeydown($e) {\n    // which is normalized and consistent (but not for ie)\n    var keyName = specialKeyCodeMap[$e.which || $e.keyCode];\n\n    this._managePreventDefault(keyName, $e);\n    if (keyName && this._shouldTrigger(keyName, $e)) {\n      this.trigger(keyName + 'Keyed', $e);\n    }\n  },\n\n  _onInput: function onInput() {\n    this._checkInputValue();\n  },\n\n  _managePreventDefault: function managePreventDefault(keyName, $e) {\n    var preventDefault;\n    var hintValue;\n    var inputValue;\n\n    switch (keyName) {\n    case 'tab':\n      hintValue = this.getHint();\n      inputValue = this.getInputValue();\n\n      preventDefault = hintValue &&\n        hintValue !== inputValue &&\n        !withModifier($e);\n      break;\n\n    case 'up':\n    case 'down':\n      preventDefault = !withModifier($e);\n      break;\n\n    default:\n      preventDefault = false;\n    }\n\n    if (preventDefault) {\n      $e.preventDefault();\n    }\n  },\n\n  _shouldTrigger: function shouldTrigger(keyName, $e) {\n    var trigger;\n\n    switch (keyName) {\n    case 'tab':\n      trigger = !withModifier($e);\n      break;\n\n    default:\n      trigger = true;\n    }\n\n    return trigger;\n  },\n\n  _checkInputValue: function checkInputValue() {\n    var inputValue;\n    var areEquivalent;\n    var hasDifferentWhitespace;\n\n    inputValue = this.getInputValue();\n    areEquivalent = areQueriesEquivalent(inputValue, this.query);\n    hasDifferentWhitespace = areEquivalent && this.query ?\n      this.query.length !== inputValue.length : false;\n\n    this.query = inputValue;\n\n    if (!areEquivalent) {\n      this.trigger('queryChanged', this.query);\n    } else if (hasDifferentWhitespace) {\n      this.trigger('whitespaceChanged', this.query);\n    }\n  },\n\n  // ### public\n\n  focus: function focus() {\n    this.$input.focus();\n  },\n\n  blur: function blur() {\n    this.$input.blur();\n  },\n\n  getQuery: function getQuery() {\n    return this.query;\n  },\n\n  setQuery: function setQuery(query) {\n    this.query = query;\n  },\n\n  getInputValue: function getInputValue() {\n    return this.$input.val();\n  },\n\n  setInputValue: function setInputValue(value, silent) {\n    if (typeof value === 'undefined') {\n      value = this.query;\n    }\n    this.$input.val(value);\n\n    // silent prevents any additional events from being triggered\n    if (silent) {\n      this.clearHint();\n    } else {\n      this._checkInputValue();\n    }\n  },\n\n  expand: function expand() {\n    this.$input.attr('aria-expanded', 'true');\n  },\n\n  collapse: function collapse() {\n    this.$input.attr('aria-expanded', 'false');\n  },\n\n  setActiveDescendant: function setActiveDescendant(activedescendantId) {\n    this.$input.attr('aria-activedescendant', activedescendantId);\n  },\n\n  removeActiveDescendant: function removeActiveDescendant() {\n    this.$input.removeAttr('aria-activedescendant');\n  },\n\n  resetInputValue: function resetInputValue() {\n    this.setInputValue(this.query, true);\n  },\n\n  getHint: function getHint() {\n    return this.$hint.val();\n  },\n\n  setHint: function setHint(value) {\n    this.$hint.val(value);\n  },\n\n  clearHint: function clearHint() {\n    this.setHint('');\n  },\n\n  clearHintIfInvalid: function clearHintIfInvalid() {\n    var val;\n    var hint;\n    var valIsPrefixOfHint;\n    var isValid;\n\n    val = this.getInputValue();\n    hint = this.getHint();\n    valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;\n    isValid = val !== '' && valIsPrefixOfHint && !this.hasOverflow();\n\n    if (!isValid) {\n      this.clearHint();\n    }\n  },\n\n  getLanguageDirection: function getLanguageDirection() {\n    return (this.$input.css('direction') || 'ltr').toLowerCase();\n  },\n\n  hasOverflow: function hasOverflow() {\n    // 2 is arbitrary, just picking a small number to handle edge cases\n    var constraint = this.$input.width() - 2;\n\n    this.$overflowHelper.text(this.getInputValue());\n\n    return this.$overflowHelper.width() >= constraint;\n  },\n\n  isCursorAtEnd: function() {\n    var valueLength;\n    var selectionStart;\n    var range;\n\n    valueLength = this.$input.val().length;\n    selectionStart = this.$input[0].selectionStart;\n\n    if (_.isNumber(selectionStart)) {\n      return selectionStart === valueLength;\n    } else if (document.selection) {\n      // NOTE: this won't work unless the input has focus, the good news\n      // is this code should only get called when the input has focus\n      range = document.selection.createRange();\n      range.moveStart('character', -valueLength);\n\n      return valueLength === range.text.length;\n    }\n\n    return true;\n  },\n\n  destroy: function destroy() {\n    this.$hint.off('.aa');\n    this.$input.off('.aa');\n\n    this.$hint = this.$input = this.$overflowHelper = null;\n  }\n});\n\n// helper functions\n// ----------------\n\nfunction buildOverflowHelper($input) {\n  return DOM.element('<pre aria-hidden=\"true\"></pre>')\n    .css({\n      // position helper off-screen\n      position: 'absolute',\n      visibility: 'hidden',\n      // avoid line breaks and whitespace collapsing\n      whiteSpace: 'pre',\n      // use same font css as input to calculate accurate width\n      fontFamily: $input.css('font-family'),\n      fontSize: $input.css('font-size'),\n      fontStyle: $input.css('font-style'),\n      fontVariant: $input.css('font-variant'),\n      fontWeight: $input.css('font-weight'),\n      wordSpacing: $input.css('word-spacing'),\n      letterSpacing: $input.css('letter-spacing'),\n      textIndent: $input.css('text-indent'),\n      textRendering: $input.css('text-rendering'),\n      textTransform: $input.css('text-transform')\n    })\n    .insertAfter($input);\n}\n\nfunction areQueriesEquivalent(a, b) {\n  return Input.normalizeQuery(a) === Input.normalizeQuery(b);\n}\n\nfunction withModifier($e) {\n  return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;\n}\n\nmodule.exports = Input;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTc3NDguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsbUJBQU8sQ0FBQyxLQUFvQjtBQUNwQyxVQUFVLG1CQUFPLENBQUMsS0FBa0I7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsS0FBb0I7O0FBRS9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9hdXRvY29tcGxldGUvaW5wdXQuanM/YjFmMCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzcGVjaWFsS2V5Q29kZU1hcDtcblxuc3BlY2lhbEtleUNvZGVNYXAgPSB7XG4gIDk6ICd0YWInLFxuICAyNzogJ2VzYycsXG4gIDM3OiAnbGVmdCcsXG4gIDM5OiAncmlnaHQnLFxuICAxMzogJ2VudGVyJyxcbiAgMzg6ICd1cCcsXG4gIDQwOiAnZG93bidcbn07XG5cbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzLmpzJyk7XG52YXIgRE9NID0gcmVxdWlyZSgnLi4vY29tbW9uL2RvbS5qcycpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vZXZlbnRfZW1pdHRlci5qcycpO1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gSW5wdXQobykge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBvbkJsdXI7XG4gIHZhciBvbkZvY3VzO1xuICB2YXIgb25LZXlkb3duO1xuICB2YXIgb25JbnB1dDtcblxuICBvID0gbyB8fCB7fTtcblxuICBpZiAoIW8uaW5wdXQpIHtcbiAgICBfLmVycm9yKCdpbnB1dCBpcyBtaXNzaW5nJyk7XG4gIH1cblxuICAvLyBib3VuZCBmdW5jdGlvbnNcbiAgb25CbHVyID0gXy5iaW5kKHRoaXMuX29uQmx1ciwgdGhpcyk7XG4gIG9uRm9jdXMgPSBfLmJpbmQodGhpcy5fb25Gb2N1cywgdGhpcyk7XG4gIG9uS2V5ZG93biA9IF8uYmluZCh0aGlzLl9vbktleWRvd24sIHRoaXMpO1xuICBvbklucHV0ID0gXy5iaW5kKHRoaXMuX29uSW5wdXQsIHRoaXMpO1xuXG4gIHRoaXMuJGhpbnQgPSBET00uZWxlbWVudChvLmhpbnQpO1xuICB0aGlzLiRpbnB1dCA9IERPTS5lbGVtZW50KG8uaW5wdXQpXG4gICAgLm9uKCdibHVyLmFhJywgb25CbHVyKVxuICAgIC5vbignZm9jdXMuYWEnLCBvbkZvY3VzKVxuICAgIC5vbigna2V5ZG93bi5hYScsIG9uS2V5ZG93bik7XG5cbiAgLy8gaWYgbm8gaGludCwgbm9vcCBhbGwgdGhlIGhpbnQgcmVsYXRlZCBmdW5jdGlvbnNcbiAgaWYgKHRoaXMuJGhpbnQubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5zZXRIaW50ID0gdGhpcy5nZXRIaW50ID0gdGhpcy5jbGVhckhpbnQgPSB0aGlzLmNsZWFySGludElmSW52YWxpZCA9IF8ubm9vcDtcbiAgfVxuXG4gIC8vIGllNyBhbmQgaWU4IGRvbid0IHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50XG4gIC8vIGllOSBkb2Vzbid0IGZpcmUgdGhlIGlucHV0IGV2ZW50IHdoZW4gY2hhcmFjdGVycyBhcmUgcmVtb3ZlZFxuICAvLyBub3Qgc3VyZSBpZiBpZTEwIGlzIGNvbXBhdGlibGVcbiAgaWYgKCFfLmlzTXNpZSgpKSB7XG4gICAgdGhpcy4kaW5wdXQub24oJ2lucHV0LmFhJywgb25JbnB1dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24uYWEga2V5cHJlc3MuYWEgY3V0LmFhIHBhc3RlLmFhJywgZnVuY3Rpb24oJGUpIHtcbiAgICAgIC8vIGlmIGEgc3BlY2lhbCBrZXkgdHJpZ2dlcmVkIHRoaXMsIGlnbm9yZSBpdFxuICAgICAgaWYgKHNwZWNpYWxLZXlDb2RlTWFwWyRlLndoaWNoIHx8ICRlLmtleUNvZGVdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZ2l2ZSB0aGUgYnJvd3NlciBhIGNoYW5jZSB0byB1cGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dFxuICAgICAgLy8gYmVmb3JlIGNoZWNraW5nIHRvIHNlZSBpZiB0aGUgcXVlcnkgY2hhbmdlZFxuICAgICAgXy5kZWZlcihfLmJpbmQodGhhdC5fb25JbnB1dCwgdGhhdCwgJGUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHRoZSBxdWVyeSBkZWZhdWx0cyB0byB3aGF0ZXZlciB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGlzXG4gIC8vIG9uIGluaXRpYWxpemF0aW9uLCBpdCdsbCBtb3N0IGxpa2VseSBiZSBhbiBlbXB0eSBzdHJpbmdcbiAgdGhpcy5xdWVyeSA9IHRoaXMuJGlucHV0LnZhbCgpO1xuXG4gIC8vIGhlbHBzIHdpdGggY2FsY3VsYXRpbmcgdGhlIHdpZHRoIG9mIHRoZSBpbnB1dCdzIHZhbHVlXG4gIHRoaXMuJG92ZXJmbG93SGVscGVyID0gYnVpbGRPdmVyZmxvd0hlbHBlcih0aGlzLiRpbnB1dCk7XG59XG5cbi8vIHN0YXRpYyBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLVxuXG5JbnB1dC5ub3JtYWxpemVRdWVyeSA9IGZ1bmN0aW9uKHN0cikge1xuICAvLyBzdHJpcHMgbGVhZGluZyB3aGl0ZXNwYWNlIGFuZCBjb25kZW5zZXMgYWxsIHdoaXRlc3BhY2VcbiAgcmV0dXJuIChzdHIgfHwgJycpLnJlcGxhY2UoL15cXHMqL2csICcnKS5yZXBsYWNlKC9cXHN7Mix9L2csICcgJyk7XG59O1xuXG4vLyBpbnN0YW5jZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG5cbl8ubWl4aW4oSW5wdXQucHJvdG90eXBlLCBFdmVudEVtaXR0ZXIsIHtcblxuICAvLyAjIyMgcHJpdmF0ZVxuXG4gIF9vbkJsdXI6IGZ1bmN0aW9uIG9uQmx1cigpIHtcbiAgICB0aGlzLnJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgIHRoaXMuJGlucHV0LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICAgIHRoaXMudHJpZ2dlcignYmx1cnJlZCcpO1xuICB9LFxuXG4gIF9vbkZvY3VzOiBmdW5jdGlvbiBvbkZvY3VzKCkge1xuICAgIHRoaXMudHJpZ2dlcignZm9jdXNlZCcpO1xuICB9LFxuXG4gIF9vbktleWRvd246IGZ1bmN0aW9uIG9uS2V5ZG93bigkZSkge1xuICAgIC8vIHdoaWNoIGlzIG5vcm1hbGl6ZWQgYW5kIGNvbnNpc3RlbnQgKGJ1dCBub3QgZm9yIGllKVxuICAgIHZhciBrZXlOYW1lID0gc3BlY2lhbEtleUNvZGVNYXBbJGUud2hpY2ggfHwgJGUua2V5Q29kZV07XG5cbiAgICB0aGlzLl9tYW5hZ2VQcmV2ZW50RGVmYXVsdChrZXlOYW1lLCAkZSk7XG4gICAgaWYgKGtleU5hbWUgJiYgdGhpcy5fc2hvdWxkVHJpZ2dlcihrZXlOYW1lLCAkZSkpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihrZXlOYW1lICsgJ0tleWVkJywgJGUpO1xuICAgIH1cbiAgfSxcblxuICBfb25JbnB1dDogZnVuY3Rpb24gb25JbnB1dCgpIHtcbiAgICB0aGlzLl9jaGVja0lucHV0VmFsdWUoKTtcbiAgfSxcblxuICBfbWFuYWdlUHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIG1hbmFnZVByZXZlbnREZWZhdWx0KGtleU5hbWUsICRlKSB7XG4gICAgdmFyIHByZXZlbnREZWZhdWx0O1xuICAgIHZhciBoaW50VmFsdWU7XG4gICAgdmFyIGlucHV0VmFsdWU7XG5cbiAgICBzd2l0Y2ggKGtleU5hbWUpIHtcbiAgICBjYXNlICd0YWInOlxuICAgICAgaGludFZhbHVlID0gdGhpcy5nZXRIaW50KCk7XG4gICAgICBpbnB1dFZhbHVlID0gdGhpcy5nZXRJbnB1dFZhbHVlKCk7XG5cbiAgICAgIHByZXZlbnREZWZhdWx0ID0gaGludFZhbHVlICYmXG4gICAgICAgIGhpbnRWYWx1ZSAhPT0gaW5wdXRWYWx1ZSAmJlxuICAgICAgICAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXAnOlxuICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgcHJldmVudERlZmF1bHQgPSAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHByZXZlbnREZWZhdWx0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XG4gICAgICAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcblxuICBfc2hvdWxkVHJpZ2dlcjogZnVuY3Rpb24gc2hvdWxkVHJpZ2dlcihrZXlOYW1lLCAkZSkge1xuICAgIHZhciB0cmlnZ2VyO1xuXG4gICAgc3dpdGNoIChrZXlOYW1lKSB7XG4gICAgY2FzZSAndGFiJzpcbiAgICAgIHRyaWdnZXIgPSAhd2l0aE1vZGlmaWVyKCRlKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRyaWdnZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB0cmlnZ2VyO1xuICB9LFxuXG4gIF9jaGVja0lucHV0VmFsdWU6IGZ1bmN0aW9uIGNoZWNrSW5wdXRWYWx1ZSgpIHtcbiAgICB2YXIgaW5wdXRWYWx1ZTtcbiAgICB2YXIgYXJlRXF1aXZhbGVudDtcbiAgICB2YXIgaGFzRGlmZmVyZW50V2hpdGVzcGFjZTtcblxuICAgIGlucHV0VmFsdWUgPSB0aGlzLmdldElucHV0VmFsdWUoKTtcbiAgICBhcmVFcXVpdmFsZW50ID0gYXJlUXVlcmllc0VxdWl2YWxlbnQoaW5wdXRWYWx1ZSwgdGhpcy5xdWVyeSk7XG4gICAgaGFzRGlmZmVyZW50V2hpdGVzcGFjZSA9IGFyZUVxdWl2YWxlbnQgJiYgdGhpcy5xdWVyeSA/XG4gICAgICB0aGlzLnF1ZXJ5Lmxlbmd0aCAhPT0gaW5wdXRWYWx1ZS5sZW5ndGggOiBmYWxzZTtcblxuICAgIHRoaXMucXVlcnkgPSBpbnB1dFZhbHVlO1xuXG4gICAgaWYgKCFhcmVFcXVpdmFsZW50KSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5Q2hhbmdlZCcsIHRoaXMucXVlcnkpO1xuICAgIH0gZWxzZSBpZiAoaGFzRGlmZmVyZW50V2hpdGVzcGFjZSkge1xuICAgICAgdGhpcy50cmlnZ2VyKCd3aGl0ZXNwYWNlQ2hhbmdlZCcsIHRoaXMucXVlcnkpO1xuICAgIH1cbiAgfSxcblxuICAvLyAjIyMgcHVibGljXG5cbiAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKCkge1xuICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gIH0sXG5cbiAgYmx1cjogZnVuY3Rpb24gYmx1cigpIHtcbiAgICB0aGlzLiRpbnB1dC5ibHVyKCk7XG4gIH0sXG5cbiAgZ2V0UXVlcnk6IGZ1bmN0aW9uIGdldFF1ZXJ5KCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5O1xuICB9LFxuXG4gIHNldFF1ZXJ5OiBmdW5jdGlvbiBzZXRRdWVyeShxdWVyeSkge1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgfSxcblxuICBnZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBnZXRJbnB1dFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLiRpbnB1dC52YWwoKTtcbiAgfSxcblxuICBzZXRJbnB1dFZhbHVlOiBmdW5jdGlvbiBzZXRJbnB1dFZhbHVlKHZhbHVlLCBzaWxlbnQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnF1ZXJ5O1xuICAgIH1cbiAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuXG4gICAgLy8gc2lsZW50IHByZXZlbnRzIGFueSBhZGRpdGlvbmFsIGV2ZW50cyBmcm9tIGJlaW5nIHRyaWdnZXJlZFxuICAgIGlmIChzaWxlbnQpIHtcbiAgICAgIHRoaXMuY2xlYXJIaW50KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoZWNrSW5wdXRWYWx1ZSgpO1xuICAgIH1cbiAgfSxcblxuICBleHBhbmQ6IGZ1bmN0aW9uIGV4cGFuZCgpIHtcbiAgICB0aGlzLiRpbnB1dC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgfSxcblxuICBjb2xsYXBzZTogZnVuY3Rpb24gY29sbGFwc2UoKSB7XG4gICAgdGhpcy4kaW5wdXQuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICB9LFxuXG4gIHNldEFjdGl2ZURlc2NlbmRhbnQ6IGZ1bmN0aW9uIHNldEFjdGl2ZURlc2NlbmRhbnQoYWN0aXZlZGVzY2VuZGFudElkKSB7XG4gICAgdGhpcy4kaW5wdXQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgYWN0aXZlZGVzY2VuZGFudElkKTtcbiAgfSxcblxuICByZW1vdmVBY3RpdmVEZXNjZW5kYW50OiBmdW5jdGlvbiByZW1vdmVBY3RpdmVEZXNjZW5kYW50KCkge1xuICAgIHRoaXMuJGlucHV0LnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xuICB9LFxuXG4gIHJlc2V0SW5wdXRWYWx1ZTogZnVuY3Rpb24gcmVzZXRJbnB1dFZhbHVlKCkge1xuICAgIHRoaXMuc2V0SW5wdXRWYWx1ZSh0aGlzLnF1ZXJ5LCB0cnVlKTtcbiAgfSxcblxuICBnZXRIaW50OiBmdW5jdGlvbiBnZXRIaW50KCkge1xuICAgIHJldHVybiB0aGlzLiRoaW50LnZhbCgpO1xuICB9LFxuXG4gIHNldEhpbnQ6IGZ1bmN0aW9uIHNldEhpbnQodmFsdWUpIHtcbiAgICB0aGlzLiRoaW50LnZhbCh2YWx1ZSk7XG4gIH0sXG5cbiAgY2xlYXJIaW50OiBmdW5jdGlvbiBjbGVhckhpbnQoKSB7XG4gICAgdGhpcy5zZXRIaW50KCcnKTtcbiAgfSxcblxuICBjbGVhckhpbnRJZkludmFsaWQ6IGZ1bmN0aW9uIGNsZWFySGludElmSW52YWxpZCgpIHtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBoaW50O1xuICAgIHZhciB2YWxJc1ByZWZpeE9mSGludDtcbiAgICB2YXIgaXNWYWxpZDtcblxuICAgIHZhbCA9IHRoaXMuZ2V0SW5wdXRWYWx1ZSgpO1xuICAgIGhpbnQgPSB0aGlzLmdldEhpbnQoKTtcbiAgICB2YWxJc1ByZWZpeE9mSGludCA9IHZhbCAhPT0gaGludCAmJiBoaW50LmluZGV4T2YodmFsKSA9PT0gMDtcbiAgICBpc1ZhbGlkID0gdmFsICE9PSAnJyAmJiB2YWxJc1ByZWZpeE9mSGludCAmJiAhdGhpcy5oYXNPdmVyZmxvdygpO1xuXG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB0aGlzLmNsZWFySGludCgpO1xuICAgIH1cbiAgfSxcblxuICBnZXRMYW5ndWFnZURpcmVjdGlvbjogZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLiRpbnB1dC5jc3MoJ2RpcmVjdGlvbicpIHx8ICdsdHInKS50b0xvd2VyQ2FzZSgpO1xuICB9LFxuXG4gIGhhc092ZXJmbG93OiBmdW5jdGlvbiBoYXNPdmVyZmxvdygpIHtcbiAgICAvLyAyIGlzIGFyYml0cmFyeSwganVzdCBwaWNraW5nIGEgc21hbGwgbnVtYmVyIHRvIGhhbmRsZSBlZGdlIGNhc2VzXG4gICAgdmFyIGNvbnN0cmFpbnQgPSB0aGlzLiRpbnB1dC53aWR0aCgpIC0gMjtcblxuICAgIHRoaXMuJG92ZXJmbG93SGVscGVyLnRleHQodGhpcy5nZXRJbnB1dFZhbHVlKCkpO1xuXG4gICAgcmV0dXJuIHRoaXMuJG92ZXJmbG93SGVscGVyLndpZHRoKCkgPj0gY29uc3RyYWludDtcbiAgfSxcblxuICBpc0N1cnNvckF0RW5kOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWVMZW5ndGg7XG4gICAgdmFyIHNlbGVjdGlvblN0YXJ0O1xuICAgIHZhciByYW5nZTtcblxuICAgIHZhbHVlTGVuZ3RoID0gdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoO1xuICAgIHNlbGVjdGlvblN0YXJ0ID0gdGhpcy4kaW5wdXRbMF0uc2VsZWN0aW9uU3RhcnQ7XG5cbiAgICBpZiAoXy5pc051bWJlcihzZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgIHJldHVybiBzZWxlY3Rpb25TdGFydCA9PT0gdmFsdWVMZW5ndGg7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24pIHtcbiAgICAgIC8vIE5PVEU6IHRoaXMgd29uJ3Qgd29yayB1bmxlc3MgdGhlIGlucHV0IGhhcyBmb2N1cywgdGhlIGdvb2QgbmV3c1xuICAgICAgLy8gaXMgdGhpcyBjb2RlIHNob3VsZCBvbmx5IGdldCBjYWxsZWQgd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzXG4gICAgICByYW5nZSA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtdmFsdWVMZW5ndGgpO1xuXG4gICAgICByZXR1cm4gdmFsdWVMZW5ndGggPT09IHJhbmdlLnRleHQubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4kaGludC5vZmYoJy5hYScpO1xuICAgIHRoaXMuJGlucHV0Lm9mZignLmFhJyk7XG5cbiAgICB0aGlzLiRoaW50ID0gdGhpcy4kaW5wdXQgPSB0aGlzLiRvdmVyZmxvd0hlbHBlciA9IG51bGw7XG4gIH1cbn0pO1xuXG4vLyBoZWxwZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGJ1aWxkT3ZlcmZsb3dIZWxwZXIoJGlucHV0KSB7XG4gIHJldHVybiBET00uZWxlbWVudCgnPHByZSBhcmlhLWhpZGRlbj1cInRydWVcIj48L3ByZT4nKVxuICAgIC5jc3Moe1xuICAgICAgLy8gcG9zaXRpb24gaGVscGVyIG9mZi1zY3JlZW5cbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgICAvLyBhdm9pZCBsaW5lIGJyZWFrcyBhbmQgd2hpdGVzcGFjZSBjb2xsYXBzaW5nXG4gICAgICB3aGl0ZVNwYWNlOiAncHJlJyxcbiAgICAgIC8vIHVzZSBzYW1lIGZvbnQgY3NzIGFzIGlucHV0IHRvIGNhbGN1bGF0ZSBhY2N1cmF0ZSB3aWR0aFxuICAgICAgZm9udEZhbWlseTogJGlucHV0LmNzcygnZm9udC1mYW1pbHknKSxcbiAgICAgIGZvbnRTaXplOiAkaW5wdXQuY3NzKCdmb250LXNpemUnKSxcbiAgICAgIGZvbnRTdHlsZTogJGlucHV0LmNzcygnZm9udC1zdHlsZScpLFxuICAgICAgZm9udFZhcmlhbnQ6ICRpbnB1dC5jc3MoJ2ZvbnQtdmFyaWFudCcpLFxuICAgICAgZm9udFdlaWdodDogJGlucHV0LmNzcygnZm9udC13ZWlnaHQnKSxcbiAgICAgIHdvcmRTcGFjaW5nOiAkaW5wdXQuY3NzKCd3b3JkLXNwYWNpbmcnKSxcbiAgICAgIGxldHRlclNwYWNpbmc6ICRpbnB1dC5jc3MoJ2xldHRlci1zcGFjaW5nJyksXG4gICAgICB0ZXh0SW5kZW50OiAkaW5wdXQuY3NzKCd0ZXh0LWluZGVudCcpLFxuICAgICAgdGV4dFJlbmRlcmluZzogJGlucHV0LmNzcygndGV4dC1yZW5kZXJpbmcnKSxcbiAgICAgIHRleHRUcmFuc2Zvcm06ICRpbnB1dC5jc3MoJ3RleHQtdHJhbnNmb3JtJylcbiAgICB9KVxuICAgIC5pbnNlcnRBZnRlcigkaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBhcmVRdWVyaWVzRXF1aXZhbGVudChhLCBiKSB7XG4gIHJldHVybiBJbnB1dC5ub3JtYWxpemVRdWVyeShhKSA9PT0gSW5wdXQubm9ybWFsaXplUXVlcnkoYik7XG59XG5cbmZ1bmN0aW9uIHdpdGhNb2RpZmllcigkZSkge1xuICByZXR1cm4gJGUuYWx0S2V5IHx8ICRlLmN0cmxLZXkgfHwgJGUubWV0YUtleSB8fCAkZS5zaGlmdEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBJbnB1dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///97748\n")},98693:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar attrsKey = 'aaAttrs';\n\nvar _ = __webpack_require__(16220);\nvar DOM = __webpack_require__(71337);\nvar EventBus = __webpack_require__(94045);\nvar Input = __webpack_require__(97748);\nvar Dropdown = __webpack_require__(82731);\nvar html = __webpack_require__(74499);\nvar css = __webpack_require__(60819);\n\n// constructor\n// -----------\n\n// THOUGHT: what if datasets could dynamically be added/removed?\nfunction Typeahead(o) {\n  var $menu;\n  var $hint;\n\n  o = o || {};\n\n  if (!o.input) {\n    _.error('missing input');\n  }\n\n  this.isActivated = false;\n  this.debug = !!o.debug;\n  this.autoselect = !!o.autoselect;\n  this.autoselectOnBlur = !!o.autoselectOnBlur;\n  this.openOnFocus = !!o.openOnFocus;\n  this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;\n  this.autoWidth = (o.autoWidth === undefined) ? true : !!o.autoWidth;\n  this.clearOnSelected = !!o.clearOnSelected;\n  this.tabAutocomplete = (o.tabAutocomplete === undefined) ? true : !!o.tabAutocomplete;\n\n  o.hint = !!o.hint;\n\n  if (o.hint && o.appendTo) {\n    throw new Error('[autocomplete.js] hint and appendTo options can\\'t be used at the same time');\n  }\n\n  this.css = o.css = _.mixin({}, css, o.appendTo ? css.appendTo : {});\n  this.cssClasses = o.cssClasses = _.mixin({}, css.defaultClasses, o.cssClasses || {});\n  this.cssClasses.prefix =\n    o.cssClasses.formattedPrefix = _.formatPrefix(this.cssClasses.prefix, this.cssClasses.noPrefix);\n  this.listboxId = o.listboxId = [this.cssClasses.root, 'listbox', _.getUniqueId()].join('-');\n\n  var domElts = buildDom(o);\n\n  this.$node = domElts.wrapper;\n  var $input = this.$input = domElts.input;\n  $menu = domElts.menu;\n  $hint = domElts.hint;\n\n  if (o.dropdownMenuContainer) {\n    DOM.element(o.dropdownMenuContainer)\n      .css('position', 'relative') // ensure the container has a relative position\n      .append($menu.css('top', '0')); // override the top: 100%\n  }\n\n  // #705: if there's scrollable overflow, ie doesn't support\n  // blur cancellations when the scrollbar is clicked\n  //\n  // #351: preventDefault won't cancel blurs in ie <= 8\n  $input.on('blur.aa', function($e) {\n    var active = document.activeElement;\n    if (_.isMsie() && ($menu[0] === active || $menu[0].contains(active))) {\n      $e.preventDefault();\n      // stop immediate in order to prevent Input#_onBlur from\n      // getting exectued\n      $e.stopImmediatePropagation();\n      _.defer(function() { $input.focus(); });\n    }\n  });\n\n  // #351: prevents input blur due to clicks within dropdown menu\n  $menu.on('mousedown.aa', function($e) { $e.preventDefault(); });\n\n  this.eventBus = o.eventBus || new EventBus({el: $input});\n\n  this.dropdown = new Typeahead.Dropdown({\n    appendTo: o.appendTo,\n    wrapper: this.$node,\n    menu: $menu,\n    datasets: o.datasets,\n    templates: o.templates,\n    cssClasses: o.cssClasses,\n    minLength: this.minLength\n  })\n    .onSync('suggestionClicked', this._onSuggestionClicked, this)\n    .onSync('cursorMoved', this._onCursorMoved, this)\n    .onSync('cursorRemoved', this._onCursorRemoved, this)\n    .onSync('opened', this._onOpened, this)\n    .onSync('closed', this._onClosed, this)\n    .onSync('shown', this._onShown, this)\n    .onSync('empty', this._onEmpty, this)\n    .onSync('redrawn', this._onRedrawn, this)\n    .onAsync('datasetRendered', this._onDatasetRendered, this);\n\n  this.input = new Typeahead.Input({input: $input, hint: $hint})\n    .onSync('focused', this._onFocused, this)\n    .onSync('blurred', this._onBlurred, this)\n    .onSync('enterKeyed', this._onEnterKeyed, this)\n    .onSync('tabKeyed', this._onTabKeyed, this)\n    .onSync('escKeyed', this._onEscKeyed, this)\n    .onSync('upKeyed', this._onUpKeyed, this)\n    .onSync('downKeyed', this._onDownKeyed, this)\n    .onSync('leftKeyed', this._onLeftKeyed, this)\n    .onSync('rightKeyed', this._onRightKeyed, this)\n    .onSync('queryChanged', this._onQueryChanged, this)\n    .onSync('whitespaceChanged', this._onWhitespaceChanged, this);\n\n  this._bindKeyboardShortcuts(o);\n\n  this._setLanguageDirection();\n}\n\n// instance methods\n// ----------------\n\n_.mixin(Typeahead.prototype, {\n  // ### private\n\n  _bindKeyboardShortcuts: function(options) {\n    if (!options.keyboardShortcuts) {\n      return;\n    }\n    var $input = this.$input;\n    var keyboardShortcuts = [];\n    _.each(options.keyboardShortcuts, function(key) {\n      if (typeof key === 'string') {\n        key = key.toUpperCase().charCodeAt(0);\n      }\n      keyboardShortcuts.push(key);\n    });\n    DOM.element(document).keydown(function(event) {\n      var elt = (event.target || event.srcElement);\n      var tagName = elt.tagName;\n      if (elt.isContentEditable || tagName === 'INPUT' || tagName === 'SELECT' || tagName === 'TEXTAREA') {\n        // already in an input\n        return;\n      }\n\n      var which = event.which || event.keyCode;\n      if (keyboardShortcuts.indexOf(which) === -1) {\n        // not the right shortcut\n        return;\n      }\n\n      $input.focus();\n      event.stopPropagation();\n      event.preventDefault();\n    });\n  },\n\n  _onSuggestionClicked: function onSuggestionClicked(type, $el) {\n    var datum;\n    var context = {selectionMethod: 'click'};\n\n    if (datum = this.dropdown.getDatumForSuggestion($el)) {\n      this._select(datum, context);\n    }\n  },\n\n  _onCursorMoved: function onCursorMoved(event, updateInput) {\n    var datum = this.dropdown.getDatumForCursor();\n    var currentCursorId = this.dropdown.getCurrentCursor().attr('id');\n    this.input.setActiveDescendant(currentCursorId);\n\n    if (datum) {\n      if (updateInput) {\n        this.input.setInputValue(datum.value, true);\n      }\n\n      this.eventBus.trigger('cursorchanged', datum.raw, datum.datasetName);\n    }\n  },\n\n  _onCursorRemoved: function onCursorRemoved() {\n    this.input.resetInputValue();\n    this._updateHint();\n    this.eventBus.trigger('cursorremoved');\n  },\n\n  _onDatasetRendered: function onDatasetRendered() {\n    this._updateHint();\n\n    this.eventBus.trigger('updated');\n  },\n\n  _onOpened: function onOpened() {\n    this._updateHint();\n    this.input.expand();\n\n    this.eventBus.trigger('opened');\n  },\n\n  _onEmpty: function onEmpty() {\n    this.eventBus.trigger('empty');\n  },\n\n  _onRedrawn: function onRedrawn() {\n    this.$node.css('top', 0 + 'px');\n    this.$node.css('left', 0 + 'px');\n\n    var inputRect = this.$input[0].getBoundingClientRect();\n\n    if (this.autoWidth) {\n      this.$node.css('width', inputRect.width + 'px');\n    }\n\n    var wrapperRect = this.$node[0].getBoundingClientRect();\n\n    var top = inputRect.bottom - wrapperRect.top;\n    this.$node.css('top', top + 'px');\n    var left = inputRect.left - wrapperRect.left;\n    this.$node.css('left', left + 'px');\n\n    this.eventBus.trigger('redrawn');\n  },\n\n  _onShown: function onShown() {\n    this.eventBus.trigger('shown');\n    if (this.autoselect) {\n      this.dropdown.cursorTopSuggestion();\n    }\n  },\n\n  _onClosed: function onClosed() {\n    this.input.clearHint();\n    this.input.removeActiveDescendant();\n    this.input.collapse();\n\n    this.eventBus.trigger('closed');\n  },\n\n  _onFocused: function onFocused() {\n    this.isActivated = true;\n\n    if (this.openOnFocus) {\n      var query = this.input.getQuery();\n      if (query.length >= this.minLength) {\n        this.dropdown.update(query);\n      } else {\n        this.dropdown.empty();\n      }\n\n      this.dropdown.open();\n    }\n  },\n\n  _onBlurred: function onBlurred() {\n    var cursorDatum;\n    var topSuggestionDatum;\n\n    cursorDatum = this.dropdown.getDatumForCursor();\n    topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();\n    var context = {selectionMethod: 'blur'};\n\n    if (!this.debug) {\n      if (this.autoselectOnBlur && cursorDatum) {\n        this._select(cursorDatum, context);\n      } else if (this.autoselectOnBlur && topSuggestionDatum) {\n        this._select(topSuggestionDatum, context);\n      } else {\n        this.isActivated = false;\n        this.dropdown.empty();\n        this.dropdown.close();\n      }\n    }\n  },\n\n  _onEnterKeyed: function onEnterKeyed(type, $e) {\n    var cursorDatum;\n    var topSuggestionDatum;\n\n    cursorDatum = this.dropdown.getDatumForCursor();\n    topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();\n    var context = {selectionMethod: 'enterKey'};\n\n    if (cursorDatum) {\n      this._select(cursorDatum, context);\n      $e.preventDefault();\n    } else if (this.autoselect && topSuggestionDatum) {\n      this._select(topSuggestionDatum, context);\n      $e.preventDefault();\n    }\n  },\n\n  _onTabKeyed: function onTabKeyed(type, $e) {\n    if (!this.tabAutocomplete) {\n      // Closing the dropdown enables further tabbing\n      this.dropdown.close();\n      return;\n    }\n\n    var datum;\n    var context = {selectionMethod: 'tabKey'};\n\n    if (datum = this.dropdown.getDatumForCursor()) {\n      this._select(datum, context);\n      $e.preventDefault();\n    } else {\n      this._autocomplete(true);\n    }\n  },\n\n  _onEscKeyed: function onEscKeyed() {\n    this.dropdown.close();\n    this.input.resetInputValue();\n  },\n\n  _onUpKeyed: function onUpKeyed() {\n    var query = this.input.getQuery();\n\n    if (this.dropdown.isEmpty && query.length >= this.minLength) {\n      this.dropdown.update(query);\n    } else {\n      this.dropdown.moveCursorUp();\n    }\n\n    this.dropdown.open();\n  },\n\n  _onDownKeyed: function onDownKeyed() {\n    var query = this.input.getQuery();\n\n    if (this.dropdown.isEmpty && query.length >= this.minLength) {\n      this.dropdown.update(query);\n    } else {\n      this.dropdown.moveCursorDown();\n    }\n\n    this.dropdown.open();\n  },\n\n  _onLeftKeyed: function onLeftKeyed() {\n    if (this.dir === 'rtl') {\n      this._autocomplete();\n    }\n  },\n\n  _onRightKeyed: function onRightKeyed() {\n    if (this.dir === 'ltr') {\n      this._autocomplete();\n    }\n  },\n\n  _onQueryChanged: function onQueryChanged(e, query) {\n    this.input.clearHintIfInvalid();\n\n    if (query.length >= this.minLength) {\n      this.dropdown.update(query);\n    } else {\n      this.dropdown.empty();\n    }\n\n    this.dropdown.open();\n    this._setLanguageDirection();\n  },\n\n  _onWhitespaceChanged: function onWhitespaceChanged() {\n    this._updateHint();\n    this.dropdown.open();\n  },\n\n  _setLanguageDirection: function setLanguageDirection() {\n    var dir = this.input.getLanguageDirection();\n\n    if (this.dir !== dir) {\n      this.dir = dir;\n      this.$node.css('direction', dir);\n      this.dropdown.setLanguageDirection(dir);\n    }\n  },\n\n  _updateHint: function updateHint() {\n    var datum;\n    var val;\n    var query;\n    var escapedQuery;\n    var frontMatchRegEx;\n    var match;\n\n    datum = this.dropdown.getDatumForTopSuggestion();\n\n    if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {\n      val = this.input.getInputValue();\n      query = Input.normalizeQuery(val);\n      escapedQuery = _.escapeRegExChars(query);\n\n      // match input value, then capture trailing text\n      frontMatchRegEx = new RegExp('^(?:' + escapedQuery + ')(.+$)', 'i');\n      match = frontMatchRegEx.exec(datum.value);\n\n      // clear hint if there's no trailing text\n      if (match) {\n        this.input.setHint(val + match[1]);\n      } else {\n        this.input.clearHint();\n      }\n    } else {\n      this.input.clearHint();\n    }\n  },\n\n  _autocomplete: function autocomplete(laxCursor) {\n    var hint;\n    var query;\n    var isCursorAtEnd;\n    var datum;\n\n    hint = this.input.getHint();\n    query = this.input.getQuery();\n    isCursorAtEnd = laxCursor || this.input.isCursorAtEnd();\n\n    if (hint && query !== hint && isCursorAtEnd) {\n      datum = this.dropdown.getDatumForTopSuggestion();\n      if (datum) {\n        this.input.setInputValue(datum.value);\n      }\n\n      this.eventBus.trigger('autocompleted', datum.raw, datum.datasetName);\n    }\n  },\n\n  _select: function select(datum, context) {\n    if (typeof datum.value !== 'undefined') {\n      this.input.setQuery(datum.value);\n    }\n    if (this.clearOnSelected) {\n      this.setVal('');\n    } else {\n      this.input.setInputValue(datum.value, true);\n    }\n\n    this._setLanguageDirection();\n\n    var event = this.eventBus.trigger('selected', datum.raw, datum.datasetName, context);\n    if (event.isDefaultPrevented() === false) {\n      this.dropdown.close();\n\n      // #118: allow click event to bubble up to the body before removing\n      // the suggestions otherwise we break event delegation\n      _.defer(_.bind(this.dropdown.empty, this.dropdown));\n    }\n  },\n\n  // ### public\n\n  open: function open() {\n    // if the menu is not activated yet, we need to update\n    // the underlying dropdown menu to trigger the search\n    // otherwise we're not gonna see anything\n    if (!this.isActivated) {\n      var query = this.input.getInputValue();\n      if (query.length >= this.minLength) {\n        this.dropdown.update(query);\n      } else {\n        this.dropdown.empty();\n      }\n    }\n    this.dropdown.open();\n  },\n\n  close: function close() {\n    this.dropdown.close();\n  },\n\n  setVal: function setVal(val) {\n    // expect val to be a string, so be safe, and coerce\n    val = _.toStr(val);\n\n    if (this.isActivated) {\n      this.input.setInputValue(val);\n    } else {\n      this.input.setQuery(val);\n      this.input.setInputValue(val, true);\n    }\n\n    this._setLanguageDirection();\n  },\n\n  getVal: function getVal() {\n    return this.input.getQuery();\n  },\n\n  destroy: function destroy() {\n    this.input.destroy();\n    this.dropdown.destroy();\n\n    destroyDomStructure(this.$node, this.cssClasses);\n\n    this.$node = null;\n  },\n\n  getWrapper: function getWrapper() {\n    return this.dropdown.$container[0];\n  }\n});\n\nfunction buildDom(options) {\n  var $input;\n  var $wrapper;\n  var $dropdown;\n  var $hint;\n\n  $input = DOM.element(options.input);\n  $wrapper = DOM\n    .element(html.wrapper.replace('%ROOT%', options.cssClasses.root))\n    .css(options.css.wrapper);\n\n  // override the display property with the table-cell value\n  // if the parent element is a table and the original input was a block\n  //  -> https://github.com/algolia/autocomplete.js/issues/16\n  if (!options.appendTo && $input.css('display') === 'block' && $input.parent().css('display') === 'table') {\n    $wrapper.css('display', 'table-cell');\n  }\n  var dropdownHtml = html.dropdown.\n    replace('%PREFIX%', options.cssClasses.prefix).\n    replace('%DROPDOWN_MENU%', options.cssClasses.dropdownMenu);\n  $dropdown = DOM.element(dropdownHtml)\n    .css(options.css.dropdown)\n    .attr({\n      role: 'listbox',\n      id: options.listboxId\n    });\n  if (options.templates && options.templates.dropdownMenu) {\n    $dropdown.html(_.templatify(options.templates.dropdownMenu)());\n  }\n  $hint = $input.clone().css(options.css.hint).css(getBackgroundStyles($input));\n\n  $hint\n    .val('')\n    .addClass(_.className(options.cssClasses.prefix, options.cssClasses.hint, true))\n    .removeAttr('id name placeholder required')\n    .prop('readonly', true)\n    .attr({\n      'aria-hidden': 'true',\n      autocomplete: 'off',\n      spellcheck: 'false',\n      tabindex: -1\n    });\n  if ($hint.removeData) {\n    $hint.removeData();\n  }\n\n  // store the original values of the attrs that get modified\n  // so modifications can be reverted on destroy\n  $input.data(attrsKey, {\n    'aria-autocomplete': $input.attr('aria-autocomplete'),\n    'aria-expanded': $input.attr('aria-expanded'),\n    'aria-owns': $input.attr('aria-owns'),\n    autocomplete: $input.attr('autocomplete'),\n    dir: $input.attr('dir'),\n    role: $input.attr('role'),\n    spellcheck: $input.attr('spellcheck'),\n    style: $input.attr('style'),\n    type: $input.attr('type')\n  });\n\n  $input\n    .addClass(_.className(options.cssClasses.prefix, options.cssClasses.input, true))\n    .attr({\n      autocomplete: 'off',\n      spellcheck: false,\n\n      // Accessibility features\n      // Give the field a presentation of a \"select\".\n      // Combobox is the combined presentation of a single line textfield\n      // with a listbox popup.\n      // https://www.w3.org/WAI/PF/aria/roles#combobox\n      role: 'combobox',\n      // Let the screen reader know the field has an autocomplete\n      // feature to it.\n      'aria-autocomplete': (options.datasets &&\n        options.datasets[0] && options.datasets[0].displayKey ? 'both' : 'list'),\n      // Indicates whether the dropdown it controls is currently expanded or collapsed\n      'aria-expanded': 'false',\n      'aria-label': options.ariaLabel,\n      // Explicitly point to the listbox,\n      // which is a list of suggestions (aka options)\n      'aria-owns': options.listboxId\n    })\n    .css(options.hint ? options.css.input : options.css.inputWithNoHint);\n\n  // ie7 does not like it when dir is set to auto\n  try {\n    if (!$input.attr('dir')) {\n      $input.attr('dir', 'auto');\n    }\n  } catch (e) {\n    // ignore\n  }\n\n  $wrapper = options.appendTo\n    ? $wrapper.appendTo(DOM.element(options.appendTo).eq(0)).eq(0)\n    : $input.wrap($wrapper).parent();\n\n  $wrapper\n    .prepend(options.hint ? $hint : null)\n    .append($dropdown);\n\n  return {\n    wrapper: $wrapper,\n    input: $input,\n    hint: $hint,\n    menu: $dropdown\n  };\n}\n\nfunction getBackgroundStyles($el) {\n  return {\n    backgroundAttachment: $el.css('background-attachment'),\n    backgroundClip: $el.css('background-clip'),\n    backgroundColor: $el.css('background-color'),\n    backgroundImage: $el.css('background-image'),\n    backgroundOrigin: $el.css('background-origin'),\n    backgroundPosition: $el.css('background-position'),\n    backgroundRepeat: $el.css('background-repeat'),\n    backgroundSize: $el.css('background-size')\n  };\n}\n\nfunction destroyDomStructure($node, cssClasses) {\n  var $input = $node.find(_.className(cssClasses.prefix, cssClasses.input));\n\n  // need to remove attrs that weren't previously defined and\n  // revert attrs that originally had a value\n  _.each($input.data(attrsKey), function(val, key) {\n    if (val === undefined) {\n      $input.removeAttr(key);\n    } else {\n      $input.attr(key, val);\n    }\n  });\n\n  $input\n    .detach()\n    .removeClass(_.className(cssClasses.prefix, cssClasses.input, true))\n    .insertAfter($node);\n  if ($input.removeData) {\n    $input.removeData(attrsKey);\n  }\n\n  $node.remove();\n}\n\nTypeahead.Dropdown = Dropdown;\nTypeahead.Input = Input;\nTypeahead.sources = __webpack_require__(64710);\n\nmodule.exports = Typeahead;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTg2OTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxLQUFrQjtBQUNwQyxlQUFlLG1CQUFPLENBQUMsS0FBZ0I7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLEtBQVk7QUFDaEMsZUFBZSxtQkFBTyxDQUFDLEtBQWU7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLEtBQVc7QUFDOUIsVUFBVSxtQkFBTyxDQUFDLEtBQVU7O0FBRTVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLHFDQUFxQztBQUNwRSw2Q0FBNkMsd0NBQXdDO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMENBQTBDLHNCQUFzQjs7QUFFaEUsOENBQThDLFdBQVc7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsS0FBcUI7O0FBRWpEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9hdXRvY29tcGxldGUuanMvc3JjL2F1dG9jb21wbGV0ZS90eXBlYWhlYWQuanM/ZTdlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBhdHRyc0tleSA9ICdhYUF0dHJzJztcblxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMuanMnKTtcbnZhciBET00gPSByZXF1aXJlKCcuLi9jb21tb24vZG9tLmpzJyk7XG52YXIgRXZlbnRCdXMgPSByZXF1aXJlKCcuL2V2ZW50X2J1cy5qcycpO1xudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dC5qcycpO1xudmFyIERyb3Bkb3duID0gcmVxdWlyZSgnLi9kcm9wZG93bi5qcycpO1xudmFyIGh0bWwgPSByZXF1aXJlKCcuL2h0bWwuanMnKTtcbnZhciBjc3MgPSByZXF1aXJlKCcuL2Nzcy5qcycpO1xuXG4vLyBjb25zdHJ1Y3RvclxuLy8gLS0tLS0tLS0tLS1cblxuLy8gVEhPVUdIVDogd2hhdCBpZiBkYXRhc2V0cyBjb3VsZCBkeW5hbWljYWxseSBiZSBhZGRlZC9yZW1vdmVkP1xuZnVuY3Rpb24gVHlwZWFoZWFkKG8pIHtcbiAgdmFyICRtZW51O1xuICB2YXIgJGhpbnQ7XG5cbiAgbyA9IG8gfHwge307XG5cbiAgaWYgKCFvLmlucHV0KSB7XG4gICAgXy5lcnJvcignbWlzc2luZyBpbnB1dCcpO1xuICB9XG5cbiAgdGhpcy5pc0FjdGl2YXRlZCA9IGZhbHNlO1xuICB0aGlzLmRlYnVnID0gISFvLmRlYnVnO1xuICB0aGlzLmF1dG9zZWxlY3QgPSAhIW8uYXV0b3NlbGVjdDtcbiAgdGhpcy5hdXRvc2VsZWN0T25CbHVyID0gISFvLmF1dG9zZWxlY3RPbkJsdXI7XG4gIHRoaXMub3Blbk9uRm9jdXMgPSAhIW8ub3Blbk9uRm9jdXM7XG4gIHRoaXMubWluTGVuZ3RoID0gXy5pc051bWJlcihvLm1pbkxlbmd0aCkgPyBvLm1pbkxlbmd0aCA6IDE7XG4gIHRoaXMuYXV0b1dpZHRoID0gKG8uYXV0b1dpZHRoID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6ICEhby5hdXRvV2lkdGg7XG4gIHRoaXMuY2xlYXJPblNlbGVjdGVkID0gISFvLmNsZWFyT25TZWxlY3RlZDtcbiAgdGhpcy50YWJBdXRvY29tcGxldGUgPSAoby50YWJBdXRvY29tcGxldGUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogISFvLnRhYkF1dG9jb21wbGV0ZTtcblxuICBvLmhpbnQgPSAhIW8uaGludDtcblxuICBpZiAoby5oaW50ICYmIG8uYXBwZW5kVG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1thdXRvY29tcGxldGUuanNdIGhpbnQgYW5kIGFwcGVuZFRvIG9wdGlvbnMgY2FuXFwndCBiZSB1c2VkIGF0IHRoZSBzYW1lIHRpbWUnKTtcbiAgfVxuXG4gIHRoaXMuY3NzID0gby5jc3MgPSBfLm1peGluKHt9LCBjc3MsIG8uYXBwZW5kVG8gPyBjc3MuYXBwZW5kVG8gOiB7fSk7XG4gIHRoaXMuY3NzQ2xhc3NlcyA9IG8uY3NzQ2xhc3NlcyA9IF8ubWl4aW4oe30sIGNzcy5kZWZhdWx0Q2xhc3Nlcywgby5jc3NDbGFzc2VzIHx8IHt9KTtcbiAgdGhpcy5jc3NDbGFzc2VzLnByZWZpeCA9XG4gICAgby5jc3NDbGFzc2VzLmZvcm1hdHRlZFByZWZpeCA9IF8uZm9ybWF0UHJlZml4KHRoaXMuY3NzQ2xhc3Nlcy5wcmVmaXgsIHRoaXMuY3NzQ2xhc3Nlcy5ub1ByZWZpeCk7XG4gIHRoaXMubGlzdGJveElkID0gby5saXN0Ym94SWQgPSBbdGhpcy5jc3NDbGFzc2VzLnJvb3QsICdsaXN0Ym94JywgXy5nZXRVbmlxdWVJZCgpXS5qb2luKCctJyk7XG5cbiAgdmFyIGRvbUVsdHMgPSBidWlsZERvbShvKTtcblxuICB0aGlzLiRub2RlID0gZG9tRWx0cy53cmFwcGVyO1xuICB2YXIgJGlucHV0ID0gdGhpcy4kaW5wdXQgPSBkb21FbHRzLmlucHV0O1xuICAkbWVudSA9IGRvbUVsdHMubWVudTtcbiAgJGhpbnQgPSBkb21FbHRzLmhpbnQ7XG5cbiAgaWYgKG8uZHJvcGRvd25NZW51Q29udGFpbmVyKSB7XG4gICAgRE9NLmVsZW1lbnQoby5kcm9wZG93bk1lbnVDb250YWluZXIpXG4gICAgICAuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpIC8vIGVuc3VyZSB0aGUgY29udGFpbmVyIGhhcyBhIHJlbGF0aXZlIHBvc2l0aW9uXG4gICAgICAuYXBwZW5kKCRtZW51LmNzcygndG9wJywgJzAnKSk7IC8vIG92ZXJyaWRlIHRoZSB0b3A6IDEwMCVcbiAgfVxuXG4gIC8vICM3MDU6IGlmIHRoZXJlJ3Mgc2Nyb2xsYWJsZSBvdmVyZmxvdywgaWUgZG9lc24ndCBzdXBwb3J0XG4gIC8vIGJsdXIgY2FuY2VsbGF0aW9ucyB3aGVuIHRoZSBzY3JvbGxiYXIgaXMgY2xpY2tlZFxuICAvL1xuICAvLyAjMzUxOiBwcmV2ZW50RGVmYXVsdCB3b24ndCBjYW5jZWwgYmx1cnMgaW4gaWUgPD0gOFxuICAkaW5wdXQub24oJ2JsdXIuYWEnLCBmdW5jdGlvbigkZSkge1xuICAgIHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChfLmlzTXNpZSgpICYmICgkbWVudVswXSA9PT0gYWN0aXZlIHx8ICRtZW51WzBdLmNvbnRhaW5zKGFjdGl2ZSkpKSB7XG4gICAgICAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gc3RvcCBpbW1lZGlhdGUgaW4gb3JkZXIgdG8gcHJldmVudCBJbnB1dCNfb25CbHVyIGZyb21cbiAgICAgIC8vIGdldHRpbmcgZXhlY3R1ZWRcbiAgICAgICRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgXy5kZWZlcihmdW5jdGlvbigpIHsgJGlucHV0LmZvY3VzKCk7IH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gIzM1MTogcHJldmVudHMgaW5wdXQgYmx1ciBkdWUgdG8gY2xpY2tzIHdpdGhpbiBkcm9wZG93biBtZW51XG4gICRtZW51Lm9uKCdtb3VzZWRvd24uYWEnLCBmdW5jdGlvbigkZSkgeyAkZS5wcmV2ZW50RGVmYXVsdCgpOyB9KTtcblxuICB0aGlzLmV2ZW50QnVzID0gby5ldmVudEJ1cyB8fCBuZXcgRXZlbnRCdXMoe2VsOiAkaW5wdXR9KTtcblxuICB0aGlzLmRyb3Bkb3duID0gbmV3IFR5cGVhaGVhZC5Ecm9wZG93bih7XG4gICAgYXBwZW5kVG86IG8uYXBwZW5kVG8sXG4gICAgd3JhcHBlcjogdGhpcy4kbm9kZSxcbiAgICBtZW51OiAkbWVudSxcbiAgICBkYXRhc2V0czogby5kYXRhc2V0cyxcbiAgICB0ZW1wbGF0ZXM6IG8udGVtcGxhdGVzLFxuICAgIGNzc0NsYXNzZXM6IG8uY3NzQ2xhc3NlcyxcbiAgICBtaW5MZW5ndGg6IHRoaXMubWluTGVuZ3RoXG4gIH0pXG4gICAgLm9uU3luYygnc3VnZ2VzdGlvbkNsaWNrZWQnLCB0aGlzLl9vblN1Z2dlc3Rpb25DbGlja2VkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2N1cnNvck1vdmVkJywgdGhpcy5fb25DdXJzb3JNb3ZlZCwgdGhpcylcbiAgICAub25TeW5jKCdjdXJzb3JSZW1vdmVkJywgdGhpcy5fb25DdXJzb3JSZW1vdmVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ29wZW5lZCcsIHRoaXMuX29uT3BlbmVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2Nsb3NlZCcsIHRoaXMuX29uQ2xvc2VkLCB0aGlzKVxuICAgIC5vblN5bmMoJ3Nob3duJywgdGhpcy5fb25TaG93biwgdGhpcylcbiAgICAub25TeW5jKCdlbXB0eScsIHRoaXMuX29uRW1wdHksIHRoaXMpXG4gICAgLm9uU3luYygncmVkcmF3bicsIHRoaXMuX29uUmVkcmF3biwgdGhpcylcbiAgICAub25Bc3luYygnZGF0YXNldFJlbmRlcmVkJywgdGhpcy5fb25EYXRhc2V0UmVuZGVyZWQsIHRoaXMpO1xuXG4gIHRoaXMuaW5wdXQgPSBuZXcgVHlwZWFoZWFkLklucHV0KHtpbnB1dDogJGlucHV0LCBoaW50OiAkaGludH0pXG4gICAgLm9uU3luYygnZm9jdXNlZCcsIHRoaXMuX29uRm9jdXNlZCwgdGhpcylcbiAgICAub25TeW5jKCdibHVycmVkJywgdGhpcy5fb25CbHVycmVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2VudGVyS2V5ZWQnLCB0aGlzLl9vbkVudGVyS2V5ZWQsIHRoaXMpXG4gICAgLm9uU3luYygndGFiS2V5ZWQnLCB0aGlzLl9vblRhYktleWVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2VzY0tleWVkJywgdGhpcy5fb25Fc2NLZXllZCwgdGhpcylcbiAgICAub25TeW5jKCd1cEtleWVkJywgdGhpcy5fb25VcEtleWVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2Rvd25LZXllZCcsIHRoaXMuX29uRG93bktleWVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ2xlZnRLZXllZCcsIHRoaXMuX29uTGVmdEtleWVkLCB0aGlzKVxuICAgIC5vblN5bmMoJ3JpZ2h0S2V5ZWQnLCB0aGlzLl9vblJpZ2h0S2V5ZWQsIHRoaXMpXG4gICAgLm9uU3luYygncXVlcnlDaGFuZ2VkJywgdGhpcy5fb25RdWVyeUNoYW5nZWQsIHRoaXMpXG4gICAgLm9uU3luYygnd2hpdGVzcGFjZUNoYW5nZWQnLCB0aGlzLl9vbldoaXRlc3BhY2VDaGFuZ2VkLCB0aGlzKTtcblxuICB0aGlzLl9iaW5kS2V5Ym9hcmRTaG9ydGN1dHMobyk7XG5cbiAgdGhpcy5fc2V0TGFuZ3VhZ2VEaXJlY3Rpb24oKTtcbn1cblxuLy8gaW5zdGFuY2UgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG5fLm1peGluKFR5cGVhaGVhZC5wcm90b3R5cGUsIHtcbiAgLy8gIyMjIHByaXZhdGVcblxuICBfYmluZEtleWJvYXJkU2hvcnRjdXRzOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zLmtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciAkaW5wdXQgPSB0aGlzLiRpbnB1dDtcbiAgICB2YXIga2V5Ym9hcmRTaG9ydGN1dHMgPSBbXTtcbiAgICBfLmVhY2gob3B0aW9ucy5rZXlib2FyZFNob3J0Y3V0cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvVXBwZXJDYXNlKCkuY2hhckNvZGVBdCgwKTtcbiAgICAgIH1cbiAgICAgIGtleWJvYXJkU2hvcnRjdXRzLnB1c2goa2V5KTtcbiAgICB9KTtcbiAgICBET00uZWxlbWVudChkb2N1bWVudCkua2V5ZG93bihmdW5jdGlvbihldmVudCkge1xuICAgICAgdmFyIGVsdCA9IChldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCk7XG4gICAgICB2YXIgdGFnTmFtZSA9IGVsdC50YWdOYW1lO1xuICAgICAgaWYgKGVsdC5pc0NvbnRlbnRFZGl0YWJsZSB8fCB0YWdOYW1lID09PSAnSU5QVVQnIHx8IHRhZ05hbWUgPT09ICdTRUxFQ1QnIHx8IHRhZ05hbWUgPT09ICdURVhUQVJFQScpIHtcbiAgICAgICAgLy8gYWxyZWFkeSBpbiBhbiBpbnB1dFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB3aGljaCA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG4gICAgICBpZiAoa2V5Ym9hcmRTaG9ydGN1dHMuaW5kZXhPZih3aGljaCkgPT09IC0xKSB7XG4gICAgICAgIC8vIG5vdCB0aGUgcmlnaHQgc2hvcnRjdXRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkaW5wdXQuZm9jdXMoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbiAgfSxcblxuICBfb25TdWdnZXN0aW9uQ2xpY2tlZDogZnVuY3Rpb24gb25TdWdnZXN0aW9uQ2xpY2tlZCh0eXBlLCAkZWwpIHtcbiAgICB2YXIgZGF0dW07XG4gICAgdmFyIGNvbnRleHQgPSB7c2VsZWN0aW9uTWV0aG9kOiAnY2xpY2snfTtcblxuICAgIGlmIChkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JTdWdnZXN0aW9uKCRlbCkpIHtcbiAgICAgIHRoaXMuX3NlbGVjdChkYXR1bSwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkN1cnNvck1vdmVkOiBmdW5jdGlvbiBvbkN1cnNvck1vdmVkKGV2ZW50LCB1cGRhdGVJbnB1dCkge1xuICAgIHZhciBkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JDdXJzb3IoKTtcbiAgICB2YXIgY3VycmVudEN1cnNvcklkID0gdGhpcy5kcm9wZG93bi5nZXRDdXJyZW50Q3Vyc29yKCkuYXR0cignaWQnKTtcbiAgICB0aGlzLmlucHV0LnNldEFjdGl2ZURlc2NlbmRhbnQoY3VycmVudEN1cnNvcklkKTtcblxuICAgIGlmIChkYXR1bSkge1xuICAgICAgaWYgKHVwZGF0ZUlucHV0KSB7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0SW5wdXRWYWx1ZShkYXR1bS52YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcignY3Vyc29yY2hhbmdlZCcsIGRhdHVtLnJhdywgZGF0dW0uZGF0YXNldE5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBfb25DdXJzb3JSZW1vdmVkOiBmdW5jdGlvbiBvbkN1cnNvclJlbW92ZWQoKSB7XG4gICAgdGhpcy5pbnB1dC5yZXNldElucHV0VmFsdWUoKTtcbiAgICB0aGlzLl91cGRhdGVIaW50KCk7XG4gICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKCdjdXJzb3JyZW1vdmVkJyk7XG4gIH0sXG5cbiAgX29uRGF0YXNldFJlbmRlcmVkOiBmdW5jdGlvbiBvbkRhdGFzZXRSZW5kZXJlZCgpIHtcbiAgICB0aGlzLl91cGRhdGVIaW50KCk7XG5cbiAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ3VwZGF0ZWQnKTtcbiAgfSxcblxuICBfb25PcGVuZWQ6IGZ1bmN0aW9uIG9uT3BlbmVkKCkge1xuICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICB0aGlzLmlucHV0LmV4cGFuZCgpO1xuXG4gICAgdGhpcy5ldmVudEJ1cy50cmlnZ2VyKCdvcGVuZWQnKTtcbiAgfSxcblxuICBfb25FbXB0eTogZnVuY3Rpb24gb25FbXB0eSgpIHtcbiAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ2VtcHR5Jyk7XG4gIH0sXG5cbiAgX29uUmVkcmF3bjogZnVuY3Rpb24gb25SZWRyYXduKCkge1xuICAgIHRoaXMuJG5vZGUuY3NzKCd0b3AnLCAwICsgJ3B4Jyk7XG4gICAgdGhpcy4kbm9kZS5jc3MoJ2xlZnQnLCAwICsgJ3B4Jyk7XG5cbiAgICB2YXIgaW5wdXRSZWN0ID0gdGhpcy4kaW5wdXRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAodGhpcy5hdXRvV2lkdGgpIHtcbiAgICAgIHRoaXMuJG5vZGUuY3NzKCd3aWR0aCcsIGlucHV0UmVjdC53aWR0aCArICdweCcpO1xuICAgIH1cblxuICAgIHZhciB3cmFwcGVyUmVjdCA9IHRoaXMuJG5vZGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgdG9wID0gaW5wdXRSZWN0LmJvdHRvbSAtIHdyYXBwZXJSZWN0LnRvcDtcbiAgICB0aGlzLiRub2RlLmNzcygndG9wJywgdG9wICsgJ3B4Jyk7XG4gICAgdmFyIGxlZnQgPSBpbnB1dFJlY3QubGVmdCAtIHdyYXBwZXJSZWN0LmxlZnQ7XG4gICAgdGhpcy4kbm9kZS5jc3MoJ2xlZnQnLCBsZWZ0ICsgJ3B4Jyk7XG5cbiAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ3JlZHJhd24nKTtcbiAgfSxcblxuICBfb25TaG93bjogZnVuY3Rpb24gb25TaG93bigpIHtcbiAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ3Nob3duJyk7XG4gICAgaWYgKHRoaXMuYXV0b3NlbGVjdCkge1xuICAgICAgdGhpcy5kcm9wZG93bi5jdXJzb3JUb3BTdWdnZXN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkNsb3NlZDogZnVuY3Rpb24gb25DbG9zZWQoKSB7XG4gICAgdGhpcy5pbnB1dC5jbGVhckhpbnQoKTtcbiAgICB0aGlzLmlucHV0LnJlbW92ZUFjdGl2ZURlc2NlbmRhbnQoKTtcbiAgICB0aGlzLmlucHV0LmNvbGxhcHNlKCk7XG5cbiAgICB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ2Nsb3NlZCcpO1xuICB9LFxuXG4gIF9vbkZvY3VzZWQ6IGZ1bmN0aW9uIG9uRm9jdXNlZCgpIHtcbiAgICB0aGlzLmlzQWN0aXZhdGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLm9wZW5PbkZvY3VzKSB7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG4gICAgICBpZiAocXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24udXBkYXRlKHF1ZXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcm9wZG93bi5vcGVuKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkJsdXJyZWQ6IGZ1bmN0aW9uIG9uQmx1cnJlZCgpIHtcbiAgICB2YXIgY3Vyc29yRGF0dW07XG4gICAgdmFyIHRvcFN1Z2dlc3Rpb25EYXR1bTtcblxuICAgIGN1cnNvckRhdHVtID0gdGhpcy5kcm9wZG93bi5nZXREYXR1bUZvckN1cnNvcigpO1xuICAgIHRvcFN1Z2dlc3Rpb25EYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JUb3BTdWdnZXN0aW9uKCk7XG4gICAgdmFyIGNvbnRleHQgPSB7c2VsZWN0aW9uTWV0aG9kOiAnYmx1cid9O1xuXG4gICAgaWYgKCF0aGlzLmRlYnVnKSB7XG4gICAgICBpZiAodGhpcy5hdXRvc2VsZWN0T25CbHVyICYmIGN1cnNvckRhdHVtKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdChjdXJzb3JEYXR1bSwgY29udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYXV0b3NlbGVjdE9uQmx1ciAmJiB0b3BTdWdnZXN0aW9uRGF0dW0pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0KHRvcFN1Z2dlc3Rpb25EYXR1bSwgY29udGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzQWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICAgICAgdGhpcy5kcm9wZG93bi5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfb25FbnRlcktleWVkOiBmdW5jdGlvbiBvbkVudGVyS2V5ZWQodHlwZSwgJGUpIHtcbiAgICB2YXIgY3Vyc29yRGF0dW07XG4gICAgdmFyIHRvcFN1Z2dlc3Rpb25EYXR1bTtcblxuICAgIGN1cnNvckRhdHVtID0gdGhpcy5kcm9wZG93bi5nZXREYXR1bUZvckN1cnNvcigpO1xuICAgIHRvcFN1Z2dlc3Rpb25EYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JUb3BTdWdnZXN0aW9uKCk7XG4gICAgdmFyIGNvbnRleHQgPSB7c2VsZWN0aW9uTWV0aG9kOiAnZW50ZXJLZXknfTtcblxuICAgIGlmIChjdXJzb3JEYXR1bSkge1xuICAgICAgdGhpcy5fc2VsZWN0KGN1cnNvckRhdHVtLCBjb250ZXh0KTtcbiAgICAgICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmF1dG9zZWxlY3QgJiYgdG9wU3VnZ2VzdGlvbkRhdHVtKSB7XG4gICAgICB0aGlzLl9zZWxlY3QodG9wU3VnZ2VzdGlvbkRhdHVtLCBjb250ZXh0KTtcbiAgICAgICRlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9LFxuXG4gIF9vblRhYktleWVkOiBmdW5jdGlvbiBvblRhYktleWVkKHR5cGUsICRlKSB7XG4gICAgaWYgKCF0aGlzLnRhYkF1dG9jb21wbGV0ZSkge1xuICAgICAgLy8gQ2xvc2luZyB0aGUgZHJvcGRvd24gZW5hYmxlcyBmdXJ0aGVyIHRhYmJpbmdcbiAgICAgIHRoaXMuZHJvcGRvd24uY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0dW07XG4gICAgdmFyIGNvbnRleHQgPSB7c2VsZWN0aW9uTWV0aG9kOiAndGFiS2V5J307XG5cbiAgICBpZiAoZGF0dW0gPSB0aGlzLmRyb3Bkb3duLmdldERhdHVtRm9yQ3Vyc29yKCkpIHtcbiAgICAgIHRoaXMuX3NlbGVjdChkYXR1bSwgY29udGV4dCk7XG4gICAgICAkZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvY29tcGxldGUodHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkVzY0tleWVkOiBmdW5jdGlvbiBvbkVzY0tleWVkKCkge1xuICAgIHRoaXMuZHJvcGRvd24uY2xvc2UoKTtcbiAgICB0aGlzLmlucHV0LnJlc2V0SW5wdXRWYWx1ZSgpO1xuICB9LFxuXG4gIF9vblVwS2V5ZWQ6IGZ1bmN0aW9uIG9uVXBLZXllZCgpIHtcbiAgICB2YXIgcXVlcnkgPSB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG5cbiAgICBpZiAodGhpcy5kcm9wZG93bi5pc0VtcHR5ICYmIHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLm1pbkxlbmd0aCkge1xuICAgICAgdGhpcy5kcm9wZG93bi51cGRhdGUocXVlcnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyb3Bkb3duLm1vdmVDdXJzb3JVcCgpO1xuICAgIH1cblxuICAgIHRoaXMuZHJvcGRvd24ub3BlbigpO1xuICB9LFxuXG4gIF9vbkRvd25LZXllZDogZnVuY3Rpb24gb25Eb3duS2V5ZWQoKSB7XG4gICAgdmFyIHF1ZXJ5ID0gdGhpcy5pbnB1dC5nZXRRdWVyeSgpO1xuXG4gICAgaWYgKHRoaXMuZHJvcGRvd24uaXNFbXB0eSAmJiBxdWVyeS5sZW5ndGggPj0gdGhpcy5taW5MZW5ndGgpIHtcbiAgICAgIHRoaXMuZHJvcGRvd24udXBkYXRlKHF1ZXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcm9wZG93bi5tb3ZlQ3Vyc29yRG93bigpO1xuICAgIH1cblxuICAgIHRoaXMuZHJvcGRvd24ub3BlbigpO1xuICB9LFxuXG4gIF9vbkxlZnRLZXllZDogZnVuY3Rpb24gb25MZWZ0S2V5ZWQoKSB7XG4gICAgaWYgKHRoaXMuZGlyID09PSAncnRsJykge1xuICAgICAgdGhpcy5fYXV0b2NvbXBsZXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIF9vblJpZ2h0S2V5ZWQ6IGZ1bmN0aW9uIG9uUmlnaHRLZXllZCgpIHtcbiAgICBpZiAodGhpcy5kaXIgPT09ICdsdHInKSB7XG4gICAgICB0aGlzLl9hdXRvY29tcGxldGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uUXVlcnlDaGFuZ2VkOiBmdW5jdGlvbiBvblF1ZXJ5Q2hhbmdlZChlLCBxdWVyeSkge1xuICAgIHRoaXMuaW5wdXQuY2xlYXJIaW50SWZJbnZhbGlkKCk7XG5cbiAgICBpZiAocXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICB0aGlzLmRyb3Bkb3duLnVwZGF0ZShxdWVyeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgICB0aGlzLl9zZXRMYW5ndWFnZURpcmVjdGlvbigpO1xuICB9LFxuXG4gIF9vbldoaXRlc3BhY2VDaGFuZ2VkOiBmdW5jdGlvbiBvbldoaXRlc3BhY2VDaGFuZ2VkKCkge1xuICAgIHRoaXMuX3VwZGF0ZUhpbnQoKTtcbiAgICB0aGlzLmRyb3Bkb3duLm9wZW4oKTtcbiAgfSxcblxuICBfc2V0TGFuZ3VhZ2VEaXJlY3Rpb246IGZ1bmN0aW9uIHNldExhbmd1YWdlRGlyZWN0aW9uKCkge1xuICAgIHZhciBkaXIgPSB0aGlzLmlucHV0LmdldExhbmd1YWdlRGlyZWN0aW9uKCk7XG5cbiAgICBpZiAodGhpcy5kaXIgIT09IGRpcikge1xuICAgICAgdGhpcy5kaXIgPSBkaXI7XG4gICAgICB0aGlzLiRub2RlLmNzcygnZGlyZWN0aW9uJywgZGlyKTtcbiAgICAgIHRoaXMuZHJvcGRvd24uc2V0TGFuZ3VhZ2VEaXJlY3Rpb24oZGlyKTtcbiAgICB9XG4gIH0sXG5cbiAgX3VwZGF0ZUhpbnQ6IGZ1bmN0aW9uIHVwZGF0ZUhpbnQoKSB7XG4gICAgdmFyIGRhdHVtO1xuICAgIHZhciB2YWw7XG4gICAgdmFyIHF1ZXJ5O1xuICAgIHZhciBlc2NhcGVkUXVlcnk7XG4gICAgdmFyIGZyb250TWF0Y2hSZWdFeDtcbiAgICB2YXIgbWF0Y2g7XG5cbiAgICBkYXR1bSA9IHRoaXMuZHJvcGRvd24uZ2V0RGF0dW1Gb3JUb3BTdWdnZXN0aW9uKCk7XG5cbiAgICBpZiAoZGF0dW0gJiYgdGhpcy5kcm9wZG93bi5pc1Zpc2libGUoKSAmJiAhdGhpcy5pbnB1dC5oYXNPdmVyZmxvdygpKSB7XG4gICAgICB2YWwgPSB0aGlzLmlucHV0LmdldElucHV0VmFsdWUoKTtcbiAgICAgIHF1ZXJ5ID0gSW5wdXQubm9ybWFsaXplUXVlcnkodmFsKTtcbiAgICAgIGVzY2FwZWRRdWVyeSA9IF8uZXNjYXBlUmVnRXhDaGFycyhxdWVyeSk7XG5cbiAgICAgIC8vIG1hdGNoIGlucHV0IHZhbHVlLCB0aGVuIGNhcHR1cmUgdHJhaWxpbmcgdGV4dFxuICAgICAgZnJvbnRNYXRjaFJlZ0V4ID0gbmV3IFJlZ0V4cCgnXig/OicgKyBlc2NhcGVkUXVlcnkgKyAnKSguKyQpJywgJ2knKTtcbiAgICAgIG1hdGNoID0gZnJvbnRNYXRjaFJlZ0V4LmV4ZWMoZGF0dW0udmFsdWUpO1xuXG4gICAgICAvLyBjbGVhciBoaW50IGlmIHRoZXJlJ3Mgbm8gdHJhaWxpbmcgdGV4dFxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0SGludCh2YWwgKyBtYXRjaFsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlucHV0LmNsZWFySGludCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlucHV0LmNsZWFySGludCgpO1xuICAgIH1cbiAgfSxcblxuICBfYXV0b2NvbXBsZXRlOiBmdW5jdGlvbiBhdXRvY29tcGxldGUobGF4Q3Vyc29yKSB7XG4gICAgdmFyIGhpbnQ7XG4gICAgdmFyIHF1ZXJ5O1xuICAgIHZhciBpc0N1cnNvckF0RW5kO1xuICAgIHZhciBkYXR1bTtcblxuICAgIGhpbnQgPSB0aGlzLmlucHV0LmdldEhpbnQoKTtcbiAgICBxdWVyeSA9IHRoaXMuaW5wdXQuZ2V0UXVlcnkoKTtcbiAgICBpc0N1cnNvckF0RW5kID0gbGF4Q3Vyc29yIHx8IHRoaXMuaW5wdXQuaXNDdXJzb3JBdEVuZCgpO1xuXG4gICAgaWYgKGhpbnQgJiYgcXVlcnkgIT09IGhpbnQgJiYgaXNDdXJzb3JBdEVuZCkge1xuICAgICAgZGF0dW0gPSB0aGlzLmRyb3Bkb3duLmdldERhdHVtRm9yVG9wU3VnZ2VzdGlvbigpO1xuICAgICAgaWYgKGRhdHVtKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0SW5wdXRWYWx1ZShkYXR1bS52YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMudHJpZ2dlcignYXV0b2NvbXBsZXRlZCcsIGRhdHVtLnJhdywgZGF0dW0uZGF0YXNldE5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBfc2VsZWN0OiBmdW5jdGlvbiBzZWxlY3QoZGF0dW0sIGNvbnRleHQpIHtcbiAgICBpZiAodHlwZW9mIGRhdHVtLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5pbnB1dC5zZXRRdWVyeShkYXR1bS52YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNsZWFyT25TZWxlY3RlZCkge1xuICAgICAgdGhpcy5zZXRWYWwoJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlucHV0LnNldElucHV0VmFsdWUoZGF0dW0udmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldExhbmd1YWdlRGlyZWN0aW9uKCk7XG5cbiAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50QnVzLnRyaWdnZXIoJ3NlbGVjdGVkJywgZGF0dW0ucmF3LCBkYXR1bS5kYXRhc2V0TmFtZSwgY29udGV4dCk7XG4gICAgaWYgKGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5kcm9wZG93bi5jbG9zZSgpO1xuXG4gICAgICAvLyAjMTE4OiBhbGxvdyBjbGljayBldmVudCB0byBidWJibGUgdXAgdG8gdGhlIGJvZHkgYmVmb3JlIHJlbW92aW5nXG4gICAgICAvLyB0aGUgc3VnZ2VzdGlvbnMgb3RoZXJ3aXNlIHdlIGJyZWFrIGV2ZW50IGRlbGVnYXRpb25cbiAgICAgIF8uZGVmZXIoXy5iaW5kKHRoaXMuZHJvcGRvd24uZW1wdHksIHRoaXMuZHJvcGRvd24pKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gIyMjIHB1YmxpY1xuXG4gIG9wZW46IGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgLy8gaWYgdGhlIG1lbnUgaXMgbm90IGFjdGl2YXRlZCB5ZXQsIHdlIG5lZWQgdG8gdXBkYXRlXG4gICAgLy8gdGhlIHVuZGVybHlpbmcgZHJvcGRvd24gbWVudSB0byB0cmlnZ2VyIHRoZSBzZWFyY2hcbiAgICAvLyBvdGhlcndpc2Ugd2UncmUgbm90IGdvbm5hIHNlZSBhbnl0aGluZ1xuICAgIGlmICghdGhpcy5pc0FjdGl2YXRlZCkge1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5pbnB1dC5nZXRJbnB1dFZhbHVlKCk7XG4gICAgICBpZiAocXVlcnkubGVuZ3RoID49IHRoaXMubWluTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24udXBkYXRlKHF1ZXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uZW1wdHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kcm9wZG93bi5vcGVuKCk7XG4gIH0sXG5cbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIHRoaXMuZHJvcGRvd24uY2xvc2UoKTtcbiAgfSxcblxuICBzZXRWYWw6IGZ1bmN0aW9uIHNldFZhbCh2YWwpIHtcbiAgICAvLyBleHBlY3QgdmFsIHRvIGJlIGEgc3RyaW5nLCBzbyBiZSBzYWZlLCBhbmQgY29lcmNlXG4gICAgdmFsID0gXy50b1N0cih2YWwpO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHRoaXMuaW5wdXQuc2V0SW5wdXRWYWx1ZSh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlucHV0LnNldFF1ZXJ5KHZhbCk7XG4gICAgICB0aGlzLmlucHV0LnNldElucHV0VmFsdWUodmFsLCB0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRMYW5ndWFnZURpcmVjdGlvbigpO1xuICB9LFxuXG4gIGdldFZhbDogZnVuY3Rpb24gZ2V0VmFsKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0LmdldFF1ZXJ5KCk7XG4gIH0sXG5cbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcbiAgICB0aGlzLmRyb3Bkb3duLmRlc3Ryb3koKTtcblxuICAgIGRlc3Ryb3lEb21TdHJ1Y3R1cmUodGhpcy4kbm9kZSwgdGhpcy5jc3NDbGFzc2VzKTtcblxuICAgIHRoaXMuJG5vZGUgPSBudWxsO1xuICB9LFxuXG4gIGdldFdyYXBwZXI6IGZ1bmN0aW9uIGdldFdyYXBwZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZHJvcGRvd24uJGNvbnRhaW5lclswXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGJ1aWxkRG9tKG9wdGlvbnMpIHtcbiAgdmFyICRpbnB1dDtcbiAgdmFyICR3cmFwcGVyO1xuICB2YXIgJGRyb3Bkb3duO1xuICB2YXIgJGhpbnQ7XG5cbiAgJGlucHV0ID0gRE9NLmVsZW1lbnQob3B0aW9ucy5pbnB1dCk7XG4gICR3cmFwcGVyID0gRE9NXG4gICAgLmVsZW1lbnQoaHRtbC53cmFwcGVyLnJlcGxhY2UoJyVST09UJScsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5yb290KSlcbiAgICAuY3NzKG9wdGlvbnMuY3NzLndyYXBwZXIpO1xuXG4gIC8vIG92ZXJyaWRlIHRoZSBkaXNwbGF5IHByb3BlcnR5IHdpdGggdGhlIHRhYmxlLWNlbGwgdmFsdWVcbiAgLy8gaWYgdGhlIHBhcmVudCBlbGVtZW50IGlzIGEgdGFibGUgYW5kIHRoZSBvcmlnaW5hbCBpbnB1dCB3YXMgYSBibG9ja1xuICAvLyAgLT4gaHR0cHM6Ly9naXRodWIuY29tL2FsZ29saWEvYXV0b2NvbXBsZXRlLmpzL2lzc3Vlcy8xNlxuICBpZiAoIW9wdGlvbnMuYXBwZW5kVG8gJiYgJGlucHV0LmNzcygnZGlzcGxheScpID09PSAnYmxvY2snICYmICRpbnB1dC5wYXJlbnQoKS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ3RhYmxlJykge1xuICAgICR3cmFwcGVyLmNzcygnZGlzcGxheScsICd0YWJsZS1jZWxsJyk7XG4gIH1cbiAgdmFyIGRyb3Bkb3duSHRtbCA9IGh0bWwuZHJvcGRvd24uXG4gICAgcmVwbGFjZSgnJVBSRUZJWCUnLCBvcHRpb25zLmNzc0NsYXNzZXMucHJlZml4KS5cbiAgICByZXBsYWNlKCclRFJPUERPV05fTUVOVSUnLCBvcHRpb25zLmNzc0NsYXNzZXMuZHJvcGRvd25NZW51KTtcbiAgJGRyb3Bkb3duID0gRE9NLmVsZW1lbnQoZHJvcGRvd25IdG1sKVxuICAgIC5jc3Mob3B0aW9ucy5jc3MuZHJvcGRvd24pXG4gICAgLmF0dHIoe1xuICAgICAgcm9sZTogJ2xpc3Rib3gnLFxuICAgICAgaWQ6IG9wdGlvbnMubGlzdGJveElkXG4gICAgfSk7XG4gIGlmIChvcHRpb25zLnRlbXBsYXRlcyAmJiBvcHRpb25zLnRlbXBsYXRlcy5kcm9wZG93bk1lbnUpIHtcbiAgICAkZHJvcGRvd24uaHRtbChfLnRlbXBsYXRpZnkob3B0aW9ucy50ZW1wbGF0ZXMuZHJvcGRvd25NZW51KSgpKTtcbiAgfVxuICAkaGludCA9ICRpbnB1dC5jbG9uZSgpLmNzcyhvcHRpb25zLmNzcy5oaW50KS5jc3MoZ2V0QmFja2dyb3VuZFN0eWxlcygkaW5wdXQpKTtcblxuICAkaGludFxuICAgIC52YWwoJycpXG4gICAgLmFkZENsYXNzKF8uY2xhc3NOYW1lKG9wdGlvbnMuY3NzQ2xhc3Nlcy5wcmVmaXgsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5oaW50LCB0cnVlKSlcbiAgICAucmVtb3ZlQXR0cignaWQgbmFtZSBwbGFjZWhvbGRlciByZXF1aXJlZCcpXG4gICAgLnByb3AoJ3JlYWRvbmx5JywgdHJ1ZSlcbiAgICAuYXR0cih7XG4gICAgICAnYXJpYS1oaWRkZW4nOiAndHJ1ZScsXG4gICAgICBhdXRvY29tcGxldGU6ICdvZmYnLFxuICAgICAgc3BlbGxjaGVjazogJ2ZhbHNlJyxcbiAgICAgIHRhYmluZGV4OiAtMVxuICAgIH0pO1xuICBpZiAoJGhpbnQucmVtb3ZlRGF0YSkge1xuICAgICRoaW50LnJlbW92ZURhdGEoKTtcbiAgfVxuXG4gIC8vIHN0b3JlIHRoZSBvcmlnaW5hbCB2YWx1ZXMgb2YgdGhlIGF0dHJzIHRoYXQgZ2V0IG1vZGlmaWVkXG4gIC8vIHNvIG1vZGlmaWNhdGlvbnMgY2FuIGJlIHJldmVydGVkIG9uIGRlc3Ryb3lcbiAgJGlucHV0LmRhdGEoYXR0cnNLZXksIHtcbiAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAkaW5wdXQuYXR0cignYXJpYS1hdXRvY29tcGxldGUnKSxcbiAgICAnYXJpYS1leHBhbmRlZCc6ICRpbnB1dC5hdHRyKCdhcmlhLWV4cGFuZGVkJyksXG4gICAgJ2FyaWEtb3ducyc6ICRpbnB1dC5hdHRyKCdhcmlhLW93bnMnKSxcbiAgICBhdXRvY29tcGxldGU6ICRpbnB1dC5hdHRyKCdhdXRvY29tcGxldGUnKSxcbiAgICBkaXI6ICRpbnB1dC5hdHRyKCdkaXInKSxcbiAgICByb2xlOiAkaW5wdXQuYXR0cigncm9sZScpLFxuICAgIHNwZWxsY2hlY2s6ICRpbnB1dC5hdHRyKCdzcGVsbGNoZWNrJyksXG4gICAgc3R5bGU6ICRpbnB1dC5hdHRyKCdzdHlsZScpLFxuICAgIHR5cGU6ICRpbnB1dC5hdHRyKCd0eXBlJylcbiAgfSk7XG5cbiAgJGlucHV0XG4gICAgLmFkZENsYXNzKF8uY2xhc3NOYW1lKG9wdGlvbnMuY3NzQ2xhc3Nlcy5wcmVmaXgsIG9wdGlvbnMuY3NzQ2xhc3Nlcy5pbnB1dCwgdHJ1ZSkpXG4gICAgLmF0dHIoe1xuICAgICAgYXV0b2NvbXBsZXRlOiAnb2ZmJyxcbiAgICAgIHNwZWxsY2hlY2s6IGZhbHNlLFxuXG4gICAgICAvLyBBY2Nlc3NpYmlsaXR5IGZlYXR1cmVzXG4gICAgICAvLyBHaXZlIHRoZSBmaWVsZCBhIHByZXNlbnRhdGlvbiBvZiBhIFwic2VsZWN0XCIuXG4gICAgICAvLyBDb21ib2JveCBpcyB0aGUgY29tYmluZWQgcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGxpbmUgdGV4dGZpZWxkXG4gICAgICAvLyB3aXRoIGEgbGlzdGJveCBwb3B1cC5cbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9XQUkvUEYvYXJpYS9yb2xlcyNjb21ib2JveFxuICAgICAgcm9sZTogJ2NvbWJvYm94JyxcbiAgICAgIC8vIExldCB0aGUgc2NyZWVuIHJlYWRlciBrbm93IHRoZSBmaWVsZCBoYXMgYW4gYXV0b2NvbXBsZXRlXG4gICAgICAvLyBmZWF0dXJlIHRvIGl0LlxuICAgICAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogKG9wdGlvbnMuZGF0YXNldHMgJiZcbiAgICAgICAgb3B0aW9ucy5kYXRhc2V0c1swXSAmJiBvcHRpb25zLmRhdGFzZXRzWzBdLmRpc3BsYXlLZXkgPyAnYm90aCcgOiAnbGlzdCcpLFxuICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRyb3Bkb3duIGl0IGNvbnRyb2xzIGlzIGN1cnJlbnRseSBleHBhbmRlZCBvciBjb2xsYXBzZWRcbiAgICAgICdhcmlhLWV4cGFuZGVkJzogJ2ZhbHNlJyxcbiAgICAgICdhcmlhLWxhYmVsJzogb3B0aW9ucy5hcmlhTGFiZWwsXG4gICAgICAvLyBFeHBsaWNpdGx5IHBvaW50IHRvIHRoZSBsaXN0Ym94LFxuICAgICAgLy8gd2hpY2ggaXMgYSBsaXN0IG9mIHN1Z2dlc3Rpb25zIChha2Egb3B0aW9ucylcbiAgICAgICdhcmlhLW93bnMnOiBvcHRpb25zLmxpc3Rib3hJZFxuICAgIH0pXG4gICAgLmNzcyhvcHRpb25zLmhpbnQgPyBvcHRpb25zLmNzcy5pbnB1dCA6IG9wdGlvbnMuY3NzLmlucHV0V2l0aE5vSGludCk7XG5cbiAgLy8gaWU3IGRvZXMgbm90IGxpa2UgaXQgd2hlbiBkaXIgaXMgc2V0IHRvIGF1dG9cbiAgdHJ5IHtcbiAgICBpZiAoISRpbnB1dC5hdHRyKCdkaXInKSkge1xuICAgICAgJGlucHV0LmF0dHIoJ2RpcicsICdhdXRvJyk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaWdub3JlXG4gIH1cblxuICAkd3JhcHBlciA9IG9wdGlvbnMuYXBwZW5kVG9cbiAgICA/ICR3cmFwcGVyLmFwcGVuZFRvKERPTS5lbGVtZW50KG9wdGlvbnMuYXBwZW5kVG8pLmVxKDApKS5lcSgwKVxuICAgIDogJGlucHV0LndyYXAoJHdyYXBwZXIpLnBhcmVudCgpO1xuXG4gICR3cmFwcGVyXG4gICAgLnByZXBlbmQob3B0aW9ucy5oaW50ID8gJGhpbnQgOiBudWxsKVxuICAgIC5hcHBlbmQoJGRyb3Bkb3duKTtcblxuICByZXR1cm4ge1xuICAgIHdyYXBwZXI6ICR3cmFwcGVyLFxuICAgIGlucHV0OiAkaW5wdXQsXG4gICAgaGludDogJGhpbnQsXG4gICAgbWVudTogJGRyb3Bkb3duXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRTdHlsZXMoJGVsKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZEF0dGFjaG1lbnQ6ICRlbC5jc3MoJ2JhY2tncm91bmQtYXR0YWNobWVudCcpLFxuICAgIGJhY2tncm91bmRDbGlwOiAkZWwuY3NzKCdiYWNrZ3JvdW5kLWNsaXAnKSxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICRlbC5jc3MoJ2JhY2tncm91bmQtY29sb3InKSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6ICRlbC5jc3MoJ2JhY2tncm91bmQtaW1hZ2UnKSxcbiAgICBiYWNrZ3JvdW5kT3JpZ2luOiAkZWwuY3NzKCdiYWNrZ3JvdW5kLW9yaWdpbicpLFxuICAgIGJhY2tncm91bmRQb3NpdGlvbjogJGVsLmNzcygnYmFja2dyb3VuZC1wb3NpdGlvbicpLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6ICRlbC5jc3MoJ2JhY2tncm91bmQtcmVwZWF0JyksXG4gICAgYmFja2dyb3VuZFNpemU6ICRlbC5jc3MoJ2JhY2tncm91bmQtc2l6ZScpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lEb21TdHJ1Y3R1cmUoJG5vZGUsIGNzc0NsYXNzZXMpIHtcbiAgdmFyICRpbnB1dCA9ICRub2RlLmZpbmQoXy5jbGFzc05hbWUoY3NzQ2xhc3Nlcy5wcmVmaXgsIGNzc0NsYXNzZXMuaW5wdXQpKTtcblxuICAvLyBuZWVkIHRvIHJlbW92ZSBhdHRycyB0aGF0IHdlcmVuJ3QgcHJldmlvdXNseSBkZWZpbmVkIGFuZFxuICAvLyByZXZlcnQgYXR0cnMgdGhhdCBvcmlnaW5hbGx5IGhhZCBhIHZhbHVlXG4gIF8uZWFjaCgkaW5wdXQuZGF0YShhdHRyc0tleSksIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAkaW5wdXQucmVtb3ZlQXR0cihrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkaW5wdXQuYXR0cihrZXksIHZhbCk7XG4gICAgfVxuICB9KTtcblxuICAkaW5wdXRcbiAgICAuZGV0YWNoKClcbiAgICAucmVtb3ZlQ2xhc3MoXy5jbGFzc05hbWUoY3NzQ2xhc3Nlcy5wcmVmaXgsIGNzc0NsYXNzZXMuaW5wdXQsIHRydWUpKVxuICAgIC5pbnNlcnRBZnRlcigkbm9kZSk7XG4gIGlmICgkaW5wdXQucmVtb3ZlRGF0YSkge1xuICAgICRpbnB1dC5yZW1vdmVEYXRhKGF0dHJzS2V5KTtcbiAgfVxuXG4gICRub2RlLnJlbW92ZSgpO1xufVxuXG5UeXBlYWhlYWQuRHJvcGRvd24gPSBEcm9wZG93bjtcblR5cGVhaGVhZC5JbnB1dCA9IElucHV0O1xuVHlwZWFoZWFkLnNvdXJjZXMgPSByZXF1aXJlKCcuLi9zb3VyY2VzL2luZGV4LmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHlwZWFoZWFkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///98693\n")},71337:module=>{"use strict";eval("\n\nmodule.exports = {\n  element: null\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEzMzcuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9hdXRvY29tcGxldGUuanMvc3JjL2NvbW1vbi9kb20uanM/MjZlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbGVtZW50OiBudWxsXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///71337\n")},66766:module=>{"use strict";eval("\n\nmodule.exports = function parseAlgoliaClientVersion(agent) {\n  var parsed =\n    // User agent for algoliasearch >= 3.33.0\n    agent.match(/Algolia for JavaScript \\((\\d+\\.)(\\d+\\.)(\\d+)\\)/) ||\n    // User agent for algoliasearch < 3.33.0\n    agent.match(/Algolia for vanilla JavaScript (\\d+\\.)(\\d+\\.)(\\d+)/);\n\n  if (parsed) {\n    return [parsed[1], parsed[2], parsed[3]];\n  }\n\n  return undefined;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY3NjYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9hdXRvY29tcGxldGUuanMvc3JjL2NvbW1vbi9wYXJzZUFsZ29saWFDbGllbnRWZXJzaW9uLmpzP2U1YjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlQWxnb2xpYUNsaWVudFZlcnNpb24oYWdlbnQpIHtcbiAgdmFyIHBhcnNlZCA9XG4gICAgLy8gVXNlciBhZ2VudCBmb3IgYWxnb2xpYXNlYXJjaCA+PSAzLjMzLjBcbiAgICBhZ2VudC5tYXRjaCgvQWxnb2xpYSBmb3IgSmF2YVNjcmlwdCBcXCgoXFxkK1xcLikoXFxkK1xcLikoXFxkKylcXCkvKSB8fFxuICAgIC8vIFVzZXIgYWdlbnQgZm9yIGFsZ29saWFzZWFyY2ggPCAzLjMzLjBcbiAgICBhZ2VudC5tYXRjaCgvQWxnb2xpYSBmb3IgdmFuaWxsYSBKYXZhU2NyaXB0IChcXGQrXFwuKShcXGQrXFwuKShcXGQrKS8pO1xuXG4gIGlmIChwYXJzZWQpIHtcbiAgICByZXR1cm4gW3BhcnNlZFsxXSwgcGFyc2VkWzJdLCBwYXJzZWRbM11dO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///66766\n")},16220:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar DOM = __webpack_require__(71337);\n\nfunction escapeRegExp(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n\nmodule.exports = {\n  // those methods are implemented differently\n  // depending on which build it is, using\n  // $... or angular... or Zepto... or require(...)\n  isArray: null,\n  isFunction: null,\n  isObject: null,\n  bind: null,\n  each: null,\n  map: null,\n  mixin: null,\n\n  isMsie: function(agentString) {\n    if (agentString === undefined) { agentString = navigator.userAgent; }\n    // from https://github.com/ded/bowser/blob/master/bowser.js\n    if ((/(msie|trident)/i).test(agentString)) {\n      var match = agentString.match(/(msie |rv:)(\\d+(.\\d+)?)/i);\n      if (match) { return match[2]; }\n    }\n    return false;\n  },\n\n  // http://stackoverflow.com/a/6969486\n  escapeRegExChars: function(str) {\n    return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n  },\n\n  isNumber: function(obj) { return typeof obj === 'number'; },\n\n  toStr: function toStr(s) {\n    return s === undefined || s === null ? '' : s + '';\n  },\n\n  cloneDeep: function cloneDeep(obj) {\n    var clone = this.mixin({}, obj);\n    var self = this;\n    this.each(clone, function(value, key) {\n      if (value) {\n        if (self.isArray(value)) {\n          clone[key] = [].concat(value);\n        } else if (self.isObject(value)) {\n          clone[key] = self.cloneDeep(value);\n        }\n      }\n    });\n    return clone;\n  },\n\n  error: function(msg) {\n    throw new Error(msg);\n  },\n\n  every: function(obj, test) {\n    var result = true;\n    if (!obj) {\n      return result;\n    }\n    this.each(obj, function(val, key) {\n      if (result) {\n        result = test.call(null, val, key, obj) && result;\n      }\n    });\n    return !!result;\n  },\n\n  any: function(obj, test) {\n    var found = false;\n    if (!obj) {\n      return found;\n    }\n    this.each(obj, function(val, key) {\n      if (test.call(null, val, key, obj)) {\n        found = true;\n        return false;\n      }\n    });\n    return found;\n  },\n\n  getUniqueId: (function() {\n    var counter = 0;\n    return function() { return counter++; };\n  })(),\n\n  templatify: function templatify(obj) {\n    if (this.isFunction(obj)) {\n      return obj;\n    }\n    var $template = DOM.element(obj);\n    if ($template.prop('tagName') === 'SCRIPT') {\n      return function template() { return $template.text(); };\n    }\n    return function template() { return String(obj); };\n  },\n\n  defer: function(fn) { setTimeout(fn, 0); },\n\n  noop: function() {},\n\n  formatPrefix: function(prefix, noPrefix) {\n    return noPrefix ? '' : prefix + '-';\n  },\n\n  className: function(prefix, clazz, skipDot) {\n    return (skipDot ? '' : '.') + prefix + clazz;\n  },\n\n  escapeHighlightedString: function(str, highlightPreTag, highlightPostTag) {\n    highlightPreTag = highlightPreTag || '<em>';\n    var pre = document.createElement('div');\n    pre.appendChild(document.createTextNode(highlightPreTag));\n\n    highlightPostTag = highlightPostTag || '</em>';\n    var post = document.createElement('div');\n    post.appendChild(document.createTextNode(highlightPostTag));\n\n    var div = document.createElement('div');\n    div.appendChild(document.createTextNode(str));\n    return div.innerHTML\n      .replace(RegExp(escapeRegExp(pre.innerHTML), 'g'), highlightPreTag)\n      .replace(RegExp(escapeRegExp(post.innerHTML), 'g'), highlightPostTag);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyMjAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLEtBQVU7O0FBRTVCO0FBQ0EsaUNBQWlDLEVBQUU7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1DQUFtQyxFQUFFO0FBQ3JDLEdBQUc7O0FBRUgsNEJBQTRCLGlDQUFpQzs7QUFFN0Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxpQ0FBaUM7QUFDakMsR0FBRzs7QUFFSCx3QkFBd0Isb0JBQW9COztBQUU1QyxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9jb21tb24vdXRpbHMuanM/MWE1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBET00gPSByZXF1aXJlKCcuL2RvbS5qcycpO1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIHRob3NlIG1ldGhvZHMgYXJlIGltcGxlbWVudGVkIGRpZmZlcmVudGx5XG4gIC8vIGRlcGVuZGluZyBvbiB3aGljaCBidWlsZCBpdCBpcywgdXNpbmdcbiAgLy8gJC4uLiBvciBhbmd1bGFyLi4uIG9yIFplcHRvLi4uIG9yIHJlcXVpcmUoLi4uKVxuICBpc0FycmF5OiBudWxsLFxuICBpc0Z1bmN0aW9uOiBudWxsLFxuICBpc09iamVjdDogbnVsbCxcbiAgYmluZDogbnVsbCxcbiAgZWFjaDogbnVsbCxcbiAgbWFwOiBudWxsLFxuICBtaXhpbjogbnVsbCxcblxuICBpc01zaWU6IGZ1bmN0aW9uKGFnZW50U3RyaW5nKSB7XG4gICAgaWYgKGFnZW50U3RyaW5nID09PSB1bmRlZmluZWQpIHsgYWdlbnRTdHJpbmcgPSBuYXZpZ2F0b3IudXNlckFnZW50OyB9XG4gICAgLy8gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZGVkL2Jvd3Nlci9ibG9iL21hc3Rlci9ib3dzZXIuanNcbiAgICBpZiAoKC8obXNpZXx0cmlkZW50KS9pKS50ZXN0KGFnZW50U3RyaW5nKSkge1xuICAgICAgdmFyIG1hdGNoID0gYWdlbnRTdHJpbmcubWF0Y2goLyhtc2llIHxydjopKFxcZCsoLlxcZCspPykvaSk7XG4gICAgICBpZiAobWF0Y2gpIHsgcmV0dXJuIG1hdGNoWzJdOyB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG4gIGVzY2FwZVJlZ0V4Q2hhcnM6IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvW1xcLVxcW1xcXVxcL1xce1xcfVxcKFxcKVxcKlxcK1xcP1xcLlxcXFxcXF5cXCRcXHxdL2csICdcXFxcJCYnKTtcbiAgfSxcblxuICBpc051bWJlcjogZnVuY3Rpb24ob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJzsgfSxcblxuICB0b1N0cjogZnVuY3Rpb24gdG9TdHIocykge1xuICAgIHJldHVybiBzID09PSB1bmRlZmluZWQgfHwgcyA9PT0gbnVsbCA/ICcnIDogcyArICcnO1xuICB9LFxuXG4gIGNsb25lRGVlcDogZnVuY3Rpb24gY2xvbmVEZWVwKG9iaikge1xuICAgIHZhciBjbG9uZSA9IHRoaXMubWl4aW4oe30sIG9iaik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZWFjaChjbG9uZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGlmIChzZWxmLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgY2xvbmVba2V5XSA9IFtdLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsZi5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICBjbG9uZVtrZXldID0gc2VsZi5jbG9uZURlZXAodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9LFxuXG4gIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfSxcblxuICBldmVyeTogZnVuY3Rpb24ob2JqLCB0ZXN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRoaXMuZWFjaChvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IHRlc3QuY2FsbChudWxsLCB2YWwsIGtleSwgb2JqKSAmJiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9LFxuXG4gIGFueTogZnVuY3Rpb24ob2JqLCB0ZXN0KSB7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgdGhpcy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgIGlmICh0ZXN0LmNhbGwobnVsbCwgdmFsLCBrZXksIG9iaikpIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xuICB9LFxuXG4gIGdldFVuaXF1ZUlkOiAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIGNvdW50ZXIrKzsgfTtcbiAgfSkoKSxcblxuICB0ZW1wbGF0aWZ5OiBmdW5jdGlvbiB0ZW1wbGF0aWZ5KG9iaikge1xuICAgIGlmICh0aGlzLmlzRnVuY3Rpb24ob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyICR0ZW1wbGF0ZSA9IERPTS5lbGVtZW50KG9iaik7XG4gICAgaWYgKCR0ZW1wbGF0ZS5wcm9wKCd0YWdOYW1lJykgPT09ICdTQ1JJUFQnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdGVtcGxhdGUoKSB7IHJldHVybiAkdGVtcGxhdGUudGV4dCgpOyB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdGVtcGxhdGUoKSB7IHJldHVybiBTdHJpbmcob2JqKTsgfTtcbiAgfSxcblxuICBkZWZlcjogZnVuY3Rpb24oZm4pIHsgc2V0VGltZW91dChmbiwgMCk7IH0sXG5cbiAgbm9vcDogZnVuY3Rpb24oKSB7fSxcblxuICBmb3JtYXRQcmVmaXg6IGZ1bmN0aW9uKHByZWZpeCwgbm9QcmVmaXgpIHtcbiAgICByZXR1cm4gbm9QcmVmaXggPyAnJyA6IHByZWZpeCArICctJztcbiAgfSxcblxuICBjbGFzc05hbWU6IGZ1bmN0aW9uKHByZWZpeCwgY2xhenosIHNraXBEb3QpIHtcbiAgICByZXR1cm4gKHNraXBEb3QgPyAnJyA6ICcuJykgKyBwcmVmaXggKyBjbGF6ejtcbiAgfSxcblxuICBlc2NhcGVIaWdobGlnaHRlZFN0cmluZzogZnVuY3Rpb24oc3RyLCBoaWdobGlnaHRQcmVUYWcsIGhpZ2hsaWdodFBvc3RUYWcpIHtcbiAgICBoaWdobGlnaHRQcmVUYWcgPSBoaWdobGlnaHRQcmVUYWcgfHwgJzxlbT4nO1xuICAgIHZhciBwcmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoaGlnaGxpZ2h0UHJlVGFnKSk7XG5cbiAgICBoaWdobGlnaHRQb3N0VGFnID0gaGlnaGxpZ2h0UG9zdFRhZyB8fCAnPC9lbT4nO1xuICAgIHZhciBwb3N0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9zdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShoaWdobGlnaHRQb3N0VGFnKSk7XG5cbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cikpO1xuICAgIHJldHVybiBkaXYuaW5uZXJIVE1MXG4gICAgICAucmVwbGFjZShSZWdFeHAoZXNjYXBlUmVnRXhwKHByZS5pbm5lckhUTUwpLCAnZycpLCBoaWdobGlnaHRQcmVUYWcpXG4gICAgICAucmVwbGFjZShSZWdFeHAoZXNjYXBlUmVnRXhwKHBvc3QuaW5uZXJIVE1MKSwgJ2cnKSwgaGlnaGxpZ2h0UG9zdFRhZyk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16220\n")},81242:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _ = __webpack_require__(16220);\nvar version = __webpack_require__(71622);\nvar parseAlgoliaClientVersion = __webpack_require__(66766);\n\nmodule.exports = function search(index, params) {\n  var algoliaVersion = parseAlgoliaClientVersion(index.as._ua);\n  if (algoliaVersion && algoliaVersion[0] >= 3 && algoliaVersion[1] > 20) {\n    params = params || {};\n    params.additionalUA = 'autocomplete.js ' + version;\n  }\n  return sourceFn;\n\n  function sourceFn(query, cb) {\n    index.search(query, params, function(error, content) {\n      if (error) {\n        _.error(error.message);\n        return;\n      }\n      cb(content.hits, content);\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEyNDIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxLQUFrQjtBQUN4QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxLQUF3Qzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9zb3VyY2VzL2hpdHMuanM/ODcwYyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzLmpzJyk7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3ZlcnNpb24uanMnKTtcbnZhciBwYXJzZUFsZ29saWFDbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vY29tbW9uL3BhcnNlQWxnb2xpYUNsaWVudFZlcnNpb24uanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZWFyY2goaW5kZXgsIHBhcmFtcykge1xuICB2YXIgYWxnb2xpYVZlcnNpb24gPSBwYXJzZUFsZ29saWFDbGllbnRWZXJzaW9uKGluZGV4LmFzLl91YSk7XG4gIGlmIChhbGdvbGlhVmVyc2lvbiAmJiBhbGdvbGlhVmVyc2lvblswXSA+PSAzICYmIGFsZ29saWFWZXJzaW9uWzFdID4gMjApIHtcbiAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgcGFyYW1zLmFkZGl0aW9uYWxVQSA9ICdhdXRvY29tcGxldGUuanMgJyArIHZlcnNpb247XG4gIH1cbiAgcmV0dXJuIHNvdXJjZUZuO1xuXG4gIGZ1bmN0aW9uIHNvdXJjZUZuKHF1ZXJ5LCBjYikge1xuICAgIGluZGV4LnNlYXJjaChxdWVyeSwgcGFyYW1zLCBmdW5jdGlvbihlcnJvciwgY29udGVudCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIF8uZXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNiKGNvbnRlbnQuaGl0cywgY29udGVudCk7XG4gICAgfSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81242\n")},64710:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nmodule.exports = {\n  hits: __webpack_require__(81242),\n  popularIn: __webpack_require__(30392)\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQ3MTAuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxRQUFRLG1CQUFPLENBQUMsS0FBVztBQUMzQixhQUFhLG1CQUFPLENBQUMsS0FBZ0I7QUFDckMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvc291cmNlcy9pbmRleC5qcz9jMzk1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGhpdHM6IHJlcXVpcmUoJy4vaGl0cy5qcycpLFxuICBwb3B1bGFySW46IHJlcXVpcmUoJy4vcG9wdWxhckluLmpzJylcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///64710\n")},30392:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nvar _ = __webpack_require__(16220);\nvar version = __webpack_require__(71622);\nvar parseAlgoliaClientVersion = __webpack_require__(66766);\n\nmodule.exports = function popularIn(index, params, details, options) {\n  var algoliaVersion = parseAlgoliaClientVersion(index.as._ua);\n  if (algoliaVersion && algoliaVersion[0] >= 3 && algoliaVersion[1] > 20) {\n    params = params || {};\n    params.additionalUA = 'autocomplete.js ' + version;\n  }\n  if (!details.source) {\n    return _.error(\"Missing 'source' key\");\n  }\n  var source = _.isFunction(details.source) ? details.source : function(hit) { return hit[details.source]; };\n\n  if (!details.index) {\n    return _.error(\"Missing 'index' key\");\n  }\n  var detailsIndex = details.index;\n\n  options = options || {};\n\n  return sourceFn;\n\n  function sourceFn(query, cb) {\n    index.search(query, params, function(error, content) {\n      if (error) {\n        _.error(error.message);\n        return;\n      }\n\n      if (content.hits.length > 0) {\n        var first = content.hits[0];\n\n        var detailsParams = _.mixin({hitsPerPage: 0}, details);\n        delete detailsParams.source; // not a query parameter\n        delete detailsParams.index; // not a query parameter\n\n        var detailsAlgoliaVersion = parseAlgoliaClientVersion(detailsIndex.as._ua);\n        if (detailsAlgoliaVersion && detailsAlgoliaVersion[0] >= 3 && detailsAlgoliaVersion[1] > 20) {\n          params.additionalUA = 'autocomplete.js ' + version;\n        }\n\n        detailsIndex.search(source(first), detailsParams, function(error2, content2) {\n          if (error2) {\n            _.error(error2.message);\n            return;\n          }\n\n          var suggestions = [];\n\n          // add the 'all department' entry before others\n          if (options.includeAll) {\n            var label = options.allTitle || 'All departments';\n            suggestions.push(_.mixin({\n              facet: {value: label, count: content2.nbHits}\n            }, _.cloneDeep(first)));\n          }\n\n          // enrich the first hit iterating over the facets\n          _.each(content2.facets, function(values, facet) {\n            _.each(values, function(count, value) {\n              suggestions.push(_.mixin({\n                facet: {facet: facet, value: value, count: count}\n              }, _.cloneDeep(first)));\n            });\n          });\n\n          // append all other hits\n          for (var i = 1; i < content.hits.length; ++i) {\n            suggestions.push(content.hits[i]);\n          }\n\n          cb(suggestions, content);\n        });\n\n        return;\n      }\n\n      cb([]);\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAzOTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDLGNBQWMsbUJBQU8sQ0FBQyxLQUFrQjtBQUN4QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxLQUF3Qzs7QUFFaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUMsZUFBZTtBQUNwRCxxQ0FBcUM7QUFDckMsb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixlQUFlO0FBQ2YsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvYXV0b2NvbXBsZXRlLmpzL3NyYy9zb3VyY2VzL3BvcHVsYXJJbi5qcz84N2E1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMuanMnKTtcbnZhciB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vdmVyc2lvbi5qcycpO1xudmFyIHBhcnNlQWxnb2xpYUNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi9jb21tb24vcGFyc2VBbGdvbGlhQ2xpZW50VmVyc2lvbi5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBvcHVsYXJJbihpbmRleCwgcGFyYW1zLCBkZXRhaWxzLCBvcHRpb25zKSB7XG4gIHZhciBhbGdvbGlhVmVyc2lvbiA9IHBhcnNlQWxnb2xpYUNsaWVudFZlcnNpb24oaW5kZXguYXMuX3VhKTtcbiAgaWYgKGFsZ29saWFWZXJzaW9uICYmIGFsZ29saWFWZXJzaW9uWzBdID49IDMgJiYgYWxnb2xpYVZlcnNpb25bMV0gPiAyMCkge1xuICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICBwYXJhbXMuYWRkaXRpb25hbFVBID0gJ2F1dG9jb21wbGV0ZS5qcyAnICsgdmVyc2lvbjtcbiAgfVxuICBpZiAoIWRldGFpbHMuc291cmNlKSB7XG4gICAgcmV0dXJuIF8uZXJyb3IoXCJNaXNzaW5nICdzb3VyY2UnIGtleVwiKTtcbiAgfVxuICB2YXIgc291cmNlID0gXy5pc0Z1bmN0aW9uKGRldGFpbHMuc291cmNlKSA/IGRldGFpbHMuc291cmNlIDogZnVuY3Rpb24oaGl0KSB7IHJldHVybiBoaXRbZGV0YWlscy5zb3VyY2VdOyB9O1xuXG4gIGlmICghZGV0YWlscy5pbmRleCkge1xuICAgIHJldHVybiBfLmVycm9yKFwiTWlzc2luZyAnaW5kZXgnIGtleVwiKTtcbiAgfVxuICB2YXIgZGV0YWlsc0luZGV4ID0gZGV0YWlscy5pbmRleDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICByZXR1cm4gc291cmNlRm47XG5cbiAgZnVuY3Rpb24gc291cmNlRm4ocXVlcnksIGNiKSB7XG4gICAgaW5kZXguc2VhcmNoKHF1ZXJ5LCBwYXJhbXMsIGZ1bmN0aW9uKGVycm9yLCBjb250ZW50KSB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgXy5lcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudC5oaXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gY29udGVudC5oaXRzWzBdO1xuXG4gICAgICAgIHZhciBkZXRhaWxzUGFyYW1zID0gXy5taXhpbih7aGl0c1BlclBhZ2U6IDB9LCBkZXRhaWxzKTtcbiAgICAgICAgZGVsZXRlIGRldGFpbHNQYXJhbXMuc291cmNlOyAvLyBub3QgYSBxdWVyeSBwYXJhbWV0ZXJcbiAgICAgICAgZGVsZXRlIGRldGFpbHNQYXJhbXMuaW5kZXg7IC8vIG5vdCBhIHF1ZXJ5IHBhcmFtZXRlclxuXG4gICAgICAgIHZhciBkZXRhaWxzQWxnb2xpYVZlcnNpb24gPSBwYXJzZUFsZ29saWFDbGllbnRWZXJzaW9uKGRldGFpbHNJbmRleC5hcy5fdWEpO1xuICAgICAgICBpZiAoZGV0YWlsc0FsZ29saWFWZXJzaW9uICYmIGRldGFpbHNBbGdvbGlhVmVyc2lvblswXSA+PSAzICYmIGRldGFpbHNBbGdvbGlhVmVyc2lvblsxXSA+IDIwKSB7XG4gICAgICAgICAgcGFyYW1zLmFkZGl0aW9uYWxVQSA9ICdhdXRvY29tcGxldGUuanMgJyArIHZlcnNpb247XG4gICAgICAgIH1cblxuICAgICAgICBkZXRhaWxzSW5kZXguc2VhcmNoKHNvdXJjZShmaXJzdCksIGRldGFpbHNQYXJhbXMsIGZ1bmN0aW9uKGVycm9yMiwgY29udGVudDIpIHtcbiAgICAgICAgICBpZiAoZXJyb3IyKSB7XG4gICAgICAgICAgICBfLmVycm9yKGVycm9yMi5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3VnZ2VzdGlvbnMgPSBbXTtcblxuICAgICAgICAgIC8vIGFkZCB0aGUgJ2FsbCBkZXBhcnRtZW50JyBlbnRyeSBiZWZvcmUgb3RoZXJzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUFsbCkge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gb3B0aW9ucy5hbGxUaXRsZSB8fCAnQWxsIGRlcGFydG1lbnRzJztcbiAgICAgICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goXy5taXhpbih7XG4gICAgICAgICAgICAgIGZhY2V0OiB7dmFsdWU6IGxhYmVsLCBjb3VudDogY29udGVudDIubmJIaXRzfVxuICAgICAgICAgICAgfSwgXy5jbG9uZURlZXAoZmlyc3QpKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZW5yaWNoIHRoZSBmaXJzdCBoaXQgaXRlcmF0aW5nIG92ZXIgdGhlIGZhY2V0c1xuICAgICAgICAgIF8uZWFjaChjb250ZW50Mi5mYWNldHMsIGZ1bmN0aW9uKHZhbHVlcywgZmFjZXQpIHtcbiAgICAgICAgICAgIF8uZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKGNvdW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKF8ubWl4aW4oe1xuICAgICAgICAgICAgICAgIGZhY2V0OiB7ZmFjZXQ6IGZhY2V0LCB2YWx1ZTogdmFsdWUsIGNvdW50OiBjb3VudH1cbiAgICAgICAgICAgICAgfSwgXy5jbG9uZURlZXAoZmlyc3QpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIGFwcGVuZCBhbGwgb3RoZXIgaGl0c1xuICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgY29udGVudC5oaXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKGNvbnRlbnQuaGl0c1tpXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2Ioc3VnZ2VzdGlvbnMsIGNvbnRlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNiKFtdKTtcbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30392\n")},75275:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\n// this will inject Zepto in window, unfortunately no easy commonJS zepto build\nvar zepto = __webpack_require__(53704);\n\n// setup DOM element\nvar DOM = __webpack_require__(71337);\nDOM.element = zepto;\n\n// setup utils functions\nvar _ = __webpack_require__(16220);\n_.isArray = zepto.isArray;\n_.isFunction = zepto.isFunction;\n_.isObject = zepto.isPlainObject;\n_.bind = zepto.proxy;\n_.each = function(collection, cb) {\n  // stupid argument order for jQuery.each\n  zepto.each(collection, reverseArgs);\n  function reverseArgs(index, value) {\n    return cb(value, index);\n  }\n};\n_.map = zepto.map;\n_.mixin = zepto.extend;\n_.Event = zepto.Event;\n\nvar typeaheadKey = 'aaAutocomplete';\nvar Typeahead = __webpack_require__(98693);\nvar EventBus = __webpack_require__(94045);\n\nfunction autocomplete(selector, options, datasets, typeaheadObject) {\n  datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 2);\n\n  var inputs = zepto(selector).each(function(i, input) {\n    var $input = zepto(input);\n    var eventBus = new EventBus({el: $input});\n    var typeahead = typeaheadObject || new Typeahead({\n      input: $input,\n      eventBus: eventBus,\n      dropdownMenuContainer: options.dropdownMenuContainer,\n      hint: options.hint === undefined ? true : !!options.hint,\n      minLength: options.minLength,\n      autoselect: options.autoselect,\n      autoselectOnBlur: options.autoselectOnBlur,\n      tabAutocomplete: options.tabAutocomplete,\n      openOnFocus: options.openOnFocus,\n      templates: options.templates,\n      debug: options.debug,\n      clearOnSelected: options.clearOnSelected,\n      cssClasses: options.cssClasses,\n      datasets: datasets,\n      keyboardShortcuts: options.keyboardShortcuts,\n      appendTo: options.appendTo,\n      autoWidth: options.autoWidth,\n      ariaLabel: options.ariaLabel || input.getAttribute('aria-label')\n    });\n    $input.data(typeaheadKey, typeahead);\n  });\n\n  // expose all methods in the `autocomplete` attribute\n  inputs.autocomplete = {};\n  _.each(['open', 'close', 'getVal', 'setVal', 'destroy', 'getWrapper'], function(method) {\n    inputs.autocomplete[method] = function() {\n      var methodArguments = arguments;\n      var result;\n      inputs.each(function(j, input) {\n        var typeahead = zepto(input).data(typeaheadKey);\n        result = typeahead[method].apply(typeahead, methodArguments);\n      });\n      return result;\n    };\n  });\n\n  return inputs;\n}\n\nautocomplete.sources = Typeahead.sources;\nautocomplete.escapeHighlightedString = _.escapeHighlightedString;\n\nvar wasAutocompleteSet = 'autocomplete' in window;\nvar oldAutocomplete = window.autocomplete;\nautocomplete.noConflict = function noConflict() {\n  if (wasAutocompleteSet) {\n    window.autocomplete = oldAutocomplete;\n  } else {\n    delete window.autocomplete;\n  }\n  return autocomplete;\n};\n\nmodule.exports = autocomplete;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUyNzUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQSxZQUFZLG1CQUFPLENBQUMsS0FBZ0I7O0FBRXBDO0FBQ0EsVUFBVSxtQkFBTyxDQUFDLEtBQWtCO0FBQ3BDOztBQUVBO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLEtBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxLQUE4QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsS0FBOEI7O0FBRXJEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy9zcmMvc3RhbmRhbG9uZS9pbmRleC5qcz9lMzY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLy8gdGhpcyB3aWxsIGluamVjdCBaZXB0byBpbiB3aW5kb3csIHVuZm9ydHVuYXRlbHkgbm8gZWFzeSBjb21tb25KUyB6ZXB0byBidWlsZFxudmFyIHplcHRvID0gcmVxdWlyZSgnLi4vLi4vemVwdG8uanMnKTtcblxuLy8gc2V0dXAgRE9NIGVsZW1lbnRcbnZhciBET00gPSByZXF1aXJlKCcuLi9jb21tb24vZG9tLmpzJyk7XG5ET00uZWxlbWVudCA9IHplcHRvO1xuXG4vLyBzZXR1cCB1dGlscyBmdW5jdGlvbnNcbnZhciBfID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzLmpzJyk7XG5fLmlzQXJyYXkgPSB6ZXB0by5pc0FycmF5O1xuXy5pc0Z1bmN0aW9uID0gemVwdG8uaXNGdW5jdGlvbjtcbl8uaXNPYmplY3QgPSB6ZXB0by5pc1BsYWluT2JqZWN0O1xuXy5iaW5kID0gemVwdG8ucHJveHk7XG5fLmVhY2ggPSBmdW5jdGlvbihjb2xsZWN0aW9uLCBjYikge1xuICAvLyBzdHVwaWQgYXJndW1lbnQgb3JkZXIgZm9yIGpRdWVyeS5lYWNoXG4gIHplcHRvLmVhY2goY29sbGVjdGlvbiwgcmV2ZXJzZUFyZ3MpO1xuICBmdW5jdGlvbiByZXZlcnNlQXJncyhpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGluZGV4KTtcbiAgfVxufTtcbl8ubWFwID0gemVwdG8ubWFwO1xuXy5taXhpbiA9IHplcHRvLmV4dGVuZDtcbl8uRXZlbnQgPSB6ZXB0by5FdmVudDtcblxudmFyIHR5cGVhaGVhZEtleSA9ICdhYUF1dG9jb21wbGV0ZSc7XG52YXIgVHlwZWFoZWFkID0gcmVxdWlyZSgnLi4vYXV0b2NvbXBsZXRlL3R5cGVhaGVhZC5qcycpO1xudmFyIEV2ZW50QnVzID0gcmVxdWlyZSgnLi4vYXV0b2NvbXBsZXRlL2V2ZW50X2J1cy5qcycpO1xuXG5mdW5jdGlvbiBhdXRvY29tcGxldGUoc2VsZWN0b3IsIG9wdGlvbnMsIGRhdGFzZXRzLCB0eXBlYWhlYWRPYmplY3QpIHtcbiAgZGF0YXNldHMgPSBfLmlzQXJyYXkoZGF0YXNldHMpID8gZGF0YXNldHMgOiBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG5cbiAgdmFyIGlucHV0cyA9IHplcHRvKHNlbGVjdG9yKS5lYWNoKGZ1bmN0aW9uKGksIGlucHV0KSB7XG4gICAgdmFyICRpbnB1dCA9IHplcHRvKGlucHV0KTtcbiAgICB2YXIgZXZlbnRCdXMgPSBuZXcgRXZlbnRCdXMoe2VsOiAkaW5wdXR9KTtcbiAgICB2YXIgdHlwZWFoZWFkID0gdHlwZWFoZWFkT2JqZWN0IHx8IG5ldyBUeXBlYWhlYWQoe1xuICAgICAgaW5wdXQ6ICRpbnB1dCxcbiAgICAgIGV2ZW50QnVzOiBldmVudEJ1cyxcbiAgICAgIGRyb3Bkb3duTWVudUNvbnRhaW5lcjogb3B0aW9ucy5kcm9wZG93bk1lbnVDb250YWluZXIsXG4gICAgICBoaW50OiBvcHRpb25zLmhpbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAhIW9wdGlvbnMuaGludCxcbiAgICAgIG1pbkxlbmd0aDogb3B0aW9ucy5taW5MZW5ndGgsXG4gICAgICBhdXRvc2VsZWN0OiBvcHRpb25zLmF1dG9zZWxlY3QsXG4gICAgICBhdXRvc2VsZWN0T25CbHVyOiBvcHRpb25zLmF1dG9zZWxlY3RPbkJsdXIsXG4gICAgICB0YWJBdXRvY29tcGxldGU6IG9wdGlvbnMudGFiQXV0b2NvbXBsZXRlLFxuICAgICAgb3Blbk9uRm9jdXM6IG9wdGlvbnMub3Blbk9uRm9jdXMsXG4gICAgICB0ZW1wbGF0ZXM6IG9wdGlvbnMudGVtcGxhdGVzLFxuICAgICAgZGVidWc6IG9wdGlvbnMuZGVidWcsXG4gICAgICBjbGVhck9uU2VsZWN0ZWQ6IG9wdGlvbnMuY2xlYXJPblNlbGVjdGVkLFxuICAgICAgY3NzQ2xhc3Nlczogb3B0aW9ucy5jc3NDbGFzc2VzLFxuICAgICAgZGF0YXNldHM6IGRhdGFzZXRzLFxuICAgICAga2V5Ym9hcmRTaG9ydGN1dHM6IG9wdGlvbnMua2V5Ym9hcmRTaG9ydGN1dHMsXG4gICAgICBhcHBlbmRUbzogb3B0aW9ucy5hcHBlbmRUbyxcbiAgICAgIGF1dG9XaWR0aDogb3B0aW9ucy5hdXRvV2lkdGgsXG4gICAgICBhcmlhTGFiZWw6IG9wdGlvbnMuYXJpYUxhYmVsIHx8IGlucHV0LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpXG4gICAgfSk7XG4gICAgJGlucHV0LmRhdGEodHlwZWFoZWFkS2V5LCB0eXBlYWhlYWQpO1xuICB9KTtcblxuICAvLyBleHBvc2UgYWxsIG1ldGhvZHMgaW4gdGhlIGBhdXRvY29tcGxldGVgIGF0dHJpYnV0ZVxuICBpbnB1dHMuYXV0b2NvbXBsZXRlID0ge307XG4gIF8uZWFjaChbJ29wZW4nLCAnY2xvc2UnLCAnZ2V0VmFsJywgJ3NldFZhbCcsICdkZXN0cm95JywgJ2dldFdyYXBwZXInXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgaW5wdXRzLmF1dG9jb21wbGV0ZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWV0aG9kQXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIGlucHV0cy5lYWNoKGZ1bmN0aW9uKGosIGlucHV0KSB7XG4gICAgICAgIHZhciB0eXBlYWhlYWQgPSB6ZXB0byhpbnB1dCkuZGF0YSh0eXBlYWhlYWRLZXkpO1xuICAgICAgICByZXN1bHQgPSB0eXBlYWhlYWRbbWV0aG9kXS5hcHBseSh0eXBlYWhlYWQsIG1ldGhvZEFyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSk7XG5cbiAgcmV0dXJuIGlucHV0cztcbn1cblxuYXV0b2NvbXBsZXRlLnNvdXJjZXMgPSBUeXBlYWhlYWQuc291cmNlcztcbmF1dG9jb21wbGV0ZS5lc2NhcGVIaWdobGlnaHRlZFN0cmluZyA9IF8uZXNjYXBlSGlnaGxpZ2h0ZWRTdHJpbmc7XG5cbnZhciB3YXNBdXRvY29tcGxldGVTZXQgPSAnYXV0b2NvbXBsZXRlJyBpbiB3aW5kb3c7XG52YXIgb2xkQXV0b2NvbXBsZXRlID0gd2luZG93LmF1dG9jb21wbGV0ZTtcbmF1dG9jb21wbGV0ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgaWYgKHdhc0F1dG9jb21wbGV0ZVNldCkge1xuICAgIHdpbmRvdy5hdXRvY29tcGxldGUgPSBvbGRBdXRvY29tcGxldGU7XG4gIH0gZWxzZSB7XG4gICAgZGVsZXRlIHdpbmRvdy5hdXRvY29tcGxldGU7XG4gIH1cbiAgcmV0dXJuIGF1dG9jb21wbGV0ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXV0b2NvbXBsZXRlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///75275\n")},71622:module=>{eval('module.exports = "0.37.1";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE2MjIuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy92ZXJzaW9uLmpzPzM2MzgiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIjAuMzcuMVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///71622\n')},53704:module=>{eval("/* istanbul ignore next */\n/* Zepto v1.2.0 - zepto event assets data - zeptojs.com/license */\n(function(global, factory) {\n  module.exports = factory(global);\n}(/* this ##### UPDATED: here we want to use window/global instead of this which is the current file context ##### */ window, function(window) {\n  var Zepto = (function() {\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\n    document = window.document,\n    elementDisplay = {}, classCache = {},\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\n    fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n    singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n    rootNodeRE = /^(?:body|html)$/i,\n    capitalRE = /([A-Z])/g,\n\n    // special attributes that should be get/set via method calls\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\n    table = document.createElement('table'),\n    tableRow = document.createElement('tr'),\n    containers = {\n      'tr': document.createElement('tbody'),\n      'tbody': table, 'thead': table, 'tfoot': table,\n      'td': tableRow, 'th': tableRow,\n      '*': document.createElement('div')\n    },\n    readyRE = /complete|loaded|interactive/,\n    simpleSelectorRE = /^[\\w-]*$/,\n    class2type = {},\n    toString = class2type.toString,\n    zepto = {},\n    camelize, uniq,\n    tempParent = document.createElement('div'),\n    propMap = {\n      'tabindex': 'tabIndex',\n      'readonly': 'readOnly',\n      'for': 'htmlFor',\n      'class': 'className',\n      'maxlength': 'maxLength',\n      'cellspacing': 'cellSpacing',\n      'cellpadding': 'cellPadding',\n      'rowspan': 'rowSpan',\n      'colspan': 'colSpan',\n      'usemap': 'useMap',\n      'frameborder': 'frameBorder',\n      'contenteditable': 'contentEditable'\n    },\n    isArray = Array.isArray ||\n      function(object){ return object instanceof Array }\n\n  zepto.matches = function(element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\n                          element.mozMatchesSelector || element.oMatchesSelector ||\n                          element.matchesSelector\n    if (matchesSelector) return matchesSelector.call(element, selector)\n    // fall back to performing a selector:\n    var match, parent = element.parentNode, temp = !parent\n    if (temp) (parent = tempParent).appendChild(element)\n    match = ~zepto.qsa(parent, selector).indexOf(element)\n    temp && tempParent.removeChild(element)\n    return match\n  }\n\n  function type(obj) {\n    return obj == null ? String(obj) :\n      class2type[toString.call(obj)] || \"object\"\n  }\n\n  function isFunction(value) { return type(value) == \"function\" }\n  function isWindow(obj)     { return obj != null && obj == obj.window }\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\n  function isObject(obj)     { return type(obj) == \"object\" }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\n  }\n\n  function likeArray(obj) {\n    var length = !!obj && 'length' in obj && obj.length,\n      type = $.type(obj)\n\n    return 'function' != type && !isWindow(obj) && (\n      'array' == type || length === 0 ||\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\n    )\n  }\n\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\n  function dasherize(str) {\n    return str.replace(/::/g, '/')\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\n           .replace(/([a-z\\d])([A-Z])/g, '$1_$2')\n           .replace(/_/g, '-')\n           .toLowerCase()\n  }\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\n\n  function classRE(name) {\n    return name in classCache ?\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'))\n  }\n\n  function maybeAddPx(name, value) {\n    return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName)\n      document.body.appendChild(element)\n      display = getComputedStyle(element, '').getPropertyValue(\"display\")\n      element.parentNode.removeChild(element)\n      display == \"none\" && (display = \"block\")\n      elementDisplay[nodeName] = display\n    }\n    return elementDisplay[nodeName]\n  }\n\n  function children(element) {\n    return 'children' in element ?\n      slice.call(element.children) :\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\n  }\n\n  function Z(dom, selector) {\n    var i, len = dom ? dom.length : 0\n    for (i = 0; i < len; i++) this[i] = dom[i]\n    this.length = len\n    this.selector = selector || ''\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overridden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function(html, name, properties) {\n    var dom, nodes, container\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\")\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\n      if (!(name in containers)) name = '*'\n\n      container = containers[name]\n      container.innerHTML = '' + html\n      dom = $.each(slice.call(container.childNodes), function(){\n        container.removeChild(this)\n      })\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom)\n      $.each(properties, function(key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\n        else nodes.attr(key, value)\n      })\n    }\n\n    return dom\n  }\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. This method can be overridden in plugins.\n  zepto.Z = function(dom, selector) {\n    return new Z(dom, selector)\n  }\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overridden in plugins.\n  zepto.isZ = function(object) {\n    return object instanceof zepto.Z\n  }\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overridden in plugins.\n  zepto.init = function(selector, context) {\n    var dom\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z()\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n      selector = selector.trim()\n      // If it's a html fragment, create nodes from it\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\n      // is thrown if the fragment doesn't begin with <\n      if (selector[0] == '<' && fragmentRE.test(selector))\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // If it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // If a function is given, call it when the DOM is ready\n    else if (isFunction(selector)) return $(document).ready(selector)\n    // If a Zepto collection is given, just return it\n    else if (zepto.isZ(selector)) return selector\n    else {\n      // normalize array if an array of nodes is given\n      if (isArray(selector)) dom = compact(selector)\n      // Wrap DOM nodes.\n      else if (isObject(selector))\n        dom = [selector], selector = null\n      // If it's a html fragment, create nodes from it\n      else if (fragmentRE.test(selector))\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\n      // If there's a context, create a collection on that context first, and select\n      // nodes from there\n      else if (context !== undefined) return $(context).find(selector)\n      // And last but no least, if it's a CSS selector, use it to select nodes.\n      else dom = zepto.qsa(document, selector)\n    }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector)\n  }\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function(selector, context){\n    return zepto.init(selector, context)\n  }\n\n  function extend(target, source, deep) {\n    for (key in source)\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\n          target[key] = {}\n        if (isArray(source[key]) && !isArray(target[key]))\n          target[key] = []\n        extend(target[key], source[key], deep)\n      }\n      else if (source[key] !== undefined) target[key] = source[key]\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function(target){\n    var deep, args = slice.call(arguments, 1)\n    if (typeof target == 'boolean') {\n      deep = target\n      target = args.shift()\n    }\n    args.forEach(function(arg){ extend(target, arg, deep) })\n    return target\n  }\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overridden in plugins.\n  zepto.qsa = function(element, selector){\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\n        isSimple = simpleSelectorRE.test(nameOnly)\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\n      slice.call(\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n          element.getElementsByTagName(selector) : // Or a tag\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n      )\n  }\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\n  }\n\n  $.contains = document.documentElement.contains ?\n    function(parent, node) {\n      return parent !== node && parent.contains(node)\n    } :\n    function(parent, node) {\n      while (node && (node = node.parentNode))\n        if (node === parent) return true\n      return false\n    }\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value){\n    var klass = node.className || '',\n        svg   = klass && klass.baseVal !== undefined\n\n    if (value === undefined) return svg ? klass.baseVal : klass\n    svg ? (klass.baseVal = value) : (node.className = value)\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    try {\n      return value ?\n        value == \"true\" ||\n        ( value == \"false\" ? false :\n          value == \"null\" ? null :\n          +value + \"\" == value ? +value :\n          /^[\\[\\{]/.test(value) ? $.parseJSON(value) :\n          value )\n        : value\n    } catch(e) {\n      return value\n    }\n  }\n\n  $.type = type\n  $.isFunction = isFunction\n  $.isWindow = isWindow\n  $.isArray = isArray\n  $.isPlainObject = isPlainObject\n\n  $.isEmptyObject = function(obj) {\n    var name\n    for (name in obj) return false\n    return true\n  }\n\n  $.isNumeric = function(val) {\n    var num = Number(val), type = typeof val\n    return val != null && type != 'boolean' &&\n      (type != 'string' || val.length) &&\n      !isNaN(num) && isFinite(num) || false\n  }\n\n  $.inArray = function(elem, array, i){\n    return emptyArray.indexOf.call(array, elem, i)\n  }\n\n  $.camelCase = camelize\n  $.trim = function(str) {\n    return str == null ? \"\" : String.prototype.trim.call(str)\n  }\n\n  // plugin compatibility\n  $.uuid = 0\n  $.support = { }\n  $.expr = { }\n  $.noop = function() {}\n\n  $.map = function(elements, callback){\n    var value, values = [], i, key\n    if (likeArray(elements))\n      for (i = 0; i < elements.length; i++) {\n        value = callback(elements[i], i)\n        if (value != null) values.push(value)\n      }\n    else\n      for (key in elements) {\n        value = callback(elements[key], key)\n        if (value != null) values.push(value)\n      }\n    return flatten(values)\n  }\n\n  $.each = function(elements, callback){\n    var i, key\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++)\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\n    } else {\n      for (key in elements)\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\n    }\n\n    return elements\n  }\n\n  $.grep = function(elements, callback){\n    return filter.call(elements, callback)\n  }\n\n  if (window.JSON) $.parseJSON = JSON.parse\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase()\n  })\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    constructor: zepto.Z,\n    length: 0,\n\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    splice: emptyArray.splice,\n    indexOf: emptyArray.indexOf,\n    concat: function(){\n      var i, value, args = []\n      for (i = 0; i < arguments.length; i++) {\n        value = arguments[i]\n        args[i] = zepto.isZ(value) ? value.toArray() : value\n      }\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\n    },\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function(fn){\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\n    },\n    slice: function(){\n      return $(slice.apply(this, arguments))\n    },\n\n    ready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    },\n    get: function(idx){\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\n    },\n    toArray: function(){ return this.get() },\n    size: function(){\n      return this.length\n    },\n    remove: function(){\n      return this.each(function(){\n        if (this.parentNode != null)\n          this.parentNode.removeChild(this)\n      })\n    },\n    each: function(callback){\n      emptyArray.every.call(this, function(el, idx){\n        return callback.call(el, idx, el) !== false\n      })\n      return this\n    },\n    filter: function(selector){\n      if (isFunction(selector)) return this.not(this.not(selector))\n      return $(filter.call(this, function(element){\n        return zepto.matches(element, selector)\n      }))\n    },\n    add: function(selector,context){\n      return $(uniq(this.concat($(selector,context))))\n    },\n    is: function(selector){\n      return this.length > 0 && zepto.matches(this[0], selector)\n    },\n    not: function(selector){\n      var nodes=[]\n      if (isFunction(selector) && selector.call !== undefined)\n        this.each(function(idx){\n          if (!selector.call(this,idx)) nodes.push(this)\n        })\n      else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\n        this.forEach(function(el){\n          if (excludes.indexOf(el) < 0) nodes.push(el)\n        })\n      }\n      return $(nodes)\n    },\n    has: function(selector){\n      return this.filter(function(){\n        return isObject(selector) ?\n          $.contains(this, selector) :\n          $(this).find(selector).size()\n      })\n    },\n    eq: function(idx){\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\n    },\n    first: function(){\n      var el = this[0]\n      return el && !isObject(el) ? el : $(el)\n    },\n    last: function(){\n      var el = this[this.length - 1]\n      return el && !isObject(el) ? el : $(el)\n    },\n    find: function(selector){\n      var result, $this = this\n      if (!selector) result = $()\n      else if (typeof selector == 'object')\n        result = $(selector).filter(function(){\n          var node = this\n          return emptyArray.some.call($this, function(parent){\n            return $.contains(parent, node)\n          })\n        })\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\n      return result\n    },\n    closest: function(selector, context){\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\n      this.each(function(_, node){\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\n          node = node !== context && !isDocument(node) && node.parentNode\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\n      })\n      return $(nodes)\n    },\n    parents: function(selector){\n      var ancestors = [], nodes = this\n      while (nodes.length > 0)\n        nodes = $.map(nodes, function(node){\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node)\n            return node\n          }\n        })\n      return filtered(ancestors, selector)\n    },\n    parent: function(selector){\n      return filtered(uniq(this.pluck('parentNode')), selector)\n    },\n    children: function(selector){\n      return filtered(this.map(function(){ return children(this) }), selector)\n    },\n    contents: function() {\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\n    },\n    siblings: function(selector){\n      return filtered(this.map(function(i, el){\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\n      }), selector)\n    },\n    empty: function(){\n      return this.each(function(){ this.innerHTML = '' })\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function(property){\n      return $.map(this, function(el){ return el[property] })\n    },\n    show: function(){\n      return this.each(function(){\n        this.style.display == \"none\" && (this.style.display = '')\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\")\n          this.style.display = defaultDisplay(this.nodeName)\n      })\n    },\n    replaceWith: function(newContent){\n      return this.before(newContent).remove()\n    },\n    wrap: function(structure){\n      var func = isFunction(structure)\n      if (this[0] && !func)\n        var dom   = $(structure).get(0),\n            clone = dom.parentNode || this.length > 1\n\n      return this.each(function(index){\n        $(this).wrapAll(\n          func ? structure.call(this, index) :\n            clone ? dom.cloneNode(true) : dom\n        )\n      })\n    },\n    wrapAll: function(structure){\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure))\n        var children\n        // drill down to the inmost element\n        while ((children = structure.children()).length) structure = children.first()\n        $(structure).append(this)\n      }\n      return this\n    },\n    wrapInner: function(structure){\n      var func = isFunction(structure)\n      return this.each(function(index){\n        var self = $(this), contents = self.contents(),\n            dom  = func ? structure.call(this, index) : structure\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\n      })\n    },\n    unwrap: function(){\n      this.parent().each(function(){\n        $(this).replaceWith($(this).children())\n      })\n      return this\n    },\n    clone: function(){\n      return this.map(function(){ return this.cloneNode(true) })\n    },\n    hide: function(){\n      return this.css(\"display\", \"none\")\n    },\n    toggle: function(setting){\n      return this.each(function(){\n        var el = $(this)\n        ;(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide()\n      })\n    },\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\n    html: function(html){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var originHtml = this.innerHTML\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\n        }) :\n        (0 in this ? this[0].innerHTML : null)\n    },\n    text: function(text){\n      return 0 in arguments ?\n        this.each(function(idx){\n          var newText = funcArg(this, text, idx, this.textContent)\n          this.textContent = newText == null ? '' : ''+newText\n        }) :\n        (0 in this ? this.pluck('textContent').join(\"\") : null)\n    },\n    attr: function(name, value){\n      var result\n      return (typeof name == 'string' && !(1 in arguments)) ?\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\n        this.each(function(idx){\n          if (this.nodeType !== 1) return\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\n        })\n    },\n    removeAttr: function(name){\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\n        setAttribute(this, attribute)\n      }, this)})\n    },\n    prop: function(name, value){\n      name = propMap[name] || name\n      return (1 in arguments) ?\n        this.each(function(idx){\n          this[name] = funcArg(this, value, idx, this[name])\n        }) :\n        (this[0] && this[0][name])\n    },\n    removeProp: function(name){\n      name = propMap[name] || name\n      return this.each(function(){ delete this[name] })\n    },\n    data: function(name, value){\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\n\n      var data = (1 in arguments) ?\n        this.attr(attrName, value) :\n        this.attr(attrName)\n\n      return data !== null ? deserializeValue(data) : undefined\n    },\n    val: function(value){\n      if (0 in arguments) {\n        if (value == null) value = \"\"\n        return this.each(function(idx){\n          this.value = funcArg(this, value, idx, this.value)\n        })\n      } else {\n        return this[0] && (this[0].multiple ?\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\n           this[0].value)\n      }\n    },\n    offset: function(coordinates){\n      if (coordinates) return this.each(function(index){\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n              top:  coords.top  - parentOffset.top,\n              left: coords.left - parentOffset.left\n            }\n\n        if ($this.css('position') == 'static') props['position'] = 'relative'\n        $this.css(props)\n      })\n      if (!this.length) return null\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\n        return {top: 0, left: 0}\n      var obj = this[0].getBoundingClientRect()\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      }\n    },\n    css: function(property, value){\n      if (arguments.length < 2) {\n        var element = this[0]\n        if (typeof property == 'string') {\n          if (!element) return\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\n        } else if (isArray(property)) {\n          if (!element) return\n          var props = {}\n          var computedStyle = getComputedStyle(element, '')\n          $.each(property, function(_, prop){\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\n          })\n          return props\n        }\n      }\n\n      var css = ''\n      if (type(property) == 'string') {\n        if (!value && value !== 0)\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\n        else\n          css = dasherize(property) + \":\" + maybeAddPx(property, value)\n      } else {\n        for (key in property)\n          if (!property[key] && property[key] !== 0)\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\n          else\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\n      }\n\n      return this.each(function(){ this.style.cssText += ';' + css })\n    },\n    index: function(element){\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\n    },\n    hasClass: function(name){\n      if (!name) return false\n      return emptyArray.some.call(this, function(el){\n        return this.test(className(el))\n      }, classRE(name))\n    },\n    addClass: function(name){\n      if (!name) return this\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        classList = []\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\n        newName.split(/\\s+/g).forEach(function(klass){\n          if (!$(this).hasClass(klass)) classList.push(klass)\n        }, this)\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"))\n      })\n    },\n    removeClass: function(name){\n      return this.each(function(idx){\n        if (!('className' in this)) return\n        if (name === undefined) return className(this, '')\n        classList = className(this)\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function(klass){\n          classList = classList.replace(classRE(klass), \" \")\n        })\n        className(this, classList.trim())\n      })\n    },\n    toggleClass: function(name, when){\n      if (!name) return this\n      return this.each(function(idx){\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\n        names.split(/\\s+/g).forEach(function(klass){\n          (when === undefined ? !$this.hasClass(klass) : when) ?\n            $this.addClass(klass) : $this.removeClass(klass)\n        })\n      })\n    },\n    scrollTop: function(value){\n      if (!this.length) return\n      var hasScrollTop = 'scrollTop' in this[0]\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\n      return this.each(hasScrollTop ?\n        function(){ this.scrollTop = value } :\n        function(){ this.scrollTo(this.scrollX, value) })\n    },\n    scrollLeft: function(value){\n      if (!this.length) return\n      var hasScrollLeft = 'scrollLeft' in this[0]\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\n      return this.each(hasScrollLeft ?\n        function(){ this.scrollLeft = value } :\n        function(){ this.scrollTo(value, this.scrollY) })\n    },\n    position: function() {\n      if (!this.length) return\n\n      var elem = this[0],\n        // Get *real* offsetParent\n        offsetParent = this.offsetParent(),\n        // Get correct offsets\n        offset       = this.offset(),\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\n\n      // Add offsetParent borders\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\n\n      // Subtract the two offsets\n      return {\n        top:  offset.top  - parentOffset.top,\n        left: offset.left - parentOffset.left\n      }\n    },\n    offsetParent: function() {\n      return this.map(function(){\n        var parent = this.offsetParent || document.body\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\")\n          parent = parent.offsetParent\n        return parent\n      })\n    }\n  }\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function(dimension){\n    var dimensionProperty =\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\n\n    $.fn[dimension] = function(value){\n      var offset, el = this[0]\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\n        (offset = this.offset()) && offset[dimension]\n      else return this.each(function(idx){\n        el = $(this)\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\n      })\n    }\n  })\n\n  function traverseNode(node, fun) {\n    fun(node)\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\n      traverseNode(node.childNodes[i], fun)\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\n    var inside = operatorIndex % 2 //=> prepend, append\n\n    $.fn[operator] = function(){\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType, nodes = $.map(arguments, function(arg) {\n            var arr = []\n            argType = type(arg)\n            if (argType == \"array\") {\n              arg.forEach(function(el) {\n                if (el.nodeType !== undefined) return arr.push(el)\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\n                arr = arr.concat(zepto.fragment(el))\n              })\n              return arr\n            }\n            return argType == \"object\" || arg == null ?\n              arg : zepto.fragment(arg)\n          }),\n          parent, copyByClone = this.length > 1\n      if (nodes.length < 1) return this\n\n      return this.each(function(_, target){\n        parent = inside ? target : target.parentNode\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling :\n                 operatorIndex == 1 ? target.firstChild :\n                 operatorIndex == 2 ? target :\n                 null\n\n        var parentInDocument = $.contains(document.documentElement, parent)\n\n        nodes.forEach(function(node){\n          if (copyByClone) node = node.cloneNode(true)\n          else if (!parent) return $(node).remove()\n\n          parent.insertBefore(node, target)\n          if (parentInDocument) traverseNode(node, function(el){\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\n               (!el.type || el.type === 'text/javascript') && !el.src){\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\n              target['eval'].call(target, el.innerHTML)\n            }\n          })\n        })\n      })\n    }\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\n      $(html)[operator](this)\n      return this\n    }\n  })\n\n  zepto.Z.prototype = Z.prototype = $.fn\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq\n  zepto.deserializeValue = deserializeValue\n  $.zepto = zepto\n\n  return $\n})()\n\n;(function($){\n  var _zid = 1, undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function(obj){ return typeof obj == 'string' },\n      handlers = {},\n      specialEvents={},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++)\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event)\n    if (event.ns) var matcher = matcherFor(event.ns)\n    return (handlers[zid(element)] || []).filter(function(handler) {\n      return handler\n        && (!event.e  || handler.e == event.e)\n        && (!event.ns || matcher.test(handler.ns))\n        && (!fn       || zid(handler.fn) === zid(fn))\n        && (!selector || handler.sel == selector)\n    })\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.')\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del &&\n      (!focusinSupported && (handler.e in focus)) ||\n      !!captureSetting\n  }\n\n  function realEvent(type) {\n    return hover[type] || (focusinSupported && focus[type]) || type\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture){\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\n    events.split(/\\s/).forEach(function(event){\n      if (event == 'ready') return $(document).ready(fn)\n      var handler   = parse(event)\n      handler.fn    = fn\n      handler.sel   = selector\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function(e){\n        var related = e.relatedTarget\n        if (!related || (related !== this && !$.contains(this, related)))\n          return handler.fn.apply(this, arguments)\n      }\n      handler.del   = delegator\n      var callback  = delegator || fn\n      handler.proxy = function(e){\n        e = compatible(e)\n        if (e.isImmediatePropagationStopped()) return\n        try {\n          var dataPropDescriptor = Object.getOwnPropertyDescriptor(e, 'data')\n          if (!dataPropDescriptor || dataPropDescriptor.writable)\n            e.data = data\n        } catch (e) {} // when using strict mode dataPropDescriptor will be undefined when e is InputEvent (even though data property exists). So we surround with try/catch\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\n        if (result === false) e.preventDefault(), e.stopPropagation()\n        return result\n      }\n      handler.i = set.length\n      set.push(handler)\n      if ('addEventListener' in element)\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n    })\n  }\n  function remove(element, events, fn, selector, capture){\n    var id = zid(element)\n    ;(events || '').split(/\\s/).forEach(function(event){\n      findHandlers(element, event, fn, selector).forEach(function(handler){\n        delete handlers[id][handler.i]\n      if ('removeEventListener' in element)\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\n      })\n    })\n  }\n\n  $.event = { add: add, remove: remove }\n\n  $.proxy = function(fn, context) {\n    var args = (2 in arguments) && slice.call(arguments, 2)\n    if (isFunction(fn)) {\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\n      proxyFn._zid = zid(fn)\n      return proxyFn\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn)\n        return $.proxy.apply(null, args)\n      } else {\n        return $.proxy(fn[context], fn)\n      }\n    } else {\n      throw new TypeError(\"expected function\")\n    }\n  }\n\n  $.fn.bind = function(event, data, callback){\n    return this.on(event, data, callback)\n  }\n  $.fn.unbind = function(event, callback){\n    return this.off(event, callback)\n  }\n  $.fn.one = function(event, selector, data, callback){\n    return this.on(event, selector, data, callback, 1)\n  }\n\n  var returnTrue = function(){return true},\n      returnFalse = function(){return false},\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\n      eventMethods = {\n        preventDefault: 'isDefaultPrevented',\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\n        stopPropagation: 'isPropagationStopped'\n      }\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event)\n\n      $.each(eventMethods, function(name, predicate) {\n        var sourceMethod = source[name]\n        event[name] = function(){\n          this[predicate] = returnTrue\n          return sourceMethod && sourceMethod.apply(source, arguments)\n        }\n        event[predicate] = returnFalse\n      })\n\n      try {\n        event.timeStamp || (event.timeStamp = Date.now())\n      } catch (ignored) { }\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\n          'returnValue' in source ? source.returnValue === false :\n          source.getPreventDefault && source.getPreventDefault())\n        event.isDefaultPrevented = returnTrue\n    }\n    return event\n  }\n\n  function createProxy(event) {\n    var key, proxy = { originalEvent: event }\n    for (key in event)\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\n\n    return compatible(proxy, event)\n  }\n\n  $.fn.delegate = function(selector, event, callback){\n    return this.on(event, selector, callback)\n  }\n  $.fn.undelegate = function(selector, event, callback){\n    return this.off(event, selector, callback)\n  }\n\n  $.fn.live = function(event, callback){\n    $(document.body).delegate(this.selector, event, callback)\n    return this\n  }\n  $.fn.die = function(event, callback){\n    $(document.body).undelegate(this.selector, event, callback)\n    return this\n  }\n\n  $.fn.on = function(event, selector, data, callback, one){\n    var autoRemove, delegator, $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.on(type, selector, data, fn, one)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = data, data = selector, selector = undefined\n    if (callback === undefined || data === false)\n      callback = data, data = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(_, element){\n      if (one) autoRemove = function(e){\n        remove(element, e.type, callback)\n        return callback.apply(this, arguments)\n      }\n\n      if (selector) delegator = function(e){\n        var evt, match = $(e.target).closest(selector, element).get(0)\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\n        }\n      }\n\n      add(element, event, callback, data, selector, delegator || autoRemove)\n    })\n  }\n  $.fn.off = function(event, selector, callback){\n    var $this = this\n    if (event && !isString(event)) {\n      $.each(event, function(type, fn){\n        $this.off(type, selector, fn)\n      })\n      return $this\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\n      callback = selector, selector = undefined\n\n    if (callback === false) callback = returnFalse\n\n    return $this.each(function(){\n      remove(this, event, callback, selector)\n    })\n  }\n\n  $.fn.trigger = function(event, args){\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\n    event._args = args\n    return this.each(function(){\n      // handle focus(), blur() by calling them directly\n      if (event.type in focus && typeof this[event.type] == \"function\") this[event.type]()\n      // items in the collection might not be DOM elements\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\n      else $(this).triggerHandler(event, args)\n    })\n  }\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function(event, args){\n    var e, result\n    this.each(function(i, element){\n      e = createProxy(isString(event) ? $.Event(event) : event)\n      e._args = args\n      e.target = element\n      $.each(findHandlers(element, event.type || event), function(i, handler){\n        result = handler.proxy(e)\n        if (e.isImmediatePropagationStopped()) return false\n      })\n    })\n    return result\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\n    $.fn[event] = function(callback) {\n      return (0 in arguments) ?\n        this.bind(event, callback) :\n        this.trigger(event)\n    }\n  })\n\n  $.Event = function(type, props) {\n    if (!isString(type)) props = type, type = props.type\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\n    event.initEvent(type, bubbles, true)\n    return compatible(event)\n  }\n\n})(Zepto)\n\n;(function($){\n  var cache = [], timeout\n\n  $.fn.remove = function(){\n    return this.each(function(){\n      if(this.parentNode){\n        if(this.tagName === 'IMG'){\n          cache.push(this)\n          this.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='\n          if (timeout) clearTimeout(timeout)\n          timeout = setTimeout(function(){ cache = [] }, 60000)\n        }\n        this.parentNode.removeChild(this)\n      }\n    })\n  }\n})(Zepto)\n\n;(function($){\n  var data = {}, dataAttr = $.fn.data, camelize = $.camelCase,\n    exp = $.expando = 'Zepto' + (+new Date()), emptyArray = []\n\n  // Get value from node:\n  // 1. first try key as given,\n  // 2. then try camelized key,\n  // 3. fall back to reading \"data-*\" attribute.\n  function getData(node, name) {\n    var id = node[exp], store = id && data[id]\n    if (name === undefined) return store || setData(node)\n    else {\n      if (store) {\n        if (name in store) return store[name]\n        var camelName = camelize(name)\n        if (camelName in store) return store[camelName]\n      }\n      return dataAttr.call($(node), name)\n    }\n  }\n\n  // Store value under camelized key on node\n  function setData(node, name, value) {\n    var id = node[exp] || (node[exp] = ++$.uuid),\n      store = data[id] || (data[id] = attributeData(node))\n    if (name !== undefined) store[camelize(name)] = value\n    return store\n  }\n\n  // Read all \"data-*\" attributes from a node\n  function attributeData(node) {\n    var store = {}\n    $.each(node.attributes || emptyArray, function(i, attr){\n      if (attr.name.indexOf('data-') == 0)\n        store[camelize(attr.name.replace('data-', ''))] =\n          $.zepto.deserializeValue(attr.value)\n    })\n    return store\n  }\n\n  $.fn.data = function(name, value) {\n    return value === undefined ?\n      // set multiple values via object\n      $.isPlainObject(name) ?\n        this.each(function(i, node){\n          $.each(name, function(key, value){ setData(node, key, value) })\n        }) :\n        // get value from first element\n        (0 in this ? getData(this[0], name) : undefined) :\n      // set value on all elements\n      this.each(function(){ setData(this, name, value) })\n  }\n\n  $.data = function(elem, name, value) {\n    return $(elem).data(name, value)\n  }\n\n  $.hasData = function(elem) {\n    var id = elem[exp], store = id && data[id]\n    return store ? !$.isEmptyObject(store) : false\n  }\n\n  $.fn.removeData = function(names) {\n    if (typeof names == 'string') names = names.split(/\\s+/)\n    return this.each(function(){\n      var id = this[exp], store = id && data[id]\n      if (store) $.each(names || store, function(key){\n        delete store[names ? camelize(this) : key]\n      })\n    })\n  }\n\n  // Generate extended `remove` and `empty` functions\n  ;['remove', 'empty'].forEach(function(methodName){\n    var origFn = $.fn[methodName]\n    $.fn[methodName] = function() {\n      var elements = this.find('*')\n      if (methodName === 'remove') elements = elements.add(this)\n      elements.removeData()\n      return origFn.call(this)\n    }\n  })\n})(Zepto)\n  return Zepto\n}))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTM3MDQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QyxrQkFBa0IsMkdBQTJHO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwwQ0FBMEMscUJBQXFCO0FBQzNGLDRCQUE0QjtBQUM1Qiw0QkFBNEIsb0RBQW9ELHFDQUFxQztBQUNySDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBK0MsbUNBQW1DOztBQUU1RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQ0FBcUM7QUFDckY7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyQkFBMkI7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkJBQTJCO0FBQ3ZFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxhQUFhO0FBQ2xGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSx5Q0FBeUMsa0NBQWtDO0FBQzNFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFLEtBQUs7QUFDTDtBQUNBLG1DQUFtQyw0REFBNEQ7QUFDL0YsS0FBSztBQUNMO0FBQ0E7QUFDQSxxRUFBcUUsbUJBQW1CO0FBQ3hGLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUNBQXVDLHFCQUFxQjtBQUM1RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLGtDQUFrQyw2QkFBNkI7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsOEJBQThCLHdFQUF3RTtBQUN0Ryw4QkFBOEIsb0VBQW9FO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLG1DQUFtQztBQUNuQztBQUNBLE9BQU8sUUFBUTtBQUNmLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3RELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUU7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0RBQWdEO0FBQ2hGO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGtDQUFrQywyQ0FBMkM7QUFDN0U7QUFDQSw2RUFBNkU7QUFDN0U7O0FBRUEsbUNBQW1DLHdCQUF3QixTQUFTO0FBQ3BFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxvQkFBb0Isb0NBQW9DO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QyxvQkFBb0Isb0NBQW9DO0FBQ3hELEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsa0JBQWtCOztBQUV2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEMsMkJBQTJCOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0Esa0RBQWtELFNBQVM7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrQkFBK0I7QUFDL0QsbUJBQW1CO0FBQ25CLHNCQUFzQjtBQUN0QjtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQsZ0JBQWdCOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxhQUFhO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLFlBQVk7QUFDMUMsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx5Q0FBeUM7QUFDbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQsQ0FBQztBQUNELGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsMkJBQTJCO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2F1dG9jb21wbGV0ZS5qcy96ZXB0by5qcz8zYjlkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4vKiBaZXB0byB2MS4yLjAgLSB6ZXB0byBldmVudCBhc3NldHMgZGF0YSAtIHplcHRvanMuY29tL2xpY2Vuc2UgKi9cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbCk7XG59KC8qIHRoaXMgIyMjIyMgVVBEQVRFRDogaGVyZSB3ZSB3YW50IHRvIHVzZSB3aW5kb3cvZ2xvYmFsIGluc3RlYWQgb2YgdGhpcyB3aGljaCBpcyB0aGUgY3VycmVudCBmaWxlIGNvbnRleHQgIyMjIyMgKi8gd2luZG93LCBmdW5jdGlvbih3aW5kb3cpIHtcbiAgdmFyIFplcHRvID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBjb25jYXQgPSBlbXB0eUFycmF5LmNvbmNhdCwgZmlsdGVyID0gZW1wdHlBcnJheS5maWx0ZXIsIHNsaWNlID0gZW1wdHlBcnJheS5zbGljZSxcbiAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcbiAgICBlbGVtZW50RGlzcGxheSA9IHt9LCBjbGFzc0NhY2hlID0ge30sXG4gICAgY3NzTnVtYmVyID0geyAnY29sdW1uLWNvdW50JzogMSwgJ2NvbHVtbnMnOiAxLCAnZm9udC13ZWlnaHQnOiAxLCAnbGluZS1oZWlnaHQnOiAxLCdvcGFjaXR5JzogMSwgJ3otaW5kZXgnOiAxLCAnem9vbSc6IDEgfSxcbiAgICBmcmFnbWVudFJFID0gL15cXHMqPChcXHcrfCEpW14+XSo+LyxcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcbiAgICB0YWdFeHBhbmRlclJFID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnLFxuICAgIHJvb3ROb2RlUkUgPSAvXig/OmJvZHl8aHRtbCkkL2ksXG4gICAgY2FwaXRhbFJFID0gLyhbQS1aXSkvZyxcblxuICAgIC8vIHNwZWNpYWwgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBiZSBnZXQvc2V0IHZpYSBtZXRob2QgY2FsbHNcbiAgICBtZXRob2RBdHRyaWJ1dGVzID0gWyd2YWwnLCAnY3NzJywgJ2h0bWwnLCAndGV4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdvZmZzZXQnXSxcblxuICAgIGFkamFjZW5jeU9wZXJhdG9ycyA9IFsgJ2FmdGVyJywgJ3ByZXBlbmQnLCAnYmVmb3JlJywgJ2FwcGVuZCcgXSxcbiAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyksXG4gICAgdGFibGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpLFxuICAgIGNvbnRhaW5lcnMgPSB7XG4gICAgICAndHInOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxuICAgICAgJ3Rib2R5JzogdGFibGUsICd0aGVhZCc6IHRhYmxlLCAndGZvb3QnOiB0YWJsZSxcbiAgICAgICd0ZCc6IHRhYmxlUm93LCAndGgnOiB0YWJsZVJvdyxcbiAgICAgICcqJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9LFxuICAgIHJlYWR5UkUgPSAvY29tcGxldGV8bG9hZGVkfGludGVyYWN0aXZlLyxcbiAgICBzaW1wbGVTZWxlY3RvclJFID0gL15bXFx3LV0qJC8sXG4gICAgY2xhc3MydHlwZSA9IHt9LFxuICAgIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZyxcbiAgICB6ZXB0byA9IHt9LFxuICAgIGNhbWVsaXplLCB1bmlxLFxuICAgIHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICBwcm9wTWFwID0ge1xuICAgICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4JyxcbiAgICAgICdyZWFkb25seSc6ICdyZWFkT25seScsXG4gICAgICAnZm9yJzogJ2h0bWxGb3InLFxuICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gICAgICAnbWF4bGVuZ3RoJzogJ21heExlbmd0aCcsXG4gICAgICAnY2VsbHNwYWNpbmcnOiAnY2VsbFNwYWNpbmcnLFxuICAgICAgJ2NlbGxwYWRkaW5nJzogJ2NlbGxQYWRkaW5nJyxcbiAgICAgICdyb3dzcGFuJzogJ3Jvd1NwYW4nLFxuICAgICAgJ2NvbHNwYW4nOiAnY29sU3BhbicsXG4gICAgICAndXNlbWFwJzogJ3VzZU1hcCcsXG4gICAgICAnZnJhbWVib3JkZXInOiAnZnJhbWVCb3JkZXInLFxuICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnXG4gICAgfSxcbiAgICBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fFxuICAgICAgZnVuY3Rpb24ob2JqZWN0KXsgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5IH1cblxuICB6ZXB0by5tYXRjaGVzID0gZnVuY3Rpb24oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yIHx8ICFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZVxuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBlbGVtZW50Lm1hdGNoZXMgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yXG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKVxuICAgIC8vIGZhbGwgYmFjayB0byBwZXJmb3JtaW5nIGEgc2VsZWN0b3I6XG4gICAgdmFyIG1hdGNoLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsIHRlbXAgPSAhcGFyZW50XG4gICAgaWYgKHRlbXApIChwYXJlbnQgPSB0ZW1wUGFyZW50KS5hcHBlbmRDaGlsZChlbGVtZW50KVxuICAgIG1hdGNoID0gfnplcHRvLnFzYShwYXJlbnQsIHNlbGVjdG9yKS5pbmRleE9mKGVsZW1lbnQpXG4gICAgdGVtcCAmJiB0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpXG4gICAgcmV0dXJuIG1hdGNoXG4gIH1cblxuICBmdW5jdGlvbiB0eXBlKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IFN0cmluZyhvYmopIDpcbiAgICAgIGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiXG4gIH1cblxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlKHZhbHVlKSA9PSBcImZ1bmN0aW9uXCIgfVxuICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopICAgICB7IHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT0gb2JqLndpbmRvdyB9XG4gIGZ1bmN0aW9uIGlzRG9jdW1lbnQob2JqKSAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5ub2RlVHlwZSA9PSBvYmouRE9DVU1FTlRfTk9ERSB9XG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgICAgIHsgcmV0dXJuIHR5cGUob2JqKSA9PSBcIm9iamVjdFwiIH1cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gaXNPYmplY3Qob2JqKSAmJiAhaXNXaW5kb3cob2JqKSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PSBPYmplY3QucHJvdG90eXBlXG4gIH1cblxuICBmdW5jdGlvbiBsaWtlQXJyYXkob2JqKSB7XG4gICAgdmFyIGxlbmd0aCA9ICEhb2JqICYmICdsZW5ndGgnIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuICAgICAgdHlwZSA9ICQudHlwZShvYmopXG5cbiAgICByZXR1cm4gJ2Z1bmN0aW9uJyAhPSB0eXBlICYmICFpc1dpbmRvdyhvYmopICYmIChcbiAgICAgICdhcnJheScgPT0gdHlwZSB8fCBsZW5ndGggPT09IDAgfHxcbiAgICAgICAgKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID4gMCAmJiAobGVuZ3RoIC0gMSkgaW4gb2JqKVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0gIT0gbnVsbCB9KSB9XG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHsgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDAgPyAkLmZuLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpIDogYXJyYXkgfVxuICBjYW1lbGl6ZSA9IGZ1bmN0aW9uKHN0cil7IHJldHVybiBzdHIucmVwbGFjZSgvLSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjaHIpeyByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJyB9KSB9XG4gIGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzo6L2csICcvJylcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbQS1aXSspKFtBLVpdW2Etel0pL2csICckMV8kMicpXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKVxuICAgICAgICAgICAucmVwbGFjZSgvXy9nLCAnLScpXG4gICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgdW5pcSA9IGZ1bmN0aW9uKGFycmF5KXsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtLCBpZHgpeyByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSA9PSBpZHggfSkgfVxuXG4gIGZ1bmN0aW9uIGNsYXNzUkUobmFtZSkge1xuICAgIHJldHVybiBuYW1lIGluIGNsYXNzQ2FjaGUgP1xuICAgICAgY2xhc3NDYWNoZVtuYW1lXSA6IChjbGFzc0NhY2hlW25hbWVdID0gbmV3IFJlZ0V4cCgnKF58XFxcXHMpJyArIG5hbWUgKyAnKFxcXFxzfCQpJykpXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUFkZFB4KG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0pID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkobm9kZU5hbWUpIHtcbiAgICB2YXIgZWxlbWVudCwgZGlzcGxheVxuICAgIGlmICghZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdKSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudClcbiAgICAgIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKVxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpXG4gICAgICBkaXNwbGF5ID09IFwibm9uZVwiICYmIChkaXNwbGF5ID0gXCJibG9ja1wiKVxuICAgICAgZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdID0gZGlzcGxheVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XG4gICAgcmV0dXJuICdjaGlsZHJlbicgaW4gZWxlbWVudCA/XG4gICAgICBzbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pIDpcbiAgICAgICQubWFwKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSl7IGlmIChub2RlLm5vZGVUeXBlID09IDEpIHJldHVybiBub2RlIH0pXG4gIH1cblxuICBmdW5jdGlvbiBaKGRvbSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgaSwgbGVuID0gZG9tID8gZG9tLmxlbmd0aCA6IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHRoaXNbaV0gPSBkb21baV1cbiAgICB0aGlzLmxlbmd0aCA9IGxlblxuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xuICB9XG5cbiAgLy8gYCQuemVwdG8uZnJhZ21lbnRgIHRha2VzIGEgaHRtbCBzdHJpbmcgYW5kIGFuIG9wdGlvbmFsIHRhZyBuYW1lXG4gIC8vIHRvIGdlbmVyYXRlIERPTSBub2RlcyBmcm9tIHRoZSBnaXZlbiBodG1sIHN0cmluZy5cbiAgLy8gVGhlIGdlbmVyYXRlZCBET00gbm9kZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5LlxuICAvLyBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMgZm9yIGV4YW1wbGUgdG8gbWFrZVxuICAvLyBpdCBjb21wYXRpYmxlIHdpdGggYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBET00gZnVsbHkuXG4gIHplcHRvLmZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCwgbmFtZSwgcHJvcGVydGllcykge1xuICAgIHZhciBkb20sIG5vZGVzLCBjb250YWluZXJcblxuICAgIC8vIEEgc3BlY2lhbCBjYXNlIG9wdGltaXphdGlvbiBmb3IgYSBzaW5nbGUgdGFnXG4gICAgaWYgKHNpbmdsZVRhZ1JFLnRlc3QoaHRtbCkpIGRvbSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKVxuXG4gICAgaWYgKCFkb20pIHtcbiAgICAgIGlmIChodG1sLnJlcGxhY2UpIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnRXhwYW5kZXJSRSwgXCI8JDE+PC8kMj5cIilcbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBmcmFnbWVudFJFLnRlc3QoaHRtbCkgJiYgUmVnRXhwLiQxXG4gICAgICBpZiAoIShuYW1lIGluIGNvbnRhaW5lcnMpKSBuYW1lID0gJyonXG5cbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNbbmFtZV1cbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAnJyArIGh0bWxcbiAgICAgIGRvbSA9ICQuZWFjaChzbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzKSwgZnVuY3Rpb24oKXtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpc1BsYWluT2JqZWN0KHByb3BlcnRpZXMpKSB7XG4gICAgICBub2RlcyA9ICQoZG9tKVxuICAgICAgJC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZEF0dHJpYnV0ZXMuaW5kZXhPZihrZXkpID4gLTEpIG5vZGVzW2tleV0odmFsdWUpXG4gICAgICAgIGVsc2Ugbm9kZXMuYXR0cihrZXksIHZhbHVlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvLyBgJC56ZXB0by5aYCBzd2FwcyBvdXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgZ2l2ZW4gYGRvbWAgYXJyYXlcbiAgLy8gb2Ygbm9kZXMgd2l0aCBgJC5mbmAgYW5kIHRodXMgc3VwcGx5aW5nIGFsbCB0aGUgWmVwdG8gZnVuY3Rpb25zXG4gIC8vIHRvIHRoZSBhcnJheS4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cbiAgemVwdG8uWiA9IGZ1bmN0aW9uKGRvbSwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gbmV3IFooZG9tLCBzZWxlY3RvcilcbiAgfVxuXG4gIC8vIGAkLnplcHRvLmlzWmAgc2hvdWxkIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhIFplcHRvXG4gIC8vIGNvbGxlY3Rpb24uIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXG4gIHplcHRvLmlzWiA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB6ZXB0by5aXG4gIH1cblxuICAvLyBgJC56ZXB0by5pbml0YCBpcyBaZXB0bydzIGNvdW50ZXJwYXJ0IHRvIGpRdWVyeSdzIGAkLmZuLmluaXRgIGFuZFxuICAvLyB0YWtlcyBhIENTUyBzZWxlY3RvciBhbmQgYW4gb3B0aW9uYWwgY29udGV4dCAoYW5kIGhhbmRsZXMgdmFyaW91c1xuICAvLyBzcGVjaWFsIGNhc2VzKS5cbiAgLy8gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cbiAgemVwdG8uaW5pdCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGRvbVxuICAgIC8vIElmIG5vdGhpbmcgZ2l2ZW4sIHJldHVybiBhbiBlbXB0eSBaZXB0byBjb2xsZWN0aW9uXG4gICAgaWYgKCFzZWxlY3RvcikgcmV0dXJuIHplcHRvLlooKVxuICAgIC8vIE9wdGltaXplIGZvciBzdHJpbmcgc2VsZWN0b3JzXG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKVxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XG4gICAgICAvLyBOb3RlOiBJbiBib3RoIENocm9tZSAyMSBhbmQgRmlyZWZveCAxNSwgRE9NIGVycm9yIDEyXG4gICAgICAvLyBpcyB0aHJvd24gaWYgdGhlIGZyYWdtZW50IGRvZXNuJ3QgYmVnaW4gd2l0aCA8XG4gICAgICBpZiAoc2VsZWN0b3JbMF0gPT0gJzwnICYmIGZyYWdtZW50UkUudGVzdChzZWxlY3RvcikpXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb250ZXh0LCBjcmVhdGUgYSBjb2xsZWN0aW9uIG9uIHRoYXQgY29udGV4dCBmaXJzdCwgYW5kIHNlbGVjdFxuICAgICAgLy8gbm9kZXMgZnJvbSB0aGVyZVxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxuICAgICAgLy8gSWYgaXQncyBhIENTUyBzZWxlY3RvciwgdXNlIGl0IHRvIHNlbGVjdCBub2Rlcy5cbiAgICAgIGVsc2UgZG9tID0gemVwdG8ucXNhKGRvY3VtZW50LCBzZWxlY3RvcilcbiAgICB9XG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBnaXZlbiwgY2FsbCBpdCB3aGVuIHRoZSBET00gaXMgcmVhZHlcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuICQoZG9jdW1lbnQpLnJlYWR5KHNlbGVjdG9yKVxuICAgIC8vIElmIGEgWmVwdG8gY29sbGVjdGlvbiBpcyBnaXZlbiwganVzdCByZXR1cm4gaXRcbiAgICBlbHNlIGlmICh6ZXB0by5pc1ooc2VsZWN0b3IpKSByZXR1cm4gc2VsZWN0b3JcbiAgICBlbHNlIHtcbiAgICAgIC8vIG5vcm1hbGl6ZSBhcnJheSBpZiBhbiBhcnJheSBvZiBub2RlcyBpcyBnaXZlblxuICAgICAgaWYgKGlzQXJyYXkoc2VsZWN0b3IpKSBkb20gPSBjb21wYWN0KHNlbGVjdG9yKVxuICAgICAgLy8gV3JhcCBET00gbm9kZXMuXG4gICAgICBlbHNlIGlmIChpc09iamVjdChzZWxlY3RvcikpXG4gICAgICAgIGRvbSA9IFtzZWxlY3Rvcl0sIHNlbGVjdG9yID0gbnVsbFxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XG4gICAgICBlbHNlIGlmIChmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxuICAgICAgICBkb20gPSB6ZXB0by5mcmFnbWVudChzZWxlY3Rvci50cmltKCksIFJlZ0V4cC4kMSwgY29udGV4dCksIHNlbGVjdG9yID0gbnVsbFxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXG4gICAgICBlbHNlIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQpIHJldHVybiAkKGNvbnRleHQpLmZpbmQoc2VsZWN0b3IpXG4gICAgICAvLyBBbmQgbGFzdCBidXQgbm8gbGVhc3QsIGlmIGl0J3MgYSBDU1Mgc2VsZWN0b3IsIHVzZSBpdCB0byBzZWxlY3Qgbm9kZXMuXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIG5ldyBaZXB0byBjb2xsZWN0aW9uIGZyb20gdGhlIG5vZGVzIGZvdW5kXG4gICAgcmV0dXJuIHplcHRvLlooZG9tLCBzZWxlY3RvcilcbiAgfVxuXG4gIC8vIGAkYCB3aWxsIGJlIHRoZSBiYXNlIGBaZXB0b2Agb2JqZWN0LiBXaGVuIGNhbGxpbmcgdGhpc1xuICAvLyBmdW5jdGlvbiBqdXN0IGNhbGwgYCQuemVwdG8uaW5pdCwgd2hpY2ggbWFrZXMgdGhlIGltcGxlbWVudGF0aW9uXG4gIC8vIGRldGFpbHMgb2Ygc2VsZWN0aW5nIG5vZGVzIGFuZCBjcmVhdGluZyBaZXB0byBjb2xsZWN0aW9uc1xuICAvLyBwYXRjaGFibGUgaW4gcGx1Z2lucy5cbiAgJCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBjb250ZXh0KXtcbiAgICByZXR1cm4gemVwdG8uaW5pdChzZWxlY3RvciwgY29udGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xuICAgIGZvciAoa2V5IGluIHNvdXJjZSlcbiAgICAgIGlmIChkZWVwICYmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSB8fCBpc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmICFpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSlcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9XG4gICAgICAgIGlmIChpc0FycmF5KHNvdXJjZVtrZXldKSAmJiAhaXNBcnJheSh0YXJnZXRba2V5XSkpXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXVxuICAgICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICB9XG5cbiAgLy8gQ29weSBhbGwgYnV0IHVuZGVmaW5lZCBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmVcbiAgLy8gb2JqZWN0cyB0byB0aGUgYHRhcmdldGAgb2JqZWN0LlxuICAkLmV4dGVuZCA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIGRlZXAsIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcbiAgICAgIGRlZXAgPSB0YXJnZXRcbiAgICAgIHRhcmdldCA9IGFyZ3Muc2hpZnQoKVxuICAgIH1cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKXsgZXh0ZW5kKHRhcmdldCwgYXJnLCBkZWVwKSB9KVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8vIGAkLnplcHRvLnFzYWAgaXMgWmVwdG8ncyBDU1Mgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24gd2hpY2hcbiAgLy8gdXNlcyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGAgYW5kIG9wdGltaXplcyBmb3Igc29tZSBzcGVjaWFsIGNhc2VzLCBsaWtlIGAjaWRgLlxuICAvLyBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxuICB6ZXB0by5xc2EgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcil7XG4gICAgdmFyIGZvdW5kLFxuICAgICAgICBtYXliZUlEID0gc2VsZWN0b3JbMF0gPT0gJyMnLFxuICAgICAgICBtYXliZUNsYXNzID0gIW1heWJlSUQgJiYgc2VsZWN0b3JbMF0gPT0gJy4nLFxuICAgICAgICBuYW1lT25seSA9IG1heWJlSUQgfHwgbWF5YmVDbGFzcyA/IHNlbGVjdG9yLnNsaWNlKDEpIDogc2VsZWN0b3IsIC8vIEVuc3VyZSB0aGF0IGEgMSBjaGFyIHRhZyBuYW1lIHN0aWxsIGdldHMgY2hlY2tlZFxuICAgICAgICBpc1NpbXBsZSA9IHNpbXBsZVNlbGVjdG9yUkUudGVzdChuYW1lT25seSlcbiAgICByZXR1cm4gKGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQgJiYgaXNTaW1wbGUgJiYgbWF5YmVJRCkgPyAvLyBTYWZhcmkgRG9jdW1lbnRGcmFnbWVudCBkb2Vzbid0IGhhdmUgZ2V0RWxlbWVudEJ5SWRcbiAgICAgICggKGZvdW5kID0gZWxlbWVudC5nZXRFbGVtZW50QnlJZChuYW1lT25seSkpID8gW2ZvdW5kXSA6IFtdICkgOlxuICAgICAgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSAxMSkgPyBbXSA6XG4gICAgICBzbGljZS5jYWxsKFxuICAgICAgICBpc1NpbXBsZSAmJiAhbWF5YmVJRCAmJiBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPyAvLyBEb2N1bWVudEZyYWdtZW50IGRvZXNuJ3QgaGF2ZSBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lL1RhZ05hbWVcbiAgICAgICAgICBtYXliZUNsYXNzID8gZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKG5hbWVPbmx5KSA6IC8vIElmIGl0J3Mgc2ltcGxlLCBpdCBjb3VsZCBiZSBhIGNsYXNzXG4gICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikgOiAvLyBPciBhIHRhZ1xuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgLy8gT3IgaXQncyBub3Qgc2ltcGxlLCBhbmQgd2UgbmVlZCB0byBxdWVyeSBhbGxcbiAgICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbHRlcmVkKG5vZGVzLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gJChub2RlcykgOiAkKG5vZGVzKS5maWx0ZXIoc2VsZWN0b3IpXG4gIH1cblxuICAkLmNvbnRhaW5zID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zID9cbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcbiAgICAgIHJldHVybiBwYXJlbnQgIT09IG5vZGUgJiYgcGFyZW50LmNvbnRhaW5zKG5vZGUpXG4gICAgfSA6XG4gICAgZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XG4gICAgICB3aGlsZSAobm9kZSAmJiAobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpXG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgZnVuY3Rpb24gZnVuY0FyZyhjb250ZXh0LCBhcmcsIGlkeCwgcGF5bG9hZCkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZykgPyBhcmcuY2FsbChjb250ZXh0LCBpZHgsIHBheWxvYWQpIDogYXJnXG4gIH1cblxuICBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9PSBudWxsID8gbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgOiBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGFjY2VzcyBjbGFzc05hbWUgcHJvcGVydHkgd2hpbGUgcmVzcGVjdGluZyBTVkdBbmltYXRlZFN0cmluZ1xuICBmdW5jdGlvbiBjbGFzc05hbWUobm9kZSwgdmFsdWUpe1xuICAgIHZhciBrbGFzcyA9IG5vZGUuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICBzdmcgICA9IGtsYXNzICYmIGtsYXNzLmJhc2VWYWwgIT09IHVuZGVmaW5lZFxuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBzdmcgPyBrbGFzcy5iYXNlVmFsIDoga2xhc3NcbiAgICBzdmcgPyAoa2xhc3MuYmFzZVZhbCA9IHZhbHVlKSA6IChub2RlLmNsYXNzTmFtZSA9IHZhbHVlKVxuICB9XG5cbiAgLy8gXCJ0cnVlXCIgID0+IHRydWVcbiAgLy8gXCJmYWxzZVwiID0+IGZhbHNlXG4gIC8vIFwibnVsbFwiICA9PiBudWxsXG4gIC8vIFwiNDJcIiAgICA9PiA0MlxuICAvLyBcIjQyLjVcIiAgPT4gNDIuNVxuICAvLyBcIjA4XCIgICAgPT4gXCIwOFwiXG4gIC8vIEpTT04gICAgPT4gcGFyc2UgaWYgdmFsaWRcbiAgLy8gU3RyaW5nICA9PiBzZWxmXG4gIGZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHZhbHVlID9cbiAgICAgICAgdmFsdWUgPT0gXCJ0cnVlXCIgfHxcbiAgICAgICAgKCB2YWx1ZSA9PSBcImZhbHNlXCIgPyBmYWxzZSA6XG4gICAgICAgICAgdmFsdWUgPT0gXCJudWxsXCIgPyBudWxsIDpcbiAgICAgICAgICArdmFsdWUgKyBcIlwiID09IHZhbHVlID8gK3ZhbHVlIDpcbiAgICAgICAgICAvXltcXFtcXHtdLy50ZXN0KHZhbHVlKSA/ICQucGFyc2VKU09OKHZhbHVlKSA6XG4gICAgICAgICAgdmFsdWUgKVxuICAgICAgICA6IHZhbHVlXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG4gIH1cblxuICAkLnR5cGUgPSB0eXBlXG4gICQuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb25cbiAgJC5pc1dpbmRvdyA9IGlzV2luZG93XG4gICQuaXNBcnJheSA9IGlzQXJyYXlcbiAgJC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdFxuXG4gICQuaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lXG4gICAgZm9yIChuYW1lIGluIG9iaikgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gICQuaXNOdW1lcmljID0gZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIG51bSA9IE51bWJlcih2YWwpLCB0eXBlID0gdHlwZW9mIHZhbFxuICAgIHJldHVybiB2YWwgIT0gbnVsbCAmJiB0eXBlICE9ICdib29sZWFuJyAmJlxuICAgICAgKHR5cGUgIT0gJ3N0cmluZycgfHwgdmFsLmxlbmd0aCkgJiZcbiAgICAgICFpc05hTihudW0pICYmIGlzRmluaXRlKG51bSkgfHwgZmFsc2VcbiAgfVxuXG4gICQuaW5BcnJheSA9IGZ1bmN0aW9uKGVsZW0sIGFycmF5LCBpKXtcbiAgICByZXR1cm4gZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyYXksIGVsZW0sIGkpXG4gIH1cblxuICAkLmNhbWVsQ2FzZSA9IGNhbWVsaXplXG4gICQudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IFwiXCIgOiBTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbChzdHIpXG4gIH1cblxuICAvLyBwbHVnaW4gY29tcGF0aWJpbGl0eVxuICAkLnV1aWQgPSAwXG4gICQuc3VwcG9ydCA9IHsgfVxuICAkLmV4cHIgPSB7IH1cbiAgJC5ub29wID0gZnVuY3Rpb24oKSB7fVxuXG4gICQubWFwID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcbiAgICB2YXIgdmFsdWUsIHZhbHVlcyA9IFtdLCBpLCBrZXlcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSlcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKVxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWVzLnB1c2godmFsdWUpXG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgZm9yIChrZXkgaW4gZWxlbWVudHMpIHtcbiAgICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1trZXldLCBrZXkpXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICAgIH1cbiAgICByZXR1cm4gZmxhdHRlbih2YWx1ZXMpXG4gIH1cblxuICAkLmVhY2ggPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIHZhciBpLCBrZXlcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1tpXSwgaSwgZWxlbWVudHNbaV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKVxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1trZXldLCBrZXksIGVsZW1lbnRzW2tleV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnRzXG4gIH1cblxuICAkLmdyZXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xuICAgIHJldHVybiBmaWx0ZXIuY2FsbChlbGVtZW50cywgY2FsbGJhY2spXG4gIH1cblxuICBpZiAod2luZG93LkpTT04pICQucGFyc2VKU09OID0gSlNPTi5wYXJzZVxuXG4gIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxuICAkLmVhY2goXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIuc3BsaXQoXCIgXCIpLCBmdW5jdGlvbihpLCBuYW1lKSB7XG4gICAgY2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfSlcblxuICAvLyBEZWZpbmUgbWV0aG9kcyB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIG9uIGFsbFxuICAvLyBaZXB0byBjb2xsZWN0aW9uc1xuICAkLmZuID0ge1xuICAgIGNvbnN0cnVjdG9yOiB6ZXB0by5aLFxuICAgIGxlbmd0aDogMCxcblxuICAgIC8vIEJlY2F1c2UgYSBjb2xsZWN0aW9uIGFjdHMgbGlrZSBhbiBhcnJheVxuICAgIC8vIGNvcHkgb3ZlciB0aGVzZSB1c2VmdWwgYXJyYXkgZnVuY3Rpb25zLlxuICAgIGZvckVhY2g6IGVtcHR5QXJyYXkuZm9yRWFjaCxcbiAgICByZWR1Y2U6IGVtcHR5QXJyYXkucmVkdWNlLFxuICAgIHB1c2g6IGVtcHR5QXJyYXkucHVzaCxcbiAgICBzb3J0OiBlbXB0eUFycmF5LnNvcnQsXG4gICAgc3BsaWNlOiBlbXB0eUFycmF5LnNwbGljZSxcbiAgICBpbmRleE9mOiBlbXB0eUFycmF5LmluZGV4T2YsXG4gICAgY29uY2F0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGksIHZhbHVlLCBhcmdzID0gW11cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBhcmd1bWVudHNbaV1cbiAgICAgICAgYXJnc1tpXSA9IHplcHRvLmlzWih2YWx1ZSkgPyB2YWx1ZS50b0FycmF5KCkgOiB2YWx1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseSh6ZXB0by5pc1oodGhpcykgPyB0aGlzLnRvQXJyYXkoKSA6IHRoaXMsIGFyZ3MpXG4gICAgfSxcblxuICAgIC8vIGBtYXBgIGFuZCBgc2xpY2VgIGluIHRoZSBqUXVlcnkgQVBJIHdvcmsgZGlmZmVyZW50bHlcbiAgICAvLyBmcm9tIHRoZWlyIGFycmF5IGNvdW50ZXJwYXJ0c1xuICAgIG1hcDogZnVuY3Rpb24oZm4pe1xuICAgICAgcmV0dXJuICQoJC5tYXAodGhpcywgZnVuY3Rpb24oZWwsIGkpeyByZXR1cm4gZm4uY2FsbChlbCwgaSwgZWwpIH0pKVxuICAgIH0sXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gJChzbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKVxuICAgIH0sXG5cbiAgICByZWFkeTogZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgICAgLy8gbmVlZCB0byBjaGVjayBpZiBkb2N1bWVudC5ib2R5IGV4aXN0cyBmb3IgSUUgYXMgdGhhdCBicm93c2VyIHJlcG9ydHNcbiAgICAgIC8vIGRvY3VtZW50IHJlYWR5IHdoZW4gaXQgaGFzbid0IHlldCBjcmVhdGVkIHRoZSBib2R5IGVsZW1lbnRcbiAgICAgIGlmIChyZWFkeVJFLnRlc3QoZG9jdW1lbnQucmVhZHlTdGF0ZSkgJiYgZG9jdW1lbnQuYm9keSkgY2FsbGJhY2soJClcbiAgICAgIGVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCl7IGNhbGxiYWNrKCQpIH0sIGZhbHNlKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oaWR4KXtcbiAgICAgIHJldHVybiBpZHggPT09IHVuZGVmaW5lZCA/IHNsaWNlLmNhbGwodGhpcykgOiB0aGlzW2lkeCA+PSAwID8gaWR4IDogaWR4ICsgdGhpcy5sZW5ndGhdXG4gICAgfSxcbiAgICB0b0FycmF5OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5nZXQoKSB9LFxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGhcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50Tm9kZSAhPSBudWxsKVxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICAgIGVtcHR5QXJyYXkuZXZlcnkuY2FsbCh0aGlzLCBmdW5jdGlvbihlbCwgaWR4KXtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoZWwsIGlkeCwgZWwpICE9PSBmYWxzZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuIHRoaXMubm90KHRoaXMubm90KHNlbGVjdG9yKSlcbiAgICAgIHJldHVybiAkKGZpbHRlci5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gemVwdG8ubWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcilcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbihzZWxlY3Rvcixjb250ZXh0KXtcbiAgICAgIHJldHVybiAkKHVuaXEodGhpcy5jb25jYXQoJChzZWxlY3Rvcixjb250ZXh0KSkpKVxuICAgIH0sXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgemVwdG8ubWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIG5vdDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgdmFyIG5vZGVzPVtdXG4gICAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikgJiYgc2VsZWN0b3IuY2FsbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcyxpZHgpKSBub2Rlcy5wdXNoKHRoaXMpXG4gICAgICAgIH0pXG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDpcbiAgICAgICAgICAobGlrZUFycmF5KHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yLml0ZW0pKSA/IHNsaWNlLmNhbGwoc2VsZWN0b3IpIDogJChzZWxlY3RvcilcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICBpZiAoZXhjbHVkZXMuaW5kZXhPZihlbCkgPCAwKSBub2Rlcy5wdXNoKGVsKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBoYXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gaXNPYmplY3Qoc2VsZWN0b3IpID9cbiAgICAgICAgICAkLmNvbnRhaW5zKHRoaXMsIHNlbGVjdG9yKSA6XG4gICAgICAgICAgJCh0aGlzKS5maW5kKHNlbGVjdG9yKS5zaXplKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBlcTogZnVuY3Rpb24oaWR4KXtcbiAgICAgIHJldHVybiBpZHggPT09IC0xID8gdGhpcy5zbGljZShpZHgpIDogdGhpcy5zbGljZShpZHgsICsgaWR4ICsgMSlcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1swXVxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXG4gICAgICByZXR1cm4gZWwgJiYgIWlzT2JqZWN0KGVsKSA/IGVsIDogJChlbClcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHZhciByZXN1bHQsICR0aGlzID0gdGhpc1xuICAgICAgaWYgKCFzZWxlY3RvcikgcmVzdWx0ID0gJCgpXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcpXG4gICAgICAgIHJlc3VsdCA9ICQoc2VsZWN0b3IpLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBub2RlID0gdGhpc1xuICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCgkdGhpcywgZnVuY3Rpb24ocGFyZW50KXtcbiAgICAgICAgICAgIHJldHVybiAkLmNvbnRhaW5zKHBhcmVudCwgbm9kZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgZWxzZSBpZiAodGhpcy5sZW5ndGggPT0gMSkgcmVzdWx0ID0gJCh6ZXB0by5xc2EodGhpc1swXSwgc2VsZWN0b3IpKVxuICAgICAgZWxzZSByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gemVwdG8ucXNhKHRoaXMsIHNlbGVjdG9yKSB9KVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0sXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xuICAgICAgdmFyIG5vZGVzID0gW10sIGNvbGxlY3Rpb24gPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcgJiYgJChzZWxlY3RvcilcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihfLCBub2RlKXtcbiAgICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiB6ZXB0by5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpXG4gICAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlXG4gICAgICAgIGlmIChub2RlICYmIG5vZGVzLmluZGV4T2Yobm9kZSkgPCAwKSBub2Rlcy5wdXNoKG5vZGUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuICQobm9kZXMpXG4gICAgfSxcbiAgICBwYXJlbnRzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG5vZGVzID0gdGhpc1xuICAgICAgd2hpbGUgKG5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgIG5vZGVzID0gJC5tYXAobm9kZXMsIGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIGlmICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPCAwKSB7XG4gICAgICAgICAgICBhbmNlc3RvcnMucHVzaChub2RlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICByZXR1cm4gZmlsdGVyZWQoYW5jZXN0b3JzLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIHBhcmVudDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHVuaXEodGhpcy5wbHVjaygncGFyZW50Tm9kZScpKSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiBjaGlsZHJlbih0aGlzKSB9KSwgc2VsZWN0b3IpXG4gICAgfSxcbiAgICBjb250ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRlbnREb2N1bWVudCB8fCBzbGljZS5jYWxsKHRoaXMuY2hpbGROb2RlcykgfSlcbiAgICB9LFxuICAgIHNpYmxpbmdzOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gZmlsdGVyZWQodGhpcy5tYXAoZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICByZXR1cm4gZmlsdGVyLmNhbGwoY2hpbGRyZW4oZWwucGFyZW50Tm9kZSksIGZ1bmN0aW9uKGNoaWxkKXsgcmV0dXJuIGNoaWxkIT09ZWwgfSlcbiAgICAgIH0pLCBzZWxlY3RvcilcbiAgICB9LFxuICAgIGVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLmlubmVySFRNTCA9ICcnIH0pXG4gICAgfSxcbiAgICAvLyBgcGx1Y2tgIGlzIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLmpzXG4gICAgcGx1Y2s6IGZ1bmN0aW9uKHByb3BlcnR5KXtcbiAgICAgIHJldHVybiAkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCl7IHJldHVybiBlbFtwcm9wZXJ0eV0gfSlcbiAgICB9LFxuICAgIHNob3c6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRoaXMsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKSA9PSBcIm5vbmVcIilcbiAgICAgICAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSBkZWZhdWx0RGlzcGxheSh0aGlzLm5vZGVOYW1lKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHJlcGxhY2VXaXRoOiBmdW5jdGlvbihuZXdDb250ZW50KXtcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZShuZXdDb250ZW50KS5yZW1vdmUoKVxuICAgIH0sXG4gICAgd3JhcDogZnVuY3Rpb24oc3RydWN0dXJlKXtcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXG4gICAgICBpZiAodGhpc1swXSAmJiAhZnVuYylcbiAgICAgICAgdmFyIGRvbSAgID0gJChzdHJ1Y3R1cmUpLmdldCgwKSxcbiAgICAgICAgICAgIGNsb25lID0gZG9tLnBhcmVudE5vZGUgfHwgdGhpcy5sZW5ndGggPiAxXG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICAkKHRoaXMpLndyYXBBbGwoXG4gICAgICAgICAgZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6XG4gICAgICAgICAgICBjbG9uZSA/IGRvbS5jbG9uZU5vZGUodHJ1ZSkgOiBkb21cbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XG4gICAgICBpZiAodGhpc1swXSkge1xuICAgICAgICAkKHRoaXNbMF0pLmJlZm9yZShzdHJ1Y3R1cmUgPSAkKHN0cnVjdHVyZSkpXG4gICAgICAgIHZhciBjaGlsZHJlblxuICAgICAgICAvLyBkcmlsbCBkb3duIHRvIHRoZSBpbm1vc3QgZWxlbWVudFxuICAgICAgICB3aGlsZSAoKGNoaWxkcmVuID0gc3RydWN0dXJlLmNoaWxkcmVuKCkpLmxlbmd0aCkgc3RydWN0dXJlID0gY2hpbGRyZW4uZmlyc3QoKVxuICAgICAgICAkKHN0cnVjdHVyZSkuYXBwZW5kKHRoaXMpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgd3JhcElubmVyOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmN0aW9uKHN0cnVjdHVyZSlcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgc2VsZiA9ICQodGhpcyksIGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpLFxuICAgICAgICAgICAgZG9tICA9IGZ1bmMgPyBzdHJ1Y3R1cmUuY2FsbCh0aGlzLCBpbmRleCkgOiBzdHJ1Y3R1cmVcbiAgICAgICAgY29udGVudHMubGVuZ3RoID8gY29udGVudHMud3JhcEFsbChkb20pIDogc2VsZi5hcHBlbmQoZG9tKVxuICAgICAgfSlcbiAgICB9LFxuICAgIHVud3JhcDogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICAkKHRoaXMpLnJlcGxhY2VXaXRoKCQodGhpcykuY2hpbGRyZW4oKSlcbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpIH0pXG4gICAgfSxcbiAgICBoaWRlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuY3NzKFwiZGlzcGxheVwiLCBcIm5vbmVcIilcbiAgICB9LFxuICAgIHRvZ2dsZTogZnVuY3Rpb24oc2V0dGluZyl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBlbCA9ICQodGhpcylcbiAgICAgICAgOyhzZXR0aW5nID09PSB1bmRlZmluZWQgPyBlbC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcbiAgICBuZXh0OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ25leHRFbGVtZW50U2libGluZycpKS5maWx0ZXIoc2VsZWN0b3IgfHwgJyonKSB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG9yaWdpbkh0bWwgPSB0aGlzLmlubmVySFRNTFxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbClcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmdW5jQXJnKHRoaXMsIHRleHQsIGlkeCwgdGhpcy50ZXh0Q29udGVudClcbiAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gbmV3VGV4dCA9PSBudWxsID8gJycgOiAnJytuZXdUZXh0XG4gICAgICAgIH0pIDpcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXMucGx1Y2soJ3RleHRDb250ZW50Jykuam9pbihcIlwiKSA6IG51bGwpXG4gICAgfSxcbiAgICBhdHRyOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XG4gICAgICB2YXIgcmVzdWx0XG4gICAgICByZXR1cm4gKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnICYmICEoMSBpbiBhcmd1bWVudHMpKSA/XG4gICAgICAgICgwIGluIHRoaXMgJiYgdGhpc1swXS5ub2RlVHlwZSA9PSAxICYmIChyZXN1bHQgPSB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKSkgIT0gbnVsbCA/IHJlc3VsdCA6IHVuZGVmaW5lZCkgOlxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG5hbWUpKSBmb3IgKGtleSBpbiBuYW1lKSBzZXRBdHRyaWJ1dGUodGhpcywga2V5LCBuYW1lW2tleV0pXG4gICAgICAgICAgZWxzZSBzZXRBdHRyaWJ1dGUodGhpcywgbmFtZSwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSkpXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBuYW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihhdHRyaWJ1dGUpe1xuICAgICAgICBzZXRBdHRyaWJ1dGUodGhpcywgYXR0cmlidXRlKVxuICAgICAgfSwgdGhpcyl9KVxuICAgIH0sXG4gICAgcHJvcDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuICAgICAgbmFtZSA9IHByb3BNYXBbbmFtZV0gfHwgbmFtZVxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzW25hbWVdKVxuICAgICAgICB9KSA6XG4gICAgICAgICh0aGlzWzBdICYmIHRoaXNbMF1bbmFtZV0pXG4gICAgfSxcbiAgICByZW1vdmVQcm9wOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgZGVsZXRlIHRoaXNbbmFtZV0gfSlcbiAgICB9LFxuICAgIGRhdGE6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcbiAgICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBuYW1lLnJlcGxhY2UoY2FwaXRhbFJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxuXG4gICAgICB2YXIgZGF0YSA9ICgxIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUsIHZhbHVlKSA6XG4gICAgICAgIHRoaXMuYXR0cihhdHRyTmFtZSlcblxuICAgICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkZXNlcmlhbGl6ZVZhbHVlKGRhdGEpIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2YWw6IGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIGlmICgwIGluIGFyZ3VtZW50cykge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcIlwiXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gJiYgKHRoaXNbMF0ubXVsdGlwbGUgP1xuICAgICAgICAgICAkKHRoaXNbMF0pLmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5zZWxlY3RlZCB9KS5wbHVjaygndmFsdWUnKSA6XG4gICAgICAgICAgIHRoaXNbMF0udmFsdWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKXtcbiAgICAgIGlmIChjb29yZGluYXRlcykgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXG4gICAgICAgICAgICBjb29yZHMgPSBmdW5jQXJnKHRoaXMsIGNvb3JkaW5hdGVzLCBpbmRleCwgJHRoaXMub2Zmc2V0KCkpLFxuICAgICAgICAgICAgcGFyZW50T2Zmc2V0ID0gJHRoaXMub2Zmc2V0UGFyZW50KCkub2Zmc2V0KCksXG4gICAgICAgICAgICBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgdG9wOiAgY29vcmRzLnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICAgICAgICBsZWZ0OiBjb29yZHMubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKCR0aGlzLmNzcygncG9zaXRpb24nKSA9PSAnc3RhdGljJykgcHJvcHNbJ3Bvc2l0aW9uJ10gPSAncmVsYXRpdmUnXG4gICAgICAgICR0aGlzLmNzcyhwcm9wcylcbiAgICAgIH0pXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAhPT0gdGhpc1swXSAmJiAhJC5jb250YWlucyhkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXNbMF0pKVxuICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH1cbiAgICAgIHZhciBvYmogPSB0aGlzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBvYmoubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdG9wOiBvYmoudG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChvYmoud2lkdGgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQob2JqLmhlaWdodClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNzczogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXNbMF1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbY2FtZWxpemUocHJvcGVydHkpXSB8fCBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICcnKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm5cbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fVxuICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcbiAgICAgICAgICAkLmVhY2gocHJvcGVydHksIGZ1bmN0aW9uKF8sIHByb3Ape1xuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSAoZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wKV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIHByb3BzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNzcyA9ICcnXG4gICAgICBpZiAodHlwZShwcm9wZXJ0eSkgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSAmJiB2YWx1ZSAhPT0gMClcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKSB9KVxuICAgICAgICBlbHNlXG4gICAgICAgICAgY3NzID0gZGFzaGVyaXplKHByb3BlcnR5KSArIFwiOlwiICsgbWF5YmVBZGRQeChwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGtleSBpbiBwcm9wZXJ0eSlcbiAgICAgICAgICBpZiAoIXByb3BlcnR5W2tleV0gJiYgcHJvcGVydHlba2V5XSAhPT0gMClcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShrZXkpKSB9KVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNzcyArPSBkYXNoZXJpemUoa2V5KSArICc6JyArIG1heWJlQWRkUHgoa2V5LCBwcm9wZXJ0eVtrZXldKSArICc7J1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuc3R5bGUuY3NzVGV4dCArPSAnOycgKyBjc3MgfSlcbiAgICB9LFxuICAgIGluZGV4OiBmdW5jdGlvbihlbGVtZW50KXtcbiAgICAgIHJldHVybiBlbGVtZW50ID8gdGhpcy5pbmRleE9mKCQoZWxlbWVudClbMF0pIDogdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4T2YodGhpc1swXSlcbiAgICB9LFxuICAgIGhhc0NsYXNzOiBmdW5jdGlvbihuYW1lKXtcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIGZhbHNlXG4gICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwodGhpcywgZnVuY3Rpb24oZWwpe1xuICAgICAgICByZXR1cm4gdGhpcy50ZXN0KGNsYXNzTmFtZShlbCkpXG4gICAgICB9LCBjbGFzc1JFKG5hbWUpKVxuICAgIH0sXG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICBpZiAoISgnY2xhc3NOYW1lJyBpbiB0aGlzKSkgcmV0dXJuXG4gICAgICAgIGNsYXNzTGlzdCA9IFtdXG4gICAgICAgIHZhciBjbHMgPSBjbGFzc05hbWUodGhpcyksIG5ld05hbWUgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xzKVxuICAgICAgICBuZXdOYW1lLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGlmICghJCh0aGlzKS5oYXNDbGFzcyhrbGFzcykpIGNsYXNzTGlzdC5wdXNoKGtsYXNzKVxuICAgICAgICB9LCB0aGlzKVxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoICYmIGNsYXNzTmFtZSh0aGlzLCBjbHMgKyAoY2xzID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTGlzdC5qb2luKFwiIFwiKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSl7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNsYXNzTmFtZSh0aGlzLCAnJylcbiAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NOYW1lKHRoaXMpXG4gICAgICAgIGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc0xpc3QpLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTGlzdC5yZXBsYWNlKGNsYXNzUkUoa2xhc3MpLCBcIiBcIilcbiAgICAgICAgfSlcbiAgICAgICAgY2xhc3NOYW1lKHRoaXMsIGNsYXNzTGlzdC50cmltKCkpXG4gICAgICB9KVxuICAgIH0sXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUsIHdoZW4pe1xuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBuYW1lcyA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc05hbWUodGhpcykpXG4gICAgICAgIG5hbWVzLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xuICAgICAgICAgICh3aGVuID09PSB1bmRlZmluZWQgPyAhJHRoaXMuaGFzQ2xhc3Moa2xhc3MpIDogd2hlbikgP1xuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0sXG4gICAgc2Nyb2xsVG9wOiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGhhc1Njcm9sbFRvcCA/IHRoaXNbMF0uc2Nyb2xsVG9wIDogdGhpc1swXS5wYWdlWU9mZnNldFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxUb3AgP1xuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHRoaXMuc2Nyb2xsWCwgdmFsdWUpIH0pXG4gICAgfSxcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cbiAgICAgIHZhciBoYXNTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnIGluIHRoaXNbMF1cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsTGVmdCA/XG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsTGVmdCA9IHZhbHVlIH0gOlxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXG4gICAgfSxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cblxuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxuICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpLFxuICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXG4gICAgICAgIHBhcmVudE9mZnNldCA9IHJvb3ROb2RlUkUudGVzdChvZmZzZXRQYXJlbnRbMF0ubm9kZU5hbWUpID8geyB0b3A6IDAsIGxlZnQ6IDAgfSA6IG9mZnNldFBhcmVudC5vZmZzZXQoKVxuXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcbiAgICAgIC8vIG5vdGU6IHdoZW4gYW4gZWxlbWVudCBoYXMgbWFyZ2luOiBhdXRvIHRoZSBvZmZzZXRMZWZ0IGFuZCBtYXJnaW5MZWZ0XG4gICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcbiAgICAgIG9mZnNldC5sZWZ0IC09IHBhcnNlRmxvYXQoICQoZWxlbSkuY3NzKCdtYXJnaW4tbGVmdCcpICkgfHwgMFxuXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcbiAgICAgIHBhcmVudE9mZnNldC50b3AgICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci10b3Atd2lkdGgnKSApIHx8IDBcbiAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykgKSB8fCAwXG5cbiAgICAgIC8vIFN1YnRyYWN0IHRoZSB0d28gb2Zmc2V0c1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxuICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0XG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgIXJvb3ROb2RlUkUudGVzdChwYXJlbnQubm9kZU5hbWUpICYmICQocGFyZW50KS5jc3MoXCJwb3NpdGlvblwiKSA9PSBcInN0YXRpY1wiKVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnRcbiAgICAgICAgcmV0dXJuIHBhcmVudFxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvLyBmb3Igbm93XG4gICQuZm4uZGV0YWNoID0gJC5mbi5yZW1vdmVcblxuICAvLyBHZW5lcmF0ZSB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgZnVuY3Rpb25zXG4gIDtbJ3dpZHRoJywgJ2hlaWdodCddLmZvckVhY2goZnVuY3Rpb24oZGltZW5zaW9uKXtcbiAgICB2YXIgZGltZW5zaW9uUHJvcGVydHkgPVxuICAgICAgZGltZW5zaW9uLnJlcGxhY2UoLy4vLCBmdW5jdGlvbihtKXsgcmV0dXJuIG1bMF0udG9VcHBlckNhc2UoKSB9KVxuXG4gICAgJC5mbltkaW1lbnNpb25dID0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgdmFyIG9mZnNldCwgZWwgPSB0aGlzWzBdXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzV2luZG93KGVsKSA/IGVsWydpbm5lcicgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxuICAgICAgICBpc0RvY3VtZW50KGVsKSA/IGVsLmRvY3VtZW50RWxlbWVudFsnc2Nyb2xsJyArIGRpbWVuc2lvblByb3BlcnR5XSA6XG4gICAgICAgIChvZmZzZXQgPSB0aGlzLm9mZnNldCgpKSAmJiBvZmZzZXRbZGltZW5zaW9uXVxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIGVsID0gJCh0aGlzKVxuICAgICAgICBlbC5jc3MoZGltZW5zaW9uLCBmdW5jQXJnKHRoaXMsIHZhbHVlLCBpZHgsIGVsW2RpbWVuc2lvbl0oKSkpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuKSB7XG4gICAgZnVuKG5vZGUpXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIHRyYXZlcnNlTm9kZShub2RlLmNoaWxkTm9kZXNbaV0sIGZ1bilcbiAgfVxuXG4gIC8vIEdlbmVyYXRlIHRoZSBgYWZ0ZXJgLCBgcHJlcGVuZGAsIGBiZWZvcmVgLCBgYXBwZW5kYCxcbiAgLy8gYGluc2VydEFmdGVyYCwgYGluc2VydEJlZm9yZWAsIGBhcHBlbmRUb2AsIGFuZCBgcHJlcGVuZFRvYCBtZXRob2RzLlxuICBhZGphY2VuY3lPcGVyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvciwgb3BlcmF0b3JJbmRleCkge1xuICAgIHZhciBpbnNpZGUgPSBvcGVyYXRvckluZGV4ICUgMiAvLz0+IHByZXBlbmQsIGFwcGVuZFxuXG4gICAgJC5mbltvcGVyYXRvcl0gPSBmdW5jdGlvbigpe1xuICAgICAgLy8gYXJndW1lbnRzIGNhbiBiZSBub2RlcywgYXJyYXlzIG9mIG5vZGVzLCBaZXB0byBvYmplY3RzIGFuZCBIVE1MIHN0cmluZ3NcbiAgICAgIHZhciBhcmdUeXBlLCBub2RlcyA9ICQubWFwKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICB2YXIgYXJyID0gW11cbiAgICAgICAgICAgIGFyZ1R5cGUgPSB0eXBlKGFyZylcbiAgICAgICAgICAgIGlmIChhcmdUeXBlID09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICBhcmcuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5ub2RlVHlwZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJyLnB1c2goZWwpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJC56ZXB0by5pc1ooZWwpKSByZXR1cm4gYXJyID0gYXJyLmNvbmNhdChlbC5nZXQoKSlcbiAgICAgICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KHplcHRvLmZyYWdtZW50KGVsKSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIGFyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT0gXCJvYmplY3RcIiB8fCBhcmcgPT0gbnVsbCA/XG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwYXJlbnQsIGNvcHlCeUNsb25lID0gdGhpcy5sZW5ndGggPiAxXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcblxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihfLCB0YXJnZXQpe1xuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxuXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIG1ldGhvZHMgdG8gYSBcImJlZm9yZVwiIG9wZXJhdGlvblxuICAgICAgICB0YXJnZXQgPSBvcGVyYXRvckluZGV4ID09IDAgPyB0YXJnZXQubmV4dFNpYmxpbmcgOlxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDEgPyB0YXJnZXQuZmlyc3RDaGlsZCA6XG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMiA/IHRhcmdldCA6XG4gICAgICAgICAgICAgICAgIG51bGxcblxuICAgICAgICB2YXIgcGFyZW50SW5Eb2N1bWVudCA9ICQuY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBwYXJlbnQpXG5cbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcbiAgICAgICAgICBpZiAoY29weUJ5Q2xvbmUpIG5vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHJldHVybiAkKG5vZGUpLnJlbW92ZSgpXG5cbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldClcbiAgICAgICAgICBpZiAocGFyZW50SW5Eb2N1bWVudCkgdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZSAhPSBudWxsICYmIGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICAgICAoIWVsLnR5cGUgfHwgZWwudHlwZSA9PT0gJ3RleHQvamF2YXNjcmlwdCcpICYmICFlbC5zcmMpe1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWwub3duZXJEb2N1bWVudCA/IGVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3dcbiAgICAgICAgICAgICAgdGFyZ2V0WydldmFsJ10uY2FsbCh0YXJnZXQsIGVsLmlubmVySFRNTClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBhZnRlciAgICA9PiBpbnNlcnRBZnRlclxuICAgIC8vIHByZXBlbmQgID0+IHByZXBlbmRUb1xuICAgIC8vIGJlZm9yZSAgID0+IGluc2VydEJlZm9yZVxuICAgIC8vIGFwcGVuZCAgID0+IGFwcGVuZFRvXG4gICAgJC5mbltpbnNpZGUgPyBvcGVyYXRvcisnVG8nIDogJ2luc2VydCcrKG9wZXJhdG9ySW5kZXggPyAnQmVmb3JlJyA6ICdBZnRlcicpXSA9IGZ1bmN0aW9uKGh0bWwpe1xuICAgICAgJChodG1sKVtvcGVyYXRvcl0odGhpcylcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxuXG4gIHplcHRvLloucHJvdG90eXBlID0gWi5wcm90b3R5cGUgPSAkLmZuXG5cbiAgLy8gRXhwb3J0IGludGVybmFsIEFQSSBmdW5jdGlvbnMgaW4gdGhlIGAkLnplcHRvYCBuYW1lc3BhY2VcbiAgemVwdG8udW5pcSA9IHVuaXFcbiAgemVwdG8uZGVzZXJpYWxpemVWYWx1ZSA9IGRlc2VyaWFsaXplVmFsdWVcbiAgJC56ZXB0byA9IHplcHRvXG5cbiAgcmV0dXJuICRcbn0pKClcblxuOyhmdW5jdGlvbigkKXtcbiAgdmFyIF96aWQgPSAxLCB1bmRlZmluZWQsXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcbiAgICAgIGlzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24sXG4gICAgICBpc1N0cmluZyA9IGZ1bmN0aW9uKG9iail7IHJldHVybiB0eXBlb2Ygb2JqID09ICdzdHJpbmcnIH0sXG4gICAgICBoYW5kbGVycyA9IHt9LFxuICAgICAgc3BlY2lhbEV2ZW50cz17fSxcbiAgICAgIGZvY3VzaW5TdXBwb3J0ZWQgPSAnb25mb2N1c2luJyBpbiB3aW5kb3csXG4gICAgICBmb2N1cyA9IHsgZm9jdXM6ICdmb2N1c2luJywgYmx1cjogJ2ZvY3Vzb3V0JyB9LFxuICAgICAgaG92ZXIgPSB7IG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLCBtb3VzZWxlYXZlOiAnbW91c2VvdXQnIH1cblxuICBzcGVjaWFsRXZlbnRzLmNsaWNrID0gc3BlY2lhbEV2ZW50cy5tb3VzZWRvd24gPSBzcGVjaWFsRXZlbnRzLm1vdXNldXAgPSBzcGVjaWFsRXZlbnRzLm1vdXNlbW92ZSA9ICdNb3VzZUV2ZW50cydcblxuICBmdW5jdGlvbiB6aWQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50Ll96aWQgfHwgKGVsZW1lbnQuX3ppZCA9IF96aWQrKylcbiAgfVxuICBmdW5jdGlvbiBmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQsIGZuLCBzZWxlY3Rvcikge1xuICAgIGV2ZW50ID0gcGFyc2UoZXZlbnQpXG4gICAgaWYgKGV2ZW50Lm5zKSB2YXIgbWF0Y2hlciA9IG1hdGNoZXJGb3IoZXZlbnQubnMpXG4gICAgcmV0dXJuIChoYW5kbGVyc1t6aWQoZWxlbWVudCldIHx8IFtdKS5maWx0ZXIoZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgcmV0dXJuIGhhbmRsZXJcbiAgICAgICAgJiYgKCFldmVudC5lICB8fCBoYW5kbGVyLmUgPT0gZXZlbnQuZSlcbiAgICAgICAgJiYgKCFldmVudC5ucyB8fCBtYXRjaGVyLnRlc3QoaGFuZGxlci5ucykpXG4gICAgICAgICYmICghZm4gICAgICAgfHwgemlkKGhhbmRsZXIuZm4pID09PSB6aWQoZm4pKVxuICAgICAgICAmJiAoIXNlbGVjdG9yIHx8IGhhbmRsZXIuc2VsID09IHNlbGVjdG9yKVxuICAgIH0pXG4gIH1cbiAgZnVuY3Rpb24gcGFyc2UoZXZlbnQpIHtcbiAgICB2YXIgcGFydHMgPSAoJycgKyBldmVudCkuc3BsaXQoJy4nKVxuICAgIHJldHVybiB7ZTogcGFydHNbMF0sIG5zOiBwYXJ0cy5zbGljZSgxKS5zb3J0KCkuam9pbignICcpfVxuICB9XG4gIGZ1bmN0aW9uIG1hdGNoZXJGb3IobnMpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnwgKScgKyBucy5yZXBsYWNlKCcgJywgJyAuKiA/JykgKyAnKD86IHwkKScpXG4gIH1cblxuICBmdW5jdGlvbiBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZVNldHRpbmcpIHtcbiAgICByZXR1cm4gaGFuZGxlci5kZWwgJiZcbiAgICAgICghZm9jdXNpblN1cHBvcnRlZCAmJiAoaGFuZGxlci5lIGluIGZvY3VzKSkgfHxcbiAgICAgICEhY2FwdHVyZVNldHRpbmdcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWxFdmVudCh0eXBlKSB7XG4gICAgcmV0dXJuIGhvdmVyW3R5cGVdIHx8IChmb2N1c2luU3VwcG9ydGVkICYmIGZvY3VzW3R5cGVdKSB8fCB0eXBlXG4gIH1cblxuICBmdW5jdGlvbiBhZGQoZWxlbWVudCwgZXZlbnRzLCBmbiwgZGF0YSwgc2VsZWN0b3IsIGRlbGVnYXRvciwgY2FwdHVyZSl7XG4gICAgdmFyIGlkID0gemlkKGVsZW1lbnQpLCBzZXQgPSAoaGFuZGxlcnNbaWRdIHx8IChoYW5kbGVyc1tpZF0gPSBbXSkpXG4gICAgZXZlbnRzLnNwbGl0KC9cXHMvKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGlmIChldmVudCA9PSAncmVhZHknKSByZXR1cm4gJChkb2N1bWVudCkucmVhZHkoZm4pXG4gICAgICB2YXIgaGFuZGxlciAgID0gcGFyc2UoZXZlbnQpXG4gICAgICBoYW5kbGVyLmZuICAgID0gZm5cbiAgICAgIGhhbmRsZXIuc2VsICAgPSBzZWxlY3RvclxuICAgICAgLy8gZW11bGF0ZSBtb3VzZWVudGVyLCBtb3VzZWxlYXZlXG4gICAgICBpZiAoaGFuZGxlci5lIGluIGhvdmVyKSBmbiA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldFxuICAgICAgICBpZiAoIXJlbGF0ZWQgfHwgKHJlbGF0ZWQgIT09IHRoaXMgJiYgISQuY29udGFpbnModGhpcywgcmVsYXRlZCkpKVxuICAgICAgICAgIHJldHVybiBoYW5kbGVyLmZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIGhhbmRsZXIuZGVsICAgPSBkZWxlZ2F0b3JcbiAgICAgIHZhciBjYWxsYmFjayAgPSBkZWxlZ2F0b3IgfHwgZm5cbiAgICAgIGhhbmRsZXIucHJveHkgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgZSA9IGNvbXBhdGlibGUoZSlcbiAgICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRhdGFQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgJ2RhdGEnKVxuICAgICAgICAgIGlmICghZGF0YVByb3BEZXNjcmlwdG9yIHx8IGRhdGFQcm9wRGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAgICAgICAgIGUuZGF0YSA9IGRhdGFcbiAgICAgICAgfSBjYXRjaCAoZSkge30gLy8gd2hlbiB1c2luZyBzdHJpY3QgbW9kZSBkYXRhUHJvcERlc2NyaXB0b3Igd2lsbCBiZSB1bmRlZmluZWQgd2hlbiBlIGlzIElucHV0RXZlbnQgKGV2ZW4gdGhvdWdoIGRhdGEgcHJvcGVydHkgZXhpc3RzKS4gU28gd2Ugc3Vycm91bmQgd2l0aCB0cnkvY2F0Y2hcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KGVsZW1lbnQsIGUuX2FyZ3MgPT0gdW5kZWZpbmVkID8gW2VdIDogW2VdLmNvbmNhdChlLl9hcmdzKSlcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgICBoYW5kbGVyLmkgPSBzZXQubGVuZ3RoXG4gICAgICBzZXQucHVzaChoYW5kbGVyKVxuICAgICAgaWYgKCdhZGRFdmVudExpc3RlbmVyJyBpbiBlbGVtZW50KVxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIocmVhbEV2ZW50KGhhbmRsZXIuZSksIGhhbmRsZXIucHJveHksIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlKSlcbiAgICB9KVxuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50LCBldmVudHMsIGZuLCBzZWxlY3RvciwgY2FwdHVyZSl7XG4gICAgdmFyIGlkID0gemlkKGVsZW1lbnQpXG4gICAgOyhldmVudHMgfHwgJycpLnNwbGl0KC9cXHMvKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpe1xuICAgICAgICBkZWxldGUgaGFuZGxlcnNbaWRdW2hhbmRsZXIuaV1cbiAgICAgIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudClcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAkLmV2ZW50ID0geyBhZGQ6IGFkZCwgcmVtb3ZlOiByZW1vdmUgfVxuXG4gICQucHJveHkgPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgIHZhciBhcmdzID0gKDIgaW4gYXJndW1lbnRzKSAmJiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIHZhciBwcm94eUZuID0gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MgPyBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogYXJndW1lbnRzKSB9XG4gICAgICBwcm94eUZuLl96aWQgPSB6aWQoZm4pXG4gICAgICByZXR1cm4gcHJveHlGblxuICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcoY29udGV4dCkpIHtcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdChmbltjb250ZXh0XSwgZm4pXG4gICAgICAgIHJldHVybiAkLnByb3h5LmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJC5wcm94eShmbltjb250ZXh0XSwgZm4pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCBmdW5jdGlvblwiKVxuICAgIH1cbiAgfVxuXG4gICQuZm4uYmluZCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKVxuICB9XG4gICQuZm4udW5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIGNhbGxiYWNrKVxuICB9XG4gICQuZm4ub25lID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjayl7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgMSlcbiAgfVxuXG4gIHZhciByZXR1cm5UcnVlID0gZnVuY3Rpb24oKXtyZXR1cm4gdHJ1ZX0sXG4gICAgICByZXR1cm5GYWxzZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlfSxcbiAgICAgIGlnbm9yZVByb3BlcnRpZXMgPSAvXihbQS1aXXxyZXR1cm5WYWx1ZSR8bGF5ZXJbWFldJHx3ZWJraXRNb3ZlbWVudFtYWV0kKS8sXG4gICAgICBldmVudE1ldGhvZHMgPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiAnaXNEZWZhdWx0UHJldmVudGVkJyxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiAnaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQnLFxuICAgICAgICBzdG9wUHJvcGFnYXRpb246ICdpc1Byb3BhZ2F0aW9uU3RvcHBlZCdcbiAgICAgIH1cblxuICBmdW5jdGlvbiBjb21wYXRpYmxlKGV2ZW50LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlIHx8ICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHNvdXJjZSB8fCAoc291cmNlID0gZXZlbnQpXG5cbiAgICAgICQuZWFjaChldmVudE1ldGhvZHMsIGZ1bmN0aW9uKG5hbWUsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgc291cmNlTWV0aG9kID0gc291cmNlW25hbWVdXG4gICAgICAgIGV2ZW50W25hbWVdID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICB0aGlzW3ByZWRpY2F0ZV0gPSByZXR1cm5UcnVlXG4gICAgICAgICAgcmV0dXJuIHNvdXJjZU1ldGhvZCAmJiBzb3VyY2VNZXRob2QuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRbcHJlZGljYXRlXSA9IHJldHVybkZhbHNlXG4gICAgICB9KVxuXG4gICAgICB0cnkge1xuICAgICAgICBldmVudC50aW1lU3RhbXAgfHwgKGV2ZW50LnRpbWVTdGFtcCA9IERhdGUubm93KCkpXG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7IH1cblxuICAgICAgaWYgKHNvdXJjZS5kZWZhdWx0UHJldmVudGVkICE9PSB1bmRlZmluZWQgPyBzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCA6XG4gICAgICAgICAgJ3JldHVyblZhbHVlJyBpbiBzb3VyY2UgPyBzb3VyY2UucmV0dXJuVmFsdWUgPT09IGZhbHNlIDpcbiAgICAgICAgICBzb3VyY2UuZ2V0UHJldmVudERlZmF1bHQgJiYgc291cmNlLmdldFByZXZlbnREZWZhdWx0KCkpXG4gICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWVcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcm94eShldmVudCkge1xuICAgIHZhciBrZXksIHByb3h5ID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9XG4gICAgZm9yIChrZXkgaW4gZXZlbnQpXG4gICAgICBpZiAoIWlnbm9yZVByb3BlcnRpZXMudGVzdChrZXkpICYmIGV2ZW50W2tleV0gIT09IHVuZGVmaW5lZCkgcHJveHlba2V5XSA9IGV2ZW50W2tleV1cblxuICAgIHJldHVybiBjb21wYXRpYmxlKHByb3h5LCBldmVudClcbiAgfVxuXG4gICQuZm4uZGVsZWdhdGUgPSBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gdGhpcy5vbihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxuICB9XG4gICQuZm4udW5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xuICAgIHJldHVybiB0aGlzLm9mZihldmVudCwgc2VsZWN0b3IsIGNhbGxiYWNrKVxuICB9XG5cbiAgJC5mbi5saXZlID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICAkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjaylcbiAgICByZXR1cm4gdGhpc1xuICB9XG4gICQuZm4uZGllID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcbiAgICAkKGRvY3VtZW50LmJvZHkpLnVuZGVsZWdhdGUodGhpcy5zZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAkLmZuLm9uID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjaywgb25lKXtcbiAgICB2YXIgYXV0b1JlbW92ZSwgZGVsZWdhdG9yLCAkdGhpcyA9IHRoaXNcbiAgICBpZiAoZXZlbnQgJiYgIWlzU3RyaW5nKGV2ZW50KSkge1xuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XG4gICAgICAgICR0aGlzLm9uKHR5cGUsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKVxuICAgICAgfSlcbiAgICAgIHJldHVybiAkdGhpc1xuICAgIH1cblxuICAgIGlmICghaXNTdHJpbmcoc2VsZWN0b3IpICYmICFpc0Z1bmN0aW9uKGNhbGxiYWNrKSAmJiBjYWxsYmFjayAhPT0gZmFsc2UpXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBmYWxzZSlcbiAgICAgIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKGNhbGxiYWNrID09PSBmYWxzZSkgY2FsbGJhY2sgPSByZXR1cm5GYWxzZVxuXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oXywgZWxlbWVudCl7XG4gICAgICBpZiAob25lKSBhdXRvUmVtb3ZlID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHJlbW92ZShlbGVtZW50LCBlLnR5cGUsIGNhbGxiYWNrKVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0b3IpIGRlbGVnYXRvciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgZXZ0LCBtYXRjaCA9ICQoZS50YXJnZXQpLmNsb3Nlc3Qoc2VsZWN0b3IsIGVsZW1lbnQpLmdldCgwKVxuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2ggIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBldnQgPSAkLmV4dGVuZChjcmVhdGVQcm94eShlKSwge2N1cnJlbnRUYXJnZXQ6IG1hdGNoLCBsaXZlRmlyZWQ6IGVsZW1lbnR9KVxuICAgICAgICAgIHJldHVybiAoYXV0b1JlbW92ZSB8fCBjYWxsYmFjaykuYXBwbHkobWF0Y2gsIFtldnRdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFkZChlbGVtZW50LCBldmVudCwgY2FsbGJhY2ssIGRhdGEsIHNlbGVjdG9yLCBkZWxlZ2F0b3IgfHwgYXV0b1JlbW92ZSlcbiAgICB9KVxuICB9XG4gICQuZm4ub2ZmID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjayl7XG4gICAgdmFyICR0aGlzID0gdGhpc1xuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XG4gICAgICAkLmVhY2goZXZlbnQsIGZ1bmN0aW9uKHR5cGUsIGZuKXtcbiAgICAgICAgJHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCBmbilcbiAgICAgIH0pXG4gICAgICByZXR1cm4gJHRoaXNcbiAgICB9XG5cbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxuICAgICAgY2FsbGJhY2sgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcblxuICAgIGlmIChjYWxsYmFjayA9PT0gZmFsc2UpIGNhbGxiYWNrID0gcmV0dXJuRmFsc2VcblxuICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICByZW1vdmUodGhpcywgZXZlbnQsIGNhbGxiYWNrLCBzZWxlY3RvcilcbiAgICB9KVxuICB9XG5cbiAgJC5mbi50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgIGV2ZW50ID0gKGlzU3RyaW5nKGV2ZW50KSB8fCAkLmlzUGxhaW5PYmplY3QoZXZlbnQpKSA/ICQuRXZlbnQoZXZlbnQpIDogY29tcGF0aWJsZShldmVudClcbiAgICBldmVudC5fYXJncyA9IGFyZ3NcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAvLyBoYW5kbGUgZm9jdXMoKSwgYmx1cigpIGJ5IGNhbGxpbmcgdGhlbSBkaXJlY3RseVxuICAgICAgaWYgKGV2ZW50LnR5cGUgaW4gZm9jdXMgJiYgdHlwZW9mIHRoaXNbZXZlbnQudHlwZV0gPT0gXCJmdW5jdGlvblwiKSB0aGlzW2V2ZW50LnR5cGVdKClcbiAgICAgIC8vIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG1pZ2h0IG5vdCBiZSBET00gZWxlbWVudHNcbiAgICAgIGVsc2UgaWYgKCdkaXNwYXRjaEV2ZW50JyBpbiB0aGlzKSB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICBlbHNlICQodGhpcykudHJpZ2dlckhhbmRsZXIoZXZlbnQsIGFyZ3MpXG4gICAgfSlcbiAgfVxuXG4gIC8vIHRyaWdnZXJzIGV2ZW50IGhhbmRsZXJzIG9uIGN1cnJlbnQgZWxlbWVudCBqdXN0IGFzIGlmIGFuIGV2ZW50IG9jY3VycmVkLFxuICAvLyBkb2Vzbid0IHRyaWdnZXIgYW4gYWN0dWFsIGV2ZW50LCBkb2Vzbid0IGJ1YmJsZVxuICAkLmZuLnRyaWdnZXJIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xuICAgIHZhciBlLCByZXN1bHRcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICBlID0gY3JlYXRlUHJveHkoaXNTdHJpbmcoZXZlbnQpID8gJC5FdmVudChldmVudCkgOiBldmVudClcbiAgICAgIGUuX2FyZ3MgPSBhcmdzXG4gICAgICBlLnRhcmdldCA9IGVsZW1lbnRcbiAgICAgICQuZWFjaChmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQudHlwZSB8fCBldmVudCksIGZ1bmN0aW9uKGksIGhhbmRsZXIpe1xuICAgICAgICByZXN1bHQgPSBoYW5kbGVyLnByb3h5KGUpXG4gICAgICAgIGlmIChlLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkpIHJldHVybiBmYWxzZVxuICAgICAgfSlcbiAgICB9KVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIHNob3J0Y3V0IG1ldGhvZHMgZm9yIGAuYmluZChldmVudCwgZm4pYCBmb3IgZWFjaCBldmVudCB0eXBlXG4gIDsoJ2ZvY3VzaW4gZm9jdXNvdXQgZm9jdXMgYmx1ciBsb2FkIHJlc2l6ZSBzY3JvbGwgdW5sb2FkIGNsaWNrIGRibGNsaWNrICcrXG4gICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSAnK1xuICAnY2hhbmdlIHNlbGVjdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yJykuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgJC5mbltldmVudF0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuICgwIGluIGFyZ3VtZW50cykgP1xuICAgICAgICB0aGlzLmJpbmQoZXZlbnQsIGNhbGxiYWNrKSA6XG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudClcbiAgICB9XG4gIH0pXG5cbiAgJC5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzKSB7XG4gICAgaWYgKCFpc1N0cmluZyh0eXBlKSkgcHJvcHMgPSB0eXBlLCB0eXBlID0gcHJvcHMudHlwZVxuICAgIHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KHNwZWNpYWxFdmVudHNbdHlwZV0gfHwgJ0V2ZW50cycpLCBidWJibGVzID0gdHJ1ZVxuICAgIGlmIChwcm9wcykgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykgKG5hbWUgPT0gJ2J1YmJsZXMnKSA/IChidWJibGVzID0gISFwcm9wc1tuYW1lXSkgOiAoZXZlbnRbbmFtZV0gPSBwcm9wc1tuYW1lXSlcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgYnViYmxlcywgdHJ1ZSlcbiAgICByZXR1cm4gY29tcGF0aWJsZShldmVudClcbiAgfVxuXG59KShaZXB0bylcblxuOyhmdW5jdGlvbigkKXtcbiAgdmFyIGNhY2hlID0gW10sIHRpbWVvdXRcblxuICAkLmZuLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgaWYodGhpcy5wYXJlbnROb2RlKXtcbiAgICAgICAgaWYodGhpcy50YWdOYW1lID09PSAnSU1HJyl7XG4gICAgICAgICAgY2FjaGUucHVzaCh0aGlzKVxuICAgICAgICAgIHRoaXMuc3JjID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nXG4gICAgICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KVxuICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7IGNhY2hlID0gW10gfSwgNjAwMDApXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufSkoWmVwdG8pXG5cbjsoZnVuY3Rpb24oJCl7XG4gIHZhciBkYXRhID0ge30sIGRhdGFBdHRyID0gJC5mbi5kYXRhLCBjYW1lbGl6ZSA9ICQuY2FtZWxDYXNlLFxuICAgIGV4cCA9ICQuZXhwYW5kbyA9ICdaZXB0bycgKyAoK25ldyBEYXRlKCkpLCBlbXB0eUFycmF5ID0gW11cblxuICAvLyBHZXQgdmFsdWUgZnJvbSBub2RlOlxuICAvLyAxLiBmaXJzdCB0cnkga2V5IGFzIGdpdmVuLFxuICAvLyAyLiB0aGVuIHRyeSBjYW1lbGl6ZWQga2V5LFxuICAvLyAzLiBmYWxsIGJhY2sgdG8gcmVhZGluZyBcImRhdGEtKlwiIGF0dHJpYnV0ZS5cbiAgZnVuY3Rpb24gZ2V0RGF0YShub2RlLCBuYW1lKSB7XG4gICAgdmFyIGlkID0gbm9kZVtleHBdLCBzdG9yZSA9IGlkICYmIGRhdGFbaWRdXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN0b3JlIHx8IHNldERhdGEobm9kZSlcbiAgICBlbHNlIHtcbiAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICBpZiAobmFtZSBpbiBzdG9yZSkgcmV0dXJuIHN0b3JlW25hbWVdXG4gICAgICAgIHZhciBjYW1lbE5hbWUgPSBjYW1lbGl6ZShuYW1lKVxuICAgICAgICBpZiAoY2FtZWxOYW1lIGluIHN0b3JlKSByZXR1cm4gc3RvcmVbY2FtZWxOYW1lXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFBdHRyLmNhbGwoJChub2RlKSwgbmFtZSlcbiAgICB9XG4gIH1cblxuICAvLyBTdG9yZSB2YWx1ZSB1bmRlciBjYW1lbGl6ZWQga2V5IG9uIG5vZGVcbiAgZnVuY3Rpb24gc2V0RGF0YShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBpZCA9IG5vZGVbZXhwXSB8fCAobm9kZVtleHBdID0gKyskLnV1aWQpLFxuICAgICAgc3RvcmUgPSBkYXRhW2lkXSB8fCAoZGF0YVtpZF0gPSBhdHRyaWJ1dGVEYXRhKG5vZGUpKVxuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHN0b3JlW2NhbWVsaXplKG5hbWUpXSA9IHZhbHVlXG4gICAgcmV0dXJuIHN0b3JlXG4gIH1cblxuICAvLyBSZWFkIGFsbCBcImRhdGEtKlwiIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGVcbiAgZnVuY3Rpb24gYXR0cmlidXRlRGF0YShub2RlKSB7XG4gICAgdmFyIHN0b3JlID0ge31cbiAgICAkLmVhY2gobm9kZS5hdHRyaWJ1dGVzIHx8IGVtcHR5QXJyYXksIGZ1bmN0aW9uKGksIGF0dHIpe1xuICAgICAgaWYgKGF0dHIubmFtZS5pbmRleE9mKCdkYXRhLScpID09IDApXG4gICAgICAgIHN0b3JlW2NhbWVsaXplKGF0dHIubmFtZS5yZXBsYWNlKCdkYXRhLScsICcnKSldID1cbiAgICAgICAgICAkLnplcHRvLmRlc2VyaWFsaXplVmFsdWUoYXR0ci52YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiBzdG9yZVxuICB9XG5cbiAgJC5mbi5kYXRhID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAvLyBzZXQgbXVsdGlwbGUgdmFsdWVzIHZpYSBvYmplY3RcbiAgICAgICQuaXNQbGFpbk9iamVjdChuYW1lKSA/XG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBub2RlKXtcbiAgICAgICAgICAkLmVhY2gobmFtZSwgZnVuY3Rpb24oa2V5LCB2YWx1ZSl7IHNldERhdGEobm9kZSwga2V5LCB2YWx1ZSkgfSlcbiAgICAgICAgfSkgOlxuICAgICAgICAvLyBnZXQgdmFsdWUgZnJvbSBmaXJzdCBlbGVtZW50XG4gICAgICAgICgwIGluIHRoaXMgPyBnZXREYXRhKHRoaXNbMF0sIG5hbWUpIDogdW5kZWZpbmVkKSA6XG4gICAgICAvLyBzZXQgdmFsdWUgb24gYWxsIGVsZW1lbnRzXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgc2V0RGF0YSh0aGlzLCBuYW1lLCB2YWx1ZSkgfSlcbiAgfVxuXG4gICQuZGF0YSA9IGZ1bmN0aW9uKGVsZW0sIG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuICQoZWxlbSkuZGF0YShuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gICQuaGFzRGF0YSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgaWQgPSBlbGVtW2V4cF0sIHN0b3JlID0gaWQgJiYgZGF0YVtpZF1cbiAgICByZXR1cm4gc3RvcmUgPyAhJC5pc0VtcHR5T2JqZWN0KHN0b3JlKSA6IGZhbHNlXG4gIH1cblxuICAkLmZuLnJlbW92ZURhdGEgPSBmdW5jdGlvbihuYW1lcykge1xuICAgIGlmICh0eXBlb2YgbmFtZXMgPT0gJ3N0cmluZycpIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKVxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpZCA9IHRoaXNbZXhwXSwgc3RvcmUgPSBpZCAmJiBkYXRhW2lkXVxuICAgICAgaWYgKHN0b3JlKSAkLmVhY2gobmFtZXMgfHwgc3RvcmUsIGZ1bmN0aW9uKGtleSl7XG4gICAgICAgIGRlbGV0ZSBzdG9yZVtuYW1lcyA/IGNhbWVsaXplKHRoaXMpIDoga2V5XVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLy8gR2VuZXJhdGUgZXh0ZW5kZWQgYHJlbW92ZWAgYW5kIGBlbXB0eWAgZnVuY3Rpb25zXG4gIDtbJ3JlbW92ZScsICdlbXB0eSddLmZvckVhY2goZnVuY3Rpb24obWV0aG9kTmFtZSl7XG4gICAgdmFyIG9yaWdGbiA9ICQuZm5bbWV0aG9kTmFtZV1cbiAgICAkLmZuW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmZpbmQoJyonKVxuICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdyZW1vdmUnKSBlbGVtZW50cyA9IGVsZW1lbnRzLmFkZCh0aGlzKVxuICAgICAgZWxlbWVudHMucmVtb3ZlRGF0YSgpXG4gICAgICByZXR1cm4gb3JpZ0ZuLmNhbGwodGhpcylcbiAgICB9XG4gIH0pXG59KShaZXB0bylcbiAgcmV0dXJuIFplcHRvXG59KSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53704\n")},15765:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "default": () => (/* binding */ SearchBar_DocSearch)\n});\n\n// EXTERNAL MODULE: ./node_modules/hogan.js/lib/hogan.js\nvar hogan = __webpack_require__(34714);\nvar hogan_default = /*#__PURE__*/__webpack_require__.n(hogan);\n// EXTERNAL MODULE: ./.docusaurus/lunr.client.js\nvar lunr_client = __webpack_require__(20549);\n;// ./node_modules/docusaurus-lunr-search/src/theme/SearchBar/lunar-search.js\n/*\nAloglia DocSearch Adapter for Lunr.js\n====================================\nWritten by:  Praveen N\ngithub: praveenn77\n*/lunr_client/* default */.A.tokenizer.separator=/[\\s\\-/]+/;class LunrSearchAdapter{constructor(searchDocs,searchIndex,baseUrl,maxHits){if(baseUrl===void 0){baseUrl=\'/\';}this.searchDocs=searchDocs;this.lunrIndex=lunr_client/* default */.A.Index.load(searchIndex);this.baseUrl=baseUrl;this.maxHits=maxHits;}getLunrResult(input){return this.lunrIndex.query(function(query){const tokens=lunr_client/* default */.A.tokenizer(input);query.term(tokens,{boost:10});query.term(tokens,{wildcard:lunr_client/* default */.A.Query.wildcard.TRAILING});});}getHit(doc,formattedTitle,formattedContent){return{hierarchy:{lvl0:doc.pageTitle||doc.title,lvl1:doc.type===0?null:doc.title},url:doc.url,version:doc.version,_snippetResult:formattedContent?{content:{value:formattedContent,matchLevel:"full"}}:null,_highlightResult:{hierarchy:{lvl0:{value:doc.type===0?formattedTitle||doc.title:doc.pageTitle},lvl1:doc.type===0?null:{value:formattedTitle||doc.title}}}};}getTitleHit(doc,position,length){const start=position[0];const end=position[0]+length;let formattedTitle=doc.title.substring(0,start)+\'<span class="algolia-docsearch-suggestion--highlight">\'+doc.title.substring(start,end)+\'</span>\'+doc.title.substring(end,doc.title.length);return this.getHit(doc,formattedTitle);}getKeywordHit(doc,position,length){const start=position[0];const end=position[0]+length;let formattedTitle=doc.title+\'<br /><i>Keywords: \'+doc.keywords.substring(0,start)+\'<span class="algolia-docsearch-suggestion--highlight">\'+doc.keywords.substring(start,end)+\'</span>\'+doc.keywords.substring(end,doc.keywords.length)+\'</i>\';return this.getHit(doc,formattedTitle);}getContentHit(doc,position){const start=position[0];const end=position[0]+position[1];let previewStart=start;let previewEnd=end;let ellipsesBefore=true;let ellipsesAfter=true;for(let k=0;k<3;k++){const nextSpace=doc.content.lastIndexOf(\' \',previewStart-2);const nextDot=doc.content.lastIndexOf(\'.\',previewStart-2);if(nextDot>0&&nextDot>nextSpace){previewStart=nextDot+1;ellipsesBefore=false;break;}if(nextSpace<0){previewStart=0;ellipsesBefore=false;break;}previewStart=nextSpace+1;}for(let k=0;k<10;k++){const nextSpace=doc.content.indexOf(\' \',previewEnd+1);const nextDot=doc.content.indexOf(\'.\',previewEnd+1);if(nextDot>0&&nextDot<nextSpace){previewEnd=nextDot;ellipsesAfter=false;break;}if(nextSpace<0){previewEnd=doc.content.length;ellipsesAfter=false;break;}previewEnd=nextSpace;}let preview=doc.content.substring(previewStart,start);if(ellipsesBefore){preview=\'... \'+preview;}preview+=\'<span class="algolia-docsearch-suggestion--highlight">\'+doc.content.substring(start,end)+\'</span>\';preview+=doc.content.substring(end,previewEnd);if(ellipsesAfter){preview+=\' ...\';}return this.getHit(doc,null,preview);}search(input){return new Promise((resolve,rej)=>{const results=this.getLunrResult(input);const hits=[];results.length>this.maxHits&&(results.length=this.maxHits);this.titleHitsRes=[];this.contentHitsRes=[];results.forEach(result=>{const doc=this.searchDocs[result.ref];const{metadata}=result.matchData;for(let i in metadata){if(metadata[i].title){if(!this.titleHitsRes.includes(result.ref)){const position=metadata[i].title.position[0];hits.push(this.getTitleHit(doc,position,input.length));this.titleHitsRes.push(result.ref);}}else if(metadata[i].content){const position=metadata[i].content.position[0];hits.push(this.getContentHit(doc,position));}else if(metadata[i].keywords){const position=metadata[i].keywords.position[0];hits.push(this.getKeywordHit(doc,position,input.length));this.titleHitsRes.push(result.ref);}}});hits.length>this.maxHits&&(hits.length=this.maxHits);resolve(hits);});}}/* harmony default export */ const lunar_search = (LunrSearchAdapter);\n// EXTERNAL MODULE: ./node_modules/autocomplete.js/index.js\nvar autocomplete_js = __webpack_require__(64498);\nvar autocomplete_js_default = /*#__PURE__*/__webpack_require__.n(autocomplete_js);\n;// ./node_modules/docusaurus-lunr-search/src/theme/SearchBar/templates.js\nconst prefix=\'algolia-docsearch\';const suggestionPrefix=`${prefix}-suggestion`;const footerPrefix=`${prefix}-footer`;/* eslint-disable max-len */const templates={suggestion:`\n  <a class="${suggestionPrefix}\n    {{#isCategoryHeader}}${suggestionPrefix}__main{{/isCategoryHeader}}\n    {{#isSubCategoryHeader}}${suggestionPrefix}__secondary{{/isSubCategoryHeader}}\n    "\n    aria-label="Link to the result"\n    href="{{{url}}}"\n    >\n    <div class="${suggestionPrefix}--category-header">\n        <span class="${suggestionPrefix}--category-header-lvl0">{{{category}}}</span>\n    </div>\n    <div class="${suggestionPrefix}--wrapper">\n      <div class="${suggestionPrefix}--subcategory-column">\n        <span class="${suggestionPrefix}--subcategory-column-text">{{{subcategory}}}</span>\n      </div>\n      {{#isTextOrSubcategoryNonEmpty}}\n      <div class="${suggestionPrefix}--content">\n        <div class="${suggestionPrefix}--subcategory-inline">{{{subcategory}}}</div>\n        <div class="${suggestionPrefix}--title">{{{title}}}</div>\n        {{#text}}<div class="${suggestionPrefix}--text">{{{text}}}</div>{{/text}}\n        {{#version}}<div class="${suggestionPrefix}--version">{{version}}</div>{{/version}}\n      </div>\n      {{/isTextOrSubcategoryNonEmpty}}\n    </div>\n  </a>\n  `,suggestionSimple:`\n  <div class="${suggestionPrefix}\n    {{#isCategoryHeader}}${suggestionPrefix}__main{{/isCategoryHeader}}\n    {{#isSubCategoryHeader}}${suggestionPrefix}__secondary{{/isSubCategoryHeader}}\n    suggestion-layout-simple\n  ">\n    <div class="${suggestionPrefix}--category-header">\n        {{^isLvl0}}\n        <span class="${suggestionPrefix}--category-header-lvl0 ${suggestionPrefix}--category-header-item">{{{category}}}</span>\n          {{^isLvl1}}\n          {{^isLvl1EmptyOrDuplicate}}\n          <span class="${suggestionPrefix}--category-header-lvl1 ${suggestionPrefix}--category-header-item">\n              {{{subcategory}}}\n          </span>\n          {{/isLvl1EmptyOrDuplicate}}\n          {{/isLvl1}}\n        {{/isLvl0}}\n        <div class="${suggestionPrefix}--title ${suggestionPrefix}--category-header-item">\n            {{#isLvl2}}\n                {{{title}}}\n            {{/isLvl2}}\n            {{#isLvl1}}\n                {{{subcategory}}}\n            {{/isLvl1}}\n            {{#isLvl0}}\n                {{{category}}}\n            {{/isLvl0}}\n        </div>\n    </div>\n    <div class="${suggestionPrefix}--wrapper">\n      {{#text}}\n      <div class="${suggestionPrefix}--content">\n        <div class="${suggestionPrefix}--text">{{{text}}}</div>\n      </div>\n      {{/text}}\n    </div>\n  </div>\n  `,footer:`\n    <div class="${footerPrefix}">\n    </div>\n  `,empty:`\n  <div class="${suggestionPrefix}">\n    <div class="${suggestionPrefix}--wrapper">\n        <div class="${suggestionPrefix}--content ${suggestionPrefix}--no-results">\n            <div class="${suggestionPrefix}--title">\n                <div class="${suggestionPrefix}--text">\n                    No results found for query <b>"{{query}}"</b>\n                </div>\n            </div>\n        </div>\n    </div>\n  </div>\n  `,searchBox:`\n  <form novalidate="novalidate" onsubmit="return false;" class="searchbox">\n    <div role="search" class="searchbox__wrapper">\n      <input id="docsearch" type="search" name="search" placeholder="Search the docs" autocomplete="off" required="required" class="searchbox__input"/>\n      <button type="submit" title="Submit your search query." class="searchbox__submit" >\n        <svg width=12 height=12 role="img" aria-label="Search">\n          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#sbx-icon-search-13"></use>\n        </svg>\n      </button>\n      <button type="reset" title="Clear the search query." class="searchbox__reset hide">\n        <svg width=12 height=12 role="img" aria-label="Reset">\n          <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#sbx-icon-clear-3"></use>\n        </svg>\n      </button>\n    </div>\n</form>\n\n<div class="svg-icons" style="height: 0; width: 0; position: absolute; visibility: hidden">\n  <svg xmlns="http://www.w3.org/2000/svg">\n    <symbol id="sbx-icon-clear-3" viewBox="0 0 40 40"><path d="M16.228 20L1.886 5.657 0 3.772 3.772 0l1.885 1.886L20 16.228 34.343 1.886 36.228 0 40 3.772l-1.886 1.885L23.772 20l14.342 14.343L40 36.228 36.228 40l-1.885-1.886L20 23.772 5.657 38.114 3.772 40 0 36.228l1.886-1.885L16.228 20z" fill-rule="evenodd"></symbol>\n    <symbol id="sbx-icon-search-13" viewBox="0 0 40 40"><path d="M26.806 29.012a16.312 16.312 0 0 1-10.427 3.746C7.332 32.758 0 25.425 0 16.378 0 7.334 7.333 0 16.38 0c9.045 0 16.378 7.333 16.378 16.38 0 3.96-1.406 7.593-3.746 10.426L39.547 37.34c.607.608.61 1.59-.004 2.203a1.56 1.56 0 0 1-2.202.004L26.807 29.012zm-10.427.627c7.322 0 13.26-5.938 13.26-13.26 0-7.324-5.938-13.26-13.26-13.26-7.324 0-13.26 5.936-13.26 13.26 0 7.322 5.936 13.26 13.26 13.26z" fill-rule="evenodd"></symbol>\n  </svg>\n</div>\n  `};/* harmony default export */ const SearchBar_templates = (templates);\n// EXTERNAL MODULE: ./node_modules/autocomplete.js/zepto.js\nvar zepto = __webpack_require__(53704);\nvar zepto_default = /*#__PURE__*/__webpack_require__.n(zepto);\n;// ./node_modules/docusaurus-lunr-search/src/theme/SearchBar/utils.js\nconst utils={/*\n  * Move the content of an object key one level higher.\n  * eg.\n  * {\n  *   name: \'My name\',\n  *   hierarchy: {\n  *     lvl0: \'Foo\',\n  *     lvl1: \'Bar\'\n  *   }\n  * }\n  * Will be converted to\n  * {\n  *   name: \'My name\',\n  *   lvl0: \'Foo\',\n  *   lvl1: \'Bar\'\n  * }\n  * @param {Object} object Main object\n  * @param {String} property Main object key to move up\n  * @return {Object}\n  * @throws Error when key is not an attribute of Object or is not an object itself\n  */mergeKeyWithParent(object,property){if(object[property]===undefined){return object;}if(typeof object[property]!==\'object\'){return object;}const newObject=zepto_default().extend({},object,object[property]);delete newObject[property];return newObject;},/*\n  * Group all objects of a collection by the value of the specified attribute\n  * If the attribute is a string, use the lowercase form.\n  *\n  * eg.\n  * groupBy([\n  *   {name: \'Tim\', category: \'dev\'},\n  *   {name: \'Vincent\', category: \'dev\'},\n  *   {name: \'Ben\', category: \'sales\'},\n  *   {name: \'Jeremy\', category: \'sales\'},\n  *   {name: \'AlexS\', category: \'dev\'},\n  *   {name: \'AlexK\', category: \'sales\'}\n  * ], \'category\');\n  * =>\n  * {\n  *   \'devs\': [\n  *     {name: \'Tim\', category: \'dev\'},\n  *     {name: \'Vincent\', category: \'dev\'},\n  *     {name: \'AlexS\', category: \'dev\'}\n  *   ],\n  *   \'sales\': [\n  *     {name: \'Ben\', category: \'sales\'},\n  *     {name: \'Jeremy\', category: \'sales\'},\n  *     {name: \'AlexK\', category: \'sales\'}\n  *   ]\n  * }\n  * @param {array} collection Array of objects to group\n  * @param {String} property The attribute on which apply the grouping\n  * @return {array}\n  * @throws Error when one of the element does not have the specified property\n  */groupBy(collection,property){const newCollection={};zepto_default().each(collection,(index,item)=>{if(item[property]===undefined){throw new Error(`[groupBy]: Object has no key ${property}`);}let key=item[property];if(typeof key===\'string\'){key=key.toLowerCase();}// fix #171 the given data type of docsearch hits might be conflict with the properties of the native Object,\n// such as the constructor, so we need to do this check.\nif(!Object.prototype.hasOwnProperty.call(newCollection,key)){newCollection[key]=[];}newCollection[key].push(item);});return newCollection;},/*\n  * Return an array of all the values of the specified object\n  * eg.\n  * values({\n  *   foo: 42,\n  *   bar: true,\n  *   baz: \'yep\'\n  * })\n  * =>\n  * [42, true, yep]\n  * @param {object} object Object to extract values from\n  * @return {array}\n  */values(object){return Object.keys(object).map(key=>object[key]);},/*\n  * Flattens an array\n  * eg.\n  * flatten([1, 2, [3, 4], [5, 6]])\n  * =>\n  * [1, 2, 3, 4, 5, 6]\n  * @param {array} array Array to flatten\n  * @return {array}\n  */flatten(array){const results=[];array.forEach(value=>{if(!Array.isArray(value)){results.push(value);return;}value.forEach(subvalue=>{results.push(subvalue);});});return results;},/*\n  * Flatten all values of an object into an array, marking each first element of\n  * each group with a specific flag\n  * eg.\n  * flattenAndFlagFirst({\n  *   \'devs\': [\n  *     {name: \'Tim\', category: \'dev\'},\n  *     {name: \'Vincent\', category: \'dev\'},\n  *     {name: \'AlexS\', category: \'dev\'}\n  *   ],\n  *   \'sales\': [\n  *     {name: \'Ben\', category: \'sales\'},\n  *     {name: \'Jeremy\', category: \'sales\'},\n  *     {name: \'AlexK\', category: \'sales\'}\n  *   ]\n  * , \'isTop\');\n  * =>\n  * [\n  *     {name: \'Tim\', category: \'dev\', isTop: true},\n  *     {name: \'Vincent\', category: \'dev\', isTop: false},\n  *     {name: \'AlexS\', category: \'dev\', isTop: false},\n  *     {name: \'Ben\', category: \'sales\', isTop: true},\n  *     {name: \'Jeremy\', category: \'sales\', isTop: false},\n  *     {name: \'AlexK\', category: \'sales\', isTop: false}\n  * ]\n  * @param {object} object Object to flatten\n  * @param {string} flag Flag to set to true on first element of each group\n  * @return {array}\n  */flattenAndFlagFirst(object,flag){const values=this.values(object).map(collection=>collection.map((item,index)=>{// eslint-disable-next-line no-param-reassign\nitem[flag]=index===0;return item;}));return this.flatten(values);},/*\n  * Removes all empty strings, null, false and undefined elements array\n  * eg.\n  * compact([42, false, null, undefined, \'\', [], \'foo\']);\n  * =>\n  * [42, [], \'foo\']\n  * @param {array} array Array to compact\n  * @return {array}\n  */compact(array){const results=[];array.forEach(value=>{if(!value){return;}results.push(value);});return results;},/*\n   * Returns the highlighted value of the specified key in the specified object.\n   * If no highlighted value is available, will return the key value directly\n   * eg.\n   * getHighlightedValue({\n   *    _highlightResult: {\n   *      text: {\n   *        value: \'<mark>foo</mark>\'\n   *      }\n   *    },\n   *    text: \'foo\'\n   * }, \'text\');\n   * =>\n   * \'<mark>foo</mark>\'\n   * @param {object} object Hit object returned by the Algolia API\n   * @param {string} property Object key to look for\n   * @return {string}\n   **/getHighlightedValue(object,property){if(object._highlightResult&&object._highlightResult.hierarchy_camel&&object._highlightResult.hierarchy_camel[property]&&object._highlightResult.hierarchy_camel[property].matchLevel&&object._highlightResult.hierarchy_camel[property].matchLevel!==\'none\'&&object._highlightResult.hierarchy_camel[property].value){return object._highlightResult.hierarchy_camel[property].value;}if(object._highlightResult&&object._highlightResult&&object._highlightResult[property]&&object._highlightResult[property].value){return object._highlightResult[property].value;}return object[property];},/*\n   * Returns the snippeted value of the specified key in the specified object.\n   * If no highlighted value is available, will return the key value directly.\n   * Will add starting and ending ellipsis (\u2026) if we detect that a sentence is\n   * incomplete\n   * eg.\n   * getSnippetedValue({\n   *    _snippetResult: {\n   *      text: {\n   *        value: \'<mark>This is an unfinished sentence</mark>\'\n   *      }\n   *    },\n   *    text: \'This is an unfinished sentence\'\n   * }, \'text\');\n   * =>\n   * \'<mark>This is an unfinished sentence</mark>\u2026\'\n   * @param {object} object Hit object returned by the Algolia API\n   * @param {string} property Object key to look for\n   * @return {string}\n   **/getSnippetedValue(object,property){if(!object._snippetResult||!object._snippetResult[property]||!object._snippetResult[property].value){return object[property];}let snippet=object._snippetResult[property].value;if(snippet[0]!==snippet[0].toUpperCase()){snippet=`\u2026${snippet}`;}if([\'.\',\'!\',\'?\'].indexOf(snippet[snippet.length-1])===-1){snippet=`${snippet}\u2026`;}return snippet;},/*\n  * Deep clone an object.\n  * Note: This will not clone functions and dates\n  * @param {object} object Object to clone\n  * @return {object}\n  */deepClone(object){return JSON.parse(JSON.stringify(object));}};/* harmony default export */ const SearchBar_utils = (utils);\n;// ./node_modules/docusaurus-lunr-search/src/theme/SearchBar/DocSearch.js\nclass DocSearch{constructor(_ref){let{searchDocs,searchIndex,inputSelector,debug=false,baseUrl=\'/\',queryDataCallback=null,autocompleteOptions={debug:false,hint:false,autoselect:true},transformData=false,queryHook=false,handleSelected=false,enhancedSearchInput=false,layout="column",maxHits=5}=_ref;this.input=DocSearch.getInputFromSelector(inputSelector);this.queryDataCallback=queryDataCallback||null;const autocompleteOptionsDebug=autocompleteOptions&&autocompleteOptions.debug?autocompleteOptions.debug:false;// eslint-disable-next-line no-param-reassign\nautocompleteOptions.debug=debug||autocompleteOptionsDebug;this.autocompleteOptions=autocompleteOptions;this.autocompleteOptions.cssClasses=this.autocompleteOptions.cssClasses||{};this.autocompleteOptions.cssClasses.prefix=this.autocompleteOptions.cssClasses.prefix||"ds";const inputAriaLabel=this.input&&typeof this.input.attr==="function"&&this.input.attr("aria-label");this.autocompleteOptions.ariaLabel=this.autocompleteOptions.ariaLabel||inputAriaLabel||"search input";this.isSimpleLayout=layout==="simple";this.client=new lunar_search(searchDocs,searchIndex,baseUrl,maxHits);if(enhancedSearchInput){this.input=DocSearch.injectSearchBox(this.input);}this.autocomplete=autocomplete_js_default()(this.input,autocompleteOptions,[{source:this.getAutocompleteSource(transformData,queryHook),templates:{suggestion:DocSearch.getSuggestionTemplate(this.isSimpleLayout),footer:SearchBar_templates.footer,empty:DocSearch.getEmptyTemplate()}}]);const customHandleSelected=handleSelected;this.handleSelected=customHandleSelected||this.handleSelected;// We prevent default link clicking if a custom handleSelected is defined\nif(customHandleSelected){zepto_default()(".algolia-autocomplete").on("click",".ds-suggestions a",event=>{event.preventDefault();});}this.autocomplete.on("autocomplete:selected",this.handleSelected.bind(null,this.autocomplete.autocomplete));this.autocomplete.on("autocomplete:shown",this.handleShown.bind(null,this.input));if(enhancedSearchInput){DocSearch.bindSearchBoxEvent();}// Ctrl/Cmd + K should focus the search bar, emulating the Algolia search UI\ndocument.addEventListener(\'keydown\',e=>{if((e.ctrlKey||e.metaKey)&&e.key==\'k\'){this.input.focus();// By default, using Ctrl + K in Chrome will open the location bar, so disable this\ne.preventDefault();}});}static injectSearchBox(input){input.before(SearchBar_templates.searchBox);const newInput=input.prev().prev().find("input");input.remove();return newInput;}static bindSearchBoxEvent(){zepto_default()(\'.searchbox [type="reset"]\').on("click",function(){zepto_default()("input#docsearch").focus();zepto_default()(this).addClass("hide");autocomplete_js_default().autocomplete.setVal("");});zepto_default()("input#docsearch").on("keyup",()=>{const searchbox=document.querySelector("input#docsearch");const reset=document.querySelector(\'.searchbox [type="reset"]\');reset.className="searchbox__reset";if(searchbox.value.length===0){reset.className+=" hide";}});}/**\n     * Returns the matching input from a CSS selector, null if none matches\n     * @function getInputFromSelector\n     * @param  {string} selector CSS selector that matches the search\n     * input of the page\n     * @returns {void}\n     */static getInputFromSelector(selector){const input=zepto_default()(selector).filter("input");return input.length?zepto_default()(input[0]):null;}/**\n     * Returns the `source` method to be passed to autocomplete.js. It will query\n     * the Algolia index and call the callbacks with the formatted hits.\n     * @function getAutocompleteSource\n     * @param  {function} transformData An optional function to transform the hits\n     * @param {function} queryHook An optional function to transform the query\n     * @returns {function} Method to be passed as the `source` option of\n     * autocomplete\n     */getAutocompleteSource(transformData,queryHook){return(query,callback)=>{if(queryHook){// eslint-disable-next-line no-param-reassign\nquery=queryHook(query)||query;}this.client.search(query).then(hits=>{if(this.queryDataCallback&&typeof this.queryDataCallback=="function"){this.queryDataCallback(hits);}if(transformData){hits=transformData(hits)||hits;}callback(DocSearch.formatHits(hits));});};}// Given a list of hits returned by the API, will reformat them to be used in\n// a Hogan template\nstatic formatHits(receivedHits){const clonedHits=SearchBar_utils.deepClone(receivedHits);const hits=clonedHits.map(hit=>{if(hit._highlightResult){// eslint-disable-next-line no-param-reassign\nhit._highlightResult=SearchBar_utils.mergeKeyWithParent(hit._highlightResult,"hierarchy");}return SearchBar_utils.mergeKeyWithParent(hit,"hierarchy");});// Group hits by category / subcategory\nlet groupedHits=SearchBar_utils.groupBy(hits,"lvl0");zepto_default().each(groupedHits,(level,collection)=>{const groupedHitsByLvl1=SearchBar_utils.groupBy(collection,"lvl1");const flattenedHits=SearchBar_utils.flattenAndFlagFirst(groupedHitsByLvl1,"isSubCategoryHeader");groupedHits[level]=flattenedHits;});groupedHits=SearchBar_utils.flattenAndFlagFirst(groupedHits,"isCategoryHeader");// Translate hits into smaller objects to be send to the template\nreturn groupedHits.map(hit=>{const url=DocSearch.formatURL(hit);const category=SearchBar_utils.getHighlightedValue(hit,"lvl0");const subcategory=SearchBar_utils.getHighlightedValue(hit,"lvl1")||category;const displayTitle=SearchBar_utils.compact([SearchBar_utils.getHighlightedValue(hit,"lvl2")||subcategory,SearchBar_utils.getHighlightedValue(hit,"lvl3"),SearchBar_utils.getHighlightedValue(hit,"lvl4"),SearchBar_utils.getHighlightedValue(hit,"lvl5"),SearchBar_utils.getHighlightedValue(hit,"lvl6")]).join(\'<span class="aa-suggestion-title-separator" aria-hidden="true"> \u203a </span>\');const text=SearchBar_utils.getSnippetedValue(hit,"content");const isTextOrSubcategoryNonEmpty=subcategory&&subcategory!==""||displayTitle&&displayTitle!=="";const isLvl1EmptyOrDuplicate=!subcategory||subcategory===""||subcategory===category;const isLvl2=displayTitle&&displayTitle!==""&&displayTitle!==subcategory;const isLvl1=!isLvl2&&subcategory&&subcategory!==""&&subcategory!==category;const isLvl0=!isLvl1&&!isLvl2;const version=hit.version;return{isLvl0,isLvl1,isLvl2,isLvl1EmptyOrDuplicate,isCategoryHeader:hit.isCategoryHeader,isSubCategoryHeader:hit.isSubCategoryHeader,isTextOrSubcategoryNonEmpty,category,subcategory,title:displayTitle,text,url,version};});}static formatURL(hit){const{url,anchor}=hit;if(url){const containsAnchor=url.indexOf("#")!==-1;if(containsAnchor)return url;else if(anchor)return`${hit.url}#${hit.anchor}`;return url;}else if(anchor)return`#${hit.anchor}`;/* eslint-disable */console.warn("no anchor nor url for : ",JSON.stringify(hit));/* eslint-enable */return null;}static getEmptyTemplate(){return args=>hogan_default().compile(SearchBar_templates.empty).render(args);}static getSuggestionTemplate(isSimpleLayout){const stringTemplate=isSimpleLayout?SearchBar_templates.suggestionSimple:SearchBar_templates.suggestion;const template=hogan_default().compile(stringTemplate);return suggestion=>template.render(suggestion);}handleSelected(input,event,suggestion,datasetNumber,context){if(context===void 0){context={};}// Do nothing if click on the suggestion, as it\'s already a <a href>, the\n// browser will take care of it. This allow Ctrl-Clicking on results and not\n// having the main window being redirected as well\nif(context.selectionMethod==="click"){return;}input.setVal("");window.location.assign(suggestion.url);}handleShown(input){const middleOfInput=input.offset().left+input.width()/2;let middleOfWindow=zepto_default()(document).width()/2;if(isNaN(middleOfWindow)){middleOfWindow=900;}const alignClass=middleOfInput-middleOfWindow>=0?"algolia-autocomplete-right":"algolia-autocomplete-left";const otherAlignClass=middleOfInput-middleOfWindow<0?"algolia-autocomplete-right":"algolia-autocomplete-left";const autocompleteWrapper=zepto_default()(".algolia-autocomplete");if(!autocompleteWrapper.hasClass(alignClass)){autocompleteWrapper.addClass(alignClass);}if(autocompleteWrapper.hasClass(otherAlignClass)){autocompleteWrapper.removeClass(otherAlignClass);}}}/* harmony default export */ const SearchBar_DocSearch = (DocSearch);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFVLENBQUMsQ0FDNUMsQ0FFQSxHQUFJRSxtQkFBbUIsQ0FBQ0MsUUFBUSxDQUFDRixlQUFlLENBQUMsQ0FBRSxDQUMvQ0MsbUJBQW1CLENBQUNFLFdBQVcsQ0FBQ0gsZUFBZSxDQUFDLENBQ3BELENBQ0osQ0FDSixDQUVBLDBEQUFlakcsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvZG9jdXNhdXJ1cy1sdW5yLXNlYXJjaC9zcmMvdGhlbWUvU2VhcmNoQmFyL2x1bmFyLXNlYXJjaC5qcz9kMDljIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvZG9jdXNhdXJ1cy1sdW5yLXNlYXJjaC9zcmMvdGhlbWUvU2VhcmNoQmFyL3RlbXBsYXRlcy5qcz8yYTI1Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvZG9jdXNhdXJ1cy1sdW5yLXNlYXJjaC9zcmMvdGhlbWUvU2VhcmNoQmFyL3V0aWxzLmpzP2Y2MjIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9kb2N1c2F1cnVzLWx1bnItc2VhcmNoL3NyYy90aGVtZS9TZWFyY2hCYXIvRG9jU2VhcmNoLmpzP2ExNTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkFsb2dsaWEgRG9jU2VhcmNoIEFkYXB0ZXIgZm9yIEx1bnIuanNcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuV3JpdHRlbiBieTogIFByYXZlZW4gTlxuZ2l0aHViOiBwcmF2ZWVubjc3XG4qL1xuXG5pbXBvcnQgbHVuciBmcm9tIFwiQGdlbmVyYXRlZC9sdW5yLmNsaWVudFwiO1xubHVuci50b2tlbml6ZXIuc2VwYXJhdG9yID0gL1tcXHNcXC0vXSsvO1xuXG5jbGFzcyBMdW5yU2VhcmNoQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VhcmNoRG9jcywgc2VhcmNoSW5kZXgsIGJhc2VVcmwgPSAnLycsIG1heEhpdHMpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hEb2NzID0gc2VhcmNoRG9jcztcbiAgICAgICAgdGhpcy5sdW5ySW5kZXggPSBsdW5yLkluZGV4LmxvYWQoc2VhcmNoSW5kZXgpO1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgICB0aGlzLm1heEhpdHMgPSBtYXhIaXRzO1xuICAgIH1cblxuICAgIGdldEx1bnJSZXN1bHQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubHVuckluZGV4LnF1ZXJ5KGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gbHVuci50b2tlbml6ZXIoaW5wdXQpO1xuICAgICAgICAgICAgcXVlcnkudGVybSh0b2tlbnMsIHtcbiAgICAgICAgICAgICAgICBib29zdDogMTBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcXVlcnkudGVybSh0b2tlbnMsIHtcbiAgICAgICAgICAgICAgICB3aWxkY2FyZDogbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElOR1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldEhpdChkb2MsIGZvcm1hdHRlZFRpdGxlLCBmb3JtYXR0ZWRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWVyYXJjaHk6IHtcbiAgICAgICAgICAgICAgICBsdmwwOiBkb2MucGFnZVRpdGxlIHx8IGRvYy50aXRsZSxcbiAgICAgICAgICAgICAgICBsdmwxOiBkb2MudHlwZSA9PT0gMCA/IG51bGwgOiBkb2MudGl0bGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cmw6IGRvYy51cmwsXG4gICAgICAgICAgICB2ZXJzaW9uOiBkb2MudmVyc2lvbixcbiAgICAgICAgICAgIF9zbmlwcGV0UmVzdWx0OiBmb3JtYXR0ZWRDb250ZW50ID8ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGZvcm1hdHRlZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoTGV2ZWw6IFwiZnVsbFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSA6IG51bGwsXG4gICAgICAgICAgICBfaGlnaGxpZ2h0UmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgaGllcmFyY2h5OiB7XG4gICAgICAgICAgICAgICAgICAgIGx2bDA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBkb2MudHlwZSA9PT0gMCA/IGZvcm1hdHRlZFRpdGxlIHx8IGRvYy50aXRsZSA6IGRvYy5wYWdlVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGx2bDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MudHlwZSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZm9ybWF0dGVkVGl0bGUgfHwgZG9jLnRpdGxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0VGl0bGVIaXQoZG9jLCBwb3NpdGlvbiwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb25bMF07XG4gICAgICAgIGNvbnN0IGVuZCA9IHBvc2l0aW9uWzBdICsgbGVuZ3RoO1xuICAgICAgICBsZXQgZm9ybWF0dGVkVGl0bGUgPSBkb2MudGl0bGUuc3Vic3RyaW5nKDAsIHN0YXJ0KSArICc8c3BhbiBjbGFzcz1cImFsZ29saWEtZG9jc2VhcmNoLXN1Z2dlc3Rpb24tLWhpZ2hsaWdodFwiPicgKyBkb2MudGl0bGUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpICsgJzwvc3Bhbj4nICsgZG9jLnRpdGxlLnN1YnN0cmluZyhlbmQsIGRvYy50aXRsZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIaXQoZG9jLCBmb3JtYXR0ZWRUaXRsZSlcbiAgICB9XG5cbiAgICBnZXRLZXl3b3JkSGl0KGRvYywgcG9zaXRpb24sIGxlbmd0aCkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHBvc2l0aW9uWzBdO1xuICAgICAgICBjb25zdCBlbmQgPSBwb3NpdGlvblswXSArIGxlbmd0aDtcbiAgICAgICAgbGV0IGZvcm1hdHRlZFRpdGxlID0gZG9jLnRpdGxlICsgJzxiciAvPjxpPktleXdvcmRzOiAnICsgZG9jLmtleXdvcmRzLnN1YnN0cmluZygwLCBzdGFydCkgKyAnPHNwYW4gY2xhc3M9XCJhbGdvbGlhLWRvY3NlYXJjaC1zdWdnZXN0aW9uLS1oaWdobGlnaHRcIj4nICsgZG9jLmtleXdvcmRzLnN1YnN0cmluZyhzdGFydCwgZW5kKSArICc8L3NwYW4+JyArIGRvYy5rZXl3b3Jkcy5zdWJzdHJpbmcoZW5kLCBkb2Mua2V5d29yZHMubGVuZ3RoKSArICc8L2k+J1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIaXQoZG9jLCBmb3JtYXR0ZWRUaXRsZSlcbiAgICB9XG5cbiAgICBnZXRDb250ZW50SGl0KGRvYywgcG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwb3NpdGlvblswXTtcbiAgICAgICAgY29uc3QgZW5kID0gcG9zaXRpb25bMF0gKyBwb3NpdGlvblsxXTtcbiAgICAgICAgbGV0IHByZXZpZXdTdGFydCA9IHN0YXJ0O1xuICAgICAgICBsZXQgcHJldmlld0VuZCA9IGVuZDtcbiAgICAgICAgbGV0IGVsbGlwc2VzQmVmb3JlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGVsbGlwc2VzQWZ0ZXIgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDM7IGsrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dFNwYWNlID0gZG9jLmNvbnRlbnQubGFzdEluZGV4T2YoJyAnLCBwcmV2aWV3U3RhcnQgLSAyKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREb3QgPSBkb2MuY29udGVudC5sYXN0SW5kZXhPZignLicsIHByZXZpZXdTdGFydCAtIDIpO1xuICAgICAgICAgICAgaWYgKChuZXh0RG90ID4gMCkgJiYgKG5leHREb3QgPiBuZXh0U3BhY2UpKSB7XG4gICAgICAgICAgICAgICAgcHJldmlld1N0YXJ0ID0gbmV4dERvdCArIDE7XG4gICAgICAgICAgICAgICAgZWxsaXBzZXNCZWZvcmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0U3BhY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgcHJldmlld1N0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBlbGxpcHNlc0JlZm9yZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlld1N0YXJ0ID0gbmV4dFNwYWNlICsgMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IDEwOyBrKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTcGFjZSA9IGRvYy5jb250ZW50LmluZGV4T2YoJyAnLCBwcmV2aWV3RW5kICsgMSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RG90ID0gZG9jLmNvbnRlbnQuaW5kZXhPZignLicsIHByZXZpZXdFbmQgKyAxKTtcbiAgICAgICAgICAgIGlmICgobmV4dERvdCA+IDApICYmIChuZXh0RG90IDwgbmV4dFNwYWNlKSkge1xuICAgICAgICAgICAgICAgIHByZXZpZXdFbmQgPSBuZXh0RG90O1xuICAgICAgICAgICAgICAgIGVsbGlwc2VzQWZ0ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0U3BhY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgcHJldmlld0VuZCA9IGRvYy5jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBlbGxpcHNlc0FmdGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aWV3RW5kID0gbmV4dFNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2aWV3ID0gZG9jLmNvbnRlbnQuc3Vic3RyaW5nKHByZXZpZXdTdGFydCwgc3RhcnQpO1xuICAgICAgICBpZiAoZWxsaXBzZXNCZWZvcmUpIHtcbiAgICAgICAgICAgIHByZXZpZXcgPSAnLi4uICcgKyBwcmV2aWV3O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpZXcgKz0gJzxzcGFuIGNsYXNzPVwiYWxnb2xpYS1kb2NzZWFyY2gtc3VnZ2VzdGlvbi0taGlnaGxpZ2h0XCI+JyArIGRvYy5jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKSArICc8L3NwYW4+JztcbiAgICAgICAgcHJldmlldyArPSBkb2MuY29udGVudC5zdWJzdHJpbmcoZW5kLCBwcmV2aWV3RW5kKTtcbiAgICAgICAgaWYgKGVsbGlwc2VzQWZ0ZXIpIHtcbiAgICAgICAgICAgIHByZXZpZXcgKz0gJyAuLi4nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhpdChkb2MsIG51bGwsIHByZXZpZXcpO1xuXG4gICAgfVxuICAgIHNlYXJjaChpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuZ2V0THVuclJlc3VsdChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBoaXRzID0gW107XG4gICAgICAgICAgICByZXN1bHRzLmxlbmd0aCA+IHRoaXMubWF4SGl0cyAmJiAocmVzdWx0cy5sZW5ndGggPSB0aGlzLm1heEhpdHMpO1xuICAgICAgICAgICAgdGhpcy50aXRsZUhpdHNSZXMgPSBbXVxuICAgICAgICAgICAgdGhpcy5jb250ZW50SGl0c1JlcyA9IFtdXG4gICAgICAgICAgICByZXN1bHRzLmZvckVhY2gocmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB0aGlzLnNlYXJjaERvY3NbcmVzdWx0LnJlZl07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtZXRhZGF0YSB9ID0gcmVzdWx0Lm1hdGNoRGF0YTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpIGluIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YVtpXS50aXRsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnRpdGxlSGl0c1Jlcy5pbmNsdWRlcyhyZXN1bHQucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWV0YWRhdGFbaV0udGl0bGUucG9zaXRpb25bMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRzLnB1c2godGhpcy5nZXRUaXRsZUhpdChkb2MsIHBvc2l0aW9uLCBpbnB1dC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpdGxlSGl0c1Jlcy5wdXNoKHJlc3VsdC5yZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhW2ldLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWV0YWRhdGFbaV0uY29udGVudC5wb3NpdGlvblswXVxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0cy5wdXNoKHRoaXMuZ2V0Q29udGVudEhpdChkb2MsIHBvc2l0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhZGF0YVtpXS5rZXl3b3Jkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtZXRhZGF0YVtpXS5rZXl3b3Jkcy5wb3NpdGlvblswXVxuICAgICAgICAgICAgICAgICAgICAgICAgaGl0cy5wdXNoKHRoaXMuZ2V0S2V5d29yZEhpdChkb2MsIHBvc2l0aW9uLCBpbnB1dC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGl0bGVIaXRzUmVzLnB1c2gocmVzdWx0LnJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhpdHMubGVuZ3RoID4gdGhpcy5tYXhIaXRzICYmIChoaXRzLmxlbmd0aCA9IHRoaXMubWF4SGl0cyk7XG4gICAgICAgICAgICByZXNvbHZlKGhpdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEx1bnJTZWFyY2hBZGFwdGVyO1xuIiwiY29uc3QgcHJlZml4ID0gJ2FsZ29saWEtZG9jc2VhcmNoJztcbmNvbnN0IHN1Z2dlc3Rpb25QcmVmaXggPSBgJHtwcmVmaXh9LXN1Z2dlc3Rpb25gO1xuY29uc3QgZm9vdGVyUHJlZml4ID0gYCR7cHJlZml4fS1mb290ZXJgO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbmNvbnN0IHRlbXBsYXRlcyA9IHtcbiAgc3VnZ2VzdGlvbjogYFxuICA8YSBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH1cbiAgICB7eyNpc0NhdGVnb3J5SGVhZGVyfX0ke3N1Z2dlc3Rpb25QcmVmaXh9X19tYWlue3svaXNDYXRlZ29yeUhlYWRlcn19XG4gICAge3sjaXNTdWJDYXRlZ29yeUhlYWRlcn19JHtzdWdnZXN0aW9uUHJlZml4fV9fc2Vjb25kYXJ5e3svaXNTdWJDYXRlZ29yeUhlYWRlcn19XG4gICAgXCJcbiAgICBhcmlhLWxhYmVsPVwiTGluayB0byB0aGUgcmVzdWx0XCJcbiAgICBocmVmPVwie3t7dXJsfX19XCJcbiAgICA+XG4gICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlclwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlci1sdmwwXCI+e3t7Y2F0ZWdvcnl9fX08L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLXdyYXBwZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9LS1zdWJjYXRlZ29yeS1jb2x1bW5cIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9LS1zdWJjYXRlZ29yeS1jb2x1bW4tdGV4dFwiPnt7e3N1YmNhdGVnb3J5fX19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICB7eyNpc1RleHRPclN1YmNhdGVnb3J5Tm9uRW1wdHl9fVxuICAgICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNvbnRlbnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLXN1YmNhdGVnb3J5LWlubGluZVwiPnt7e3N1YmNhdGVnb3J5fX19PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9LS10aXRsZVwiPnt7e3RpdGxlfX19PC9kaXY+XG4gICAgICAgIHt7I3RleHR9fTxkaXYgY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9LS10ZXh0XCI+e3t7dGV4dH19fTwvZGl2Pnt7L3RleHR9fVxuICAgICAgICB7eyN2ZXJzaW9ufX08ZGl2IGNsYXNzPVwiJHtzdWdnZXN0aW9uUHJlZml4fS0tdmVyc2lvblwiPnt7dmVyc2lvbn19PC9kaXY+e3svdmVyc2lvbn19XG4gICAgICA8L2Rpdj5cbiAgICAgIHt7L2lzVGV4dE9yU3ViY2F0ZWdvcnlOb25FbXB0eX19XG4gICAgPC9kaXY+XG4gIDwvYT5cbiAgYCxcbiAgc3VnZ2VzdGlvblNpbXBsZTogYFxuICA8ZGl2IGNsYXNzPVwiJHtzdWdnZXN0aW9uUHJlZml4fVxuICAgIHt7I2lzQ2F0ZWdvcnlIZWFkZXJ9fSR7c3VnZ2VzdGlvblByZWZpeH1fX21haW57ey9pc0NhdGVnb3J5SGVhZGVyfX1cbiAgICB7eyNpc1N1YkNhdGVnb3J5SGVhZGVyfX0ke3N1Z2dlc3Rpb25QcmVmaXh9X19zZWNvbmRhcnl7ey9pc1N1YkNhdGVnb3J5SGVhZGVyfX1cbiAgICBzdWdnZXN0aW9uLWxheW91dC1zaW1wbGVcbiAgXCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlclwiPlxuICAgICAgICB7e15pc0x2bDB9fVxuICAgICAgICA8c3BhbiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlci1sdmwwICR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlci1pdGVtXCI+e3t7Y2F0ZWdvcnl9fX08L3NwYW4+XG4gICAgICAgICAge3teaXNMdmwxfX1cbiAgICAgICAgICB7e15pc0x2bDFFbXB0eU9yRHVwbGljYXRlfX1cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlci1sdmwxICR7c3VnZ2VzdGlvblByZWZpeH0tLWNhdGVnb3J5LWhlYWRlci1pdGVtXCI+XG4gICAgICAgICAgICAgIHt7e3N1YmNhdGVnb3J5fX19XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIHt7L2lzTHZsMUVtcHR5T3JEdXBsaWNhdGV9fVxuICAgICAgICAgIHt7L2lzTHZsMX19XG4gICAgICAgIHt7L2lzTHZsMH19XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9LS10aXRsZSAke3N1Z2dlc3Rpb25QcmVmaXh9LS1jYXRlZ29yeS1oZWFkZXItaXRlbVwiPlxuICAgICAgICAgICAge3sjaXNMdmwyfX1cbiAgICAgICAgICAgICAgICB7e3t0aXRsZX19fVxuICAgICAgICAgICAge3svaXNMdmwyfX1cbiAgICAgICAgICAgIHt7I2lzTHZsMX19XG4gICAgICAgICAgICAgICAge3t7c3ViY2F0ZWdvcnl9fX1cbiAgICAgICAgICAgIHt7L2lzTHZsMX19XG4gICAgICAgICAgICB7eyNpc0x2bDB9fVxuICAgICAgICAgICAgICAgIHt7e2NhdGVnb3J5fX19XG4gICAgICAgICAgICB7ey9pc0x2bDB9fVxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiJHtzdWdnZXN0aW9uUHJlZml4fS0td3JhcHBlclwiPlxuICAgICAge3sjdGV4dH19XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtzdWdnZXN0aW9uUHJlZml4fS0tY29udGVudFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHtzdWdnZXN0aW9uUHJlZml4fS0tdGV4dFwiPnt7e3RleHR9fX08L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAge3svdGV4dH19XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuICBgLFxuICBmb290ZXI6IGBcbiAgICA8ZGl2IGNsYXNzPVwiJHtmb290ZXJQcmVmaXh9XCI+XG4gICAgPC9kaXY+XG4gIGAsXG4gIGVtcHR5OiBgXG4gIDxkaXYgY2xhc3M9XCIke3N1Z2dlc3Rpb25QcmVmaXh9XCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLXdyYXBwZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLWNvbnRlbnQgJHtzdWdnZXN0aW9uUHJlZml4fS0tbm8tcmVzdWx0c1wiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLXRpdGxlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7c3VnZ2VzdGlvblByZWZpeH0tLXRleHRcIj5cbiAgICAgICAgICAgICAgICAgICAgTm8gcmVzdWx0cyBmb3VuZCBmb3IgcXVlcnkgPGI+XCJ7e3F1ZXJ5fX1cIjwvYj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIGAsXG4gIHNlYXJjaEJveDogYFxuICA8Zm9ybSBub3ZhbGlkYXRlPVwibm92YWxpZGF0ZVwiIG9uc3VibWl0PVwicmV0dXJuIGZhbHNlO1wiIGNsYXNzPVwic2VhcmNoYm94XCI+XG4gICAgPGRpdiByb2xlPVwic2VhcmNoXCIgY2xhc3M9XCJzZWFyY2hib3hfX3dyYXBwZXJcIj5cbiAgICAgIDxpbnB1dCBpZD1cImRvY3NlYXJjaFwiIHR5cGU9XCJzZWFyY2hcIiBuYW1lPVwic2VhcmNoXCIgcGxhY2Vob2xkZXI9XCJTZWFyY2ggdGhlIGRvY3NcIiBhdXRvY29tcGxldGU9XCJvZmZcIiByZXF1aXJlZD1cInJlcXVpcmVkXCIgY2xhc3M9XCJzZWFyY2hib3hfX2lucHV0XCIvPlxuICAgICAgPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgdGl0bGU9XCJTdWJtaXQgeW91ciBzZWFyY2ggcXVlcnkuXCIgY2xhc3M9XCJzZWFyY2hib3hfX3N1Ym1pdFwiID5cbiAgICAgICAgPHN2ZyB3aWR0aD0xMiBoZWlnaHQ9MTIgcm9sZT1cImltZ1wiIGFyaWEtbGFiZWw9XCJTZWFyY2hcIj5cbiAgICAgICAgICA8dXNlIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHhsaW5rOmhyZWY9XCIjc2J4LWljb24tc2VhcmNoLTEzXCI+PC91c2U+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8YnV0dG9uIHR5cGU9XCJyZXNldFwiIHRpdGxlPVwiQ2xlYXIgdGhlIHNlYXJjaCBxdWVyeS5cIiBjbGFzcz1cInNlYXJjaGJveF9fcmVzZXQgaGlkZVwiPlxuICAgICAgICA8c3ZnIHdpZHRoPTEyIGhlaWdodD0xMiByb2xlPVwiaW1nXCIgYXJpYS1sYWJlbD1cIlJlc2V0XCI+XG4gICAgICAgICAgPHVzZSB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4bGluazpocmVmPVwiI3NieC1pY29uLWNsZWFyLTNcIj48L3VzZT5cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2J1dHRvbj5cbiAgICA8L2Rpdj5cbjwvZm9ybT5cblxuPGRpdiBjbGFzcz1cInN2Zy1pY29uc1wiIHN0eWxlPVwiaGVpZ2h0OiAwOyB3aWR0aDogMDsgcG9zaXRpb246IGFic29sdXRlOyB2aXNpYmlsaXR5OiBoaWRkZW5cIj5cbiAgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+XG4gICAgPHN5bWJvbCBpZD1cInNieC1pY29uLWNsZWFyLTNcIiB2aWV3Qm94PVwiMCAwIDQwIDQwXCI+PHBhdGggZD1cIk0xNi4yMjggMjBMMS44ODYgNS42NTcgMCAzLjc3MiAzLjc3MiAwbDEuODg1IDEuODg2TDIwIDE2LjIyOCAzNC4zNDMgMS44ODYgMzYuMjI4IDAgNDAgMy43NzJsLTEuODg2IDEuODg1TDIzLjc3MiAyMGwxNC4zNDIgMTQuMzQzTDQwIDM2LjIyOCAzNi4yMjggNDBsLTEuODg1LTEuODg2TDIwIDIzLjc3MiA1LjY1NyAzOC4xMTQgMy43NzIgNDAgMCAzNi4yMjhsMS44ODYtMS44ODVMMTYuMjI4IDIwelwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIj48L3N5bWJvbD5cbiAgICA8c3ltYm9sIGlkPVwic2J4LWljb24tc2VhcmNoLTEzXCIgdmlld0JveD1cIjAgMCA0MCA0MFwiPjxwYXRoIGQ9XCJNMjYuODA2IDI5LjAxMmExNi4zMTIgMTYuMzEyIDAgMCAxLTEwLjQyNyAzLjc0NkM3LjMzMiAzMi43NTggMCAyNS40MjUgMCAxNi4zNzggMCA3LjMzNCA3LjMzMyAwIDE2LjM4IDBjOS4wNDUgMCAxNi4zNzggNy4zMzMgMTYuMzc4IDE2LjM4IDAgMy45Ni0xLjQwNiA3LjU5My0zLjc0NiAxMC40MjZMMzkuNTQ3IDM3LjM0Yy42MDcuNjA4LjYxIDEuNTktLjAwNCAyLjIwM2ExLjU2IDEuNTYgMCAwIDEtMi4yMDIuMDA0TDI2LjgwNyAyOS4wMTJ6bS0xMC40MjcuNjI3YzcuMzIyIDAgMTMuMjYtNS45MzggMTMuMjYtMTMuMjYgMC03LjMyNC01LjkzOC0xMy4yNi0xMy4yNi0xMy4yNi03LjMyNCAwLTEzLjI2IDUuOTM2LTEzLjI2IDEzLjI2IDAgNy4zMjIgNS45MzYgMTMuMjYgMTMuMjYgMTMuMjZ6XCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPjwvc3ltYm9sPlxuICA8L3N2Zz5cbjwvZGl2PlxuICBgLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVzO1xuIiwiaW1wb3J0ICQgZnJvbSBcImF1dG9jb21wbGV0ZS5qcy96ZXB0b1wiO1xuXG5jb25zdCB1dGlscyA9IHtcbiAgLypcbiAgKiBNb3ZlIHRoZSBjb250ZW50IG9mIGFuIG9iamVjdCBrZXkgb25lIGxldmVsIGhpZ2hlci5cbiAgKiBlZy5cbiAgKiB7XG4gICogICBuYW1lOiAnTXkgbmFtZScsXG4gICogICBoaWVyYXJjaHk6IHtcbiAgKiAgICAgbHZsMDogJ0ZvbycsXG4gICogICAgIGx2bDE6ICdCYXInXG4gICogICB9XG4gICogfVxuICAqIFdpbGwgYmUgY29udmVydGVkIHRvXG4gICoge1xuICAqICAgbmFtZTogJ015IG5hbWUnLFxuICAqICAgbHZsMDogJ0ZvbycsXG4gICogICBsdmwxOiAnQmFyJ1xuICAqIH1cbiAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IE1haW4gb2JqZWN0XG4gICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IE1haW4gb2JqZWN0IGtleSB0byBtb3ZlIHVwXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEB0aHJvd3MgRXJyb3Igd2hlbiBrZXkgaXMgbm90IGFuIGF0dHJpYnV0ZSBvZiBPYmplY3Qgb3IgaXMgbm90IGFuIG9iamVjdCBpdHNlbGZcbiAgKi9cbiAgbWVyZ2VLZXlXaXRoUGFyZW50KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAob2JqZWN0W3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICBjb25zdCBuZXdPYmplY3QgPSAkLmV4dGVuZCh7fSwgb2JqZWN0LCBvYmplY3RbcHJvcGVydHldKTtcbiAgICBkZWxldGUgbmV3T2JqZWN0W3Byb3BlcnR5XTtcbiAgICByZXR1cm4gbmV3T2JqZWN0O1xuICB9LFxuICAvKlxuICAqIEdyb3VwIGFsbCBvYmplY3RzIG9mIGEgY29sbGVjdGlvbiBieSB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVcbiAgKiBJZiB0aGUgYXR0cmlidXRlIGlzIGEgc3RyaW5nLCB1c2UgdGhlIGxvd2VyY2FzZSBmb3JtLlxuICAqXG4gICogZWcuXG4gICogZ3JvdXBCeShbXG4gICogICB7bmFtZTogJ1RpbScsIGNhdGVnb3J5OiAnZGV2J30sXG4gICogICB7bmFtZTogJ1ZpbmNlbnQnLCBjYXRlZ29yeTogJ2Rldid9LFxuICAqICAge25hbWU6ICdCZW4nLCBjYXRlZ29yeTogJ3NhbGVzJ30sXG4gICogICB7bmFtZTogJ0plcmVteScsIGNhdGVnb3J5OiAnc2FsZXMnfSxcbiAgKiAgIHtuYW1lOiAnQWxleFMnLCBjYXRlZ29yeTogJ2Rldid9LFxuICAqICAge25hbWU6ICdBbGV4SycsIGNhdGVnb3J5OiAnc2FsZXMnfVxuICAqIF0sICdjYXRlZ29yeScpO1xuICAqID0+XG4gICoge1xuICAqICAgJ2RldnMnOiBbXG4gICogICAgIHtuYW1lOiAnVGltJywgY2F0ZWdvcnk6ICdkZXYnfSxcbiAgKiAgICAge25hbWU6ICdWaW5jZW50JywgY2F0ZWdvcnk6ICdkZXYnfSxcbiAgKiAgICAge25hbWU6ICdBbGV4UycsIGNhdGVnb3J5OiAnZGV2J31cbiAgKiAgIF0sXG4gICogICAnc2FsZXMnOiBbXG4gICogICAgIHtuYW1lOiAnQmVuJywgY2F0ZWdvcnk6ICdzYWxlcyd9LFxuICAqICAgICB7bmFtZTogJ0plcmVteScsIGNhdGVnb3J5OiAnc2FsZXMnfSxcbiAgKiAgICAge25hbWU6ICdBbGV4SycsIGNhdGVnb3J5OiAnc2FsZXMnfVxuICAqICAgXVxuICAqIH1cbiAgKiBAcGFyYW0ge2FycmF5fSBjb2xsZWN0aW9uIEFycmF5IG9mIG9iamVjdHMgdG8gZ3JvdXBcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIGF0dHJpYnV0ZSBvbiB3aGljaCBhcHBseSB0aGUgZ3JvdXBpbmdcbiAgKiBAcmV0dXJuIHthcnJheX1cbiAgKiBAdGhyb3dzIEVycm9yIHdoZW4gb25lIG9mIHRoZSBlbGVtZW50IGRvZXMgbm90IGhhdmUgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAqL1xuICBncm91cEJ5KGNvbGxlY3Rpb24sIHByb3BlcnR5KSB7XG4gICAgY29uc3QgbmV3Q29sbGVjdGlvbiA9IHt9O1xuICAgICQuZWFjaChjb2xsZWN0aW9uLCAoaW5kZXgsIGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgW2dyb3VwQnldOiBPYmplY3QgaGFzIG5vIGtleSAke3Byb3BlcnR5fWApO1xuICAgICAgfVxuICAgICAgbGV0IGtleSA9IGl0ZW1bcHJvcGVydHldO1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgLy8gZml4ICMxNzEgdGhlIGdpdmVuIGRhdGEgdHlwZSBvZiBkb2NzZWFyY2ggaGl0cyBtaWdodCBiZSBjb25mbGljdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuYXRpdmUgT2JqZWN0LFxuICAgICAgLy8gc3VjaCBhcyB0aGUgY29uc3RydWN0b3IsIHNvIHdlIG5lZWQgdG8gZG8gdGhpcyBjaGVjay5cbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5ld0NvbGxlY3Rpb24sIGtleSkpIHtcbiAgICAgICAgbmV3Q29sbGVjdGlvbltrZXldID0gW107XG4gICAgICB9XG4gICAgICBuZXdDb2xsZWN0aW9uW2tleV0ucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Q29sbGVjdGlvbjtcbiAgfSxcbiAgLypcbiAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgYWxsIHRoZSB2YWx1ZXMgb2YgdGhlIHNwZWNpZmllZCBvYmplY3RcbiAgKiBlZy5cbiAgKiB2YWx1ZXMoe1xuICAqICAgZm9vOiA0MixcbiAgKiAgIGJhcjogdHJ1ZSxcbiAgKiAgIGJhejogJ3llcCdcbiAgKiB9KVxuICAqID0+XG4gICogWzQyLCB0cnVlLCB5ZXBdXG4gICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCBPYmplY3QgdG8gZXh0cmFjdCB2YWx1ZXMgZnJvbVxuICAqIEByZXR1cm4ge2FycmF5fVxuICAqL1xuICB2YWx1ZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGtleSA9PiBvYmplY3Rba2V5XSk7XG4gIH0sXG4gIC8qXG4gICogRmxhdHRlbnMgYW4gYXJyYXlcbiAgKiBlZy5cbiAgKiBmbGF0dGVuKFsxLCAyLCBbMywgNF0sIFs1LCA2XV0pXG4gICogPT5cbiAgKiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSBBcnJheSB0byBmbGF0dGVuXG4gICogQHJldHVybiB7YXJyYXl9XG4gICovXG4gIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgYXJyYXkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhbHVlLmZvckVhY2goc3VidmFsdWUgPT4ge1xuICAgICAgICByZXN1bHRzLnB1c2goc3VidmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sXG4gIC8qXG4gICogRmxhdHRlbiBhbGwgdmFsdWVzIG9mIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5LCBtYXJraW5nIGVhY2ggZmlyc3QgZWxlbWVudCBvZlxuICAqIGVhY2ggZ3JvdXAgd2l0aCBhIHNwZWNpZmljIGZsYWdcbiAgKiBlZy5cbiAgKiBmbGF0dGVuQW5kRmxhZ0ZpcnN0KHtcbiAgKiAgICdkZXZzJzogW1xuICAqICAgICB7bmFtZTogJ1RpbScsIGNhdGVnb3J5OiAnZGV2J30sXG4gICogICAgIHtuYW1lOiAnVmluY2VudCcsIGNhdGVnb3J5OiAnZGV2J30sXG4gICogICAgIHtuYW1lOiAnQWxleFMnLCBjYXRlZ29yeTogJ2Rldid9XG4gICogICBdLFxuICAqICAgJ3NhbGVzJzogW1xuICAqICAgICB7bmFtZTogJ0JlbicsIGNhdGVnb3J5OiAnc2FsZXMnfSxcbiAgKiAgICAge25hbWU6ICdKZXJlbXknLCBjYXRlZ29yeTogJ3NhbGVzJ30sXG4gICogICAgIHtuYW1lOiAnQWxleEsnLCBjYXRlZ29yeTogJ3NhbGVzJ31cbiAgKiAgIF1cbiAgKiAsICdpc1RvcCcpO1xuICAqID0+XG4gICogW1xuICAqICAgICB7bmFtZTogJ1RpbScsIGNhdGVnb3J5OiAnZGV2JywgaXNUb3A6IHRydWV9LFxuICAqICAgICB7bmFtZTogJ1ZpbmNlbnQnLCBjYXRlZ29yeTogJ2RldicsIGlzVG9wOiBmYWxzZX0sXG4gICogICAgIHtuYW1lOiAnQWxleFMnLCBjYXRlZ29yeTogJ2RldicsIGlzVG9wOiBmYWxzZX0sXG4gICogICAgIHtuYW1lOiAnQmVuJywgY2F0ZWdvcnk6ICdzYWxlcycsIGlzVG9wOiB0cnVlfSxcbiAgKiAgICAge25hbWU6ICdKZXJlbXknLCBjYXRlZ29yeTogJ3NhbGVzJywgaXNUb3A6IGZhbHNlfSxcbiAgKiAgICAge25hbWU6ICdBbGV4SycsIGNhdGVnb3J5OiAnc2FsZXMnLCBpc1RvcDogZmFsc2V9XG4gICogXVxuICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGZsYXR0ZW5cbiAgKiBAcGFyYW0ge3N0cmluZ30gZmxhZyBGbGFnIHRvIHNldCB0byB0cnVlIG9uIGZpcnN0IGVsZW1lbnQgb2YgZWFjaCBncm91cFxuICAqIEByZXR1cm4ge2FycmF5fVxuICAqL1xuICBmbGF0dGVuQW5kRmxhZ0ZpcnN0KG9iamVjdCwgZmxhZykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzKG9iamVjdCkubWFwKGNvbGxlY3Rpb24gPT5cbiAgICAgIGNvbGxlY3Rpb24ubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgaXRlbVtmbGFnXSA9IGluZGV4ID09PSAwO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5mbGF0dGVuKHZhbHVlcyk7XG4gIH0sXG4gIC8qXG4gICogUmVtb3ZlcyBhbGwgZW1wdHkgc3RyaW5ncywgbnVsbCwgZmFsc2UgYW5kIHVuZGVmaW5lZCBlbGVtZW50cyBhcnJheVxuICAqIGVnLlxuICAqIGNvbXBhY3QoWzQyLCBmYWxzZSwgbnVsbCwgdW5kZWZpbmVkLCAnJywgW10sICdmb28nXSk7XG4gICogPT5cbiAgKiBbNDIsIFtdLCAnZm9vJ11cbiAgKiBAcGFyYW0ge2FycmF5fSBhcnJheSBBcnJheSB0byBjb21wYWN0XG4gICogQHJldHVybiB7YXJyYXl9XG4gICovXG4gIGNvbXBhY3QoYXJyYXkpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgYXJyYXkuZm9yRWFjaCh2YWx1ZSA9PiB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sXG4gIC8qXG4gICAqIFJldHVybnMgdGhlIGhpZ2hsaWdodGVkIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICAgKiBJZiBubyBoaWdobGlnaHRlZCB2YWx1ZSBpcyBhdmFpbGFibGUsIHdpbGwgcmV0dXJuIHRoZSBrZXkgdmFsdWUgZGlyZWN0bHlcbiAgICogZWcuXG4gICAqIGdldEhpZ2hsaWdodGVkVmFsdWUoe1xuICAgKiAgICBfaGlnaGxpZ2h0UmVzdWx0OiB7XG4gICAqICAgICAgdGV4dDoge1xuICAgKiAgICAgICAgdmFsdWU6ICc8bWFyaz5mb288L21hcms+J1xuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgdGV4dDogJ2ZvbydcbiAgICogfSwgJ3RleHQnKTtcbiAgICogPT5cbiAgICogJzxtYXJrPmZvbzwvbWFyaz4nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSGl0IG9iamVjdCByZXR1cm5lZCBieSB0aGUgQWxnb2xpYSBBUElcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE9iamVjdCBrZXkgdG8gbG9vayBmb3JcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiovXG4gIGdldEhpZ2hsaWdodGVkVmFsdWUob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIGlmIChcbiAgICAgIG9iamVjdC5faGlnaGxpZ2h0UmVzdWx0ICYmXG4gICAgICBvYmplY3QuX2hpZ2hsaWdodFJlc3VsdC5oaWVyYXJjaHlfY2FtZWwgJiZcbiAgICAgIG9iamVjdC5faGlnaGxpZ2h0UmVzdWx0LmhpZXJhcmNoeV9jYW1lbFtwcm9wZXJ0eV0gJiZcbiAgICAgIG9iamVjdC5faGlnaGxpZ2h0UmVzdWx0LmhpZXJhcmNoeV9jYW1lbFtwcm9wZXJ0eV0ubWF0Y2hMZXZlbCAmJlxuICAgICAgb2JqZWN0Ll9oaWdobGlnaHRSZXN1bHQuaGllcmFyY2h5X2NhbWVsW3Byb3BlcnR5XS5tYXRjaExldmVsICE9PSAnbm9uZScgJiZcbiAgICAgIG9iamVjdC5faGlnaGxpZ2h0UmVzdWx0LmhpZXJhcmNoeV9jYW1lbFtwcm9wZXJ0eV0udmFsdWVcbiAgICApIHtcbiAgICAgIHJldHVybiBvYmplY3QuX2hpZ2hsaWdodFJlc3VsdC5oaWVyYXJjaHlfY2FtZWxbcHJvcGVydHldLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBvYmplY3QuX2hpZ2hsaWdodFJlc3VsdCAmJlxuICAgICAgb2JqZWN0Ll9oaWdobGlnaHRSZXN1bHQgJiZcbiAgICAgIG9iamVjdC5faGlnaGxpZ2h0UmVzdWx0W3Byb3BlcnR5XSAmJlxuICAgICAgb2JqZWN0Ll9oaWdobGlnaHRSZXN1bHRbcHJvcGVydHldLnZhbHVlXG4gICAgKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Ll9oaWdobGlnaHRSZXN1bHRbcHJvcGVydHldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XTtcbiAgfSxcbiAgLypcbiAgICogUmV0dXJucyB0aGUgc25pcHBldGVkIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoZSBzcGVjaWZpZWQgb2JqZWN0LlxuICAgKiBJZiBubyBoaWdobGlnaHRlZCB2YWx1ZSBpcyBhdmFpbGFibGUsIHdpbGwgcmV0dXJuIHRoZSBrZXkgdmFsdWUgZGlyZWN0bHkuXG4gICAqIFdpbGwgYWRkIHN0YXJ0aW5nIGFuZCBlbmRpbmcgZWxsaXBzaXMgKOKApikgaWYgd2UgZGV0ZWN0IHRoYXQgYSBzZW50ZW5jZSBpc1xuICAgKiBpbmNvbXBsZXRlXG4gICAqIGVnLlxuICAgKiBnZXRTbmlwcGV0ZWRWYWx1ZSh7XG4gICAqICAgIF9zbmlwcGV0UmVzdWx0OiB7XG4gICAqICAgICAgdGV4dDoge1xuICAgKiAgICAgICAgdmFsdWU6ICc8bWFyaz5UaGlzIGlzIGFuIHVuZmluaXNoZWQgc2VudGVuY2U8L21hcms+J1xuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgdGV4dDogJ1RoaXMgaXMgYW4gdW5maW5pc2hlZCBzZW50ZW5jZSdcbiAgICogfSwgJ3RleHQnKTtcbiAgICogPT5cbiAgICogJzxtYXJrPlRoaXMgaXMgYW4gdW5maW5pc2hlZCBzZW50ZW5jZTwvbWFyaz7igKYnXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgSGl0IG9iamVjdCByZXR1cm5lZCBieSB0aGUgQWxnb2xpYSBBUElcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE9iamVjdCBrZXkgdG8gbG9vayBmb3JcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiovXG4gIGdldFNuaXBwZXRlZFZhbHVlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAoXG4gICAgICAhb2JqZWN0Ll9zbmlwcGV0UmVzdWx0IHx8XG4gICAgICAhb2JqZWN0Ll9zbmlwcGV0UmVzdWx0W3Byb3BlcnR5XSB8fFxuICAgICAgIW9iamVjdC5fc25pcHBldFJlc3VsdFtwcm9wZXJ0eV0udmFsdWVcbiAgICApIHtcbiAgICAgIHJldHVybiBvYmplY3RbcHJvcGVydHldO1xuICAgIH1cbiAgICBsZXQgc25pcHBldCA9IG9iamVjdC5fc25pcHBldFJlc3VsdFtwcm9wZXJ0eV0udmFsdWU7XG5cbiAgICBpZiAoc25pcHBldFswXSAhPT0gc25pcHBldFswXS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBzbmlwcGV0ID0gYOKApiR7c25pcHBldH1gO1xuICAgIH1cbiAgICBpZiAoWycuJywgJyEnLCAnPyddLmluZGV4T2Yoc25pcHBldFtzbmlwcGV0Lmxlbmd0aCAtIDFdKSA9PT0gLTEpIHtcbiAgICAgIHNuaXBwZXQgPSBgJHtzbmlwcGV0feKApmA7XG4gICAgfVxuICAgIHJldHVybiBzbmlwcGV0O1xuICB9LFxuICAvKlxuICAqIERlZXAgY2xvbmUgYW4gb2JqZWN0LlxuICAqIE5vdGU6IFRoaXMgd2lsbCBub3QgY2xvbmUgZnVuY3Rpb25zIGFuZCBkYXRlc1xuICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgT2JqZWN0IHRvIGNsb25lXG4gICogQHJldHVybiB7b2JqZWN0fVxuICAqL1xuICBkZWVwQ2xvbmUob2JqZWN0KSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqZWN0KSk7XG4gIH0sXG59O1xuXG5leHBvcnQgZGVmYXVsdCB1dGlscztcbiIsImltcG9ydCBIb2dhbiBmcm9tIFwiaG9nYW4uanNcIjtcbmltcG9ydCBMdW5yU2VhcmNoQWRhcHRlciBmcm9tIFwiLi9sdW5hci1zZWFyY2hcIjtcbmltcG9ydCBhdXRvY29tcGxldGUgZnJvbSBcImF1dG9jb21wbGV0ZS5qc1wiO1xuaW1wb3J0IHRlbXBsYXRlcyBmcm9tIFwiLi90ZW1wbGF0ZXNcIjtcbmltcG9ydCB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0ICQgZnJvbSBcImF1dG9jb21wbGV0ZS5qcy96ZXB0b1wiO1xuXG5jbGFzcyBEb2NTZWFyY2gge1xuICAgIGNvbnN0cnVjdG9yKHtcbiAgICAgICAgc2VhcmNoRG9jcyxcbiAgICAgICAgc2VhcmNoSW5kZXgsXG4gICAgICAgIGlucHV0U2VsZWN0b3IsXG4gICAgICAgIGRlYnVnID0gZmFsc2UsXG4gICAgICAgIGJhc2VVcmwgPSAnLycsXG4gICAgICAgIHF1ZXJ5RGF0YUNhbGxiYWNrID0gbnVsbCxcbiAgICAgICAgYXV0b2NvbXBsZXRlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgICAgIGhpbnQ6IGZhbHNlLFxuICAgICAgICAgICAgYXV0b3NlbGVjdDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2Zvcm1EYXRhID0gZmFsc2UsXG4gICAgICAgIHF1ZXJ5SG9vayA9IGZhbHNlLFxuICAgICAgICBoYW5kbGVTZWxlY3RlZCA9IGZhbHNlLFxuICAgICAgICBlbmhhbmNlZFNlYXJjaElucHV0ID0gZmFsc2UsXG4gICAgICAgIGxheW91dCA9IFwiY29sdW1uXCIsXG4gICAgICAgIG1heEhpdHMgPSA1XG4gICAgfSkge1xuICAgICAgICB0aGlzLmlucHV0ID0gRG9jU2VhcmNoLmdldElucHV0RnJvbVNlbGVjdG9yKGlucHV0U2VsZWN0b3IpO1xuICAgICAgICB0aGlzLnF1ZXJ5RGF0YUNhbGxiYWNrID0gcXVlcnlEYXRhQ2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlT3B0aW9uc0RlYnVnID1cbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZU9wdGlvbnMgJiYgYXV0b2NvbXBsZXRlT3B0aW9ucy5kZWJ1Z1xuICAgICAgICAgICAgICAgID8gYXV0b2NvbXBsZXRlT3B0aW9ucy5kZWJ1Z1xuICAgICAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICBhdXRvY29tcGxldGVPcHRpb25zLmRlYnVnID0gZGVidWcgfHwgYXV0b2NvbXBsZXRlT3B0aW9uc0RlYnVnO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZU9wdGlvbnMgPSBhdXRvY29tcGxldGVPcHRpb25zO1xuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZU9wdGlvbnMuY3NzQ2xhc3NlcyA9XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZU9wdGlvbnMuY3NzQ2xhc3NlcyB8fCB7fTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVPcHRpb25zLmNzc0NsYXNzZXMucHJlZml4ID1cbiAgICAgICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlT3B0aW9ucy5jc3NDbGFzc2VzLnByZWZpeCB8fCBcImRzXCI7XG4gICAgICAgIGNvbnN0IGlucHV0QXJpYUxhYmVsID1cbiAgICAgICAgICAgIHRoaXMuaW5wdXQgJiZcbiAgICAgICAgICAgIHR5cGVvZiB0aGlzLmlucHV0LmF0dHIgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdGhpcy5pbnB1dC5hdHRyKFwiYXJpYS1sYWJlbFwiKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVPcHRpb25zLmFyaWFMYWJlbCA9XG4gICAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZU9wdGlvbnMuYXJpYUxhYmVsIHx8IGlucHV0QXJpYUxhYmVsIHx8IFwic2VhcmNoIGlucHV0XCI7XG5cbiAgICAgICAgdGhpcy5pc1NpbXBsZUxheW91dCA9IGxheW91dCA9PT0gXCJzaW1wbGVcIjtcblxuICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBMdW5yU2VhcmNoQWRhcHRlcihzZWFyY2hEb2NzLCBzZWFyY2hJbmRleCwgYmFzZVVybCwgbWF4SGl0cyk7XG5cbiAgICAgICAgaWYgKGVuaGFuY2VkU2VhcmNoSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSBEb2NTZWFyY2guaW5qZWN0U2VhcmNoQm94KHRoaXMuaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlID0gYXV0b2NvbXBsZXRlKHRoaXMuaW5wdXQsIGF1dG9jb21wbGV0ZU9wdGlvbnMsIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0QXV0b2NvbXBsZXRlU291cmNlKHRyYW5zZm9ybURhdGEsIHF1ZXJ5SG9vayksXG4gICAgICAgICAgICAgICAgdGVtcGxhdGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Z2dlc3Rpb246IERvY1NlYXJjaC5nZXRTdWdnZXN0aW9uVGVtcGxhdGUodGhpcy5pc1NpbXBsZUxheW91dCksXG4gICAgICAgICAgICAgICAgICAgIGZvb3RlcjogdGVtcGxhdGVzLmZvb3RlcixcbiAgICAgICAgICAgICAgICAgICAgZW1wdHk6IERvY1NlYXJjaC5nZXRFbXB0eVRlbXBsYXRlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIGNvbnN0IGN1c3RvbUhhbmRsZVNlbGVjdGVkID0gaGFuZGxlU2VsZWN0ZWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWQgPSBjdXN0b21IYW5kbGVTZWxlY3RlZCB8fCB0aGlzLmhhbmRsZVNlbGVjdGVkO1xuXG4gICAgICAgIC8vIFdlIHByZXZlbnQgZGVmYXVsdCBsaW5rIGNsaWNraW5nIGlmIGEgY3VzdG9tIGhhbmRsZVNlbGVjdGVkIGlzIGRlZmluZWRcbiAgICAgICAgaWYgKGN1c3RvbUhhbmRsZVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAkKFwiLmFsZ29saWEtYXV0b2NvbXBsZXRlXCIpLm9uKFwiY2xpY2tcIiwgXCIuZHMtc3VnZ2VzdGlvbnMgYVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGUub24oXG4gICAgICAgICAgICBcImF1dG9jb21wbGV0ZTpzZWxlY3RlZFwiLFxuICAgICAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RlZC5iaW5kKG51bGwsIHRoaXMuYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0ZSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5vbihcbiAgICAgICAgICAgIFwiYXV0b2NvbXBsZXRlOnNob3duXCIsXG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNob3duLmJpbmQobnVsbCwgdGhpcy5pbnB1dClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoZW5oYW5jZWRTZWFyY2hJbnB1dCkge1xuICAgICAgICAgICAgRG9jU2VhcmNoLmJpbmRTZWFyY2hCb3hFdmVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3RybC9DbWQgKyBLIHNob3VsZCBmb2N1cyB0aGUgc2VhcmNoIGJhciwgZW11bGF0aW5nIHRoZSBBbGdvbGlhIHNlYXJjaCBVSVxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIGUua2V5ID09ICdrJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuZm9jdXMoKTtcblxuICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHVzaW5nIEN0cmwgKyBLIGluIENocm9tZSB3aWxsIG9wZW4gdGhlIGxvY2F0aW9uIGJhciwgc28gZGlzYWJsZSB0aGlzXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaW5qZWN0U2VhcmNoQm94KGlucHV0KSB7XG4gICAgICAgIGlucHV0LmJlZm9yZSh0ZW1wbGF0ZXMuc2VhcmNoQm94KTtcbiAgICAgICAgY29uc3QgbmV3SW5wdXQgPSBpbnB1dFxuICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgLnByZXYoKVxuICAgICAgICAgICAgLmZpbmQoXCJpbnB1dFwiKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiBuZXdJbnB1dDtcbiAgICB9XG5cbiAgICBzdGF0aWMgYmluZFNlYXJjaEJveEV2ZW50KCkge1xuICAgICAgICAkKCcuc2VhcmNoYm94IFt0eXBlPVwicmVzZXRcIl0nKS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICQoXCJpbnB1dCNkb2NzZWFyY2hcIikuZm9jdXMoKTtcbiAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3MoXCJoaWRlXCIpO1xuICAgICAgICAgICAgYXV0b2NvbXBsZXRlLmF1dG9jb21wbGV0ZS5zZXRWYWwoXCJcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICQoXCJpbnB1dCNkb2NzZWFyY2hcIikub24oXCJrZXl1cFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaW5wdXQjZG9jc2VhcmNoXCIpO1xuICAgICAgICAgICAgY29uc3QgcmVzZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2VhcmNoYm94IFt0eXBlPVwicmVzZXRcIl0nKTtcbiAgICAgICAgICAgIHJlc2V0LmNsYXNzTmFtZSA9IFwic2VhcmNoYm94X19yZXNldFwiO1xuICAgICAgICAgICAgaWYgKHNlYXJjaGJveC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXNldC5jbGFzc05hbWUgKz0gXCIgaGlkZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBpbnB1dCBmcm9tIGEgQ1NTIHNlbGVjdG9yLCBudWxsIGlmIG5vbmUgbWF0Y2hlc1xuICAgICAqIEBmdW5jdGlvbiBnZXRJbnB1dEZyb21TZWxlY3RvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc2VsZWN0b3IgQ1NTIHNlbGVjdG9yIHRoYXQgbWF0Y2hlcyB0aGUgc2VhcmNoXG4gICAgICogaW5wdXQgb2YgdGhlIHBhZ2VcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0SW5wdXRGcm9tU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSAkKHNlbGVjdG9yKS5maWx0ZXIoXCJpbnB1dFwiKTtcbiAgICAgICAgcmV0dXJuIGlucHV0Lmxlbmd0aCA/ICQoaW5wdXRbMF0pIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgc291cmNlYCBtZXRob2QgdG8gYmUgcGFzc2VkIHRvIGF1dG9jb21wbGV0ZS5qcy4gSXQgd2lsbCBxdWVyeVxuICAgICAqIHRoZSBBbGdvbGlhIGluZGV4IGFuZCBjYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZm9ybWF0dGVkIGhpdHMuXG4gICAgICogQGZ1bmN0aW9uIGdldEF1dG9jb21wbGV0ZVNvdXJjZVxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB0cmFuc2Zvcm1EYXRhIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSB0aGUgaGl0c1xuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHF1ZXJ5SG9vayBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gdGhlIHF1ZXJ5XG4gICAgICogQHJldHVybnMge2Z1bmN0aW9ufSBNZXRob2QgdG8gYmUgcGFzc2VkIGFzIHRoZSBgc291cmNlYCBvcHRpb24gb2ZcbiAgICAgKiBhdXRvY29tcGxldGVcbiAgICAgKi9cbiAgICBnZXRBdXRvY29tcGxldGVTb3VyY2UodHJhbnNmb3JtRGF0YSwgcXVlcnlIb29rKSB7XG4gICAgICAgIHJldHVybiAocXVlcnksIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocXVlcnlIb29rKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICAgICAgcXVlcnkgPSBxdWVyeUhvb2socXVlcnkpIHx8IHF1ZXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnQuc2VhcmNoKHF1ZXJ5KS50aGVuKGhpdHMgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeURhdGFDYWxsYmFjayAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdGhpcy5xdWVyeURhdGFDYWxsYmFjayA9PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeURhdGFDYWxsYmFjayhoaXRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0cyA9IHRyYW5zZm9ybURhdGEoaGl0cykgfHwgaGl0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soRG9jU2VhcmNoLmZvcm1hdEhpdHMoaGl0cykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gR2l2ZW4gYSBsaXN0IG9mIGhpdHMgcmV0dXJuZWQgYnkgdGhlIEFQSSwgd2lsbCByZWZvcm1hdCB0aGVtIHRvIGJlIHVzZWQgaW5cbiAgICAvLyBhIEhvZ2FuIHRlbXBsYXRlXG4gICAgc3RhdGljIGZvcm1hdEhpdHMocmVjZWl2ZWRIaXRzKSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEhpdHMgPSB1dGlscy5kZWVwQ2xvbmUocmVjZWl2ZWRIaXRzKTtcbiAgICAgICAgY29uc3QgaGl0cyA9IGNsb25lZEhpdHMubWFwKGhpdCA9PiB7XG4gICAgICAgICAgICBpZiAoaGl0Ll9oaWdobGlnaHRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgICAgICBoaXQuX2hpZ2hsaWdodFJlc3VsdCA9IHV0aWxzLm1lcmdlS2V5V2l0aFBhcmVudChcbiAgICAgICAgICAgICAgICAgICAgaGl0Ll9oaWdobGlnaHRSZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIFwiaGllcmFyY2h5XCJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlS2V5V2l0aFBhcmVudChoaXQsIFwiaGllcmFyY2h5XCIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBHcm91cCBoaXRzIGJ5IGNhdGVnb3J5IC8gc3ViY2F0ZWdvcnlcbiAgICAgICAgbGV0IGdyb3VwZWRIaXRzID0gdXRpbHMuZ3JvdXBCeShoaXRzLCBcImx2bDBcIik7XG4gICAgICAgICQuZWFjaChncm91cGVkSGl0cywgKGxldmVsLCBjb2xsZWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncm91cGVkSGl0c0J5THZsMSA9IHV0aWxzLmdyb3VwQnkoY29sbGVjdGlvbiwgXCJsdmwxXCIpO1xuICAgICAgICAgICAgY29uc3QgZmxhdHRlbmVkSGl0cyA9IHV0aWxzLmZsYXR0ZW5BbmRGbGFnRmlyc3QoXG4gICAgICAgICAgICAgICAgZ3JvdXBlZEhpdHNCeUx2bDEsXG4gICAgICAgICAgICAgICAgXCJpc1N1YkNhdGVnb3J5SGVhZGVyXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBncm91cGVkSGl0c1tsZXZlbF0gPSBmbGF0dGVuZWRIaXRzO1xuICAgICAgICB9KTtcbiAgICAgICAgZ3JvdXBlZEhpdHMgPSB1dGlscy5mbGF0dGVuQW5kRmxhZ0ZpcnN0KGdyb3VwZWRIaXRzLCBcImlzQ2F0ZWdvcnlIZWFkZXJcIik7XG5cbiAgICAgICAgLy8gVHJhbnNsYXRlIGhpdHMgaW50byBzbWFsbGVyIG9iamVjdHMgdG8gYmUgc2VuZCB0byB0aGUgdGVtcGxhdGVcbiAgICAgICAgcmV0dXJuIGdyb3VwZWRIaXRzLm1hcChoaXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gRG9jU2VhcmNoLmZvcm1hdFVSTChoaXQpO1xuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSB1dGlscy5nZXRIaWdobGlnaHRlZFZhbHVlKGhpdCwgXCJsdmwwXCIpO1xuICAgICAgICAgICAgY29uc3Qgc3ViY2F0ZWdvcnkgPSB1dGlscy5nZXRIaWdobGlnaHRlZFZhbHVlKGhpdCwgXCJsdmwxXCIpIHx8IGNhdGVnb3J5O1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheVRpdGxlID0gdXRpbHNcbiAgICAgICAgICAgICAgICAuY29tcGFjdChbXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmdldEhpZ2hsaWdodGVkVmFsdWUoaGl0LCBcImx2bDJcIikgfHwgc3ViY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmdldEhpZ2hsaWdodGVkVmFsdWUoaGl0LCBcImx2bDNcIiksXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmdldEhpZ2hsaWdodGVkVmFsdWUoaGl0LCBcImx2bDRcIiksXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmdldEhpZ2hsaWdodGVkVmFsdWUoaGl0LCBcImx2bDVcIiksXG4gICAgICAgICAgICAgICAgICAgIHV0aWxzLmdldEhpZ2hsaWdodGVkVmFsdWUoaGl0LCBcImx2bDZcIilcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIC5qb2luKFxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJhYS1zdWdnZXN0aW9uLXRpdGxlLXNlcGFyYXRvclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiDigLogPC9zcGFuPidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IHV0aWxzLmdldFNuaXBwZXRlZFZhbHVlKGhpdCwgXCJjb250ZW50XCIpO1xuICAgICAgICAgICAgY29uc3QgaXNUZXh0T3JTdWJjYXRlZ29yeU5vbkVtcHR5ID1cbiAgICAgICAgICAgICAgICAoc3ViY2F0ZWdvcnkgJiYgc3ViY2F0ZWdvcnkgIT09IFwiXCIpIHx8XG4gICAgICAgICAgICAgICAgKGRpc3BsYXlUaXRsZSAmJiBkaXNwbGF5VGl0bGUgIT09IFwiXCIpO1xuICAgICAgICAgICAgY29uc3QgaXNMdmwxRW1wdHlPckR1cGxpY2F0ZSA9XG4gICAgICAgICAgICAgICAgIXN1YmNhdGVnb3J5IHx8IHN1YmNhdGVnb3J5ID09PSBcIlwiIHx8IHN1YmNhdGVnb3J5ID09PSBjYXRlZ29yeTtcbiAgICAgICAgICAgIGNvbnN0IGlzTHZsMiA9XG4gICAgICAgICAgICAgICAgZGlzcGxheVRpdGxlICYmIGRpc3BsYXlUaXRsZSAhPT0gXCJcIiAmJiBkaXNwbGF5VGl0bGUgIT09IHN1YmNhdGVnb3J5O1xuICAgICAgICAgICAgY29uc3QgaXNMdmwxID1cbiAgICAgICAgICAgICAgICAhaXNMdmwyICYmXG4gICAgICAgICAgICAgICAgKHN1YmNhdGVnb3J5ICYmIHN1YmNhdGVnb3J5ICE9PSBcIlwiICYmIHN1YmNhdGVnb3J5ICE9PSBjYXRlZ29yeSk7XG4gICAgICAgICAgICBjb25zdCBpc0x2bDAgPSAhaXNMdmwxICYmICFpc0x2bDI7XG4gICAgICAgICAgICBjb25zdCB2ZXJzaW9uID0gaGl0LnZlcnNpb247XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNMdmwwLFxuICAgICAgICAgICAgICAgIGlzTHZsMSxcbiAgICAgICAgICAgICAgICBpc0x2bDIsXG4gICAgICAgICAgICAgICAgaXNMdmwxRW1wdHlPckR1cGxpY2F0ZSxcbiAgICAgICAgICAgICAgICBpc0NhdGVnb3J5SGVhZGVyOiBoaXQuaXNDYXRlZ29yeUhlYWRlcixcbiAgICAgICAgICAgICAgICBpc1N1YkNhdGVnb3J5SGVhZGVyOiBoaXQuaXNTdWJDYXRlZ29yeUhlYWRlcixcbiAgICAgICAgICAgICAgICBpc1RleHRPclN1YmNhdGVnb3J5Tm9uRW1wdHksXG4gICAgICAgICAgICAgICAgY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgc3ViY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRpc3BsYXlUaXRsZSxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZm9ybWF0VVJMKGhpdCkge1xuICAgICAgICBjb25zdCB7IHVybCwgYW5jaG9yIH0gPSBoaXQ7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5zQW5jaG9yID0gdXJsLmluZGV4T2YoXCIjXCIpICE9PSAtMTtcbiAgICAgICAgICAgIGlmIChjb250YWluc0FuY2hvcikgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGFuY2hvcikgcmV0dXJuIGAke2hpdC51cmx9IyR7aGl0LmFuY2hvcn1gO1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfSBlbHNlIGlmIChhbmNob3IpIHJldHVybiBgIyR7aGl0LmFuY2hvcn1gO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAgICAgICBjb25zb2xlLndhcm4oXCJubyBhbmNob3Igbm9yIHVybCBmb3IgOiBcIiwgSlNPTi5zdHJpbmdpZnkoaGl0KSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldEVtcHR5VGVtcGxhdGUoKSB7XG4gICAgICAgIHJldHVybiBhcmdzID0+IEhvZ2FuLmNvbXBpbGUodGVtcGxhdGVzLmVtcHR5KS5yZW5kZXIoYXJncyk7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldFN1Z2dlc3Rpb25UZW1wbGF0ZShpc1NpbXBsZUxheW91dCkge1xuICAgICAgICBjb25zdCBzdHJpbmdUZW1wbGF0ZSA9IGlzU2ltcGxlTGF5b3V0XG4gICAgICAgICAgICA/IHRlbXBsYXRlcy5zdWdnZXN0aW9uU2ltcGxlXG4gICAgICAgICAgICA6IHRlbXBsYXRlcy5zdWdnZXN0aW9uO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IEhvZ2FuLmNvbXBpbGUoc3RyaW5nVGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gc3VnZ2VzdGlvbiA9PiB0ZW1wbGF0ZS5yZW5kZXIoc3VnZ2VzdGlvbik7XG4gICAgfVxuXG4gICAgaGFuZGxlU2VsZWN0ZWQoaW5wdXQsIGV2ZW50LCBzdWdnZXN0aW9uLCBkYXRhc2V0TnVtYmVyLCBjb250ZXh0ID0ge30pIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBjbGljayBvbiB0aGUgc3VnZ2VzdGlvbiwgYXMgaXQncyBhbHJlYWR5IGEgPGEgaHJlZj4sIHRoZVxuICAgICAgICAvLyBicm93c2VyIHdpbGwgdGFrZSBjYXJlIG9mIGl0LiBUaGlzIGFsbG93IEN0cmwtQ2xpY2tpbmcgb24gcmVzdWx0cyBhbmQgbm90XG4gICAgICAgIC8vIGhhdmluZyB0aGUgbWFpbiB3aW5kb3cgYmVpbmcgcmVkaXJlY3RlZCBhcyB3ZWxsXG4gICAgICAgIGlmIChjb250ZXh0LnNlbGVjdGlvbk1ldGhvZCA9PT0gXCJjbGlja1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5zZXRWYWwoXCJcIik7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oc3VnZ2VzdGlvbi51cmwpO1xuICAgIH1cblxuICAgIGhhbmRsZVNob3duKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZU9mSW5wdXQgPSBpbnB1dC5vZmZzZXQoKS5sZWZ0ICsgaW5wdXQud2lkdGgoKSAvIDI7XG4gICAgICAgIGxldCBtaWRkbGVPZldpbmRvdyA9ICQoZG9jdW1lbnQpLndpZHRoKCkgLyAyO1xuXG4gICAgICAgIGlmIChpc05hTihtaWRkbGVPZldpbmRvdykpIHtcbiAgICAgICAgICAgIG1pZGRsZU9mV2luZG93ID0gOTAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWxpZ25DbGFzcyA9XG4gICAgICAgICAgICBtaWRkbGVPZklucHV0IC0gbWlkZGxlT2ZXaW5kb3cgPj0gMFxuICAgICAgICAgICAgICAgID8gXCJhbGdvbGlhLWF1dG9jb21wbGV0ZS1yaWdodFwiXG4gICAgICAgICAgICAgICAgOiBcImFsZ29saWEtYXV0b2NvbXBsZXRlLWxlZnRcIjtcbiAgICAgICAgY29uc3Qgb3RoZXJBbGlnbkNsYXNzID1cbiAgICAgICAgICAgIG1pZGRsZU9mSW5wdXQgLSBtaWRkbGVPZldpbmRvdyA8IDBcbiAgICAgICAgICAgICAgICA/IFwiYWxnb2xpYS1hdXRvY29tcGxldGUtcmlnaHRcIlxuICAgICAgICAgICAgICAgIDogXCJhbGdvbGlhLWF1dG9jb21wbGV0ZS1sZWZ0XCI7XG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZVdyYXBwZXIgPSAkKFwiLmFsZ29saWEtYXV0b2NvbXBsZXRlXCIpO1xuICAgICAgICBpZiAoIWF1dG9jb21wbGV0ZVdyYXBwZXIuaGFzQ2xhc3MoYWxpZ25DbGFzcykpIHtcbiAgICAgICAgICAgIGF1dG9jb21wbGV0ZVdyYXBwZXIuYWRkQ2xhc3MoYWxpZ25DbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXV0b2NvbXBsZXRlV3JhcHBlci5oYXNDbGFzcyhvdGhlckFsaWduQ2xhc3MpKSB7XG4gICAgICAgICAgICBhdXRvY29tcGxldGVXcmFwcGVyLnJlbW92ZUNsYXNzKG90aGVyQWxpZ25DbGFzcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IERvY1NlYXJjaDtcbiJdLCJuYW1lcyI6WyJsdW5yIiwidG9rZW5pemVyIiwic2VwYXJhdG9yIiwiTHVuclNlYXJjaEFkYXB0ZXIiLCJjb25zdHJ1Y3RvciIsInNlYXJjaERvY3MiLCJzZWFyY2hJbmRleCIsImJhc2VVcmwiLCJtYXhIaXRzIiwibHVuckluZGV4IiwiSW5kZXgiLCJsb2FkIiwiZ2V0THVuclJlc3VsdCIsImlucHV0IiwicXVlcnkiLCJ0b2tlbnMiLCJ0ZXJtIiwiYm9vc3QiLCJ3aWxkY2FyZCIsIlF1ZXJ5IiwiVFJBSUxJTkciLCJnZXRIaXQiLCJkb2MiLCJmb3JtYXR0ZWRUaXRsZSIsImZvcm1hdHRlZENvbnRlbnQiLCJoaWVyYXJjaHkiLCJsdmwwIiwicGFnZVRpdGxlIiwidGl0bGUiLCJsdmwxIiwidHlwZSIsInVybCIsInZlcnNpb24iLCJfc25pcHBldFJlc3VsdCIsImNvbnRlbnQiLCJ2YWx1ZSIsIm1hdGNoTGV2ZWwiLCJfaGlnaGxpZ2h0UmVzdWx0IiwiZ2V0VGl0bGVIaXQiLCJwb3NpdGlvbiIsImxlbmd0aCIsInN0YXJ0IiwiZW5kIiwic3Vic3RyaW5nIiwiZ2V0S2V5d29yZEhpdCIsImtleXdvcmRzIiwiZ2V0Q29udGVudEhpdCIsInByZXZpZXdTdGFydCIsInByZXZpZXdFbmQiLCJlbGxpcHNlc0JlZm9yZSIsImVsbGlwc2VzQWZ0ZXIiLCJrIiwibmV4dFNwYWNlIiwibGFzdEluZGV4T2YiLCJuZXh0RG90IiwiaW5kZXhPZiIsInByZXZpZXciLCJzZWFyY2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlaiIsInJlc3VsdHMiLCJoaXRzIiwidGl0bGVIaXRzUmVzIiwiY29udGVudEhpdHNSZXMiLCJmb3JFYWNoIiwicmVzdWx0IiwicmVmIiwibWV0YWRhdGEiLCJtYXRjaERhdGEiLCJpIiwiaW5jbHVkZXMiLCJwdXNoIiwicHJlZml4Iiwic3VnZ2VzdGlvblByZWZpeCIsImZvb3RlclByZWZpeCIsInRlbXBsYXRlcyIsInN1Z2dlc3Rpb24iLCJzdWdnZXN0aW9uU2ltcGxlIiwiZm9vdGVyIiwiZW1wdHkiLCJzZWFyY2hCb3giLCIkIiwidXRpbHMiLCJtZXJnZUtleVdpdGhQYXJlbnQiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInVuZGVmaW5lZCIsIm5ld09iamVjdCIsImV4dGVuZCIsImdyb3VwQnkiLCJjb2xsZWN0aW9uIiwibmV3Q29sbGVjdGlvbiIsImVhY2giLCJpbmRleCIsIml0ZW0iLCJFcnJvciIsImtleSIsInRvTG93ZXJDYXNlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidmFsdWVzIiwia2V5cyIsIm1hcCIsImZsYXR0ZW4iLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsInN1YnZhbHVlIiwiZmxhdHRlbkFuZEZsYWdGaXJzdCIsImZsYWciLCJjb21wYWN0IiwiZ2V0SGlnaGxpZ2h0ZWRWYWx1ZSIsImhpZXJhcmNoeV9jYW1lbCIsImdldFNuaXBwZXRlZFZhbHVlIiwic25pcHBldCIsInRvVXBwZXJDYXNlIiwiZGVlcENsb25lIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwiSG9nYW4iLCJhdXRvY29tcGxldGUiLCJEb2NTZWFyY2giLCJfcmVmIiwiaW5wdXRTZWxlY3RvciIsImRlYnVnIiwicXVlcnlEYXRhQ2FsbGJhY2siLCJhdXRvY29tcGxldGVPcHRpb25zIiwiaGludCIsImF1dG9zZWxlY3QiLCJ0cmFuc2Zvcm1EYXRhIiwicXVlcnlIb29rIiwiaGFuZGxlU2VsZWN0ZWQiLCJlbmhhbmNlZFNlYXJjaElucHV0IiwibGF5b3V0IiwiZ2V0SW5wdXRGcm9tU2VsZWN0b3IiLCJhdXRvY29tcGxldGVPcHRpb25zRGVidWciLCJjc3NDbGFzc2VzIiwiaW5wdXRBcmlhTGFiZWwiLCJhdHRyIiwiYXJpYUxhYmVsIiwiaXNTaW1wbGVMYXlvdXQiLCJjbGllbnQiLCJpbmplY3RTZWFyY2hCb3giLCJzb3VyY2UiLCJnZXRBdXRvY29tcGxldGVTb3VyY2UiLCJnZXRTdWdnZXN0aW9uVGVtcGxhdGUiLCJnZXRFbXB0eVRlbXBsYXRlIiwiY3VzdG9tSGFuZGxlU2VsZWN0ZWQiLCJvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJiaW5kIiwiaGFuZGxlU2hvd24iLCJiaW5kU2VhcmNoQm94RXZlbnQiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwiY3RybEtleSIsIm1ldGFLZXkiLCJmb2N1cyIsImJlZm9yZSIsIm5ld0lucHV0IiwicHJldiIsImZpbmQiLCJyZW1vdmUiLCJhZGRDbGFzcyIsInNldFZhbCIsInNlYXJjaGJveCIsInF1ZXJ5U2VsZWN0b3IiLCJyZXNldCIsImNsYXNzTmFtZSIsInNlbGVjdG9yIiwiZmlsdGVyIiwiY2FsbGJhY2siLCJ0aGVuIiwiZm9ybWF0SGl0cyIsInJlY2VpdmVkSGl0cyIsImNsb25lZEhpdHMiLCJoaXQiLCJncm91cGVkSGl0cyIsImxldmVsIiwiZ3JvdXBlZEhpdHNCeUx2bDEiLCJmbGF0dGVuZWRIaXRzIiwiZm9ybWF0VVJMIiwiY2F0ZWdvcnkiLCJzdWJjYXRlZ29yeSIsImRpc3BsYXlUaXRsZSIsImpvaW4iLCJ0ZXh0IiwiaXNUZXh0T3JTdWJjYXRlZ29yeU5vbkVtcHR5IiwiaXNMdmwxRW1wdHlPckR1cGxpY2F0ZSIsImlzTHZsMiIsImlzTHZsMSIsImlzTHZsMCIsImlzQ2F0ZWdvcnlIZWFkZXIiLCJpc1N1YkNhdGVnb3J5SGVhZGVyIiwiYW5jaG9yIiwiY29udGFpbnNBbmNob3IiLCJjb25zb2xlIiwid2FybiIsImFyZ3MiLCJjb21waWxlIiwicmVuZGVyIiwic3RyaW5nVGVtcGxhdGUiLCJ0ZW1wbGF0ZSIsImRhdGFzZXROdW1iZXIiLCJjb250ZXh0Iiwic2VsZWN0aW9uTWV0aG9kIiwid2luZG93IiwibG9jYXRpb24iLCJhc3NpZ24iLCJtaWRkbGVPZklucHV0Iiwib2Zmc2V0IiwibGVmdCIsIndpZHRoIiwibWlkZGxlT2ZXaW5kb3ciLCJpc05hTiIsImFsaWduQ2xhc3MiLCJvdGhlckFsaWduQ2xhc3MiLCJhdXRvY29tcGxldGVXcmFwcGVyIiwiaGFzQ2xhc3MiLCJyZW1vdmVDbGFzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15765\n')},29110:(__unused_webpack_module,exports)=>{eval("/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n(function (Hogan) {\n  // Setup regex  assignments\n  // remove whitespace according to Mustache spec\n  var rIsWhitespace = /\\S/,\n      rQuot = /\\\"/g,\n      rNewline =  /\\n/g,\n      rCr = /\\r/g,\n      rSlash = /\\\\/g,\n      rLineSep = /\\u2028/,\n      rParagraphSep = /\\u2029/;\n\n  Hogan.tags = {\n    '#': 1, '^': 2, '<': 3, '$': 4,\n    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,\n    '{': 10, '&': 11, '_t': 12\n  };\n\n  Hogan.scan = function scan(text, delimiters) {\n    var len = text.length,\n        IN_TEXT = 0,\n        IN_TAG_TYPE = 1,\n        IN_TAG = 2,\n        state = IN_TEXT,\n        tagType = null,\n        tag = null,\n        buf = '',\n        tokens = [],\n        seenTag = false,\n        i = 0,\n        lineStart = 0,\n        otag = '{{',\n        ctag = '}}';\n\n    function addBuf() {\n      if (buf.length > 0) {\n        tokens.push({tag: '_t', text: new String(buf)});\n        buf = '';\n      }\n    }\n\n    function lineIsWhitespace() {\n      var isAllWhitespace = true;\n      for (var j = lineStart; j < tokens.length; j++) {\n        isAllWhitespace =\n          (Hogan.tags[tokens[j].tag] < Hogan.tags['_v']) ||\n          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null);\n        if (!isAllWhitespace) {\n          return false;\n        }\n      }\n\n      return isAllWhitespace;\n    }\n\n    function filterLine(haveSeenTag, noNewLine) {\n      addBuf();\n\n      if (haveSeenTag && lineIsWhitespace()) {\n        for (var j = lineStart, next; j < tokens.length; j++) {\n          if (tokens[j].text) {\n            if ((next = tokens[j+1]) && next.tag == '>') {\n              // set indent to token value\n              next.indent = tokens[j].text.toString()\n            }\n            tokens.splice(j, 1);\n          }\n        }\n      } else if (!noNewLine) {\n        tokens.push({tag:'\\n'});\n      }\n\n      seenTag = false;\n      lineStart = tokens.length;\n    }\n\n    function changeDelimiters(text, index) {\n      var close = '=' + ctag,\n          closeIndex = text.indexOf(close, index),\n          delimiters = trim(\n            text.substring(text.indexOf('=', index) + 1, closeIndex)\n          ).split(' ');\n\n      otag = delimiters[0];\n      ctag = delimiters[delimiters.length - 1];\n\n      return closeIndex + close.length - 1;\n    }\n\n    if (delimiters) {\n      delimiters = delimiters.split(' ');\n      otag = delimiters[0];\n      ctag = delimiters[1];\n    }\n\n    for (i = 0; i < len; i++) {\n      if (state == IN_TEXT) {\n        if (tagChange(otag, text, i)) {\n          --i;\n          addBuf();\n          state = IN_TAG_TYPE;\n        } else {\n          if (text.charAt(i) == '\\n') {\n            filterLine(seenTag);\n          } else {\n            buf += text.charAt(i);\n          }\n        }\n      } else if (state == IN_TAG_TYPE) {\n        i += otag.length - 1;\n        tag = Hogan.tags[text.charAt(i + 1)];\n        tagType = tag ? text.charAt(i + 1) : '_v';\n        if (tagType == '=') {\n          i = changeDelimiters(text, i);\n          state = IN_TEXT;\n        } else {\n          if (tag) {\n            i++;\n          }\n          state = IN_TAG;\n        }\n        seenTag = i;\n      } else {\n        if (tagChange(ctag, text, i)) {\n          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\n                       i: (tagType == '/') ? seenTag - otag.length : i + ctag.length});\n          buf = '';\n          i += ctag.length - 1;\n          state = IN_TEXT;\n          if (tagType == '{') {\n            if (ctag == '}}') {\n              i++;\n            } else {\n              cleanTripleStache(tokens[tokens.length - 1]);\n            }\n          }\n        } else {\n          buf += text.charAt(i);\n        }\n      }\n    }\n\n    filterLine(seenTag, true);\n\n    return tokens;\n  }\n\n  function cleanTripleStache(token) {\n    if (token.n.substr(token.n.length - 1) === '}') {\n      token.n = token.n.substring(0, token.n.length - 1);\n    }\n  }\n\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n\n    return s.replace(/^\\s*|\\s*$/g, '');\n  }\n\n  function tagChange(tag, text, index) {\n    if (text.charAt(index) != tag.charAt(0)) {\n      return false;\n    }\n\n    for (var i = 1, l = tag.length; i < l; i++) {\n      if (text.charAt(index + i) != tag.charAt(i)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // the tags allowed inside super templates\n  var allowedInSuper = {'_t': true, '\\n': true, '$': true, '/': true};\n\n  function buildTree(tokens, kind, stack, customTags) {\n    var instructions = [],\n        opener = null,\n        tail = null,\n        token = null;\n\n    tail = stack[stack.length - 1];\n\n    while (tokens.length > 0) {\n      token = tokens.shift();\n\n      if (tail && tail.tag == '<' && !(token.tag in allowedInSuper)) {\n        throw new Error('Illegal content in < super tag.');\n      }\n\n      if (Hogan.tags[token.tag] <= Hogan.tags['$'] || isOpener(token, customTags)) {\n        stack.push(token);\n        token.nodes = buildTree(tokens, token.tag, stack, customTags);\n      } else if (token.tag == '/') {\n        if (stack.length === 0) {\n          throw new Error('Closing tag without opener: /' + token.n);\n        }\n        opener = stack.pop();\n        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\n          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\n        }\n        opener.end = token.i;\n        return instructions;\n      } else if (token.tag == '\\n') {\n        token.last = (tokens.length == 0) || (tokens[0].tag == '\\n');\n      }\n\n      instructions.push(token);\n    }\n\n    if (stack.length > 0) {\n      throw new Error('missing closing tag: ' + stack.pop().n);\n    }\n\n    return instructions;\n  }\n\n  function isOpener(token, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].o == token.n) {\n        token.tag = '#';\n        return true;\n      }\n    }\n  }\n\n  function isCloser(close, open, tags) {\n    for (var i = 0, l = tags.length; i < l; i++) {\n      if (tags[i].c == close && tags[i].o == open) {\n        return true;\n      }\n    }\n  }\n\n  function stringifySubstitutions(obj) {\n    var items = [];\n    for (var key in obj) {\n      items.push('\"' + esc(key) + '\": function(c,p,t,i) {' + obj[key] + '}');\n    }\n    return \"{ \" + items.join(\",\") + \" }\";\n  }\n\n  function stringifyPartials(codeObj) {\n    var partials = [];\n    for (var key in codeObj.partials) {\n      partials.push('\"' + esc(key) + '\":{name:\"' + esc(codeObj.partials[key].name) + '\", ' + stringifyPartials(codeObj.partials[key]) + \"}\");\n    }\n    return \"partials: {\" + partials.join(\",\") + \"}, subs: \" + stringifySubstitutions(codeObj.subs);\n  }\n\n  Hogan.stringify = function(codeObj, text, options) {\n    return \"{code: function (c,p,i) { \" + Hogan.wrapMain(codeObj.code) + \" },\" + stringifyPartials(codeObj) +  \"}\";\n  }\n\n  var serialNo = 0;\n  Hogan.generate = function(tree, text, options) {\n    serialNo = 0;\n    var context = { code: '', subs: {}, partials: {} };\n    Hogan.walk(tree, context);\n\n    if (options.asString) {\n      return this.stringify(context, text, options);\n    }\n\n    return this.makeTemplate(context, text, options);\n  }\n\n  Hogan.wrapMain = function(code) {\n    return 'var t=this;t.b(i=i||\"\");' + code + 'return t.fl();';\n  }\n\n  Hogan.template = Hogan.Template;\n\n  Hogan.makeTemplate = function(codeObj, text, options) {\n    var template = this.makePartials(codeObj);\n    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code));\n    return new this.template(template, text, this, options);\n  }\n\n  Hogan.makePartials = function(codeObj) {\n    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};\n    for (key in template.partials) {\n      template.partials[key] = this.makePartials(template.partials[key]);\n    }\n    for (key in codeObj.subs) {\n      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]);\n    }\n    return template;\n  }\n\n  function esc(s) {\n    return s.replace(rSlash, '\\\\\\\\')\n            .replace(rQuot, '\\\\\\\"')\n            .replace(rNewline, '\\\\n')\n            .replace(rCr, '\\\\r')\n            .replace(rLineSep, '\\\\u2028')\n            .replace(rParagraphSep, '\\\\u2029');\n  }\n\n  function chooseMethod(s) {\n    return (~s.indexOf('.')) ? 'd' : 'f';\n  }\n\n  function createPartial(node, context) {\n    var prefix = \"<\" + (context.prefix || \"\");\n    var sym = prefix + node.n + serialNo++;\n    context.partials[sym] = {name: node.n, partials: {}};\n    context.code += 't.b(t.rp(\"' +  esc(sym) + '\",c,p,\"' + (node.indent || '') + '\"));';\n    return sym;\n  }\n\n  Hogan.codegen = {\n    '#': function(node, context) {\n      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),' +\n                      'c,p,0,' + node.i + ',' + node.end + ',\"' + node.otag + \" \" + node.ctag + '\")){' +\n                      't.rs(c,p,' + 'function(c,p,t){';\n      Hogan.walk(node.nodes, context);\n      context.code += '});c.pop();}';\n    },\n\n    '^': function(node, context) {\n      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,1),c,p,1,0,0,\"\")){';\n      Hogan.walk(node.nodes, context);\n      context.code += '};';\n    },\n\n    '>': createPartial,\n    '<': function(node, context) {\n      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};\n      Hogan.walk(node.nodes, ctx);\n      var template = context.partials[createPartial(node, context)];\n      template.subs = ctx.subs;\n      template.partials = ctx.partials;\n    },\n\n    '$': function(node, context) {\n      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};\n      Hogan.walk(node.nodes, ctx);\n      context.subs[node.n] = ctx.code;\n      if (!context.inPartial) {\n        context.code += 't.sub(\"' + esc(node.n) + '\",c,p,i);';\n      }\n    },\n\n    '\\n': function(node, context) {\n      context.code += write('\"\\\\n\"' + (node.last ? '' : ' + i'));\n    },\n\n    '_v': function(node, context) {\n      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n    },\n\n    '_t': function(node, context) {\n      context.code += write('\"' + esc(node.text) + '\"');\n    },\n\n    '{': tripleStache,\n\n    '&': tripleStache\n  }\n\n  function tripleStache(node, context) {\n    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '(\"' + esc(node.n) + '\",c,p,0)));';\n  }\n\n  function write(s) {\n    return 't.b(' + s + ');';\n  }\n\n  Hogan.walk = function(nodelist, context) {\n    var func;\n    for (var i = 0, l = nodelist.length; i < l; i++) {\n      func = Hogan.codegen[nodelist[i].tag];\n      func && func(nodelist[i], context);\n    }\n    return context;\n  }\n\n  Hogan.parse = function(tokens, text, options) {\n    options = options || {};\n    return buildTree(tokens, '', [], options.sectionTags || []);\n  }\n\n  Hogan.cache = {};\n\n  Hogan.cacheKey = function(text, options) {\n    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');\n  }\n\n  Hogan.compile = function(text, options) {\n    options = options || {};\n    var key = Hogan.cacheKey(text, options);\n    var template = this.cache[key];\n\n    if (template) {\n      var partials = template.partials;\n      for (var name in partials) {\n        delete partials[name].instance;\n      }\n      return template;\n    }\n\n    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);\n    return this.cache[key] = template;\n  }\n})( true ? exports : 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isc0ZBQXNGO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHLHFEQUFxRDtBQUNyRDtBQUNBLHdCQUF3QixFQUFFLFNBQVM7QUFDbkMsS0FBSzs7QUFFTDtBQUNBLDBHQUEwRztBQUMxRztBQUNBLHlCQUF5QjtBQUN6QixLQUFLOztBQUVMO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSxvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDZGQUE2RjtBQUM3RixLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBLDJGQUEyRjtBQUMzRjs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLEtBQThCLGFBQWEsQ0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvaG9nYW4uanMvbGliL2NvbXBpbGVyLmpzPzUyNDMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgMjAxMSBUd2l0dGVyLCBJbmMuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4oZnVuY3Rpb24gKEhvZ2FuKSB7XG4gIC8vIFNldHVwIHJlZ2V4ICBhc3NpZ25tZW50c1xuICAvLyByZW1vdmUgd2hpdGVzcGFjZSBhY2NvcmRpbmcgdG8gTXVzdGFjaGUgc3BlY1xuICB2YXIgcklzV2hpdGVzcGFjZSA9IC9cXFMvLFxuICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgck5ld2xpbmUgPSAgL1xcbi9nLFxuICAgICAgckNyID0gL1xcci9nLFxuICAgICAgclNsYXNoID0gL1xcXFwvZyxcbiAgICAgIHJMaW5lU2VwID0gL1xcdTIwMjgvLFxuICAgICAgclBhcmFncmFwaFNlcCA9IC9cXHUyMDI5LztcblxuICBIb2dhbi50YWdzID0ge1xuICAgICcjJzogMSwgJ14nOiAyLCAnPCc6IDMsICckJzogNCxcbiAgICAnLyc6IDUsICchJzogNiwgJz4nOiA3LCAnPSc6IDgsICdfdic6IDksXG4gICAgJ3snOiAxMCwgJyYnOiAxMSwgJ190JzogMTJcbiAgfTtcblxuICBIb2dhbi5zY2FuID0gZnVuY3Rpb24gc2Nhbih0ZXh0LCBkZWxpbWl0ZXJzKSB7XG4gICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJTl9URVhUID0gMCxcbiAgICAgICAgSU5fVEFHX1RZUEUgPSAxLFxuICAgICAgICBJTl9UQUcgPSAyLFxuICAgICAgICBzdGF0ZSA9IElOX1RFWFQsXG4gICAgICAgIHRhZ1R5cGUgPSBudWxsLFxuICAgICAgICB0YWcgPSBudWxsLFxuICAgICAgICBidWYgPSAnJyxcbiAgICAgICAgdG9rZW5zID0gW10sXG4gICAgICAgIHNlZW5UYWcgPSBmYWxzZSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxpbmVTdGFydCA9IDAsXG4gICAgICAgIG90YWcgPSAne3snLFxuICAgICAgICBjdGFnID0gJ319JztcblxuICAgIGZ1bmN0aW9uIGFkZEJ1ZigpIHtcbiAgICAgIGlmIChidWYubGVuZ3RoID4gMCkge1xuICAgICAgICB0b2tlbnMucHVzaCh7dGFnOiAnX3QnLCB0ZXh0OiBuZXcgU3RyaW5nKGJ1Zil9KTtcbiAgICAgICAgYnVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZUlzV2hpdGVzcGFjZSgpIHtcbiAgICAgIHZhciBpc0FsbFdoaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgZm9yICh2YXIgaiA9IGxpbmVTdGFydDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICBpc0FsbFdoaXRlc3BhY2UgPVxuICAgICAgICAgIChIb2dhbi50YWdzW3Rva2Vuc1tqXS50YWddIDwgSG9nYW4udGFnc1snX3YnXSkgfHxcbiAgICAgICAgICAodG9rZW5zW2pdLnRhZyA9PSAnX3QnICYmIHRva2Vuc1tqXS50ZXh0Lm1hdGNoKHJJc1doaXRlc3BhY2UpID09PSBudWxsKTtcbiAgICAgICAgaWYgKCFpc0FsbFdoaXRlc3BhY2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGlzQWxsV2hpdGVzcGFjZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaWx0ZXJMaW5lKGhhdmVTZWVuVGFnLCBub05ld0xpbmUpIHtcbiAgICAgIGFkZEJ1ZigpO1xuXG4gICAgICBpZiAoaGF2ZVNlZW5UYWcgJiYgbGluZUlzV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBsaW5lU3RhcnQsIG5leHQ7IGogPCB0b2tlbnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodG9rZW5zW2pdLnRleHQpIHtcbiAgICAgICAgICAgIGlmICgobmV4dCA9IHRva2Vuc1tqKzFdKSAmJiBuZXh0LnRhZyA9PSAnPicpIHtcbiAgICAgICAgICAgICAgLy8gc2V0IGluZGVudCB0byB0b2tlbiB2YWx1ZVxuICAgICAgICAgICAgICBuZXh0LmluZGVudCA9IHRva2Vuc1tqXS50ZXh0LnRvU3RyaW5nKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFub05ld0xpbmUpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe3RhZzonXFxuJ30pO1xuICAgICAgfVxuXG4gICAgICBzZWVuVGFnID0gZmFsc2U7XG4gICAgICBsaW5lU3RhcnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoYW5nZURlbGltaXRlcnModGV4dCwgaW5kZXgpIHtcbiAgICAgIHZhciBjbG9zZSA9ICc9JyArIGN0YWcsXG4gICAgICAgICAgY2xvc2VJbmRleCA9IHRleHQuaW5kZXhPZihjbG9zZSwgaW5kZXgpLFxuICAgICAgICAgIGRlbGltaXRlcnMgPSB0cmltKFxuICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcodGV4dC5pbmRleE9mKCc9JywgaW5kZXgpICsgMSwgY2xvc2VJbmRleClcbiAgICAgICAgICApLnNwbGl0KCcgJyk7XG5cbiAgICAgIG90YWcgPSBkZWxpbWl0ZXJzWzBdO1xuICAgICAgY3RhZyA9IGRlbGltaXRlcnNbZGVsaW1pdGVycy5sZW5ndGggLSAxXTtcblxuICAgICAgcmV0dXJuIGNsb3NlSW5kZXggKyBjbG9zZS5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICBkZWxpbWl0ZXJzID0gZGVsaW1pdGVycy5zcGxpdCgnICcpO1xuICAgICAgb3RhZyA9IGRlbGltaXRlcnNbMF07XG4gICAgICBjdGFnID0gZGVsaW1pdGVyc1sxXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChzdGF0ZSA9PSBJTl9URVhUKSB7XG4gICAgICAgIGlmICh0YWdDaGFuZ2Uob3RhZywgdGV4dCwgaSkpIHtcbiAgICAgICAgICAtLWk7XG4gICAgICAgICAgYWRkQnVmKCk7XG4gICAgICAgICAgc3RhdGUgPSBJTl9UQUdfVFlQRTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGV4dC5jaGFyQXQoaSkgPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGZpbHRlckxpbmUoc2VlblRhZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZiArPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gSU5fVEFHX1RZUEUpIHtcbiAgICAgICAgaSArPSBvdGFnLmxlbmd0aCAtIDE7XG4gICAgICAgIHRhZyA9IEhvZ2FuLnRhZ3NbdGV4dC5jaGFyQXQoaSArIDEpXTtcbiAgICAgICAgdGFnVHlwZSA9IHRhZyA/IHRleHQuY2hhckF0KGkgKyAxKSA6ICdfdic7XG4gICAgICAgIGlmICh0YWdUeXBlID09ICc9Jykge1xuICAgICAgICAgIGkgPSBjaGFuZ2VEZWxpbWl0ZXJzKHRleHQsIGkpO1xuICAgICAgICAgIHN0YXRlID0gSU5fVEVYVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlID0gSU5fVEFHO1xuICAgICAgICB9XG4gICAgICAgIHNlZW5UYWcgPSBpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRhZ0NoYW5nZShjdGFnLCB0ZXh0LCBpKSkge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHt0YWc6IHRhZ1R5cGUsIG46IHRyaW0oYnVmKSwgb3RhZzogb3RhZywgY3RhZzogY3RhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgaTogKHRhZ1R5cGUgPT0gJy8nKSA/IHNlZW5UYWcgLSBvdGFnLmxlbmd0aCA6IGkgKyBjdGFnLmxlbmd0aH0pO1xuICAgICAgICAgIGJ1ZiA9ICcnO1xuICAgICAgICAgIGkgKz0gY3RhZy5sZW5ndGggLSAxO1xuICAgICAgICAgIHN0YXRlID0gSU5fVEVYVDtcbiAgICAgICAgICBpZiAodGFnVHlwZSA9PSAneycpIHtcbiAgICAgICAgICAgIGlmIChjdGFnID09ICd9fScpIHtcbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xlYW5UcmlwbGVTdGFjaGUodG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJ1ZiArPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpbHRlckxpbmUoc2VlblRhZywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5UcmlwbGVTdGFjaGUodG9rZW4pIHtcbiAgICBpZiAodG9rZW4ubi5zdWJzdHIodG9rZW4ubi5sZW5ndGggLSAxKSA9PT0gJ30nKSB7XG4gICAgICB0b2tlbi5uID0gdG9rZW4ubi5zdWJzdHJpbmcoMCwgdG9rZW4ubi5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmltKHMpIHtcbiAgICBpZiAocy50cmltKSB7XG4gICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGFnQ2hhbmdlKHRhZywgdGV4dCwgaW5kZXgpIHtcbiAgICBpZiAodGV4dC5jaGFyQXQoaW5kZXgpICE9IHRhZy5jaGFyQXQoMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IHRhZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXh0LmNoYXJBdChpbmRleCArIGkpICE9IHRhZy5jaGFyQXQoaSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlIHRhZ3MgYWxsb3dlZCBpbnNpZGUgc3VwZXIgdGVtcGxhdGVzXG4gIHZhciBhbGxvd2VkSW5TdXBlciA9IHsnX3QnOiB0cnVlLCAnXFxuJzogdHJ1ZSwgJyQnOiB0cnVlLCAnLyc6IHRydWV9O1xuXG4gIGZ1bmN0aW9uIGJ1aWxkVHJlZSh0b2tlbnMsIGtpbmQsIHN0YWNrLCBjdXN0b21UYWdzKSB7XG4gICAgdmFyIGluc3RydWN0aW9ucyA9IFtdLFxuICAgICAgICBvcGVuZXIgPSBudWxsLFxuICAgICAgICB0YWlsID0gbnVsbCxcbiAgICAgICAgdG9rZW4gPSBudWxsO1xuXG4gICAgdGFpbCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgd2hpbGUgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICB0b2tlbiA9IHRva2Vucy5zaGlmdCgpO1xuXG4gICAgICBpZiAodGFpbCAmJiB0YWlsLnRhZyA9PSAnPCcgJiYgISh0b2tlbi50YWcgaW4gYWxsb3dlZEluU3VwZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBjb250ZW50IGluIDwgc3VwZXIgdGFnLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoSG9nYW4udGFnc1t0b2tlbi50YWddIDw9IEhvZ2FuLnRhZ3NbJyQnXSB8fCBpc09wZW5lcih0b2tlbiwgY3VzdG9tVGFncykpIHtcbiAgICAgICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIHRva2VuLm5vZGVzID0gYnVpbGRUcmVlKHRva2VucywgdG9rZW4udGFnLCBzdGFjaywgY3VzdG9tVGFncyk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnRhZyA9PSAnLycpIHtcbiAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xvc2luZyB0YWcgd2l0aG91dCBvcGVuZXI6IC8nICsgdG9rZW4ubik7XG4gICAgICAgIH1cbiAgICAgICAgb3BlbmVyID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0b2tlbi5uICE9IG9wZW5lci5uICYmICFpc0Nsb3Nlcih0b2tlbi5uLCBvcGVuZXIubiwgY3VzdG9tVGFncykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05lc3RpbmcgZXJyb3I6ICcgKyBvcGVuZXIubiArICcgdnMuICcgKyB0b2tlbi5uKTtcbiAgICAgICAgfVxuICAgICAgICBvcGVuZXIuZW5kID0gdG9rZW4uaTtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgICAgIH0gZWxzZSBpZiAodG9rZW4udGFnID09ICdcXG4nKSB7XG4gICAgICAgIHRva2VuLmxhc3QgPSAodG9rZW5zLmxlbmd0aCA9PSAwKSB8fCAodG9rZW5zWzBdLnRhZyA9PSAnXFxuJyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RydWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIGNsb3NpbmcgdGFnOiAnICsgc3RhY2sucG9wKCkubik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RydWN0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3BlbmVyKHRva2VuLCB0YWdzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YWdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRhZ3NbaV0ubyA9PSB0b2tlbi5uKSB7XG4gICAgICAgIHRva2VuLnRhZyA9ICcjJztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNDbG9zZXIoY2xvc2UsIG9wZW4sIHRhZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGFnc1tpXS5jID09IGNsb3NlICYmIHRhZ3NbaV0ubyA9PSBvcGVuKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVN1YnN0aXR1dGlvbnMob2JqKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaXRlbXMucHVzaCgnXCInICsgZXNjKGtleSkgKyAnXCI6IGZ1bmN0aW9uKGMscCx0LGkpIHsnICsgb2JqW2tleV0gKyAnfScpO1xuICAgIH1cbiAgICByZXR1cm4gXCJ7IFwiICsgaXRlbXMuam9pbihcIixcIikgKyBcIiB9XCI7XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqKSB7XG4gICAgdmFyIHBhcnRpYWxzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIGNvZGVPYmoucGFydGlhbHMpIHtcbiAgICAgIHBhcnRpYWxzLnB1c2goJ1wiJyArIGVzYyhrZXkpICsgJ1wiOntuYW1lOlwiJyArIGVzYyhjb2RlT2JqLnBhcnRpYWxzW2tleV0ubmFtZSkgKyAnXCIsICcgKyBzdHJpbmdpZnlQYXJ0aWFscyhjb2RlT2JqLnBhcnRpYWxzW2tleV0pICsgXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gXCJwYXJ0aWFsczoge1wiICsgcGFydGlhbHMuam9pbihcIixcIikgKyBcIn0sIHN1YnM6IFwiICsgc3RyaW5naWZ5U3Vic3RpdHV0aW9ucyhjb2RlT2JqLnN1YnMpO1xuICB9XG5cbiAgSG9nYW4uc3RyaW5naWZ5ID0gZnVuY3Rpb24oY29kZU9iaiwgdGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBcIntjb2RlOiBmdW5jdGlvbiAoYyxwLGkpIHsgXCIgKyBIb2dhbi53cmFwTWFpbihjb2RlT2JqLmNvZGUpICsgXCIgfSxcIiArIHN0cmluZ2lmeVBhcnRpYWxzKGNvZGVPYmopICsgIFwifVwiO1xuICB9XG5cbiAgdmFyIHNlcmlhbE5vID0gMDtcbiAgSG9nYW4uZ2VuZXJhdGUgPSBmdW5jdGlvbih0cmVlLCB0ZXh0LCBvcHRpb25zKSB7XG4gICAgc2VyaWFsTm8gPSAwO1xuICAgIHZhciBjb250ZXh0ID0geyBjb2RlOiAnJywgc3Viczoge30sIHBhcnRpYWxzOiB7fSB9O1xuICAgIEhvZ2FuLndhbGsodHJlZSwgY29udGV4dCk7XG5cbiAgICBpZiAob3B0aW9ucy5hc1N0cmluZykge1xuICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KGNvbnRleHQsIHRleHQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1ha2VUZW1wbGF0ZShjb250ZXh0LCB0ZXh0LCBvcHRpb25zKTtcbiAgfVxuXG4gIEhvZ2FuLndyYXBNYWluID0gZnVuY3Rpb24oY29kZSkge1xuICAgIHJldHVybiAndmFyIHQ9dGhpczt0LmIoaT1pfHxcIlwiKTsnICsgY29kZSArICdyZXR1cm4gdC5mbCgpOyc7XG4gIH1cblxuICBIb2dhbi50ZW1wbGF0ZSA9IEhvZ2FuLlRlbXBsYXRlO1xuXG4gIEhvZ2FuLm1ha2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKGNvZGVPYmosIHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm1ha2VQYXJ0aWFscyhjb2RlT2JqKTtcbiAgICB0ZW1wbGF0ZS5jb2RlID0gbmV3IEZ1bmN0aW9uKCdjJywgJ3AnLCAnaScsIHRoaXMud3JhcE1haW4oY29kZU9iai5jb2RlKSk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLnRlbXBsYXRlKHRlbXBsYXRlLCB0ZXh0LCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIEhvZ2FuLm1ha2VQYXJ0aWFscyA9IGZ1bmN0aW9uKGNvZGVPYmopIHtcbiAgICB2YXIga2V5LCB0ZW1wbGF0ZSA9IHtzdWJzOiB7fSwgcGFydGlhbHM6IGNvZGVPYmoucGFydGlhbHMsIG5hbWU6IGNvZGVPYmoubmFtZX07XG4gICAgZm9yIChrZXkgaW4gdGVtcGxhdGUucGFydGlhbHMpIHtcbiAgICAgIHRlbXBsYXRlLnBhcnRpYWxzW2tleV0gPSB0aGlzLm1ha2VQYXJ0aWFscyh0ZW1wbGF0ZS5wYXJ0aWFsc1trZXldKTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gY29kZU9iai5zdWJzKSB7XG4gICAgICB0ZW1wbGF0ZS5zdWJzW2tleV0gPSBuZXcgRnVuY3Rpb24oJ2MnLCAncCcsICd0JywgJ2knLCBjb2RlT2JqLnN1YnNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzYyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZShyU2xhc2gsICdcXFxcXFxcXCcpXG4gICAgICAgICAgICAucmVwbGFjZShyUXVvdCwgJ1xcXFxcXFwiJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UockNyLCAnXFxcXHInKVxuICAgICAgICAgICAgLnJlcGxhY2UockxpbmVTZXAsICdcXFxcdTIwMjgnKVxuICAgICAgICAgICAgLnJlcGxhY2UoclBhcmFncmFwaFNlcCwgJ1xcXFx1MjAyOScpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hvb3NlTWV0aG9kKHMpIHtcbiAgICByZXR1cm4gKH5zLmluZGV4T2YoJy4nKSkgPyAnZCcgOiAnZic7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKG5vZGUsIGNvbnRleHQpIHtcbiAgICB2YXIgcHJlZml4ID0gXCI8XCIgKyAoY29udGV4dC5wcmVmaXggfHwgXCJcIik7XG4gICAgdmFyIHN5bSA9IHByZWZpeCArIG5vZGUubiArIHNlcmlhbE5vKys7XG4gICAgY29udGV4dC5wYXJ0aWFsc1tzeW1dID0ge25hbWU6IG5vZGUubiwgcGFydGlhbHM6IHt9fTtcbiAgICBjb250ZXh0LmNvZGUgKz0gJ3QuYih0LnJwKFwiJyArICBlc2Moc3ltKSArICdcIixjLHAsXCInICsgKG5vZGUuaW5kZW50IHx8ICcnKSArICdcIikpOyc7XG4gICAgcmV0dXJuIHN5bTtcbiAgfVxuXG4gIEhvZ2FuLmNvZGVnZW4gPSB7XG4gICAgJyMnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gJ2lmKHQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLCcgK1xuICAgICAgICAgICAgICAgICAgICAgICdjLHAsMCwnICsgbm9kZS5pICsgJywnICsgbm9kZS5lbmQgKyAnLFwiJyArIG5vZGUub3RhZyArIFwiIFwiICsgbm9kZS5jdGFnICsgJ1wiKSl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3QucnMoYyxwLCcgKyAnZnVuY3Rpb24oYyxwLHQpeyc7XG4gICAgICBIb2dhbi53YWxrKG5vZGUubm9kZXMsIGNvbnRleHQpO1xuICAgICAgY29udGV4dC5jb2RlICs9ICd9KTtjLnBvcCgpO30nO1xuICAgIH0sXG5cbiAgICAnXic6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuY29kZSArPSAnaWYoIXQucyh0LicgKyBjaG9vc2VNZXRob2Qobm9kZS5uKSArICcoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLDEpLGMscCwxLDAsMCxcIlwiKSl7JztcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY29udGV4dCk7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gJ307JztcbiAgICB9LFxuXG4gICAgJz4nOiBjcmVhdGVQYXJ0aWFsLFxuICAgICc8JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgdmFyIGN0eCA9IHtwYXJ0aWFsczoge30sIGNvZGU6ICcnLCBzdWJzOiB7fSwgaW5QYXJ0aWFsOiB0cnVlfTtcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY3R4KTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IGNvbnRleHQucGFydGlhbHNbY3JlYXRlUGFydGlhbChub2RlLCBjb250ZXh0KV07XG4gICAgICB0ZW1wbGF0ZS5zdWJzID0gY3R4LnN1YnM7XG4gICAgICB0ZW1wbGF0ZS5wYXJ0aWFscyA9IGN0eC5wYXJ0aWFscztcbiAgICB9LFxuXG4gICAgJyQnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY3R4ID0ge3N1YnM6IHt9LCBjb2RlOiAnJywgcGFydGlhbHM6IGNvbnRleHQucGFydGlhbHMsIHByZWZpeDogbm9kZS5ufTtcbiAgICAgIEhvZ2FuLndhbGsobm9kZS5ub2RlcywgY3R4KTtcbiAgICAgIGNvbnRleHQuc3Vic1tub2RlLm5dID0gY3R4LmNvZGU7XG4gICAgICBpZiAoIWNvbnRleHQuaW5QYXJ0aWFsKSB7XG4gICAgICAgIGNvbnRleHQuY29kZSArPSAndC5zdWIoXCInICsgZXNjKG5vZGUubikgKyAnXCIsYyxwLGkpOyc7XG4gICAgICB9XG4gICAgfSxcblxuICAgICdcXG4nOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gd3JpdGUoJ1wiXFxcXG5cIicgKyAobm9kZS5sYXN0ID8gJycgOiAnICsgaScpKTtcbiAgICB9LFxuXG4gICAgJ192JzogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5jb2RlICs9ICd0LmIodC52KHQuJyArIGNob29zZU1ldGhvZChub2RlLm4pICsgJyhcIicgKyBlc2Mobm9kZS5uKSArICdcIixjLHAsMCkpKTsnO1xuICAgIH0sXG5cbiAgICAnX3QnOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmNvZGUgKz0gd3JpdGUoJ1wiJyArIGVzYyhub2RlLnRleHQpICsgJ1wiJyk7XG4gICAgfSxcblxuICAgICd7JzogdHJpcGxlU3RhY2hlLFxuXG4gICAgJyYnOiB0cmlwbGVTdGFjaGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaXBsZVN0YWNoZShub2RlLCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5jb2RlICs9ICd0LmIodC50KHQuJyArIGNob29zZU1ldGhvZChub2RlLm4pICsgJyhcIicgKyBlc2Mobm9kZS5uKSArICdcIixjLHAsMCkpKTsnO1xuICB9XG5cbiAgZnVuY3Rpb24gd3JpdGUocykge1xuICAgIHJldHVybiAndC5iKCcgKyBzICsgJyk7JztcbiAgfVxuXG4gIEhvZ2FuLndhbGsgPSBmdW5jdGlvbihub2RlbGlzdCwgY29udGV4dCkge1xuICAgIHZhciBmdW5jO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZWxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmdW5jID0gSG9nYW4uY29kZWdlbltub2RlbGlzdFtpXS50YWddO1xuICAgICAgZnVuYyAmJiBmdW5jKG5vZGVsaXN0W2ldLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBIb2dhbi5wYXJzZSA9IGZ1bmN0aW9uKHRva2VucywgdGV4dCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBidWlsZFRyZWUodG9rZW5zLCAnJywgW10sIG9wdGlvbnMuc2VjdGlvblRhZ3MgfHwgW10pO1xuICB9XG5cbiAgSG9nYW4uY2FjaGUgPSB7fTtcblxuICBIb2dhbi5jYWNoZUtleSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gW3RleHQsICEhb3B0aW9ucy5hc1N0cmluZywgISFvcHRpb25zLmRpc2FibGVMYW1iZGEsIG9wdGlvbnMuZGVsaW1pdGVycywgISFvcHRpb25zLm1vZGVsR2V0XS5qb2luKCd8fCcpO1xuICB9XG5cbiAgSG9nYW4uY29tcGlsZSA9IGZ1bmN0aW9uKHRleHQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIga2V5ID0gSG9nYW4uY2FjaGVLZXkodGV4dCwgb3B0aW9ucyk7XG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5jYWNoZVtrZXldO1xuXG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICB2YXIgcGFydGlhbHMgPSB0ZW1wbGF0ZS5wYXJ0aWFscztcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGFydGlhbHMpIHtcbiAgICAgICAgZGVsZXRlIHBhcnRpYWxzW25hbWVdLmluc3RhbmNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cblxuICAgIHRlbXBsYXRlID0gdGhpcy5nZW5lcmF0ZSh0aGlzLnBhcnNlKHRoaXMuc2Nhbih0ZXh0LCBvcHRpb25zLmRlbGltaXRlcnMpLCB0ZXh0LCBvcHRpb25zKSwgdGV4dCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVba2V5XSA9IHRlbXBsYXRlO1xuICB9XG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogSG9nYW4pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29110\n")},34714:(module,__unused_webpack_exports,__webpack_require__)=>{eval('/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\n// This file is for use with Node.js. See dist/ for browser files.\n\nvar Hogan = __webpack_require__(29110);\nHogan.Template = (__webpack_require__(59549).Template);\nHogan.template = Hogan.Template;\nmodule.exports = Hogan;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ3MTQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsS0FBWTtBQUNoQyxpQkFBaUIscUNBQThCO0FBQy9DO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2hvZ2FuLmpzL2xpYi9ob2dhbi5qcz85NDhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgQ29weXJpZ2h0IDIwMTEgVHdpdHRlciwgSW5jLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gVGhpcyBmaWxlIGlzIGZvciB1c2Ugd2l0aCBOb2RlLmpzLiBTZWUgZGlzdC8gZm9yIGJyb3dzZXIgZmlsZXMuXG5cbnZhciBIb2dhbiA9IHJlcXVpcmUoJy4vY29tcGlsZXInKTtcbkhvZ2FuLlRlbXBsYXRlID0gcmVxdWlyZSgnLi90ZW1wbGF0ZScpLlRlbXBsYXRlO1xuSG9nYW4udGVtcGxhdGUgPSBIb2dhbi5UZW1wbGF0ZTtcbm1vZHVsZS5leHBvcnRzID0gSG9nYW47XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///34714\n')},59549:(__unused_webpack_module,exports)=>{eval("/*\n *  Copyright 2011 Twitter, Inc.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\nvar Hogan = {};\n\n(function (Hogan) {\n  Hogan.Template = function (codeObj, text, compiler, options) {\n    codeObj = codeObj || {};\n    this.r = codeObj.code || this.r;\n    this.c = compiler;\n    this.options = options || {};\n    this.text = text || '';\n    this.partials = codeObj.partials || {};\n    this.subs = codeObj.subs || {};\n    this.buf = '';\n  }\n\n  Hogan.Template.prototype = {\n    // render: replaced by generated code.\n    r: function (context, partials, indent) { return ''; },\n\n    // variable escaping\n    v: hoganEscape,\n\n    // triple stache\n    t: coerceToString,\n\n    render: function render(context, partials, indent) {\n      return this.ri([context], partials || {}, indent);\n    },\n\n    // render internal -- a hook for overrides that catches partials too\n    ri: function (context, partials, indent) {\n      return this.r(context, partials, indent);\n    },\n\n    // ensurePartial\n    ep: function(symbol, partials) {\n      var partial = this.partials[symbol];\n\n      // check to see that if we've instantiated this partial before\n      var template = partials[partial.name];\n      if (partial.instance && partial.base == template) {\n        return partial.instance;\n      }\n\n      if (typeof template == 'string') {\n        if (!this.c) {\n          throw new Error(\"No compiler available.\");\n        }\n        template = this.c.compile(template, this.options);\n      }\n\n      if (!template) {\n        return null;\n      }\n\n      // We use this to check whether the partials dictionary has changed\n      this.partials[symbol].base = template;\n\n      if (partial.subs) {\n        // Make sure we consider parent template now\n        if (!partials.stackText) partials.stackText = {};\n        for (key in partial.subs) {\n          if (!partials.stackText[key]) {\n            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;\n          }\n        }\n        template = createSpecializedPartial(template, partial.subs, partial.partials,\n          this.stackSubs, this.stackPartials, partials.stackText);\n      }\n      this.partials[symbol].instance = template;\n\n      return template;\n    },\n\n    // tries to find a partial in the current scope and render it\n    rp: function(symbol, context, partials, indent) {\n      var partial = this.ep(symbol, partials);\n      if (!partial) {\n        return '';\n      }\n\n      return partial.ri(context, partials, indent);\n    },\n\n    // render a section\n    rs: function(context, partials, section) {\n      var tail = context[context.length - 1];\n\n      if (!isArray(tail)) {\n        section(context, partials, this);\n        return;\n      }\n\n      for (var i = 0; i < tail.length; i++) {\n        context.push(tail[i]);\n        section(context, partials, this);\n        context.pop();\n      }\n    },\n\n    // maybe start a section\n    s: function(val, ctx, partials, inverted, start, end, tags) {\n      var pass;\n\n      if (isArray(val) && val.length === 0) {\n        return false;\n      }\n\n      if (typeof val == 'function') {\n        val = this.ms(val, ctx, partials, inverted, start, end, tags);\n      }\n\n      pass = !!val;\n\n      if (!inverted && pass && ctx) {\n        ctx.push((typeof val == 'object') ? val : ctx[ctx.length - 1]);\n      }\n\n      return pass;\n    },\n\n    // find values with dotted names\n    d: function(key, ctx, partials, returnFound) {\n      var found,\n          names = key.split('.'),\n          val = this.f(names[0], ctx, partials, returnFound),\n          doModelGet = this.options.modelGet,\n          cx = null;\n\n      if (key === '.' && isArray(ctx[ctx.length - 2])) {\n        val = ctx[ctx.length - 1];\n      } else {\n        for (var i = 1; i < names.length; i++) {\n          found = findInScope(names[i], val, doModelGet);\n          if (found !== undefined) {\n            cx = val;\n            val = found;\n          } else {\n            val = '';\n          }\n        }\n      }\n\n      if (returnFound && !val) {\n        return false;\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        ctx.push(cx);\n        val = this.mv(val, ctx, partials);\n        ctx.pop();\n      }\n\n      return val;\n    },\n\n    // find values with normal names\n    f: function(key, ctx, partials, returnFound) {\n      var val = false,\n          v = null,\n          found = false,\n          doModelGet = this.options.modelGet;\n\n      for (var i = ctx.length - 1; i >= 0; i--) {\n        v = ctx[i];\n        val = findInScope(key, v, doModelGet);\n        if (val !== undefined) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return (returnFound) ? false : \"\";\n      }\n\n      if (!returnFound && typeof val == 'function') {\n        val = this.mv(val, ctx, partials);\n      }\n\n      return val;\n    },\n\n    // higher order templates\n    ls: function(func, cx, partials, text, tags) {\n      var oldTags = this.options.delimiters;\n\n      this.options.delimiters = tags;\n      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));\n      this.options.delimiters = oldTags;\n\n      return false;\n    },\n\n    // compile text\n    ct: function(text, cx, partials) {\n      if (this.options.disableLambda) {\n        throw new Error('Lambda features disabled.');\n      }\n      return this.c.compile(text, this.options).render(cx, partials);\n    },\n\n    // template result buffering\n    b: function(s) { this.buf += s; },\n\n    fl: function() { var r = this.buf; this.buf = ''; return r; },\n\n    // method replace section\n    ms: function(func, ctx, partials, inverted, start, end, tags) {\n      var textSource,\n          cx = ctx[ctx.length - 1],\n          result = func.call(cx);\n\n      if (typeof result == 'function') {\n        if (inverted) {\n          return true;\n        } else {\n          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;\n          return this.ls(result, cx, partials, textSource.substring(start, end), tags);\n        }\n      }\n\n      return result;\n    },\n\n    // method replace variable\n    mv: function(func, ctx, partials) {\n      var cx = ctx[ctx.length - 1];\n      var result = func.call(cx);\n\n      if (typeof result == 'function') {\n        return this.ct(coerceToString(result.call(cx)), cx, partials);\n      }\n\n      return result;\n    },\n\n    sub: function(name, context, partials, indent) {\n      var f = this.subs[name];\n      if (f) {\n        this.activeSub = name;\n        f(context, partials, this, indent);\n        this.activeSub = false;\n      }\n    }\n\n  };\n\n  //Find a key in an object\n  function findInScope(key, scope, doModelGet) {\n    var val;\n\n    if (scope && typeof scope == 'object') {\n\n      if (scope[key] !== undefined) {\n        val = scope[key];\n\n      // try lookup with get for backbone or similar model data\n      } else if (doModelGet && scope.get && typeof scope.get == 'function') {\n        val = scope.get(key);\n      }\n    }\n\n    return val;\n  }\n\n  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {\n    function PartialTemplate() {};\n    PartialTemplate.prototype = instance;\n    function Substitutions() {};\n    Substitutions.prototype = instance.subs;\n    var key;\n    var partial = new PartialTemplate();\n    partial.subs = new Substitutions();\n    partial.subsText = {};  //hehe. substext.\n    partial.buf = '';\n\n    stackSubs = stackSubs || {};\n    partial.stackSubs = stackSubs;\n    partial.subsText = stackText;\n    for (key in subs) {\n      if (!stackSubs[key]) stackSubs[key] = subs[key];\n    }\n    for (key in stackSubs) {\n      partial.subs[key] = stackSubs[key];\n    }\n\n    stackPartials = stackPartials || {};\n    partial.stackPartials = stackPartials;\n    for (key in partials) {\n      if (!stackPartials[key]) stackPartials[key] = partials[key];\n    }\n    for (key in stackPartials) {\n      partial.partials[key] = stackPartials[key];\n    }\n\n    return partial;\n  }\n\n  var rAmp = /&/g,\n      rLt = /</g,\n      rGt = />/g,\n      rApos = /\\'/g,\n      rQuot = /\\\"/g,\n      hChars = /[&<>\\\"\\']/;\n\n  function coerceToString(val) {\n    return String((val === null || val === undefined) ? '' : val);\n  }\n\n  function hoganEscape(str) {\n    str = coerceToString(str);\n    return hChars.test(str) ?\n      str\n        .replace(rAmp, '&amp;')\n        .replace(rLt, '&lt;')\n        .replace(rGt, '&gt;')\n        .replace(rApos, '&#39;')\n        .replace(rQuot, '&quot;') :\n      str;\n  }\n\n  var isArray = Array.isArray || function(a) {\n    return Object.prototype.toString.call(a) === '[object Array]';\n  };\n\n})( true ? exports : 0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk1NDkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTs7QUFFMUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxxQkFBcUIsZ0JBQWdCOztBQUVyQyxxQkFBcUIsa0JBQWtCLGVBQWUsV0FBVzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDhCQUE4QjtBQUM5QiwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLEtBQThCLGFBQWEsQ0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvaG9nYW4uanMvbGliL3RlbXBsYXRlLmpzPzE0OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICBDb3B5cmlnaHQgMjAxMSBUd2l0dGVyLCBJbmMuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG52YXIgSG9nYW4gPSB7fTtcblxuKGZ1bmN0aW9uIChIb2dhbikge1xuICBIb2dhbi5UZW1wbGF0ZSA9IGZ1bmN0aW9uIChjb2RlT2JqLCB0ZXh0LCBjb21waWxlciwgb3B0aW9ucykge1xuICAgIGNvZGVPYmogPSBjb2RlT2JqIHx8IHt9O1xuICAgIHRoaXMuciA9IGNvZGVPYmouY29kZSB8fCB0aGlzLnI7XG4gICAgdGhpcy5jID0gY29tcGlsZXI7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0IHx8ICcnO1xuICAgIHRoaXMucGFydGlhbHMgPSBjb2RlT2JqLnBhcnRpYWxzIHx8IHt9O1xuICAgIHRoaXMuc3VicyA9IGNvZGVPYmouc3VicyB8fCB7fTtcbiAgICB0aGlzLmJ1ZiA9ICcnO1xuICB9XG5cbiAgSG9nYW4uVGVtcGxhdGUucHJvdG90eXBlID0ge1xuICAgIC8vIHJlbmRlcjogcmVwbGFjZWQgYnkgZ2VuZXJhdGVkIGNvZGUuXG4gICAgcjogZnVuY3Rpb24gKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHsgcmV0dXJuICcnOyB9LFxuXG4gICAgLy8gdmFyaWFibGUgZXNjYXBpbmdcbiAgICB2OiBob2dhbkVzY2FwZSxcblxuICAgIC8vIHRyaXBsZSBzdGFjaGVcbiAgICB0OiBjb2VyY2VUb1N0cmluZyxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnJpKFtjb250ZXh0XSwgcGFydGlhbHMgfHwge30sIGluZGVudCk7XG4gICAgfSxcblxuICAgIC8vIHJlbmRlciBpbnRlcm5hbCAtLSBhIGhvb2sgZm9yIG92ZXJyaWRlcyB0aGF0IGNhdGNoZXMgcGFydGlhbHMgdG9vXG4gICAgcmk6IGZ1bmN0aW9uIChjb250ZXh0LCBwYXJ0aWFscywgaW5kZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5yKGNvbnRleHQsIHBhcnRpYWxzLCBpbmRlbnQpO1xuICAgIH0sXG5cbiAgICAvLyBlbnN1cmVQYXJ0aWFsXG4gICAgZXA6IGZ1bmN0aW9uKHN5bWJvbCwgcGFydGlhbHMpIHtcbiAgICAgIHZhciBwYXJ0aWFsID0gdGhpcy5wYXJ0aWFsc1tzeW1ib2xdO1xuXG4gICAgICAvLyBjaGVjayB0byBzZWUgdGhhdCBpZiB3ZSd2ZSBpbnN0YW50aWF0ZWQgdGhpcyBwYXJ0aWFsIGJlZm9yZVxuICAgICAgdmFyIHRlbXBsYXRlID0gcGFydGlhbHNbcGFydGlhbC5uYW1lXTtcbiAgICAgIGlmIChwYXJ0aWFsLmluc3RhbmNlICYmIHBhcnRpYWwuYmFzZSA9PSB0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gcGFydGlhbC5pbnN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIXRoaXMuYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbXBpbGVyIGF2YWlsYWJsZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcGxhdGUgPSB0aGlzLmMuY29tcGlsZSh0ZW1wbGF0ZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gV2UgdXNlIHRoaXMgdG8gY2hlY2sgd2hldGhlciB0aGUgcGFydGlhbHMgZGljdGlvbmFyeSBoYXMgY2hhbmdlZFxuICAgICAgdGhpcy5wYXJ0aWFsc1tzeW1ib2xdLmJhc2UgPSB0ZW1wbGF0ZTtcblxuICAgICAgaWYgKHBhcnRpYWwuc3Vicykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY29uc2lkZXIgcGFyZW50IHRlbXBsYXRlIG5vd1xuICAgICAgICBpZiAoIXBhcnRpYWxzLnN0YWNrVGV4dCkgcGFydGlhbHMuc3RhY2tUZXh0ID0ge307XG4gICAgICAgIGZvciAoa2V5IGluIHBhcnRpYWwuc3Vicykge1xuICAgICAgICAgIGlmICghcGFydGlhbHMuc3RhY2tUZXh0W2tleV0pIHtcbiAgICAgICAgICAgIHBhcnRpYWxzLnN0YWNrVGV4dFtrZXldID0gKHRoaXMuYWN0aXZlU3ViICE9PSB1bmRlZmluZWQgJiYgcGFydGlhbHMuc3RhY2tUZXh0W3RoaXMuYWN0aXZlU3ViXSkgPyBwYXJ0aWFscy5zdGFja1RleHRbdGhpcy5hY3RpdmVTdWJdIDogdGhpcy50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wbGF0ZSA9IGNyZWF0ZVNwZWNpYWxpemVkUGFydGlhbCh0ZW1wbGF0ZSwgcGFydGlhbC5zdWJzLCBwYXJ0aWFsLnBhcnRpYWxzLFxuICAgICAgICAgIHRoaXMuc3RhY2tTdWJzLCB0aGlzLnN0YWNrUGFydGlhbHMsIHBhcnRpYWxzLnN0YWNrVGV4dCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpYWxzW3N5bWJvbF0uaW5zdGFuY2UgPSB0ZW1wbGF0ZTtcblxuICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH0sXG5cbiAgICAvLyB0cmllcyB0byBmaW5kIGEgcGFydGlhbCBpbiB0aGUgY3VycmVudCBzY29wZSBhbmQgcmVuZGVyIGl0XG4gICAgcnA6IGZ1bmN0aW9uKHN5bWJvbCwgY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkge1xuICAgICAgdmFyIHBhcnRpYWwgPSB0aGlzLmVwKHN5bWJvbCwgcGFydGlhbHMpO1xuICAgICAgaWYgKCFwYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnRpYWwucmkoY29udGV4dCwgcGFydGlhbHMsIGluZGVudCk7XG4gICAgfSxcblxuICAgIC8vIHJlbmRlciBhIHNlY3Rpb25cbiAgICByczogZnVuY3Rpb24oY29udGV4dCwgcGFydGlhbHMsIHNlY3Rpb24pIHtcbiAgICAgIHZhciB0YWlsID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIWlzQXJyYXkodGFpbCkpIHtcbiAgICAgICAgc2VjdGlvbihjb250ZXh0LCBwYXJ0aWFscywgdGhpcyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWlsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnRleHQucHVzaCh0YWlsW2ldKTtcbiAgICAgICAgc2VjdGlvbihjb250ZXh0LCBwYXJ0aWFscywgdGhpcyk7XG4gICAgICAgIGNvbnRleHQucG9wKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIG1heWJlIHN0YXJ0IGEgc2VjdGlvblxuICAgIHM6IGZ1bmN0aW9uKHZhbCwgY3R4LCBwYXJ0aWFscywgaW52ZXJ0ZWQsIHN0YXJ0LCBlbmQsIHRhZ3MpIHtcbiAgICAgIHZhciBwYXNzO1xuXG4gICAgICBpZiAoaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHRoaXMubXModmFsLCBjdHgsIHBhcnRpYWxzLCBpbnZlcnRlZCwgc3RhcnQsIGVuZCwgdGFncyk7XG4gICAgICB9XG5cbiAgICAgIHBhc3MgPSAhIXZhbDtcblxuICAgICAgaWYgKCFpbnZlcnRlZCAmJiBwYXNzICYmIGN0eCkge1xuICAgICAgICBjdHgucHVzaCgodHlwZW9mIHZhbCA9PSAnb2JqZWN0JykgPyB2YWwgOiBjdHhbY3R4Lmxlbmd0aCAtIDFdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhc3M7XG4gICAgfSxcblxuICAgIC8vIGZpbmQgdmFsdWVzIHdpdGggZG90dGVkIG5hbWVzXG4gICAgZDogZnVuY3Rpb24oa2V5LCBjdHgsIHBhcnRpYWxzLCByZXR1cm5Gb3VuZCkge1xuICAgICAgdmFyIGZvdW5kLFxuICAgICAgICAgIG5hbWVzID0ga2V5LnNwbGl0KCcuJyksXG4gICAgICAgICAgdmFsID0gdGhpcy5mKG5hbWVzWzBdLCBjdHgsIHBhcnRpYWxzLCByZXR1cm5Gb3VuZCksXG4gICAgICAgICAgZG9Nb2RlbEdldCA9IHRoaXMub3B0aW9ucy5tb2RlbEdldCxcbiAgICAgICAgICBjeCA9IG51bGw7XG5cbiAgICAgIGlmIChrZXkgPT09ICcuJyAmJiBpc0FycmF5KGN0eFtjdHgubGVuZ3RoIC0gMl0pKSB7XG4gICAgICAgIHZhbCA9IGN0eFtjdHgubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZm91bmQgPSBmaW5kSW5TY29wZShuYW1lc1tpXSwgdmFsLCBkb01vZGVsR2V0KTtcbiAgICAgICAgICBpZiAoZm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3ggPSB2YWw7XG4gICAgICAgICAgICB2YWwgPSBmb3VuZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5Gb3VuZCAmJiAhdmFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXR1cm5Gb3VuZCAmJiB0eXBlb2YgdmFsID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY3R4LnB1c2goY3gpO1xuICAgICAgICB2YWwgPSB0aGlzLm12KHZhbCwgY3R4LCBwYXJ0aWFscyk7XG4gICAgICAgIGN0eC5wb3AoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9LFxuXG4gICAgLy8gZmluZCB2YWx1ZXMgd2l0aCBub3JtYWwgbmFtZXNcbiAgICBmOiBmdW5jdGlvbihrZXksIGN0eCwgcGFydGlhbHMsIHJldHVybkZvdW5kKSB7XG4gICAgICB2YXIgdmFsID0gZmFsc2UsXG4gICAgICAgICAgdiA9IG51bGwsXG4gICAgICAgICAgZm91bmQgPSBmYWxzZSxcbiAgICAgICAgICBkb01vZGVsR2V0ID0gdGhpcy5vcHRpb25zLm1vZGVsR2V0O1xuXG4gICAgICBmb3IgKHZhciBpID0gY3R4Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHYgPSBjdHhbaV07XG4gICAgICAgIHZhbCA9IGZpbmRJblNjb3BlKGtleSwgdiwgZG9Nb2RlbEdldCk7XG4gICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgIHJldHVybiAocmV0dXJuRm91bmQpID8gZmFsc2UgOiBcIlwiO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXJldHVybkZvdW5kICYmIHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWwgPSB0aGlzLm12KHZhbCwgY3R4LCBwYXJ0aWFscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSxcblxuICAgIC8vIGhpZ2hlciBvcmRlciB0ZW1wbGF0ZXNcbiAgICBsczogZnVuY3Rpb24oZnVuYywgY3gsIHBhcnRpYWxzLCB0ZXh0LCB0YWdzKSB7XG4gICAgICB2YXIgb2xkVGFncyA9IHRoaXMub3B0aW9ucy5kZWxpbWl0ZXJzO1xuXG4gICAgICB0aGlzLm9wdGlvbnMuZGVsaW1pdGVycyA9IHRhZ3M7XG4gICAgICB0aGlzLmIodGhpcy5jdChjb2VyY2VUb1N0cmluZyhmdW5jLmNhbGwoY3gsIHRleHQpKSwgY3gsIHBhcnRpYWxzKSk7XG4gICAgICB0aGlzLm9wdGlvbnMuZGVsaW1pdGVycyA9IG9sZFRhZ3M7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gY29tcGlsZSB0ZXh0XG4gICAgY3Q6IGZ1bmN0aW9uKHRleHQsIGN4LCBwYXJ0aWFscykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlTGFtYmRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGFtYmRhIGZlYXR1cmVzIGRpc2FibGVkLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuYy5jb21waWxlKHRleHQsIHRoaXMub3B0aW9ucykucmVuZGVyKGN4LCBwYXJ0aWFscyk7XG4gICAgfSxcblxuICAgIC8vIHRlbXBsYXRlIHJlc3VsdCBidWZmZXJpbmdcbiAgICBiOiBmdW5jdGlvbihzKSB7IHRoaXMuYnVmICs9IHM7IH0sXG5cbiAgICBmbDogZnVuY3Rpb24oKSB7IHZhciByID0gdGhpcy5idWY7IHRoaXMuYnVmID0gJyc7IHJldHVybiByOyB9LFxuXG4gICAgLy8gbWV0aG9kIHJlcGxhY2Ugc2VjdGlvblxuICAgIG1zOiBmdW5jdGlvbihmdW5jLCBjdHgsIHBhcnRpYWxzLCBpbnZlcnRlZCwgc3RhcnQsIGVuZCwgdGFncykge1xuICAgICAgdmFyIHRleHRTb3VyY2UsXG4gICAgICAgICAgY3ggPSBjdHhbY3R4Lmxlbmd0aCAtIDFdLFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuY2FsbChjeCk7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGludmVydGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dFNvdXJjZSA9ICh0aGlzLmFjdGl2ZVN1YiAmJiB0aGlzLnN1YnNUZXh0ICYmIHRoaXMuc3Vic1RleHRbdGhpcy5hY3RpdmVTdWJdKSA/IHRoaXMuc3Vic1RleHRbdGhpcy5hY3RpdmVTdWJdIDogdGhpcy50ZXh0O1xuICAgICAgICAgIHJldHVybiB0aGlzLmxzKHJlc3VsdCwgY3gsIHBhcnRpYWxzLCB0ZXh0U291cmNlLnN1YnN0cmluZyhzdGFydCwgZW5kKSwgdGFncyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gbWV0aG9kIHJlcGxhY2UgdmFyaWFibGVcbiAgICBtdjogZnVuY3Rpb24oZnVuYywgY3R4LCBwYXJ0aWFscykge1xuICAgICAgdmFyIGN4ID0gY3R4W2N0eC5sZW5ndGggLSAxXTtcbiAgICAgIHZhciByZXN1bHQgPSBmdW5jLmNhbGwoY3gpO1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN0KGNvZXJjZVRvU3RyaW5nKHJlc3VsdC5jYWxsKGN4KSksIGN4LCBwYXJ0aWFscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHN1YjogZnVuY3Rpb24obmFtZSwgY29udGV4dCwgcGFydGlhbHMsIGluZGVudCkge1xuICAgICAgdmFyIGYgPSB0aGlzLnN1YnNbbmFtZV07XG4gICAgICBpZiAoZikge1xuICAgICAgICB0aGlzLmFjdGl2ZVN1YiA9IG5hbWU7XG4gICAgICAgIGYoY29udGV4dCwgcGFydGlhbHMsIHRoaXMsIGluZGVudCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU3ViID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIH07XG5cbiAgLy9GaW5kIGEga2V5IGluIGFuIG9iamVjdFxuICBmdW5jdGlvbiBmaW5kSW5TY29wZShrZXksIHNjb3BlLCBkb01vZGVsR2V0KSB7XG4gICAgdmFyIHZhbDtcblxuICAgIGlmIChzY29wZSAmJiB0eXBlb2Ygc2NvcGUgPT0gJ29iamVjdCcpIHtcblxuICAgICAgaWYgKHNjb3BlW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWwgPSBzY29wZVtrZXldO1xuXG4gICAgICAvLyB0cnkgbG9va3VwIHdpdGggZ2V0IGZvciBiYWNrYm9uZSBvciBzaW1pbGFyIG1vZGVsIGRhdGFcbiAgICAgIH0gZWxzZSBpZiAoZG9Nb2RlbEdldCAmJiBzY29wZS5nZXQgJiYgdHlwZW9mIHNjb3BlLmdldCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbCA9IHNjb3BlLmdldChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTcGVjaWFsaXplZFBhcnRpYWwoaW5zdGFuY2UsIHN1YnMsIHBhcnRpYWxzLCBzdGFja1N1YnMsIHN0YWNrUGFydGlhbHMsIHN0YWNrVGV4dCkge1xuICAgIGZ1bmN0aW9uIFBhcnRpYWxUZW1wbGF0ZSgpIHt9O1xuICAgIFBhcnRpYWxUZW1wbGF0ZS5wcm90b3R5cGUgPSBpbnN0YW5jZTtcbiAgICBmdW5jdGlvbiBTdWJzdGl0dXRpb25zKCkge307XG4gICAgU3Vic3RpdHV0aW9ucy5wcm90b3R5cGUgPSBpbnN0YW5jZS5zdWJzO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIHBhcnRpYWwgPSBuZXcgUGFydGlhbFRlbXBsYXRlKCk7XG4gICAgcGFydGlhbC5zdWJzID0gbmV3IFN1YnN0aXR1dGlvbnMoKTtcbiAgICBwYXJ0aWFsLnN1YnNUZXh0ID0ge307ICAvL2hlaGUuIHN1YnN0ZXh0LlxuICAgIHBhcnRpYWwuYnVmID0gJyc7XG5cbiAgICBzdGFja1N1YnMgPSBzdGFja1N1YnMgfHwge307XG4gICAgcGFydGlhbC5zdGFja1N1YnMgPSBzdGFja1N1YnM7XG4gICAgcGFydGlhbC5zdWJzVGV4dCA9IHN0YWNrVGV4dDtcbiAgICBmb3IgKGtleSBpbiBzdWJzKSB7XG4gICAgICBpZiAoIXN0YWNrU3Vic1trZXldKSBzdGFja1N1YnNba2V5XSA9IHN1YnNba2V5XTtcbiAgICB9XG4gICAgZm9yIChrZXkgaW4gc3RhY2tTdWJzKSB7XG4gICAgICBwYXJ0aWFsLnN1YnNba2V5XSA9IHN0YWNrU3Vic1trZXldO1xuICAgIH1cblxuICAgIHN0YWNrUGFydGlhbHMgPSBzdGFja1BhcnRpYWxzIHx8IHt9O1xuICAgIHBhcnRpYWwuc3RhY2tQYXJ0aWFscyA9IHN0YWNrUGFydGlhbHM7XG4gICAgZm9yIChrZXkgaW4gcGFydGlhbHMpIHtcbiAgICAgIGlmICghc3RhY2tQYXJ0aWFsc1trZXldKSBzdGFja1BhcnRpYWxzW2tleV0gPSBwYXJ0aWFsc1trZXldO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBzdGFja1BhcnRpYWxzKSB7XG4gICAgICBwYXJ0aWFsLnBhcnRpYWxzW2tleV0gPSBzdGFja1BhcnRpYWxzW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnRpYWw7XG4gIH1cblxuICB2YXIgckFtcCA9IC8mL2csXG4gICAgICByTHQgPSAvPC9nLFxuICAgICAgckd0ID0gLz4vZyxcbiAgICAgIHJBcG9zID0gL1xcJy9nLFxuICAgICAgclF1b3QgPSAvXFxcIi9nLFxuICAgICAgaENoYXJzID0gL1smPD5cXFwiXFwnXS87XG5cbiAgZnVuY3Rpb24gY29lcmNlVG9TdHJpbmcodmFsKSB7XG4gICAgcmV0dXJuIFN0cmluZygodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSA/ICcnIDogdmFsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhvZ2FuRXNjYXBlKHN0cikge1xuICAgIHN0ciA9IGNvZXJjZVRvU3RyaW5nKHN0cik7XG4gICAgcmV0dXJuIGhDaGFycy50ZXN0KHN0cikgP1xuICAgICAgc3RyXG4gICAgICAgIC5yZXBsYWNlKHJBbXAsICcmYW1wOycpXG4gICAgICAgIC5yZXBsYWNlKHJMdCwgJyZsdDsnKVxuICAgICAgICAucmVwbGFjZShyR3QsICcmZ3Q7JylcbiAgICAgICAgLnJlcGxhY2UockFwb3MsICcmIzM5OycpXG4gICAgICAgIC5yZXBsYWNlKHJRdW90LCAnJnF1b3Q7JykgOlxuICAgICAgc3RyO1xuICB9XG5cbiAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGEpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG59KSh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogSG9nYW4pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59549\n")},90874:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\nvar types = [\n  __webpack_require__(45741),\n  __webpack_require__(91856),\n  __webpack_require__(41015),\n  __webpack_require__(16486),\n  __webpack_require__(45723),\n  __webpack_require__(26345)\n];\nvar draining;\nvar currentQueue;\nvar queueIndex = -1;\nvar queue = [];\nvar scheduled = false;\nfunction cleanUpNextTick() {\n  if (!draining || !currentQueue) {\n    return;\n  }\n  draining = false;\n  if (currentQueue.length) {\n    queue = currentQueue.concat(queue);\n  } else {\n    queueIndex = -1;\n  }\n  if (queue.length) {\n    nextTick();\n  }\n}\n\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  if (draining) {\n    return;\n  }\n  scheduled = false;\n  draining = true;\n  var len = queue.length;\n  var timeout = setTimeout(cleanUpNextTick);\n  while (len) {\n    currentQueue = queue;\n    queue = [];\n    while (currentQueue && ++queueIndex < len) {\n      currentQueue[queueIndex].run();\n    }\n    queueIndex = -1;\n    len = queue.length;\n  }\n  currentQueue = null;\n  queueIndex = -1;\n  draining = false;\n  clearTimeout(timeout);\n}\nvar scheduleDrain;\nvar i = -1;\nvar len = types.length;\nwhile (++i < len) {\n  if (types[i] && types[i].test && types[i].test()) {\n    scheduleDrain = types[i].install(nextTick);\n    break;\n  }\n}\n// v8 likes predictible objects\nfunction Item(fun, array) {\n  this.fun = fun;\n  this.array = array;\n}\nItem.prototype.run = function () {\n  var fun = this.fun;\n  var array = this.array;\n  switch (array.length) {\n  case 0:\n    return fun();\n  case 1:\n    return fun(array[0]);\n  case 2:\n    return fun(array[0], array[1]);\n  case 3:\n    return fun(array[0], array[1], array[2]);\n  default:\n    return fun.apply(null, array);\n  }\n\n};\nmodule.exports = immediate;\nfunction immediate(task) {\n  var args = new Array(arguments.length - 1);\n  if (arguments.length > 1) {\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n  }\n  queue.push(new Item(task, args));\n  if (!scheduled && !draining) {\n    scheduled = true;\n    scheduleDrain();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTA4NzQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxLQUFZO0FBQ3RCLEVBQUUsbUJBQU8sQ0FBQyxLQUFrQjtBQUM1QixFQUFFLG1CQUFPLENBQUMsS0FBZTtBQUN6QixFQUFFLG1CQUFPLENBQUMsS0FBa0I7QUFDNUIsRUFBRSxtQkFBTyxDQUFDLEtBQWU7QUFDekIsRUFBRSxtQkFBTyxDQUFDLEtBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9pbmRleC5qcz9mNDJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciB0eXBlcyA9IFtcbiAgcmVxdWlyZSgnLi9uZXh0VGljaycpLFxuICByZXF1aXJlKCcuL3F1ZXVlTWljcm90YXNrJyksXG4gIHJlcXVpcmUoJy4vbXV0YXRpb24uanMnKSxcbiAgcmVxdWlyZSgnLi9tZXNzYWdlQ2hhbm5lbCcpLFxuICByZXF1aXJlKCcuL3N0YXRlQ2hhbmdlJyksXG4gIHJlcXVpcmUoJy4vdGltZW91dCcpXG5dO1xudmFyIGRyYWluaW5nO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG52YXIgcXVldWUgPSBbXTtcbnZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGRyYWluaW5nID0gZmFsc2U7XG4gIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gIH1cbiAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgIG5leHRUaWNrKCk7XG4gIH1cbn1cblxuLy9uYW1lZCBuZXh0VGljayBmb3IgbGVzcyBjb25mdXNpbmcgc3RhY2sgdHJhY2VzXG5mdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgaWYgKGRyYWluaW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjaGVkdWxlZCA9IGZhbHNlO1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICB3aGlsZSAobGVuKSB7XG4gICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSBbXTtcbiAgICB3aGlsZSAoY3VycmVudFF1ZXVlICYmICsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgIH1cbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG4gIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gIHF1ZXVlSW5kZXggPSAtMTtcbiAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxudmFyIHNjaGVkdWxlRHJhaW47XG52YXIgaSA9IC0xO1xudmFyIGxlbiA9IHR5cGVzLmxlbmd0aDtcbndoaWxlICgrK2kgPCBsZW4pIHtcbiAgaWYgKHR5cGVzW2ldICYmIHR5cGVzW2ldLnRlc3QgJiYgdHlwZXNbaV0udGVzdCgpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IHR5cGVzW2ldLmluc3RhbGwobmV4dFRpY2spO1xuICAgIGJyZWFrO1xuICB9XG59XG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgdGhpcy5mdW4gPSBmdW47XG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZ1biA9IHRoaXMuZnVuO1xuICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICBzd2l0Y2ggKGFycmF5Lmxlbmd0aCkge1xuICBjYXNlIDA6XG4gICAgcmV0dXJuIGZ1bigpO1xuICBjYXNlIDE6XG4gICAgcmV0dXJuIGZ1bihhcnJheVswXSk7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gZnVuKGFycmF5WzBdLCBhcnJheVsxXSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gZnVuKGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0pO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiBmdW4uYXBwbHkobnVsbCwgYXJyYXkpO1xuICB9XG5cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGltbWVkaWF0ZTtcbmZ1bmN0aW9uIGltbWVkaWF0ZSh0YXNrKSB7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuICBxdWV1ZS5wdXNoKG5ldyBJdGVtKHRhc2ssIGFyZ3MpKTtcbiAgaWYgKCFzY2hlZHVsZWQgJiYgIWRyYWluaW5nKSB7XG4gICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90874\n")},16486:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nexports.test = function () {\n  if (__webpack_require__.g.setImmediate) {\n    // we can only get here in IE10\n    // which doesn't handel postMessage well\n    return false;\n  }\n  return typeof __webpack_require__.g.MessageChannel !== 'undefined';\n};\n\nexports.install = function (func) {\n  var channel = new __webpack_require__.g.MessageChannel();\n  channel.port1.onmessage = func;\n  return function () {\n    channel.port2.postMessage(0);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0ODYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWTtBQUNaLE1BQU0scUJBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBTTtBQUN0Qjs7QUFFQSxlQUFlO0FBQ2Ysb0JBQW9CLHFCQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvbWVzc2FnZUNoYW5uZWwuanM/NGYzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAvLyB3ZSBjYW4gb25seSBnZXQgaGVyZSBpbiBJRTEwXG4gICAgLy8gd2hpY2ggZG9lc24ndCBoYW5kZWwgcG9zdE1lc3NhZ2Ugd2VsbFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAoZnVuYykge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16486\n")},41015:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n//based off rsvp https://github.com/tildeio/rsvp.js\n//license https://github.com/tildeio/rsvp.js/blob/master/LICENSE\n//https://github.com/tildeio/rsvp.js/blob/master/lib/rsvp/asap.js\n\nvar Mutation = __webpack_require__.g.MutationObserver || __webpack_require__.g.WebKitMutationObserver;\n\nexports.test = function () {\n  return Mutation;\n};\n\nexports.install = function (handle) {\n  var called = 0;\n  var observer = new Mutation(handle);\n  var element = __webpack_require__.g.document.createTextNode('');\n  observer.observe(element, {\n    characterData: true\n  });\n  return function () {\n    element.data = (called = ++called % 2);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEwMTUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxxQkFBTSxxQkFBcUIscUJBQU07O0FBRWhELFlBQVk7QUFDWjtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFNO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvbXV0YXRpb24uanM/NGRkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vL2Jhc2VkIG9mZiByc3ZwIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanNcbi8vbGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0Vcbi8vaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL21hc3Rlci9saWIvcnN2cC9hc2FwLmpzXG5cbnZhciBNdXRhdGlvbiA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG5leHBvcnRzLnRlc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNdXRhdGlvbjtcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbihoYW5kbGUpO1xuICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCwge1xuICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZWxlbWVudC5kYXRhID0gKGNhbGxlZCA9ICsrY2FsbGVkICUgMik7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41015\n")},91856:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\nexports.test = function () {\n  return typeof __webpack_require__.g.queueMicrotask === 'function';\n};\n\nexports.install = function (func) {\n  return function () {\n    __webpack_require__.g.queueMicrotask(func);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTE4NTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZO0FBQ1osZ0JBQWdCLHFCQUFNO0FBQ3RCOztBQUVBLGVBQWU7QUFDZjtBQUNBLElBQUkscUJBQU07QUFDVjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9pbW1lZGlhdGUvbGliL3F1ZXVlTWljcm90YXNrLmpzPzYyN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy50ZXN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIGdsb2JhbC5xdWV1ZU1pY3JvdGFzayA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZ2xvYmFsLnF1ZXVlTWljcm90YXNrKGZ1bmMpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91856\n")},45723:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("\n\nexports.test = function () {\n  return 'document' in __webpack_require__.g && 'onreadystatechange' in __webpack_require__.g.document.createElement('script');\n};\n\nexports.install = function (handle) {\n  return function () {\n\n    // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n    // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n    var scriptEl = __webpack_require__.g.document.createElement('script');\n    scriptEl.onreadystatechange = function () {\n      handle();\n\n      scriptEl.onreadystatechange = null;\n      scriptEl.parentNode.removeChild(scriptEl);\n      scriptEl = null;\n    };\n    __webpack_require__.g.document.documentElement.appendChild(scriptEl);\n\n    return handle;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDU3MjMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsWUFBWTtBQUNaLHVCQUF1QixxQkFBTSw0QkFBNEIscUJBQU07QUFDL0Q7O0FBRUEsZUFBZTtBQUNmOztBQUVBLGtDQUFrQztBQUNsQztBQUNBLG1CQUFtQixxQkFBTTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxxQkFBTTs7QUFFVjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvc3RhdGVDaGFuZ2UuanM/NGRkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdkb2N1bWVudCcgaW4gZ2xvYmFsICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbn07XG5cbmV4cG9ydHMuaW5zdGFsbCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGhhbmRsZSgpO1xuXG4gICAgICBzY3JpcHRFbC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgc2NyaXB0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHRFbCk7XG4gICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHNjcmlwdEVsKTtcblxuICAgIHJldHVybiBoYW5kbGU7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///45723\n")},26345:(__unused_webpack_module,exports)=>{"use strict";eval("\nexports.test = function () {\n  return true;\n};\n\nexports.install = function (t) {\n  return function () {\n    setTimeout(t, 0);\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYzNDUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2ltbWVkaWF0ZS9saWIvdGltZW91dC5qcz8xMjU5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmluc3RhbGwgPSBmdW5jdGlvbiAodCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQodCwgMCk7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26345\n")},58291:(module,exports,__webpack_require__)=>{eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9\n * Copyright (C) 2020 Oliver Nightingale\n * @license MIT\n */\n\n;(function(){\n\n/**\n * A convenience function for configuring and constructing\n * a new lunr Index.\n *\n * A lunr.Builder instance is created and the pipeline setup\n * with a trimmer, stop word filter and stemmer.\n *\n * This builder object is yielded to the configuration function\n * that is passed as a parameter, allowing the list of fields\n * and other builder parameters to be customised.\n *\n * All documents _must_ be added within the passed config function.\n *\n * @example\n * var idx = lunr(function () {\n *   this.field('title')\n *   this.field('body')\n *   this.ref('id')\n *\n *   documents.forEach(function (doc) {\n *     this.add(doc)\n *   }, this)\n * })\n *\n * @see {@link lunr.Builder}\n * @see {@link lunr.Pipeline}\n * @see {@link lunr.trimmer}\n * @see {@link lunr.stopWordFilter}\n * @see {@link lunr.stemmer}\n * @namespace {function} lunr\n */\nvar lunr = function (config) {\n  var builder = new lunr.Builder\n\n  builder.pipeline.add(\n    lunr.trimmer,\n    lunr.stopWordFilter,\n    lunr.stemmer\n  )\n\n  builder.searchPipeline.add(\n    lunr.stemmer\n  )\n\n  config.call(builder, builder)\n  return builder.build()\n}\n\nlunr.version = \"2.3.9\"\n/*!\n * lunr.utils\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * A namespace containing utils for the rest of the lunr library\n * @namespace lunr.utils\n */\nlunr.utils = {}\n\n/**\n * Print a warning message to the console.\n *\n * @param {String} message The message to be printed.\n * @memberOf lunr.utils\n * @function\n */\nlunr.utils.warn = (function (global) {\n  /* eslint-disable no-console */\n  return function (message) {\n    if (global.console && console.warn) {\n      console.warn(message)\n    }\n  }\n  /* eslint-enable no-console */\n})(this)\n\n/**\n * Convert an object to a string.\n *\n * In the case of `null` and `undefined` the function returns\n * the empty string, in all other cases the result of calling\n * `toString` on the passed object is returned.\n *\n * @param {Any} obj The object to convert to a string.\n * @return {String} string representation of the passed object.\n * @memberOf lunr.utils\n */\nlunr.utils.asString = function (obj) {\n  if (obj === void 0 || obj === null) {\n    return \"\"\n  } else {\n    return obj.toString()\n  }\n}\n\n/**\n * Clones an object.\n *\n * Will create a copy of an existing object such that any mutations\n * on the copy cannot affect the original.\n *\n * Only shallow objects are supported, passing a nested object to this\n * function will cause a TypeError.\n *\n * Objects with primitives, and arrays of primitives are supported.\n *\n * @param {Object} obj The object to clone.\n * @return {Object} a clone of the passed object.\n * @throws {TypeError} when a nested object is passed.\n * @memberOf Utils\n */\nlunr.utils.clone = function (obj) {\n  if (obj === null || obj === undefined) {\n    return obj\n  }\n\n  var clone = Object.create(null),\n      keys = Object.keys(obj)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i],\n        val = obj[key]\n\n    if (Array.isArray(val)) {\n      clone[key] = val.slice()\n      continue\n    }\n\n    if (typeof val === 'string' ||\n        typeof val === 'number' ||\n        typeof val === 'boolean') {\n      clone[key] = val\n      continue\n    }\n\n    throw new TypeError(\"clone is not deep and does not support nested objects\")\n  }\n\n  return clone\n}\nlunr.FieldRef = function (docRef, fieldName, stringValue) {\n  this.docRef = docRef\n  this.fieldName = fieldName\n  this._stringValue = stringValue\n}\n\nlunr.FieldRef.joiner = \"/\"\n\nlunr.FieldRef.fromString = function (s) {\n  var n = s.indexOf(lunr.FieldRef.joiner)\n\n  if (n === -1) {\n    throw \"malformed field ref string\"\n  }\n\n  var fieldRef = s.slice(0, n),\n      docRef = s.slice(n + 1)\n\n  return new lunr.FieldRef (docRef, fieldRef, s)\n}\n\nlunr.FieldRef.prototype.toString = function () {\n  if (this._stringValue == undefined) {\n    this._stringValue = this.fieldName + lunr.FieldRef.joiner + this.docRef\n  }\n\n  return this._stringValue\n}\n/*!\n * lunr.Set\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * A lunr set.\n *\n * @constructor\n */\nlunr.Set = function (elements) {\n  this.elements = Object.create(null)\n\n  if (elements) {\n    this.length = elements.length\n\n    for (var i = 0; i < this.length; i++) {\n      this.elements[elements[i]] = true\n    }\n  } else {\n    this.length = 0\n  }\n}\n\n/**\n * A complete set that contains all elements.\n *\n * @static\n * @readonly\n * @type {lunr.Set}\n */\nlunr.Set.complete = {\n  intersect: function (other) {\n    return other\n  },\n\n  union: function () {\n    return this\n  },\n\n  contains: function () {\n    return true\n  }\n}\n\n/**\n * An empty set that contains no elements.\n *\n * @static\n * @readonly\n * @type {lunr.Set}\n */\nlunr.Set.empty = {\n  intersect: function () {\n    return this\n  },\n\n  union: function (other) {\n    return other\n  },\n\n  contains: function () {\n    return false\n  }\n}\n\n/**\n * Returns true if this set contains the specified object.\n *\n * @param {object} object - Object whose presence in this set is to be tested.\n * @returns {boolean} - True if this set contains the specified object.\n */\nlunr.Set.prototype.contains = function (object) {\n  return !!this.elements[object]\n}\n\n/**\n * Returns a new set containing only the elements that are present in both\n * this set and the specified set.\n *\n * @param {lunr.Set} other - set to intersect with this set.\n * @returns {lunr.Set} a new set that is the intersection of this and the specified set.\n */\n\nlunr.Set.prototype.intersect = function (other) {\n  var a, b, elements, intersection = []\n\n  if (other === lunr.Set.complete) {\n    return this\n  }\n\n  if (other === lunr.Set.empty) {\n    return other\n  }\n\n  if (this.length < other.length) {\n    a = this\n    b = other\n  } else {\n    a = other\n    b = this\n  }\n\n  elements = Object.keys(a.elements)\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i]\n    if (element in b.elements) {\n      intersection.push(element)\n    }\n  }\n\n  return new lunr.Set (intersection)\n}\n\n/**\n * Returns a new set combining the elements of this and the specified set.\n *\n * @param {lunr.Set} other - set to union with this set.\n * @return {lunr.Set} a new set that is the union of this and the specified set.\n */\n\nlunr.Set.prototype.union = function (other) {\n  if (other === lunr.Set.complete) {\n    return lunr.Set.complete\n  }\n\n  if (other === lunr.Set.empty) {\n    return this\n  }\n\n  return new lunr.Set(Object.keys(this.elements).concat(Object.keys(other.elements)))\n}\n/**\n * A function to calculate the inverse document frequency for\n * a posting. This is shared between the builder and the index\n *\n * @private\n * @param {object} posting - The posting for a given term\n * @param {number} documentCount - The total number of documents.\n */\nlunr.idf = function (posting, documentCount) {\n  var documentsWithTerm = 0\n\n  for (var fieldName in posting) {\n    if (fieldName == '_index') continue // Ignore the term index, its not a field\n    documentsWithTerm += Object.keys(posting[fieldName]).length\n  }\n\n  var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)\n\n  return Math.log(1 + Math.abs(x))\n}\n\n/**\n * A token wraps a string representation of a token\n * as it is passed through the text processing pipeline.\n *\n * @constructor\n * @param {string} [str=''] - The string token being wrapped.\n * @param {object} [metadata={}] - Metadata associated with this token.\n */\nlunr.Token = function (str, metadata) {\n  this.str = str || \"\"\n  this.metadata = metadata || {}\n}\n\n/**\n * Returns the token string that is being wrapped by this object.\n *\n * @returns {string}\n */\nlunr.Token.prototype.toString = function () {\n  return this.str\n}\n\n/**\n * A token update function is used when updating or optionally\n * when cloning a token.\n *\n * @callback lunr.Token~updateFunction\n * @param {string} str - The string representation of the token.\n * @param {Object} metadata - All metadata associated with this token.\n */\n\n/**\n * Applies the given function to the wrapped string token.\n *\n * @example\n * token.update(function (str, metadata) {\n *   return str.toUpperCase()\n * })\n *\n * @param {lunr.Token~updateFunction} fn - A function to apply to the token string.\n * @returns {lunr.Token}\n */\nlunr.Token.prototype.update = function (fn) {\n  this.str = fn(this.str, this.metadata)\n  return this\n}\n\n/**\n * Creates a clone of this token. Optionally a function can be\n * applied to the cloned token.\n *\n * @param {lunr.Token~updateFunction} [fn] - An optional function to apply to the cloned token.\n * @returns {lunr.Token}\n */\nlunr.Token.prototype.clone = function (fn) {\n  fn = fn || function (s) { return s }\n  return new lunr.Token (fn(this.str, this.metadata), this.metadata)\n}\n/*!\n * lunr.tokenizer\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * A function for splitting a string into tokens ready to be inserted into\n * the search index. Uses `lunr.tokenizer.separator` to split strings, change\n * the value of this property to change how strings are split into tokens.\n *\n * This tokenizer will convert its parameter to a string by calling `toString` and\n * then will split this string on the character in `lunr.tokenizer.separator`.\n * Arrays will have their elements converted to strings and wrapped in a lunr.Token.\n *\n * Optional metadata can be passed to the tokenizer, this metadata will be cloned and\n * added as metadata to every token that is created from the object to be tokenized.\n *\n * @static\n * @param {?(string|object|object[])} obj - The object to convert into tokens\n * @param {?object} metadata - Optional metadata to associate with every token\n * @returns {lunr.Token[]}\n * @see {@link lunr.Pipeline}\n */\nlunr.tokenizer = function (obj, metadata) {\n  if (obj == null || obj == undefined) {\n    return []\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(function (t) {\n      return new lunr.Token(\n        lunr.utils.asString(t).toLowerCase(),\n        lunr.utils.clone(metadata)\n      )\n    })\n  }\n\n  var str = obj.toString().toLowerCase(),\n      len = str.length,\n      tokens = []\n\n  for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {\n    var char = str.charAt(sliceEnd),\n        sliceLength = sliceEnd - sliceStart\n\n    if ((char.match(lunr.tokenizer.separator) || sliceEnd == len)) {\n\n      if (sliceLength > 0) {\n        var tokenMetadata = lunr.utils.clone(metadata) || {}\n        tokenMetadata[\"position\"] = [sliceStart, sliceLength]\n        tokenMetadata[\"index\"] = tokens.length\n\n        tokens.push(\n          new lunr.Token (\n            str.slice(sliceStart, sliceEnd),\n            tokenMetadata\n          )\n        )\n      }\n\n      sliceStart = sliceEnd + 1\n    }\n\n  }\n\n  return tokens\n}\n\n/**\n * The separator used to split a string into tokens. Override this property to change the behaviour of\n * `lunr.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.\n *\n * @static\n * @see lunr.tokenizer\n */\nlunr.tokenizer.separator = /[\\s\\-]+/\n/*!\n * lunr.Pipeline\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * lunr.Pipelines maintain an ordered list of functions to be applied to all\n * tokens in documents entering the search index and queries being ran against\n * the index.\n *\n * An instance of lunr.Index created with the lunr shortcut will contain a\n * pipeline with a stop word filter and an English language stemmer. Extra\n * functions can be added before or after either of these functions or these\n * default functions can be removed.\n *\n * When run the pipeline will call each function in turn, passing a token, the\n * index of that token in the original list of all tokens and finally a list of\n * all the original tokens.\n *\n * The output of functions in the pipeline will be passed to the next function\n * in the pipeline. To exclude a token from entering the index the function\n * should return undefined, the rest of the pipeline will not be called with\n * this token.\n *\n * For serialisation of pipelines to work, all functions used in an instance of\n * a pipeline should be registered with lunr.Pipeline. Registered functions can\n * then be loaded. If trying to load a serialised pipeline that uses functions\n * that are not registered an error will be thrown.\n *\n * If not planning on serialising the pipeline then registering pipeline functions\n * is not necessary.\n *\n * @constructor\n */\nlunr.Pipeline = function () {\n  this._stack = []\n}\n\nlunr.Pipeline.registeredFunctions = Object.create(null)\n\n/**\n * A pipeline function maps lunr.Token to lunr.Token. A lunr.Token contains the token\n * string as well as all known metadata. A pipeline function can mutate the token string\n * or mutate (or add) metadata for a given token.\n *\n * A pipeline function can indicate that the passed token should be discarded by returning\n * null, undefined or an empty string. This token will not be passed to any downstream pipeline\n * functions and will not be added to the index.\n *\n * Multiple tokens can be returned by returning an array of tokens. Each token will be passed\n * to any downstream pipeline functions and all will returned tokens will be added to the index.\n *\n * Any number of pipeline functions may be chained together using a lunr.Pipeline.\n *\n * @interface lunr.PipelineFunction\n * @param {lunr.Token} token - A token from the document being processed.\n * @param {number} i - The index of this token in the complete list of tokens for this document/field.\n * @param {lunr.Token[]} tokens - All tokens for this document/field.\n * @returns {(?lunr.Token|lunr.Token[])}\n */\n\n/**\n * Register a function with the pipeline.\n *\n * Functions that are used in the pipeline should be registered if the pipeline\n * needs to be serialised, or a serialised pipeline needs to be loaded.\n *\n * Registering a function does not add it to a pipeline, functions must still be\n * added to instances of the pipeline for them to be used when running a pipeline.\n *\n * @param {lunr.PipelineFunction} fn - The function to check for.\n * @param {String} label - The label to register this function with\n */\nlunr.Pipeline.registerFunction = function (fn, label) {\n  if (label in this.registeredFunctions) {\n    lunr.utils.warn('Overwriting existing registered function: ' + label)\n  }\n\n  fn.label = label\n  lunr.Pipeline.registeredFunctions[fn.label] = fn\n}\n\n/**\n * Warns if the function is not registered as a Pipeline function.\n *\n * @param {lunr.PipelineFunction} fn - The function to check for.\n * @private\n */\nlunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {\n  var isRegistered = fn.label && (fn.label in this.registeredFunctions)\n\n  if (!isRegistered) {\n    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\\n', fn)\n  }\n}\n\n/**\n * Loads a previously serialised pipeline.\n *\n * All functions to be loaded must already be registered with lunr.Pipeline.\n * If any function from the serialised data has not been registered then an\n * error will be thrown.\n *\n * @param {Object} serialised - The serialised pipeline to load.\n * @returns {lunr.Pipeline}\n */\nlunr.Pipeline.load = function (serialised) {\n  var pipeline = new lunr.Pipeline\n\n  serialised.forEach(function (fnName) {\n    var fn = lunr.Pipeline.registeredFunctions[fnName]\n\n    if (fn) {\n      pipeline.add(fn)\n    } else {\n      throw new Error('Cannot load unregistered function: ' + fnName)\n    }\n  })\n\n  return pipeline\n}\n\n/**\n * Adds new functions to the end of the pipeline.\n *\n * Logs a warning if the function has not been registered.\n *\n * @param {lunr.PipelineFunction[]} functions - Any number of functions to add to the pipeline.\n */\nlunr.Pipeline.prototype.add = function () {\n  var fns = Array.prototype.slice.call(arguments)\n\n  fns.forEach(function (fn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n    this._stack.push(fn)\n  }, this)\n}\n\n/**\n * Adds a single function after a function that already exists in the\n * pipeline.\n *\n * Logs a warning if the function has not been registered.\n *\n * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.\n * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.\n */\nlunr.Pipeline.prototype.after = function (existingFn, newFn) {\n  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n  var pos = this._stack.indexOf(existingFn)\n  if (pos == -1) {\n    throw new Error('Cannot find existingFn')\n  }\n\n  pos = pos + 1\n  this._stack.splice(pos, 0, newFn)\n}\n\n/**\n * Adds a single function before a function that already exists in the\n * pipeline.\n *\n * Logs a warning if the function has not been registered.\n *\n * @param {lunr.PipelineFunction} existingFn - A function that already exists in the pipeline.\n * @param {lunr.PipelineFunction} newFn - The new function to add to the pipeline.\n */\nlunr.Pipeline.prototype.before = function (existingFn, newFn) {\n  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)\n\n  var pos = this._stack.indexOf(existingFn)\n  if (pos == -1) {\n    throw new Error('Cannot find existingFn')\n  }\n\n  this._stack.splice(pos, 0, newFn)\n}\n\n/**\n * Removes a function from the pipeline.\n *\n * @param {lunr.PipelineFunction} fn The function to remove from the pipeline.\n */\nlunr.Pipeline.prototype.remove = function (fn) {\n  var pos = this._stack.indexOf(fn)\n  if (pos == -1) {\n    return\n  }\n\n  this._stack.splice(pos, 1)\n}\n\n/**\n * Runs the current list of functions that make up the pipeline against the\n * passed tokens.\n *\n * @param {Array} tokens The tokens to run through the pipeline.\n * @returns {Array}\n */\nlunr.Pipeline.prototype.run = function (tokens) {\n  var stackLength = this._stack.length\n\n  for (var i = 0; i < stackLength; i++) {\n    var fn = this._stack[i]\n    var memo = []\n\n    for (var j = 0; j < tokens.length; j++) {\n      var result = fn(tokens[j], j, tokens)\n\n      if (result === null || result === void 0 || result === '') continue\n\n      if (Array.isArray(result)) {\n        for (var k = 0; k < result.length; k++) {\n          memo.push(result[k])\n        }\n      } else {\n        memo.push(result)\n      }\n    }\n\n    tokens = memo\n  }\n\n  return tokens\n}\n\n/**\n * Convenience method for passing a string through a pipeline and getting\n * strings out. This method takes care of wrapping the passed string in a\n * token and mapping the resulting tokens back to strings.\n *\n * @param {string} str - The string to pass through the pipeline.\n * @param {?object} metadata - Optional metadata to associate with the token\n * passed to the pipeline.\n * @returns {string[]}\n */\nlunr.Pipeline.prototype.runString = function (str, metadata) {\n  var token = new lunr.Token (str, metadata)\n\n  return this.run([token]).map(function (t) {\n    return t.toString()\n  })\n}\n\n/**\n * Resets the pipeline by removing any existing processors.\n *\n */\nlunr.Pipeline.prototype.reset = function () {\n  this._stack = []\n}\n\n/**\n * Returns a representation of the pipeline ready for serialisation.\n *\n * Logs a warning if the function has not been registered.\n *\n * @returns {Array}\n */\nlunr.Pipeline.prototype.toJSON = function () {\n  return this._stack.map(function (fn) {\n    lunr.Pipeline.warnIfFunctionNotRegistered(fn)\n\n    return fn.label\n  })\n}\n/*!\n * lunr.Vector\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * A vector is used to construct the vector space of documents and queries. These\n * vectors support operations to determine the similarity between two documents or\n * a document and a query.\n *\n * Normally no parameters are required for initializing a vector, but in the case of\n * loading a previously dumped vector the raw elements can be provided to the constructor.\n *\n * For performance reasons vectors are implemented with a flat array, where an elements\n * index is immediately followed by its value. E.g. [index, value, index, value]. This\n * allows the underlying array to be as sparse as possible and still offer decent\n * performance when being used for vector calculations.\n *\n * @constructor\n * @param {Number[]} [elements] - The flat list of element index and element value pairs.\n */\nlunr.Vector = function (elements) {\n  this._magnitude = 0\n  this.elements = elements || []\n}\n\n\n/**\n * Calculates the position within the vector to insert a given index.\n *\n * This is used internally by insert and upsert. If there are duplicate indexes then\n * the position is returned as if the value for that index were to be updated, but it\n * is the callers responsibility to check whether there is a duplicate at that index\n *\n * @param {Number} insertIdx - The index at which the element should be inserted.\n * @returns {Number}\n */\nlunr.Vector.prototype.positionForIndex = function (index) {\n  // For an empty vector the tuple can be inserted at the beginning\n  if (this.elements.length == 0) {\n    return 0\n  }\n\n  var start = 0,\n      end = this.elements.length / 2,\n      sliceLength = end - start,\n      pivotPoint = Math.floor(sliceLength / 2),\n      pivotIndex = this.elements[pivotPoint * 2]\n\n  while (sliceLength > 1) {\n    if (pivotIndex < index) {\n      start = pivotPoint\n    }\n\n    if (pivotIndex > index) {\n      end = pivotPoint\n    }\n\n    if (pivotIndex == index) {\n      break\n    }\n\n    sliceLength = end - start\n    pivotPoint = start + Math.floor(sliceLength / 2)\n    pivotIndex = this.elements[pivotPoint * 2]\n  }\n\n  if (pivotIndex == index) {\n    return pivotPoint * 2\n  }\n\n  if (pivotIndex > index) {\n    return pivotPoint * 2\n  }\n\n  if (pivotIndex < index) {\n    return (pivotPoint + 1) * 2\n  }\n}\n\n/**\n * Inserts an element at an index within the vector.\n *\n * Does not allow duplicates, will throw an error if there is already an entry\n * for this index.\n *\n * @param {Number} insertIdx - The index at which the element should be inserted.\n * @param {Number} val - The value to be inserted into the vector.\n */\nlunr.Vector.prototype.insert = function (insertIdx, val) {\n  this.upsert(insertIdx, val, function () {\n    throw \"duplicate index\"\n  })\n}\n\n/**\n * Inserts or updates an existing index within the vector.\n *\n * @param {Number} insertIdx - The index at which the element should be inserted.\n * @param {Number} val - The value to be inserted into the vector.\n * @param {function} fn - A function that is called for updates, the existing value and the\n * requested value are passed as arguments\n */\nlunr.Vector.prototype.upsert = function (insertIdx, val, fn) {\n  this._magnitude = 0\n  var position = this.positionForIndex(insertIdx)\n\n  if (this.elements[position] == insertIdx) {\n    this.elements[position + 1] = fn(this.elements[position + 1], val)\n  } else {\n    this.elements.splice(position, 0, insertIdx, val)\n  }\n}\n\n/**\n * Calculates the magnitude of this vector.\n *\n * @returns {Number}\n */\nlunr.Vector.prototype.magnitude = function () {\n  if (this._magnitude) return this._magnitude\n\n  var sumOfSquares = 0,\n      elementsLength = this.elements.length\n\n  for (var i = 1; i < elementsLength; i += 2) {\n    var val = this.elements[i]\n    sumOfSquares += val * val\n  }\n\n  return this._magnitude = Math.sqrt(sumOfSquares)\n}\n\n/**\n * Calculates the dot product of this vector and another vector.\n *\n * @param {lunr.Vector} otherVector - The vector to compute the dot product with.\n * @returns {Number}\n */\nlunr.Vector.prototype.dot = function (otherVector) {\n  var dotProduct = 0,\n      a = this.elements, b = otherVector.elements,\n      aLen = a.length, bLen = b.length,\n      aVal = 0, bVal = 0,\n      i = 0, j = 0\n\n  while (i < aLen && j < bLen) {\n    aVal = a[i], bVal = b[j]\n    if (aVal < bVal) {\n      i += 2\n    } else if (aVal > bVal) {\n      j += 2\n    } else if (aVal == bVal) {\n      dotProduct += a[i + 1] * b[j + 1]\n      i += 2\n      j += 2\n    }\n  }\n\n  return dotProduct\n}\n\n/**\n * Calculates the similarity between this vector and another vector.\n *\n * @param {lunr.Vector} otherVector - The other vector to calculate the\n * similarity with.\n * @returns {Number}\n */\nlunr.Vector.prototype.similarity = function (otherVector) {\n  return this.dot(otherVector) / this.magnitude() || 0\n}\n\n/**\n * Converts the vector to an array of the elements within the vector.\n *\n * @returns {Number[]}\n */\nlunr.Vector.prototype.toArray = function () {\n  var output = new Array (this.elements.length / 2)\n\n  for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {\n    output[j] = this.elements[i]\n  }\n\n  return output\n}\n\n/**\n * A JSON serializable representation of the vector.\n *\n * @returns {Number[]}\n */\nlunr.Vector.prototype.toJSON = function () {\n  return this.elements\n}\n/* eslint-disable */\n/*!\n * lunr.stemmer\n * Copyright (C) 2020 Oliver Nightingale\n * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt\n */\n\n/**\n * lunr.stemmer is an english language stemmer, this is a JavaScript\n * implementation of the PorterStemmer taken from http://tartarus.org/~martin\n *\n * @static\n * @implements {lunr.PipelineFunction}\n * @param {lunr.Token} token - The string to stem\n * @returns {lunr.Token}\n * @see {@link lunr.Pipeline}\n * @function\n */\nlunr.stemmer = (function(){\n  var step2list = {\n      \"ational\" : \"ate\",\n      \"tional\" : \"tion\",\n      \"enci\" : \"ence\",\n      \"anci\" : \"ance\",\n      \"izer\" : \"ize\",\n      \"bli\" : \"ble\",\n      \"alli\" : \"al\",\n      \"entli\" : \"ent\",\n      \"eli\" : \"e\",\n      \"ousli\" : \"ous\",\n      \"ization\" : \"ize\",\n      \"ation\" : \"ate\",\n      \"ator\" : \"ate\",\n      \"alism\" : \"al\",\n      \"iveness\" : \"ive\",\n      \"fulness\" : \"ful\",\n      \"ousness\" : \"ous\",\n      \"aliti\" : \"al\",\n      \"iviti\" : \"ive\",\n      \"biliti\" : \"ble\",\n      \"logi\" : \"log\"\n    },\n\n    step3list = {\n      \"icate\" : \"ic\",\n      \"ative\" : \"\",\n      \"alize\" : \"al\",\n      \"iciti\" : \"ic\",\n      \"ical\" : \"ic\",\n      \"ful\" : \"\",\n      \"ness\" : \"\"\n    },\n\n    c = \"[^aeiou]\",          // consonant\n    v = \"[aeiouy]\",          // vowel\n    C = c + \"[^aeiouy]*\",    // consonant sequence\n    V = v + \"[aeiou]*\",      // vowel sequence\n\n    mgr0 = \"^(\" + C + \")?\" + V + C,               // [C]VC... is m>0\n    meq1 = \"^(\" + C + \")?\" + V + C + \"(\" + V + \")?$\",  // [C]VC[V] is m=1\n    mgr1 = \"^(\" + C + \")?\" + V + C + V + C,       // [C]VCVC... is m>1\n    s_v = \"^(\" + C + \")?\" + v;                   // vowel in stem\n\n  var re_mgr0 = new RegExp(mgr0);\n  var re_mgr1 = new RegExp(mgr1);\n  var re_meq1 = new RegExp(meq1);\n  var re_s_v = new RegExp(s_v);\n\n  var re_1a = /^(.+?)(ss|i)es$/;\n  var re2_1a = /^(.+?)([^s])s$/;\n  var re_1b = /^(.+?)eed$/;\n  var re2_1b = /^(.+?)(ed|ing)$/;\n  var re_1b_2 = /.$/;\n  var re2_1b_2 = /(at|bl|iz)$/;\n  var re3_1b_2 = new RegExp(\"([^aeiouylsz])\\\\1$\");\n  var re4_1b_2 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n  var re_1c = /^(.+?[^aeiou])y$/;\n  var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;\n\n  var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;\n\n  var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;\n  var re2_4 = /^(.+?)(s|t)(ion)$/;\n\n  var re_5 = /^(.+?)e$/;\n  var re_5_1 = /ll$/;\n  var re3_5 = new RegExp(\"^\" + C + v + \"[^aeiouwxy]$\");\n\n  var porterStemmer = function porterStemmer(w) {\n    var stem,\n      suffix,\n      firstch,\n      re,\n      re2,\n      re3,\n      re4;\n\n    if (w.length < 3) { return w; }\n\n    firstch = w.substr(0,1);\n    if (firstch == \"y\") {\n      w = firstch.toUpperCase() + w.substr(1);\n    }\n\n    // Step 1a\n    re = re_1a\n    re2 = re2_1a;\n\n    if (re.test(w)) { w = w.replace(re,\"$1$2\"); }\n    else if (re2.test(w)) { w = w.replace(re2,\"$1$2\"); }\n\n    // Step 1b\n    re = re_1b;\n    re2 = re2_1b;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      re = re_mgr0;\n      if (re.test(fp[1])) {\n        re = re_1b_2;\n        w = w.replace(re,\"\");\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1];\n      re2 = re_s_v;\n      if (re2.test(stem)) {\n        w = stem;\n        re2 = re2_1b_2;\n        re3 = re3_1b_2;\n        re4 = re4_1b_2;\n        if (re2.test(w)) { w = w + \"e\"; }\n        else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,\"\"); }\n        else if (re4.test(w)) { w = w + \"e\"; }\n      }\n    }\n\n    // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)\n    re = re_1c;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      w = stem + \"i\";\n    }\n\n    // Step 2\n    re = re_2;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = re_mgr0;\n      if (re.test(stem)) {\n        w = stem + step2list[suffix];\n      }\n    }\n\n    // Step 3\n    re = re_3;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      suffix = fp[2];\n      re = re_mgr0;\n      if (re.test(stem)) {\n        w = stem + step3list[suffix];\n      }\n    }\n\n    // Step 4\n    re = re_4;\n    re2 = re2_4;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = re_mgr1;\n      if (re.test(stem)) {\n        w = stem;\n      }\n    } else if (re2.test(w)) {\n      var fp = re2.exec(w);\n      stem = fp[1] + fp[2];\n      re2 = re_mgr1;\n      if (re2.test(stem)) {\n        w = stem;\n      }\n    }\n\n    // Step 5\n    re = re_5;\n    if (re.test(w)) {\n      var fp = re.exec(w);\n      stem = fp[1];\n      re = re_mgr1;\n      re2 = re_meq1;\n      re3 = re3_5;\n      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {\n        w = stem;\n      }\n    }\n\n    re = re_5_1;\n    re2 = re_mgr1;\n    if (re.test(w) && re2.test(w)) {\n      re = re_1b_2;\n      w = w.replace(re,\"\");\n    }\n\n    // and turn initial Y back to y\n\n    if (firstch == \"y\") {\n      w = firstch.toLowerCase() + w.substr(1);\n    }\n\n    return w;\n  };\n\n  return function (token) {\n    return token.update(porterStemmer);\n  }\n})();\n\nlunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')\n/*!\n * lunr.stopWordFilter\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * lunr.generateStopWordFilter builds a stopWordFilter function from the provided\n * list of stop words.\n *\n * The built in lunr.stopWordFilter is built using this generator and can be used\n * to generate custom stopWordFilters for applications or non English languages.\n *\n * @function\n * @param {Array} token The token to pass through the filter\n * @returns {lunr.PipelineFunction}\n * @see lunr.Pipeline\n * @see lunr.stopWordFilter\n */\nlunr.generateStopWordFilter = function (stopWords) {\n  var words = stopWords.reduce(function (memo, stopWord) {\n    memo[stopWord] = stopWord\n    return memo\n  }, {})\n\n  return function (token) {\n    if (token && words[token.toString()] !== token.toString()) return token\n  }\n}\n\n/**\n * lunr.stopWordFilter is an English language stop word list filter, any words\n * contained in the list will not be passed through the filter.\n *\n * This is intended to be used in the Pipeline. If the token does not pass the\n * filter then undefined will be returned.\n *\n * @function\n * @implements {lunr.PipelineFunction}\n * @params {lunr.Token} token - A token to check for being a stop word.\n * @returns {lunr.Token}\n * @see {@link lunr.Pipeline}\n */\nlunr.stopWordFilter = lunr.generateStopWordFilter([\n  'a',\n  'able',\n  'about',\n  'across',\n  'after',\n  'all',\n  'almost',\n  'also',\n  'am',\n  'among',\n  'an',\n  'and',\n  'any',\n  'are',\n  'as',\n  'at',\n  'be',\n  'because',\n  'been',\n  'but',\n  'by',\n  'can',\n  'cannot',\n  'could',\n  'dear',\n  'did',\n  'do',\n  'does',\n  'either',\n  'else',\n  'ever',\n  'every',\n  'for',\n  'from',\n  'get',\n  'got',\n  'had',\n  'has',\n  'have',\n  'he',\n  'her',\n  'hers',\n  'him',\n  'his',\n  'how',\n  'however',\n  'i',\n  'if',\n  'in',\n  'into',\n  'is',\n  'it',\n  'its',\n  'just',\n  'least',\n  'let',\n  'like',\n  'likely',\n  'may',\n  'me',\n  'might',\n  'most',\n  'must',\n  'my',\n  'neither',\n  'no',\n  'nor',\n  'not',\n  'of',\n  'off',\n  'often',\n  'on',\n  'only',\n  'or',\n  'other',\n  'our',\n  'own',\n  'rather',\n  'said',\n  'say',\n  'says',\n  'she',\n  'should',\n  'since',\n  'so',\n  'some',\n  'than',\n  'that',\n  'the',\n  'their',\n  'them',\n  'then',\n  'there',\n  'these',\n  'they',\n  'this',\n  'tis',\n  'to',\n  'too',\n  'twas',\n  'us',\n  'wants',\n  'was',\n  'we',\n  'were',\n  'what',\n  'when',\n  'where',\n  'which',\n  'while',\n  'who',\n  'whom',\n  'why',\n  'will',\n  'with',\n  'would',\n  'yet',\n  'you',\n  'your'\n])\n\nlunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')\n/*!\n * lunr.trimmer\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * lunr.trimmer is a pipeline function for trimming non word\n * characters from the beginning and end of tokens before they\n * enter the index.\n *\n * This implementation may not work correctly for non latin\n * characters and should either be removed or adapted for use\n * with languages with non-latin characters.\n *\n * @static\n * @implements {lunr.PipelineFunction}\n * @param {lunr.Token} token The token to pass through the filter\n * @returns {lunr.Token}\n * @see lunr.Pipeline\n */\nlunr.trimmer = function (token) {\n  return token.update(function (s) {\n    return s.replace(/^\\W+/, '').replace(/\\W+$/, '')\n  })\n}\n\nlunr.Pipeline.registerFunction(lunr.trimmer, 'trimmer')\n/*!\n * lunr.TokenSet\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * A token set is used to store the unique list of all tokens\n * within an index. Token sets are also used to represent an\n * incoming query to the index, this query token set and index\n * token set are then intersected to find which tokens to look\n * up in the inverted index.\n *\n * A token set can hold multiple tokens, as in the case of the\n * index token set, or it can hold a single token as in the\n * case of a simple query token set.\n *\n * Additionally token sets are used to perform wildcard matching.\n * Leading, contained and trailing wildcards are supported, and\n * from this edit distance matching can also be provided.\n *\n * Token sets are implemented as a minimal finite state automata,\n * where both common prefixes and suffixes are shared between tokens.\n * This helps to reduce the space used for storing the token set.\n *\n * @constructor\n */\nlunr.TokenSet = function () {\n  this.final = false\n  this.edges = {}\n  this.id = lunr.TokenSet._nextId\n  lunr.TokenSet._nextId += 1\n}\n\n/**\n * Keeps track of the next, auto increment, identifier to assign\n * to a new tokenSet.\n *\n * TokenSets require a unique identifier to be correctly minimised.\n *\n * @private\n */\nlunr.TokenSet._nextId = 1\n\n/**\n * Creates a TokenSet instance from the given sorted array of words.\n *\n * @param {String[]} arr - A sorted array of strings to create the set from.\n * @returns {lunr.TokenSet}\n * @throws Will throw an error if the input array is not sorted.\n */\nlunr.TokenSet.fromArray = function (arr) {\n  var builder = new lunr.TokenSet.Builder\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    builder.insert(arr[i])\n  }\n\n  builder.finish()\n  return builder.root\n}\n\n/**\n * Creates a token set from a query clause.\n *\n * @private\n * @param {Object} clause - A single clause from lunr.Query.\n * @param {string} clause.term - The query clause term.\n * @param {number} [clause.editDistance] - The optional edit distance for the term.\n * @returns {lunr.TokenSet}\n */\nlunr.TokenSet.fromClause = function (clause) {\n  if ('editDistance' in clause) {\n    return lunr.TokenSet.fromFuzzyString(clause.term, clause.editDistance)\n  } else {\n    return lunr.TokenSet.fromString(clause.term)\n  }\n}\n\n/**\n * Creates a token set representing a single string with a specified\n * edit distance.\n *\n * Insertions, deletions, substitutions and transpositions are each\n * treated as an edit distance of 1.\n *\n * Increasing the allowed edit distance will have a dramatic impact\n * on the performance of both creating and intersecting these TokenSets.\n * It is advised to keep the edit distance less than 3.\n *\n * @param {string} str - The string to create the token set from.\n * @param {number} editDistance - The allowed edit distance to match.\n * @returns {lunr.Vector}\n */\nlunr.TokenSet.fromFuzzyString = function (str, editDistance) {\n  var root = new lunr.TokenSet\n\n  var stack = [{\n    node: root,\n    editsRemaining: editDistance,\n    str: str\n  }]\n\n  while (stack.length) {\n    var frame = stack.pop()\n\n    // no edit\n    if (frame.str.length > 0) {\n      var char = frame.str.charAt(0),\n          noEditNode\n\n      if (char in frame.node.edges) {\n        noEditNode = frame.node.edges[char]\n      } else {\n        noEditNode = new lunr.TokenSet\n        frame.node.edges[char] = noEditNode\n      }\n\n      if (frame.str.length == 1) {\n        noEditNode.final = true\n      }\n\n      stack.push({\n        node: noEditNode,\n        editsRemaining: frame.editsRemaining,\n        str: frame.str.slice(1)\n      })\n    }\n\n    if (frame.editsRemaining == 0) {\n      continue\n    }\n\n    // insertion\n    if (\"*\" in frame.node.edges) {\n      var insertionNode = frame.node.edges[\"*\"]\n    } else {\n      var insertionNode = new lunr.TokenSet\n      frame.node.edges[\"*\"] = insertionNode\n    }\n\n    if (frame.str.length == 0) {\n      insertionNode.final = true\n    }\n\n    stack.push({\n      node: insertionNode,\n      editsRemaining: frame.editsRemaining - 1,\n      str: frame.str\n    })\n\n    // deletion\n    // can only do a deletion if we have enough edits remaining\n    // and if there are characters left to delete in the string\n    if (frame.str.length > 1) {\n      stack.push({\n        node: frame.node,\n        editsRemaining: frame.editsRemaining - 1,\n        str: frame.str.slice(1)\n      })\n    }\n\n    // deletion\n    // just removing the last character from the str\n    if (frame.str.length == 1) {\n      frame.node.final = true\n    }\n\n    // substitution\n    // can only do a substitution if we have enough edits remaining\n    // and if there are characters left to substitute\n    if (frame.str.length >= 1) {\n      if (\"*\" in frame.node.edges) {\n        var substitutionNode = frame.node.edges[\"*\"]\n      } else {\n        var substitutionNode = new lunr.TokenSet\n        frame.node.edges[\"*\"] = substitutionNode\n      }\n\n      if (frame.str.length == 1) {\n        substitutionNode.final = true\n      }\n\n      stack.push({\n        node: substitutionNode,\n        editsRemaining: frame.editsRemaining - 1,\n        str: frame.str.slice(1)\n      })\n    }\n\n    // transposition\n    // can only do a transposition if there are edits remaining\n    // and there are enough characters to transpose\n    if (frame.str.length > 1) {\n      var charA = frame.str.charAt(0),\n          charB = frame.str.charAt(1),\n          transposeNode\n\n      if (charB in frame.node.edges) {\n        transposeNode = frame.node.edges[charB]\n      } else {\n        transposeNode = new lunr.TokenSet\n        frame.node.edges[charB] = transposeNode\n      }\n\n      if (frame.str.length == 1) {\n        transposeNode.final = true\n      }\n\n      stack.push({\n        node: transposeNode,\n        editsRemaining: frame.editsRemaining - 1,\n        str: charA + frame.str.slice(2)\n      })\n    }\n  }\n\n  return root\n}\n\n/**\n * Creates a TokenSet from a string.\n *\n * The string may contain one or more wildcard characters (*)\n * that will allow wildcard matching when intersecting with\n * another TokenSet.\n *\n * @param {string} str - The string to create a TokenSet from.\n * @returns {lunr.TokenSet}\n */\nlunr.TokenSet.fromString = function (str) {\n  var node = new lunr.TokenSet,\n      root = node\n\n  /*\n   * Iterates through all characters within the passed string\n   * appending a node for each character.\n   *\n   * When a wildcard character is found then a self\n   * referencing edge is introduced to continually match\n   * any number of any characters.\n   */\n  for (var i = 0, len = str.length; i < len; i++) {\n    var char = str[i],\n        final = (i == len - 1)\n\n    if (char == \"*\") {\n      node.edges[char] = node\n      node.final = final\n\n    } else {\n      var next = new lunr.TokenSet\n      next.final = final\n\n      node.edges[char] = next\n      node = next\n    }\n  }\n\n  return root\n}\n\n/**\n * Converts this TokenSet into an array of strings\n * contained within the TokenSet.\n *\n * This is not intended to be used on a TokenSet that\n * contains wildcards, in these cases the results are\n * undefined and are likely to cause an infinite loop.\n *\n * @returns {string[]}\n */\nlunr.TokenSet.prototype.toArray = function () {\n  var words = []\n\n  var stack = [{\n    prefix: \"\",\n    node: this\n  }]\n\n  while (stack.length) {\n    var frame = stack.pop(),\n        edges = Object.keys(frame.node.edges),\n        len = edges.length\n\n    if (frame.node.final) {\n      /* In Safari, at this point the prefix is sometimes corrupted, see:\n       * https://github.com/olivernn/lunr.js/issues/279 Calling any\n       * String.prototype method forces Safari to \"cast\" this string to what\n       * it's supposed to be, fixing the bug. */\n      frame.prefix.charAt(0)\n      words.push(frame.prefix)\n    }\n\n    for (var i = 0; i < len; i++) {\n      var edge = edges[i]\n\n      stack.push({\n        prefix: frame.prefix.concat(edge),\n        node: frame.node.edges[edge]\n      })\n    }\n  }\n\n  return words\n}\n\n/**\n * Generates a string representation of a TokenSet.\n *\n * This is intended to allow TokenSets to be used as keys\n * in objects, largely to aid the construction and minimisation\n * of a TokenSet. As such it is not designed to be a human\n * friendly representation of the TokenSet.\n *\n * @returns {string}\n */\nlunr.TokenSet.prototype.toString = function () {\n  // NOTE: Using Object.keys here as this.edges is very likely\n  // to enter 'hash-mode' with many keys being added\n  //\n  // avoiding a for-in loop here as it leads to the function\n  // being de-optimised (at least in V8). From some simple\n  // benchmarks the performance is comparable, but allowing\n  // V8 to optimize may mean easy performance wins in the future.\n\n  if (this._str) {\n    return this._str\n  }\n\n  var str = this.final ? '1' : '0',\n      labels = Object.keys(this.edges).sort(),\n      len = labels.length\n\n  for (var i = 0; i < len; i++) {\n    var label = labels[i],\n        node = this.edges[label]\n\n    str = str + label + node.id\n  }\n\n  return str\n}\n\n/**\n * Returns a new TokenSet that is the intersection of\n * this TokenSet and the passed TokenSet.\n *\n * This intersection will take into account any wildcards\n * contained within the TokenSet.\n *\n * @param {lunr.TokenSet} b - An other TokenSet to intersect with.\n * @returns {lunr.TokenSet}\n */\nlunr.TokenSet.prototype.intersect = function (b) {\n  var output = new lunr.TokenSet,\n      frame = undefined\n\n  var stack = [{\n    qNode: b,\n    output: output,\n    node: this\n  }]\n\n  while (stack.length) {\n    frame = stack.pop()\n\n    // NOTE: As with the #toString method, we are using\n    // Object.keys and a for loop instead of a for-in loop\n    // as both of these objects enter 'hash' mode, causing\n    // the function to be de-optimised in V8\n    var qEdges = Object.keys(frame.qNode.edges),\n        qLen = qEdges.length,\n        nEdges = Object.keys(frame.node.edges),\n        nLen = nEdges.length\n\n    for (var q = 0; q < qLen; q++) {\n      var qEdge = qEdges[q]\n\n      for (var n = 0; n < nLen; n++) {\n        var nEdge = nEdges[n]\n\n        if (nEdge == qEdge || qEdge == '*') {\n          var node = frame.node.edges[nEdge],\n              qNode = frame.qNode.edges[qEdge],\n              final = node.final && qNode.final,\n              next = undefined\n\n          if (nEdge in frame.output.edges) {\n            // an edge already exists for this character\n            // no need to create a new node, just set the finality\n            // bit unless this node is already final\n            next = frame.output.edges[nEdge]\n            next.final = next.final || final\n\n          } else {\n            // no edge exists yet, must create one\n            // set the finality bit and insert it\n            // into the output\n            next = new lunr.TokenSet\n            next.final = final\n            frame.output.edges[nEdge] = next\n          }\n\n          stack.push({\n            qNode: qNode,\n            output: next,\n            node: node\n          })\n        }\n      }\n    }\n  }\n\n  return output\n}\nlunr.TokenSet.Builder = function () {\n  this.previousWord = \"\"\n  this.root = new lunr.TokenSet\n  this.uncheckedNodes = []\n  this.minimizedNodes = {}\n}\n\nlunr.TokenSet.Builder.prototype.insert = function (word) {\n  var node,\n      commonPrefix = 0\n\n  if (word < this.previousWord) {\n    throw new Error (\"Out of order word insertion\")\n  }\n\n  for (var i = 0; i < word.length && i < this.previousWord.length; i++) {\n    if (word[i] != this.previousWord[i]) break\n    commonPrefix++\n  }\n\n  this.minimize(commonPrefix)\n\n  if (this.uncheckedNodes.length == 0) {\n    node = this.root\n  } else {\n    node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child\n  }\n\n  for (var i = commonPrefix; i < word.length; i++) {\n    var nextNode = new lunr.TokenSet,\n        char = word[i]\n\n    node.edges[char] = nextNode\n\n    this.uncheckedNodes.push({\n      parent: node,\n      char: char,\n      child: nextNode\n    })\n\n    node = nextNode\n  }\n\n  node.final = true\n  this.previousWord = word\n}\n\nlunr.TokenSet.Builder.prototype.finish = function () {\n  this.minimize(0)\n}\n\nlunr.TokenSet.Builder.prototype.minimize = function (downTo) {\n  for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {\n    var node = this.uncheckedNodes[i],\n        childKey = node.child.toString()\n\n    if (childKey in this.minimizedNodes) {\n      node.parent.edges[node.char] = this.minimizedNodes[childKey]\n    } else {\n      // Cache the key for this node since\n      // we know it can't change anymore\n      node.child._str = childKey\n\n      this.minimizedNodes[childKey] = node.child\n    }\n\n    this.uncheckedNodes.pop()\n  }\n}\n/*!\n * lunr.Index\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * An index contains the built index of all documents and provides a query interface\n * to the index.\n *\n * Usually instances of lunr.Index will not be created using this constructor, instead\n * lunr.Builder should be used to construct new indexes, or lunr.Index.load should be\n * used to load previously built and serialized indexes.\n *\n * @constructor\n * @param {Object} attrs - The attributes of the built search index.\n * @param {Object} attrs.invertedIndex - An index of term/field to document reference.\n * @param {Object<string, lunr.Vector>} attrs.fieldVectors - Field vectors\n * @param {lunr.TokenSet} attrs.tokenSet - An set of all corpus tokens.\n * @param {string[]} attrs.fields - The names of indexed document fields.\n * @param {lunr.Pipeline} attrs.pipeline - The pipeline to use for search terms.\n */\nlunr.Index = function (attrs) {\n  this.invertedIndex = attrs.invertedIndex\n  this.fieldVectors = attrs.fieldVectors\n  this.tokenSet = attrs.tokenSet\n  this.fields = attrs.fields\n  this.pipeline = attrs.pipeline\n}\n\n/**\n * A result contains details of a document matching a search query.\n * @typedef {Object} lunr.Index~Result\n * @property {string} ref - The reference of the document this result represents.\n * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.\n * @property {lunr.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.\n */\n\n/**\n * Although lunr provides the ability to create queries using lunr.Query, it also provides a simple\n * query language which itself is parsed into an instance of lunr.Query.\n *\n * For programmatically building queries it is advised to directly use lunr.Query, the query language\n * is best used for human entered text rather than program generated text.\n *\n * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported\n * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'\n * or 'world', though those that contain both will rank higher in the results.\n *\n * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can\n * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding\n * wildcards will increase the number of documents that will be found but can also have a negative\n * impact on query performance, especially with wildcards at the beginning of a term.\n *\n * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term\n * hello in the title field will match this query. Using a field not present in the index will lead\n * to an error being thrown.\n *\n * Modifiers can also be added to terms, lunr supports edit distance and boost modifiers on terms. A term\n * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported\n * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.\n * Avoid large values for edit distance to improve query performance.\n *\n * Each term also supports a presence modifier. By default a term's presence in document is optional, however\n * this can be changed to either required or prohibited. For a term's presence to be required in a document the\n * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and\n * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not\n * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'.\n *\n * To escape special characters the backslash character '\\' can be used, this allows searches to include\n * characters that would normally be considered modifiers, e.g. `foo\\~2` will search for a term \"foo~2\" instead\n * of attempting to apply a boost of 2 to the search term \"foo\".\n *\n * @typedef {string} lunr.Index~QueryString\n * @example <caption>Simple single term query</caption>\n * hello\n * @example <caption>Multiple term query</caption>\n * hello world\n * @example <caption>term scoped to a field</caption>\n * title:hello\n * @example <caption>term with a boost of 10</caption>\n * hello^10\n * @example <caption>term with an edit distance of 2</caption>\n * hello~2\n * @example <caption>terms with presence modifiers</caption>\n * -foo +bar baz\n */\n\n/**\n * Performs a search against the index using lunr query syntax.\n *\n * Results will be returned sorted by their score, the most relevant results\n * will be returned first.  For details on how the score is calculated, please see\n * the {@link https://lunrjs.com/guides/searching.html#scoring|guide}.\n *\n * For more programmatic querying use lunr.Index#query.\n *\n * @param {lunr.Index~QueryString} queryString - A string containing a lunr query.\n * @throws {lunr.QueryParseError} If the passed query string cannot be parsed.\n * @returns {lunr.Index~Result[]}\n */\nlunr.Index.prototype.search = function (queryString) {\n  return this.query(function (query) {\n    var parser = new lunr.QueryParser(queryString, query)\n    parser.parse()\n  })\n}\n\n/**\n * A query builder callback provides a query object to be used to express\n * the query to perform on the index.\n *\n * @callback lunr.Index~queryBuilder\n * @param {lunr.Query} query - The query object to build up.\n * @this lunr.Query\n */\n\n/**\n * Performs a query against the index using the yielded lunr.Query object.\n *\n * If performing programmatic queries against the index, this method is preferred\n * over lunr.Index#search so as to avoid the additional query parsing overhead.\n *\n * A query object is yielded to the supplied function which should be used to\n * express the query to be run against the index.\n *\n * Note that although this function takes a callback parameter it is _not_ an\n * asynchronous operation, the callback is just yielded a query object to be\n * customized.\n *\n * @param {lunr.Index~queryBuilder} fn - A function that is used to build the query.\n * @returns {lunr.Index~Result[]}\n */\nlunr.Index.prototype.query = function (fn) {\n  // for each query clause\n  // * process terms\n  // * expand terms from token set\n  // * find matching documents and metadata\n  // * get document vectors\n  // * score documents\n\n  var query = new lunr.Query(this.fields),\n      matchingFields = Object.create(null),\n      queryVectors = Object.create(null),\n      termFieldCache = Object.create(null),\n      requiredMatches = Object.create(null),\n      prohibitedMatches = Object.create(null)\n\n  /*\n   * To support field level boosts a query vector is created per\n   * field. An empty vector is eagerly created to support negated\n   * queries.\n   */\n  for (var i = 0; i < this.fields.length; i++) {\n    queryVectors[this.fields[i]] = new lunr.Vector\n  }\n\n  fn.call(query, query)\n\n  for (var i = 0; i < query.clauses.length; i++) {\n    /*\n     * Unless the pipeline has been disabled for this term, which is\n     * the case for terms with wildcards, we need to pass the clause\n     * term through the search pipeline. A pipeline returns an array\n     * of processed terms. Pipeline functions may expand the passed\n     * term, which means we may end up performing multiple index lookups\n     * for a single query term.\n     */\n    var clause = query.clauses[i],\n        terms = null,\n        clauseMatches = lunr.Set.empty\n\n    if (clause.usePipeline) {\n      terms = this.pipeline.runString(clause.term, {\n        fields: clause.fields\n      })\n    } else {\n      terms = [clause.term]\n    }\n\n    for (var m = 0; m < terms.length; m++) {\n      var term = terms[m]\n\n      /*\n       * Each term returned from the pipeline needs to use the same query\n       * clause object, e.g. the same boost and or edit distance. The\n       * simplest way to do this is to re-use the clause object but mutate\n       * its term property.\n       */\n      clause.term = term\n\n      /*\n       * From the term in the clause we create a token set which will then\n       * be used to intersect the indexes token set to get a list of terms\n       * to lookup in the inverted index\n       */\n      var termTokenSet = lunr.TokenSet.fromClause(clause),\n          expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()\n\n      /*\n       * If a term marked as required does not exist in the tokenSet it is\n       * impossible for the search to return any matches. We set all the field\n       * scoped required matches set to empty and stop examining any further\n       * clauses.\n       */\n      if (expandedTerms.length === 0 && clause.presence === lunr.Query.presence.REQUIRED) {\n        for (var k = 0; k < clause.fields.length; k++) {\n          var field = clause.fields[k]\n          requiredMatches[field] = lunr.Set.empty\n        }\n\n        break\n      }\n\n      for (var j = 0; j < expandedTerms.length; j++) {\n        /*\n         * For each term get the posting and termIndex, this is required for\n         * building the query vector.\n         */\n        var expandedTerm = expandedTerms[j],\n            posting = this.invertedIndex[expandedTerm],\n            termIndex = posting._index\n\n        for (var k = 0; k < clause.fields.length; k++) {\n          /*\n           * For each field that this query term is scoped by (by default\n           * all fields are in scope) we need to get all the document refs\n           * that have this term in that field.\n           *\n           * The posting is the entry in the invertedIndex for the matching\n           * term from above.\n           */\n          var field = clause.fields[k],\n              fieldPosting = posting[field],\n              matchingDocumentRefs = Object.keys(fieldPosting),\n              termField = expandedTerm + \"/\" + field,\n              matchingDocumentsSet = new lunr.Set(matchingDocumentRefs)\n\n          /*\n           * if the presence of this term is required ensure that the matching\n           * documents are added to the set of required matches for this clause.\n           *\n           */\n          if (clause.presence == lunr.Query.presence.REQUIRED) {\n            clauseMatches = clauseMatches.union(matchingDocumentsSet)\n\n            if (requiredMatches[field] === undefined) {\n              requiredMatches[field] = lunr.Set.complete\n            }\n          }\n\n          /*\n           * if the presence of this term is prohibited ensure that the matching\n           * documents are added to the set of prohibited matches for this field,\n           * creating that set if it does not yet exist.\n           */\n          if (clause.presence == lunr.Query.presence.PROHIBITED) {\n            if (prohibitedMatches[field] === undefined) {\n              prohibitedMatches[field] = lunr.Set.empty\n            }\n\n            prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet)\n\n            /*\n             * Prohibited matches should not be part of the query vector used for\n             * similarity scoring and no metadata should be extracted so we continue\n             * to the next field\n             */\n            continue\n          }\n\n          /*\n           * The query field vector is populated using the termIndex found for\n           * the term and a unit value with the appropriate boost applied.\n           * Using upsert because there could already be an entry in the vector\n           * for the term we are working with. In that case we just add the scores\n           * together.\n           */\n          queryVectors[field].upsert(termIndex, clause.boost, function (a, b) { return a + b })\n\n          /**\n           * If we've already seen this term, field combo then we've already collected\n           * the matching documents and metadata, no need to go through all that again\n           */\n          if (termFieldCache[termField]) {\n            continue\n          }\n\n          for (var l = 0; l < matchingDocumentRefs.length; l++) {\n            /*\n             * All metadata for this term/field/document triple\n             * are then extracted and collected into an instance\n             * of lunr.MatchData ready to be returned in the query\n             * results\n             */\n            var matchingDocumentRef = matchingDocumentRefs[l],\n                matchingFieldRef = new lunr.FieldRef (matchingDocumentRef, field),\n                metadata = fieldPosting[matchingDocumentRef],\n                fieldMatch\n\n            if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {\n              matchingFields[matchingFieldRef] = new lunr.MatchData (expandedTerm, field, metadata)\n            } else {\n              fieldMatch.add(expandedTerm, field, metadata)\n            }\n\n          }\n\n          termFieldCache[termField] = true\n        }\n      }\n    }\n\n    /**\n     * If the presence was required we need to update the requiredMatches field sets.\n     * We do this after all fields for the term have collected their matches because\n     * the clause terms presence is required in _any_ of the fields not _all_ of the\n     * fields.\n     */\n    if (clause.presence === lunr.Query.presence.REQUIRED) {\n      for (var k = 0; k < clause.fields.length; k++) {\n        var field = clause.fields[k]\n        requiredMatches[field] = requiredMatches[field].intersect(clauseMatches)\n      }\n    }\n  }\n\n  /**\n   * Need to combine the field scoped required and prohibited\n   * matching documents into a global set of required and prohibited\n   * matches\n   */\n  var allRequiredMatches = lunr.Set.complete,\n      allProhibitedMatches = lunr.Set.empty\n\n  for (var i = 0; i < this.fields.length; i++) {\n    var field = this.fields[i]\n\n    if (requiredMatches[field]) {\n      allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field])\n    }\n\n    if (prohibitedMatches[field]) {\n      allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field])\n    }\n  }\n\n  var matchingFieldRefs = Object.keys(matchingFields),\n      results = [],\n      matches = Object.create(null)\n\n  /*\n   * If the query is negated (contains only prohibited terms)\n   * we need to get _all_ fieldRefs currently existing in the\n   * index. This is only done when we know that the query is\n   * entirely prohibited terms to avoid any cost of getting all\n   * fieldRefs unnecessarily.\n   *\n   * Additionally, blank MatchData must be created to correctly\n   * populate the results.\n   */\n  if (query.isNegated()) {\n    matchingFieldRefs = Object.keys(this.fieldVectors)\n\n    for (var i = 0; i < matchingFieldRefs.length; i++) {\n      var matchingFieldRef = matchingFieldRefs[i]\n      var fieldRef = lunr.FieldRef.fromString(matchingFieldRef)\n      matchingFields[matchingFieldRef] = new lunr.MatchData\n    }\n  }\n\n  for (var i = 0; i < matchingFieldRefs.length; i++) {\n    /*\n     * Currently we have document fields that match the query, but we\n     * need to return documents. The matchData and scores are combined\n     * from multiple fields belonging to the same document.\n     *\n     * Scores are calculated by field, using the query vectors created\n     * above, and combined into a final document score using addition.\n     */\n    var fieldRef = lunr.FieldRef.fromString(matchingFieldRefs[i]),\n        docRef = fieldRef.docRef\n\n    if (!allRequiredMatches.contains(docRef)) {\n      continue\n    }\n\n    if (allProhibitedMatches.contains(docRef)) {\n      continue\n    }\n\n    var fieldVector = this.fieldVectors[fieldRef],\n        score = queryVectors[fieldRef.fieldName].similarity(fieldVector),\n        docMatch\n\n    if ((docMatch = matches[docRef]) !== undefined) {\n      docMatch.score += score\n      docMatch.matchData.combine(matchingFields[fieldRef])\n    } else {\n      var match = {\n        ref: docRef,\n        score: score,\n        matchData: matchingFields[fieldRef]\n      }\n      matches[docRef] = match\n      results.push(match)\n    }\n  }\n\n  /*\n   * Sort the results objects by score, highest first.\n   */\n  return results.sort(function (a, b) {\n    return b.score - a.score\n  })\n}\n\n/**\n * Prepares the index for JSON serialization.\n *\n * The schema for this JSON blob will be described in a\n * separate JSON schema file.\n *\n * @returns {Object}\n */\nlunr.Index.prototype.toJSON = function () {\n  var invertedIndex = Object.keys(this.invertedIndex)\n    .sort()\n    .map(function (term) {\n      return [term, this.invertedIndex[term]]\n    }, this)\n\n  var fieldVectors = Object.keys(this.fieldVectors)\n    .map(function (ref) {\n      return [ref, this.fieldVectors[ref].toJSON()]\n    }, this)\n\n  return {\n    version: lunr.version,\n    fields: this.fields,\n    fieldVectors: fieldVectors,\n    invertedIndex: invertedIndex,\n    pipeline: this.pipeline.toJSON()\n  }\n}\n\n/**\n * Loads a previously serialized lunr.Index\n *\n * @param {Object} serializedIndex - A previously serialized lunr.Index\n * @returns {lunr.Index}\n */\nlunr.Index.load = function (serializedIndex) {\n  var attrs = {},\n      fieldVectors = {},\n      serializedVectors = serializedIndex.fieldVectors,\n      invertedIndex = Object.create(null),\n      serializedInvertedIndex = serializedIndex.invertedIndex,\n      tokenSetBuilder = new lunr.TokenSet.Builder,\n      pipeline = lunr.Pipeline.load(serializedIndex.pipeline)\n\n  if (serializedIndex.version != lunr.version) {\n    lunr.utils.warn(\"Version mismatch when loading serialised index. Current version of lunr '\" + lunr.version + \"' does not match serialized index '\" + serializedIndex.version + \"'\")\n  }\n\n  for (var i = 0; i < serializedVectors.length; i++) {\n    var tuple = serializedVectors[i],\n        ref = tuple[0],\n        elements = tuple[1]\n\n    fieldVectors[ref] = new lunr.Vector(elements)\n  }\n\n  for (var i = 0; i < serializedInvertedIndex.length; i++) {\n    var tuple = serializedInvertedIndex[i],\n        term = tuple[0],\n        posting = tuple[1]\n\n    tokenSetBuilder.insert(term)\n    invertedIndex[term] = posting\n  }\n\n  tokenSetBuilder.finish()\n\n  attrs.fields = serializedIndex.fields\n\n  attrs.fieldVectors = fieldVectors\n  attrs.invertedIndex = invertedIndex\n  attrs.tokenSet = tokenSetBuilder.root\n  attrs.pipeline = pipeline\n\n  return new lunr.Index(attrs)\n}\n/*!\n * lunr.Builder\n * Copyright (C) 2020 Oliver Nightingale\n */\n\n/**\n * lunr.Builder performs indexing on a set of documents and\n * returns instances of lunr.Index ready for querying.\n *\n * All configuration of the index is done via the builder, the\n * fields to index, the document reference, the text processing\n * pipeline and document scoring parameters are all set on the\n * builder before indexing.\n *\n * @constructor\n * @property {string} _ref - Internal reference to the document reference field.\n * @property {string[]} _fields - Internal reference to the document fields to index.\n * @property {object} invertedIndex - The inverted index maps terms to document fields.\n * @property {object} documentTermFrequencies - Keeps track of document term frequencies.\n * @property {object} documentLengths - Keeps track of the length of documents added to the index.\n * @property {lunr.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.\n * @property {lunr.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.\n * @property {lunr.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.\n * @property {number} documentCount - Keeps track of the total number of documents indexed.\n * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.\n * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.\n * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.\n * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.\n */\nlunr.Builder = function () {\n  this._ref = \"id\"\n  this._fields = Object.create(null)\n  this._documents = Object.create(null)\n  this.invertedIndex = Object.create(null)\n  this.fieldTermFrequencies = {}\n  this.fieldLengths = {}\n  this.tokenizer = lunr.tokenizer\n  this.pipeline = new lunr.Pipeline\n  this.searchPipeline = new lunr.Pipeline\n  this.documentCount = 0\n  this._b = 0.75\n  this._k1 = 1.2\n  this.termIndex = 0\n  this.metadataWhitelist = []\n}\n\n/**\n * Sets the document field used as the document reference. Every document must have this field.\n * The type of this field in the document should be a string, if it is not a string it will be\n * coerced into a string by calling toString.\n *\n * The default ref is 'id'.\n *\n * The ref should _not_ be changed during indexing, it should be set before any documents are\n * added to the index. Changing it during indexing can lead to inconsistent results.\n *\n * @param {string} ref - The name of the reference field in the document.\n */\nlunr.Builder.prototype.ref = function (ref) {\n  this._ref = ref\n}\n\n/**\n * A function that is used to extract a field from a document.\n *\n * Lunr expects a field to be at the top level of a document, if however the field\n * is deeply nested within a document an extractor function can be used to extract\n * the right field for indexing.\n *\n * @callback fieldExtractor\n * @param {object} doc - The document being added to the index.\n * @returns {?(string|object|object[])} obj - The object that will be indexed for this field.\n * @example <caption>Extracting a nested field</caption>\n * function (doc) { return doc.nested.field }\n */\n\n/**\n * Adds a field to the list of document fields that will be indexed. Every document being\n * indexed should have this field. Null values for this field in indexed documents will\n * not cause errors but will limit the chance of that document being retrieved by searches.\n *\n * All fields should be added before adding documents to the index. Adding fields after\n * a document has been indexed will have no effect on already indexed documents.\n *\n * Fields can be boosted at build time. This allows terms within that field to have more\n * importance when ranking search results. Use a field boost to specify that matches within\n * one field are more important than other fields.\n *\n * @param {string} fieldName - The name of a field to index in all documents.\n * @param {object} attributes - Optional attributes associated with this field.\n * @param {number} [attributes.boost=1] - Boost applied to all terms within this field.\n * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document.\n * @throws {RangeError} fieldName cannot contain unsupported characters '/'\n */\nlunr.Builder.prototype.field = function (fieldName, attributes) {\n  if (/\\//.test(fieldName)) {\n    throw new RangeError (\"Field '\" + fieldName + \"' contains illegal character '/'\")\n  }\n\n  this._fields[fieldName] = attributes || {}\n}\n\n/**\n * A parameter to tune the amount of field length normalisation that is applied when\n * calculating relevance scores. A value of 0 will completely disable any normalisation\n * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b\n * will be clamped to the range 0 - 1.\n *\n * @param {number} number - The value to set for this tuning parameter.\n */\nlunr.Builder.prototype.b = function (number) {\n  if (number < 0) {\n    this._b = 0\n  } else if (number > 1) {\n    this._b = 1\n  } else {\n    this._b = number\n  }\n}\n\n/**\n * A parameter that controls the speed at which a rise in term frequency results in term\n * frequency saturation. The default value is 1.2. Setting this to a higher value will give\n * slower saturation levels, a lower value will result in quicker saturation.\n *\n * @param {number} number - The value to set for this tuning parameter.\n */\nlunr.Builder.prototype.k1 = function (number) {\n  this._k1 = number\n}\n\n/**\n * Adds a document to the index.\n *\n * Before adding fields to the index the index should have been fully setup, with the document\n * ref and all fields to index already having been specified.\n *\n * The document must have a field name as specified by the ref (by default this is 'id') and\n * it should have all fields defined for indexing, though null or undefined values will not\n * cause errors.\n *\n * Entire documents can be boosted at build time. Applying a boost to a document indicates that\n * this document should rank higher in search results than other documents.\n *\n * @param {object} doc - The document to add to the index.\n * @param {object} attributes - Optional attributes associated with this document.\n * @param {number} [attributes.boost=1] - Boost applied to all terms within this document.\n */\nlunr.Builder.prototype.add = function (doc, attributes) {\n  var docRef = doc[this._ref],\n      fields = Object.keys(this._fields)\n\n  this._documents[docRef] = attributes || {}\n  this.documentCount += 1\n\n  for (var i = 0; i < fields.length; i++) {\n    var fieldName = fields[i],\n        extractor = this._fields[fieldName].extractor,\n        field = extractor ? extractor(doc) : doc[fieldName],\n        tokens = this.tokenizer(field, {\n          fields: [fieldName]\n        }),\n        terms = this.pipeline.run(tokens),\n        fieldRef = new lunr.FieldRef (docRef, fieldName),\n        fieldTerms = Object.create(null)\n\n    this.fieldTermFrequencies[fieldRef] = fieldTerms\n    this.fieldLengths[fieldRef] = 0\n\n    // store the length of this field for this document\n    this.fieldLengths[fieldRef] += terms.length\n\n    // calculate term frequencies for this field\n    for (var j = 0; j < terms.length; j++) {\n      var term = terms[j]\n\n      if (fieldTerms[term] == undefined) {\n        fieldTerms[term] = 0\n      }\n\n      fieldTerms[term] += 1\n\n      // add to inverted index\n      // create an initial posting if one doesn't exist\n      if (this.invertedIndex[term] == undefined) {\n        var posting = Object.create(null)\n        posting[\"_index\"] = this.termIndex\n        this.termIndex += 1\n\n        for (var k = 0; k < fields.length; k++) {\n          posting[fields[k]] = Object.create(null)\n        }\n\n        this.invertedIndex[term] = posting\n      }\n\n      // add an entry for this term/fieldName/docRef to the invertedIndex\n      if (this.invertedIndex[term][fieldName][docRef] == undefined) {\n        this.invertedIndex[term][fieldName][docRef] = Object.create(null)\n      }\n\n      // store all whitelisted metadata about this token in the\n      // inverted index\n      for (var l = 0; l < this.metadataWhitelist.length; l++) {\n        var metadataKey = this.metadataWhitelist[l],\n            metadata = term.metadata[metadataKey]\n\n        if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {\n          this.invertedIndex[term][fieldName][docRef][metadataKey] = []\n        }\n\n        this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)\n      }\n    }\n\n  }\n}\n\n/**\n * Calculates the average document length for this index\n *\n * @private\n */\nlunr.Builder.prototype.calculateAverageFieldLengths = function () {\n\n  var fieldRefs = Object.keys(this.fieldLengths),\n      numberOfFields = fieldRefs.length,\n      accumulator = {},\n      documentsWithField = {}\n\n  for (var i = 0; i < numberOfFields; i++) {\n    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),\n        field = fieldRef.fieldName\n\n    documentsWithField[field] || (documentsWithField[field] = 0)\n    documentsWithField[field] += 1\n\n    accumulator[field] || (accumulator[field] = 0)\n    accumulator[field] += this.fieldLengths[fieldRef]\n  }\n\n  var fields = Object.keys(this._fields)\n\n  for (var i = 0; i < fields.length; i++) {\n    var fieldName = fields[i]\n    accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName]\n  }\n\n  this.averageFieldLength = accumulator\n}\n\n/**\n * Builds a vector space model of every document using lunr.Vector\n *\n * @private\n */\nlunr.Builder.prototype.createFieldVectors = function () {\n  var fieldVectors = {},\n      fieldRefs = Object.keys(this.fieldTermFrequencies),\n      fieldRefsLength = fieldRefs.length,\n      termIdfCache = Object.create(null)\n\n  for (var i = 0; i < fieldRefsLength; i++) {\n    var fieldRef = lunr.FieldRef.fromString(fieldRefs[i]),\n        fieldName = fieldRef.fieldName,\n        fieldLength = this.fieldLengths[fieldRef],\n        fieldVector = new lunr.Vector,\n        termFrequencies = this.fieldTermFrequencies[fieldRef],\n        terms = Object.keys(termFrequencies),\n        termsLength = terms.length\n\n\n    var fieldBoost = this._fields[fieldName].boost || 1,\n        docBoost = this._documents[fieldRef.docRef].boost || 1\n\n    for (var j = 0; j < termsLength; j++) {\n      var term = terms[j],\n          tf = termFrequencies[term],\n          termIndex = this.invertedIndex[term]._index,\n          idf, score, scoreWithPrecision\n\n      if (termIdfCache[term] === undefined) {\n        idf = lunr.idf(this.invertedIndex[term], this.documentCount)\n        termIdfCache[term] = idf\n      } else {\n        idf = termIdfCache[term]\n      }\n\n      score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf)\n      score *= fieldBoost\n      score *= docBoost\n      scoreWithPrecision = Math.round(score * 1000) / 1000\n      // Converts 1.23456789 to 1.234.\n      // Reducing the precision so that the vectors take up less\n      // space when serialised. Doing it now so that they behave\n      // the same before and after serialisation. Also, this is\n      // the fastest approach to reducing a number's precision in\n      // JavaScript.\n\n      fieldVector.insert(termIndex, scoreWithPrecision)\n    }\n\n    fieldVectors[fieldRef] = fieldVector\n  }\n\n  this.fieldVectors = fieldVectors\n}\n\n/**\n * Creates a token set of all tokens in the index using lunr.TokenSet\n *\n * @private\n */\nlunr.Builder.prototype.createTokenSet = function () {\n  this.tokenSet = lunr.TokenSet.fromArray(\n    Object.keys(this.invertedIndex).sort()\n  )\n}\n\n/**\n * Builds the index, creating an instance of lunr.Index.\n *\n * This completes the indexing process and should only be called\n * once all documents have been added to the index.\n *\n * @returns {lunr.Index}\n */\nlunr.Builder.prototype.build = function () {\n  this.calculateAverageFieldLengths()\n  this.createFieldVectors()\n  this.createTokenSet()\n\n  return new lunr.Index({\n    invertedIndex: this.invertedIndex,\n    fieldVectors: this.fieldVectors,\n    tokenSet: this.tokenSet,\n    fields: Object.keys(this._fields),\n    pipeline: this.searchPipeline\n  })\n}\n\n/**\n * Applies a plugin to the index builder.\n *\n * A plugin is a function that is called with the index builder as its context.\n * Plugins can be used to customise or extend the behaviour of the index\n * in some way. A plugin is just a function, that encapsulated the custom\n * behaviour that should be applied when building the index.\n *\n * The plugin function will be called with the index builder as its argument, additional\n * arguments can also be passed when calling use. The function will be called\n * with the index builder as its context.\n *\n * @param {Function} plugin The plugin to apply.\n */\nlunr.Builder.prototype.use = function (fn) {\n  var args = Array.prototype.slice.call(arguments, 1)\n  args.unshift(this)\n  fn.apply(this, args)\n}\n/**\n * Contains and collects metadata about a matching document.\n * A single instance of lunr.MatchData is returned as part of every\n * lunr.Index~Result.\n *\n * @constructor\n * @param {string} term - The term this match data is associated with\n * @param {string} field - The field in which the term was found\n * @param {object} metadata - The metadata recorded about this term in this field\n * @property {object} metadata - A cloned collection of metadata associated with this document.\n * @see {@link lunr.Index~Result}\n */\nlunr.MatchData = function (term, field, metadata) {\n  var clonedMetadata = Object.create(null),\n      metadataKeys = Object.keys(metadata || {})\n\n  // Cloning the metadata to prevent the original\n  // being mutated during match data combination.\n  // Metadata is kept in an array within the inverted\n  // index so cloning the data can be done with\n  // Array#slice\n  for (var i = 0; i < metadataKeys.length; i++) {\n    var key = metadataKeys[i]\n    clonedMetadata[key] = metadata[key].slice()\n  }\n\n  this.metadata = Object.create(null)\n\n  if (term !== undefined) {\n    this.metadata[term] = Object.create(null)\n    this.metadata[term][field] = clonedMetadata\n  }\n}\n\n/**\n * An instance of lunr.MatchData will be created for every term that matches a\n * document. However only one instance is required in a lunr.Index~Result. This\n * method combines metadata from another instance of lunr.MatchData with this\n * objects metadata.\n *\n * @param {lunr.MatchData} otherMatchData - Another instance of match data to merge with this one.\n * @see {@link lunr.Index~Result}\n */\nlunr.MatchData.prototype.combine = function (otherMatchData) {\n  var terms = Object.keys(otherMatchData.metadata)\n\n  for (var i = 0; i < terms.length; i++) {\n    var term = terms[i],\n        fields = Object.keys(otherMatchData.metadata[term])\n\n    if (this.metadata[term] == undefined) {\n      this.metadata[term] = Object.create(null)\n    }\n\n    for (var j = 0; j < fields.length; j++) {\n      var field = fields[j],\n          keys = Object.keys(otherMatchData.metadata[term][field])\n\n      if (this.metadata[term][field] == undefined) {\n        this.metadata[term][field] = Object.create(null)\n      }\n\n      for (var k = 0; k < keys.length; k++) {\n        var key = keys[k]\n\n        if (this.metadata[term][field][key] == undefined) {\n          this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]\n        } else {\n          this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])\n        }\n\n      }\n    }\n  }\n}\n\n/**\n * Add metadata for a term/field pair to this instance of match data.\n *\n * @param {string} term - The term this match data is associated with\n * @param {string} field - The field in which the term was found\n * @param {object} metadata - The metadata recorded about this term in this field\n */\nlunr.MatchData.prototype.add = function (term, field, metadata) {\n  if (!(term in this.metadata)) {\n    this.metadata[term] = Object.create(null)\n    this.metadata[term][field] = metadata\n    return\n  }\n\n  if (!(field in this.metadata[term])) {\n    this.metadata[term][field] = metadata\n    return\n  }\n\n  var metadataKeys = Object.keys(metadata)\n\n  for (var i = 0; i < metadataKeys.length; i++) {\n    var key = metadataKeys[i]\n\n    if (key in this.metadata[term][field]) {\n      this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key])\n    } else {\n      this.metadata[term][field][key] = metadata[key]\n    }\n  }\n}\n/**\n * A lunr.Query provides a programmatic way of defining queries to be performed\n * against a {@link lunr.Index}.\n *\n * Prefer constructing a lunr.Query using the {@link lunr.Index#query} method\n * so the query object is pre-initialized with the right index fields.\n *\n * @constructor\n * @property {lunr.Query~Clause[]} clauses - An array of query clauses.\n * @property {string[]} allFields - An array of all available fields in a lunr.Index.\n */\nlunr.Query = function (allFields) {\n  this.clauses = []\n  this.allFields = allFields\n}\n\n/**\n * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.\n *\n * This allows wildcards to be added to the beginning and end of a term without having to manually do any string\n * concatenation.\n *\n * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.\n *\n * @constant\n * @default\n * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour\n * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists\n * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists\n * @see lunr.Query~Clause\n * @see lunr.Query#clause\n * @see lunr.Query#term\n * @example <caption>query term with trailing wildcard</caption>\n * query.term('foo', { wildcard: lunr.Query.wildcard.TRAILING })\n * @example <caption>query term with leading and trailing wildcard</caption>\n * query.term('foo', {\n *   wildcard: lunr.Query.wildcard.LEADING | lunr.Query.wildcard.TRAILING\n * })\n */\n\nlunr.Query.wildcard = new String (\"*\")\nlunr.Query.wildcard.NONE = 0\nlunr.Query.wildcard.LEADING = 1\nlunr.Query.wildcard.TRAILING = 2\n\n/**\n * Constants for indicating what kind of presence a term must have in matching documents.\n *\n * @constant\n * @enum {number}\n * @see lunr.Query~Clause\n * @see lunr.Query#clause\n * @see lunr.Query#term\n * @example <caption>query term with required presence</caption>\n * query.term('foo', { presence: lunr.Query.presence.REQUIRED })\n */\nlunr.Query.presence = {\n  /**\n   * Term's presence in a document is optional, this is the default value.\n   */\n  OPTIONAL: 1,\n\n  /**\n   * Term's presence in a document is required, documents that do not contain\n   * this term will not be returned.\n   */\n  REQUIRED: 2,\n\n  /**\n   * Term's presence in a document is prohibited, documents that do contain\n   * this term will not be returned.\n   */\n  PROHIBITED: 3\n}\n\n/**\n * A single clause in a {@link lunr.Query} contains a term and details on how to\n * match that term against a {@link lunr.Index}.\n *\n * @typedef {Object} lunr.Query~Clause\n * @property {string[]} fields - The fields in an index this clause should be matched against.\n * @property {number} [boost=1] - Any boost that should be applied when matching this clause.\n * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.\n * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.\n * @property {number} [wildcard=lunr.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended.\n * @property {number} [presence=lunr.Query.presence.OPTIONAL] - The terms presence in any matching documents.\n */\n\n/**\n * Adds a {@link lunr.Query~Clause} to this query.\n *\n * Unless the clause contains the fields to be matched all fields will be matched. In addition\n * a default boost of 1 is applied to the clause.\n *\n * @param {lunr.Query~Clause} clause - The clause to add to this query.\n * @see lunr.Query~Clause\n * @returns {lunr.Query}\n */\nlunr.Query.prototype.clause = function (clause) {\n  if (!('fields' in clause)) {\n    clause.fields = this.allFields\n  }\n\n  if (!('boost' in clause)) {\n    clause.boost = 1\n  }\n\n  if (!('usePipeline' in clause)) {\n    clause.usePipeline = true\n  }\n\n  if (!('wildcard' in clause)) {\n    clause.wildcard = lunr.Query.wildcard.NONE\n  }\n\n  if ((clause.wildcard & lunr.Query.wildcard.LEADING) && (clause.term.charAt(0) != lunr.Query.wildcard)) {\n    clause.term = \"*\" + clause.term\n  }\n\n  if ((clause.wildcard & lunr.Query.wildcard.TRAILING) && (clause.term.slice(-1) != lunr.Query.wildcard)) {\n    clause.term = \"\" + clause.term + \"*\"\n  }\n\n  if (!('presence' in clause)) {\n    clause.presence = lunr.Query.presence.OPTIONAL\n  }\n\n  this.clauses.push(clause)\n\n  return this\n}\n\n/**\n * A negated query is one in which every clause has a presence of\n * prohibited. These queries require some special processing to return\n * the expected results.\n *\n * @returns boolean\n */\nlunr.Query.prototype.isNegated = function () {\n  for (var i = 0; i < this.clauses.length; i++) {\n    if (this.clauses[i].presence != lunr.Query.presence.PROHIBITED) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Adds a term to the current query, under the covers this will create a {@link lunr.Query~Clause}\n * to the list of clauses that make up this query.\n *\n * The term is used as is, i.e. no tokenization will be performed by this method. Instead conversion\n * to a token or token-like string should be done before calling this method.\n *\n * The term will be converted to a string by calling `toString`. Multiple terms can be passed as an\n * array, each term in the array will share the same options.\n *\n * @param {object|object[]} term - The term(s) to add to the query.\n * @param {object} [options] - Any additional properties to add to the query clause.\n * @returns {lunr.Query}\n * @see lunr.Query#clause\n * @see lunr.Query~Clause\n * @example <caption>adding a single term to a query</caption>\n * query.term(\"foo\")\n * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>\n * query.term(\"foo\", {\n *   fields: [\"title\"],\n *   boost: 10,\n *   wildcard: lunr.Query.wildcard.TRAILING\n * })\n * @example <caption>using lunr.tokenizer to convert a string to tokens before using them as terms</caption>\n * query.term(lunr.tokenizer(\"foo bar\"))\n */\nlunr.Query.prototype.term = function (term, options) {\n  if (Array.isArray(term)) {\n    term.forEach(function (t) { this.term(t, lunr.utils.clone(options)) }, this)\n    return this\n  }\n\n  var clause = options || {}\n  clause.term = term.toString()\n\n  this.clause(clause)\n\n  return this\n}\nlunr.QueryParseError = function (message, start, end) {\n  this.name = \"QueryParseError\"\n  this.message = message\n  this.start = start\n  this.end = end\n}\n\nlunr.QueryParseError.prototype = new Error\nlunr.QueryLexer = function (str) {\n  this.lexemes = []\n  this.str = str\n  this.length = str.length\n  this.pos = 0\n  this.start = 0\n  this.escapeCharPositions = []\n}\n\nlunr.QueryLexer.prototype.run = function () {\n  var state = lunr.QueryLexer.lexText\n\n  while (state) {\n    state = state(this)\n  }\n}\n\nlunr.QueryLexer.prototype.sliceString = function () {\n  var subSlices = [],\n      sliceStart = this.start,\n      sliceEnd = this.pos\n\n  for (var i = 0; i < this.escapeCharPositions.length; i++) {\n    sliceEnd = this.escapeCharPositions[i]\n    subSlices.push(this.str.slice(sliceStart, sliceEnd))\n    sliceStart = sliceEnd + 1\n  }\n\n  subSlices.push(this.str.slice(sliceStart, this.pos))\n  this.escapeCharPositions.length = 0\n\n  return subSlices.join('')\n}\n\nlunr.QueryLexer.prototype.emit = function (type) {\n  this.lexemes.push({\n    type: type,\n    str: this.sliceString(),\n    start: this.start,\n    end: this.pos\n  })\n\n  this.start = this.pos\n}\n\nlunr.QueryLexer.prototype.escapeCharacter = function () {\n  this.escapeCharPositions.push(this.pos - 1)\n  this.pos += 1\n}\n\nlunr.QueryLexer.prototype.next = function () {\n  if (this.pos >= this.length) {\n    return lunr.QueryLexer.EOS\n  }\n\n  var char = this.str.charAt(this.pos)\n  this.pos += 1\n  return char\n}\n\nlunr.QueryLexer.prototype.width = function () {\n  return this.pos - this.start\n}\n\nlunr.QueryLexer.prototype.ignore = function () {\n  if (this.start == this.pos) {\n    this.pos += 1\n  }\n\n  this.start = this.pos\n}\n\nlunr.QueryLexer.prototype.backup = function () {\n  this.pos -= 1\n}\n\nlunr.QueryLexer.prototype.acceptDigitRun = function () {\n  var char, charCode\n\n  do {\n    char = this.next()\n    charCode = char.charCodeAt(0)\n  } while (charCode > 47 && charCode < 58)\n\n  if (char != lunr.QueryLexer.EOS) {\n    this.backup()\n  }\n}\n\nlunr.QueryLexer.prototype.more = function () {\n  return this.pos < this.length\n}\n\nlunr.QueryLexer.EOS = 'EOS'\nlunr.QueryLexer.FIELD = 'FIELD'\nlunr.QueryLexer.TERM = 'TERM'\nlunr.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'\nlunr.QueryLexer.BOOST = 'BOOST'\nlunr.QueryLexer.PRESENCE = 'PRESENCE'\n\nlunr.QueryLexer.lexField = function (lexer) {\n  lexer.backup()\n  lexer.emit(lunr.QueryLexer.FIELD)\n  lexer.ignore()\n  return lunr.QueryLexer.lexText\n}\n\nlunr.QueryLexer.lexTerm = function (lexer) {\n  if (lexer.width() > 1) {\n    lexer.backup()\n    lexer.emit(lunr.QueryLexer.TERM)\n  }\n\n  lexer.ignore()\n\n  if (lexer.more()) {\n    return lunr.QueryLexer.lexText\n  }\n}\n\nlunr.QueryLexer.lexEditDistance = function (lexer) {\n  lexer.ignore()\n  lexer.acceptDigitRun()\n  lexer.emit(lunr.QueryLexer.EDIT_DISTANCE)\n  return lunr.QueryLexer.lexText\n}\n\nlunr.QueryLexer.lexBoost = function (lexer) {\n  lexer.ignore()\n  lexer.acceptDigitRun()\n  lexer.emit(lunr.QueryLexer.BOOST)\n  return lunr.QueryLexer.lexText\n}\n\nlunr.QueryLexer.lexEOS = function (lexer) {\n  if (lexer.width() > 0) {\n    lexer.emit(lunr.QueryLexer.TERM)\n  }\n}\n\n// This matches the separator used when tokenising fields\n// within a document. These should match otherwise it is\n// not possible to search for some tokens within a document.\n//\n// It is possible for the user to change the separator on the\n// tokenizer so it _might_ clash with any other of the special\n// characters already used within the search string, e.g. :.\n//\n// This means that it is possible to change the separator in\n// such a way that makes some words unsearchable using a search\n// string.\nlunr.QueryLexer.termSeparator = lunr.tokenizer.separator\n\nlunr.QueryLexer.lexText = function (lexer) {\n  while (true) {\n    var char = lexer.next()\n\n    if (char == lunr.QueryLexer.EOS) {\n      return lunr.QueryLexer.lexEOS\n    }\n\n    // Escape character is '\\'\n    if (char.charCodeAt(0) == 92) {\n      lexer.escapeCharacter()\n      continue\n    }\n\n    if (char == \":\") {\n      return lunr.QueryLexer.lexField\n    }\n\n    if (char == \"~\") {\n      lexer.backup()\n      if (lexer.width() > 0) {\n        lexer.emit(lunr.QueryLexer.TERM)\n      }\n      return lunr.QueryLexer.lexEditDistance\n    }\n\n    if (char == \"^\") {\n      lexer.backup()\n      if (lexer.width() > 0) {\n        lexer.emit(lunr.QueryLexer.TERM)\n      }\n      return lunr.QueryLexer.lexBoost\n    }\n\n    // \"+\" indicates term presence is required\n    // checking for length to ensure that only\n    // leading \"+\" are considered\n    if (char == \"+\" && lexer.width() === 1) {\n      lexer.emit(lunr.QueryLexer.PRESENCE)\n      return lunr.QueryLexer.lexText\n    }\n\n    // \"-\" indicates term presence is prohibited\n    // checking for length to ensure that only\n    // leading \"-\" are considered\n    if (char == \"-\" && lexer.width() === 1) {\n      lexer.emit(lunr.QueryLexer.PRESENCE)\n      return lunr.QueryLexer.lexText\n    }\n\n    if (char.match(lunr.QueryLexer.termSeparator)) {\n      return lunr.QueryLexer.lexTerm\n    }\n  }\n}\n\nlunr.QueryParser = function (str, query) {\n  this.lexer = new lunr.QueryLexer (str)\n  this.query = query\n  this.currentClause = {}\n  this.lexemeIdx = 0\n}\n\nlunr.QueryParser.prototype.parse = function () {\n  this.lexer.run()\n  this.lexemes = this.lexer.lexemes\n\n  var state = lunr.QueryParser.parseClause\n\n  while (state) {\n    state = state(this)\n  }\n\n  return this.query\n}\n\nlunr.QueryParser.prototype.peekLexeme = function () {\n  return this.lexemes[this.lexemeIdx]\n}\n\nlunr.QueryParser.prototype.consumeLexeme = function () {\n  var lexeme = this.peekLexeme()\n  this.lexemeIdx += 1\n  return lexeme\n}\n\nlunr.QueryParser.prototype.nextClause = function () {\n  var completedClause = this.currentClause\n  this.query.clause(completedClause)\n  this.currentClause = {}\n}\n\nlunr.QueryParser.parseClause = function (parser) {\n  var lexeme = parser.peekLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  switch (lexeme.type) {\n    case lunr.QueryLexer.PRESENCE:\n      return lunr.QueryParser.parsePresence\n    case lunr.QueryLexer.FIELD:\n      return lunr.QueryParser.parseField\n    case lunr.QueryLexer.TERM:\n      return lunr.QueryParser.parseTerm\n    default:\n      var errorMessage = \"expected either a field or a term, found \" + lexeme.type\n\n      if (lexeme.str.length >= 1) {\n        errorMessage += \" with value '\" + lexeme.str + \"'\"\n      }\n\n      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n}\n\nlunr.QueryParser.parsePresence = function (parser) {\n  var lexeme = parser.consumeLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  switch (lexeme.str) {\n    case \"-\":\n      parser.currentClause.presence = lunr.Query.presence.PROHIBITED\n      break\n    case \"+\":\n      parser.currentClause.presence = lunr.Query.presence.REQUIRED\n      break\n    default:\n      var errorMessage = \"unrecognised presence operator'\" + lexeme.str + \"'\"\n      throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  var nextLexeme = parser.peekLexeme()\n\n  if (nextLexeme == undefined) {\n    var errorMessage = \"expecting term or field, found nothing\"\n    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  switch (nextLexeme.type) {\n    case lunr.QueryLexer.FIELD:\n      return lunr.QueryParser.parseField\n    case lunr.QueryLexer.TERM:\n      return lunr.QueryParser.parseTerm\n    default:\n      var errorMessage = \"expecting term or field, found '\" + nextLexeme.type + \"'\"\n      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)\n  }\n}\n\nlunr.QueryParser.parseField = function (parser) {\n  var lexeme = parser.consumeLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  if (parser.query.allFields.indexOf(lexeme.str) == -1) {\n    var possibleFields = parser.query.allFields.map(function (f) { return \"'\" + f + \"'\" }).join(', '),\n        errorMessage = \"unrecognised field '\" + lexeme.str + \"', possible fields: \" + possibleFields\n\n    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  parser.currentClause.fields = [lexeme.str]\n\n  var nextLexeme = parser.peekLexeme()\n\n  if (nextLexeme == undefined) {\n    var errorMessage = \"expecting term, found nothing\"\n    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  switch (nextLexeme.type) {\n    case lunr.QueryLexer.TERM:\n      return lunr.QueryParser.parseTerm\n    default:\n      var errorMessage = \"expecting term, found '\" + nextLexeme.type + \"'\"\n      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)\n  }\n}\n\nlunr.QueryParser.parseTerm = function (parser) {\n  var lexeme = parser.consumeLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  parser.currentClause.term = lexeme.str.toLowerCase()\n\n  if (lexeme.str.indexOf(\"*\") != -1) {\n    parser.currentClause.usePipeline = false\n  }\n\n  var nextLexeme = parser.peekLexeme()\n\n  if (nextLexeme == undefined) {\n    parser.nextClause()\n    return\n  }\n\n  switch (nextLexeme.type) {\n    case lunr.QueryLexer.TERM:\n      parser.nextClause()\n      return lunr.QueryParser.parseTerm\n    case lunr.QueryLexer.FIELD:\n      parser.nextClause()\n      return lunr.QueryParser.parseField\n    case lunr.QueryLexer.EDIT_DISTANCE:\n      return lunr.QueryParser.parseEditDistance\n    case lunr.QueryLexer.BOOST:\n      return lunr.QueryParser.parseBoost\n    case lunr.QueryLexer.PRESENCE:\n      parser.nextClause()\n      return lunr.QueryParser.parsePresence\n    default:\n      var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\"\n      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)\n  }\n}\n\nlunr.QueryParser.parseEditDistance = function (parser) {\n  var lexeme = parser.consumeLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  var editDistance = parseInt(lexeme.str, 10)\n\n  if (isNaN(editDistance)) {\n    var errorMessage = \"edit distance must be numeric\"\n    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  parser.currentClause.editDistance = editDistance\n\n  var nextLexeme = parser.peekLexeme()\n\n  if (nextLexeme == undefined) {\n    parser.nextClause()\n    return\n  }\n\n  switch (nextLexeme.type) {\n    case lunr.QueryLexer.TERM:\n      parser.nextClause()\n      return lunr.QueryParser.parseTerm\n    case lunr.QueryLexer.FIELD:\n      parser.nextClause()\n      return lunr.QueryParser.parseField\n    case lunr.QueryLexer.EDIT_DISTANCE:\n      return lunr.QueryParser.parseEditDistance\n    case lunr.QueryLexer.BOOST:\n      return lunr.QueryParser.parseBoost\n    case lunr.QueryLexer.PRESENCE:\n      parser.nextClause()\n      return lunr.QueryParser.parsePresence\n    default:\n      var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\"\n      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)\n  }\n}\n\nlunr.QueryParser.parseBoost = function (parser) {\n  var lexeme = parser.consumeLexeme()\n\n  if (lexeme == undefined) {\n    return\n  }\n\n  var boost = parseInt(lexeme.str, 10)\n\n  if (isNaN(boost)) {\n    var errorMessage = \"boost must be numeric\"\n    throw new lunr.QueryParseError (errorMessage, lexeme.start, lexeme.end)\n  }\n\n  parser.currentClause.boost = boost\n\n  var nextLexeme = parser.peekLexeme()\n\n  if (nextLexeme == undefined) {\n    parser.nextClause()\n    return\n  }\n\n  switch (nextLexeme.type) {\n    case lunr.QueryLexer.TERM:\n      parser.nextClause()\n      return lunr.QueryParser.parseTerm\n    case lunr.QueryLexer.FIELD:\n      parser.nextClause()\n      return lunr.QueryParser.parseField\n    case lunr.QueryLexer.EDIT_DISTANCE:\n      return lunr.QueryParser.parseEditDistance\n    case lunr.QueryLexer.BOOST:\n      return lunr.QueryParser.parseBoost\n    case lunr.QueryLexer.PRESENCE:\n      parser.nextClause()\n      return lunr.QueryParser.parsePresence\n    default:\n      var errorMessage = \"Unexpected lexeme type '\" + nextLexeme.type + \"'\"\n      throw new lunr.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)\n  }\n}\n\n  /**\n   * export the module via AMD, CommonJS or as a browser global\n   * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js\n   */\n  ;(function (root, factory) {\n    if (true) {\n      // AMD. Register as an anonymous module.\n      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n  }(this, function () {\n    /**\n     * Just return a value to define the module export.\n     * This example returns an object, but the module\n     * can return a function as the exported value.\n     */\n    return lunr\n  }))\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtRUFBbUUsc0JBQXNCO0FBQ3pGOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsUUFBUSxJQUEwQztBQUNsRDtBQUNBLE1BQU0sb0NBQU8sT0FBTztBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFDO0FBQ3JCLE1BQU0sS0FBSyxFQVVOO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sdW5yL2x1bnIuanM/MmM1OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGx1bnIgLSBodHRwOi8vbHVucmpzLmNvbSAtIEEgYml0IGxpa2UgU29sciwgYnV0IG11Y2ggc21hbGxlciBhbmQgbm90IGFzIGJyaWdodCAtIDIuMy45XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG47KGZ1bmN0aW9uKCl7XG5cbi8qKlxuICogQSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29uZmlndXJpbmcgYW5kIGNvbnN0cnVjdGluZ1xuICogYSBuZXcgbHVuciBJbmRleC5cbiAqXG4gKiBBIGx1bnIuQnVpbGRlciBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCB0aGUgcGlwZWxpbmUgc2V0dXBcbiAqIHdpdGggYSB0cmltbWVyLCBzdG9wIHdvcmQgZmlsdGVyIGFuZCBzdGVtbWVyLlxuICpcbiAqIFRoaXMgYnVpbGRlciBvYmplY3QgaXMgeWllbGRlZCB0byB0aGUgY29uZmlndXJhdGlvbiBmdW5jdGlvblxuICogdGhhdCBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIsIGFsbG93aW5nIHRoZSBsaXN0IG9mIGZpZWxkc1xuICogYW5kIG90aGVyIGJ1aWxkZXIgcGFyYW1ldGVycyB0byBiZSBjdXN0b21pc2VkLlxuICpcbiAqIEFsbCBkb2N1bWVudHMgX211c3RfIGJlIGFkZGVkIHdpdGhpbiB0aGUgcGFzc2VkIGNvbmZpZyBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIGlkeCA9IGx1bnIoZnVuY3Rpb24gKCkge1xuICogICB0aGlzLmZpZWxkKCd0aXRsZScpXG4gKiAgIHRoaXMuZmllbGQoJ2JvZHknKVxuICogICB0aGlzLnJlZignaWQnKVxuICpcbiAqICAgZG9jdW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICogICAgIHRoaXMuYWRkKGRvYylcbiAqICAgfSwgdGhpcylcbiAqIH0pXG4gKlxuICogQHNlZSB7QGxpbmsgbHVuci5CdWlsZGVyfVxuICogQHNlZSB7QGxpbmsgbHVuci5QaXBlbGluZX1cbiAqIEBzZWUge0BsaW5rIGx1bnIudHJpbW1lcn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuc3RvcFdvcmRGaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBsdW5yLnN0ZW1tZXJ9XG4gKiBAbmFtZXNwYWNlIHtmdW5jdGlvbn0gbHVuclxuICovXG52YXIgbHVuciA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGJ1aWxkZXIgPSBuZXcgbHVuci5CdWlsZGVyXG5cbiAgYnVpbGRlci5waXBlbGluZS5hZGQoXG4gICAgbHVuci50cmltbWVyLFxuICAgIGx1bnIuc3RvcFdvcmRGaWx0ZXIsXG4gICAgbHVuci5zdGVtbWVyXG4gIClcblxuICBidWlsZGVyLnNlYXJjaFBpcGVsaW5lLmFkZChcbiAgICBsdW5yLnN0ZW1tZXJcbiAgKVxuXG4gIGNvbmZpZy5jYWxsKGJ1aWxkZXIsIGJ1aWxkZXIpXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxubHVuci52ZXJzaW9uID0gXCIyLjMuOVwiXG4vKiFcbiAqIGx1bnIudXRpbHNcbiAqIENvcHlyaWdodCAoQykgMjAyMCBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqL1xuXG4vKipcbiAqIEEgbmFtZXNwYWNlIGNvbnRhaW5pbmcgdXRpbHMgZm9yIHRoZSByZXN0IG9mIHRoZSBsdW5yIGxpYnJhcnlcbiAqIEBuYW1lc3BhY2UgbHVuci51dGlsc1xuICovXG5sdW5yLnV0aWxzID0ge31cblxuLyoqXG4gKiBQcmludCBhIHdhcm5pbmcgbWVzc2FnZSB0byB0aGUgY29uc29sZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBiZSBwcmludGVkLlxuICogQG1lbWJlck9mIGx1bnIudXRpbHNcbiAqIEBmdW5jdGlvblxuICovXG5sdW5yLnV0aWxzLndhcm4gPSAoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChnbG9iYWwuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKVxuICAgIH1cbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cbn0pKHRoaXMpXG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICogdGhlIGVtcHR5IHN0cmluZywgaW4gYWxsIG90aGVyIGNhc2VzIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICogYHRvU3RyaW5nYCBvbiB0aGUgcGFzc2VkIG9iamVjdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0FueX0gb2JqIFRoZSBvYmplY3QgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm4ge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwYXNzZWQgb2JqZWN0LlxuICogQG1lbWJlck9mIGx1bnIudXRpbHNcbiAqL1xubHVuci51dGlscy5hc1N0cmluZyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKG9iaiA9PT0gdm9pZCAwIHx8IG9iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIlwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iai50b1N0cmluZygpXG4gIH1cbn1cblxuLyoqXG4gKiBDbG9uZXMgYW4gb2JqZWN0LlxuICpcbiAqIFdpbGwgY3JlYXRlIGEgY29weSBvZiBhbiBleGlzdGluZyBvYmplY3Qgc3VjaCB0aGF0IGFueSBtdXRhdGlvbnNcbiAqIG9uIHRoZSBjb3B5IGNhbm5vdCBhZmZlY3QgdGhlIG9yaWdpbmFsLlxuICpcbiAqIE9ubHkgc2hhbGxvdyBvYmplY3RzIGFyZSBzdXBwb3J0ZWQsIHBhc3NpbmcgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgY2F1c2UgYSBUeXBlRXJyb3IuXG4gKlxuICogT2JqZWN0cyB3aXRoIHByaW1pdGl2ZXMsIGFuZCBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBjbG9uZSBvZiB0aGUgcGFzc2VkIG9iamVjdC5cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gd2hlbiBhIG5lc3RlZCBvYmplY3QgaXMgcGFzc2VkLlxuICogQG1lbWJlck9mIFV0aWxzXG4gKi9cbmx1bnIudXRpbHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICB2YXIgY2xvbmUgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG9iailcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXSxcbiAgICAgICAgdmFsID0gb2JqW2tleV1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGNsb25lW2tleV0gPSB2YWwuc2xpY2UoKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBjbG9uZVtrZXldID0gdmFsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjbG9uZSBpcyBub3QgZGVlcCBhbmQgZG9lcyBub3Qgc3VwcG9ydCBuZXN0ZWQgb2JqZWN0c1wiKVxuICB9XG5cbiAgcmV0dXJuIGNsb25lXG59XG5sdW5yLkZpZWxkUmVmID0gZnVuY3Rpb24gKGRvY1JlZiwgZmllbGROYW1lLCBzdHJpbmdWYWx1ZSkge1xuICB0aGlzLmRvY1JlZiA9IGRvY1JlZlxuICB0aGlzLmZpZWxkTmFtZSA9IGZpZWxkTmFtZVxuICB0aGlzLl9zdHJpbmdWYWx1ZSA9IHN0cmluZ1ZhbHVlXG59XG5cbmx1bnIuRmllbGRSZWYuam9pbmVyID0gXCIvXCJcblxubHVuci5GaWVsZFJlZi5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHMpIHtcbiAgdmFyIG4gPSBzLmluZGV4T2YobHVuci5GaWVsZFJlZi5qb2luZXIpXG5cbiAgaWYgKG4gPT09IC0xKSB7XG4gICAgdGhyb3cgXCJtYWxmb3JtZWQgZmllbGQgcmVmIHN0cmluZ1wiXG4gIH1cblxuICB2YXIgZmllbGRSZWYgPSBzLnNsaWNlKDAsIG4pLFxuICAgICAgZG9jUmVmID0gcy5zbGljZShuICsgMSlcblxuICByZXR1cm4gbmV3IGx1bnIuRmllbGRSZWYgKGRvY1JlZiwgZmllbGRSZWYsIHMpXG59XG5cbmx1bnIuRmllbGRSZWYucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fc3RyaW5nVmFsdWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5fc3RyaW5nVmFsdWUgPSB0aGlzLmZpZWxkTmFtZSArIGx1bnIuRmllbGRSZWYuam9pbmVyICsgdGhpcy5kb2NSZWZcbiAgfVxuXG4gIHJldHVybiB0aGlzLl9zdHJpbmdWYWx1ZVxufVxuLyohXG4gKiBsdW5yLlNldFxuICogQ29weXJpZ2h0IChDKSAyMDIwIE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSBsdW5yIHNldC5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xubHVuci5TZXQgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgdGhpcy5lbGVtZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBpZiAoZWxlbWVudHMpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzW2VsZW1lbnRzW2ldXSA9IHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZW5ndGggPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbXBsZXRlIHNldCB0aGF0IGNvbnRhaW5zIGFsbCBlbGVtZW50cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcmVhZG9ubHlcbiAqIEB0eXBlIHtsdW5yLlNldH1cbiAqL1xubHVuci5TZXQuY29tcGxldGUgPSB7XG4gIGludGVyc2VjdDogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyXG4gIH0sXG5cbiAgdW5pb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vKipcbiAqIEFuIGVtcHR5IHNldCB0aGF0IGNvbnRhaW5zIG5vIGVsZW1lbnRzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEByZWFkb25seVxuICogQHR5cGUge2x1bnIuU2V0fVxuICovXG5sdW5yLlNldC5lbXB0eSA9IHtcbiAgaW50ZXJzZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB1bmlvbjogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyXG4gIH0sXG5cbiAgY29udGFpbnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIHNldCBjb250YWlucyB0aGUgc3BlY2lmaWVkIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gT2JqZWN0IHdob3NlIHByZXNlbmNlIGluIHRoaXMgc2V0IGlzIHRvIGJlIHRlc3RlZC5cbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhpcyBzZXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBvYmplY3QuXG4gKi9cbmx1bnIuU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgcmV0dXJuICEhdGhpcy5lbGVtZW50c1tvYmplY3RdXG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBzZXQgY29udGFpbmluZyBvbmx5IHRoZSBlbGVtZW50cyB0aGF0IGFyZSBwcmVzZW50IGluIGJvdGhcbiAqIHRoaXMgc2V0IGFuZCB0aGUgc3BlY2lmaWVkIHNldC5cbiAqXG4gKiBAcGFyYW0ge2x1bnIuU2V0fSBvdGhlciAtIHNldCB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHNldC5cbiAqIEByZXR1cm5zIHtsdW5yLlNldH0gYSBuZXcgc2V0IHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIHNldC5cbiAqL1xuXG5sdW5yLlNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBhLCBiLCBlbGVtZW50cywgaW50ZXJzZWN0aW9uID0gW11cblxuICBpZiAob3RoZXIgPT09IGx1bnIuU2V0LmNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuZW1wdHkpIHtcbiAgICByZXR1cm4gb3RoZXJcbiAgfVxuXG4gIGlmICh0aGlzLmxlbmd0aCA8IG90aGVyLmxlbmd0aCkge1xuICAgIGEgPSB0aGlzXG4gICAgYiA9IG90aGVyXG4gIH0gZWxzZSB7XG4gICAgYSA9IG90aGVyXG4gICAgYiA9IHRoaXNcbiAgfVxuXG4gIGVsZW1lbnRzID0gT2JqZWN0LmtleXMoYS5lbGVtZW50cylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXVxuICAgIGlmIChlbGVtZW50IGluIGIuZWxlbWVudHMpIHtcbiAgICAgIGludGVyc2VjdGlvbi5wdXNoKGVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBsdW5yLlNldCAoaW50ZXJzZWN0aW9uKVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgc2V0IGNvbWJpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBzZXQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlNldH0gb3RoZXIgLSBzZXQgdG8gdW5pb24gd2l0aCB0aGlzIHNldC5cbiAqIEByZXR1cm4ge2x1bnIuU2V0fSBhIG5ldyBzZXQgdGhhdCBpcyB0aGUgdW5pb24gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBzZXQuXG4gKi9cblxubHVuci5TZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuY29tcGxldGUpIHtcbiAgICByZXR1cm4gbHVuci5TZXQuY29tcGxldGVcbiAgfVxuXG4gIGlmIChvdGhlciA9PT0gbHVuci5TZXQuZW1wdHkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcmV0dXJuIG5ldyBsdW5yLlNldChPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRzKS5jb25jYXQoT2JqZWN0LmtleXMob3RoZXIuZWxlbWVudHMpKSlcbn1cbi8qKlxuICogQSBmdW5jdGlvbiB0byBjYWxjdWxhdGUgdGhlIGludmVyc2UgZG9jdW1lbnQgZnJlcXVlbmN5IGZvclxuICogYSBwb3N0aW5nLiBUaGlzIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZSBidWlsZGVyIGFuZCB0aGUgaW5kZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtvYmplY3R9IHBvc3RpbmcgLSBUaGUgcG9zdGluZyBmb3IgYSBnaXZlbiB0ZXJtXG4gKiBAcGFyYW0ge251bWJlcn0gZG9jdW1lbnRDb3VudCAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZG9jdW1lbnRzLlxuICovXG5sdW5yLmlkZiA9IGZ1bmN0aW9uIChwb3N0aW5nLCBkb2N1bWVudENvdW50KSB7XG4gIHZhciBkb2N1bWVudHNXaXRoVGVybSA9IDBcblxuICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gcG9zdGluZykge1xuICAgIGlmIChmaWVsZE5hbWUgPT0gJ19pbmRleCcpIGNvbnRpbnVlIC8vIElnbm9yZSB0aGUgdGVybSBpbmRleCwgaXRzIG5vdCBhIGZpZWxkXG4gICAgZG9jdW1lbnRzV2l0aFRlcm0gKz0gT2JqZWN0LmtleXMocG9zdGluZ1tmaWVsZE5hbWVdKS5sZW5ndGhcbiAgfVxuXG4gIHZhciB4ID0gKGRvY3VtZW50Q291bnQgLSBkb2N1bWVudHNXaXRoVGVybSArIDAuNSkgLyAoZG9jdW1lbnRzV2l0aFRlcm0gKyAwLjUpXG5cbiAgcmV0dXJuIE1hdGgubG9nKDEgKyBNYXRoLmFicyh4KSlcbn1cblxuLyoqXG4gKiBBIHRva2VuIHdyYXBzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdG9rZW5cbiAqIGFzIGl0IGlzIHBhc3NlZCB0aHJvdWdoIHRoZSB0ZXh0IHByb2Nlc3NpbmcgcGlwZWxpbmUuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW3N0cj0nJ10gLSBUaGUgc3RyaW5nIHRva2VuIGJlaW5nIHdyYXBwZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gW21ldGFkYXRhPXt9XSAtIE1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRva2VuLlxuICovXG5sdW5yLlRva2VuID0gZnVuY3Rpb24gKHN0ciwgbWV0YWRhdGEpIHtcbiAgdGhpcy5zdHIgPSBzdHIgfHwgXCJcIlxuICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEgfHwge31cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0b2tlbiBzdHJpbmcgdGhhdCBpcyBiZWluZyB3cmFwcGVkIGJ5IHRoaXMgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmx1bnIuVG9rZW4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zdHJcbn1cblxuLyoqXG4gKiBBIHRva2VuIHVwZGF0ZSBmdW5jdGlvbiBpcyB1c2VkIHdoZW4gdXBkYXRpbmcgb3Igb3B0aW9uYWxseVxuICogd2hlbiBjbG9uaW5nIGEgdG9rZW4uXG4gKlxuICogQGNhbGxiYWNrIGx1bnIuVG9rZW5+dXBkYXRlRnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSAtIEFsbCBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0b2tlbi5cbiAqL1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIHRvIHRoZSB3cmFwcGVkIHN0cmluZyB0b2tlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogdG9rZW4udXBkYXRlKGZ1bmN0aW9uIChzdHIsIG1ldGFkYXRhKSB7XG4gKiAgIHJldHVybiBzdHIudG9VcHBlckNhc2UoKVxuICogfSlcbiAqXG4gKiBAcGFyYW0ge2x1bnIuVG9rZW5+dXBkYXRlRnVuY3Rpb259IGZuIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byB0aGUgdG9rZW4gc3RyaW5nLlxuICogQHJldHVybnMge2x1bnIuVG9rZW59XG4gKi9cbmx1bnIuVG9rZW4ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChmbikge1xuICB0aGlzLnN0ciA9IGZuKHRoaXMuc3RyLCB0aGlzLm1ldGFkYXRhKVxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHRva2VuLiBPcHRpb25hbGx5IGEgZnVuY3Rpb24gY2FuIGJlXG4gKiBhcHBsaWVkIHRvIHRoZSBjbG9uZWQgdG9rZW4uXG4gKlxuICogQHBhcmFtIHtsdW5yLlRva2VufnVwZGF0ZUZ1bmN0aW9ufSBbZm5dIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gYXBwbHkgdG8gdGhlIGNsb25lZCB0b2tlbi5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VufVxuICovXG5sdW5yLlRva2VuLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIChmbikge1xuICBmbiA9IGZuIHx8IGZ1bmN0aW9uIChzKSB7IHJldHVybiBzIH1cbiAgcmV0dXJuIG5ldyBsdW5yLlRva2VuIChmbih0aGlzLnN0ciwgdGhpcy5tZXRhZGF0YSksIHRoaXMubWV0YWRhdGEpXG59XG4vKiFcbiAqIGx1bnIudG9rZW5pemVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIGZvciBzcGxpdHRpbmcgYSBzdHJpbmcgaW50byB0b2tlbnMgcmVhZHkgdG8gYmUgaW5zZXJ0ZWQgaW50b1xuICogdGhlIHNlYXJjaCBpbmRleC4gVXNlcyBgbHVuci50b2tlbml6ZXIuc2VwYXJhdG9yYCB0byBzcGxpdCBzdHJpbmdzLCBjaGFuZ2VcbiAqIHRoZSB2YWx1ZSBvZiB0aGlzIHByb3BlcnR5IHRvIGNoYW5nZSBob3cgc3RyaW5ncyBhcmUgc3BsaXQgaW50byB0b2tlbnMuXG4gKlxuICogVGhpcyB0b2tlbml6ZXIgd2lsbCBjb252ZXJ0IGl0cyBwYXJhbWV0ZXIgdG8gYSBzdHJpbmcgYnkgY2FsbGluZyBgdG9TdHJpbmdgIGFuZFxuICogdGhlbiB3aWxsIHNwbGl0IHRoaXMgc3RyaW5nIG9uIHRoZSBjaGFyYWN0ZXIgaW4gYGx1bnIudG9rZW5pemVyLnNlcGFyYXRvcmAuXG4gKiBBcnJheXMgd2lsbCBoYXZlIHRoZWlyIGVsZW1lbnRzIGNvbnZlcnRlZCB0byBzdHJpbmdzIGFuZCB3cmFwcGVkIGluIGEgbHVuci5Ub2tlbi5cbiAqXG4gKiBPcHRpb25hbCBtZXRhZGF0YSBjYW4gYmUgcGFzc2VkIHRvIHRoZSB0b2tlbml6ZXIsIHRoaXMgbWV0YWRhdGEgd2lsbCBiZSBjbG9uZWQgYW5kXG4gKiBhZGRlZCBhcyBtZXRhZGF0YSB0byBldmVyeSB0b2tlbiB0aGF0IGlzIGNyZWF0ZWQgZnJvbSB0aGUgb2JqZWN0IHRvIGJlIHRva2VuaXplZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0gez8oc3RyaW5nfG9iamVjdHxvYmplY3RbXSl9IG9iaiAtIFRoZSBvYmplY3QgdG8gY29udmVydCBpbnRvIHRva2Vuc1xuICogQHBhcmFtIHs/b2JqZWN0fSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGFzc29jaWF0ZSB3aXRoIGV2ZXJ5IHRva2VuXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbltdfVxuICogQHNlZSB7QGxpbmsgbHVuci5QaXBlbGluZX1cbiAqL1xubHVuci50b2tlbml6ZXIgPSBmdW5jdGlvbiAob2JqLCBtZXRhZGF0YSkge1xuICBpZiAob2JqID09IG51bGwgfHwgb2JqID09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIHJldHVybiBvYmoubWFwKGZ1bmN0aW9uICh0KSB7XG4gICAgICByZXR1cm4gbmV3IGx1bnIuVG9rZW4oXG4gICAgICAgIGx1bnIudXRpbHMuYXNTdHJpbmcodCkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgbHVuci51dGlscy5jbG9uZShtZXRhZGF0YSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgdmFyIHN0ciA9IG9iai50b1N0cmluZygpLnRvTG93ZXJDYXNlKCksXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoLFxuICAgICAgdG9rZW5zID0gW11cblxuICBmb3IgKHZhciBzbGljZUVuZCA9IDAsIHNsaWNlU3RhcnQgPSAwOyBzbGljZUVuZCA8PSBsZW47IHNsaWNlRW5kKyspIHtcbiAgICB2YXIgY2hhciA9IHN0ci5jaGFyQXQoc2xpY2VFbmQpLFxuICAgICAgICBzbGljZUxlbmd0aCA9IHNsaWNlRW5kIC0gc2xpY2VTdGFydFxuXG4gICAgaWYgKChjaGFyLm1hdGNoKGx1bnIudG9rZW5pemVyLnNlcGFyYXRvcikgfHwgc2xpY2VFbmQgPT0gbGVuKSkge1xuXG4gICAgICBpZiAoc2xpY2VMZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciB0b2tlbk1ldGFkYXRhID0gbHVuci51dGlscy5jbG9uZShtZXRhZGF0YSkgfHwge31cbiAgICAgICAgdG9rZW5NZXRhZGF0YVtcInBvc2l0aW9uXCJdID0gW3NsaWNlU3RhcnQsIHNsaWNlTGVuZ3RoXVxuICAgICAgICB0b2tlbk1ldGFkYXRhW1wiaW5kZXhcIl0gPSB0b2tlbnMubGVuZ3RoXG5cbiAgICAgICAgdG9rZW5zLnB1c2goXG4gICAgICAgICAgbmV3IGx1bnIuVG9rZW4gKFxuICAgICAgICAgICAgc3RyLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKSxcbiAgICAgICAgICAgIHRva2VuTWV0YWRhdGFcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgc2xpY2VTdGFydCA9IHNsaWNlRW5kICsgMVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIFRoZSBzZXBhcmF0b3IgdXNlZCB0byBzcGxpdCBhIHN0cmluZyBpbnRvIHRva2Vucy4gT3ZlcnJpZGUgdGhpcyBwcm9wZXJ0eSB0byBjaGFuZ2UgdGhlIGJlaGF2aW91ciBvZlxuICogYGx1bnIudG9rZW5pemVyYCBiZWhhdmlvdXIgd2hlbiB0b2tlbml6aW5nIHN0cmluZ3MuIEJ5IGRlZmF1bHQgdGhpcyBzcGxpdHMgb24gd2hpdGVzcGFjZSBhbmQgaHlwaGVucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2VlIGx1bnIudG9rZW5pemVyXG4gKi9cbmx1bnIudG9rZW5pemVyLnNlcGFyYXRvciA9IC9bXFxzXFwtXSsvXG4vKiFcbiAqIGx1bnIuUGlwZWxpbmVcbiAqIENvcHlyaWdodCAoQykgMjAyMCBPbGl2ZXIgTmlnaHRpbmdhbGVcbiAqL1xuXG4vKipcbiAqIGx1bnIuUGlwZWxpbmVzIG1haW50YWluIGFuIG9yZGVyZWQgbGlzdCBvZiBmdW5jdGlvbnMgdG8gYmUgYXBwbGllZCB0byBhbGxcbiAqIHRva2VucyBpbiBkb2N1bWVudHMgZW50ZXJpbmcgdGhlIHNlYXJjaCBpbmRleCBhbmQgcXVlcmllcyBiZWluZyByYW4gYWdhaW5zdFxuICogdGhlIGluZGV4LlxuICpcbiAqIEFuIGluc3RhbmNlIG9mIGx1bnIuSW5kZXggY3JlYXRlZCB3aXRoIHRoZSBsdW5yIHNob3J0Y3V0IHdpbGwgY29udGFpbiBhXG4gKiBwaXBlbGluZSB3aXRoIGEgc3RvcCB3b3JkIGZpbHRlciBhbmQgYW4gRW5nbGlzaCBsYW5ndWFnZSBzdGVtbWVyLiBFeHRyYVxuICogZnVuY3Rpb25zIGNhbiBiZSBhZGRlZCBiZWZvcmUgb3IgYWZ0ZXIgZWl0aGVyIG9mIHRoZXNlIGZ1bmN0aW9ucyBvciB0aGVzZVxuICogZGVmYXVsdCBmdW5jdGlvbnMgY2FuIGJlIHJlbW92ZWQuXG4gKlxuICogV2hlbiBydW4gdGhlIHBpcGVsaW5lIHdpbGwgY2FsbCBlYWNoIGZ1bmN0aW9uIGluIHR1cm4sIHBhc3NpbmcgYSB0b2tlbiwgdGhlXG4gKiBpbmRleCBvZiB0aGF0IHRva2VuIGluIHRoZSBvcmlnaW5hbCBsaXN0IG9mIGFsbCB0b2tlbnMgYW5kIGZpbmFsbHkgYSBsaXN0IG9mXG4gKiBhbGwgdGhlIG9yaWdpbmFsIHRva2Vucy5cbiAqXG4gKiBUaGUgb3V0cHV0IG9mIGZ1bmN0aW9ucyBpbiB0aGUgcGlwZWxpbmUgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG5leHQgZnVuY3Rpb25cbiAqIGluIHRoZSBwaXBlbGluZS4gVG8gZXhjbHVkZSBhIHRva2VuIGZyb20gZW50ZXJpbmcgdGhlIGluZGV4IHRoZSBmdW5jdGlvblxuICogc2hvdWxkIHJldHVybiB1bmRlZmluZWQsIHRoZSByZXN0IG9mIHRoZSBwaXBlbGluZSB3aWxsIG5vdCBiZSBjYWxsZWQgd2l0aFxuICogdGhpcyB0b2tlbi5cbiAqXG4gKiBGb3Igc2VyaWFsaXNhdGlvbiBvZiBwaXBlbGluZXMgdG8gd29yaywgYWxsIGZ1bmN0aW9ucyB1c2VkIGluIGFuIGluc3RhbmNlIG9mXG4gKiBhIHBpcGVsaW5lIHNob3VsZCBiZSByZWdpc3RlcmVkIHdpdGggbHVuci5QaXBlbGluZS4gUmVnaXN0ZXJlZCBmdW5jdGlvbnMgY2FuXG4gKiB0aGVuIGJlIGxvYWRlZC4gSWYgdHJ5aW5nIHRvIGxvYWQgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRoYXQgdXNlcyBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIG5vdCByZWdpc3RlcmVkIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIElmIG5vdCBwbGFubmluZyBvbiBzZXJpYWxpc2luZyB0aGUgcGlwZWxpbmUgdGhlbiByZWdpc3RlcmluZyBwaXBlbGluZSBmdW5jdGlvbnNcbiAqIGlzIG5vdCBuZWNlc3NhcnkuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmx1bnIuUGlwZWxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3N0YWNrID0gW11cbn1cblxubHVuci5QaXBlbGluZS5yZWdpc3RlcmVkRnVuY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vKipcbiAqIEEgcGlwZWxpbmUgZnVuY3Rpb24gbWFwcyBsdW5yLlRva2VuIHRvIGx1bnIuVG9rZW4uIEEgbHVuci5Ub2tlbiBjb250YWlucyB0aGUgdG9rZW5cbiAqIHN0cmluZyBhcyB3ZWxsIGFzIGFsbCBrbm93biBtZXRhZGF0YS4gQSBwaXBlbGluZSBmdW5jdGlvbiBjYW4gbXV0YXRlIHRoZSB0b2tlbiBzdHJpbmdcbiAqIG9yIG11dGF0ZSAob3IgYWRkKSBtZXRhZGF0YSBmb3IgYSBnaXZlbiB0b2tlbi5cbiAqXG4gKiBBIHBpcGVsaW5lIGZ1bmN0aW9uIGNhbiBpbmRpY2F0ZSB0aGF0IHRoZSBwYXNzZWQgdG9rZW4gc2hvdWxkIGJlIGRpc2NhcmRlZCBieSByZXR1cm5pbmdcbiAqIG51bGwsIHVuZGVmaW5lZCBvciBhbiBlbXB0eSBzdHJpbmcuIFRoaXMgdG9rZW4gd2lsbCBub3QgYmUgcGFzc2VkIHRvIGFueSBkb3duc3RyZWFtIHBpcGVsaW5lXG4gKiBmdW5jdGlvbnMgYW5kIHdpbGwgbm90IGJlIGFkZGVkIHRvIHRoZSBpbmRleC5cbiAqXG4gKiBNdWx0aXBsZSB0b2tlbnMgY2FuIGJlIHJldHVybmVkIGJ5IHJldHVybmluZyBhbiBhcnJheSBvZiB0b2tlbnMuIEVhY2ggdG9rZW4gd2lsbCBiZSBwYXNzZWRcbiAqIHRvIGFueSBkb3duc3RyZWFtIHBpcGVsaW5lIGZ1bmN0aW9ucyBhbmQgYWxsIHdpbGwgcmV0dXJuZWQgdG9rZW5zIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEFueSBudW1iZXIgb2YgcGlwZWxpbmUgZnVuY3Rpb25zIG1heSBiZSBjaGFpbmVkIHRvZ2V0aGVyIHVzaW5nIGEgbHVuci5QaXBlbGluZS5cbiAqXG4gKiBAaW50ZXJmYWNlIGx1bnIuUGlwZWxpbmVGdW5jdGlvblxuICogQHBhcmFtIHtsdW5yLlRva2VufSB0b2tlbiAtIEEgdG9rZW4gZnJvbSB0aGUgZG9jdW1lbnQgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGkgLSBUaGUgaW5kZXggb2YgdGhpcyB0b2tlbiBpbiB0aGUgY29tcGxldGUgbGlzdCBvZiB0b2tlbnMgZm9yIHRoaXMgZG9jdW1lbnQvZmllbGQuXG4gKiBAcGFyYW0ge2x1bnIuVG9rZW5bXX0gdG9rZW5zIC0gQWxsIHRva2VucyBmb3IgdGhpcyBkb2N1bWVudC9maWVsZC5cbiAqIEByZXR1cm5zIHsoP2x1bnIuVG9rZW58bHVuci5Ub2tlbltdKX1cbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZnVuY3Rpb24gd2l0aCB0aGUgcGlwZWxpbmUuXG4gKlxuICogRnVuY3Rpb25zIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHBpcGVsaW5lIHNob3VsZCBiZSByZWdpc3RlcmVkIGlmIHRoZSBwaXBlbGluZVxuICogbmVlZHMgdG8gYmUgc2VyaWFsaXNlZCwgb3IgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIG5lZWRzIHRvIGJlIGxvYWRlZC5cbiAqXG4gKiBSZWdpc3RlcmluZyBhIGZ1bmN0aW9uIGRvZXMgbm90IGFkZCBpdCB0byBhIHBpcGVsaW5lLCBmdW5jdGlvbnMgbXVzdCBzdGlsbCBiZVxuICogYWRkZWQgdG8gaW5zdGFuY2VzIG9mIHRoZSBwaXBlbGluZSBmb3IgdGhlbSB0byBiZSB1c2VkIHdoZW4gcnVubmluZyBhIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjaGVjayBmb3IuXG4gKiBAcGFyYW0ge1N0cmluZ30gbGFiZWwgLSBUaGUgbGFiZWwgdG8gcmVnaXN0ZXIgdGhpcyBmdW5jdGlvbiB3aXRoXG4gKi9cbmx1bnIuUGlwZWxpbmUucmVnaXN0ZXJGdW5jdGlvbiA9IGZ1bmN0aW9uIChmbiwgbGFiZWwpIHtcbiAgaWYgKGxhYmVsIGluIHRoaXMucmVnaXN0ZXJlZEZ1bmN0aW9ucykge1xuICAgIGx1bnIudXRpbHMud2FybignT3ZlcndyaXRpbmcgZXhpc3RpbmcgcmVnaXN0ZXJlZCBmdW5jdGlvbjogJyArIGxhYmVsKVxuICB9XG5cbiAgZm4ubGFiZWwgPSBsYWJlbFxuICBsdW5yLlBpcGVsaW5lLnJlZ2lzdGVyZWRGdW5jdGlvbnNbZm4ubGFiZWxdID0gZm5cbn1cblxuLyoqXG4gKiBXYXJucyBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBQaXBlbGluZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yLlxuICogQHByaXZhdGVcbiAqL1xubHVuci5QaXBlbGluZS53YXJuSWZGdW5jdGlvbk5vdFJlZ2lzdGVyZWQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIGlzUmVnaXN0ZXJlZCA9IGZuLmxhYmVsICYmIChmbi5sYWJlbCBpbiB0aGlzLnJlZ2lzdGVyZWRGdW5jdGlvbnMpXG5cbiAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICBsdW5yLnV0aWxzLndhcm4oJ0Z1bmN0aW9uIGlzIG5vdCByZWdpc3RlcmVkIHdpdGggcGlwZWxpbmUuIFRoaXMgbWF5IGNhdXNlIHByb2JsZW1zIHdoZW4gc2VyaWFsaXNpbmcgdGhlIGluZGV4LlxcbicsIGZuKVxuICB9XG59XG5cbi8qKlxuICogTG9hZHMgYSBwcmV2aW91c2x5IHNlcmlhbGlzZWQgcGlwZWxpbmUuXG4gKlxuICogQWxsIGZ1bmN0aW9ucyB0byBiZSBsb2FkZWQgbXVzdCBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQgd2l0aCBsdW5yLlBpcGVsaW5lLlxuICogSWYgYW55IGZ1bmN0aW9uIGZyb20gdGhlIHNlcmlhbGlzZWQgZGF0YSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB0aGVuIGFuXG4gKiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXNlZCAtIFRoZSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRvIGxvYWQuXG4gKiBAcmV0dXJucyB7bHVuci5QaXBlbGluZX1cbiAqL1xubHVuci5QaXBlbGluZS5sb2FkID0gZnVuY3Rpb24gKHNlcmlhbGlzZWQpIHtcbiAgdmFyIHBpcGVsaW5lID0gbmV3IGx1bnIuUGlwZWxpbmVcblxuICBzZXJpYWxpc2VkLmZvckVhY2goZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgIHZhciBmbiA9IGx1bnIuUGlwZWxpbmUucmVnaXN0ZXJlZEZ1bmN0aW9uc1tmbk5hbWVdXG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIHBpcGVsaW5lLmFkZChmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgbG9hZCB1bnJlZ2lzdGVyZWQgZnVuY3Rpb246ICcgKyBmbk5hbWUpXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBwaXBlbGluZVxufVxuXG4vKipcbiAqIEFkZHMgbmV3IGZ1bmN0aW9ucyB0byB0aGUgZW5kIG9mIHRoZSBwaXBlbGluZS5cbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb25bXX0gZnVuY3Rpb25zIC0gQW55IG51bWJlciBvZiBmdW5jdGlvbnMgdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZm5zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIGx1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKGZuKVxuICAgIHRoaXMuX3N0YWNrLnB1c2goZm4pXG4gIH0sIHRoaXMpXG59XG5cbi8qKlxuICogQWRkcyBhIHNpbmdsZSBmdW5jdGlvbiBhZnRlciBhIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlXG4gKiBwaXBlbGluZS5cbiAqXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259IGV4aXN0aW5nRm4gLSBBIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259IG5ld0ZuIC0gVGhlIG5ldyBmdW5jdGlvbiB0byBhZGQgdG8gdGhlIHBpcGVsaW5lLlxuICovXG5sdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5hZnRlciA9IGZ1bmN0aW9uIChleGlzdGluZ0ZuLCBuZXdGbikge1xuICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChuZXdGbilcblxuICB2YXIgcG9zID0gdGhpcy5fc3RhY2suaW5kZXhPZihleGlzdGluZ0ZuKVxuICBpZiAocG9zID09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBleGlzdGluZ0ZuJylcbiAgfVxuXG4gIHBvcyA9IHBvcyArIDFcbiAgdGhpcy5fc3RhY2suc3BsaWNlKHBvcywgMCwgbmV3Rm4pXG59XG5cbi8qKlxuICogQWRkcyBhIHNpbmdsZSBmdW5jdGlvbiBiZWZvcmUgYSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZVxuICogcGlwZWxpbmUuXG4gKlxuICogTG9ncyBhIHdhcm5pbmcgaWYgdGhlIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBleGlzdGluZ0ZuIC0gQSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBwaXBlbGluZS5cbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBuZXdGbiAtIFRoZSBuZXcgZnVuY3Rpb24gdG8gYWRkIHRvIHRoZSBwaXBlbGluZS5cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGV4aXN0aW5nRm4sIG5ld0ZuKSB7XG4gIGx1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKG5ld0ZuKVxuXG4gIHZhciBwb3MgPSB0aGlzLl9zdGFjay5pbmRleE9mKGV4aXN0aW5nRm4pXG4gIGlmIChwb3MgPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIGV4aXN0aW5nRm4nKVxuICB9XG5cbiAgdGhpcy5fc3RhY2suc3BsaWNlKHBvcywgMCwgbmV3Rm4pXG59XG5cbi8qKlxuICogUmVtb3ZlcyBhIGZ1bmN0aW9uIGZyb20gdGhlIHBpcGVsaW5lLlxuICpcbiAqIEBwYXJhbSB7bHVuci5QaXBlbGluZUZ1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIHBpcGVsaW5lLlxuICovXG5sdW5yLlBpcGVsaW5lLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHBvcyA9IHRoaXMuX3N0YWNrLmluZGV4T2YoZm4pXG4gIGlmIChwb3MgPT0gLTEpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuX3N0YWNrLnNwbGljZShwb3MsIDEpXG59XG5cbi8qKlxuICogUnVucyB0aGUgY3VycmVudCBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IG1ha2UgdXAgdGhlIHBpcGVsaW5lIGFnYWluc3QgdGhlXG4gKiBwYXNzZWQgdG9rZW5zLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHRva2VucyBUaGUgdG9rZW5zIHRvIHJ1biB0aHJvdWdoIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHRva2Vucykge1xuICB2YXIgc3RhY2tMZW5ndGggPSB0aGlzLl9zdGFjay5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZm4gPSB0aGlzLl9zdGFja1tpXVxuICAgIHZhciBtZW1vID0gW11cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gZm4odG9rZW5zW2pdLCBqLCB0b2tlbnMpXG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgfHwgcmVzdWx0ID09PSAnJykgY29udGludWVcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlc3VsdC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIG1lbW8ucHVzaChyZXN1bHRba10pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8ucHVzaChyZXN1bHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdG9rZW5zID0gbWVtb1xuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcGFzc2luZyBhIHN0cmluZyB0aHJvdWdoIGEgcGlwZWxpbmUgYW5kIGdldHRpbmdcbiAqIHN0cmluZ3Mgb3V0LiBUaGlzIG1ldGhvZCB0YWtlcyBjYXJlIG9mIHdyYXBwaW5nIHRoZSBwYXNzZWQgc3RyaW5nIGluIGFcbiAqIHRva2VuIGFuZCBtYXBwaW5nIHRoZSByZXN1bHRpbmcgdG9rZW5zIGJhY2sgdG8gc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIC0gVGhlIHN0cmluZyB0byBwYXNzIHRocm91Z2ggdGhlIHBpcGVsaW5lLlxuICogQHBhcmFtIHs/b2JqZWN0fSBtZXRhZGF0YSAtIE9wdGlvbmFsIG1ldGFkYXRhIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlblxuICogcGFzc2VkIHRvIHRoZSBwaXBlbGluZS5cbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucnVuU3RyaW5nID0gZnVuY3Rpb24gKHN0ciwgbWV0YWRhdGEpIHtcbiAgdmFyIHRva2VuID0gbmV3IGx1bnIuVG9rZW4gKHN0ciwgbWV0YWRhdGEpXG5cbiAgcmV0dXJuIHRoaXMucnVuKFt0b2tlbl0pLm1hcChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnRvU3RyaW5nKClcbiAgfSlcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIHBpcGVsaW5lIGJ5IHJlbW92aW5nIGFueSBleGlzdGluZyBwcm9jZXNzb3JzLlxuICpcbiAqL1xubHVuci5QaXBlbGluZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3N0YWNrID0gW11cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHBpcGVsaW5lIHJlYWR5IGZvciBzZXJpYWxpc2F0aW9uLlxuICpcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmx1bnIuUGlwZWxpbmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3N0YWNrLm1hcChmdW5jdGlvbiAoZm4pIHtcbiAgICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChmbilcblxuICAgIHJldHVybiBmbi5sYWJlbFxuICB9KVxufVxuLyohXG4gKiBsdW5yLlZlY3RvclxuICogQ29weXJpZ2h0IChDKSAyMDIwIE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSB2ZWN0b3IgaXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHZlY3RvciBzcGFjZSBvZiBkb2N1bWVudHMgYW5kIHF1ZXJpZXMuIFRoZXNlXG4gKiB2ZWN0b3JzIHN1cHBvcnQgb3BlcmF0aW9ucyB0byBkZXRlcm1pbmUgdGhlIHNpbWlsYXJpdHkgYmV0d2VlbiB0d28gZG9jdW1lbnRzIG9yXG4gKiBhIGRvY3VtZW50IGFuZCBhIHF1ZXJ5LlxuICpcbiAqIE5vcm1hbGx5IG5vIHBhcmFtZXRlcnMgYXJlIHJlcXVpcmVkIGZvciBpbml0aWFsaXppbmcgYSB2ZWN0b3IsIGJ1dCBpbiB0aGUgY2FzZSBvZlxuICogbG9hZGluZyBhIHByZXZpb3VzbHkgZHVtcGVkIHZlY3RvciB0aGUgcmF3IGVsZW1lbnRzIGNhbiBiZSBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKlxuICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgdmVjdG9ycyBhcmUgaW1wbGVtZW50ZWQgd2l0aCBhIGZsYXQgYXJyYXksIHdoZXJlIGFuIGVsZW1lbnRzXG4gKiBpbmRleCBpcyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBpdHMgdmFsdWUuIEUuZy4gW2luZGV4LCB2YWx1ZSwgaW5kZXgsIHZhbHVlXS4gVGhpc1xuICogYWxsb3dzIHRoZSB1bmRlcmx5aW5nIGFycmF5IHRvIGJlIGFzIHNwYXJzZSBhcyBwb3NzaWJsZSBhbmQgc3RpbGwgb2ZmZXIgZGVjZW50XG4gKiBwZXJmb3JtYW5jZSB3aGVuIGJlaW5nIHVzZWQgZm9yIHZlY3RvciBjYWxjdWxhdGlvbnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcltdfSBbZWxlbWVudHNdIC0gVGhlIGZsYXQgbGlzdCBvZiBlbGVtZW50IGluZGV4IGFuZCBlbGVtZW50IHZhbHVlIHBhaXJzLlxuICovXG5sdW5yLlZlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICB0aGlzLl9tYWduaXR1ZGUgPSAwXG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cyB8fCBbXVxufVxuXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSB2ZWN0b3IgdG8gaW5zZXJ0IGEgZ2l2ZW4gaW5kZXguXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgaW5zZXJ0IGFuZCB1cHNlcnQuIElmIHRoZXJlIGFyZSBkdXBsaWNhdGUgaW5kZXhlcyB0aGVuXG4gKiB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQgYXMgaWYgdGhlIHZhbHVlIGZvciB0aGF0IGluZGV4IHdlcmUgdG8gYmUgdXBkYXRlZCwgYnV0IGl0XG4gKiBpcyB0aGUgY2FsbGVycyByZXNwb25zaWJpbGl0eSB0byBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGEgZHVwbGljYXRlIGF0IHRoYXQgaW5kZXhcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaW5zZXJ0SWR4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCBiZSBpbnNlcnRlZC5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmx1bnIuVmVjdG9yLnByb3RvdHlwZS5wb3NpdGlvbkZvckluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIC8vIEZvciBhbiBlbXB0eSB2ZWN0b3IgdGhlIHR1cGxlIGNhbiBiZSBpbnNlcnRlZCBhdCB0aGUgYmVnaW5uaW5nXG4gIGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIHZhciBzdGFydCA9IDAsXG4gICAgICBlbmQgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCAvIDIsXG4gICAgICBzbGljZUxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxuICAgICAgcGl2b3RQb2ludCA9IE1hdGguZmxvb3Ioc2xpY2VMZW5ndGggLyAyKSxcbiAgICAgIHBpdm90SW5kZXggPSB0aGlzLmVsZW1lbnRzW3Bpdm90UG9pbnQgKiAyXVxuXG4gIHdoaWxlIChzbGljZUxlbmd0aCA+IDEpIHtcbiAgICBpZiAocGl2b3RJbmRleCA8IGluZGV4KSB7XG4gICAgICBzdGFydCA9IHBpdm90UG9pbnRcbiAgICB9XG5cbiAgICBpZiAocGl2b3RJbmRleCA+IGluZGV4KSB7XG4gICAgICBlbmQgPSBwaXZvdFBvaW50XG4gICAgfVxuXG4gICAgaWYgKHBpdm90SW5kZXggPT0gaW5kZXgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgc2xpY2VMZW5ndGggPSBlbmQgLSBzdGFydFxuICAgIHBpdm90UG9pbnQgPSBzdGFydCArIE1hdGguZmxvb3Ioc2xpY2VMZW5ndGggLyAyKVxuICAgIHBpdm90SW5kZXggPSB0aGlzLmVsZW1lbnRzW3Bpdm90UG9pbnQgKiAyXVxuICB9XG5cbiAgaWYgKHBpdm90SW5kZXggPT0gaW5kZXgpIHtcbiAgICByZXR1cm4gcGl2b3RQb2ludCAqIDJcbiAgfVxuXG4gIGlmIChwaXZvdEluZGV4ID4gaW5kZXgpIHtcbiAgICByZXR1cm4gcGl2b3RQb2ludCAqIDJcbiAgfVxuXG4gIGlmIChwaXZvdEluZGV4IDwgaW5kZXgpIHtcbiAgICByZXR1cm4gKHBpdm90UG9pbnQgKyAxKSAqIDJcbiAgfVxufVxuXG4vKipcbiAqIEluc2VydHMgYW4gZWxlbWVudCBhdCBhbiBpbmRleCB3aXRoaW4gdGhlIHZlY3Rvci5cbiAqXG4gKiBEb2VzIG5vdCBhbGxvdyBkdXBsaWNhdGVzLCB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGlzIGFscmVhZHkgYW4gZW50cnlcbiAqIGZvciB0aGlzIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnNlcnRJZHggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIFRoZSB2YWx1ZSB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB2ZWN0b3IuXG4gKi9cbmx1bnIuVmVjdG9yLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoaW5zZXJ0SWR4LCB2YWwpIHtcbiAgdGhpcy51cHNlcnQoaW5zZXJ0SWR4LCB2YWwsIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBcImR1cGxpY2F0ZSBpbmRleFwiXG4gIH0pXG59XG5cbi8qKlxuICogSW5zZXJ0cyBvciB1cGRhdGVzIGFuIGV4aXN0aW5nIGluZGV4IHdpdGhpbiB0aGUgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbnNlcnRJZHggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGVsZW1lbnQgc2hvdWxkIGJlIGluc2VydGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIFRoZSB2YWx1ZSB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSB2ZWN0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgZm9yIHVwZGF0ZXMsIHRoZSBleGlzdGluZyB2YWx1ZSBhbmQgdGhlXG4gKiByZXF1ZXN0ZWQgdmFsdWUgYXJlIHBhc3NlZCBhcyBhcmd1bWVudHNcbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLnVwc2VydCA9IGZ1bmN0aW9uIChpbnNlcnRJZHgsIHZhbCwgZm4pIHtcbiAgdGhpcy5fbWFnbml0dWRlID0gMFxuICB2YXIgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9ySW5kZXgoaW5zZXJ0SWR4KVxuXG4gIGlmICh0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXSA9PSBpbnNlcnRJZHgpIHtcbiAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uICsgMV0gPSBmbih0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uICsgMV0sIHZhbClcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmVsZW1lbnRzLnNwbGljZShwb3NpdGlvbiwgMCwgaW5zZXJ0SWR4LCB2YWwpXG4gIH1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtYWduaXR1ZGUgb2YgdGhpcyB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLm1hZ25pdHVkZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX21hZ25pdHVkZSkgcmV0dXJuIHRoaXMuX21hZ25pdHVkZVxuXG4gIHZhciBzdW1PZlNxdWFyZXMgPSAwLFxuICAgICAgZWxlbWVudHNMZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgZWxlbWVudHNMZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciB2YWwgPSB0aGlzLmVsZW1lbnRzW2ldXG4gICAgc3VtT2ZTcXVhcmVzICs9IHZhbCAqIHZhbFxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX21hZ25pdHVkZSA9IE1hdGguc3FydChzdW1PZlNxdWFyZXMpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7bHVuci5WZWN0b3J9IG90aGVyVmVjdG9yIC0gVGhlIHZlY3RvciB0byBjb21wdXRlIHRoZSBkb3QgcHJvZHVjdCB3aXRoLlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xubHVuci5WZWN0b3IucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uIChvdGhlclZlY3Rvcikge1xuICB2YXIgZG90UHJvZHVjdCA9IDAsXG4gICAgICBhID0gdGhpcy5lbGVtZW50cywgYiA9IG90aGVyVmVjdG9yLmVsZW1lbnRzLFxuICAgICAgYUxlbiA9IGEubGVuZ3RoLCBiTGVuID0gYi5sZW5ndGgsXG4gICAgICBhVmFsID0gMCwgYlZhbCA9IDAsXG4gICAgICBpID0gMCwgaiA9IDBcblxuICB3aGlsZSAoaSA8IGFMZW4gJiYgaiA8IGJMZW4pIHtcbiAgICBhVmFsID0gYVtpXSwgYlZhbCA9IGJbal1cbiAgICBpZiAoYVZhbCA8IGJWYWwpIHtcbiAgICAgIGkgKz0gMlxuICAgIH0gZWxzZSBpZiAoYVZhbCA+IGJWYWwpIHtcbiAgICAgIGogKz0gMlxuICAgIH0gZWxzZSBpZiAoYVZhbCA9PSBiVmFsKSB7XG4gICAgICBkb3RQcm9kdWN0ICs9IGFbaSArIDFdICogYltqICsgMV1cbiAgICAgIGkgKz0gMlxuICAgICAgaiArPSAyXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvdFByb2R1Y3Rcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzaW1pbGFyaXR5IGJldHdlZW4gdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxuICpcbiAqIEBwYXJhbSB7bHVuci5WZWN0b3J9IG90aGVyVmVjdG9yIC0gVGhlIG90aGVyIHZlY3RvciB0byBjYWxjdWxhdGUgdGhlXG4gKiBzaW1pbGFyaXR5IHdpdGguXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUuc2ltaWxhcml0eSA9IGZ1bmN0aW9uIChvdGhlclZlY3Rvcikge1xuICByZXR1cm4gdGhpcy5kb3Qob3RoZXJWZWN0b3IpIC8gdGhpcy5tYWduaXR1ZGUoKSB8fCAwXG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHZlY3RvciB0byBhbiBhcnJheSBvZiB0aGUgZWxlbWVudHMgd2l0aGluIHRoZSB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dHB1dCA9IG5ldyBBcnJheSAodGhpcy5lbGVtZW50cy5sZW5ndGggLyAyKVxuXG4gIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8IHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpICs9IDIsIGorKykge1xuICAgIG91dHB1dFtqXSA9IHRoaXMuZWxlbWVudHNbaV1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBBIEpTT04gc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3IuXG4gKlxuICogQHJldHVybnMge051bWJlcltdfVxuICovXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lbGVtZW50c1xufVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIVxuICogbHVuci5zdGVtbWVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKiBJbmNsdWRlcyBjb2RlIGZyb20gLSBodHRwOi8vdGFydGFydXMub3JnL35tYXJ0aW4vUG9ydGVyU3RlbW1lci9qcy50eHRcbiAqL1xuXG4vKipcbiAqIGx1bnIuc3RlbW1lciBpcyBhbiBlbmdsaXNoIGxhbmd1YWdlIHN0ZW1tZXIsIHRoaXMgaXMgYSBKYXZhU2NyaXB0XG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9ydGVyU3RlbW1lciB0YWtlbiBmcm9tIGh0dHA6Ly90YXJ0YXJ1cy5vcmcvfm1hcnRpblxuICpcbiAqIEBzdGF0aWNcbiAqIEBpbXBsZW1lbnRzIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259XG4gKiBAcGFyYW0ge2x1bnIuVG9rZW59IHRva2VuIC0gVGhlIHN0cmluZyB0byBzdGVtXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuUGlwZWxpbmV9XG4gKiBAZnVuY3Rpb25cbiAqL1xubHVuci5zdGVtbWVyID0gKGZ1bmN0aW9uKCl7XG4gIHZhciBzdGVwMmxpc3QgPSB7XG4gICAgICBcImF0aW9uYWxcIiA6IFwiYXRlXCIsXG4gICAgICBcInRpb25hbFwiIDogXCJ0aW9uXCIsXG4gICAgICBcImVuY2lcIiA6IFwiZW5jZVwiLFxuICAgICAgXCJhbmNpXCIgOiBcImFuY2VcIixcbiAgICAgIFwiaXplclwiIDogXCJpemVcIixcbiAgICAgIFwiYmxpXCIgOiBcImJsZVwiLFxuICAgICAgXCJhbGxpXCIgOiBcImFsXCIsXG4gICAgICBcImVudGxpXCIgOiBcImVudFwiLFxuICAgICAgXCJlbGlcIiA6IFwiZVwiLFxuICAgICAgXCJvdXNsaVwiIDogXCJvdXNcIixcbiAgICAgIFwiaXphdGlvblwiIDogXCJpemVcIixcbiAgICAgIFwiYXRpb25cIiA6IFwiYXRlXCIsXG4gICAgICBcImF0b3JcIiA6IFwiYXRlXCIsXG4gICAgICBcImFsaXNtXCIgOiBcImFsXCIsXG4gICAgICBcIml2ZW5lc3NcIiA6IFwiaXZlXCIsXG4gICAgICBcImZ1bG5lc3NcIiA6IFwiZnVsXCIsXG4gICAgICBcIm91c25lc3NcIiA6IFwib3VzXCIsXG4gICAgICBcImFsaXRpXCIgOiBcImFsXCIsXG4gICAgICBcIml2aXRpXCIgOiBcIml2ZVwiLFxuICAgICAgXCJiaWxpdGlcIiA6IFwiYmxlXCIsXG4gICAgICBcImxvZ2lcIiA6IFwibG9nXCJcbiAgICB9LFxuXG4gICAgc3RlcDNsaXN0ID0ge1xuICAgICAgXCJpY2F0ZVwiIDogXCJpY1wiLFxuICAgICAgXCJhdGl2ZVwiIDogXCJcIixcbiAgICAgIFwiYWxpemVcIiA6IFwiYWxcIixcbiAgICAgIFwiaWNpdGlcIiA6IFwiaWNcIixcbiAgICAgIFwiaWNhbFwiIDogXCJpY1wiLFxuICAgICAgXCJmdWxcIiA6IFwiXCIsXG4gICAgICBcIm5lc3NcIiA6IFwiXCJcbiAgICB9LFxuXG4gICAgYyA9IFwiW15hZWlvdV1cIiwgICAgICAgICAgLy8gY29uc29uYW50XG4gICAgdiA9IFwiW2FlaW91eV1cIiwgICAgICAgICAgLy8gdm93ZWxcbiAgICBDID0gYyArIFwiW15hZWlvdXldKlwiLCAgICAvLyBjb25zb25hbnQgc2VxdWVuY2VcbiAgICBWID0gdiArIFwiW2FlaW91XSpcIiwgICAgICAvLyB2b3dlbCBzZXF1ZW5jZVxuXG4gICAgbWdyMCA9IFwiXihcIiArIEMgKyBcIik/XCIgKyBWICsgQywgICAgICAgICAgICAgICAvLyBbQ11WQy4uLiBpcyBtPjBcbiAgICBtZXExID0gXCJeKFwiICsgQyArIFwiKT9cIiArIFYgKyBDICsgXCIoXCIgKyBWICsgXCIpPyRcIiwgIC8vIFtDXVZDW1ZdIGlzIG09MVxuICAgIG1ncjEgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgViArIEMgKyBWICsgQywgICAgICAgLy8gW0NdVkNWQy4uLiBpcyBtPjFcbiAgICBzX3YgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgdjsgICAgICAgICAgICAgICAgICAgLy8gdm93ZWwgaW4gc3RlbVxuXG4gIHZhciByZV9tZ3IwID0gbmV3IFJlZ0V4cChtZ3IwKTtcbiAgdmFyIHJlX21ncjEgPSBuZXcgUmVnRXhwKG1ncjEpO1xuICB2YXIgcmVfbWVxMSA9IG5ldyBSZWdFeHAobWVxMSk7XG4gIHZhciByZV9zX3YgPSBuZXcgUmVnRXhwKHNfdik7XG5cbiAgdmFyIHJlXzFhID0gL14oLis/KShzc3xpKWVzJC87XG4gIHZhciByZTJfMWEgPSAvXiguKz8pKFtec10pcyQvO1xuICB2YXIgcmVfMWIgPSAvXiguKz8pZWVkJC87XG4gIHZhciByZTJfMWIgPSAvXiguKz8pKGVkfGluZykkLztcbiAgdmFyIHJlXzFiXzIgPSAvLiQvO1xuICB2YXIgcmUyXzFiXzIgPSAvKGF0fGJsfGl6KSQvO1xuICB2YXIgcmUzXzFiXzIgPSBuZXcgUmVnRXhwKFwiKFteYWVpb3V5bHN6XSlcXFxcMSRcIik7XG4gIHZhciByZTRfMWJfMiA9IG5ldyBSZWdFeHAoXCJeXCIgKyBDICsgdiArIFwiW15hZWlvdXd4eV0kXCIpO1xuXG4gIHZhciByZV8xYyA9IC9eKC4rP1teYWVpb3VdKXkkLztcbiAgdmFyIHJlXzIgPSAvXiguKz8pKGF0aW9uYWx8dGlvbmFsfGVuY2l8YW5jaXxpemVyfGJsaXxhbGxpfGVudGxpfGVsaXxvdXNsaXxpemF0aW9ufGF0aW9ufGF0b3J8YWxpc218aXZlbmVzc3xmdWxuZXNzfG91c25lc3N8YWxpdGl8aXZpdGl8YmlsaXRpfGxvZ2kpJC87XG5cbiAgdmFyIHJlXzMgPSAvXiguKz8pKGljYXRlfGF0aXZlfGFsaXplfGljaXRpfGljYWx8ZnVsfG5lc3MpJC87XG5cbiAgdmFyIHJlXzQgPSAvXiguKz8pKGFsfGFuY2V8ZW5jZXxlcnxpY3xhYmxlfGlibGV8YW50fGVtZW50fG1lbnR8ZW50fG91fGlzbXxhdGV8aXRpfG91c3xpdmV8aXplKSQvO1xuICB2YXIgcmUyXzQgPSAvXiguKz8pKHN8dCkoaW9uKSQvO1xuXG4gIHZhciByZV81ID0gL14oLis/KWUkLztcbiAgdmFyIHJlXzVfMSA9IC9sbCQvO1xuICB2YXIgcmUzXzUgPSBuZXcgUmVnRXhwKFwiXlwiICsgQyArIHYgKyBcIlteYWVpb3V3eHldJFwiKTtcblxuICB2YXIgcG9ydGVyU3RlbW1lciA9IGZ1bmN0aW9uIHBvcnRlclN0ZW1tZXIodykge1xuICAgIHZhciBzdGVtLFxuICAgICAgc3VmZml4LFxuICAgICAgZmlyc3RjaCxcbiAgICAgIHJlLFxuICAgICAgcmUyLFxuICAgICAgcmUzLFxuICAgICAgcmU0O1xuXG4gICAgaWYgKHcubGVuZ3RoIDwgMykgeyByZXR1cm4gdzsgfVxuXG4gICAgZmlyc3RjaCA9IHcuc3Vic3RyKDAsMSk7XG4gICAgaWYgKGZpcnN0Y2ggPT0gXCJ5XCIpIHtcbiAgICAgIHcgPSBmaXJzdGNoLnRvVXBwZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDFhXG4gICAgcmUgPSByZV8xYVxuICAgIHJlMiA9IHJlMl8xYTtcblxuICAgIGlmIChyZS50ZXN0KHcpKSB7IHcgPSB3LnJlcGxhY2UocmUsXCIkMSQyXCIpOyB9XG4gICAgZWxzZSBpZiAocmUyLnRlc3QodykpIHsgdyA9IHcucmVwbGFjZShyZTIsXCIkMSQyXCIpOyB9XG5cbiAgICAvLyBTdGVwIDFiXG4gICAgcmUgPSByZV8xYjtcbiAgICByZTIgPSByZTJfMWI7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICByZSA9IHJlX21ncjA7XG4gICAgICBpZiAocmUudGVzdChmcFsxXSkpIHtcbiAgICAgICAgcmUgPSByZV8xYl8yO1xuICAgICAgICB3ID0gdy5yZXBsYWNlKHJlLFwiXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmUyLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlMi5leGVjKHcpO1xuICAgICAgc3RlbSA9IGZwWzFdO1xuICAgICAgcmUyID0gcmVfc192O1xuICAgICAgaWYgKHJlMi50ZXN0KHN0ZW0pKSB7XG4gICAgICAgIHcgPSBzdGVtO1xuICAgICAgICByZTIgPSByZTJfMWJfMjtcbiAgICAgICAgcmUzID0gcmUzXzFiXzI7XG4gICAgICAgIHJlNCA9IHJlNF8xYl8yO1xuICAgICAgICBpZiAocmUyLnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgICBlbHNlIGlmIChyZTMudGVzdCh3KSkgeyByZSA9IHJlXzFiXzI7IHcgPSB3LnJlcGxhY2UocmUsXCJcIik7IH1cbiAgICAgICAgZWxzZSBpZiAocmU0LnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgMWMgLSByZXBsYWNlIHN1ZmZpeCB5IG9yIFkgYnkgaSBpZiBwcmVjZWRlZCBieSBhIG5vbi12b3dlbCB3aGljaCBpcyBub3QgdGhlIGZpcnN0IGxldHRlciBvZiB0aGUgd29yZCAoc28gY3J5IC0+IGNyaSwgYnkgLT4gYnksIHNheSAtPiBzYXkpXG4gICAgcmUgPSByZV8xYztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHcgPSBzdGVtICsgXCJpXCI7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAyXG4gICAgcmUgPSByZV8yO1xuICAgIGlmIChyZS50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xuICAgICAgc3RlbSA9IGZwWzFdO1xuICAgICAgc3VmZml4ID0gZnBbMl07XG4gICAgICByZSA9IHJlX21ncjA7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbSArIHN0ZXAybGlzdFtzdWZmaXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0ZXAgM1xuICAgIHJlID0gcmVfMztcbiAgICBpZiAocmUudGVzdCh3KSkge1xuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXTtcbiAgICAgIHN1ZmZpeCA9IGZwWzJdO1xuICAgICAgcmUgPSByZV9tZ3IwO1xuICAgICAgaWYgKHJlLnRlc3Qoc3RlbSkpIHtcbiAgICAgICAgdyA9IHN0ZW0gKyBzdGVwM2xpc3Rbc3VmZml4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDRcbiAgICByZSA9IHJlXzQ7XG4gICAgcmUyID0gcmUyXzQ7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7XG4gICAgICB2YXIgZnAgPSByZTIuZXhlYyh3KTtcbiAgICAgIHN0ZW0gPSBmcFsxXSArIGZwWzJdO1xuICAgICAgcmUyID0gcmVfbWdyMTtcbiAgICAgIGlmIChyZTIudGVzdChzdGVtKSkge1xuICAgICAgICB3ID0gc3RlbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdGVwIDVcbiAgICByZSA9IHJlXzU7XG4gICAgaWYgKHJlLnRlc3QodykpIHtcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XG4gICAgICBzdGVtID0gZnBbMV07XG4gICAgICByZSA9IHJlX21ncjE7XG4gICAgICByZTIgPSByZV9tZXExO1xuICAgICAgcmUzID0gcmUzXzU7XG4gICAgICBpZiAocmUudGVzdChzdGVtKSB8fCAocmUyLnRlc3Qoc3RlbSkgJiYgIShyZTMudGVzdChzdGVtKSkpKSB7XG4gICAgICAgIHcgPSBzdGVtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJlID0gcmVfNV8xO1xuICAgIHJlMiA9IHJlX21ncjE7XG4gICAgaWYgKHJlLnRlc3QodykgJiYgcmUyLnRlc3QodykpIHtcbiAgICAgIHJlID0gcmVfMWJfMjtcbiAgICAgIHcgPSB3LnJlcGxhY2UocmUsXCJcIik7XG4gICAgfVxuXG4gICAgLy8gYW5kIHR1cm4gaW5pdGlhbCBZIGJhY2sgdG8geVxuXG4gICAgaWYgKGZpcnN0Y2ggPT0gXCJ5XCIpIHtcbiAgICAgIHcgPSBmaXJzdGNoLnRvTG93ZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnVwZGF0ZShwb3J0ZXJTdGVtbWVyKTtcbiAgfVxufSkoKTtcblxubHVuci5QaXBlbGluZS5yZWdpc3RlckZ1bmN0aW9uKGx1bnIuc3RlbW1lciwgJ3N0ZW1tZXInKVxuLyohXG4gKiBsdW5yLnN0b3BXb3JkRmlsdGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBsdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIgYnVpbGRzIGEgc3RvcFdvcmRGaWx0ZXIgZnVuY3Rpb24gZnJvbSB0aGUgcHJvdmlkZWRcbiAqIGxpc3Qgb2Ygc3RvcCB3b3Jkcy5cbiAqXG4gKiBUaGUgYnVpbHQgaW4gbHVuci5zdG9wV29yZEZpbHRlciBpcyBidWlsdCB1c2luZyB0aGlzIGdlbmVyYXRvciBhbmQgY2FuIGJlIHVzZWRcbiAqIHRvIGdlbmVyYXRlIGN1c3RvbSBzdG9wV29yZEZpbHRlcnMgZm9yIGFwcGxpY2F0aW9ucyBvciBub24gRW5nbGlzaCBsYW5ndWFnZXMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fSB0b2tlbiBUaGUgdG9rZW4gdG8gcGFzcyB0aHJvdWdoIHRoZSBmaWx0ZXJcbiAqIEByZXR1cm5zIHtsdW5yLlBpcGVsaW5lRnVuY3Rpb259XG4gKiBAc2VlIGx1bnIuUGlwZWxpbmVcbiAqIEBzZWUgbHVuci5zdG9wV29yZEZpbHRlclxuICovXG5sdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIgPSBmdW5jdGlvbiAoc3RvcFdvcmRzKSB7XG4gIHZhciB3b3JkcyA9IHN0b3BXb3Jkcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIHN0b3BXb3JkKSB7XG4gICAgbWVtb1tzdG9wV29yZF0gPSBzdG9wV29yZFxuICAgIHJldHVybiBtZW1vXG4gIH0sIHt9KVxuXG4gIHJldHVybiBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICBpZiAodG9rZW4gJiYgd29yZHNbdG9rZW4udG9TdHJpbmcoKV0gIT09IHRva2VuLnRvU3RyaW5nKCkpIHJldHVybiB0b2tlblxuICB9XG59XG5cbi8qKlxuICogbHVuci5zdG9wV29yZEZpbHRlciBpcyBhbiBFbmdsaXNoIGxhbmd1YWdlIHN0b3Agd29yZCBsaXN0IGZpbHRlciwgYW55IHdvcmRzXG4gKiBjb250YWluZWQgaW4gdGhlIGxpc3Qgd2lsbCBub3QgYmUgcGFzc2VkIHRocm91Z2ggdGhlIGZpbHRlci5cbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gdGhlIFBpcGVsaW5lLiBJZiB0aGUgdG9rZW4gZG9lcyBub3QgcGFzcyB0aGVcbiAqIGZpbHRlciB0aGVuIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICpcbiAqIEBmdW5jdGlvblxuICogQGltcGxlbWVudHMge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn1cbiAqIEBwYXJhbXMge2x1bnIuVG9rZW59IHRva2VuIC0gQSB0b2tlbiB0byBjaGVjayBmb3IgYmVpbmcgYSBzdG9wIHdvcmQuXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUge0BsaW5rIGx1bnIuUGlwZWxpbmV9XG4gKi9cbmx1bnIuc3RvcFdvcmRGaWx0ZXIgPSBsdW5yLmdlbmVyYXRlU3RvcFdvcmRGaWx0ZXIoW1xuICAnYScsXG4gICdhYmxlJyxcbiAgJ2Fib3V0JyxcbiAgJ2Fjcm9zcycsXG4gICdhZnRlcicsXG4gICdhbGwnLFxuICAnYWxtb3N0JyxcbiAgJ2Fsc28nLFxuICAnYW0nLFxuICAnYW1vbmcnLFxuICAnYW4nLFxuICAnYW5kJyxcbiAgJ2FueScsXG4gICdhcmUnLFxuICAnYXMnLFxuICAnYXQnLFxuICAnYmUnLFxuICAnYmVjYXVzZScsXG4gICdiZWVuJyxcbiAgJ2J1dCcsXG4gICdieScsXG4gICdjYW4nLFxuICAnY2Fubm90JyxcbiAgJ2NvdWxkJyxcbiAgJ2RlYXInLFxuICAnZGlkJyxcbiAgJ2RvJyxcbiAgJ2RvZXMnLFxuICAnZWl0aGVyJyxcbiAgJ2Vsc2UnLFxuICAnZXZlcicsXG4gICdldmVyeScsXG4gICdmb3InLFxuICAnZnJvbScsXG4gICdnZXQnLFxuICAnZ290JyxcbiAgJ2hhZCcsXG4gICdoYXMnLFxuICAnaGF2ZScsXG4gICdoZScsXG4gICdoZXInLFxuICAnaGVycycsXG4gICdoaW0nLFxuICAnaGlzJyxcbiAgJ2hvdycsXG4gICdob3dldmVyJyxcbiAgJ2knLFxuICAnaWYnLFxuICAnaW4nLFxuICAnaW50bycsXG4gICdpcycsXG4gICdpdCcsXG4gICdpdHMnLFxuICAnanVzdCcsXG4gICdsZWFzdCcsXG4gICdsZXQnLFxuICAnbGlrZScsXG4gICdsaWtlbHknLFxuICAnbWF5JyxcbiAgJ21lJyxcbiAgJ21pZ2h0JyxcbiAgJ21vc3QnLFxuICAnbXVzdCcsXG4gICdteScsXG4gICduZWl0aGVyJyxcbiAgJ25vJyxcbiAgJ25vcicsXG4gICdub3QnLFxuICAnb2YnLFxuICAnb2ZmJyxcbiAgJ29mdGVuJyxcbiAgJ29uJyxcbiAgJ29ubHknLFxuICAnb3InLFxuICAnb3RoZXInLFxuICAnb3VyJyxcbiAgJ293bicsXG4gICdyYXRoZXInLFxuICAnc2FpZCcsXG4gICdzYXknLFxuICAnc2F5cycsXG4gICdzaGUnLFxuICAnc2hvdWxkJyxcbiAgJ3NpbmNlJyxcbiAgJ3NvJyxcbiAgJ3NvbWUnLFxuICAndGhhbicsXG4gICd0aGF0JyxcbiAgJ3RoZScsXG4gICd0aGVpcicsXG4gICd0aGVtJyxcbiAgJ3RoZW4nLFxuICAndGhlcmUnLFxuICAndGhlc2UnLFxuICAndGhleScsXG4gICd0aGlzJyxcbiAgJ3RpcycsXG4gICd0bycsXG4gICd0b28nLFxuICAndHdhcycsXG4gICd1cycsXG4gICd3YW50cycsXG4gICd3YXMnLFxuICAnd2UnLFxuICAnd2VyZScsXG4gICd3aGF0JyxcbiAgJ3doZW4nLFxuICAnd2hlcmUnLFxuICAnd2hpY2gnLFxuICAnd2hpbGUnLFxuICAnd2hvJyxcbiAgJ3dob20nLFxuICAnd2h5JyxcbiAgJ3dpbGwnLFxuICAnd2l0aCcsXG4gICd3b3VsZCcsXG4gICd5ZXQnLFxuICAneW91JyxcbiAgJ3lvdXInXG5dKVxuXG5sdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24obHVuci5zdG9wV29yZEZpbHRlciwgJ3N0b3BXb3JkRmlsdGVyJylcbi8qIVxuICogbHVuci50cmltbWVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBsdW5yLnRyaW1tZXIgaXMgYSBwaXBlbGluZSBmdW5jdGlvbiBmb3IgdHJpbW1pbmcgbm9uIHdvcmRcbiAqIGNoYXJhY3RlcnMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdG9rZW5zIGJlZm9yZSB0aGV5XG4gKiBlbnRlciB0aGUgaW5kZXguXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBtYXkgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24gbGF0aW5cbiAqIGNoYXJhY3RlcnMgYW5kIHNob3VsZCBlaXRoZXIgYmUgcmVtb3ZlZCBvciBhZGFwdGVkIGZvciB1c2VcbiAqIHdpdGggbGFuZ3VhZ2VzIHdpdGggbm9uLWxhdGluIGNoYXJhY3RlcnMuXG4gKlxuICogQHN0YXRpY1xuICogQGltcGxlbWVudHMge2x1bnIuUGlwZWxpbmVGdW5jdGlvbn1cbiAqIEBwYXJhbSB7bHVuci5Ub2tlbn0gdG9rZW4gVGhlIHRva2VuIHRvIHBhc3MgdGhyb3VnaCB0aGUgZmlsdGVyXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlbn1cbiAqIEBzZWUgbHVuci5QaXBlbGluZVxuICovXG5sdW5yLnRyaW1tZXIgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnVwZGF0ZShmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnJlcGxhY2UoL15cXFcrLywgJycpLnJlcGxhY2UoL1xcVyskLywgJycpXG4gIH0pXG59XG5cbmx1bnIuUGlwZWxpbmUucmVnaXN0ZXJGdW5jdGlvbihsdW5yLnRyaW1tZXIsICd0cmltbWVyJylcbi8qIVxuICogbHVuci5Ub2tlblNldFxuICogQ29weXJpZ2h0IChDKSAyMDIwIE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogQSB0b2tlbiBzZXQgaXMgdXNlZCB0byBzdG9yZSB0aGUgdW5pcXVlIGxpc3Qgb2YgYWxsIHRva2Vuc1xuICogd2l0aGluIGFuIGluZGV4LiBUb2tlbiBzZXRzIGFyZSBhbHNvIHVzZWQgdG8gcmVwcmVzZW50IGFuXG4gKiBpbmNvbWluZyBxdWVyeSB0byB0aGUgaW5kZXgsIHRoaXMgcXVlcnkgdG9rZW4gc2V0IGFuZCBpbmRleFxuICogdG9rZW4gc2V0IGFyZSB0aGVuIGludGVyc2VjdGVkIHRvIGZpbmQgd2hpY2ggdG9rZW5zIHRvIGxvb2tcbiAqIHVwIGluIHRoZSBpbnZlcnRlZCBpbmRleC5cbiAqXG4gKiBBIHRva2VuIHNldCBjYW4gaG9sZCBtdWx0aXBsZSB0b2tlbnMsIGFzIGluIHRoZSBjYXNlIG9mIHRoZVxuICogaW5kZXggdG9rZW4gc2V0LCBvciBpdCBjYW4gaG9sZCBhIHNpbmdsZSB0b2tlbiBhcyBpbiB0aGVcbiAqIGNhc2Ugb2YgYSBzaW1wbGUgcXVlcnkgdG9rZW4gc2V0LlxuICpcbiAqIEFkZGl0aW9uYWxseSB0b2tlbiBzZXRzIGFyZSB1c2VkIHRvIHBlcmZvcm0gd2lsZGNhcmQgbWF0Y2hpbmcuXG4gKiBMZWFkaW5nLCBjb250YWluZWQgYW5kIHRyYWlsaW5nIHdpbGRjYXJkcyBhcmUgc3VwcG9ydGVkLCBhbmRcbiAqIGZyb20gdGhpcyBlZGl0IGRpc3RhbmNlIG1hdGNoaW5nIGNhbiBhbHNvIGJlIHByb3ZpZGVkLlxuICpcbiAqIFRva2VuIHNldHMgYXJlIGltcGxlbWVudGVkIGFzIGEgbWluaW1hbCBmaW5pdGUgc3RhdGUgYXV0b21hdGEsXG4gKiB3aGVyZSBib3RoIGNvbW1vbiBwcmVmaXhlcyBhbmQgc3VmZml4ZXMgYXJlIHNoYXJlZCBiZXR3ZWVuIHRva2Vucy5cbiAqIFRoaXMgaGVscHMgdG8gcmVkdWNlIHRoZSBzcGFjZSB1c2VkIGZvciBzdG9yaW5nIHRoZSB0b2tlbiBzZXQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmx1bnIuVG9rZW5TZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZmluYWwgPSBmYWxzZVxuICB0aGlzLmVkZ2VzID0ge31cbiAgdGhpcy5pZCA9IGx1bnIuVG9rZW5TZXQuX25leHRJZFxuICBsdW5yLlRva2VuU2V0Ll9uZXh0SWQgKz0gMVxufVxuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBuZXh0LCBhdXRvIGluY3JlbWVudCwgaWRlbnRpZmllciB0byBhc3NpZ25cbiAqIHRvIGEgbmV3IHRva2VuU2V0LlxuICpcbiAqIFRva2VuU2V0cyByZXF1aXJlIGEgdW5pcXVlIGlkZW50aWZpZXIgdG8gYmUgY29ycmVjdGx5IG1pbmltaXNlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5sdW5yLlRva2VuU2V0Ll9uZXh0SWQgPSAxXG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuU2V0IGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHNvcnRlZCBhcnJheSBvZiB3b3Jkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBhcnIgLSBBIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzIHRvIGNyZWF0ZSB0aGUgc2V0IGZyb20uXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlblNldH1cbiAqIEB0aHJvd3MgV2lsbCB0aHJvdyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgYXJyYXkgaXMgbm90IHNvcnRlZC5cbiAqL1xubHVuci5Ub2tlblNldC5mcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBidWlsZGVyID0gbmV3IGx1bnIuVG9rZW5TZXQuQnVpbGRlclxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWlsZGVyLmluc2VydChhcnJbaV0pXG4gIH1cblxuICBidWlsZGVyLmZpbmlzaCgpXG4gIHJldHVybiBidWlsZGVyLnJvb3Rcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdG9rZW4gc2V0IGZyb20gYSBxdWVyeSBjbGF1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGF1c2UgLSBBIHNpbmdsZSBjbGF1c2UgZnJvbSBsdW5yLlF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGNsYXVzZS50ZXJtIC0gVGhlIHF1ZXJ5IGNsYXVzZSB0ZXJtLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjbGF1c2UuZWRpdERpc3RhbmNlXSAtIFRoZSBvcHRpb25hbCBlZGl0IGRpc3RhbmNlIGZvciB0aGUgdGVybS5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VuU2V0fVxuICovXG5sdW5yLlRva2VuU2V0LmZyb21DbGF1c2UgPSBmdW5jdGlvbiAoY2xhdXNlKSB7XG4gIGlmICgnZWRpdERpc3RhbmNlJyBpbiBjbGF1c2UpIHtcbiAgICByZXR1cm4gbHVuci5Ub2tlblNldC5mcm9tRnV6enlTdHJpbmcoY2xhdXNlLnRlcm0sIGNsYXVzZS5lZGl0RGlzdGFuY2UpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGx1bnIuVG9rZW5TZXQuZnJvbVN0cmluZyhjbGF1c2UudGVybSlcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0b2tlbiBzZXQgcmVwcmVzZW50aW5nIGEgc2luZ2xlIHN0cmluZyB3aXRoIGEgc3BlY2lmaWVkXG4gKiBlZGl0IGRpc3RhbmNlLlxuICpcbiAqIEluc2VydGlvbnMsIGRlbGV0aW9ucywgc3Vic3RpdHV0aW9ucyBhbmQgdHJhbnNwb3NpdGlvbnMgYXJlIGVhY2hcbiAqIHRyZWF0ZWQgYXMgYW4gZWRpdCBkaXN0YW5jZSBvZiAxLlxuICpcbiAqIEluY3JlYXNpbmcgdGhlIGFsbG93ZWQgZWRpdCBkaXN0YW5jZSB3aWxsIGhhdmUgYSBkcmFtYXRpYyBpbXBhY3RcbiAqIG9uIHRoZSBwZXJmb3JtYW5jZSBvZiBib3RoIGNyZWF0aW5nIGFuZCBpbnRlcnNlY3RpbmcgdGhlc2UgVG9rZW5TZXRzLlxuICogSXQgaXMgYWR2aXNlZCB0byBrZWVwIHRoZSBlZGl0IGRpc3RhbmNlIGxlc3MgdGhhbiAzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgc3RyaW5nIHRvIGNyZWF0ZSB0aGUgdG9rZW4gc2V0IGZyb20uXG4gKiBAcGFyYW0ge251bWJlcn0gZWRpdERpc3RhbmNlIC0gVGhlIGFsbG93ZWQgZWRpdCBkaXN0YW5jZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtsdW5yLlZlY3Rvcn1cbiAqL1xubHVuci5Ub2tlblNldC5mcm9tRnV6enlTdHJpbmcgPSBmdW5jdGlvbiAoc3RyLCBlZGl0RGlzdGFuY2UpIHtcbiAgdmFyIHJvb3QgPSBuZXcgbHVuci5Ub2tlblNldFxuXG4gIHZhciBzdGFjayA9IFt7XG4gICAgbm9kZTogcm9vdCxcbiAgICBlZGl0c1JlbWFpbmluZzogZWRpdERpc3RhbmNlLFxuICAgIHN0cjogc3RyXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmcmFtZSA9IHN0YWNrLnBvcCgpXG5cbiAgICAvLyBubyBlZGl0XG4gICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgY2hhciA9IGZyYW1lLnN0ci5jaGFyQXQoMCksXG4gICAgICAgICAgbm9FZGl0Tm9kZVxuXG4gICAgICBpZiAoY2hhciBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIG5vRWRpdE5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW2NoYXJdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub0VkaXROb2RlID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgZnJhbWUubm9kZS5lZGdlc1tjaGFyXSA9IG5vRWRpdE5vZGVcbiAgICAgIH1cblxuICAgICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPT0gMSkge1xuICAgICAgICBub0VkaXROb2RlLmZpbmFsID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgbm9kZTogbm9FZGl0Tm9kZSxcbiAgICAgICAgZWRpdHNSZW1haW5pbmc6IGZyYW1lLmVkaXRzUmVtYWluaW5nLFxuICAgICAgICBzdHI6IGZyYW1lLnN0ci5zbGljZSgxKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuZWRpdHNSZW1haW5pbmcgPT0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyBpbnNlcnRpb25cbiAgICBpZiAoXCIqXCIgaW4gZnJhbWUubm9kZS5lZGdlcykge1xuICAgICAgdmFyIGluc2VydGlvbk5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW1wiKlwiXVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaW5zZXJ0aW9uTm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0XG4gICAgICBmcmFtZS5ub2RlLmVkZ2VzW1wiKlwiXSA9IGluc2VydGlvbk5vZGVcbiAgICB9XG5cbiAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA9PSAwKSB7XG4gICAgICBpbnNlcnRpb25Ob2RlLmZpbmFsID0gdHJ1ZVxuICAgIH1cblxuICAgIHN0YWNrLnB1c2goe1xuICAgICAgbm9kZTogaW5zZXJ0aW9uTm9kZSxcbiAgICAgIGVkaXRzUmVtYWluaW5nOiBmcmFtZS5lZGl0c1JlbWFpbmluZyAtIDEsXG4gICAgICBzdHI6IGZyYW1lLnN0clxuICAgIH0pXG5cbiAgICAvLyBkZWxldGlvblxuICAgIC8vIGNhbiBvbmx5IGRvIGEgZGVsZXRpb24gaWYgd2UgaGF2ZSBlbm91Z2ggZWRpdHMgcmVtYWluaW5nXG4gICAgLy8gYW5kIGlmIHRoZXJlIGFyZSBjaGFyYWN0ZXJzIGxlZnQgdG8gZGVsZXRlIGluIHRoZSBzdHJpbmdcbiAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA+IDEpIHtcbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBub2RlOiBmcmFtZS5ub2RlLFxuICAgICAgICBlZGl0c1JlbWFpbmluZzogZnJhbWUuZWRpdHNSZW1haW5pbmcgLSAxLFxuICAgICAgICBzdHI6IGZyYW1lLnN0ci5zbGljZSgxKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBkZWxldGlvblxuICAgIC8vIGp1c3QgcmVtb3ZpbmcgdGhlIGxhc3QgY2hhcmFjdGVyIGZyb20gdGhlIHN0clxuICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID09IDEpIHtcbiAgICAgIGZyYW1lLm5vZGUuZmluYWwgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gc3Vic3RpdHV0aW9uXG4gICAgLy8gY2FuIG9ubHkgZG8gYSBzdWJzdGl0dXRpb24gaWYgd2UgaGF2ZSBlbm91Z2ggZWRpdHMgcmVtYWluaW5nXG4gICAgLy8gYW5kIGlmIHRoZXJlIGFyZSBjaGFyYWN0ZXJzIGxlZnQgdG8gc3Vic3RpdHV0ZVxuICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID49IDEpIHtcbiAgICAgIGlmIChcIipcIiBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25Ob2RlID0gZnJhbWUubm9kZS5lZGdlc1tcIipcIl1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdWJzdGl0dXRpb25Ob2RlID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgZnJhbWUubm9kZS5lZGdlc1tcIipcIl0gPSBzdWJzdGl0dXRpb25Ob2RlXG4gICAgICB9XG5cbiAgICAgIGlmIChmcmFtZS5zdHIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgc3Vic3RpdHV0aW9uTm9kZS5maW5hbCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaCh7XG4gICAgICAgIG5vZGU6IHN1YnN0aXR1dGlvbk5vZGUsXG4gICAgICAgIGVkaXRzUmVtYWluaW5nOiBmcmFtZS5lZGl0c1JlbWFpbmluZyAtIDEsXG4gICAgICAgIHN0cjogZnJhbWUuc3RyLnNsaWNlKDEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIHRyYW5zcG9zaXRpb25cbiAgICAvLyBjYW4gb25seSBkbyBhIHRyYW5zcG9zaXRpb24gaWYgdGhlcmUgYXJlIGVkaXRzIHJlbWFpbmluZ1xuICAgIC8vIGFuZCB0aGVyZSBhcmUgZW5vdWdoIGNoYXJhY3RlcnMgdG8gdHJhbnNwb3NlXG4gICAgaWYgKGZyYW1lLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgY2hhckEgPSBmcmFtZS5zdHIuY2hhckF0KDApLFxuICAgICAgICAgIGNoYXJCID0gZnJhbWUuc3RyLmNoYXJBdCgxKSxcbiAgICAgICAgICB0cmFuc3Bvc2VOb2RlXG5cbiAgICAgIGlmIChjaGFyQiBpbiBmcmFtZS5ub2RlLmVkZ2VzKSB7XG4gICAgICAgIHRyYW5zcG9zZU5vZGUgPSBmcmFtZS5ub2RlLmVkZ2VzW2NoYXJCXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNwb3NlTm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0XG4gICAgICAgIGZyYW1lLm5vZGUuZWRnZXNbY2hhckJdID0gdHJhbnNwb3NlTm9kZVxuICAgICAgfVxuXG4gICAgICBpZiAoZnJhbWUuc3RyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRyYW5zcG9zZU5vZGUuZmluYWwgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICBub2RlOiB0cmFuc3Bvc2VOb2RlLFxuICAgICAgICBlZGl0c1JlbWFpbmluZzogZnJhbWUuZWRpdHNSZW1haW5pbmcgLSAxLFxuICAgICAgICBzdHI6IGNoYXJBICsgZnJhbWUuc3RyLnNsaWNlKDIpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByb290XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFRva2VuU2V0IGZyb20gYSBzdHJpbmcuXG4gKlxuICogVGhlIHN0cmluZyBtYXkgY29udGFpbiBvbmUgb3IgbW9yZSB3aWxkY2FyZCBjaGFyYWN0ZXJzICgqKVxuICogdGhhdCB3aWxsIGFsbG93IHdpbGRjYXJkIG1hdGNoaW5nIHdoZW4gaW50ZXJzZWN0aW5nIHdpdGhcbiAqIGFub3RoZXIgVG9rZW5TZXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciAtIFRoZSBzdHJpbmcgdG8gY3JlYXRlIGEgVG9rZW5TZXQgZnJvbS5cbiAqIEByZXR1cm5zIHtsdW5yLlRva2VuU2V0fVxuICovXG5sdW5yLlRva2VuU2V0LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBub2RlID0gbmV3IGx1bnIuVG9rZW5TZXQsXG4gICAgICByb290ID0gbm9kZVxuXG4gIC8qXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIGNoYXJhY3RlcnMgd2l0aGluIHRoZSBwYXNzZWQgc3RyaW5nXG4gICAqIGFwcGVuZGluZyBhIG5vZGUgZm9yIGVhY2ggY2hhcmFjdGVyLlxuICAgKlxuICAgKiBXaGVuIGEgd2lsZGNhcmQgY2hhcmFjdGVyIGlzIGZvdW5kIHRoZW4gYSBzZWxmXG4gICAqIHJlZmVyZW5jaW5nIGVkZ2UgaXMgaW50cm9kdWNlZCB0byBjb250aW51YWxseSBtYXRjaFxuICAgKiBhbnkgbnVtYmVyIG9mIGFueSBjaGFyYWN0ZXJzLlxuICAgKi9cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBjaGFyID0gc3RyW2ldLFxuICAgICAgICBmaW5hbCA9IChpID09IGxlbiAtIDEpXG5cbiAgICBpZiAoY2hhciA9PSBcIipcIikge1xuICAgICAgbm9kZS5lZGdlc1tjaGFyXSA9IG5vZGVcbiAgICAgIG5vZGUuZmluYWwgPSBmaW5hbFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBuZXh0ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgIG5leHQuZmluYWwgPSBmaW5hbFxuXG4gICAgICBub2RlLmVkZ2VzW2NoYXJdID0gbmV4dFxuICAgICAgbm9kZSA9IG5leHRcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcm9vdFxufVxuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgVG9rZW5TZXQgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzXG4gKiBjb250YWluZWQgd2l0aGluIHRoZSBUb2tlblNldC5cbiAqXG4gKiBUaGlzIGlzIG5vdCBpbnRlbmRlZCB0byBiZSB1c2VkIG9uIGEgVG9rZW5TZXQgdGhhdFxuICogY29udGFpbnMgd2lsZGNhcmRzLCBpbiB0aGVzZSBjYXNlcyB0aGUgcmVzdWx0cyBhcmVcbiAqIHVuZGVmaW5lZCBhbmQgYXJlIGxpa2VseSB0byBjYXVzZSBhbiBpbmZpbml0ZSBsb29wLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAqL1xubHVuci5Ub2tlblNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHdvcmRzID0gW11cblxuICB2YXIgc3RhY2sgPSBbe1xuICAgIHByZWZpeDogXCJcIixcbiAgICBub2RlOiB0aGlzXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmcmFtZSA9IHN0YWNrLnBvcCgpLFxuICAgICAgICBlZGdlcyA9IE9iamVjdC5rZXlzKGZyYW1lLm5vZGUuZWRnZXMpLFxuICAgICAgICBsZW4gPSBlZGdlcy5sZW5ndGhcblxuICAgIGlmIChmcmFtZS5ub2RlLmZpbmFsKSB7XG4gICAgICAvKiBJbiBTYWZhcmksIGF0IHRoaXMgcG9pbnQgdGhlIHByZWZpeCBpcyBzb21ldGltZXMgY29ycnVwdGVkLCBzZWU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vb2xpdmVybm4vbHVuci5qcy9pc3N1ZXMvMjc5IENhbGxpbmcgYW55XG4gICAgICAgKiBTdHJpbmcucHJvdG90eXBlIG1ldGhvZCBmb3JjZXMgU2FmYXJpIHRvIFwiY2FzdFwiIHRoaXMgc3RyaW5nIHRvIHdoYXRcbiAgICAgICAqIGl0J3Mgc3VwcG9zZWQgdG8gYmUsIGZpeGluZyB0aGUgYnVnLiAqL1xuICAgICAgZnJhbWUucHJlZml4LmNoYXJBdCgwKVxuICAgICAgd29yZHMucHVzaChmcmFtZS5wcmVmaXgpXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXVxuXG4gICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgcHJlZml4OiBmcmFtZS5wcmVmaXguY29uY2F0KGVkZ2UpLFxuICAgICAgICBub2RlOiBmcmFtZS5ub2RlLmVkZ2VzW2VkZ2VdXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3Jkc1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIFRva2VuU2V0LlxuICpcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYWxsb3cgVG9rZW5TZXRzIHRvIGJlIHVzZWQgYXMga2V5c1xuICogaW4gb2JqZWN0cywgbGFyZ2VseSB0byBhaWQgdGhlIGNvbnN0cnVjdGlvbiBhbmQgbWluaW1pc2F0aW9uXG4gKiBvZiBhIFRva2VuU2V0LiBBcyBzdWNoIGl0IGlzIG5vdCBkZXNpZ25lZCB0byBiZSBhIGh1bWFuXG4gKiBmcmllbmRseSByZXByZXNlbnRhdGlvbiBvZiB0aGUgVG9rZW5TZXQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xubHVuci5Ub2tlblNldC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIE5PVEU6IFVzaW5nIE9iamVjdC5rZXlzIGhlcmUgYXMgdGhpcy5lZGdlcyBpcyB2ZXJ5IGxpa2VseVxuICAvLyB0byBlbnRlciAnaGFzaC1tb2RlJyB3aXRoIG1hbnkga2V5cyBiZWluZyBhZGRlZFxuICAvL1xuICAvLyBhdm9pZGluZyBhIGZvci1pbiBsb29wIGhlcmUgYXMgaXQgbGVhZHMgdG8gdGhlIGZ1bmN0aW9uXG4gIC8vIGJlaW5nIGRlLW9wdGltaXNlZCAoYXQgbGVhc3QgaW4gVjgpLiBGcm9tIHNvbWUgc2ltcGxlXG4gIC8vIGJlbmNobWFya3MgdGhlIHBlcmZvcm1hbmNlIGlzIGNvbXBhcmFibGUsIGJ1dCBhbGxvd2luZ1xuICAvLyBWOCB0byBvcHRpbWl6ZSBtYXkgbWVhbiBlYXN5IHBlcmZvcm1hbmNlIHdpbnMgaW4gdGhlIGZ1dHVyZS5cblxuICBpZiAodGhpcy5fc3RyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0clxuICB9XG5cbiAgdmFyIHN0ciA9IHRoaXMuZmluYWwgPyAnMScgOiAnMCcsXG4gICAgICBsYWJlbHMgPSBPYmplY3Qua2V5cyh0aGlzLmVkZ2VzKS5zb3J0KCksXG4gICAgICBsZW4gPSBsYWJlbHMubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBsYWJlbCA9IGxhYmVsc1tpXSxcbiAgICAgICAgbm9kZSA9IHRoaXMuZWRnZXNbbGFiZWxdXG5cbiAgICBzdHIgPSBzdHIgKyBsYWJlbCArIG5vZGUuaWRcbiAgfVxuXG4gIHJldHVybiBzdHJcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFRva2VuU2V0IHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZlxuICogdGhpcyBUb2tlblNldCBhbmQgdGhlIHBhc3NlZCBUb2tlblNldC5cbiAqXG4gKiBUaGlzIGludGVyc2VjdGlvbiB3aWxsIHRha2UgaW50byBhY2NvdW50IGFueSB3aWxkY2FyZHNcbiAqIGNvbnRhaW5lZCB3aXRoaW4gdGhlIFRva2VuU2V0LlxuICpcbiAqIEBwYXJhbSB7bHVuci5Ub2tlblNldH0gYiAtIEFuIG90aGVyIFRva2VuU2V0IHRvIGludGVyc2VjdCB3aXRoLlxuICogQHJldHVybnMge2x1bnIuVG9rZW5TZXR9XG4gKi9cbmx1bnIuVG9rZW5TZXQucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChiKSB7XG4gIHZhciBvdXRwdXQgPSBuZXcgbHVuci5Ub2tlblNldCxcbiAgICAgIGZyYW1lID0gdW5kZWZpbmVkXG5cbiAgdmFyIHN0YWNrID0gW3tcbiAgICBxTm9kZTogYixcbiAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICBub2RlOiB0aGlzXG4gIH1dXG5cbiAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgIGZyYW1lID0gc3RhY2sucG9wKClcblxuICAgIC8vIE5PVEU6IEFzIHdpdGggdGhlICN0b1N0cmluZyBtZXRob2QsIHdlIGFyZSB1c2luZ1xuICAgIC8vIE9iamVjdC5rZXlzIGFuZCBhIGZvciBsb29wIGluc3RlYWQgb2YgYSBmb3ItaW4gbG9vcFxuICAgIC8vIGFzIGJvdGggb2YgdGhlc2Ugb2JqZWN0cyBlbnRlciAnaGFzaCcgbW9kZSwgY2F1c2luZ1xuICAgIC8vIHRoZSBmdW5jdGlvbiB0byBiZSBkZS1vcHRpbWlzZWQgaW4gVjhcbiAgICB2YXIgcUVkZ2VzID0gT2JqZWN0LmtleXMoZnJhbWUucU5vZGUuZWRnZXMpLFxuICAgICAgICBxTGVuID0gcUVkZ2VzLmxlbmd0aCxcbiAgICAgICAgbkVkZ2VzID0gT2JqZWN0LmtleXMoZnJhbWUubm9kZS5lZGdlcyksXG4gICAgICAgIG5MZW4gPSBuRWRnZXMubGVuZ3RoXG5cbiAgICBmb3IgKHZhciBxID0gMDsgcSA8IHFMZW47IHErKykge1xuICAgICAgdmFyIHFFZGdlID0gcUVkZ2VzW3FdXG5cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbkxlbjsgbisrKSB7XG4gICAgICAgIHZhciBuRWRnZSA9IG5FZGdlc1tuXVxuXG4gICAgICAgIGlmIChuRWRnZSA9PSBxRWRnZSB8fCBxRWRnZSA9PSAnKicpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IGZyYW1lLm5vZGUuZWRnZXNbbkVkZ2VdLFxuICAgICAgICAgICAgICBxTm9kZSA9IGZyYW1lLnFOb2RlLmVkZ2VzW3FFZGdlXSxcbiAgICAgICAgICAgICAgZmluYWwgPSBub2RlLmZpbmFsICYmIHFOb2RlLmZpbmFsLFxuICAgICAgICAgICAgICBuZXh0ID0gdW5kZWZpbmVkXG5cbiAgICAgICAgICBpZiAobkVkZ2UgaW4gZnJhbWUub3V0cHV0LmVkZ2VzKSB7XG4gICAgICAgICAgICAvLyBhbiBlZGdlIGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjcmVhdGUgYSBuZXcgbm9kZSwganVzdCBzZXQgdGhlIGZpbmFsaXR5XG4gICAgICAgICAgICAvLyBiaXQgdW5sZXNzIHRoaXMgbm9kZSBpcyBhbHJlYWR5IGZpbmFsXG4gICAgICAgICAgICBuZXh0ID0gZnJhbWUub3V0cHV0LmVkZ2VzW25FZGdlXVxuICAgICAgICAgICAgbmV4dC5maW5hbCA9IG5leHQuZmluYWwgfHwgZmluYWxcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBubyBlZGdlIGV4aXN0cyB5ZXQsIG11c3QgY3JlYXRlIG9uZVxuICAgICAgICAgICAgLy8gc2V0IHRoZSBmaW5hbGl0eSBiaXQgYW5kIGluc2VydCBpdFxuICAgICAgICAgICAgLy8gaW50byB0aGUgb3V0cHV0XG4gICAgICAgICAgICBuZXh0ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgICAgICAgICAgIG5leHQuZmluYWwgPSBmaW5hbFxuICAgICAgICAgICAgZnJhbWUub3V0cHV0LmVkZ2VzW25FZGdlXSA9IG5leHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICAgIHFOb2RlOiBxTm9kZSxcbiAgICAgICAgICAgIG91dHB1dDogbmV4dCxcbiAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxubHVuci5Ub2tlblNldC5CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnByZXZpb3VzV29yZCA9IFwiXCJcbiAgdGhpcy5yb290ID0gbmV3IGx1bnIuVG9rZW5TZXRcbiAgdGhpcy51bmNoZWNrZWROb2RlcyA9IFtdXG4gIHRoaXMubWluaW1pemVkTm9kZXMgPSB7fVxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uICh3b3JkKSB7XG4gIHZhciBub2RlLFxuICAgICAgY29tbW9uUHJlZml4ID0gMFxuXG4gIGlmICh3b3JkIDwgdGhpcy5wcmV2aW91c1dvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IgKFwiT3V0IG9mIG9yZGVyIHdvcmQgaW5zZXJ0aW9uXCIpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmQubGVuZ3RoICYmIGkgPCB0aGlzLnByZXZpb3VzV29yZC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh3b3JkW2ldICE9IHRoaXMucHJldmlvdXNXb3JkW2ldKSBicmVha1xuICAgIGNvbW1vblByZWZpeCsrXG4gIH1cblxuICB0aGlzLm1pbmltaXplKGNvbW1vblByZWZpeClcblxuICBpZiAodGhpcy51bmNoZWNrZWROb2Rlcy5sZW5ndGggPT0gMCkge1xuICAgIG5vZGUgPSB0aGlzLnJvb3RcbiAgfSBlbHNlIHtcbiAgICBub2RlID0gdGhpcy51bmNoZWNrZWROb2Rlc1t0aGlzLnVuY2hlY2tlZE5vZGVzLmxlbmd0aCAtIDFdLmNoaWxkXG4gIH1cblxuICBmb3IgKHZhciBpID0gY29tbW9uUHJlZml4OyBpIDwgd29yZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5ldyBsdW5yLlRva2VuU2V0LFxuICAgICAgICBjaGFyID0gd29yZFtpXVxuXG4gICAgbm9kZS5lZGdlc1tjaGFyXSA9IG5leHROb2RlXG5cbiAgICB0aGlzLnVuY2hlY2tlZE5vZGVzLnB1c2goe1xuICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgY2hhcjogY2hhcixcbiAgICAgIGNoaWxkOiBuZXh0Tm9kZVxuICAgIH0pXG5cbiAgICBub2RlID0gbmV4dE5vZGVcbiAgfVxuXG4gIG5vZGUuZmluYWwgPSB0cnVlXG4gIHRoaXMucHJldmlvdXNXb3JkID0gd29yZFxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5taW5pbWl6ZSgwKVxufVxuXG5sdW5yLlRva2VuU2V0LkJ1aWxkZXIucHJvdG90eXBlLm1pbmltaXplID0gZnVuY3Rpb24gKGRvd25Ubykge1xuICBmb3IgKHZhciBpID0gdGhpcy51bmNoZWNrZWROb2Rlcy5sZW5ndGggLSAxOyBpID49IGRvd25UbzsgaS0tKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnVuY2hlY2tlZE5vZGVzW2ldLFxuICAgICAgICBjaGlsZEtleSA9IG5vZGUuY2hpbGQudG9TdHJpbmcoKVxuXG4gICAgaWYgKGNoaWxkS2V5IGluIHRoaXMubWluaW1pemVkTm9kZXMpIHtcbiAgICAgIG5vZGUucGFyZW50LmVkZ2VzW25vZGUuY2hhcl0gPSB0aGlzLm1pbmltaXplZE5vZGVzW2NoaWxkS2V5XVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYWNoZSB0aGUga2V5IGZvciB0aGlzIG5vZGUgc2luY2VcbiAgICAgIC8vIHdlIGtub3cgaXQgY2FuJ3QgY2hhbmdlIGFueW1vcmVcbiAgICAgIG5vZGUuY2hpbGQuX3N0ciA9IGNoaWxkS2V5XG5cbiAgICAgIHRoaXMubWluaW1pemVkTm9kZXNbY2hpbGRLZXldID0gbm9kZS5jaGlsZFxuICAgIH1cblxuICAgIHRoaXMudW5jaGVja2VkTm9kZXMucG9wKClcbiAgfVxufVxuLyohXG4gKiBsdW5yLkluZGV4XG4gKiBDb3B5cmlnaHQgKEMpIDIwMjAgT2xpdmVyIE5pZ2h0aW5nYWxlXG4gKi9cblxuLyoqXG4gKiBBbiBpbmRleCBjb250YWlucyB0aGUgYnVpbHQgaW5kZXggb2YgYWxsIGRvY3VtZW50cyBhbmQgcHJvdmlkZXMgYSBxdWVyeSBpbnRlcmZhY2VcbiAqIHRvIHRoZSBpbmRleC5cbiAqXG4gKiBVc3VhbGx5IGluc3RhbmNlcyBvZiBsdW5yLkluZGV4IHdpbGwgbm90IGJlIGNyZWF0ZWQgdXNpbmcgdGhpcyBjb25zdHJ1Y3RvciwgaW5zdGVhZFxuICogbHVuci5CdWlsZGVyIHNob3VsZCBiZSB1c2VkIHRvIGNvbnN0cnVjdCBuZXcgaW5kZXhlcywgb3IgbHVuci5JbmRleC5sb2FkIHNob3VsZCBiZVxuICogdXNlZCB0byBsb2FkIHByZXZpb3VzbHkgYnVpbHQgYW5kIHNlcmlhbGl6ZWQgaW5kZXhlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyAtIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBidWlsdCBzZWFyY2ggaW5kZXguXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMuaW52ZXJ0ZWRJbmRleCAtIEFuIGluZGV4IG9mIHRlcm0vZmllbGQgdG8gZG9jdW1lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBsdW5yLlZlY3Rvcj59IGF0dHJzLmZpZWxkVmVjdG9ycyAtIEZpZWxkIHZlY3RvcnNcbiAqIEBwYXJhbSB7bHVuci5Ub2tlblNldH0gYXR0cnMudG9rZW5TZXQgLSBBbiBzZXQgb2YgYWxsIGNvcnB1cyB0b2tlbnMuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhdHRycy5maWVsZHMgLSBUaGUgbmFtZXMgb2YgaW5kZXhlZCBkb2N1bWVudCBmaWVsZHMuXG4gKiBAcGFyYW0ge2x1bnIuUGlwZWxpbmV9IGF0dHJzLnBpcGVsaW5lIC0gVGhlIHBpcGVsaW5lIHRvIHVzZSBmb3Igc2VhcmNoIHRlcm1zLlxuICovXG5sdW5yLkluZGV4ID0gZnVuY3Rpb24gKGF0dHJzKSB7XG4gIHRoaXMuaW52ZXJ0ZWRJbmRleCA9IGF0dHJzLmludmVydGVkSW5kZXhcbiAgdGhpcy5maWVsZFZlY3RvcnMgPSBhdHRycy5maWVsZFZlY3RvcnNcbiAgdGhpcy50b2tlblNldCA9IGF0dHJzLnRva2VuU2V0XG4gIHRoaXMuZmllbGRzID0gYXR0cnMuZmllbGRzXG4gIHRoaXMucGlwZWxpbmUgPSBhdHRycy5waXBlbGluZVxufVxuXG4vKipcbiAqIEEgcmVzdWx0IGNvbnRhaW5zIGRldGFpbHMgb2YgYSBkb2N1bWVudCBtYXRjaGluZyBhIHNlYXJjaCBxdWVyeS5cbiAqIEB0eXBlZGVmIHtPYmplY3R9IGx1bnIuSW5kZXh+UmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVmIC0gVGhlIHJlZmVyZW5jZSBvZiB0aGUgZG9jdW1lbnQgdGhpcyByZXN1bHQgcmVwcmVzZW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzY29yZSAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgaG93IHNpbWlsYXIgdGhpcyBkb2N1bWVudCBpcyB0byB0aGUgcXVlcnkuXG4gKiBAcHJvcGVydHkge2x1bnIuTWF0Y2hEYXRhfSBtYXRjaERhdGEgLSBDb250YWlucyBtZXRhZGF0YSBhYm91dCB0aGlzIG1hdGNoIGluY2x1ZGluZyB3aGljaCB0ZXJtKHMpIGNhdXNlZCB0aGUgbWF0Y2guXG4gKi9cblxuLyoqXG4gKiBBbHRob3VnaCBsdW5yIHByb3ZpZGVzIHRoZSBhYmlsaXR5IHRvIGNyZWF0ZSBxdWVyaWVzIHVzaW5nIGx1bnIuUXVlcnksIGl0IGFsc28gcHJvdmlkZXMgYSBzaW1wbGVcbiAqIHF1ZXJ5IGxhbmd1YWdlIHdoaWNoIGl0c2VsZiBpcyBwYXJzZWQgaW50byBhbiBpbnN0YW5jZSBvZiBsdW5yLlF1ZXJ5LlxuICpcbiAqIEZvciBwcm9ncmFtbWF0aWNhbGx5IGJ1aWxkaW5nIHF1ZXJpZXMgaXQgaXMgYWR2aXNlZCB0byBkaXJlY3RseSB1c2UgbHVuci5RdWVyeSwgdGhlIHF1ZXJ5IGxhbmd1YWdlXG4gKiBpcyBiZXN0IHVzZWQgZm9yIGh1bWFuIGVudGVyZWQgdGV4dCByYXRoZXIgdGhhbiBwcm9ncmFtIGdlbmVyYXRlZCB0ZXh0LlxuICpcbiAqIEF0IGl0cyBzaW1wbGVzdCBxdWVyaWVzIGNhbiBqdXN0IGJlIGEgc2luZ2xlIHRlcm0sIGUuZy4gYGhlbGxvYCwgbXVsdGlwbGUgdGVybXMgYXJlIGFsc28gc3VwcG9ydGVkXG4gKiBhbmQgd2lsbCBiZSBjb21iaW5lZCB3aXRoIE9SLCBlLmcgYGhlbGxvIHdvcmxkYCB3aWxsIG1hdGNoIGRvY3VtZW50cyB0aGF0IGNvbnRhaW4gZWl0aGVyICdoZWxsbydcbiAqIG9yICd3b3JsZCcsIHRob3VnaCB0aG9zZSB0aGF0IGNvbnRhaW4gYm90aCB3aWxsIHJhbmsgaGlnaGVyIGluIHRoZSByZXN1bHRzLlxuICpcbiAqIFdpbGRjYXJkcyBjYW4gYmUgaW5jbHVkZWQgaW4gdGVybXMgdG8gbWF0Y2ggb25lIG9yIG1vcmUgdW5zcGVjaWZpZWQgY2hhcmFjdGVycywgdGhlc2Ugd2lsZGNhcmRzIGNhblxuICogYmUgaW5zZXJ0ZWQgYW55d2hlcmUgd2l0aGluIHRoZSB0ZXJtLCBhbmQgbW9yZSB0aGFuIG9uZSB3aWxkY2FyZCBjYW4gZXhpc3QgaW4gYSBzaW5nbGUgdGVybS4gQWRkaW5nXG4gKiB3aWxkY2FyZHMgd2lsbCBpbmNyZWFzZSB0aGUgbnVtYmVyIG9mIGRvY3VtZW50cyB0aGF0IHdpbGwgYmUgZm91bmQgYnV0IGNhbiBhbHNvIGhhdmUgYSBuZWdhdGl2ZVxuICogaW1wYWN0IG9uIHF1ZXJ5IHBlcmZvcm1hbmNlLCBlc3BlY2lhbGx5IHdpdGggd2lsZGNhcmRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSB0ZXJtLlxuICpcbiAqIFRlcm1zIGNhbiBiZSByZXN0cmljdGVkIHRvIHNwZWNpZmljIGZpZWxkcywgZS5nLiBgdGl0bGU6aGVsbG9gLCBvbmx5IGRvY3VtZW50cyB3aXRoIHRoZSB0ZXJtXG4gKiBoZWxsbyBpbiB0aGUgdGl0bGUgZmllbGQgd2lsbCBtYXRjaCB0aGlzIHF1ZXJ5LiBVc2luZyBhIGZpZWxkIG5vdCBwcmVzZW50IGluIHRoZSBpbmRleCB3aWxsIGxlYWRcbiAqIHRvIGFuIGVycm9yIGJlaW5nIHRocm93bi5cbiAqXG4gKiBNb2RpZmllcnMgY2FuIGFsc28gYmUgYWRkZWQgdG8gdGVybXMsIGx1bnIgc3VwcG9ydHMgZWRpdCBkaXN0YW5jZSBhbmQgYm9vc3QgbW9kaWZpZXJzIG9uIHRlcm1zLiBBIHRlcm1cbiAqIGJvb3N0IHdpbGwgbWFrZSBkb2N1bWVudHMgbWF0Y2hpbmcgdGhhdCB0ZXJtIHNjb3JlIGhpZ2hlciwgZS5nLiBgZm9vXjVgLiBFZGl0IGRpc3RhbmNlIGlzIGFsc28gc3VwcG9ydGVkXG4gKiB0byBwcm92aWRlIGZ1enp5IG1hdGNoaW5nLCBlLmcuICdoZWxsb34yJyB3aWxsIG1hdGNoIGRvY3VtZW50cyB3aXRoIGhlbGxvIHdpdGggYW4gZWRpdCBkaXN0YW5jZSBvZiAyLlxuICogQXZvaWQgbGFyZ2UgdmFsdWVzIGZvciBlZGl0IGRpc3RhbmNlIHRvIGltcHJvdmUgcXVlcnkgcGVyZm9ybWFuY2UuXG4gKlxuICogRWFjaCB0ZXJtIGFsc28gc3VwcG9ydHMgYSBwcmVzZW5jZSBtb2RpZmllci4gQnkgZGVmYXVsdCBhIHRlcm0ncyBwcmVzZW5jZSBpbiBkb2N1bWVudCBpcyBvcHRpb25hbCwgaG93ZXZlclxuICogdGhpcyBjYW4gYmUgY2hhbmdlZCB0byBlaXRoZXIgcmVxdWlyZWQgb3IgcHJvaGliaXRlZC4gRm9yIGEgdGVybSdzIHByZXNlbmNlIHRvIGJlIHJlcXVpcmVkIGluIGEgZG9jdW1lbnQgdGhlXG4gKiB0ZXJtIHNob3VsZCBiZSBwcmVmaXhlZCB3aXRoIGEgJysnLCBlLmcuIGArZm9vIGJhcmAgaXMgYSBzZWFyY2ggZm9yIGRvY3VtZW50cyB0aGF0IG11c3QgY29udGFpbiAnZm9vJyBhbmRcbiAqIG9wdGlvbmFsbHkgY29udGFpbiAnYmFyJy4gQ29udmVyc2VseSBhIGxlYWRpbmcgJy0nIHNldHMgdGhlIHRlcm1zIHByZXNlbmNlIHRvIHByb2hpYml0ZWQsIGkuZS4gaXQgbXVzdCBub3RcbiAqIGFwcGVhciBpbiBhIGRvY3VtZW50LCBlLmcuIGAtZm9vIGJhcmAgaXMgYSBzZWFyY2ggZm9yIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluICdmb28nIGJ1dCBtYXkgY29udGFpbiAnYmFyJy5cbiAqXG4gKiBUbyBlc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoZSBiYWNrc2xhc2ggY2hhcmFjdGVyICdcXCcgY2FuIGJlIHVzZWQsIHRoaXMgYWxsb3dzIHNlYXJjaGVzIHRvIGluY2x1ZGVcbiAqIGNoYXJhY3RlcnMgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBjb25zaWRlcmVkIG1vZGlmaWVycywgZS5nLiBgZm9vXFx+MmAgd2lsbCBzZWFyY2ggZm9yIGEgdGVybSBcImZvb34yXCIgaW5zdGVhZFxuICogb2YgYXR0ZW1wdGluZyB0byBhcHBseSBhIGJvb3N0IG9mIDIgdG8gdGhlIHNlYXJjaCB0ZXJtIFwiZm9vXCIuXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ30gbHVuci5JbmRleH5RdWVyeVN0cmluZ1xuICogQGV4YW1wbGUgPGNhcHRpb24+U2ltcGxlIHNpbmdsZSB0ZXJtIHF1ZXJ5PC9jYXB0aW9uPlxuICogaGVsbG9cbiAqIEBleGFtcGxlIDxjYXB0aW9uPk11bHRpcGxlIHRlcm0gcXVlcnk8L2NhcHRpb24+XG4gKiBoZWxsbyB3b3JsZFxuICogQGV4YW1wbGUgPGNhcHRpb24+dGVybSBzY29wZWQgdG8gYSBmaWVsZDwvY2FwdGlvbj5cbiAqIHRpdGxlOmhlbGxvXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj50ZXJtIHdpdGggYSBib29zdCBvZiAxMDwvY2FwdGlvbj5cbiAqIGhlbGxvXjEwXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj50ZXJtIHdpdGggYW4gZWRpdCBkaXN0YW5jZSBvZiAyPC9jYXB0aW9uPlxuICogaGVsbG9+MlxuICogQGV4YW1wbGUgPGNhcHRpb24+dGVybXMgd2l0aCBwcmVzZW5jZSBtb2RpZmllcnM8L2NhcHRpb24+XG4gKiAtZm9vICtiYXIgYmF6XG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNlYXJjaCBhZ2FpbnN0IHRoZSBpbmRleCB1c2luZyBsdW5yIHF1ZXJ5IHN5bnRheC5cbiAqXG4gKiBSZXN1bHRzIHdpbGwgYmUgcmV0dXJuZWQgc29ydGVkIGJ5IHRoZWlyIHNjb3JlLCB0aGUgbW9zdCByZWxldmFudCByZXN1bHRzXG4gKiB3aWxsIGJlIHJldHVybmVkIGZpcnN0LiAgRm9yIGRldGFpbHMgb24gaG93IHRoZSBzY29yZSBpcyBjYWxjdWxhdGVkLCBwbGVhc2Ugc2VlXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vbHVucmpzLmNvbS9ndWlkZXMvc2VhcmNoaW5nLmh0bWwjc2NvcmluZ3xndWlkZX0uXG4gKlxuICogRm9yIG1vcmUgcHJvZ3JhbW1hdGljIHF1ZXJ5aW5nIHVzZSBsdW5yLkluZGV4I3F1ZXJ5LlxuICpcbiAqIEBwYXJhbSB7bHVuci5JbmRleH5RdWVyeVN0cmluZ30gcXVlcnlTdHJpbmcgLSBBIHN0cmluZyBjb250YWluaW5nIGEgbHVuciBxdWVyeS5cbiAqIEB0aHJvd3Mge2x1bnIuUXVlcnlQYXJzZUVycm9yfSBJZiB0aGUgcGFzc2VkIHF1ZXJ5IHN0cmluZyBjYW5ub3QgYmUgcGFyc2VkLlxuICogQHJldHVybnMge2x1bnIuSW5kZXh+UmVzdWx0W119XG4gKi9cbmx1bnIuSW5kZXgucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeVN0cmluZykge1xuICByZXR1cm4gdGhpcy5xdWVyeShmdW5jdGlvbiAocXVlcnkpIHtcbiAgICB2YXIgcGFyc2VyID0gbmV3IGx1bnIuUXVlcnlQYXJzZXIocXVlcnlTdHJpbmcsIHF1ZXJ5KVxuICAgIHBhcnNlci5wYXJzZSgpXG4gIH0pXG59XG5cbi8qKlxuICogQSBxdWVyeSBidWlsZGVyIGNhbGxiYWNrIHByb3ZpZGVzIGEgcXVlcnkgb2JqZWN0IHRvIGJlIHVzZWQgdG8gZXhwcmVzc1xuICogdGhlIHF1ZXJ5IHRvIHBlcmZvcm0gb24gdGhlIGluZGV4LlxuICpcbiAqIEBjYWxsYmFjayBsdW5yLkluZGV4fnF1ZXJ5QnVpbGRlclxuICogQHBhcmFtIHtsdW5yLlF1ZXJ5fSBxdWVyeSAtIFRoZSBxdWVyeSBvYmplY3QgdG8gYnVpbGQgdXAuXG4gKiBAdGhpcyBsdW5yLlF1ZXJ5XG4gKi9cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHF1ZXJ5IGFnYWluc3QgdGhlIGluZGV4IHVzaW5nIHRoZSB5aWVsZGVkIGx1bnIuUXVlcnkgb2JqZWN0LlxuICpcbiAqIElmIHBlcmZvcm1pbmcgcHJvZ3JhbW1hdGljIHF1ZXJpZXMgYWdhaW5zdCB0aGUgaW5kZXgsIHRoaXMgbWV0aG9kIGlzIHByZWZlcnJlZFxuICogb3ZlciBsdW5yLkluZGV4I3NlYXJjaCBzbyBhcyB0byBhdm9pZCB0aGUgYWRkaXRpb25hbCBxdWVyeSBwYXJzaW5nIG92ZXJoZWFkLlxuICpcbiAqIEEgcXVlcnkgb2JqZWN0IGlzIHlpZWxkZWQgdG8gdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCBiZSB1c2VkIHRvXG4gKiBleHByZXNzIHRoZSBxdWVyeSB0byBiZSBydW4gYWdhaW5zdCB0aGUgaW5kZXguXG4gKlxuICogTm90ZSB0aGF0IGFsdGhvdWdoIHRoaXMgZnVuY3Rpb24gdGFrZXMgYSBjYWxsYmFjayBwYXJhbWV0ZXIgaXQgaXMgX25vdF8gYW5cbiAqIGFzeW5jaHJvbm91cyBvcGVyYXRpb24sIHRoZSBjYWxsYmFjayBpcyBqdXN0IHlpZWxkZWQgYSBxdWVyeSBvYmplY3QgdG8gYmVcbiAqIGN1c3RvbWl6ZWQuXG4gKlxuICogQHBhcmFtIHtsdW5yLkluZGV4fnF1ZXJ5QnVpbGRlcn0gZm4gLSBBIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBidWlsZCB0aGUgcXVlcnkuXG4gKiBAcmV0dXJucyB7bHVuci5JbmRleH5SZXN1bHRbXX1cbiAqL1xubHVuci5JbmRleC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgLy8gZm9yIGVhY2ggcXVlcnkgY2xhdXNlXG4gIC8vICogcHJvY2VzcyB0ZXJtc1xuICAvLyAqIGV4cGFuZCB0ZXJtcyBmcm9tIHRva2VuIHNldFxuICAvLyAqIGZpbmQgbWF0Y2hpbmcgZG9jdW1lbnRzIGFuZCBtZXRhZGF0YVxuICAvLyAqIGdldCBkb2N1bWVudCB2ZWN0b3JzXG4gIC8vICogc2NvcmUgZG9jdW1lbnRzXG5cbiAgdmFyIHF1ZXJ5ID0gbmV3IGx1bnIuUXVlcnkodGhpcy5maWVsZHMpLFxuICAgICAgbWF0Y2hpbmdGaWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgcXVlcnlWZWN0b3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIHRlcm1GaWVsZENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIHJlcXVpcmVkTWF0Y2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBwcm9oaWJpdGVkTWF0Y2hlcyA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAvKlxuICAgKiBUbyBzdXBwb3J0IGZpZWxkIGxldmVsIGJvb3N0cyBhIHF1ZXJ5IHZlY3RvciBpcyBjcmVhdGVkIHBlclxuICAgKiBmaWVsZC4gQW4gZW1wdHkgdmVjdG9yIGlzIGVhZ2VybHkgY3JlYXRlZCB0byBzdXBwb3J0IG5lZ2F0ZWRcbiAgICogcXVlcmllcy5cbiAgICovXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICBxdWVyeVZlY3RvcnNbdGhpcy5maWVsZHNbaV1dID0gbmV3IGx1bnIuVmVjdG9yXG4gIH1cblxuICBmbi5jYWxsKHF1ZXJ5LCBxdWVyeSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJ5LmNsYXVzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvKlxuICAgICAqIFVubGVzcyB0aGUgcGlwZWxpbmUgaGFzIGJlZW4gZGlzYWJsZWQgZm9yIHRoaXMgdGVybSwgd2hpY2ggaXNcbiAgICAgKiB0aGUgY2FzZSBmb3IgdGVybXMgd2l0aCB3aWxkY2FyZHMsIHdlIG5lZWQgdG8gcGFzcyB0aGUgY2xhdXNlXG4gICAgICogdGVybSB0aHJvdWdoIHRoZSBzZWFyY2ggcGlwZWxpbmUuIEEgcGlwZWxpbmUgcmV0dXJucyBhbiBhcnJheVxuICAgICAqIG9mIHByb2Nlc3NlZCB0ZXJtcy4gUGlwZWxpbmUgZnVuY3Rpb25zIG1heSBleHBhbmQgdGhlIHBhc3NlZFxuICAgICAqIHRlcm0sIHdoaWNoIG1lYW5zIHdlIG1heSBlbmQgdXAgcGVyZm9ybWluZyBtdWx0aXBsZSBpbmRleCBsb29rdXBzXG4gICAgICogZm9yIGEgc2luZ2xlIHF1ZXJ5IHRlcm0uXG4gICAgICovXG4gICAgdmFyIGNsYXVzZSA9IHF1ZXJ5LmNsYXVzZXNbaV0sXG4gICAgICAgIHRlcm1zID0gbnVsbCxcbiAgICAgICAgY2xhdXNlTWF0Y2hlcyA9IGx1bnIuU2V0LmVtcHR5XG5cbiAgICBpZiAoY2xhdXNlLnVzZVBpcGVsaW5lKSB7XG4gICAgICB0ZXJtcyA9IHRoaXMucGlwZWxpbmUucnVuU3RyaW5nKGNsYXVzZS50ZXJtLCB7XG4gICAgICAgIGZpZWxkczogY2xhdXNlLmZpZWxkc1xuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGVybXMgPSBbY2xhdXNlLnRlcm1dXG4gICAgfVxuXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCB0ZXJtcy5sZW5ndGg7IG0rKykge1xuICAgICAgdmFyIHRlcm0gPSB0ZXJtc1ttXVxuXG4gICAgICAvKlxuICAgICAgICogRWFjaCB0ZXJtIHJldHVybmVkIGZyb20gdGhlIHBpcGVsaW5lIG5lZWRzIHRvIHVzZSB0aGUgc2FtZSBxdWVyeVxuICAgICAgICogY2xhdXNlIG9iamVjdCwgZS5nLiB0aGUgc2FtZSBib29zdCBhbmQgb3IgZWRpdCBkaXN0YW5jZS4gVGhlXG4gICAgICAgKiBzaW1wbGVzdCB3YXkgdG8gZG8gdGhpcyBpcyB0byByZS11c2UgdGhlIGNsYXVzZSBvYmplY3QgYnV0IG11dGF0ZVxuICAgICAgICogaXRzIHRlcm0gcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIGNsYXVzZS50ZXJtID0gdGVybVxuXG4gICAgICAvKlxuICAgICAgICogRnJvbSB0aGUgdGVybSBpbiB0aGUgY2xhdXNlIHdlIGNyZWF0ZSBhIHRva2VuIHNldCB3aGljaCB3aWxsIHRoZW5cbiAgICAgICAqIGJlIHVzZWQgdG8gaW50ZXJzZWN0IHRoZSBpbmRleGVzIHRva2VuIHNldCB0byBnZXQgYSBsaXN0IG9mIHRlcm1zXG4gICAgICAgKiB0byBsb29rdXAgaW4gdGhlIGludmVydGVkIGluZGV4XG4gICAgICAgKi9cbiAgICAgIHZhciB0ZXJtVG9rZW5TZXQgPSBsdW5yLlRva2VuU2V0LmZyb21DbGF1c2UoY2xhdXNlKSxcbiAgICAgICAgICBleHBhbmRlZFRlcm1zID0gdGhpcy50b2tlblNldC5pbnRlcnNlY3QodGVybVRva2VuU2V0KS50b0FycmF5KClcblxuICAgICAgLypcbiAgICAgICAqIElmIGEgdGVybSBtYXJrZWQgYXMgcmVxdWlyZWQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHRva2VuU2V0IGl0IGlzXG4gICAgICAgKiBpbXBvc3NpYmxlIGZvciB0aGUgc2VhcmNoIHRvIHJldHVybiBhbnkgbWF0Y2hlcy4gV2Ugc2V0IGFsbCB0aGUgZmllbGRcbiAgICAgICAqIHNjb3BlZCByZXF1aXJlZCBtYXRjaGVzIHNldCB0byBlbXB0eSBhbmQgc3RvcCBleGFtaW5pbmcgYW55IGZ1cnRoZXJcbiAgICAgICAqIGNsYXVzZXMuXG4gICAgICAgKi9cbiAgICAgIGlmIChleHBhbmRlZFRlcm1zLmxlbmd0aCA9PT0gMCAmJiBjbGF1c2UucHJlc2VuY2UgPT09IGx1bnIuUXVlcnkucHJlc2VuY2UuUkVRVUlSRUQpIHtcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gY2xhdXNlLmZpZWxkc1trXVxuICAgICAgICAgIHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0gPSBsdW5yLlNldC5lbXB0eVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHBhbmRlZFRlcm1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIEZvciBlYWNoIHRlcm0gZ2V0IHRoZSBwb3N0aW5nIGFuZCB0ZXJtSW5kZXgsIHRoaXMgaXMgcmVxdWlyZWQgZm9yXG4gICAgICAgICAqIGJ1aWxkaW5nIHRoZSBxdWVyeSB2ZWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZXhwYW5kZWRUZXJtID0gZXhwYW5kZWRUZXJtc1tqXSxcbiAgICAgICAgICAgIHBvc3RpbmcgPSB0aGlzLmludmVydGVkSW5kZXhbZXhwYW5kZWRUZXJtXSxcbiAgICAgICAgICAgIHRlcm1JbmRleCA9IHBvc3RpbmcuX2luZGV4XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgKiBGb3IgZWFjaCBmaWVsZCB0aGF0IHRoaXMgcXVlcnkgdGVybSBpcyBzY29wZWQgYnkgKGJ5IGRlZmF1bHRcbiAgICAgICAgICAgKiBhbGwgZmllbGRzIGFyZSBpbiBzY29wZSkgd2UgbmVlZCB0byBnZXQgYWxsIHRoZSBkb2N1bWVudCByZWZzXG4gICAgICAgICAgICogdGhhdCBoYXZlIHRoaXMgdGVybSBpbiB0aGF0IGZpZWxkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhlIHBvc3RpbmcgaXMgdGhlIGVudHJ5IGluIHRoZSBpbnZlcnRlZEluZGV4IGZvciB0aGUgbWF0Y2hpbmdcbiAgICAgICAgICAgKiB0ZXJtIGZyb20gYWJvdmUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgdmFyIGZpZWxkID0gY2xhdXNlLmZpZWxkc1trXSxcbiAgICAgICAgICAgICAgZmllbGRQb3N0aW5nID0gcG9zdGluZ1tmaWVsZF0sXG4gICAgICAgICAgICAgIG1hdGNoaW5nRG9jdW1lbnRSZWZzID0gT2JqZWN0LmtleXMoZmllbGRQb3N0aW5nKSxcbiAgICAgICAgICAgICAgdGVybUZpZWxkID0gZXhwYW5kZWRUZXJtICsgXCIvXCIgKyBmaWVsZCxcbiAgICAgICAgICAgICAgbWF0Y2hpbmdEb2N1bWVudHNTZXQgPSBuZXcgbHVuci5TZXQobWF0Y2hpbmdEb2N1bWVudFJlZnMpXG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIGlmIHRoZSBwcmVzZW5jZSBvZiB0aGlzIHRlcm0gaXMgcmVxdWlyZWQgZW5zdXJlIHRoYXQgdGhlIG1hdGNoaW5nXG4gICAgICAgICAgICogZG9jdW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgc2V0IG9mIHJlcXVpcmVkIG1hdGNoZXMgZm9yIHRoaXMgY2xhdXNlLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICovXG4gICAgICAgICAgaWYgKGNsYXVzZS5wcmVzZW5jZSA9PSBsdW5yLlF1ZXJ5LnByZXNlbmNlLlJFUVVJUkVEKSB7XG4gICAgICAgICAgICBjbGF1c2VNYXRjaGVzID0gY2xhdXNlTWF0Y2hlcy51bmlvbihtYXRjaGluZ0RvY3VtZW50c1NldClcblxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXF1aXJlZE1hdGNoZXNbZmllbGRdID0gbHVuci5TZXQuY29tcGxldGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKlxuICAgICAgICAgICAqIGlmIHRoZSBwcmVzZW5jZSBvZiB0aGlzIHRlcm0gaXMgcHJvaGliaXRlZCBlbnN1cmUgdGhhdCB0aGUgbWF0Y2hpbmdcbiAgICAgICAgICAgKiBkb2N1bWVudHMgYXJlIGFkZGVkIHRvIHRoZSBzZXQgb2YgcHJvaGliaXRlZCBtYXRjaGVzIGZvciB0aGlzIGZpZWxkLFxuICAgICAgICAgICAqIGNyZWF0aW5nIHRoYXQgc2V0IGlmIGl0IGRvZXMgbm90IHlldCBleGlzdC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAoY2xhdXNlLnByZXNlbmNlID09IGx1bnIuUXVlcnkucHJlc2VuY2UuUFJPSElCSVRFRCkge1xuICAgICAgICAgICAgaWYgKHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9IGx1bnIuU2V0LmVtcHR5XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXSA9IHByb2hpYml0ZWRNYXRjaGVzW2ZpZWxkXS51bmlvbihtYXRjaGluZ0RvY3VtZW50c1NldClcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFByb2hpYml0ZWQgbWF0Y2hlcyBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIHF1ZXJ5IHZlY3RvciB1c2VkIGZvclxuICAgICAgICAgICAgICogc2ltaWxhcml0eSBzY29yaW5nIGFuZCBubyBtZXRhZGF0YSBzaG91bGQgYmUgZXh0cmFjdGVkIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICAgKiB0byB0aGUgbmV4dCBmaWVsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qXG4gICAgICAgICAgICogVGhlIHF1ZXJ5IGZpZWxkIHZlY3RvciBpcyBwb3B1bGF0ZWQgdXNpbmcgdGhlIHRlcm1JbmRleCBmb3VuZCBmb3JcbiAgICAgICAgICAgKiB0aGUgdGVybSBhbmQgYSB1bml0IHZhbHVlIHdpdGggdGhlIGFwcHJvcHJpYXRlIGJvb3N0IGFwcGxpZWQuXG4gICAgICAgICAgICogVXNpbmcgdXBzZXJ0IGJlY2F1c2UgdGhlcmUgY291bGQgYWxyZWFkeSBiZSBhbiBlbnRyeSBpbiB0aGUgdmVjdG9yXG4gICAgICAgICAgICogZm9yIHRoZSB0ZXJtIHdlIGFyZSB3b3JraW5nIHdpdGguIEluIHRoYXQgY2FzZSB3ZSBqdXN0IGFkZCB0aGUgc2NvcmVzXG4gICAgICAgICAgICogdG9nZXRoZXIuXG4gICAgICAgICAgICovXG4gICAgICAgICAgcXVlcnlWZWN0b3JzW2ZpZWxkXS51cHNlcnQodGVybUluZGV4LCBjbGF1c2UuYm9vc3QsIGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhICsgYiB9KVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgd2UndmUgYWxyZWFkeSBzZWVuIHRoaXMgdGVybSwgZmllbGQgY29tYm8gdGhlbiB3ZSd2ZSBhbHJlYWR5IGNvbGxlY3RlZFxuICAgICAgICAgICAqIHRoZSBtYXRjaGluZyBkb2N1bWVudHMgYW5kIG1ldGFkYXRhLCBubyBuZWVkIHRvIGdvIHRocm91Z2ggYWxsIHRoYXQgYWdhaW5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGVybUZpZWxkQ2FjaGVbdGVybUZpZWxkXSkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IG1hdGNoaW5nRG9jdW1lbnRSZWZzLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogQWxsIG1ldGFkYXRhIGZvciB0aGlzIHRlcm0vZmllbGQvZG9jdW1lbnQgdHJpcGxlXG4gICAgICAgICAgICAgKiBhcmUgdGhlbiBleHRyYWN0ZWQgYW5kIGNvbGxlY3RlZCBpbnRvIGFuIGluc3RhbmNlXG4gICAgICAgICAgICAgKiBvZiBsdW5yLk1hdGNoRGF0YSByZWFkeSB0byBiZSByZXR1cm5lZCBpbiB0aGUgcXVlcnlcbiAgICAgICAgICAgICAqIHJlc3VsdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nRG9jdW1lbnRSZWYgPSBtYXRjaGluZ0RvY3VtZW50UmVmc1tsXSxcbiAgICAgICAgICAgICAgICBtYXRjaGluZ0ZpZWxkUmVmID0gbmV3IGx1bnIuRmllbGRSZWYgKG1hdGNoaW5nRG9jdW1lbnRSZWYsIGZpZWxkKSxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGZpZWxkUG9zdGluZ1ttYXRjaGluZ0RvY3VtZW50UmVmXSxcbiAgICAgICAgICAgICAgICBmaWVsZE1hdGNoXG5cbiAgICAgICAgICAgIGlmICgoZmllbGRNYXRjaCA9IG1hdGNoaW5nRmllbGRzW21hdGNoaW5nRmllbGRSZWZdKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG1hdGNoaW5nRmllbGRzW21hdGNoaW5nRmllbGRSZWZdID0gbmV3IGx1bnIuTWF0Y2hEYXRhIChleHBhbmRlZFRlcm0sIGZpZWxkLCBtZXRhZGF0YSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkTWF0Y2guYWRkKGV4cGFuZGVkVGVybSwgZmllbGQsIG1ldGFkYXRhKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGVybUZpZWxkQ2FjaGVbdGVybUZpZWxkXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcmVzZW5jZSB3YXMgcmVxdWlyZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJlcXVpcmVkTWF0Y2hlcyBmaWVsZCBzZXRzLlxuICAgICAqIFdlIGRvIHRoaXMgYWZ0ZXIgYWxsIGZpZWxkcyBmb3IgdGhlIHRlcm0gaGF2ZSBjb2xsZWN0ZWQgdGhlaXIgbWF0Y2hlcyBiZWNhdXNlXG4gICAgICogdGhlIGNsYXVzZSB0ZXJtcyBwcmVzZW5jZSBpcyByZXF1aXJlZCBpbiBfYW55XyBvZiB0aGUgZmllbGRzIG5vdCBfYWxsXyBvZiB0aGVcbiAgICAgKiBmaWVsZHMuXG4gICAgICovXG4gICAgaWYgKGNsYXVzZS5wcmVzZW5jZSA9PT0gbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRCkge1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjbGF1c2UuZmllbGRzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGNsYXVzZS5maWVsZHNba11cbiAgICAgICAgcmVxdWlyZWRNYXRjaGVzW2ZpZWxkXSA9IHJlcXVpcmVkTWF0Y2hlc1tmaWVsZF0uaW50ZXJzZWN0KGNsYXVzZU1hdGNoZXMpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5lZWQgdG8gY29tYmluZSB0aGUgZmllbGQgc2NvcGVkIHJlcXVpcmVkIGFuZCBwcm9oaWJpdGVkXG4gICAqIG1hdGNoaW5nIGRvY3VtZW50cyBpbnRvIGEgZ2xvYmFsIHNldCBvZiByZXF1aXJlZCBhbmQgcHJvaGliaXRlZFxuICAgKiBtYXRjaGVzXG4gICAqL1xuICB2YXIgYWxsUmVxdWlyZWRNYXRjaGVzID0gbHVuci5TZXQuY29tcGxldGUsXG4gICAgICBhbGxQcm9oaWJpdGVkTWF0Y2hlcyA9IGx1bnIuU2V0LmVtcHR5XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW2ldXG5cbiAgICBpZiAocmVxdWlyZWRNYXRjaGVzW2ZpZWxkXSkge1xuICAgICAgYWxsUmVxdWlyZWRNYXRjaGVzID0gYWxsUmVxdWlyZWRNYXRjaGVzLmludGVyc2VjdChyZXF1aXJlZE1hdGNoZXNbZmllbGRdKVxuICAgIH1cblxuICAgIGlmIChwcm9oaWJpdGVkTWF0Y2hlc1tmaWVsZF0pIHtcbiAgICAgIGFsbFByb2hpYml0ZWRNYXRjaGVzID0gYWxsUHJvaGliaXRlZE1hdGNoZXMudW5pb24ocHJvaGliaXRlZE1hdGNoZXNbZmllbGRdKVxuICAgIH1cbiAgfVxuXG4gIHZhciBtYXRjaGluZ0ZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKG1hdGNoaW5nRmllbGRzKSxcbiAgICAgIHJlc3VsdHMgPSBbXSxcbiAgICAgIG1hdGNoZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLypcbiAgICogSWYgdGhlIHF1ZXJ5IGlzIG5lZ2F0ZWQgKGNvbnRhaW5zIG9ubHkgcHJvaGliaXRlZCB0ZXJtcylcbiAgICogd2UgbmVlZCB0byBnZXQgX2FsbF8gZmllbGRSZWZzIGN1cnJlbnRseSBleGlzdGluZyBpbiB0aGVcbiAgICogaW5kZXguIFRoaXMgaXMgb25seSBkb25lIHdoZW4gd2Uga25vdyB0aGF0IHRoZSBxdWVyeSBpc1xuICAgKiBlbnRpcmVseSBwcm9oaWJpdGVkIHRlcm1zIHRvIGF2b2lkIGFueSBjb3N0IG9mIGdldHRpbmcgYWxsXG4gICAqIGZpZWxkUmVmcyB1bm5lY2Vzc2FyaWx5LlxuICAgKlxuICAgKiBBZGRpdGlvbmFsbHksIGJsYW5rIE1hdGNoRGF0YSBtdXN0IGJlIGNyZWF0ZWQgdG8gY29ycmVjdGx5XG4gICAqIHBvcHVsYXRlIHRoZSByZXN1bHRzLlxuICAgKi9cbiAgaWYgKHF1ZXJ5LmlzTmVnYXRlZCgpKSB7XG4gICAgbWF0Y2hpbmdGaWVsZFJlZnMgPSBPYmplY3Qua2V5cyh0aGlzLmZpZWxkVmVjdG9ycylcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hpbmdGaWVsZFJlZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBtYXRjaGluZ0ZpZWxkUmVmID0gbWF0Y2hpbmdGaWVsZFJlZnNbaV1cbiAgICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhtYXRjaGluZ0ZpZWxkUmVmKVxuICAgICAgbWF0Y2hpbmdGaWVsZHNbbWF0Y2hpbmdGaWVsZFJlZl0gPSBuZXcgbHVuci5NYXRjaERhdGFcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdGNoaW5nRmllbGRSZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgLypcbiAgICAgKiBDdXJyZW50bHkgd2UgaGF2ZSBkb2N1bWVudCBmaWVsZHMgdGhhdCBtYXRjaCB0aGUgcXVlcnksIGJ1dCB3ZVxuICAgICAqIG5lZWQgdG8gcmV0dXJuIGRvY3VtZW50cy4gVGhlIG1hdGNoRGF0YSBhbmQgc2NvcmVzIGFyZSBjb21iaW5lZFxuICAgICAqIGZyb20gbXVsdGlwbGUgZmllbGRzIGJlbG9uZ2luZyB0byB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIFNjb3JlcyBhcmUgY2FsY3VsYXRlZCBieSBmaWVsZCwgdXNpbmcgdGhlIHF1ZXJ5IHZlY3RvcnMgY3JlYXRlZFxuICAgICAqIGFib3ZlLCBhbmQgY29tYmluZWQgaW50byBhIGZpbmFsIGRvY3VtZW50IHNjb3JlIHVzaW5nIGFkZGl0aW9uLlxuICAgICAqL1xuICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhtYXRjaGluZ0ZpZWxkUmVmc1tpXSksXG4gICAgICAgIGRvY1JlZiA9IGZpZWxkUmVmLmRvY1JlZlxuXG4gICAgaWYgKCFhbGxSZXF1aXJlZE1hdGNoZXMuY29udGFpbnMoZG9jUmVmKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoYWxsUHJvaGliaXRlZE1hdGNoZXMuY29udGFpbnMoZG9jUmVmKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB2YXIgZmllbGRWZWN0b3IgPSB0aGlzLmZpZWxkVmVjdG9yc1tmaWVsZFJlZl0sXG4gICAgICAgIHNjb3JlID0gcXVlcnlWZWN0b3JzW2ZpZWxkUmVmLmZpZWxkTmFtZV0uc2ltaWxhcml0eShmaWVsZFZlY3RvciksXG4gICAgICAgIGRvY01hdGNoXG5cbiAgICBpZiAoKGRvY01hdGNoID0gbWF0Y2hlc1tkb2NSZWZdKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb2NNYXRjaC5zY29yZSArPSBzY29yZVxuICAgICAgZG9jTWF0Y2gubWF0Y2hEYXRhLmNvbWJpbmUobWF0Y2hpbmdGaWVsZHNbZmllbGRSZWZdKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHJlZjogZG9jUmVmLFxuICAgICAgICBzY29yZTogc2NvcmUsXG4gICAgICAgIG1hdGNoRGF0YTogbWF0Y2hpbmdGaWVsZHNbZmllbGRSZWZdXG4gICAgICB9XG4gICAgICBtYXRjaGVzW2RvY1JlZl0gPSBtYXRjaFxuICAgICAgcmVzdWx0cy5wdXNoKG1hdGNoKVxuICAgIH1cbiAgfVxuXG4gIC8qXG4gICAqIFNvcnQgdGhlIHJlc3VsdHMgb2JqZWN0cyBieSBzY29yZSwgaGlnaGVzdCBmaXJzdC5cbiAgICovXG4gIHJldHVybiByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5zY29yZSAtIGEuc2NvcmVcbiAgfSlcbn1cblxuLyoqXG4gKiBQcmVwYXJlcyB0aGUgaW5kZXggZm9yIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBUaGUgc2NoZW1hIGZvciB0aGlzIEpTT04gYmxvYiB3aWxsIGJlIGRlc2NyaWJlZCBpbiBhXG4gKiBzZXBhcmF0ZSBKU09OIHNjaGVtYSBmaWxlLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmx1bnIuSW5kZXgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGludmVydGVkSW5kZXggPSBPYmplY3Qua2V5cyh0aGlzLmludmVydGVkSW5kZXgpXG4gICAgLnNvcnQoKVxuICAgIC5tYXAoZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAgIHJldHVybiBbdGVybSwgdGhpcy5pbnZlcnRlZEluZGV4W3Rlcm1dXVxuICAgIH0sIHRoaXMpXG5cbiAgdmFyIGZpZWxkVmVjdG9ycyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRWZWN0b3JzKVxuICAgIC5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgcmV0dXJuIFtyZWYsIHRoaXMuZmllbGRWZWN0b3JzW3JlZl0udG9KU09OKCldXG4gICAgfSwgdGhpcylcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246IGx1bnIudmVyc2lvbixcbiAgICBmaWVsZHM6IHRoaXMuZmllbGRzLFxuICAgIGZpZWxkVmVjdG9yczogZmllbGRWZWN0b3JzLFxuICAgIGludmVydGVkSW5kZXg6IGludmVydGVkSW5kZXgsXG4gICAgcGlwZWxpbmU6IHRoaXMucGlwZWxpbmUudG9KU09OKClcbiAgfVxufVxuXG4vKipcbiAqIExvYWRzIGEgcHJldmlvdXNseSBzZXJpYWxpemVkIGx1bnIuSW5kZXhcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXplZEluZGV4IC0gQSBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgbHVuci5JbmRleFxuICogQHJldHVybnMge2x1bnIuSW5kZXh9XG4gKi9cbmx1bnIuSW5kZXgubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpemVkSW5kZXgpIHtcbiAgdmFyIGF0dHJzID0ge30sXG4gICAgICBmaWVsZFZlY3RvcnMgPSB7fSxcbiAgICAgIHNlcmlhbGl6ZWRWZWN0b3JzID0gc2VyaWFsaXplZEluZGV4LmZpZWxkVmVjdG9ycyxcbiAgICAgIGludmVydGVkSW5kZXggPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgc2VyaWFsaXplZEludmVydGVkSW5kZXggPSBzZXJpYWxpemVkSW5kZXguaW52ZXJ0ZWRJbmRleCxcbiAgICAgIHRva2VuU2V0QnVpbGRlciA9IG5ldyBsdW5yLlRva2VuU2V0LkJ1aWxkZXIsXG4gICAgICBwaXBlbGluZSA9IGx1bnIuUGlwZWxpbmUubG9hZChzZXJpYWxpemVkSW5kZXgucGlwZWxpbmUpXG5cbiAgaWYgKHNlcmlhbGl6ZWRJbmRleC52ZXJzaW9uICE9IGx1bnIudmVyc2lvbikge1xuICAgIGx1bnIudXRpbHMud2FybihcIlZlcnNpb24gbWlzbWF0Y2ggd2hlbiBsb2FkaW5nIHNlcmlhbGlzZWQgaW5kZXguIEN1cnJlbnQgdmVyc2lvbiBvZiBsdW5yICdcIiArIGx1bnIudmVyc2lvbiArIFwiJyBkb2VzIG5vdCBtYXRjaCBzZXJpYWxpemVkIGluZGV4ICdcIiArIHNlcmlhbGl6ZWRJbmRleC52ZXJzaW9uICsgXCInXCIpXG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcmlhbGl6ZWRWZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHR1cGxlID0gc2VyaWFsaXplZFZlY3RvcnNbaV0sXG4gICAgICAgIHJlZiA9IHR1cGxlWzBdLFxuICAgICAgICBlbGVtZW50cyA9IHR1cGxlWzFdXG5cbiAgICBmaWVsZFZlY3RvcnNbcmVmXSA9IG5ldyBsdW5yLlZlY3RvcihlbGVtZW50cylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VyaWFsaXplZEludmVydGVkSW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBzZXJpYWxpemVkSW52ZXJ0ZWRJbmRleFtpXSxcbiAgICAgICAgdGVybSA9IHR1cGxlWzBdLFxuICAgICAgICBwb3N0aW5nID0gdHVwbGVbMV1cblxuICAgIHRva2VuU2V0QnVpbGRlci5pbnNlcnQodGVybSlcbiAgICBpbnZlcnRlZEluZGV4W3Rlcm1dID0gcG9zdGluZ1xuICB9XG5cbiAgdG9rZW5TZXRCdWlsZGVyLmZpbmlzaCgpXG5cbiAgYXR0cnMuZmllbGRzID0gc2VyaWFsaXplZEluZGV4LmZpZWxkc1xuXG4gIGF0dHJzLmZpZWxkVmVjdG9ycyA9IGZpZWxkVmVjdG9yc1xuICBhdHRycy5pbnZlcnRlZEluZGV4ID0gaW52ZXJ0ZWRJbmRleFxuICBhdHRycy50b2tlblNldCA9IHRva2VuU2V0QnVpbGRlci5yb290XG4gIGF0dHJzLnBpcGVsaW5lID0gcGlwZWxpbmVcblxuICByZXR1cm4gbmV3IGx1bnIuSW5kZXgoYXR0cnMpXG59XG4vKiFcbiAqIGx1bnIuQnVpbGRlclxuICogQ29weXJpZ2h0IChDKSAyMDIwIE9saXZlciBOaWdodGluZ2FsZVxuICovXG5cbi8qKlxuICogbHVuci5CdWlsZGVyIHBlcmZvcm1zIGluZGV4aW5nIG9uIGEgc2V0IG9mIGRvY3VtZW50cyBhbmRcbiAqIHJldHVybnMgaW5zdGFuY2VzIG9mIGx1bnIuSW5kZXggcmVhZHkgZm9yIHF1ZXJ5aW5nLlxuICpcbiAqIEFsbCBjb25maWd1cmF0aW9uIG9mIHRoZSBpbmRleCBpcyBkb25lIHZpYSB0aGUgYnVpbGRlciwgdGhlXG4gKiBmaWVsZHMgdG8gaW5kZXgsIHRoZSBkb2N1bWVudCByZWZlcmVuY2UsIHRoZSB0ZXh0IHByb2Nlc3NpbmdcbiAqIHBpcGVsaW5lIGFuZCBkb2N1bWVudCBzY29yaW5nIHBhcmFtZXRlcnMgYXJlIGFsbCBzZXQgb24gdGhlXG4gKiBidWlsZGVyIGJlZm9yZSBpbmRleGluZy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBfcmVmIC0gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCByZWZlcmVuY2UgZmllbGQuXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBfZmllbGRzIC0gSW50ZXJuYWwgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCBmaWVsZHMgdG8gaW5kZXguXG4gKiBAcHJvcGVydHkge29iamVjdH0gaW52ZXJ0ZWRJbmRleCAtIFRoZSBpbnZlcnRlZCBpbmRleCBtYXBzIHRlcm1zIHRvIGRvY3VtZW50IGZpZWxkcy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkb2N1bWVudFRlcm1GcmVxdWVuY2llcyAtIEtlZXBzIHRyYWNrIG9mIGRvY3VtZW50IHRlcm0gZnJlcXVlbmNpZXMuXG4gKiBAcHJvcGVydHkge29iamVjdH0gZG9jdW1lbnRMZW5ndGhzIC0gS2VlcHMgdHJhY2sgb2YgdGhlIGxlbmd0aCBvZiBkb2N1bWVudHMgYWRkZWQgdG8gdGhlIGluZGV4LlxuICogQHByb3BlcnR5IHtsdW5yLnRva2VuaXplcn0gdG9rZW5pemVyIC0gRnVuY3Rpb24gZm9yIHNwbGl0dGluZyBzdHJpbmdzIGludG8gdG9rZW5zIGZvciBpbmRleGluZy5cbiAqIEBwcm9wZXJ0eSB7bHVuci5QaXBlbGluZX0gcGlwZWxpbmUgLSBUaGUgcGlwZWxpbmUgcGVyZm9ybXMgdGV4dCBwcm9jZXNzaW5nIG9uIHRva2VucyBiZWZvcmUgaW5kZXhpbmcuXG4gKiBAcHJvcGVydHkge2x1bnIuUGlwZWxpbmV9IHNlYXJjaFBpcGVsaW5lIC0gQSBwaXBlbGluZSBmb3IgcHJvY2Vzc2luZyBzZWFyY2ggdGVybXMgYmVmb3JlIHF1ZXJ5aW5nIHRoZSBpbmRleC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb2N1bWVudENvdW50IC0gS2VlcHMgdHJhY2sgb2YgdGhlIHRvdGFsIG51bWJlciBvZiBkb2N1bWVudHMgaW5kZXhlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfYiAtIEEgcGFyYW1ldGVyIHRvIGNvbnRyb2wgZmllbGQgbGVuZ3RoIG5vcm1hbGl6YXRpb24sIHNldHRpbmcgdGhpcyB0byAwIGRpc2FibGVkIG5vcm1hbGl6YXRpb24sIDEgZnVsbHkgbm9ybWFsaXplcyBmaWVsZCBsZW5ndGhzLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyAwLjc1LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IF9rMSAtIEEgcGFyYW1ldGVyIHRvIGNvbnRyb2wgaG93IHF1aWNrbHkgYW4gaW5jcmVhc2UgaW4gdGVybSBmcmVxdWVuY3kgcmVzdWx0cyBpbiB0ZXJtIGZyZXF1ZW5jeSBzYXR1cmF0aW9uLCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGVybUluZGV4IC0gQSBjb3VudGVyIGluY3JlbWVudGVkIGZvciBlYWNoIHVuaXF1ZSB0ZXJtLCB1c2VkIHRvIGlkZW50aWZ5IGEgdGVybXMgcG9zaXRpb24gaW4gdGhlIHZlY3RvciBzcGFjZS5cbiAqIEBwcm9wZXJ0eSB7YXJyYXl9IG1ldGFkYXRhV2hpdGVsaXN0IC0gQSBsaXN0IG9mIG1ldGFkYXRhIGtleXMgdGhhdCBoYXZlIGJlZW4gd2hpdGVsaXN0ZWQgZm9yIGVudHJ5IGluIHRoZSBpbmRleC5cbiAqL1xubHVuci5CdWlsZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9yZWYgPSBcImlkXCJcbiAgdGhpcy5fZmllbGRzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICB0aGlzLl9kb2N1bWVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIHRoaXMuaW52ZXJ0ZWRJbmRleCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgdGhpcy5maWVsZFRlcm1GcmVxdWVuY2llcyA9IHt9XG4gIHRoaXMuZmllbGRMZW5ndGhzID0ge31cbiAgdGhpcy50b2tlbml6ZXIgPSBsdW5yLnRva2VuaXplclxuICB0aGlzLnBpcGVsaW5lID0gbmV3IGx1bnIuUGlwZWxpbmVcbiAgdGhpcy5zZWFyY2hQaXBlbGluZSA9IG5ldyBsdW5yLlBpcGVsaW5lXG4gIHRoaXMuZG9jdW1lbnRDb3VudCA9IDBcbiAgdGhpcy5fYiA9IDAuNzVcbiAgdGhpcy5fazEgPSAxLjJcbiAgdGhpcy50ZXJtSW5kZXggPSAwXG4gIHRoaXMubWV0YWRhdGFXaGl0ZWxpc3QgPSBbXVxufVxuXG4vKipcbiAqIFNldHMgdGhlIGRvY3VtZW50IGZpZWxkIHVzZWQgYXMgdGhlIGRvY3VtZW50IHJlZmVyZW5jZS4gRXZlcnkgZG9jdW1lbnQgbXVzdCBoYXZlIHRoaXMgZmllbGQuXG4gKiBUaGUgdHlwZSBvZiB0aGlzIGZpZWxkIGluIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgYSBzdHJpbmcsIGlmIGl0IGlzIG5vdCBhIHN0cmluZyBpdCB3aWxsIGJlXG4gKiBjb2VyY2VkIGludG8gYSBzdHJpbmcgYnkgY2FsbGluZyB0b1N0cmluZy5cbiAqXG4gKiBUaGUgZGVmYXVsdCByZWYgaXMgJ2lkJy5cbiAqXG4gKiBUaGUgcmVmIHNob3VsZCBfbm90XyBiZSBjaGFuZ2VkIGR1cmluZyBpbmRleGluZywgaXQgc2hvdWxkIGJlIHNldCBiZWZvcmUgYW55IGRvY3VtZW50cyBhcmVcbiAqIGFkZGVkIHRvIHRoZSBpbmRleC4gQ2hhbmdpbmcgaXQgZHVyaW5nIGluZGV4aW5nIGNhbiBsZWFkIHRvIGluY29uc2lzdGVudCByZXN1bHRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgLSBUaGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlIGZpZWxkIGluIHRoZSBkb2N1bWVudC5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAocmVmKSB7XG4gIHRoaXMuX3JlZiA9IHJlZlxufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGV4dHJhY3QgYSBmaWVsZCBmcm9tIGEgZG9jdW1lbnQuXG4gKlxuICogTHVuciBleHBlY3RzIGEgZmllbGQgdG8gYmUgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGRvY3VtZW50LCBpZiBob3dldmVyIHRoZSBmaWVsZFxuICogaXMgZGVlcGx5IG5lc3RlZCB3aXRoaW4gYSBkb2N1bWVudCBhbiBleHRyYWN0b3IgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZXh0cmFjdFxuICogdGhlIHJpZ2h0IGZpZWxkIGZvciBpbmRleGluZy5cbiAqXG4gKiBAY2FsbGJhY2sgZmllbGRFeHRyYWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBkb2MgLSBUaGUgZG9jdW1lbnQgYmVpbmcgYWRkZWQgdG8gdGhlIGluZGV4LlxuICogQHJldHVybnMgez8oc3RyaW5nfG9iamVjdHxvYmplY3RbXSl9IG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGluZGV4ZWQgZm9yIHRoaXMgZmllbGQuXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FeHRyYWN0aW5nIGEgbmVzdGVkIGZpZWxkPC9jYXB0aW9uPlxuICogZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gZG9jLm5lc3RlZC5maWVsZCB9XG4gKi9cblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhlIGxpc3Qgb2YgZG9jdW1lbnQgZmllbGRzIHRoYXQgd2lsbCBiZSBpbmRleGVkLiBFdmVyeSBkb2N1bWVudCBiZWluZ1xuICogaW5kZXhlZCBzaG91bGQgaGF2ZSB0aGlzIGZpZWxkLiBOdWxsIHZhbHVlcyBmb3IgdGhpcyBmaWVsZCBpbiBpbmRleGVkIGRvY3VtZW50cyB3aWxsXG4gKiBub3QgY2F1c2UgZXJyb3JzIGJ1dCB3aWxsIGxpbWl0IHRoZSBjaGFuY2Ugb2YgdGhhdCBkb2N1bWVudCBiZWluZyByZXRyaWV2ZWQgYnkgc2VhcmNoZXMuXG4gKlxuICogQWxsIGZpZWxkcyBzaG91bGQgYmUgYWRkZWQgYmVmb3JlIGFkZGluZyBkb2N1bWVudHMgdG8gdGhlIGluZGV4LiBBZGRpbmcgZmllbGRzIGFmdGVyXG4gKiBhIGRvY3VtZW50IGhhcyBiZWVuIGluZGV4ZWQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiBhbHJlYWR5IGluZGV4ZWQgZG9jdW1lbnRzLlxuICpcbiAqIEZpZWxkcyBjYW4gYmUgYm9vc3RlZCBhdCBidWlsZCB0aW1lLiBUaGlzIGFsbG93cyB0ZXJtcyB3aXRoaW4gdGhhdCBmaWVsZCB0byBoYXZlIG1vcmVcbiAqIGltcG9ydGFuY2Ugd2hlbiByYW5raW5nIHNlYXJjaCByZXN1bHRzLiBVc2UgYSBmaWVsZCBib29zdCB0byBzcGVjaWZ5IHRoYXQgbWF0Y2hlcyB3aXRoaW5cbiAqIG9uZSBmaWVsZCBhcmUgbW9yZSBpbXBvcnRhbnQgdGhhbiBvdGhlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSAtIFRoZSBuYW1lIG9mIGEgZmllbGQgdG8gaW5kZXggaW4gYWxsIGRvY3VtZW50cy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgYXR0cmlidXRlcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXR0cmlidXRlcy5ib29zdD0xXSAtIEJvb3N0IGFwcGxpZWQgdG8gYWxsIHRlcm1zIHdpdGhpbiB0aGlzIGZpZWxkLlxuICogQHBhcmFtIHtmaWVsZEV4dHJhY3Rvcn0gW2F0dHJpYnV0ZXMuZXh0cmFjdG9yXSAtIEZ1bmN0aW9uIHRvIGV4dHJhY3QgYSBmaWVsZCBmcm9tIGEgZG9jdW1lbnQuXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBmaWVsZE5hbWUgY2Fubm90IGNvbnRhaW4gdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyAnLydcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgaWYgKC9cXC8vLnRlc3QoZmllbGROYW1lKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yIChcIkZpZWxkICdcIiArIGZpZWxkTmFtZSArIFwiJyBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlciAnLydcIilcbiAgfVxuXG4gIHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdID0gYXR0cmlidXRlcyB8fCB7fVxufVxuXG4vKipcbiAqIEEgcGFyYW1ldGVyIHRvIHR1bmUgdGhlIGFtb3VudCBvZiBmaWVsZCBsZW5ndGggbm9ybWFsaXNhdGlvbiB0aGF0IGlzIGFwcGxpZWQgd2hlblxuICogY2FsY3VsYXRpbmcgcmVsZXZhbmNlIHNjb3Jlcy4gQSB2YWx1ZSBvZiAwIHdpbGwgY29tcGxldGVseSBkaXNhYmxlIGFueSBub3JtYWxpc2F0aW9uXG4gKiBhbmQgYSB2YWx1ZSBvZiAxIHdpbGwgZnVsbHkgbm9ybWFsaXNlIGZpZWxkIGxlbmd0aHMuIFRoZSBkZWZhdWx0IGlzIDAuNzUuIFZhbHVlcyBvZiBiXG4gKiB3aWxsIGJlIGNsYW1wZWQgdG8gdGhlIHJhbmdlIDAgLSAxLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgLSBUaGUgdmFsdWUgdG8gc2V0IGZvciB0aGlzIHR1bmluZyBwYXJhbWV0ZXIuXG4gKi9cbmx1bnIuQnVpbGRlci5wcm90b3R5cGUuYiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKG51bWJlciA8IDApIHtcbiAgICB0aGlzLl9iID0gMFxuICB9IGVsc2UgaWYgKG51bWJlciA+IDEpIHtcbiAgICB0aGlzLl9iID0gMVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX2IgPSBudW1iZXJcbiAgfVxufVxuXG4vKipcbiAqIEEgcGFyYW1ldGVyIHRoYXQgY29udHJvbHMgdGhlIHNwZWVkIGF0IHdoaWNoIGEgcmlzZSBpbiB0ZXJtIGZyZXF1ZW5jeSByZXN1bHRzIGluIHRlcm1cbiAqIGZyZXF1ZW5jeSBzYXR1cmF0aW9uLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxLjIuIFNldHRpbmcgdGhpcyB0byBhIGhpZ2hlciB2YWx1ZSB3aWxsIGdpdmVcbiAqIHNsb3dlciBzYXR1cmF0aW9uIGxldmVscywgYSBsb3dlciB2YWx1ZSB3aWxsIHJlc3VsdCBpbiBxdWlja2VyIHNhdHVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciAtIFRoZSB2YWx1ZSB0byBzZXQgZm9yIHRoaXMgdHVuaW5nIHBhcmFtZXRlci5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5rMSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgdGhpcy5fazEgPSBudW1iZXJcbn1cblxuLyoqXG4gKiBBZGRzIGEgZG9jdW1lbnQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEJlZm9yZSBhZGRpbmcgZmllbGRzIHRvIHRoZSBpbmRleCB0aGUgaW5kZXggc2hvdWxkIGhhdmUgYmVlbiBmdWxseSBzZXR1cCwgd2l0aCB0aGUgZG9jdW1lbnRcbiAqIHJlZiBhbmQgYWxsIGZpZWxkcyB0byBpbmRleCBhbHJlYWR5IGhhdmluZyBiZWVuIHNwZWNpZmllZC5cbiAqXG4gKiBUaGUgZG9jdW1lbnQgbXVzdCBoYXZlIGEgZmllbGQgbmFtZSBhcyBzcGVjaWZpZWQgYnkgdGhlIHJlZiAoYnkgZGVmYXVsdCB0aGlzIGlzICdpZCcpIGFuZFxuICogaXQgc2hvdWxkIGhhdmUgYWxsIGZpZWxkcyBkZWZpbmVkIGZvciBpbmRleGluZywgdGhvdWdoIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlcyB3aWxsIG5vdFxuICogY2F1c2UgZXJyb3JzLlxuICpcbiAqIEVudGlyZSBkb2N1bWVudHMgY2FuIGJlIGJvb3N0ZWQgYXQgYnVpbGQgdGltZS4gQXBwbHlpbmcgYSBib29zdCB0byBhIGRvY3VtZW50IGluZGljYXRlcyB0aGF0XG4gKiB0aGlzIGRvY3VtZW50IHNob3VsZCByYW5rIGhpZ2hlciBpbiBzZWFyY2ggcmVzdWx0cyB0aGFuIG90aGVyIGRvY3VtZW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZG9jIC0gVGhlIGRvY3VtZW50IHRvIGFkZCB0byB0aGUgaW5kZXguXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2F0dHJpYnV0ZXMuYm9vc3Q9MV0gLSBCb29zdCBhcHBsaWVkIHRvIGFsbCB0ZXJtcyB3aXRoaW4gdGhpcyBkb2N1bWVudC5cbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZG9jLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBkb2NSZWYgPSBkb2NbdGhpcy5fcmVmXSxcbiAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcylcblxuICB0aGlzLl9kb2N1bWVudHNbZG9jUmVmXSA9IGF0dHJpYnV0ZXMgfHwge31cbiAgdGhpcy5kb2N1bWVudENvdW50ICs9IDFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbaV0sXG4gICAgICAgIGV4dHJhY3RvciA9IHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdLmV4dHJhY3RvcixcbiAgICAgICAgZmllbGQgPSBleHRyYWN0b3IgPyBleHRyYWN0b3IoZG9jKSA6IGRvY1tmaWVsZE5hbWVdLFxuICAgICAgICB0b2tlbnMgPSB0aGlzLnRva2VuaXplcihmaWVsZCwge1xuICAgICAgICAgIGZpZWxkczogW2ZpZWxkTmFtZV1cbiAgICAgICAgfSksXG4gICAgICAgIHRlcm1zID0gdGhpcy5waXBlbGluZS5ydW4odG9rZW5zKSxcbiAgICAgICAgZmllbGRSZWYgPSBuZXcgbHVuci5GaWVsZFJlZiAoZG9jUmVmLCBmaWVsZE5hbWUpLFxuICAgICAgICBmaWVsZFRlcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4gICAgdGhpcy5maWVsZFRlcm1GcmVxdWVuY2llc1tmaWVsZFJlZl0gPSBmaWVsZFRlcm1zXG4gICAgdGhpcy5maWVsZExlbmd0aHNbZmllbGRSZWZdID0gMFxuXG4gICAgLy8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGlzIGZpZWxkIGZvciB0aGlzIGRvY3VtZW50XG4gICAgdGhpcy5maWVsZExlbmd0aHNbZmllbGRSZWZdICs9IHRlcm1zLmxlbmd0aFxuXG4gICAgLy8gY2FsY3VsYXRlIHRlcm0gZnJlcXVlbmNpZXMgZm9yIHRoaXMgZmllbGRcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRlcm1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdGVybSA9IHRlcm1zW2pdXG5cbiAgICAgIGlmIChmaWVsZFRlcm1zW3Rlcm1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWVsZFRlcm1zW3Rlcm1dID0gMFxuICAgICAgfVxuXG4gICAgICBmaWVsZFRlcm1zW3Rlcm1dICs9IDFcblxuICAgICAgLy8gYWRkIHRvIGludmVydGVkIGluZGV4XG4gICAgICAvLyBjcmVhdGUgYW4gaW5pdGlhbCBwb3N0aW5nIGlmIG9uZSBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAodGhpcy5pbnZlcnRlZEluZGV4W3Rlcm1dID09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcG9zdGluZyA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgcG9zdGluZ1tcIl9pbmRleFwiXSA9IHRoaXMudGVybUluZGV4XG4gICAgICAgIHRoaXMudGVybUluZGV4ICs9IDFcblxuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIHBvc3RpbmdbZmllbGRzW2tdXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXSA9IHBvc3RpbmdcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIGFuIGVudHJ5IGZvciB0aGlzIHRlcm0vZmllbGROYW1lL2RvY1JlZiB0byB0aGUgaW52ZXJ0ZWRJbmRleFxuICAgICAgaWYgKHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXVtmaWVsZE5hbWVdW2RvY1JlZl0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXVtmaWVsZE5hbWVdW2RvY1JlZl0gPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIGFsbCB3aGl0ZWxpc3RlZCBtZXRhZGF0YSBhYm91dCB0aGlzIHRva2VuIGluIHRoZVxuICAgICAgLy8gaW52ZXJ0ZWQgaW5kZXhcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhpcy5tZXRhZGF0YVdoaXRlbGlzdC5sZW5ndGg7IGwrKykge1xuICAgICAgICB2YXIgbWV0YWRhdGFLZXkgPSB0aGlzLm1ldGFkYXRhV2hpdGVsaXN0W2xdLFxuICAgICAgICAgICAgbWV0YWRhdGEgPSB0ZXJtLm1ldGFkYXRhW21ldGFkYXRhS2V5XVxuXG4gICAgICAgIGlmICh0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XSA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmludmVydGVkSW5kZXhbdGVybV1bZmllbGROYW1lXVtkb2NSZWZdW21ldGFkYXRhS2V5XS5wdXNoKG1ldGFkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICB9XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYXZlcmFnZSBkb2N1bWVudCBsZW5ndGggZm9yIHRoaXMgaW5kZXhcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLmNhbGN1bGF0ZUF2ZXJhZ2VGaWVsZExlbmd0aHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRMZW5ndGhzKSxcbiAgICAgIG51bWJlck9mRmllbGRzID0gZmllbGRSZWZzLmxlbmd0aCxcbiAgICAgIGFjY3VtdWxhdG9yID0ge30sXG4gICAgICBkb2N1bWVudHNXaXRoRmllbGQgPSB7fVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtYmVyT2ZGaWVsZHM7IGkrKykge1xuICAgIHZhciBmaWVsZFJlZiA9IGx1bnIuRmllbGRSZWYuZnJvbVN0cmluZyhmaWVsZFJlZnNbaV0pLFxuICAgICAgICBmaWVsZCA9IGZpZWxkUmVmLmZpZWxkTmFtZVxuXG4gICAgZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSB8fCAoZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSA9IDApXG4gICAgZG9jdW1lbnRzV2l0aEZpZWxkW2ZpZWxkXSArPSAxXG5cbiAgICBhY2N1bXVsYXRvcltmaWVsZF0gfHwgKGFjY3VtdWxhdG9yW2ZpZWxkXSA9IDApXG4gICAgYWNjdW11bGF0b3JbZmllbGRdICs9IHRoaXMuZmllbGRMZW5ndGhzW2ZpZWxkUmVmXVxuICB9XG5cbiAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHRoaXMuX2ZpZWxkcylcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbaV1cbiAgICBhY2N1bXVsYXRvcltmaWVsZE5hbWVdID0gYWNjdW11bGF0b3JbZmllbGROYW1lXSAvIGRvY3VtZW50c1dpdGhGaWVsZFtmaWVsZE5hbWVdXG4gIH1cblxuICB0aGlzLmF2ZXJhZ2VGaWVsZExlbmd0aCA9IGFjY3VtdWxhdG9yXG59XG5cbi8qKlxuICogQnVpbGRzIGEgdmVjdG9yIHNwYWNlIG1vZGVsIG9mIGV2ZXJ5IGRvY3VtZW50IHVzaW5nIGx1bnIuVmVjdG9yXG4gKlxuICogQHByaXZhdGVcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVGaWVsZFZlY3RvcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmaWVsZFZlY3RvcnMgPSB7fSxcbiAgICAgIGZpZWxkUmVmcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRUZXJtRnJlcXVlbmNpZXMpLFxuICAgICAgZmllbGRSZWZzTGVuZ3RoID0gZmllbGRSZWZzLmxlbmd0aCxcbiAgICAgIHRlcm1JZGZDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkUmVmc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGZpZWxkUmVmID0gbHVuci5GaWVsZFJlZi5mcm9tU3RyaW5nKGZpZWxkUmVmc1tpXSksXG4gICAgICAgIGZpZWxkTmFtZSA9IGZpZWxkUmVmLmZpZWxkTmFtZSxcbiAgICAgICAgZmllbGRMZW5ndGggPSB0aGlzLmZpZWxkTGVuZ3Roc1tmaWVsZFJlZl0sXG4gICAgICAgIGZpZWxkVmVjdG9yID0gbmV3IGx1bnIuVmVjdG9yLFxuICAgICAgICB0ZXJtRnJlcXVlbmNpZXMgPSB0aGlzLmZpZWxkVGVybUZyZXF1ZW5jaWVzW2ZpZWxkUmVmXSxcbiAgICAgICAgdGVybXMgPSBPYmplY3Qua2V5cyh0ZXJtRnJlcXVlbmNpZXMpLFxuICAgICAgICB0ZXJtc0xlbmd0aCA9IHRlcm1zLmxlbmd0aFxuXG5cbiAgICB2YXIgZmllbGRCb29zdCA9IHRoaXMuX2ZpZWxkc1tmaWVsZE5hbWVdLmJvb3N0IHx8IDEsXG4gICAgICAgIGRvY0Jvb3N0ID0gdGhpcy5fZG9jdW1lbnRzW2ZpZWxkUmVmLmRvY1JlZl0uYm9vc3QgfHwgMVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXJtc0xlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdGVybSA9IHRlcm1zW2pdLFxuICAgICAgICAgIHRmID0gdGVybUZyZXF1ZW5jaWVzW3Rlcm1dLFxuICAgICAgICAgIHRlcm1JbmRleCA9IHRoaXMuaW52ZXJ0ZWRJbmRleFt0ZXJtXS5faW5kZXgsXG4gICAgICAgICAgaWRmLCBzY29yZSwgc2NvcmVXaXRoUHJlY2lzaW9uXG5cbiAgICAgIGlmICh0ZXJtSWRmQ2FjaGVbdGVybV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZGYgPSBsdW5yLmlkZih0aGlzLmludmVydGVkSW5kZXhbdGVybV0sIHRoaXMuZG9jdW1lbnRDb3VudClcbiAgICAgICAgdGVybUlkZkNhY2hlW3Rlcm1dID0gaWRmXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZGYgPSB0ZXJtSWRmQ2FjaGVbdGVybV1cbiAgICAgIH1cblxuICAgICAgc2NvcmUgPSBpZGYgKiAoKHRoaXMuX2sxICsgMSkgKiB0ZikgLyAodGhpcy5fazEgKiAoMSAtIHRoaXMuX2IgKyB0aGlzLl9iICogKGZpZWxkTGVuZ3RoIC8gdGhpcy5hdmVyYWdlRmllbGRMZW5ndGhbZmllbGROYW1lXSkpICsgdGYpXG4gICAgICBzY29yZSAqPSBmaWVsZEJvb3N0XG4gICAgICBzY29yZSAqPSBkb2NCb29zdFxuICAgICAgc2NvcmVXaXRoUHJlY2lzaW9uID0gTWF0aC5yb3VuZChzY29yZSAqIDEwMDApIC8gMTAwMFxuICAgICAgLy8gQ29udmVydHMgMS4yMzQ1Njc4OSB0byAxLjIzNC5cbiAgICAgIC8vIFJlZHVjaW5nIHRoZSBwcmVjaXNpb24gc28gdGhhdCB0aGUgdmVjdG9ycyB0YWtlIHVwIGxlc3NcbiAgICAgIC8vIHNwYWNlIHdoZW4gc2VyaWFsaXNlZC4gRG9pbmcgaXQgbm93IHNvIHRoYXQgdGhleSBiZWhhdmVcbiAgICAgIC8vIHRoZSBzYW1lIGJlZm9yZSBhbmQgYWZ0ZXIgc2VyaWFsaXNhdGlvbi4gQWxzbywgdGhpcyBpc1xuICAgICAgLy8gdGhlIGZhc3Rlc3QgYXBwcm9hY2ggdG8gcmVkdWNpbmcgYSBudW1iZXIncyBwcmVjaXNpb24gaW5cbiAgICAgIC8vIEphdmFTY3JpcHQuXG5cbiAgICAgIGZpZWxkVmVjdG9yLmluc2VydCh0ZXJtSW5kZXgsIHNjb3JlV2l0aFByZWNpc2lvbilcbiAgICB9XG5cbiAgICBmaWVsZFZlY3RvcnNbZmllbGRSZWZdID0gZmllbGRWZWN0b3JcbiAgfVxuXG4gIHRoaXMuZmllbGRWZWN0b3JzID0gZmllbGRWZWN0b3JzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRva2VuIHNldCBvZiBhbGwgdG9rZW5zIGluIHRoZSBpbmRleCB1c2luZyBsdW5yLlRva2VuU2V0XG4gKlxuICogQHByaXZhdGVcbiAqL1xubHVuci5CdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVUb2tlblNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b2tlblNldCA9IGx1bnIuVG9rZW5TZXQuZnJvbUFycmF5KFxuICAgIE9iamVjdC5rZXlzKHRoaXMuaW52ZXJ0ZWRJbmRleCkuc29ydCgpXG4gIClcbn1cblxuLyoqXG4gKiBCdWlsZHMgdGhlIGluZGV4LCBjcmVhdGluZyBhbiBpbnN0YW5jZSBvZiBsdW5yLkluZGV4LlxuICpcbiAqIFRoaXMgY29tcGxldGVzIHRoZSBpbmRleGluZyBwcm9jZXNzIGFuZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAqIG9uY2UgYWxsIGRvY3VtZW50cyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGluZGV4LlxuICpcbiAqIEByZXR1cm5zIHtsdW5yLkluZGV4fVxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNhbGN1bGF0ZUF2ZXJhZ2VGaWVsZExlbmd0aHMoKVxuICB0aGlzLmNyZWF0ZUZpZWxkVmVjdG9ycygpXG4gIHRoaXMuY3JlYXRlVG9rZW5TZXQoKVxuXG4gIHJldHVybiBuZXcgbHVuci5JbmRleCh7XG4gICAgaW52ZXJ0ZWRJbmRleDogdGhpcy5pbnZlcnRlZEluZGV4LFxuICAgIGZpZWxkVmVjdG9yczogdGhpcy5maWVsZFZlY3RvcnMsXG4gICAgdG9rZW5TZXQ6IHRoaXMudG9rZW5TZXQsXG4gICAgZmllbGRzOiBPYmplY3Qua2V5cyh0aGlzLl9maWVsZHMpLFxuICAgIHBpcGVsaW5lOiB0aGlzLnNlYXJjaFBpcGVsaW5lXG4gIH0pXG59XG5cbi8qKlxuICogQXBwbGllcyBhIHBsdWdpbiB0byB0aGUgaW5kZXggYnVpbGRlci5cbiAqXG4gKiBBIHBsdWdpbiBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdpdGggdGhlIGluZGV4IGJ1aWxkZXIgYXMgaXRzIGNvbnRleHQuXG4gKiBQbHVnaW5zIGNhbiBiZSB1c2VkIHRvIGN1c3RvbWlzZSBvciBleHRlbmQgdGhlIGJlaGF2aW91ciBvZiB0aGUgaW5kZXhcbiAqIGluIHNvbWUgd2F5LiBBIHBsdWdpbiBpcyBqdXN0IGEgZnVuY3Rpb24sIHRoYXQgZW5jYXBzdWxhdGVkIHRoZSBjdXN0b21cbiAqIGJlaGF2aW91ciB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHdoZW4gYnVpbGRpbmcgdGhlIGluZGV4LlxuICpcbiAqIFRoZSBwbHVnaW4gZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgaW5kZXggYnVpbGRlciBhcyBpdHMgYXJndW1lbnQsIGFkZGl0aW9uYWxcbiAqIGFyZ3VtZW50cyBjYW4gYWxzbyBiZSBwYXNzZWQgd2hlbiBjYWxsaW5nIHVzZS4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkXG4gKiB3aXRoIHRoZSBpbmRleCBidWlsZGVyIGFzIGl0cyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBsdWdpbiBUaGUgcGx1Z2luIHRvIGFwcGx5LlxuICovXG5sdW5yLkJ1aWxkZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChmbikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgYXJncy51bnNoaWZ0KHRoaXMpXG4gIGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG59XG4vKipcbiAqIENvbnRhaW5zIGFuZCBjb2xsZWN0cyBtZXRhZGF0YSBhYm91dCBhIG1hdGNoaW5nIGRvY3VtZW50LlxuICogQSBzaW5nbGUgaW5zdGFuY2Ugb2YgbHVuci5NYXRjaERhdGEgaXMgcmV0dXJuZWQgYXMgcGFydCBvZiBldmVyeVxuICogbHVuci5JbmRleH5SZXN1bHQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybSAtIFRoZSB0ZXJtIHRoaXMgbWF0Y2ggZGF0YSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIFRoZSBmaWVsZCBpbiB3aGljaCB0aGUgdGVybSB3YXMgZm91bmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSByZWNvcmRlZCBhYm91dCB0aGlzIHRlcm0gaW4gdGhpcyBmaWVsZFxuICogQHByb3BlcnR5IHtvYmplY3R9IG1ldGFkYXRhIC0gQSBjbG9uZWQgY29sbGVjdGlvbiBvZiBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyBkb2N1bWVudC5cbiAqIEBzZWUge0BsaW5rIGx1bnIuSW5kZXh+UmVzdWx0fVxuICovXG5sdW5yLk1hdGNoRGF0YSA9IGZ1bmN0aW9uICh0ZXJtLCBmaWVsZCwgbWV0YWRhdGEpIHtcbiAgdmFyIGNsb25lZE1ldGFkYXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgIG1ldGFkYXRhS2V5cyA9IE9iamVjdC5rZXlzKG1ldGFkYXRhIHx8IHt9KVxuXG4gIC8vIENsb25pbmcgdGhlIG1ldGFkYXRhIHRvIHByZXZlbnQgdGhlIG9yaWdpbmFsXG4gIC8vIGJlaW5nIG11dGF0ZWQgZHVyaW5nIG1hdGNoIGRhdGEgY29tYmluYXRpb24uXG4gIC8vIE1ldGFkYXRhIGlzIGtlcHQgaW4gYW4gYXJyYXkgd2l0aGluIHRoZSBpbnZlcnRlZFxuICAvLyBpbmRleCBzbyBjbG9uaW5nIHRoZSBkYXRhIGNhbiBiZSBkb25lIHdpdGhcbiAgLy8gQXJyYXkjc2xpY2VcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhZGF0YUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gbWV0YWRhdGFLZXlzW2ldXG4gICAgY2xvbmVkTWV0YWRhdGFba2V5XSA9IG1ldGFkYXRhW2tleV0uc2xpY2UoKVxuICB9XG5cbiAgdGhpcy5tZXRhZGF0YSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICBpZiAodGVybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5tZXRhZGF0YVt0ZXJtXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IGNsb25lZE1ldGFkYXRhXG4gIH1cbn1cblxuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBsdW5yLk1hdGNoRGF0YSB3aWxsIGJlIGNyZWF0ZWQgZm9yIGV2ZXJ5IHRlcm0gdGhhdCBtYXRjaGVzIGFcbiAqIGRvY3VtZW50LiBIb3dldmVyIG9ubHkgb25lIGluc3RhbmNlIGlzIHJlcXVpcmVkIGluIGEgbHVuci5JbmRleH5SZXN1bHQuIFRoaXNcbiAqIG1ldGhvZCBjb21iaW5lcyBtZXRhZGF0YSBmcm9tIGFub3RoZXIgaW5zdGFuY2Ugb2YgbHVuci5NYXRjaERhdGEgd2l0aCB0aGlzXG4gKiBvYmplY3RzIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB7bHVuci5NYXRjaERhdGF9IG90aGVyTWF0Y2hEYXRhIC0gQW5vdGhlciBpbnN0YW5jZSBvZiBtYXRjaCBkYXRhIHRvIG1lcmdlIHdpdGggdGhpcyBvbmUuXG4gKiBAc2VlIHtAbGluayBsdW5yLkluZGV4flJlc3VsdH1cbiAqL1xubHVuci5NYXRjaERhdGEucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiAob3RoZXJNYXRjaERhdGEpIHtcbiAgdmFyIHRlcm1zID0gT2JqZWN0LmtleXMob3RoZXJNYXRjaERhdGEubWV0YWRhdGEpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXJtID0gdGVybXNbaV0sXG4gICAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dKVxuXG4gICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal0sXG4gICAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSlcblxuICAgICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdID09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdXG5cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF1ba2V5XSA9IG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF1ba2V5XSA9IHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0uY29uY2F0KG90aGVyTWF0Y2hEYXRhLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldKVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGQgbWV0YWRhdGEgZm9yIGEgdGVybS9maWVsZCBwYWlyIHRvIHRoaXMgaW5zdGFuY2Ugb2YgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGVybSAtIFRoZSB0ZXJtIHRoaXMgbWF0Y2ggZGF0YSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZCAtIFRoZSBmaWVsZCBpbiB3aGljaCB0aGUgdGVybSB3YXMgZm91bmRcbiAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YSAtIFRoZSBtZXRhZGF0YSByZWNvcmRlZCBhYm91dCB0aGlzIHRlcm0gaW4gdGhpcyBmaWVsZFxuICovXG5sdW5yLk1hdGNoRGF0YS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlcm0sIGZpZWxkLCBtZXRhZGF0YSkge1xuICBpZiAoISh0ZXJtIGluIHRoaXMubWV0YWRhdGEpKSB7XG4gICAgdGhpcy5tZXRhZGF0YVt0ZXJtXSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXSA9IG1ldGFkYXRhXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoIShmaWVsZCBpbiB0aGlzLm1ldGFkYXRhW3Rlcm1dKSkge1xuICAgIHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdID0gbWV0YWRhdGFcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBtZXRhZGF0YUtleXMgPSBPYmplY3Qua2V5cyhtZXRhZGF0YSlcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGFkYXRhS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBtZXRhZGF0YUtleXNbaV1cblxuICAgIGlmIChrZXkgaW4gdGhpcy5tZXRhZGF0YVt0ZXJtXVtmaWVsZF0pIHtcbiAgICAgIHRoaXMubWV0YWRhdGFbdGVybV1bZmllbGRdW2tleV0gPSB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldLmNvbmNhdChtZXRhZGF0YVtrZXldKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1ldGFkYXRhW3Rlcm1dW2ZpZWxkXVtrZXldID0gbWV0YWRhdGFba2V5XVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBBIGx1bnIuUXVlcnkgcHJvdmlkZXMgYSBwcm9ncmFtbWF0aWMgd2F5IG9mIGRlZmluaW5nIHF1ZXJpZXMgdG8gYmUgcGVyZm9ybWVkXG4gKiBhZ2FpbnN0IGEge0BsaW5rIGx1bnIuSW5kZXh9LlxuICpcbiAqIFByZWZlciBjb25zdHJ1Y3RpbmcgYSBsdW5yLlF1ZXJ5IHVzaW5nIHRoZSB7QGxpbmsgbHVuci5JbmRleCNxdWVyeX0gbWV0aG9kXG4gKiBzbyB0aGUgcXVlcnkgb2JqZWN0IGlzIHByZS1pbml0aWFsaXplZCB3aXRoIHRoZSByaWdodCBpbmRleCBmaWVsZHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkge2x1bnIuUXVlcnl+Q2xhdXNlW119IGNsYXVzZXMgLSBBbiBhcnJheSBvZiBxdWVyeSBjbGF1c2VzLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gYWxsRmllbGRzIC0gQW4gYXJyYXkgb2YgYWxsIGF2YWlsYWJsZSBmaWVsZHMgaW4gYSBsdW5yLkluZGV4LlxuICovXG5sdW5yLlF1ZXJ5ID0gZnVuY3Rpb24gKGFsbEZpZWxkcykge1xuICB0aGlzLmNsYXVzZXMgPSBbXVxuICB0aGlzLmFsbEZpZWxkcyA9IGFsbEZpZWxkc1xufVxuXG4vKipcbiAqIENvbnN0YW50cyBmb3IgaW5kaWNhdGluZyB3aGF0IGtpbmQgb2YgYXV0b21hdGljIHdpbGRjYXJkIGluc2VydGlvbiB3aWxsIGJlIHVzZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBxdWVyeSBjbGF1c2UuXG4gKlxuICogVGhpcyBhbGxvd3Mgd2lsZGNhcmRzIHRvIGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHRlcm0gd2l0aG91dCBoYXZpbmcgdG8gbWFudWFsbHkgZG8gYW55IHN0cmluZ1xuICogY29uY2F0ZW5hdGlvbi5cbiAqXG4gKiBUaGUgd2lsZGNhcmQgY29uc3RhbnRzIGNhbiBiZSBiaXR3aXNlIGNvbWJpbmVkIHRvIHNlbGVjdCBib3RoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdpbGRjYXJkcy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuTk9ORSAtIFRoZSB0ZXJtIHdpbGwgaGF2ZSBubyB3aWxkY2FyZHMgaW5zZXJ0ZWQsIHRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3VyXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuTEVBRElORyAtIFByZXBlbmQgdGhlIHRlcm0gd2l0aCBhIHdpbGRjYXJkLCB1bmxlc3MgYSBsZWFkaW5nIHdpbGRjYXJkIGFscmVhZHkgZXhpc3RzXG4gKiBAcHJvcGVydHkge251bWJlcn0gd2lsZGNhcmQuVFJBSUxJTkcgLSBBcHBlbmQgYSB3aWxkY2FyZCB0byB0aGUgdGVybSwgdW5sZXNzIGEgdHJhaWxpbmcgd2lsZGNhcmQgYWxyZWFkeSBleGlzdHNcbiAqIEBzZWUgbHVuci5RdWVyeX5DbGF1c2VcbiAqIEBzZWUgbHVuci5RdWVyeSNjbGF1c2VcbiAqIEBzZWUgbHVuci5RdWVyeSN0ZXJtXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5xdWVyeSB0ZXJtIHdpdGggdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKCdmb28nLCB7IHdpbGRjYXJkOiBsdW5yLlF1ZXJ5LndpbGRjYXJkLlRSQUlMSU5HIH0pXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5xdWVyeSB0ZXJtIHdpdGggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKCdmb28nLCB7XG4gKiAgIHdpbGRjYXJkOiBsdW5yLlF1ZXJ5LndpbGRjYXJkLkxFQURJTkcgfCBsdW5yLlF1ZXJ5LndpbGRjYXJkLlRSQUlMSU5HXG4gKiB9KVxuICovXG5cbmx1bnIuUXVlcnkud2lsZGNhcmQgPSBuZXcgU3RyaW5nIChcIipcIilcbmx1bnIuUXVlcnkud2lsZGNhcmQuTk9ORSA9IDBcbmx1bnIuUXVlcnkud2lsZGNhcmQuTEVBRElORyA9IDFcbmx1bnIuUXVlcnkud2lsZGNhcmQuVFJBSUxJTkcgPSAyXG5cbi8qKlxuICogQ29uc3RhbnRzIGZvciBpbmRpY2F0aW5nIHdoYXQga2luZCBvZiBwcmVzZW5jZSBhIHRlcm0gbXVzdCBoYXZlIGluIG1hdGNoaW5nIGRvY3VtZW50cy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKiBAc2VlIGx1bnIuUXVlcnl+Q2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnkjY2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnkjdGVybVxuICogQGV4YW1wbGUgPGNhcHRpb24+cXVlcnkgdGVybSB3aXRoIHJlcXVpcmVkIHByZXNlbmNlPC9jYXB0aW9uPlxuICogcXVlcnkudGVybSgnZm9vJywgeyBwcmVzZW5jZTogbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRCB9KVxuICovXG5sdW5yLlF1ZXJ5LnByZXNlbmNlID0ge1xuICAvKipcbiAgICogVGVybSdzIHByZXNlbmNlIGluIGEgZG9jdW1lbnQgaXMgb3B0aW9uYWwsIHRoaXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAqL1xuICBPUFRJT05BTDogMSxcblxuICAvKipcbiAgICogVGVybSdzIHByZXNlbmNlIGluIGEgZG9jdW1lbnQgaXMgcmVxdWlyZWQsIGRvY3VtZW50cyB0aGF0IGRvIG5vdCBjb250YWluXG4gICAqIHRoaXMgdGVybSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICovXG4gIFJFUVVJUkVEOiAyLFxuXG4gIC8qKlxuICAgKiBUZXJtJ3MgcHJlc2VuY2UgaW4gYSBkb2N1bWVudCBpcyBwcm9oaWJpdGVkLCBkb2N1bWVudHMgdGhhdCBkbyBjb250YWluXG4gICAqIHRoaXMgdGVybSB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICovXG4gIFBST0hJQklURUQ6IDNcbn1cblxuLyoqXG4gKiBBIHNpbmdsZSBjbGF1c2UgaW4gYSB7QGxpbmsgbHVuci5RdWVyeX0gY29udGFpbnMgYSB0ZXJtIGFuZCBkZXRhaWxzIG9uIGhvdyB0b1xuICogbWF0Y2ggdGhhdCB0ZXJtIGFnYWluc3QgYSB7QGxpbmsgbHVuci5JbmRleH0uXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gbHVuci5RdWVyeX5DbGF1c2VcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IGZpZWxkcyAtIFRoZSBmaWVsZHMgaW4gYW4gaW5kZXggdGhpcyBjbGF1c2Ugc2hvdWxkIGJlIG1hdGNoZWQgYWdhaW5zdC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYm9vc3Q9MV0gLSBBbnkgYm9vc3QgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB3aGVuIG1hdGNoaW5nIHRoaXMgY2xhdXNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlZGl0RGlzdGFuY2VdIC0gV2hldGhlciB0aGUgdGVybSBzaG91bGQgaGF2ZSBmdXp6eSBtYXRjaGluZyBhcHBsaWVkLCBhbmQgaG93IGZ1enp5IHRoZSBtYXRjaCBzaG91bGQgYmUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1c2VQaXBlbGluZV0gLSBXaGV0aGVyIHRoZSB0ZXJtIHNob3VsZCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgc2VhcmNoIHBpcGVsaW5lLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWxkY2FyZD1sdW5yLlF1ZXJ5LndpbGRjYXJkLk5PTkVdIC0gV2hldGhlciB0aGUgdGVybSBzaG91bGQgaGF2ZSB3aWxkY2FyZHMgYXBwZW5kZWQgb3IgcHJlcGVuZGVkLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtwcmVzZW5jZT1sdW5yLlF1ZXJ5LnByZXNlbmNlLk9QVElPTkFMXSAtIFRoZSB0ZXJtcyBwcmVzZW5jZSBpbiBhbnkgbWF0Y2hpbmcgZG9jdW1lbnRzLlxuICovXG5cbi8qKlxuICogQWRkcyBhIHtAbGluayBsdW5yLlF1ZXJ5fkNsYXVzZX0gdG8gdGhpcyBxdWVyeS5cbiAqXG4gKiBVbmxlc3MgdGhlIGNsYXVzZSBjb250YWlucyB0aGUgZmllbGRzIHRvIGJlIG1hdGNoZWQgYWxsIGZpZWxkcyB3aWxsIGJlIG1hdGNoZWQuIEluIGFkZGl0aW9uXG4gKiBhIGRlZmF1bHQgYm9vc3Qgb2YgMSBpcyBhcHBsaWVkIHRvIHRoZSBjbGF1c2UuXG4gKlxuICogQHBhcmFtIHtsdW5yLlF1ZXJ5fkNsYXVzZX0gY2xhdXNlIC0gVGhlIGNsYXVzZSB0byBhZGQgdG8gdGhpcyBxdWVyeS5cbiAqIEBzZWUgbHVuci5RdWVyeX5DbGF1c2VcbiAqIEByZXR1cm5zIHtsdW5yLlF1ZXJ5fVxuICovXG5sdW5yLlF1ZXJ5LnByb3RvdHlwZS5jbGF1c2UgPSBmdW5jdGlvbiAoY2xhdXNlKSB7XG4gIGlmICghKCdmaWVsZHMnIGluIGNsYXVzZSkpIHtcbiAgICBjbGF1c2UuZmllbGRzID0gdGhpcy5hbGxGaWVsZHNcbiAgfVxuXG4gIGlmICghKCdib29zdCcgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS5ib29zdCA9IDFcbiAgfVxuXG4gIGlmICghKCd1c2VQaXBlbGluZScgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS51c2VQaXBlbGluZSA9IHRydWVcbiAgfVxuXG4gIGlmICghKCd3aWxkY2FyZCcgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS53aWxkY2FyZCA9IGx1bnIuUXVlcnkud2lsZGNhcmQuTk9ORVxuICB9XG5cbiAgaWYgKChjbGF1c2Uud2lsZGNhcmQgJiBsdW5yLlF1ZXJ5LndpbGRjYXJkLkxFQURJTkcpICYmIChjbGF1c2UudGVybS5jaGFyQXQoMCkgIT0gbHVuci5RdWVyeS53aWxkY2FyZCkpIHtcbiAgICBjbGF1c2UudGVybSA9IFwiKlwiICsgY2xhdXNlLnRlcm1cbiAgfVxuXG4gIGlmICgoY2xhdXNlLndpbGRjYXJkICYgbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElORykgJiYgKGNsYXVzZS50ZXJtLnNsaWNlKC0xKSAhPSBsdW5yLlF1ZXJ5LndpbGRjYXJkKSkge1xuICAgIGNsYXVzZS50ZXJtID0gXCJcIiArIGNsYXVzZS50ZXJtICsgXCIqXCJcbiAgfVxuXG4gIGlmICghKCdwcmVzZW5jZScgaW4gY2xhdXNlKSkge1xuICAgIGNsYXVzZS5wcmVzZW5jZSA9IGx1bnIuUXVlcnkucHJlc2VuY2UuT1BUSU9OQUxcbiAgfVxuXG4gIHRoaXMuY2xhdXNlcy5wdXNoKGNsYXVzZSlcblxuICByZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEEgbmVnYXRlZCBxdWVyeSBpcyBvbmUgaW4gd2hpY2ggZXZlcnkgY2xhdXNlIGhhcyBhIHByZXNlbmNlIG9mXG4gKiBwcm9oaWJpdGVkLiBUaGVzZSBxdWVyaWVzIHJlcXVpcmUgc29tZSBzcGVjaWFsIHByb2Nlc3NpbmcgdG8gcmV0dXJuXG4gKiB0aGUgZXhwZWN0ZWQgcmVzdWx0cy5cbiAqXG4gKiBAcmV0dXJucyBib29sZWFuXG4gKi9cbmx1bnIuUXVlcnkucHJvdG90eXBlLmlzTmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsYXVzZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcy5jbGF1c2VzW2ldLnByZXNlbmNlICE9IGx1bnIuUXVlcnkucHJlc2VuY2UuUFJPSElCSVRFRCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBBZGRzIGEgdGVybSB0byB0aGUgY3VycmVudCBxdWVyeSwgdW5kZXIgdGhlIGNvdmVycyB0aGlzIHdpbGwgY3JlYXRlIGEge0BsaW5rIGx1bnIuUXVlcnl+Q2xhdXNlfVxuICogdG8gdGhlIGxpc3Qgb2YgY2xhdXNlcyB0aGF0IG1ha2UgdXAgdGhpcyBxdWVyeS5cbiAqXG4gKiBUaGUgdGVybSBpcyB1c2VkIGFzIGlzLCBpLmUuIG5vIHRva2VuaXphdGlvbiB3aWxsIGJlIHBlcmZvcm1lZCBieSB0aGlzIG1ldGhvZC4gSW5zdGVhZCBjb252ZXJzaW9uXG4gKiB0byBhIHRva2VuIG9yIHRva2VuLWxpa2Ugc3RyaW5nIHNob3VsZCBiZSBkb25lIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLlxuICpcbiAqIFRoZSB0ZXJtIHdpbGwgYmUgY29udmVydGVkIHRvIGEgc3RyaW5nIGJ5IGNhbGxpbmcgYHRvU3RyaW5nYC4gTXVsdGlwbGUgdGVybXMgY2FuIGJlIHBhc3NlZCBhcyBhblxuICogYXJyYXksIGVhY2ggdGVybSBpbiB0aGUgYXJyYXkgd2lsbCBzaGFyZSB0aGUgc2FtZSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fG9iamVjdFtdfSB0ZXJtIC0gVGhlIHRlcm0ocykgdG8gYWRkIHRvIHRoZSBxdWVyeS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBbnkgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGFkZCB0byB0aGUgcXVlcnkgY2xhdXNlLlxuICogQHJldHVybnMge2x1bnIuUXVlcnl9XG4gKiBAc2VlIGx1bnIuUXVlcnkjY2xhdXNlXG4gKiBAc2VlIGx1bnIuUXVlcnl+Q2xhdXNlXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5hZGRpbmcgYSBzaW5nbGUgdGVybSB0byBhIHF1ZXJ5PC9jYXB0aW9uPlxuICogcXVlcnkudGVybShcImZvb1wiKVxuICogQGV4YW1wbGUgPGNhcHRpb24+YWRkaW5nIGEgc2luZ2xlIHRlcm0gdG8gYSBxdWVyeSBhbmQgc3BlY2lmeWluZyBzZWFyY2ggZmllbGRzLCB0ZXJtIGJvb3N0IGFuZCBhdXRvbWF0aWMgdHJhaWxpbmcgd2lsZGNhcmQ8L2NhcHRpb24+XG4gKiBxdWVyeS50ZXJtKFwiZm9vXCIsIHtcbiAqICAgZmllbGRzOiBbXCJ0aXRsZVwiXSxcbiAqICAgYm9vc3Q6IDEwLFxuICogICB3aWxkY2FyZDogbHVuci5RdWVyeS53aWxkY2FyZC5UUkFJTElOR1xuICogfSlcbiAqIEBleGFtcGxlIDxjYXB0aW9uPnVzaW5nIGx1bnIudG9rZW5pemVyIHRvIGNvbnZlcnQgYSBzdHJpbmcgdG8gdG9rZW5zIGJlZm9yZSB1c2luZyB0aGVtIGFzIHRlcm1zPC9jYXB0aW9uPlxuICogcXVlcnkudGVybShsdW5yLnRva2VuaXplcihcImZvbyBiYXJcIikpXG4gKi9cbmx1bnIuUXVlcnkucHJvdG90eXBlLnRlcm0gPSBmdW5jdGlvbiAodGVybSwgb3B0aW9ucykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0ZXJtKSkge1xuICAgIHRlcm0uZm9yRWFjaChmdW5jdGlvbiAodCkgeyB0aGlzLnRlcm0odCwgbHVuci51dGlscy5jbG9uZShvcHRpb25zKSkgfSwgdGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGNsYXVzZSA9IG9wdGlvbnMgfHwge31cbiAgY2xhdXNlLnRlcm0gPSB0ZXJtLnRvU3RyaW5nKClcblxuICB0aGlzLmNsYXVzZShjbGF1c2UpXG5cbiAgcmV0dXJuIHRoaXNcbn1cbmx1bnIuUXVlcnlQYXJzZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHN0YXJ0LCBlbmQpIHtcbiAgdGhpcy5uYW1lID0gXCJRdWVyeVBhcnNlRXJyb3JcIlxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlXG4gIHRoaXMuc3RhcnQgPSBzdGFydFxuICB0aGlzLmVuZCA9IGVuZFxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3Jcbmx1bnIuUXVlcnlMZXhlciA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdGhpcy5sZXhlbWVzID0gW11cbiAgdGhpcy5zdHIgPSBzdHJcbiAgdGhpcy5sZW5ndGggPSBzdHIubGVuZ3RoXG4gIHRoaXMucG9zID0gMFxuICB0aGlzLnN0YXJ0ID0gMFxuICB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMgPSBbXVxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gbHVuci5RdWVyeUxleGVyLmxleFRleHRcblxuICB3aGlsZSAoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlKHRoaXMpXG4gIH1cbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5zbGljZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN1YlNsaWNlcyA9IFtdLFxuICAgICAgc2xpY2VTdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICBzbGljZUVuZCA9IHRoaXMucG9zXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBzbGljZUVuZCA9IHRoaXMuZXNjYXBlQ2hhclBvc2l0aW9uc1tpXVxuICAgIHN1YlNsaWNlcy5wdXNoKHRoaXMuc3RyLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKSlcbiAgICBzbGljZVN0YXJ0ID0gc2xpY2VFbmQgKyAxXG4gIH1cblxuICBzdWJTbGljZXMucHVzaCh0aGlzLnN0ci5zbGljZShzbGljZVN0YXJ0LCB0aGlzLnBvcykpXG4gIHRoaXMuZXNjYXBlQ2hhclBvc2l0aW9ucy5sZW5ndGggPSAwXG5cbiAgcmV0dXJuIHN1YlNsaWNlcy5qb2luKCcnKVxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICB0aGlzLmxleGVtZXMucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzdHI6IHRoaXMuc2xpY2VTdHJpbmcoKSxcbiAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICBlbmQ6IHRoaXMucG9zXG4gIH0pXG5cbiAgdGhpcy5zdGFydCA9IHRoaXMucG9zXG59XG5cbmx1bnIuUXVlcnlMZXhlci5wcm90b3R5cGUuZXNjYXBlQ2hhcmFjdGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVzY2FwZUNoYXJQb3NpdGlvbnMucHVzaCh0aGlzLnBvcyAtIDEpXG4gIHRoaXMucG9zICs9IDFcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbHVuci5RdWVyeUxleGVyLkVPU1xuICB9XG5cbiAgdmFyIGNoYXIgPSB0aGlzLnN0ci5jaGFyQXQodGhpcy5wb3MpXG4gIHRoaXMucG9zICs9IDFcbiAgcmV0dXJuIGNoYXJcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5zdGFydFxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIucHJvdG90eXBlLmlnbm9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc3RhcnQgPT0gdGhpcy5wb3MpIHtcbiAgICB0aGlzLnBvcyArPSAxXG4gIH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3Ncbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5iYWNrdXAgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucG9zIC09IDFcbn1cblxubHVuci5RdWVyeUxleGVyLnByb3RvdHlwZS5hY2NlcHREaWdpdFJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNoYXIsIGNoYXJDb2RlXG5cbiAgZG8ge1xuICAgIGNoYXIgPSB0aGlzLm5leHQoKVxuICAgIGNoYXJDb2RlID0gY2hhci5jaGFyQ29kZUF0KDApXG4gIH0gd2hpbGUgKGNoYXJDb2RlID4gNDcgJiYgY2hhckNvZGUgPCA1OClcblxuICBpZiAoY2hhciAhPSBsdW5yLlF1ZXJ5TGV4ZXIuRU9TKSB7XG4gICAgdGhpcy5iYWNrdXAoKVxuICB9XG59XG5cbmx1bnIuUXVlcnlMZXhlci5wcm90b3R5cGUubW9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucG9zIDwgdGhpcy5sZW5ndGhcbn1cblxubHVuci5RdWVyeUxleGVyLkVPUyA9ICdFT1MnXG5sdW5yLlF1ZXJ5TGV4ZXIuRklFTEQgPSAnRklFTEQnXG5sdW5yLlF1ZXJ5TGV4ZXIuVEVSTSA9ICdURVJNJ1xubHVuci5RdWVyeUxleGVyLkVESVRfRElTVEFOQ0UgPSAnRURJVF9ESVNUQU5DRSdcbmx1bnIuUXVlcnlMZXhlci5CT09TVCA9ICdCT09TVCdcbmx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRSA9ICdQUkVTRU5DRSdcblxubHVuci5RdWVyeUxleGVyLmxleEZpZWxkID0gZnVuY3Rpb24gKGxleGVyKSB7XG4gIGxleGVyLmJhY2t1cCgpXG4gIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLkZJRUxEKVxuICBsZXhlci5pZ25vcmUoKVxuICByZXR1cm4gbHVuci5RdWVyeUxleGVyLmxleFRleHRcbn1cblxubHVuci5RdWVyeUxleGVyLmxleFRlcm0gPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgaWYgKGxleGVyLndpZHRoKCkgPiAxKSB7XG4gICAgbGV4ZXIuYmFja3VwKClcbiAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICB9XG5cbiAgbGV4ZXIuaWdub3JlKClcblxuICBpZiAobGV4ZXIubW9yZSgpKSB7XG4gICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG4gIH1cbn1cblxubHVuci5RdWVyeUxleGVyLmxleEVkaXREaXN0YW5jZSA9IGZ1bmN0aW9uIChsZXhlcikge1xuICBsZXhlci5pZ25vcmUoKVxuICBsZXhlci5hY2NlcHREaWdpdFJ1bigpXG4gIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLkVESVRfRElTVEFOQ0UpXG4gIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4VGV4dFxufVxuXG5sdW5yLlF1ZXJ5TGV4ZXIubGV4Qm9vc3QgPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgbGV4ZXIuaWdub3JlKClcbiAgbGV4ZXIuYWNjZXB0RGlnaXRSdW4oKVxuICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5CT09TVClcbiAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG59XG5cbmx1bnIuUXVlcnlMZXhlci5sZXhFT1MgPSBmdW5jdGlvbiAobGV4ZXIpIHtcbiAgaWYgKGxleGVyLndpZHRoKCkgPiAwKSB7XG4gICAgbGV4ZXIuZW1pdChsdW5yLlF1ZXJ5TGV4ZXIuVEVSTSlcbiAgfVxufVxuXG4vLyBUaGlzIG1hdGNoZXMgdGhlIHNlcGFyYXRvciB1c2VkIHdoZW4gdG9rZW5pc2luZyBmaWVsZHNcbi8vIHdpdGhpbiBhIGRvY3VtZW50LiBUaGVzZSBzaG91bGQgbWF0Y2ggb3RoZXJ3aXNlIGl0IGlzXG4vLyBub3QgcG9zc2libGUgdG8gc2VhcmNoIGZvciBzb21lIHRva2VucyB3aXRoaW4gYSBkb2N1bWVudC5cbi8vXG4vLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHVzZXIgdG8gY2hhbmdlIHRoZSBzZXBhcmF0b3Igb24gdGhlXG4vLyB0b2tlbml6ZXIgc28gaXQgX21pZ2h0XyBjbGFzaCB3aXRoIGFueSBvdGhlciBvZiB0aGUgc3BlY2lhbFxuLy8gY2hhcmFjdGVycyBhbHJlYWR5IHVzZWQgd2l0aGluIHRoZSBzZWFyY2ggc3RyaW5nLCBlLmcuIDouXG4vL1xuLy8gVGhpcyBtZWFucyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgc2VwYXJhdG9yIGluXG4vLyBzdWNoIGEgd2F5IHRoYXQgbWFrZXMgc29tZSB3b3JkcyB1bnNlYXJjaGFibGUgdXNpbmcgYSBzZWFyY2hcbi8vIHN0cmluZy5cbmx1bnIuUXVlcnlMZXhlci50ZXJtU2VwYXJhdG9yID0gbHVuci50b2tlbml6ZXIuc2VwYXJhdG9yXG5cbmx1bnIuUXVlcnlMZXhlci5sZXhUZXh0ID0gZnVuY3Rpb24gKGxleGVyKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGNoYXIgPSBsZXhlci5uZXh0KClcblxuICAgIGlmIChjaGFyID09IGx1bnIuUXVlcnlMZXhlci5FT1MpIHtcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4RU9TXG4gICAgfVxuXG4gICAgLy8gRXNjYXBlIGNoYXJhY3RlciBpcyAnXFwnXG4gICAgaWYgKGNoYXIuY2hhckNvZGVBdCgwKSA9PSA5Mikge1xuICAgICAgbGV4ZXIuZXNjYXBlQ2hhcmFjdGVyKClcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGNoYXIgPT0gXCI6XCIpIHtcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4RmllbGRcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PSBcIn5cIikge1xuICAgICAgbGV4ZXIuYmFja3VwKClcbiAgICAgIGlmIChsZXhlci53aWR0aCgpID4gMCkge1xuICAgICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhFZGl0RGlzdGFuY2VcbiAgICB9XG5cbiAgICBpZiAoY2hhciA9PSBcIl5cIikge1xuICAgICAgbGV4ZXIuYmFja3VwKClcbiAgICAgIGlmIChsZXhlci53aWR0aCgpID4gMCkge1xuICAgICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5URVJNKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhCb29zdFxuICAgIH1cblxuICAgIC8vIFwiK1wiIGluZGljYXRlcyB0ZXJtIHByZXNlbmNlIGlzIHJlcXVpcmVkXG4gICAgLy8gY2hlY2tpbmcgZm9yIGxlbmd0aCB0byBlbnN1cmUgdGhhdCBvbmx5XG4gICAgLy8gbGVhZGluZyBcIitcIiBhcmUgY29uc2lkZXJlZFxuICAgIGlmIChjaGFyID09IFwiK1wiICYmIGxleGVyLndpZHRoKCkgPT09IDEpIHtcbiAgICAgIGxleGVyLmVtaXQobHVuci5RdWVyeUxleGVyLlBSRVNFTkNFKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXh0XG4gICAgfVxuXG4gICAgLy8gXCItXCIgaW5kaWNhdGVzIHRlcm0gcHJlc2VuY2UgaXMgcHJvaGliaXRlZFxuICAgIC8vIGNoZWNraW5nIGZvciBsZW5ndGggdG8gZW5zdXJlIHRoYXQgb25seVxuICAgIC8vIGxlYWRpbmcgXCItXCIgYXJlIGNvbnNpZGVyZWRcbiAgICBpZiAoY2hhciA9PSBcIi1cIiAmJiBsZXhlci53aWR0aCgpID09PSAxKSB7XG4gICAgICBsZXhlci5lbWl0KGx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRSlcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5TGV4ZXIubGV4VGV4dFxuICAgIH1cblxuICAgIGlmIChjaGFyLm1hdGNoKGx1bnIuUXVlcnlMZXhlci50ZXJtU2VwYXJhdG9yKSkge1xuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlMZXhlci5sZXhUZXJtXG4gICAgfVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIgPSBmdW5jdGlvbiAoc3RyLCBxdWVyeSkge1xuICB0aGlzLmxleGVyID0gbmV3IGx1bnIuUXVlcnlMZXhlciAoc3RyKVxuICB0aGlzLnF1ZXJ5ID0gcXVlcnlcbiAgdGhpcy5jdXJyZW50Q2xhdXNlID0ge31cbiAgdGhpcy5sZXhlbWVJZHggPSAwXG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmxleGVyLnJ1bigpXG4gIHRoaXMubGV4ZW1lcyA9IHRoaXMubGV4ZXIubGV4ZW1lc1xuXG4gIHZhciBzdGF0ZSA9IGx1bnIuUXVlcnlQYXJzZXIucGFyc2VDbGF1c2VcblxuICB3aGlsZSAoc3RhdGUpIHtcbiAgICBzdGF0ZSA9IHN0YXRlKHRoaXMpXG4gIH1cblxuICByZXR1cm4gdGhpcy5xdWVyeVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnByb3RvdHlwZS5wZWVrTGV4ZW1lID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZXhlbWVzW3RoaXMubGV4ZW1lSWR4XVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnByb3RvdHlwZS5jb25zdW1lTGV4ZW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbGV4ZW1lID0gdGhpcy5wZWVrTGV4ZW1lKClcbiAgdGhpcy5sZXhlbWVJZHggKz0gMVxuICByZXR1cm4gbGV4ZW1lXG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucHJvdG90eXBlLm5leHRDbGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb21wbGV0ZWRDbGF1c2UgPSB0aGlzLmN1cnJlbnRDbGF1c2VcbiAgdGhpcy5xdWVyeS5jbGF1c2UoY29tcGxldGVkQ2xhdXNlKVxuICB0aGlzLmN1cnJlbnRDbGF1c2UgPSB7fVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQ2xhdXNlID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLnBlZWtMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKGxleGVtZS50eXBlKSB7XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuVEVSTTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlVGVybVxuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJleHBlY3RlZCBlaXRoZXIgYSBmaWVsZCBvciBhIHRlcm0sIGZvdW5kIFwiICsgbGV4ZW1lLnR5cGVcblxuICAgICAgaWYgKGxleGVtZS5zdHIubGVuZ3RoID49IDEpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgJ1wiICsgbGV4ZW1lLnN0ciArIFwiJ1wiXG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cbn1cblxubHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKGxleGVtZS5zdHIpIHtcbiAgICBjYXNlIFwiLVwiOlxuICAgICAgcGFyc2VyLmN1cnJlbnRDbGF1c2UucHJlc2VuY2UgPSBsdW5yLlF1ZXJ5LnByZXNlbmNlLlBST0hJQklURURcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIitcIjpcbiAgICAgIHBhcnNlci5jdXJyZW50Q2xhdXNlLnByZXNlbmNlID0gbHVuci5RdWVyeS5wcmVzZW5jZS5SRVFVSVJFRFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwidW5yZWNvZ25pc2VkIHByZXNlbmNlIG9wZXJhdG9yJ1wiICsgbGV4ZW1lLnN0ciArIFwiJ1wiXG4gICAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiZXhwZWN0aW5nIHRlcm0gb3IgZmllbGQsIGZvdW5kIG5vdGhpbmdcIlxuICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cblxuICBzd2l0Y2ggKG5leHRMZXhlbWUudHlwZSkge1xuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLkZJRUxEOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VGaWVsZFxuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLlRFUk06XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVRlcm1cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiZXhwZWN0aW5nIHRlcm0gb3IgZmllbGQsIGZvdW5kICdcIiArIG5leHRMZXhlbWUudHlwZSArIFwiJ1wiXG4gICAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbmV4dExleGVtZS5zdGFydCwgbmV4dExleGVtZS5lbmQpXG4gIH1cbn1cblxubHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAocGFyc2VyLnF1ZXJ5LmFsbEZpZWxkcy5pbmRleE9mKGxleGVtZS5zdHIpID09IC0xKSB7XG4gICAgdmFyIHBvc3NpYmxlRmllbGRzID0gcGFyc2VyLnF1ZXJ5LmFsbEZpZWxkcy5tYXAoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIFwiJ1wiICsgZiArIFwiJ1wiIH0pLmpvaW4oJywgJyksXG4gICAgICAgIGVycm9yTWVzc2FnZSA9IFwidW5yZWNvZ25pc2VkIGZpZWxkICdcIiArIGxleGVtZS5zdHIgKyBcIicsIHBvc3NpYmxlIGZpZWxkczogXCIgKyBwb3NzaWJsZUZpZWxkc1xuXG4gICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIGxleGVtZS5zdGFydCwgbGV4ZW1lLmVuZClcbiAgfVxuXG4gIHBhcnNlci5jdXJyZW50Q2xhdXNlLmZpZWxkcyA9IFtsZXhlbWUuc3RyXVxuXG4gIHZhciBuZXh0TGV4ZW1lID0gcGFyc2VyLnBlZWtMZXhlbWUoKVxuXG4gIGlmIChuZXh0TGV4ZW1lID09IHVuZGVmaW5lZCkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImV4cGVjdGluZyB0ZXJtLCBmb3VuZCBub3RoaW5nXCJcbiAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImV4cGVjdGluZyB0ZXJtLCBmb3VuZCAnXCIgKyBuZXh0TGV4ZW1lLnR5cGUgKyBcIidcIlxuICAgICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIG5leHRMZXhlbWUuc3RhcnQsIG5leHRMZXhlbWUuZW5kKVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICB2YXIgbGV4ZW1lID0gcGFyc2VyLmNvbnN1bWVMZXhlbWUoKVxuXG4gIGlmIChsZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBwYXJzZXIuY3VycmVudENsYXVzZS50ZXJtID0gbGV4ZW1lLnN0ci50b0xvd2VyQ2FzZSgpXG5cbiAgaWYgKGxleGVtZS5zdHIuaW5kZXhPZihcIipcIikgIT0gLTEpIHtcbiAgICBwYXJzZXIuY3VycmVudENsYXVzZS51c2VQaXBlbGluZSA9IGZhbHNlXG4gIH1cblxuICB2YXIgbmV4dExleGVtZSA9IHBhcnNlci5wZWVrTGV4ZW1lKClcblxuICBpZiAobmV4dExleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzd2l0Y2ggKG5leHRMZXhlbWUudHlwZSkge1xuICAgIGNhc2UgbHVuci5RdWVyeUxleGVyLlRFUk06XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVRlcm1cbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5GSUVMRDpcbiAgICAgIHBhcnNlci5uZXh0Q2xhdXNlKClcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRmllbGRcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5FRElUX0RJU1RBTkNFOlxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VFZGl0RGlzdGFuY2VcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5CT09TVDpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQm9vc3RcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5QUkVTRU5DRTpcbiAgICAgIHBhcnNlci5uZXh0Q2xhdXNlKClcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlUHJlc2VuY2VcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiVW5leHBlY3RlZCBsZXhlbWUgdHlwZSAnXCIgKyBuZXh0TGV4ZW1lLnR5cGUgKyBcIidcIlxuICAgICAgdGhyb3cgbmV3IGx1bnIuUXVlcnlQYXJzZUVycm9yIChlcnJvck1lc3NhZ2UsIG5leHRMZXhlbWUuc3RhcnQsIG5leHRMZXhlbWUuZW5kKVxuICB9XG59XG5cbmx1bnIuUXVlcnlQYXJzZXIucGFyc2VFZGl0RGlzdGFuY2UgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIHZhciBsZXhlbWUgPSBwYXJzZXIuY29uc3VtZUxleGVtZSgpXG5cbiAgaWYgKGxleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBlZGl0RGlzdGFuY2UgPSBwYXJzZUludChsZXhlbWUuc3RyLCAxMClcblxuICBpZiAoaXNOYU4oZWRpdERpc3RhbmNlKSkge1xuICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcImVkaXQgZGlzdGFuY2UgbXVzdCBiZSBudW1lcmljXCJcbiAgICB0aHJvdyBuZXcgbHVuci5RdWVyeVBhcnNlRXJyb3IgKGVycm9yTWVzc2FnZSwgbGV4ZW1lLnN0YXJ0LCBsZXhlbWUuZW5kKVxuICB9XG5cbiAgcGFyc2VyLmN1cnJlbnRDbGF1c2UuZWRpdERpc3RhbmNlID0gZWRpdERpc3RhbmNlXG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRURJVF9ESVNUQU5DRTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRWRpdERpc3RhbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuQk9PU1Q6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUJvb3N0XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgbGV4ZW1lIHR5cGUgJ1wiICsgbmV4dExleGVtZS50eXBlICsgXCInXCJcbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBuZXh0TGV4ZW1lLnN0YXJ0LCBuZXh0TGV4ZW1lLmVuZClcbiAgfVxufVxuXG5sdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlQm9vc3QgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gIHZhciBsZXhlbWUgPSBwYXJzZXIuY29uc3VtZUxleGVtZSgpXG5cbiAgaWYgKGxleGVtZSA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBib29zdCA9IHBhcnNlSW50KGxleGVtZS5zdHIsIDEwKVxuXG4gIGlmIChpc05hTihib29zdCkpIHtcbiAgICB2YXIgZXJyb3JNZXNzYWdlID0gXCJib29zdCBtdXN0IGJlIG51bWVyaWNcIlxuICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBsZXhlbWUuc3RhcnQsIGxleGVtZS5lbmQpXG4gIH1cblxuICBwYXJzZXIuY3VycmVudENsYXVzZS5ib29zdCA9IGJvb3N0XG5cbiAgdmFyIG5leHRMZXhlbWUgPSBwYXJzZXIucGVla0xleGVtZSgpXG5cbiAgaWYgKG5leHRMZXhlbWUgPT0gdW5kZWZpbmVkKSB7XG4gICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgIHJldHVyblxuICB9XG5cbiAgc3dpdGNoIChuZXh0TGV4ZW1lLnR5cGUpIHtcbiAgICBjYXNlIGx1bnIuUXVlcnlMZXhlci5URVJNOlxuICAgICAgcGFyc2VyLm5leHRDbGF1c2UoKVxuICAgICAgcmV0dXJuIGx1bnIuUXVlcnlQYXJzZXIucGFyc2VUZXJtXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRklFTEQ6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUZpZWxkXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuRURJVF9ESVNUQU5DRTpcbiAgICAgIHJldHVybiBsdW5yLlF1ZXJ5UGFyc2VyLnBhcnNlRWRpdERpc3RhbmNlXG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuQk9PU1Q6XG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZUJvb3N0XG4gICAgY2FzZSBsdW5yLlF1ZXJ5TGV4ZXIuUFJFU0VOQ0U6XG4gICAgICBwYXJzZXIubmV4dENsYXVzZSgpXG4gICAgICByZXR1cm4gbHVuci5RdWVyeVBhcnNlci5wYXJzZVByZXNlbmNlXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgbGV4ZW1lIHR5cGUgJ1wiICsgbmV4dExleGVtZS50eXBlICsgXCInXCJcbiAgICAgIHRocm93IG5ldyBsdW5yLlF1ZXJ5UGFyc2VFcnJvciAoZXJyb3JNZXNzYWdlLCBuZXh0TGV4ZW1lLnN0YXJ0LCBuZXh0TGV4ZW1lLmVuZClcbiAgfVxufVxuXG4gIC8qKlxuICAgKiBleHBvcnQgdGhlIG1vZHVsZSB2aWEgQU1ELCBDb21tb25KUyBvciBhcyBhIGJyb3dzZXIgZ2xvYmFsXG4gICAqIEV4cG9ydCBjb2RlIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci9yZXR1cm5FeHBvcnRzLmpzXG4gICAqL1xuICA7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgICAgZGVmaW5lKGZhY3RvcnkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm9kZS4gRG9lcyBub3Qgd29yayB3aXRoIHN0cmljdCBDb21tb25KUywgYnV0XG4gICAgICAgKiBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLFxuICAgICAgICogbGlrZSBOb2RlLlxuICAgICAgICovXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgcm9vdC5sdW5yID0gZmFjdG9yeSgpXG4gICAgfVxuICB9KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBKdXN0IHJldHVybiBhIHZhbHVlIHRvIGRlZmluZSB0aGUgbW9kdWxlIGV4cG9ydC5cbiAgICAgKiBUaGlzIGV4YW1wbGUgcmV0dXJucyBhbiBvYmplY3QsIGJ1dCB0aGUgbW9kdWxlXG4gICAgICogY2FuIHJldHVybiBhIGZ1bmN0aW9uIGFzIHRoZSBleHBvcnRlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICByZXR1cm4gbHVuclxuICB9KSlcbn0pKCk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58291\n")}}]);