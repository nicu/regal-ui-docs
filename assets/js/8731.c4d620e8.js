"use strict";(self.webpackChunkregal_ui_docs=self.webpackChunkregal_ui_docs||[]).push([[8731],{59850:(__unused_webpack_module,exports,__webpack_require__)=>{eval("var __webpack_unused_export__;\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n__webpack_unused_export__ = ({ value: true });\nexports.Qi = exports.XO = void 0;\nconst ral_1 = __webpack_require__(69590);\nconst Is = __webpack_require__(78585);\nconst events_1 = __webpack_require__(62676);\nvar CancellationToken;\n(function (CancellationToken) {\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: events_1.Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: events_1.Event.None\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate === CancellationToken.None\n            || candidate === CancellationToken.Cancelled\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\n    }\n    CancellationToken.is = is;\n})(CancellationToken || (exports.XO = CancellationToken = {}));\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\n    return { dispose() { handle.dispose(); } };\n});\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new events_1.Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = undefined;\n        }\n    }\n}\nclass CancellationTokenSource {\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else {\n            this._token.cancel();\n        }\n    }\n    dispose() {\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nexports.Qi = CancellationTokenSource;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk4NTAuanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkMsRUFBRSxhQUFhLENBQUM7QUFDN0QsVUFBK0IsR0FBRyxVQUF5QjtBQUMzRCxjQUFjLG1CQUFPLENBQUMsS0FBTztBQUM3QixXQUFXLG1CQUFPLENBQUMsS0FBTTtBQUN6QixpQkFBaUIsbUJBQU8sQ0FBQyxLQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IsVUFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL2NhbmNlbGxhdGlvbi5qcz82YmZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gcmVxdWlyZShcIi4vcmFsXCIpO1xuY29uc3QgSXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xudmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXG4gICAgICAgICAgICB8fCBjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZFxuICAgICAgICAgICAgfHwgKElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSAmJiAhIWNhbmRpZGF0ZS5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XG5jb25zdCBzaG9ydGN1dEV2ZW50ID0gT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBoYW5kbGUgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQoY29udGV4dCksIDApO1xuICAgIHJldHVybiB7IGRpc3Bvc2UoKSB7IGhhbmRsZS5kaXNwb3NlKCk7IH0gfTtcbn0pO1xuY2xhc3MgTXV0YWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBnZXQgdG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGJlIGxhenkgYW5kIGNyZWF0ZSB0aGUgdG9rZW4gb25seSB3aGVuXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gbmV3IE11dGFibGVUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFuIG9iamVjdCBieSByZXR1cm5pbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGNhbmNlbGxlZCB0b2tlbiB3aGVuIGNhbmNlbGxhdGlvbiBoYXBwZW5zXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSB0b2tlbiBpZiB3ZSBoYWQgbm9uZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBkaXNwb3NlXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59850\n")},62676:(__unused_webpack_module,exports,__webpack_require__)=>{eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Emitter = exports.Event = void 0;\nconst ral_1 = __webpack_require__(69590);\nvar Event;\n(function (Event) {\n    const _disposable = { dispose() { } };\n    Event.None = function () { return _disposable; };\n})(Event || (exports.Event = Event = {}));\nclass CallbackList {\n    add(callback, context = null, bucket) {\n        if (!this._callbacks) {\n            this._callbacks = [];\n            this._contexts = [];\n        }\n        this._callbacks.push(callback);\n        this._contexts.push(context);\n        if (Array.isArray(bucket)) {\n            bucket.push({ dispose: () => this.remove(callback, context) });\n        }\n    }\n    remove(callback, context = null) {\n        if (!this._callbacks) {\n            return;\n        }\n        let foundCallbackWithDifferentContext = false;\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\n            if (this._callbacks[i] === callback) {\n                if (this._contexts[i] === context) {\n                    // callback & context match => remove it\n                    this._callbacks.splice(i, 1);\n                    this._contexts.splice(i, 1);\n                    return;\n                }\n                else {\n                    foundCallbackWithDifferentContext = true;\n                }\n            }\n        }\n        if (foundCallbackWithDifferentContext) {\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\n        }\n    }\n    invoke(...args) {\n        if (!this._callbacks) {\n            return [];\n        }\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\n        for (let i = 0, len = callbacks.length; i < len; i++) {\n            try {\n                ret.push(callbacks[i].apply(contexts[i], args));\n            }\n            catch (e) {\n                // eslint-disable-next-line no-console\n                (0, ral_1.default)().console.error(e);\n            }\n        }\n        return ret;\n    }\n    isEmpty() {\n        return !this._callbacks || this._callbacks.length === 0;\n    }\n    dispose() {\n        this._callbacks = undefined;\n        this._contexts = undefined;\n    }\n}\nclass Emitter {\n    constructor(_options) {\n        this._options = _options;\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (listener, thisArgs, disposables) => {\n                if (!this._callbacks) {\n                    this._callbacks = new CallbackList();\n                }\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                this._callbacks.add(listener, thisArgs);\n                const result = {\n                    dispose: () => {\n                        if (!this._callbacks) {\n                            // disposable is disposed after emitter is disposed.\n                            return;\n                        }\n                        this._callbacks.remove(listener, thisArgs);\n                        result.dispose = Emitter._noop;\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\n                            this._options.onLastListenerRemove(this);\n                        }\n                    }\n                };\n                if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        if (this._callbacks) {\n            this._callbacks.invoke.call(this._callbacks, event);\n        }\n    }\n    dispose() {\n        if (this._callbacks) {\n            this._callbacks.dispose();\n            this._callbacks = undefined;\n        }\n    }\n}\nexports.Emitter = Emitter;\nEmitter._noop = function () { };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjI2NzYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsYUFBYTtBQUMvQixjQUFjLG1CQUFPLENBQUMsS0FBTztBQUM3QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLCtCQUErQjtBQUMvQixDQUFDLFlBQVksYUFBYSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwrQ0FBK0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsU0FBUztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NvbW1vbi9ldmVudHMuanM/NmI0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IHJlcXVpcmUoXCIuL3JhbFwiKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0gRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62676\n")},78585:(__unused_webpack_module,exports)=>{eval("\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg1ODUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGVBQWU7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL2lzLmpzPzU3NTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0cmluZ0FycmF5ID0gZXhwb3J0cy5hcnJheSA9IGV4cG9ydHMuZnVuYyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLm51bWJlciA9IGV4cG9ydHMuc3RyaW5nID0gZXhwb3J0cy5ib29sZWFuID0gdm9pZCAwO1xuZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG59XG5leHBvcnRzLmJvb2xlYW4gPSBib29sZWFuO1xuZnVuY3Rpb24gc3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59XG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbmZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBlcnJvcih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xufVxuZXhwb3J0cy5lcnJvciA9IGVycm9yO1xuZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmZ1bmMgPSBmdW5jO1xuZnVuY3Rpb24gYXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmFycmF5ID0gYXJyYXk7XG5mdW5jdGlvbiBzdHJpbmdBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBhcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoZWxlbSA9PiBzdHJpbmcoZWxlbSkpO1xufVxuZXhwb3J0cy5zdHJpbmdBcnJheSA9IHN0cmluZ0FycmF5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78585\n")},69590:(__unused_webpack_module,exports)=>{eval('\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nlet _ral;\nfunction RAL() {\n    if (_ral === undefined) {\n        throw new Error(`No runtime abstraction layer installed`);\n    }\n    return _ral;\n}\n(function (RAL) {\n    function install(ral) {\n        if (ral === undefined) {\n            throw new Error(`No runtime abstraction layer provided`);\n        }\n        _ral = ral;\n    }\n    RAL.install = install;\n})(RAL || (RAL = {}));\nexports["default"] = RAL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk1OTAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQjtBQUNuQixrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NvbW1vbi9yYWwuanM/N2EyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmxldCBfcmFsO1xuZnVuY3Rpb24gUkFMKCkge1xuICAgIGlmIChfcmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBydW50aW1lIGFic3RyYWN0aW9uIGxheWVyIGluc3RhbGxlZGApO1xuICAgIH1cbiAgICByZXR1cm4gX3JhbDtcbn1cbihmdW5jdGlvbiAoUkFMKSB7XG4gICAgZnVuY3Rpb24gaW5zdGFsbChyYWwpIHtcbiAgICAgICAgaWYgKHJhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgcHJvdmlkZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBfcmFsID0gcmFsO1xuICAgIH1cbiAgICBSQUwuaW5zdGFsbCA9IGluc3RhbGw7XG59KShSQUwgfHwgKFJBTCA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSQUw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///69590\n')},97021:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   v: () => (/* binding */ createInfoServices)\n/* harmony export */ });\n/* unused harmony export InfoModule */\n/* harmony import */ var _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19369);\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33394);\n\n\n// src/language/info/module.ts\n\n\n// src/language/info/tokenBuilder.ts\nvar InfoTokenBuilder = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidTokenBuilder */ .mR {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "InfoTokenBuilder");\n  }\n  constructor() {\n    super(["info", "showInfo"]);\n  }\n};\n\n// src/language/info/module.ts\nvar InfoModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new InfoTokenBuilder(), "TokenBuilder"),\n    ValueConverter: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .CommonValueConverter */ .Tm(), "ValueConverter")\n  }\n};\nfunction createInfoServices(context = langium__WEBPACK_IMPORTED_MODULE_1__/* .EmptyFileSystem */ .DD) {\n  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultSharedCoreModule */ .uM)(context),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MermaidGeneratedSharedModule */ .sr\n  );\n  const Info = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultCoreModule */ .tG)({ shared }),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .InfoGeneratedModule */ .e5,\n    InfoModule\n  );\n  shared.ServiceRegistry.register(Info);\n  return { shared, Info };\n}\n(0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(createInfoServices, "createInfoServices");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcwMjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTThCOztBQUU5QjtBQU1pQjs7QUFFakI7QUFDQSxxQ0FBcUMsc0ZBQTJCO0FBQ2hFO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFNO0FBQ3hDLG9DQUFvQyxxRUFBTSxXQUFXLCtFQUFvQjtBQUN6RTtBQUNBO0FBQ0Esc0NBQXNDLDhEQUFlO0FBQ3JELGlCQUFpQix5REFBTTtBQUN2QixJQUFJLGdGQUE2QjtBQUNqQyxJQUFJLHVGQUE0QjtBQUNoQztBQUNBLGVBQWUseURBQU07QUFDckIsSUFBSSwwRUFBdUIsR0FBRyxRQUFRO0FBQ3RDLElBQUksOEVBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHFFQUFNOztBQUtKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbWVybWFpZC1qcy9wYXJzZXIvZGlzdC9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay00WUZCNVZVQy5tanM/MmU4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIsXG4gIENvbW1vblZhbHVlQ29udmVydGVyLFxuICBJbmZvR2VuZXJhdGVkTW9kdWxlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBfX25hbWVcbn0gZnJvbSBcIi4vY2h1bmstWTI3TVFaM1UubWpzXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9pbmZvL21vZHVsZS50c1xuaW1wb3J0IHtcbiAgRW1wdHlGaWxlU3lzdGVtLFxuICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSxcbiAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUsXG4gIGluamVjdFxufSBmcm9tIFwibGFuZ2l1bVwiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvaW5mby90b2tlbkJ1aWxkZXIudHNcbnZhciBJbmZvVG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkluZm9Ub2tlbkJ1aWxkZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW1wiaW5mb1wiLCBcInNob3dJbmZvXCJdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2luZm8vbW9kdWxlLnRzXG52YXIgSW5mb01vZHVsZSA9IHtcbiAgcGFyc2VyOiB7XG4gICAgVG9rZW5CdWlsZGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBJbmZvVG9rZW5CdWlsZGVyKCksIFwiVG9rZW5CdWlsZGVyXCIpLFxuICAgIFZhbHVlQ29udmVydGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBDb21tb25WYWx1ZUNvbnZlcnRlcigpLCBcIlZhbHVlQ29udmVydGVyXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVJbmZvU2VydmljZXMoY29udGV4dCA9IEVtcHR5RmlsZVN5c3RlbSkge1xuICBjb25zdCBzaGFyZWQgPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUoY29udGV4dCksXG4gICAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZVxuICApO1xuICBjb25zdCBJbmZvID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKHsgc2hhcmVkIH0pLFxuICAgIEluZm9HZW5lcmF0ZWRNb2R1bGUsXG4gICAgSW5mb01vZHVsZVxuICApO1xuICBzaGFyZWQuU2VydmljZVJlZ2lzdHJ5LnJlZ2lzdGVyKEluZm8pO1xuICByZXR1cm4geyBzaGFyZWQsIEluZm8gfTtcbn1cbl9fbmFtZShjcmVhdGVJbmZvU2VydmljZXMsIFwiY3JlYXRlSW5mb1NlcnZpY2VzXCIpO1xuXG5leHBvcnQge1xuICBJbmZvTW9kdWxlLFxuICBjcmVhdGVJbmZvU2VydmljZXNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97021\n')},88685:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   f: () => (/* binding */ createPieServices)\n/* harmony export */ });\n/* unused harmony export PieModule */\n/* harmony import */ var _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19369);\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33394);\n\n\n// src/language/pie/module.ts\n\n\n// src/language/pie/tokenBuilder.ts\nvar PieTokenBuilder = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidTokenBuilder */ .mR {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "PieTokenBuilder");\n  }\n  constructor() {\n    super(["pie", "showData"]);\n  }\n};\n\n// src/language/pie/valueConverter.ts\nvar PieValueConverter = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidValueConverter */ .dg {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "PieValueConverter");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name !== "PIE_SECTION_LABEL") {\n      return void 0;\n    }\n    return input.replace(/"/g, "").trim();\n  }\n};\n\n// src/language/pie/module.ts\nvar PieModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new PieTokenBuilder(), "TokenBuilder"),\n    ValueConverter: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new PieValueConverter(), "ValueConverter")\n  }\n};\nfunction createPieServices(context = langium__WEBPACK_IMPORTED_MODULE_1__/* .EmptyFileSystem */ .DD) {\n  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultSharedCoreModule */ .uM)(context),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MermaidGeneratedSharedModule */ .sr\n  );\n  const Pie = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultCoreModule */ .tG)({ shared }),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .PieGeneratedModule */ .KX,\n    PieModule\n  );\n  shared.ServiceRegistry.register(Pie);\n  return { shared, Pie };\n}\n(0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(createPieServices, "createPieServices");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODg2ODUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTThCOztBQUU5QjtBQU1pQjs7QUFFakI7QUFDQSxvQ0FBb0Msc0ZBQTJCO0FBQy9EO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0Msd0ZBQTZCO0FBQ25FO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFNO0FBQ3hDLG9DQUFvQyxxRUFBTTtBQUMxQztBQUNBO0FBQ0EscUNBQXFDLDhEQUFlO0FBQ3BELGlCQUFpQix5REFBTTtBQUN2QixJQUFJLGdGQUE2QjtBQUNqQyxJQUFJLHVGQUE0QjtBQUNoQztBQUNBLGNBQWMseURBQU07QUFDcEIsSUFBSSwwRUFBdUIsR0FBRyxRQUFRO0FBQ3RDLElBQUksNkVBQWtCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHFFQUFNOztBQUtKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbWVybWFpZC1qcy9wYXJzZXIvZGlzdC9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay1CSTZFUUtPUS5tanM/Njc1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIsXG4gIEFic3RyYWN0TWVybWFpZFZhbHVlQ29udmVydGVyLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBQaWVHZW5lcmF0ZWRNb2R1bGUsXG4gIF9fbmFtZVxufSBmcm9tIFwiLi9jaHVuay1ZMjdNUVozVS5tanNcIjtcblxuLy8gc3JjL2xhbmd1YWdlL3BpZS9tb2R1bGUudHNcbmltcG9ydCB7XG4gIEVtcHR5RmlsZVN5c3RlbSxcbiAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUsXG4gIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlLFxuICBpbmplY3Rcbn0gZnJvbSBcImxhbmdpdW1cIjtcblxuLy8gc3JjL2xhbmd1YWdlL3BpZS90b2tlbkJ1aWxkZXIudHNcbnZhciBQaWVUb2tlbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiUGllVG9rZW5CdWlsZGVyXCIpO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFtcInBpZVwiLCBcInNob3dEYXRhXCJdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL3BpZS92YWx1ZUNvbnZlcnRlci50c1xudmFyIFBpZVZhbHVlQ29udmVydGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiUGllVmFsdWVDb252ZXJ0ZXJcIik7XG4gIH1cbiAgcnVuQ3VzdG9tQ29udmVydGVyKHJ1bGUsIGlucHV0LCBfY3N0Tm9kZSkge1xuICAgIGlmIChydWxlLm5hbWUgIT09IFwiUElFX1NFQ1RJT05fTEFCRUxcIikge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1wiL2csIFwiXCIpLnRyaW0oKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL3BpZS9tb2R1bGUudHNcbnZhciBQaWVNb2R1bGUgPSB7XG4gIHBhcnNlcjoge1xuICAgIFRva2VuQnVpbGRlcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgUGllVG9rZW5CdWlsZGVyKCksIFwiVG9rZW5CdWlsZGVyXCIpLFxuICAgIFZhbHVlQ29udmVydGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBQaWVWYWx1ZUNvbnZlcnRlcigpLCBcIlZhbHVlQ29udmVydGVyXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVQaWVTZXJ2aWNlcyhjb250ZXh0ID0gRW1wdHlGaWxlU3lzdGVtKSB7XG4gIGNvbnN0IHNoYXJlZCA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSxcbiAgICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlXG4gICk7XG4gIGNvbnN0IFBpZSA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSh7IHNoYXJlZCB9KSxcbiAgICBQaWVHZW5lcmF0ZWRNb2R1bGUsXG4gICAgUGllTW9kdWxlXG4gICk7XG4gIHNoYXJlZC5TZXJ2aWNlUmVnaXN0cnkucmVnaXN0ZXIoUGllKTtcbiAgcmV0dXJuIHsgc2hhcmVkLCBQaWUgfTtcbn1cbl9fbmFtZShjcmVhdGVQaWVTZXJ2aWNlcywgXCJjcmVhdGVQaWVTZXJ2aWNlc1wiKTtcblxuZXhwb3J0IHtcbiAgUGllTW9kdWxlLFxuICBjcmVhdGVQaWVTZXJ2aWNlc1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///88685\n')},71609:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ createPacketServices)\n/* harmony export */ });\n/* unused harmony export PacketModule */\n/* harmony import */ var _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19369);\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33394);\n\n\n// src/language/packet/module.ts\n\n\n// src/language/packet/tokenBuilder.ts\nvar PacketTokenBuilder = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidTokenBuilder */ .mR {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "PacketTokenBuilder");\n  }\n  constructor() {\n    super(["packet-beta"]);\n  }\n};\n\n// src/language/packet/module.ts\nvar PacketModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new PacketTokenBuilder(), "TokenBuilder"),\n    ValueConverter: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .CommonValueConverter */ .Tm(), "ValueConverter")\n  }\n};\nfunction createPacketServices(context = langium__WEBPACK_IMPORTED_MODULE_1__/* .EmptyFileSystem */ .DD) {\n  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultSharedCoreModule */ .uM)(context),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MermaidGeneratedSharedModule */ .sr\n  );\n  const Packet = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultCoreModule */ .tG)({ shared }),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .PacketGeneratedModule */ .AM,\n    PacketModule\n  );\n  shared.ServiceRegistry.register(Packet);\n  return { shared, Packet };\n}\n(0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(createPacketServices, "createPacketServices");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzE2MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTThCOztBQUU5QjtBQU1pQjs7QUFFakI7QUFDQSx1Q0FBdUMsc0ZBQTJCO0FBQ2xFO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFNO0FBQ3hDLG9DQUFvQyxxRUFBTSxXQUFXLCtFQUFvQjtBQUN6RTtBQUNBO0FBQ0Esd0NBQXdDLDhEQUFlO0FBQ3ZELGlCQUFpQix5REFBTTtBQUN2QixJQUFJLGdGQUE2QjtBQUNqQyxJQUFJLHVGQUE0QjtBQUNoQztBQUNBLGlCQUFpQix5REFBTTtBQUN2QixJQUFJLDBFQUF1QixHQUFHLFFBQVE7QUFDdEMsSUFBSSxnRkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUVBQU07O0FBS0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLUVRRkxGTU5FLm1qcz9iZDVhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUsXG4gIFBhY2tldEdlbmVyYXRlZE1vZHVsZSxcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLVkyN01RWjNVLm1qc1wiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGFja2V0L21vZHVsZS50c1xuaW1wb3J0IHtcbiAgRW1wdHlGaWxlU3lzdGVtLFxuICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSxcbiAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUsXG4gIGluamVjdFxufSBmcm9tIFwibGFuZ2l1bVwiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGFja2V0L3Rva2VuQnVpbGRlci50c1xudmFyIFBhY2tldFRva2VuQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJQYWNrZXRUb2tlbkJ1aWxkZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW1wicGFja2V0LWJldGFcIl0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGFja2V0L21vZHVsZS50c1xudmFyIFBhY2tldE1vZHVsZSA9IHtcbiAgcGFyc2VyOiB7XG4gICAgVG9rZW5CdWlsZGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBQYWNrZXRUb2tlbkJ1aWxkZXIoKSwgXCJUb2tlbkJ1aWxkZXJcIiksXG4gICAgVmFsdWVDb252ZXJ0ZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IENvbW1vblZhbHVlQ29udmVydGVyKCksIFwiVmFsdWVDb252ZXJ0ZXJcIilcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVBhY2tldFNlcnZpY2VzKGNvbnRleHQgPSBFbXB0eUZpbGVTeXN0ZW0pIHtcbiAgY29uc3Qgc2hhcmVkID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKGNvbnRleHQpLFxuICAgIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGVcbiAgKTtcbiAgY29uc3QgUGFja2V0ID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKHsgc2hhcmVkIH0pLFxuICAgIFBhY2tldEdlbmVyYXRlZE1vZHVsZSxcbiAgICBQYWNrZXRNb2R1bGVcbiAgKTtcbiAgc2hhcmVkLlNlcnZpY2VSZWdpc3RyeS5yZWdpc3RlcihQYWNrZXQpO1xuICByZXR1cm4geyBzaGFyZWQsIFBhY2tldCB9O1xufVxuX19uYW1lKGNyZWF0ZVBhY2tldFNlcnZpY2VzLCBcImNyZWF0ZVBhY2tldFNlcnZpY2VzXCIpO1xuXG5leHBvcnQge1xuICBQYWNrZXRNb2R1bGUsXG4gIGNyZWF0ZVBhY2tldFNlcnZpY2VzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///71609\n')},49936:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: () => (/* binding */ createArchitectureServices)\n/* harmony export */ });\n/* unused harmony export ArchitectureModule */\n/* harmony import */ var _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19369);\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33394);\n\n\n// src/language/architecture/module.ts\n\n\n// src/language/architecture/tokenBuilder.ts\nvar ArchitectureTokenBuilder = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidTokenBuilder */ .mR {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "ArchitectureTokenBuilder");\n  }\n  constructor() {\n    super(["architecture"]);\n  }\n};\n\n// src/language/architecture/valueConverter.ts\nvar ArchitectureValueConverter = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidValueConverter */ .dg {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "ArchitectureValueConverter");\n  }\n  runCustomConverter(rule, input, _cstNode) {\n    if (rule.name === "ARCH_ICON") {\n      return input.replace(/[()]/g, "").trim();\n    } else if (rule.name === "ARCH_TEXT_ICON") {\n      return input.replace(/["()]/g, "");\n    } else if (rule.name === "ARCH_TITLE") {\n      return input.replace(/[[\\]]/g, "").trim();\n    }\n    return void 0;\n  }\n};\n\n// src/language/architecture/module.ts\nvar ArchitectureModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new ArchitectureTokenBuilder(), "TokenBuilder"),\n    ValueConverter: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new ArchitectureValueConverter(), "ValueConverter")\n  }\n};\nfunction createArchitectureServices(context = langium__WEBPACK_IMPORTED_MODULE_1__/* .EmptyFileSystem */ .DD) {\n  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultSharedCoreModule */ .uM)(context),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MermaidGeneratedSharedModule */ .sr\n  );\n  const Architecture = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultCoreModule */ .tG)({ shared }),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .ArchitectureGeneratedModule */ .jE,\n    ArchitectureModule\n  );\n  shared.ServiceRegistry.register(Architecture);\n  return { shared, Architecture };\n}\n(0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(createArchitectureServices, "createArchitectureServices");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk5MzYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTThCOztBQUU5QjtBQU1pQjs7QUFFakI7QUFDQSw2Q0FBNkMsc0ZBQTJCO0FBQ3hFO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0Msd0ZBQTZCO0FBQzVFO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFNO0FBQ3hDLG9DQUFvQyxxRUFBTTtBQUMxQztBQUNBO0FBQ0EsOENBQThDLDhEQUFlO0FBQzdELGlCQUFpQix5REFBTTtBQUN2QixJQUFJLGdGQUE2QjtBQUNqQyxJQUFJLHVGQUE0QjtBQUNoQztBQUNBLHVCQUF1Qix5REFBTTtBQUM3QixJQUFJLDBFQUF1QixHQUFHLFFBQVE7QUFDdEMsSUFBSSxzRkFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUVBQU07O0FBS0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLUZGN0JRWE9ILm1qcz84M2RlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQWJzdHJhY3RNZXJtYWlkVmFsdWVDb252ZXJ0ZXIsXG4gIEFyY2hpdGVjdHVyZUdlbmVyYXRlZE1vZHVsZSxcbiAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZSxcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLVkyN01RWjNVLm1qc1wiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvYXJjaGl0ZWN0dXJlL21vZHVsZS50c1xuaW1wb3J0IHtcbiAgRW1wdHlGaWxlU3lzdGVtLFxuICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSxcbiAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUsXG4gIGluamVjdFxufSBmcm9tIFwibGFuZ2l1bVwiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvYXJjaGl0ZWN0dXJlL3Rva2VuQnVpbGRlci50c1xudmFyIEFyY2hpdGVjdHVyZVRva2VuQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJBcmNoaXRlY3R1cmVUb2tlbkJ1aWxkZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW1wiYXJjaGl0ZWN0dXJlXCJdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2FyY2hpdGVjdHVyZS92YWx1ZUNvbnZlcnRlci50c1xudmFyIEFyY2hpdGVjdHVyZVZhbHVlQ29udmVydGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQXJjaGl0ZWN0dXJlVmFsdWVDb252ZXJ0ZXJcIik7XG4gIH1cbiAgcnVuQ3VzdG9tQ29udmVydGVyKHJ1bGUsIGlucHV0LCBfY3N0Tm9kZSkge1xuICAgIGlmIChydWxlLm5hbWUgPT09IFwiQVJDSF9JQ09OXCIpIHtcbiAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bKCldL2csIFwiXCIpLnRyaW0oKTtcbiAgICB9IGVsc2UgaWYgKHJ1bGUubmFtZSA9PT0gXCJBUkNIX1RFWFRfSUNPTlwiKSB7XG4gICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvW1wiKCldL2csIFwiXCIpO1xuICAgIH0gZWxzZSBpZiAocnVsZS5uYW1lID09PSBcIkFSQ0hfVElUTEVcIikge1xuICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1tbXFxdXS9nLCBcIlwiKS50cmltKCk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS9hcmNoaXRlY3R1cmUvbW9kdWxlLnRzXG52YXIgQXJjaGl0ZWN0dXJlTW9kdWxlID0ge1xuICBwYXJzZXI6IHtcbiAgICBUb2tlbkJ1aWxkZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IEFyY2hpdGVjdHVyZVRva2VuQnVpbGRlcigpLCBcIlRva2VuQnVpbGRlclwiKSxcbiAgICBWYWx1ZUNvbnZlcnRlcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgQXJjaGl0ZWN0dXJlVmFsdWVDb252ZXJ0ZXIoKSwgXCJWYWx1ZUNvbnZlcnRlclwiKVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXMoY29udGV4dCA9IEVtcHR5RmlsZVN5c3RlbSkge1xuICBjb25zdCBzaGFyZWQgPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUoY29udGV4dCksXG4gICAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZVxuICApO1xuICBjb25zdCBBcmNoaXRlY3R1cmUgPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksXG4gICAgQXJjaGl0ZWN0dXJlR2VuZXJhdGVkTW9kdWxlLFxuICAgIEFyY2hpdGVjdHVyZU1vZHVsZVxuICApO1xuICBzaGFyZWQuU2VydmljZVJlZ2lzdHJ5LnJlZ2lzdGVyKEFyY2hpdGVjdHVyZSk7XG4gIHJldHVybiB7IHNoYXJlZCwgQXJjaGl0ZWN0dXJlIH07XG59XG5fX25hbWUoY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXMsIFwiY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXNcIik7XG5cbmV4cG9ydCB7XG4gIEFyY2hpdGVjdHVyZU1vZHVsZSxcbiAgY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49936\n')},82785:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   b: () => (/* binding */ createGitGraphServices)\n/* harmony export */ });\n/* unused harmony export GitGraphModule */\n/* harmony import */ var _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19369);\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33394);\n\n\n// src/language/gitGraph/module.ts\n\n\n// src/language/gitGraph/tokenBuilder.ts\nvar GitGraphTokenBuilder = class extends _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .AbstractMermaidTokenBuilder */ .mR {\n  static {\n    (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(this, "GitGraphTokenBuilder");\n  }\n  constructor() {\n    super(["gitGraph"]);\n  }\n};\n\n// src/language/gitGraph/module.ts\nvar GitGraphModule = {\n  parser: {\n    TokenBuilder: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new GitGraphTokenBuilder(), "TokenBuilder"),\n    ValueConverter: /* @__PURE__ */ (0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(() => new _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .CommonValueConverter */ .Tm(), "ValueConverter")\n  }\n};\nfunction createGitGraphServices(context = langium__WEBPACK_IMPORTED_MODULE_1__/* .EmptyFileSystem */ .DD) {\n  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultSharedCoreModule */ .uM)(context),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .MermaidGeneratedSharedModule */ .sr\n  );\n  const GitGraph = (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .inject */ .WQ)(\n    (0,langium__WEBPACK_IMPORTED_MODULE_1__/* .createDefaultCoreModule */ .tG)({ shared }),\n    _chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .GitGraphGeneratedModule */ .eZ,\n    GitGraphModule\n  );\n  shared.ServiceRegistry.register(GitGraph);\n  return { shared, GitGraph };\n}\n(0,_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_0__/* .__name */ .K2)(createGitGraphServices, "createGitGraphServices");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI3ODUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBTThCOztBQUU5QjtBQU1pQjs7QUFFakI7QUFDQSx5Q0FBeUMsc0ZBQTJCO0FBQ3BFO0FBQ0EsSUFBSSxxRUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFFQUFNO0FBQ3hDLG9DQUFvQyxxRUFBTSxXQUFXLCtFQUFvQjtBQUN6RTtBQUNBO0FBQ0EsMENBQTBDLDhEQUFlO0FBQ3pELGlCQUFpQix5REFBTTtBQUN2QixJQUFJLGdGQUE2QjtBQUNqQyxJQUFJLHVGQUE0QjtBQUNoQztBQUNBLG1CQUFtQix5REFBTTtBQUN6QixJQUFJLDBFQUF1QixHQUFHLFFBQVE7QUFDdEMsSUFBSSxrRkFBdUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EscUVBQU07O0FBS0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLU5DTUZUVFVXLm1qcz84YzZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIEdpdEdyYXBoR2VuZXJhdGVkTW9kdWxlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBfX25hbWVcbn0gZnJvbSBcIi4vY2h1bmstWTI3TVFaM1UubWpzXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9naXRHcmFwaC9tb2R1bGUudHNcbmltcG9ydCB7XG4gIGluamVjdCxcbiAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUsXG4gIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlLFxuICBFbXB0eUZpbGVTeXN0ZW1cbn0gZnJvbSBcImxhbmdpdW1cIjtcblxuLy8gc3JjL2xhbmd1YWdlL2dpdEdyYXBoL3Rva2VuQnVpbGRlci50c1xudmFyIEdpdEdyYXBoVG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkdpdEdyYXBoVG9rZW5CdWlsZGVyXCIpO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFtcImdpdEdyYXBoXCJdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2dpdEdyYXBoL21vZHVsZS50c1xudmFyIEdpdEdyYXBoTW9kdWxlID0ge1xuICBwYXJzZXI6IHtcbiAgICBUb2tlbkJ1aWxkZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IEdpdEdyYXBoVG9rZW5CdWlsZGVyKCksIFwiVG9rZW5CdWlsZGVyXCIpLFxuICAgIFZhbHVlQ29udmVydGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBDb21tb25WYWx1ZUNvbnZlcnRlcigpLCBcIlZhbHVlQ29udmVydGVyXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzKGNvbnRleHQgPSBFbXB0eUZpbGVTeXN0ZW0pIHtcbiAgY29uc3Qgc2hhcmVkID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKGNvbnRleHQpLFxuICAgIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGVcbiAgKTtcbiAgY29uc3QgR2l0R3JhcGggPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksXG4gICAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gICAgR2l0R3JhcGhNb2R1bGVcbiAgKTtcbiAgc2hhcmVkLlNlcnZpY2VSZWdpc3RyeS5yZWdpc3RlcihHaXRHcmFwaCk7XG4gIHJldHVybiB7IHNoYXJlZCwgR2l0R3JhcGggfTtcbn1cbl9fbmFtZShjcmVhdGVHaXRHcmFwaFNlcnZpY2VzLCBcImNyZWF0ZUdpdEdyYXBoU2VydmljZXNcIik7XG5cbmV4cG9ydCB7XG4gIEdpdEdyYXBoTW9kdWxlLFxuICBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///82785\n')},19369:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AM: () => (/* binding */ PacketGeneratedModule),\n/* harmony export */   K2: () => (/* binding */ __name),\n/* harmony export */   KX: () => (/* binding */ PieGeneratedModule),\n/* harmony export */   Tm: () => (/* binding */ CommonValueConverter),\n/* harmony export */   dg: () => (/* binding */ AbstractMermaidValueConverter),\n/* harmony export */   e5: () => (/* binding */ InfoGeneratedModule),\n/* harmony export */   eZ: () => (/* binding */ GitGraphGeneratedModule),\n/* harmony export */   jE: () => (/* binding */ ArchitectureGeneratedModule),\n/* harmony export */   mR: () => (/* binding */ AbstractMermaidTokenBuilder),\n/* harmony export */   sr: () => (/* binding */ MermaidGeneratedSharedModule)\n/* harmony export */ });\n/* unused harmony exports Statement, Architecture, isArchitecture, Branch, isBranch, Commit, isCommit, isCommon, GitGraph, isGitGraph, Info, isInfo, Merge, isMerge, Packet, isPacket, PacketBlock, isPacketBlock, Pie, isPie, PieSection, isPieSection, CommonTokenBuilder */\n/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33394);\nvar __defProp = Object.defineProperty;\nvar __name = (target, value) => __defProp(target, "name", { value, configurable: true });\n\n// src/language/generated/ast.ts\n\nvar Statement = "Statement";\nvar Architecture = "Architecture";\nfunction isArchitecture(item) {\n  return reflection.isInstance(item, Architecture);\n}\n__name(isArchitecture, "isArchitecture");\nvar Branch = "Branch";\nfunction isBranch(item) {\n  return reflection.isInstance(item, Branch);\n}\n__name(isBranch, "isBranch");\nvar Checkout = "Checkout";\nvar CherryPicking = "CherryPicking";\nvar Commit = "Commit";\nfunction isCommit(item) {\n  return reflection.isInstance(item, Commit);\n}\n__name(isCommit, "isCommit");\nvar Common = "Common";\nfunction isCommon(item) {\n  return reflection.isInstance(item, Common);\n}\n__name(isCommon, "isCommon");\nvar GitGraph = "GitGraph";\nfunction isGitGraph(item) {\n  return reflection.isInstance(item, GitGraph);\n}\n__name(isGitGraph, "isGitGraph");\nvar Info = "Info";\nfunction isInfo(item) {\n  return reflection.isInstance(item, Info);\n}\n__name(isInfo, "isInfo");\nvar Merge = "Merge";\nfunction isMerge(item) {\n  return reflection.isInstance(item, Merge);\n}\n__name(isMerge, "isMerge");\nvar Packet = "Packet";\nfunction isPacket(item) {\n  return reflection.isInstance(item, Packet);\n}\n__name(isPacket, "isPacket");\nvar PacketBlock = "PacketBlock";\nfunction isPacketBlock(item) {\n  return reflection.isInstance(item, PacketBlock);\n}\n__name(isPacketBlock, "isPacketBlock");\nvar Pie = "Pie";\nfunction isPie(item) {\n  return reflection.isInstance(item, Pie);\n}\n__name(isPie, "isPie");\nvar PieSection = "PieSection";\nfunction isPieSection(item) {\n  return reflection.isInstance(item, PieSection);\n}\n__name(isPieSection, "isPieSection");\nvar Direction = "Direction";\nvar MermaidAstReflection = class extends langium__WEBPACK_IMPORTED_MODULE_0__/* .AbstractAstReflection */ .kD {\n  static {\n    __name(this, "MermaidAstReflection");\n  }\n  getAllTypes() {\n    return ["Architecture", "Branch", "Checkout", "CherryPicking", "Commit", "Common", "Direction", "Edge", "GitGraph", "Group", "Info", "Junction", "Merge", "Packet", "PacketBlock", "Pie", "PieSection", "Service", "Statement"];\n  }\n  computeIsSubtype(subtype, supertype) {\n    switch (subtype) {\n      case Branch:\n      case Checkout:\n      case CherryPicking:\n      case Commit:\n      case Merge: {\n        return this.isSubtype(Statement, supertype);\n      }\n      case Direction: {\n        return this.isSubtype(GitGraph, supertype);\n      }\n      default: {\n        return false;\n      }\n    }\n  }\n  getReferenceType(refInfo) {\n    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n    switch (referenceId) {\n      default: {\n        throw new Error(`${referenceId} is not a valid reference id.`);\n      }\n    }\n  }\n  getTypeMetaData(type) {\n    switch (type) {\n      case "Architecture": {\n        return {\n          name: "Architecture",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "edges", defaultValue: [] },\n            { name: "groups", defaultValue: [] },\n            { name: "junctions", defaultValue: [] },\n            { name: "services", defaultValue: [] },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Branch": {\n        return {\n          name: "Branch",\n          properties: [\n            { name: "name" },\n            { name: "order" }\n          ]\n        };\n      }\n      case "Checkout": {\n        return {\n          name: "Checkout",\n          properties: [\n            { name: "branch" }\n          ]\n        };\n      }\n      case "CherryPicking": {\n        return {\n          name: "CherryPicking",\n          properties: [\n            { name: "id" },\n            { name: "parent" },\n            { name: "tags", defaultValue: [] }\n          ]\n        };\n      }\n      case "Commit": {\n        return {\n          name: "Commit",\n          properties: [\n            { name: "id" },\n            { name: "message" },\n            { name: "tags", defaultValue: [] },\n            { name: "type" }\n          ]\n        };\n      }\n      case "Common": {\n        return {\n          name: "Common",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Edge": {\n        return {\n          name: "Edge",\n          properties: [\n            { name: "lhsDir" },\n            { name: "lhsGroup", defaultValue: false },\n            { name: "lhsId" },\n            { name: "lhsInto", defaultValue: false },\n            { name: "rhsDir" },\n            { name: "rhsGroup", defaultValue: false },\n            { name: "rhsId" },\n            { name: "rhsInto", defaultValue: false },\n            { name: "title" }\n          ]\n        };\n      }\n      case "GitGraph": {\n        return {\n          name: "GitGraph",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "statements", defaultValue: [] },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Group": {\n        return {\n          name: "Group",\n          properties: [\n            { name: "icon" },\n            { name: "id" },\n            { name: "in" },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Info": {\n        return {\n          name: "Info",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Junction": {\n        return {\n          name: "Junction",\n          properties: [\n            { name: "id" },\n            { name: "in" }\n          ]\n        };\n      }\n      case "Merge": {\n        return {\n          name: "Merge",\n          properties: [\n            { name: "branch" },\n            { name: "id" },\n            { name: "tags", defaultValue: [] },\n            { name: "type" }\n          ]\n        };\n      }\n      case "Packet": {\n        return {\n          name: "Packet",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "blocks", defaultValue: [] },\n            { name: "title" }\n          ]\n        };\n      }\n      case "PacketBlock": {\n        return {\n          name: "PacketBlock",\n          properties: [\n            { name: "end" },\n            { name: "label" },\n            { name: "start" }\n          ]\n        };\n      }\n      case "Pie": {\n        return {\n          name: "Pie",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "sections", defaultValue: [] },\n            { name: "showData", defaultValue: false },\n            { name: "title" }\n          ]\n        };\n      }\n      case "PieSection": {\n        return {\n          name: "PieSection",\n          properties: [\n            { name: "label" },\n            { name: "value" }\n          ]\n        };\n      }\n      case "Service": {\n        return {\n          name: "Service",\n          properties: [\n            { name: "icon" },\n            { name: "iconText" },\n            { name: "id" },\n            { name: "in" },\n            { name: "title" }\n          ]\n        };\n      }\n      case "Direction": {\n        return {\n          name: "Direction",\n          properties: [\n            { name: "accDescr" },\n            { name: "accTitle" },\n            { name: "dir" },\n            { name: "statements", defaultValue: [] },\n            { name: "title" }\n          ]\n        };\n      }\n      default: {\n        return {\n          name: type,\n          properties: []\n        };\n      }\n    }\n  }\n};\nvar reflection = new MermaidAstReflection();\n\n// src/language/generated/grammar.ts\n\nvar loadedInfoGrammar;\nvar InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_0__/* .loadGrammarFromJson */ .y0)(\'{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","name":"Info","entry":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"TitleAndAccessibilities","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"EOL","fragment":true,"dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\r?\\\\\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}\')), "InfoGrammar");\nvar loadedPacketGrammar;\nvar PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_0__/* .loadGrammarFromJson */ .y0)(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","name":"Packet","entry":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"packet-beta"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"+"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"?"},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","definition":{"$type":"RegexToken","regex":"/\\\\"[^\\\\"]*\\\\"|\'[^\']*\'/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"TitleAndAccessibilities","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"EOL","fragment":true,"dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\r?\\\\\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}`)), "PacketGrammar");\nvar loadedPieGrammar;\nvar PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_0__/* .loadGrammarFromJson */ .y0)(\'{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","name":"Pie","entry":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"+"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"PIE_SECTION_LABEL","definition":{"$type":"RegexToken","regex":"/\\\\"[^\\\\"]+\\\\"/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"PIE_SECTION_VALUE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/(0|[1-9][0-9]*)(\\\\\\\\.[0-9]+)?/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"TitleAndAccessibilities","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"EOL","fragment":true,"dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\r?\\\\\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}\')), "PieGrammar");\nvar loadedArchitectureGrammar;\nvar ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_0__/* .loadGrammarFromJson */ .y0)(\'{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","name":"Architecture","entry":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","fragment":true,"definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"LeftPort","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"RightPort","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Arrow","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_ID","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\w]+/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TEXT_ICON","definition":{"$type":"RegexToken","regex":"/\\\\\\\\(\\\\"[^\\\\"]+\\\\"\\\\\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\\\\\([\\\\\\\\w-:]+\\\\\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\[[\\\\\\\\w ]+\\\\\\\\]/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\\\\\{group\\\\\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"TitleAndAccessibilities","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"EOL","fragment":true,"dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\r?\\\\\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}\')), "ArchitectureGrammar");\nvar loadedGitGraphGrammar;\nvar GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_0__/* .loadGrammarFromJson */ .y0)(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"rules":[{"$type":"ParserRule","name":"TitleAndAccessibilities","fragment":true,"definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"EOL","fragment":true,"dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\\\\\r?\\\\\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accDescr(?:[\\\\\\\\t ]*:([^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)|\\\\\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*accTitle[\\\\\\\\t ]*:(?:[^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[^\\\\\\\\n\\\\\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*title(?:[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*?(?=%%)|[\\\\\\\\t ][^\\\\\\\\n\\\\\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\\\\\t ]*\\\\\\\\r?\\\\\\\\n(?:[\\\\\\\\S\\\\\\\\s]*?\\\\\\\\r?\\\\\\\\n)?---(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%{[\\\\\\\\S\\\\\\\\s]*?}%%(?:\\\\\\\\r?\\\\\\\\n|(?!\\\\\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\\\\\t ]*%%[^\\\\\\\\n\\\\\\\\r]*/"},"fragment":false},{"$type":"ParserRule","name":"GitGraph","entry":true,"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+(?=\\\\\\\\s)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\\\\\w([-\\\\\\\\./\\\\\\\\w]*[-\\\\\\\\w])?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","definition":{"$type":"RegexToken","regex":"/\\\\"[^\\\\"]*\\\\"|\'[^\']*\'/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar");\n\n// src/language/generated/module.ts\nvar InfoLanguageMetaData = {\n  languageId: "info",\n  fileExtensions: [".mmd", ".mermaid"],\n  caseInsensitive: false\n};\nvar PacketLanguageMetaData = {\n  languageId: "packet",\n  fileExtensions: [".mmd", ".mermaid"],\n  caseInsensitive: false\n};\nvar PieLanguageMetaData = {\n  languageId: "pie",\n  fileExtensions: [".mmd", ".mermaid"],\n  caseInsensitive: false\n};\nvar ArchitectureLanguageMetaData = {\n  languageId: "architecture",\n  fileExtensions: [".mmd", ".mermaid"],\n  caseInsensitive: false\n};\nvar GitGraphLanguageMetaData = {\n  languageId: "gitGraph",\n  fileExtensions: [".mmd", ".mermaid"],\n  caseInsensitive: false\n};\nvar MermaidGeneratedSharedModule = {\n  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), "AstReflection")\n};\nvar InfoGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), "Grammar"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, "LanguageMetaData"),\n  parser: {}\n};\nvar PacketGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), "Grammar"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, "LanguageMetaData"),\n  parser: {}\n};\nvar PieGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), "Grammar"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, "LanguageMetaData"),\n  parser: {}\n};\nvar ArchitectureGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), "Grammar"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, "LanguageMetaData"),\n  parser: {}\n};\nvar GitGraphGeneratedModule = {\n  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), "Grammar"),\n  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, "LanguageMetaData"),\n  parser: {}\n};\n\n// src/language/common/valueConverter.ts\n\n\n// src/language/common/matcher.ts\nvar accessibilityDescrRegex = /accDescr(?:[\\t ]*:([^\\n\\r]*)|\\s*{([^}]*)})/;\nvar accessibilityTitleRegex = /accTitle[\\t ]*:([^\\n\\r]*)/;\nvar titleRegex = /title([\\t ][^\\n\\r]*|)/;\n\n// src/language/common/valueConverter.ts\nvar rulesRegexes = {\n  ACC_DESCR: accessibilityDescrRegex,\n  ACC_TITLE: accessibilityTitleRegex,\n  TITLE: titleRegex\n};\nvar AbstractMermaidValueConverter = class extends langium__WEBPACK_IMPORTED_MODULE_0__/* .DefaultValueConverter */ .dM {\n  static {\n    __name(this, "AbstractMermaidValueConverter");\n  }\n  runConverter(rule, input, cstNode) {\n    let value = this.runCommonConverter(rule, input, cstNode);\n    if (value === void 0) {\n      value = this.runCustomConverter(rule, input, cstNode);\n    }\n    if (value === void 0) {\n      return super.runConverter(rule, input, cstNode);\n    }\n    return value;\n  }\n  runCommonConverter(rule, input, _cstNode) {\n    const regex = rulesRegexes[rule.name];\n    if (regex === void 0) {\n      return void 0;\n    }\n    const match = regex.exec(input);\n    if (match === null) {\n      return void 0;\n    }\n    if (match[1] !== void 0) {\n      return match[1].trim().replace(/[\\t ]{2,}/gm, " ");\n    }\n    if (match[2] !== void 0) {\n      return match[2].replace(/^\\s*/gm, "").replace(/\\s+$/gm, "").replace(/[\\t ]{2,}/gm, " ").replace(/[\\n\\r]{2,}/gm, "\\n");\n    }\n    return void 0;\n  }\n};\nvar CommonValueConverter = class extends AbstractMermaidValueConverter {\n  static {\n    __name(this, "CommonValueConverter");\n  }\n  runCustomConverter(_rule, _input, _cstNode) {\n    return void 0;\n  }\n};\n\n// src/language/common/tokenBuilder.ts\n\nvar AbstractMermaidTokenBuilder = class extends langium__WEBPACK_IMPORTED_MODULE_0__/* .DefaultTokenBuilder */ .QU {\n  static {\n    __name(this, "AbstractMermaidTokenBuilder");\n  }\n  constructor(keywords) {\n    super();\n    this.keywords = new Set(keywords);\n  }\n  buildKeywordTokens(rules, terminalTokens, options) {\n    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);\n    tokenTypes.forEach((tokenType) => {\n      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {\n        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + "(?:(?=%%)|(?!\\\\S))");\n      }\n    });\n    return tokenTypes;\n  }\n};\nvar CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {\n  static {\n    __name(this, "CommonTokenBuilder");\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRztBQUMvQztBQUNBO0FBQ0EsaUZBQWlGLEdBQUcsMEJBQTBCLEdBQUc7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDO0FBQzlDLGdEQUFnRCxrRUFBbUI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFvQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLVkyN01RWjNVLm1qcz9mMTk1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbi8vIHNyYy9sYW5ndWFnZS9nZW5lcmF0ZWQvYXN0LnRzXG5pbXBvcnQgeyBBYnN0cmFjdEFzdFJlZmxlY3Rpb24gfSBmcm9tIFwibGFuZ2l1bVwiO1xudmFyIFN0YXRlbWVudCA9IFwiU3RhdGVtZW50XCI7XG52YXIgQXJjaGl0ZWN0dXJlID0gXCJBcmNoaXRlY3R1cmVcIjtcbmZ1bmN0aW9uIGlzQXJjaGl0ZWN0dXJlKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBcmNoaXRlY3R1cmUpO1xufVxuX19uYW1lKGlzQXJjaGl0ZWN0dXJlLCBcImlzQXJjaGl0ZWN0dXJlXCIpO1xudmFyIEJyYW5jaCA9IFwiQnJhbmNoXCI7XG5mdW5jdGlvbiBpc0JyYW5jaChpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQnJhbmNoKTtcbn1cbl9fbmFtZShpc0JyYW5jaCwgXCJpc0JyYW5jaFwiKTtcbnZhciBDaGVja291dCA9IFwiQ2hlY2tvdXRcIjtcbnZhciBDaGVycnlQaWNraW5nID0gXCJDaGVycnlQaWNraW5nXCI7XG52YXIgQ29tbWl0ID0gXCJDb21taXRcIjtcbmZ1bmN0aW9uIGlzQ29tbWl0KGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBDb21taXQpO1xufVxuX19uYW1lKGlzQ29tbWl0LCBcImlzQ29tbWl0XCIpO1xudmFyIENvbW1vbiA9IFwiQ29tbW9uXCI7XG5mdW5jdGlvbiBpc0NvbW1vbihpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29tbW9uKTtcbn1cbl9fbmFtZShpc0NvbW1vbiwgXCJpc0NvbW1vblwiKTtcbnZhciBHaXRHcmFwaCA9IFwiR2l0R3JhcGhcIjtcbmZ1bmN0aW9uIGlzR2l0R3JhcGgoaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEdpdEdyYXBoKTtcbn1cbl9fbmFtZShpc0dpdEdyYXBoLCBcImlzR2l0R3JhcGhcIik7XG52YXIgSW5mbyA9IFwiSW5mb1wiO1xuZnVuY3Rpb24gaXNJbmZvKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBJbmZvKTtcbn1cbl9fbmFtZShpc0luZm8sIFwiaXNJbmZvXCIpO1xudmFyIE1lcmdlID0gXCJNZXJnZVwiO1xuZnVuY3Rpb24gaXNNZXJnZShpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTWVyZ2UpO1xufVxuX19uYW1lKGlzTWVyZ2UsIFwiaXNNZXJnZVwiKTtcbnZhciBQYWNrZXQgPSBcIlBhY2tldFwiO1xuZnVuY3Rpb24gaXNQYWNrZXQoaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBhY2tldCk7XG59XG5fX25hbWUoaXNQYWNrZXQsIFwiaXNQYWNrZXRcIik7XG52YXIgUGFja2V0QmxvY2sgPSBcIlBhY2tldEJsb2NrXCI7XG5mdW5jdGlvbiBpc1BhY2tldEJsb2NrKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQYWNrZXRCbG9jayk7XG59XG5fX25hbWUoaXNQYWNrZXRCbG9jaywgXCJpc1BhY2tldEJsb2NrXCIpO1xudmFyIFBpZSA9IFwiUGllXCI7XG5mdW5jdGlvbiBpc1BpZShpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUGllKTtcbn1cbl9fbmFtZShpc1BpZSwgXCJpc1BpZVwiKTtcbnZhciBQaWVTZWN0aW9uID0gXCJQaWVTZWN0aW9uXCI7XG5mdW5jdGlvbiBpc1BpZVNlY3Rpb24oaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBpZVNlY3Rpb24pO1xufVxuX19uYW1lKGlzUGllU2VjdGlvbiwgXCJpc1BpZVNlY3Rpb25cIik7XG52YXIgRGlyZWN0aW9uID0gXCJEaXJlY3Rpb25cIjtcbnZhciBNZXJtYWlkQXN0UmVmbGVjdGlvbiA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJNZXJtYWlkQXN0UmVmbGVjdGlvblwiKTtcbiAgfVxuICBnZXRBbGxUeXBlcygpIHtcbiAgICByZXR1cm4gW1wiQXJjaGl0ZWN0dXJlXCIsIFwiQnJhbmNoXCIsIFwiQ2hlY2tvdXRcIiwgXCJDaGVycnlQaWNraW5nXCIsIFwiQ29tbWl0XCIsIFwiQ29tbW9uXCIsIFwiRGlyZWN0aW9uXCIsIFwiRWRnZVwiLCBcIkdpdEdyYXBoXCIsIFwiR3JvdXBcIiwgXCJJbmZvXCIsIFwiSnVuY3Rpb25cIiwgXCJNZXJnZVwiLCBcIlBhY2tldFwiLCBcIlBhY2tldEJsb2NrXCIsIFwiUGllXCIsIFwiUGllU2VjdGlvblwiLCBcIlNlcnZpY2VcIiwgXCJTdGF0ZW1lbnRcIl07XG4gIH1cbiAgY29tcHV0ZUlzU3VidHlwZShzdWJ0eXBlLCBzdXBlcnR5cGUpIHtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQnJhbmNoOlxuICAgICAgY2FzZSBDaGVja291dDpcbiAgICAgIGNhc2UgQ2hlcnJ5UGlja2luZzpcbiAgICAgIGNhc2UgQ29tbWl0OlxuICAgICAgY2FzZSBNZXJnZToge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoU3RhdGVtZW50LCBzdXBlcnR5cGUpO1xuICAgICAgfVxuICAgICAgY2FzZSBEaXJlY3Rpb246IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEdpdEdyYXBoLCBzdXBlcnR5cGUpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFJlZmVyZW5jZVR5cGUocmVmSW5mbykge1xuICAgIGNvbnN0IHJlZmVyZW5jZUlkID0gYCR7cmVmSW5mby5jb250YWluZXIuJHR5cGV9OiR7cmVmSW5mby5wcm9wZXJ0eX1gO1xuICAgIHN3aXRjaCAocmVmZXJlbmNlSWQpIHtcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JlZmVyZW5jZUlkfSBpcyBub3QgYSB2YWxpZCByZWZlcmVuY2UgaWQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFR5cGVNZXRhRGF0YSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiQXJjaGl0ZWN0dXJlXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcIkFyY2hpdGVjdHVyZVwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NEZXNjclwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjVGl0bGVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImVkZ2VzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJncm91cHNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImp1bmN0aW9uc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwic2VydmljZXNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJCcmFuY2hcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiQnJhbmNoXCIsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIm9yZGVyXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJDaGVja291dFwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJDaGVja291dFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJicmFuY2hcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIkNoZXJyeVBpY2tpbmdcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiQ2hlcnJ5UGlja2luZ1wiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJpZFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwicGFyZW50XCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0YWdzXCIsIGRlZmF1bHRWYWx1ZTogW10gfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJDb21taXRcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiQ29tbWl0XCIsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJtZXNzYWdlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0YWdzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0eXBlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJDb21tb25cIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiQ29tbW9uXCIsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImFjY0Rlc2NyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NUaXRsZVwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwidGl0bGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIkVkZ2VcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiRWRnZVwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJsaHNEaXJcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImxoc0dyb3VwXCIsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJsaHNJZFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwibGhzSW50b1wiLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwicmhzRGlyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJyaHNHcm91cFwiLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwicmhzSWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInJoc0ludG9cIiwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJHaXRHcmFwaFwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJHaXRHcmFwaFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NEZXNjclwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjVGl0bGVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInN0YXRlbWVudHNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJHcm91cFwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJHcm91cFwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJpY29uXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJpZFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiaW5cIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJbmZvXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcIkluZm9cIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwiSnVuY3Rpb25cIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiSnVuY3Rpb25cIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiaWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImluXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJNZXJnZVwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJNZXJnZVwiLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJicmFuY2hcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0YWdzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0eXBlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJQYWNrZXRcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiUGFja2V0XCIsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImFjY0Rlc2NyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NUaXRsZVwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYmxvY2tzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFwiUGFja2V0QmxvY2tcIjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFwiUGFja2V0QmxvY2tcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiZW5kXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJsYWJlbFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwic3RhcnRcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIlBpZVwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJQaWVcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzZWN0aW9uc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwic2hvd0RhdGFcIiwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJQaWVTZWN0aW9uXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcIlBpZVNlY3Rpb25cIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwibGFiZWxcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInZhbHVlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJTZXJ2aWNlXCI6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBcIlNlcnZpY2VcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiaWNvblwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiaWNvblRleHRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJpblwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwidGl0bGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBcIkRpcmVjdGlvblwiOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogXCJEaXJlY3Rpb25cIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJkaXJcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInN0YXRlbWVudHNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJlZmxlY3Rpb24gPSBuZXcgTWVybWFpZEFzdFJlZmxlY3Rpb24oKTtcblxuLy8gc3JjL2xhbmd1YWdlL2dlbmVyYXRlZC9ncmFtbWFyLnRzXG5pbXBvcnQgeyBsb2FkR3JhbW1hckZyb21Kc29uIH0gZnJvbSBcImxhbmdpdW1cIjtcbnZhciBsb2FkZWRJbmZvR3JhbW1hcjtcbnZhciBJbmZvR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkSW5mb0dyYW1tYXIgPz8gKGxvYWRlZEluZm9HcmFtbWFyID0gbG9hZEdyYW1tYXJGcm9tSnNvbigne1wiJHR5cGVcIjpcIkdyYW1tYXJcIixcImlzRGVjbGFyZWRcIjp0cnVlLFwibmFtZVwiOlwiSW5mb1wiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkluZm9cIixcImVudHJ5XCI6dHJ1ZSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpbmZvXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInNob3dJbmZvXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dLFwiY2FyZGluYWxpdHlcIjpcIj9cIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiP1wifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlRpdGxlQW5kQWNjZXNzaWJpbGl0aWVzXCIsXCJmcmFnbWVudFwiOnRydWUsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjRGVzY3JcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY1RpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdfV0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJFT0xcIixcImZyYWdtZW50XCI6dHJ1ZSxcImRhdGFUeXBlXCI6XCJzdHJpbmdcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJFbmRPZkZpbGVcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIk5FV0xJTkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHI/XFxcXFxcXFxuL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX0RFU0NSXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY0Rlc2NyKD86W1xcXFxcXFxcdCBdKjooW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKil8XFxcXFxcXFxzKnsoW159XSopfSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjVGl0bGVbXFxcXFxcXFx0IF0qOig/OlteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qdGl0bGUoPzpbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qfCkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiV0hJVEVTUEFDRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSsvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIllBTUxcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8tLS1bXFxcXFxcXFx0IF0qXFxcXFxcXFxyP1xcXFxcXFxcbig/OltcXFxcXFxcXFNcXFxcXFxcXHNdKj9cXFxcXFxcXHI/XFxcXFxcXFxuKT8tLS0oPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJESVJFQ1RJVkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSV7W1xcXFxcXFxcU1xcXFxcXFxcc10qP30lJSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIlNJTkdMRV9MSU5FX0NPTU1FTlRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSVbXlxcXFxcXFxcblxcXFxcXFxccl0qL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJ0eXBlc1wiOltdLFwidXNlZEdyYW1tYXJzXCI6W119JykpLCBcIkluZm9HcmFtbWFyXCIpO1xudmFyIGxvYWRlZFBhY2tldEdyYW1tYXI7XG52YXIgUGFja2V0R3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkUGFja2V0R3JhbW1hciA/PyAobG9hZGVkUGFja2V0R3JhbW1hciA9IGxvYWRHcmFtbWFyRnJvbUpzb24oYHtcIiR0eXBlXCI6XCJHcmFtbWFyXCIsXCJpc0RlY2xhcmVkXCI6dHJ1ZSxcIm5hbWVcIjpcIlBhY2tldFwiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBhY2tldFwiLFwiZW50cnlcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInBhY2tldC1iZXRhXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDRcIn0sXCJhcmd1bWVudHNcIjpbXX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImJsb2Nrc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDZcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJibG9ja3NcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBhY2tldEJsb2NrXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic3RhcnRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImVuZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxhYmVsXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklOVFwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJudW1iZXJcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvMHxbMS05XVswLTldKi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlNUUklOR1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcIlteXFxcXFwiXSpcXFxcXCJ8J1teJ10qJy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJUaXRsZUFuZEFjY2Vzc2liaWxpdGllc1wiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY0Rlc2NyXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDdcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NUaXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A4XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAOVwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX1dLFwiY2FyZGluYWxpdHlcIjpcIitcIn0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiRU9MXCIsXCJmcmFnbWVudFwiOnRydWUsXCJkYXRhVHlwZVwiOlwic3RyaW5nXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSx7XCIkdHlwZVwiOlwiRW5kT2ZGaWxlXCJ9XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJORVdMSU5FXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFxcXFxyP1xcXFxcXFxcbi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19ERVNDUlwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NEZXNjcig/OltcXFxcXFxcXHQgXSo6KFteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopfFxcXFxcXFxccyp7KFtefV0qKX0pL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX1RJVExFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY1RpdGxlW1xcXFxcXFxcdCBdKjooPzpbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlRJVExFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKnRpdGxlKD86W1xcXFxcXFxcdCBdW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W1xcXFxcXFxcdCBdW15cXFxcXFxcXG5cXFxcXFxcXHJdKnwpL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIldISVRFU1BBQ0VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0rL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJZQU1MXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvLS0tW1xcXFxcXFxcdCBdKlxcXFxcXFxccj9cXFxcXFxcXG4oPzpbXFxcXFxcXFxTXFxcXFxcXFxzXSo/XFxcXFxcXFxyP1xcXFxcXFxcbik/LS0tKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiRElSRUNUSVZFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKiUle1tcXFxcXFxcXFNcXFxcXFxcXHNdKj99JSUoPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJTSU5HTEVfTElORV9DT01NRU5UXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKiUlW15cXFxcXFxcXG5cXFxcXFxcXHJdKi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfV0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcImludGVyZmFjZXNcIjpbe1wiJHR5cGVcIjpcIkludGVyZmFjZVwiLFwibmFtZVwiOlwiQ29tbW9uXCIsXCJhdHRyaWJ1dGVzXCI6W3tcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJhY2NEZXNjclwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX0se1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY1RpdGxlXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwidGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19XSxcInN1cGVyVHlwZXNcIjpbXX1dLFwidHlwZXNcIjpbXSxcInVzZWRHcmFtbWFyc1wiOltdfWApKSwgXCJQYWNrZXRHcmFtbWFyXCIpO1xudmFyIGxvYWRlZFBpZUdyYW1tYXI7XG52YXIgUGllR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkUGllR3JhbW1hciA/PyAobG9hZGVkUGllR3JhbW1hciA9IGxvYWRHcmFtbWFyRnJvbUpzb24oJ3tcIiR0eXBlXCI6XCJHcmFtbWFyXCIsXCJpc0RlY2xhcmVkXCI6dHJ1ZSxcIm5hbWVcIjpcIlBpZVwiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBpZVwiLFwiZW50cnlcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInBpZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2hvd0RhdGFcIixcIm9wZXJhdG9yXCI6XCI/PVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInNob3dEYXRhXCJ9LFwiY2FyZGluYWxpdHlcIjpcIj9cIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDZcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2VjdGlvbnNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiKlwifV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2VjdGlvbnNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBpZVNlY3Rpb25cIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsYWJlbFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInZhbHVlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlBJRV9TRUNUSU9OX0xBQkVMXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFwiW15cXFxcXCJdK1xcXFxcIi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlBJRV9TRUNUSU9OX1ZBTFVFXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcIm51bWJlclwifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8oMHxbMS05XVswLTldKikoXFxcXFxcXFwuWzAtOV0rKT8vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiVGl0bGVBbmRBY2Nlc3NpYmlsaXRpZXNcIixcImZyYWdtZW50XCI6dHJ1ZSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NEZXNjclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A3XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAOFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDlcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A1XCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkVPTFwiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIitcIn0se1wiJHR5cGVcIjpcIkVuZE9mRmlsZVwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTkVXTElORVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxccj9cXFxcXFxcXG4vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfREVTQ1JcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjRGVzY3IoPzpbXFxcXFxcXFx0IF0qOihbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKXxcXFxcXFxcXHMqeyhbXn1dKil9KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NUaXRsZVtcXFxcXFxcXHQgXSo6KD86W15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKikvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJUSVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSp0aXRsZSg/OltcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFtcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSp8KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJXSElURVNQQUNFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiWUFNTFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLy0tLVtcXFxcXFxcXHQgXSpcXFxcXFxcXHI/XFxcXFxcXFxuKD86W1xcXFxcXFxcU1xcXFxcXFxcc10qP1xcXFxcXFxccj9cXFxcXFxcXG4pPy0tLSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIkRJUkVDVElWRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJXtbXFxcXFxcXFxTXFxcXFxcXFxzXSo/fSUlKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiU0lOR0xFX0xJTkVfQ09NTUVOVFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJVteXFxcXFxcXFxuXFxcXFxcXFxyXSovXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX1dLFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJpbnRlcmZhY2VzXCI6W3tcIiR0eXBlXCI6XCJJbnRlcmZhY2VcIixcIm5hbWVcIjpcIkNvbW1vblwiLFwiYXR0cmlidXRlc1wiOlt7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjRGVzY3JcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJhY2NUaXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX0se1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcInRpdGxlXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fV0sXCJzdXBlclR5cGVzXCI6W119XSxcInR5cGVzXCI6W10sXCJ1c2VkR3JhbW1hcnNcIjpbXX0nKSksIFwiUGllR3JhbW1hclwiKTtcbnZhciBsb2FkZWRBcmNoaXRlY3R1cmVHcmFtbWFyO1xudmFyIEFyY2hpdGVjdHVyZUdyYW1tYXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IGxvYWRlZEFyY2hpdGVjdHVyZUdyYW1tYXIgPz8gKGxvYWRlZEFyY2hpdGVjdHVyZUdyYW1tYXIgPSBsb2FkR3JhbW1hckZyb21Kc29uKCd7XCIkdHlwZVwiOlwiR3JhbW1hclwiLFwiaXNEZWNsYXJlZFwiOnRydWUsXCJuYW1lXCI6XCJBcmNoaXRlY3R1cmVcIixcImltcG9ydHNcIjpbXSxcInJ1bGVzXCI6W3tcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJBcmNoaXRlY3R1cmVcIixcImVudHJ5XCI6dHJ1ZSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiYXJjaGl0ZWN0dXJlLWJldGFcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE2XCJ9LFwiYXJndW1lbnRzXCI6W119XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxOFwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlN0YXRlbWVudFwiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJncm91cHNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJzZXJ2aWNlc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImp1bmN0aW9uc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAN1wifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImVkZ2VzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A4XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkxlZnRQb3J0XCIsXCJmcmFnbWVudFwiOnRydWUsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxoc0RpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A5XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlJpZ2h0UG9ydFwiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInJoc0RpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A5XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJBcnJvd1wiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsaHNJbnRvXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiLS1cIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn1dfV19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJyaHNJbnRvXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkdyb3VwXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImdyb3VwXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJpZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImljb25cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTNcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiaW5cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImluXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlNlcnZpY2VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwic2VydmljZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJpY29uVGV4dFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImljb25cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxM1wifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpblwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaW5cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTdcIn0sXCJhcmd1bWVudHNcIjpbXX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiSnVuY3Rpb25cIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwianVuY3Rpb25cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImlkXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiaW5cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImluXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkVkZ2VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsaHNJZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxoc0dyb3VwXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNFwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwicmhzSWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJyaHNHcm91cFwiLFwib3BlcmF0b3JcIjpcIj89XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTRcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJST1dfRElSRUNUSU9OXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlRlcm1pbmFsQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiVGVybWluYWxBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJUZXJtaW5hbEFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkNoYXJhY3RlclJhbmdlXCIsXCJsZWZ0XCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJMXCJ9fSx7XCIkdHlwZVwiOlwiQ2hhcmFjdGVyUmFuZ2VcIixcImxlZnRcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIlJcIn19XX0se1wiJHR5cGVcIjpcIkNoYXJhY3RlclJhbmdlXCIsXCJsZWZ0XCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJUXCJ9fV19LHtcIiR0eXBlXCI6XCJDaGFyYWN0ZXJSYW5nZVwiLFwibGVmdFwiOntcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiQlwifX1dfSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJDSF9JRFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHddKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFSQ0hfVEVYVF9JQ09OXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFxcXFwoXFxcXFwiW15cXFxcXCJdK1xcXFxcIlxcXFxcXFxcKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFSQ0hfSUNPTlwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxcKFtcXFxcXFxcXHctOl0rXFxcXFxcXFwpL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJDSF9USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxcW1tcXFxcXFxcXHcgXStcXFxcXFxcXF0vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBUlJPV19HUk9VUFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxce2dyb3VwXFxcXFxcXFx9L1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJST1dfSU5UT1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLzx8Pi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJUaXRsZUFuZEFjY2Vzc2liaWxpdGllc1wiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY0Rlc2NyXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMVwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkVPTFwiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJFbmRPZkZpbGVcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIk5FV0xJTkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHI/XFxcXFxcXFxuL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX0RFU0NSXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY0Rlc2NyKD86W1xcXFxcXFxcdCBdKjooW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKil8XFxcXFxcXFxzKnsoW159XSopfSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjVGl0bGVbXFxcXFxcXFx0IF0qOig/OlteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qdGl0bGUoPzpbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qfCkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiV0hJVEVTUEFDRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSsvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIllBTUxcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8tLS1bXFxcXFxcXFx0IF0qXFxcXFxcXFxyP1xcXFxcXFxcbig/OltcXFxcXFxcXFNcXFxcXFxcXHNdKj9cXFxcXFxcXHI/XFxcXFxcXFxuKT8tLS0oPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJESVJFQ1RJVkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSV7W1xcXFxcXFxcU1xcXFxcXFxcc10qP30lJSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIlNJTkdMRV9MSU5FX0NPTU1FTlRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSVbXlxcXFxcXFxcblxcXFxcXFxccl0qL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJ0eXBlc1wiOltdLFwidXNlZEdyYW1tYXJzXCI6W119JykpLCBcIkFyY2hpdGVjdHVyZUdyYW1tYXJcIik7XG52YXIgbG9hZGVkR2l0R3JhcGhHcmFtbWFyO1xudmFyIEdpdEdyYXBoR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkR2l0R3JhcGhHcmFtbWFyID8/IChsb2FkZWRHaXRHcmFwaEdyYW1tYXIgPSBsb2FkR3JhbW1hckZyb21Kc29uKGB7XCIkdHlwZVwiOlwiR3JhbW1hclwiLFwiaXNEZWNsYXJlZFwiOnRydWUsXCJuYW1lXCI6XCJHaXRHcmFwaFwiLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJydWxlc1wiOlt7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiVGl0bGVBbmRBY2Nlc3NpYmlsaXRpZXNcIixcImZyYWdtZW50XCI6dHJ1ZSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NEZXNjclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkVPTFwiLFwiZnJhZ21lbnRcIjp0cnVlLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIitcIn0se1wiJHR5cGVcIjpcIkVuZE9mRmlsZVwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTkVXTElORVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxccj9cXFxcXFxcXG4vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfREVTQ1JcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjRGVzY3IoPzpbXFxcXFxcXFx0IF0qOihbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKXxcXFxcXFxcXHMqeyhbXn1dKil9KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NUaXRsZVtcXFxcXFxcXHQgXSo6KD86W15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKikvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJUSVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSp0aXRsZSg/OltcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFtcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSp8KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJXSElURVNQQUNFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiWUFNTFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLy0tLVtcXFxcXFxcXHQgXSpcXFxcXFxcXHI/XFxcXFxcXFxuKD86W1xcXFxcXFxcU1xcXFxcXFxcc10qP1xcXFxcXFxccj9cXFxcXFxcXG4pPy0tLSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIkRJUkVDVElWRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJXtbXFxcXFxcXFxTXFxcXFxcXFxzXSo/fSUlKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiU0lOR0xFX0xJTkVfQ09NTUVOVFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJVteXFxcXFxcXFxuXFxcXFxcXFxyXSovXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkdpdEdyYXBoXCIsXCJlbnRyeVwiOnRydWUsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDJcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiZ2l0R3JhcGhcIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImdpdEdyYXBoXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiOlwifV19LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiZ2l0R3JhcGg6XCJ9LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJnaXRHcmFwaFwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEyXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiOlwifV19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AwXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJzdGF0ZW1lbnRzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJTdGF0ZW1lbnRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEzXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTRcIn0sXCJhcmd1bWVudHNcIjpbXX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE2XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTdcIn0sXCJhcmd1bWVudHNcIjpbXX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiRGlyZWN0aW9uXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImRpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJMUlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIlRCXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiQlRcIn1dfX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkNvbW1pdFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJjb21taXRcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImlkOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIm1zZzpcIixcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJtZXNzYWdlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0YWc6XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0YWdzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMFwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwidHlwZTpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInR5cGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiTk9STUFMXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiUkVWRVJTRVwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIkhJR0hMSUdIVFwifV19fV19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJCcmFuY2hcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiYnJhbmNoXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJuYW1lXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX1dfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIm9yZGVyOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwib3JkZXJcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJNZXJnZVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJtZXJnZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYnJhbmNoXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX1dfX0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImlkOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInRhZzpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRhZ3NcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0eXBlOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidHlwZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJOT1JNQUxcIn0se1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJSRVZFUlNFXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiSElHSExJR0hUXCJ9XX19XX1dLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkNoZWNrb3V0XCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImNoZWNrb3V0XCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwic3dpdGNoXCJ9XX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImJyYW5jaFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxOVwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119XX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJDaGVycnlQaWNraW5nXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImNoZXJyeS1waWNrXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpZDpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImlkXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0YWc6XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0YWdzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMFwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwicGFyZW50OlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwicGFyZW50XCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklOVFwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJudW1iZXJcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvWzAtOV0rKD89XFxcXFxcXFxzKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklEXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcInN0cmluZ1wifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHcoWy1cXFxcXFxcXC4vXFxcXFxcXFx3XSpbLVxcXFxcXFxcd10pPy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlNUUklOR1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcIlteXFxcXFwiXSpcXFxcXCJ8J1teJ10qJy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW1wb3J0c1wiOltdLFwidHlwZXNcIjpbXSxcInVzZWRHcmFtbWFyc1wiOltdfWApKSwgXCJHaXRHcmFwaEdyYW1tYXJcIik7XG5cbi8vIHNyYy9sYW5ndWFnZS9nZW5lcmF0ZWQvbW9kdWxlLnRzXG52YXIgSW5mb0xhbmd1YWdlTWV0YURhdGEgPSB7XG4gIGxhbmd1YWdlSWQ6IFwiaW5mb1wiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlXG59O1xudmFyIFBhY2tldExhbmd1YWdlTWV0YURhdGEgPSB7XG4gIGxhbmd1YWdlSWQ6IFwicGFja2V0XCIsXG4gIGZpbGVFeHRlbnNpb25zOiBbXCIubW1kXCIsIFwiLm1lcm1haWRcIl0sXG4gIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2Vcbn07XG52YXIgUGllTGFuZ3VhZ2VNZXRhRGF0YSA9IHtcbiAgbGFuZ3VhZ2VJZDogXCJwaWVcIixcbiAgZmlsZUV4dGVuc2lvbnM6IFtcIi5tbWRcIiwgXCIubWVybWFpZFwiXSxcbiAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZVxufTtcbnZhciBBcmNoaXRlY3R1cmVMYW5ndWFnZU1ldGFEYXRhID0ge1xuICBsYW5ndWFnZUlkOiBcImFyY2hpdGVjdHVyZVwiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlXG59O1xudmFyIEdpdEdyYXBoTGFuZ3VhZ2VNZXRhRGF0YSA9IHtcbiAgbGFuZ3VhZ2VJZDogXCJnaXRHcmFwaFwiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlXG59O1xudmFyIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUgPSB7XG4gIEFzdFJlZmxlY3Rpb246IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IE1lcm1haWRBc3RSZWZsZWN0aW9uKCksIFwiQXN0UmVmbGVjdGlvblwiKVxufTtcbnZhciBJbmZvR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IEluZm9HcmFtbWFyKCksIFwiR3JhbW1hclwiKSxcbiAgTGFuZ3VhZ2VNZXRhRGF0YTogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBJbmZvTGFuZ3VhZ2VNZXRhRGF0YSwgXCJMYW5ndWFnZU1ldGFEYXRhXCIpLFxuICBwYXJzZXI6IHt9XG59O1xudmFyIFBhY2tldEdlbmVyYXRlZE1vZHVsZSA9IHtcbiAgR3JhbW1hcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBQYWNrZXRHcmFtbWFyKCksIFwiR3JhbW1hclwiKSxcbiAgTGFuZ3VhZ2VNZXRhRGF0YTogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBQYWNrZXRMYW5ndWFnZU1ldGFEYXRhLCBcIkxhbmd1YWdlTWV0YURhdGFcIiksXG4gIHBhcnNlcjoge31cbn07XG52YXIgUGllR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IFBpZUdyYW1tYXIoKSwgXCJHcmFtbWFyXCIpLFxuICBMYW5ndWFnZU1ldGFEYXRhOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IFBpZUxhbmd1YWdlTWV0YURhdGEsIFwiTGFuZ3VhZ2VNZXRhRGF0YVwiKSxcbiAgcGFyc2VyOiB7fVxufTtcbnZhciBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUgPSB7XG4gIEdyYW1tYXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gQXJjaGl0ZWN0dXJlR3JhbW1hcigpLCBcIkdyYW1tYXJcIiksXG4gIExhbmd1YWdlTWV0YURhdGE6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gQXJjaGl0ZWN0dXJlTGFuZ3VhZ2VNZXRhRGF0YSwgXCJMYW5ndWFnZU1ldGFEYXRhXCIpLFxuICBwYXJzZXI6IHt9XG59O1xudmFyIEdpdEdyYXBoR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IEdpdEdyYXBoR3JhbW1hcigpLCBcIkdyYW1tYXJcIiksXG4gIExhbmd1YWdlTWV0YURhdGE6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gR2l0R3JhcGhMYW5ndWFnZU1ldGFEYXRhLCBcIkxhbmd1YWdlTWV0YURhdGFcIiksXG4gIHBhcnNlcjoge31cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS9jb21tb24vdmFsdWVDb252ZXJ0ZXIudHNcbmltcG9ydCB7IERlZmF1bHRWYWx1ZUNvbnZlcnRlciB9IGZyb20gXCJsYW5naXVtXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9jb21tb24vbWF0Y2hlci50c1xudmFyIGFjY2Vzc2liaWxpdHlEZXNjclJlZ2V4ID0gL2FjY0Rlc2NyKD86W1xcdCBdKjooW15cXG5cXHJdKil8XFxzKnsoW159XSopfSkvO1xudmFyIGFjY2Vzc2liaWxpdHlUaXRsZVJlZ2V4ID0gL2FjY1RpdGxlW1xcdCBdKjooW15cXG5cXHJdKikvO1xudmFyIHRpdGxlUmVnZXggPSAvdGl0bGUoW1xcdCBdW15cXG5cXHJdKnwpLztcblxuLy8gc3JjL2xhbmd1YWdlL2NvbW1vbi92YWx1ZUNvbnZlcnRlci50c1xudmFyIHJ1bGVzUmVnZXhlcyA9IHtcbiAgQUNDX0RFU0NSOiBhY2Nlc3NpYmlsaXR5RGVzY3JSZWdleCxcbiAgQUNDX1RJVExFOiBhY2Nlc3NpYmlsaXR5VGl0bGVSZWdleCxcbiAgVElUTEU6IHRpdGxlUmVnZXhcbn07XG52YXIgQWJzdHJhY3RNZXJtYWlkVmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRWYWx1ZUNvbnZlcnRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQWJzdHJhY3RNZXJtYWlkVmFsdWVDb252ZXJ0ZXJcIik7XG4gIH1cbiAgcnVuQ29udmVydGVyKHJ1bGUsIGlucHV0LCBjc3ROb2RlKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5ydW5Db21tb25Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIGNzdE5vZGUpO1xuICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucnVuQ3VzdG9tQ29udmVydGVyKHJ1bGUsIGlucHV0LCBjc3ROb2RlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzdXBlci5ydW5Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIGNzdE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcnVuQ29tbW9uQ29udmVydGVyKHJ1bGUsIGlucHV0LCBfY3N0Tm9kZSkge1xuICAgIGNvbnN0IHJlZ2V4ID0gcnVsZXNSZWdleGVzW3J1bGUubmFtZV07XG4gICAgaWYgKHJlZ2V4ID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gcmVnZXguZXhlYyhpbnB1dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBpZiAobWF0Y2hbMV0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG1hdGNoWzFdLnRyaW0oKS5yZXBsYWNlKC9bXFx0IF17Mix9L2dtLCBcIiBcIik7XG4gICAgfVxuICAgIGlmIChtYXRjaFsyXSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMl0ucmVwbGFjZSgvXlxccyovZ20sIFwiXCIpLnJlcGxhY2UoL1xccyskL2dtLCBcIlwiKS5yZXBsYWNlKC9bXFx0IF17Mix9L2dtLCBcIiBcIikucmVwbGFjZSgvW1xcblxccl17Mix9L2dtLCBcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcbnZhciBDb21tb25WYWx1ZUNvbnZlcnRlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNZXJtYWlkVmFsdWVDb252ZXJ0ZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkNvbW1vblZhbHVlQ29udmVydGVyXCIpO1xuICB9XG4gIHJ1bkN1c3RvbUNvbnZlcnRlcihfcnVsZSwgX2lucHV0LCBfY3N0Tm9kZSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS9jb21tb24vdG9rZW5CdWlsZGVyLnRzXG5pbXBvcnQgeyBEZWZhdWx0VG9rZW5CdWlsZGVyIH0gZnJvbSBcImxhbmdpdW1cIjtcbnZhciBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIERlZmF1bHRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXl3b3Jkcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5rZXl3b3JkcyA9IG5ldyBTZXQoa2V5d29yZHMpO1xuICB9XG4gIGJ1aWxkS2V5d29yZFRva2VucyhydWxlcywgdGVybWluYWxUb2tlbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0b2tlblR5cGVzID0gc3VwZXIuYnVpbGRLZXl3b3JkVG9rZW5zKHJ1bGVzLCB0ZXJtaW5hbFRva2Vucywgb3B0aW9ucyk7XG4gICAgdG9rZW5UeXBlcy5mb3JFYWNoKCh0b2tlblR5cGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmtleXdvcmRzLmhhcyh0b2tlblR5cGUubmFtZSkgJiYgdG9rZW5UeXBlLlBBVFRFUk4gIT09IHZvaWQgMCkge1xuICAgICAgICB0b2tlblR5cGUuUEFUVEVSTiA9IG5ldyBSZWdFeHAodG9rZW5UeXBlLlBBVFRFUk4udG9TdHJpbmcoKSArIFwiKD86KD89JSUpfCg/IVxcXFxTKSlcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VuVHlwZXM7XG4gIH1cbn07XG52YXIgQ29tbW9uVG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkNvbW1vblRva2VuQnVpbGRlclwiKTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgX19uYW1lLFxuICBTdGF0ZW1lbnQsXG4gIEFyY2hpdGVjdHVyZSxcbiAgaXNBcmNoaXRlY3R1cmUsXG4gIEJyYW5jaCxcbiAgaXNCcmFuY2gsXG4gIENvbW1pdCxcbiAgaXNDb21taXQsXG4gIGlzQ29tbW9uLFxuICBHaXRHcmFwaCxcbiAgaXNHaXRHcmFwaCxcbiAgSW5mbyxcbiAgaXNJbmZvLFxuICBNZXJnZSxcbiAgaXNNZXJnZSxcbiAgUGFja2V0LFxuICBpc1BhY2tldCxcbiAgUGFja2V0QmxvY2ssXG4gIGlzUGFja2V0QmxvY2ssXG4gIFBpZSxcbiAgaXNQaWUsXG4gIFBpZVNlY3Rpb24sXG4gIGlzUGllU2VjdGlvbixcbiAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZSxcbiAgSW5mb0dlbmVyYXRlZE1vZHVsZSxcbiAgUGFja2V0R2VuZXJhdGVkTW9kdWxlLFxuICBQaWVHZW5lcmF0ZWRNb2R1bGUsXG4gIEFyY2hpdGVjdHVyZUdlbmVyYXRlZE1vZHVsZSxcbiAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gIEFic3RyYWN0TWVybWFpZFZhbHVlQ29udmVydGVyLFxuICBDb21tb25WYWx1ZUNvbnZlcnRlcixcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBDb21tb25Ub2tlbkJ1aWxkZXJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19369\n')},78731:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   qg: () => (/* binding */ parse)\n/* harmony export */ });\n/* unused harmony export MermaidParseError */\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_NCMFTTUW_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(82785);\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_4YFB5VUC_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97021);\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_EQFLFMNE_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71609);\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_BI6EQKOQ_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88685);\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_FF7BQXOH_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(49936);\n/* harmony import */ var _chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19369);\n\n\n\n\n\n\n\n// src/parse.ts\nvar parsers = {};\nvar initializers = {\n  info: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(async () => {\n    const { createInfoServices: createInfoServices2 } = await __webpack_require__.e(/* import() */ 890).then(__webpack_require__.bind(__webpack_require__, 10890));\n    const parser = createInfoServices2().Info.parser.LangiumParser;\n    parsers.info = parser;\n  }, "info"),\n  packet: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(async () => {\n    const { createPacketServices: createPacketServices2 } = await __webpack_require__.e(/* import() */ 6452).then(__webpack_require__.bind(__webpack_require__, 6452));\n    const parser = createPacketServices2().Packet.parser.LangiumParser;\n    parsers.packet = parser;\n  }, "packet"),\n  pie: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(async () => {\n    const { createPieServices: createPieServices2 } = await __webpack_require__.e(/* import() */ 7723).then(__webpack_require__.bind(__webpack_require__, 57723));\n    const parser = createPieServices2().Pie.parser.LangiumParser;\n    parsers.pie = parser;\n  }, "pie"),\n  architecture: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(async () => {\n    const { createArchitectureServices: createArchitectureServices2 } = await __webpack_require__.e(/* import() */ 9720).then(__webpack_require__.bind(__webpack_require__, 39720));\n    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;\n    parsers.architecture = parser;\n  }, "architecture"),\n  gitGraph: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(async () => {\n    const { createGitGraphServices: createGitGraphServices2 } = await __webpack_require__.e(/* import() */ 2387).then(__webpack_require__.bind(__webpack_require__, 82387));\n    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;\n    parsers.gitGraph = parser;\n  }, "gitGraph")\n};\nasync function parse(diagramType, text) {\n  const initializer = initializers[diagramType];\n  if (!initializer) {\n    throw new Error(`Unknown diagram type: ${diagramType}`);\n  }\n  if (!parsers[diagramType]) {\n    await initializer();\n  }\n  const parser = parsers[diagramType];\n  const result = parser.parse(text);\n  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {\n    throw new MermaidParseError(result);\n  }\n  return result.value;\n}\n(0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(parse, "parse");\nvar MermaidParseError = class extends Error {\n  constructor(result) {\n    const lexerErrors = result.lexerErrors.map((err) => err.message).join("\\n");\n    const parserErrors = result.parserErrors.map((err) => err.message).join("\\n");\n    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);\n    this.result = result;\n  }\n  static {\n    (0,_chunks_mermaid_parser_core_chunk_Y27MQZ3U_mjs__WEBPACK_IMPORTED_MODULE_5__/* .__name */ .K2)(this, "MermaidParseError");\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg3MzEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUd5RDtBQUlBO0FBSUE7QUFJQTtBQUlBO0FBbUNBOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0dBQU07QUFDOUIsWUFBWSwwQ0FBMEMsUUFBUSxvR0FBd0Q7QUFDdEg7QUFDQTtBQUNBLEdBQUc7QUFDSCwwQkFBMEIsZ0dBQU07QUFDaEMsWUFBWSw4Q0FBOEMsUUFBUSxvR0FBMEQ7QUFDNUg7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsZ0dBQU07QUFDN0IsWUFBWSx3Q0FBd0MsUUFBUSxxR0FBdUQ7QUFDbkg7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQ0FBZ0MsZ0dBQU07QUFDdEMsWUFBWSwwREFBMEQsUUFBUSxxR0FBZ0U7QUFDOUk7QUFDQTtBQUNBLEdBQUc7QUFDSCw0QkFBNEIsZ0dBQU07QUFDbEMsWUFBWSxrREFBa0QsUUFBUSxxR0FBNEQ7QUFDbEk7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWEsRUFBRSxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0dBQU07QUFDVjtBQUNBO0FBOENFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AbWVybWFpZC1qcy9wYXJzZXIvZGlzdC9tZXJtYWlkLXBhcnNlci5jb3JlLm1qcz9jNzVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEdpdEdyYXBoTW9kdWxlLFxuICBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzXG59IGZyb20gXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLU5DTUZUVFVXLm1qc1wiO1xuaW1wb3J0IHtcbiAgSW5mb01vZHVsZSxcbiAgY3JlYXRlSW5mb1NlcnZpY2VzXG59IGZyb20gXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLTRZRkI1VlVDLm1qc1wiO1xuaW1wb3J0IHtcbiAgUGFja2V0TW9kdWxlLFxuICBjcmVhdGVQYWNrZXRTZXJ2aWNlc1xufSBmcm9tIFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay1FUUZMRk1ORS5tanNcIjtcbmltcG9ydCB7XG4gIFBpZU1vZHVsZSxcbiAgY3JlYXRlUGllU2VydmljZXNcbn0gZnJvbSBcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvY2h1bmstQkk2RVFLT1EubWpzXCI7XG5pbXBvcnQge1xuICBBcmNoaXRlY3R1cmVNb2R1bGUsXG4gIGNyZWF0ZUFyY2hpdGVjdHVyZVNlcnZpY2VzXG59IGZyb20gXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLUZGN0JRWE9ILm1qc1wiO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlcixcbiAgQXJjaGl0ZWN0dXJlLFxuICBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUsXG4gIEJyYW5jaCxcbiAgQ29tbWl0LFxuICBDb21tb25Ub2tlbkJ1aWxkZXIsXG4gIENvbW1vblZhbHVlQ29udmVydGVyLFxuICBHaXRHcmFwaCxcbiAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gIEluZm8sXG4gIEluZm9HZW5lcmF0ZWRNb2R1bGUsXG4gIE1lcmdlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBQYWNrZXQsXG4gIFBhY2tldEJsb2NrLFxuICBQYWNrZXRHZW5lcmF0ZWRNb2R1bGUsXG4gIFBpZSxcbiAgUGllR2VuZXJhdGVkTW9kdWxlLFxuICBQaWVTZWN0aW9uLFxuICBTdGF0ZW1lbnQsXG4gIF9fbmFtZSxcbiAgaXNBcmNoaXRlY3R1cmUsXG4gIGlzQnJhbmNoLFxuICBpc0NvbW1pdCxcbiAgaXNDb21tb24sXG4gIGlzR2l0R3JhcGgsXG4gIGlzSW5mbyxcbiAgaXNNZXJnZSxcbiAgaXNQYWNrZXQsXG4gIGlzUGFja2V0QmxvY2ssXG4gIGlzUGllLFxuICBpc1BpZVNlY3Rpb25cbn0gZnJvbSBcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvY2h1bmstWTI3TVFaM1UubWpzXCI7XG5cbi8vIHNyYy9wYXJzZS50c1xudmFyIHBhcnNlcnMgPSB7fTtcbnZhciBpbml0aWFsaXplcnMgPSB7XG4gIGluZm86IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgY3JlYXRlSW5mb1NlcnZpY2VzOiBjcmVhdGVJbmZvU2VydmljZXMyIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2luZm8tNDZEVzZWSjcubWpzXCIpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUluZm9TZXJ2aWNlczIoKS5JbmZvLnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIHBhcnNlcnMuaW5mbyA9IHBhcnNlcjtcbiAgfSwgXCJpbmZvXCIpLFxuICBwYWNrZXQ6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgY3JlYXRlUGFja2V0U2VydmljZXM6IGNyZWF0ZVBhY2tldFNlcnZpY2VzMiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9wYWNrZXQtVzJHSFZDWUoubWpzXCIpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZVBhY2tldFNlcnZpY2VzMigpLlBhY2tldC5wYXJzZXIuTGFuZ2l1bVBhcnNlcjtcbiAgICBwYXJzZXJzLnBhY2tldCA9IHBhcnNlcjtcbiAgfSwgXCJwYWNrZXRcIiksXG4gIHBpZTogLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVQaWVTZXJ2aWNlczogY3JlYXRlUGllU2VydmljZXMyIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL3BpZS1CRVdUNFJIRS5tanNcIik7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlUGllU2VydmljZXMyKCkuUGllLnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIHBhcnNlcnMucGllID0gcGFyc2VyO1xuICB9LCBcInBpZVwiKSxcbiAgYXJjaGl0ZWN0dXJlOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZUFyY2hpdGVjdHVyZVNlcnZpY2VzOiBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlczIgfSA9IGF3YWl0IGltcG9ydChcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvYXJjaGl0ZWN0dXJlLUkzUUZZTUwyLm1qc1wiKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlczIoKS5BcmNoaXRlY3R1cmUucGFyc2VyLkxhbmdpdW1QYXJzZXI7XG4gICAgcGFyc2Vycy5hcmNoaXRlY3R1cmUgPSBwYXJzZXI7XG4gIH0sIFwiYXJjaGl0ZWN0dXJlXCIpLFxuICBnaXRHcmFwaDogLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzOiBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzMiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9naXRHcmFwaC1ZQ1lQTDU3Qi5tanNcIik7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlR2l0R3JhcGhTZXJ2aWNlczIoKS5HaXRHcmFwaC5wYXJzZXIuTGFuZ2l1bVBhcnNlcjtcbiAgICBwYXJzZXJzLmdpdEdyYXBoID0gcGFyc2VyO1xuICB9LCBcImdpdEdyYXBoXCIpXG59O1xuYXN5bmMgZnVuY3Rpb24gcGFyc2UoZGlhZ3JhbVR5cGUsIHRleHQpIHtcbiAgY29uc3QgaW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNbZGlhZ3JhbVR5cGVdO1xuICBpZiAoIWluaXRpYWxpemVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRpYWdyYW0gdHlwZTogJHtkaWFncmFtVHlwZX1gKTtcbiAgfVxuICBpZiAoIXBhcnNlcnNbZGlhZ3JhbVR5cGVdKSB7XG4gICAgYXdhaXQgaW5pdGlhbGl6ZXIoKTtcbiAgfVxuICBjb25zdCBwYXJzZXIgPSBwYXJzZXJzW2RpYWdyYW1UeXBlXTtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2VyLnBhcnNlKHRleHQpO1xuICBpZiAocmVzdWx0LmxleGVyRXJyb3JzLmxlbmd0aCA+IDAgfHwgcmVzdWx0LnBhcnNlckVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IE1lcm1haWRQYXJzZUVycm9yKHJlc3VsdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn1cbl9fbmFtZShwYXJzZSwgXCJwYXJzZVwiKTtcbnZhciBNZXJtYWlkUGFyc2VFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihyZXN1bHQpIHtcbiAgICBjb25zdCBsZXhlckVycm9ycyA9IHJlc3VsdC5sZXhlckVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCJcXG5cIik7XG4gICAgY29uc3QgcGFyc2VyRXJyb3JzID0gcmVzdWx0LnBhcnNlckVycm9ycy5tYXAoKGVycikgPT4gZXJyLm1lc3NhZ2UpLmpvaW4oXCJcXG5cIik7XG4gICAgc3VwZXIoYFBhcnNpbmcgZmFpbGVkOiAke2xleGVyRXJyb3JzfSAke3BhcnNlckVycm9yc31gKTtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgfVxuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIk1lcm1haWRQYXJzZUVycm9yXCIpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlcixcbiAgQXJjaGl0ZWN0dXJlLFxuICBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUsXG4gIEFyY2hpdGVjdHVyZU1vZHVsZSxcbiAgQnJhbmNoLFxuICBDb21taXQsXG4gIENvbW1vblRva2VuQnVpbGRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIEdpdEdyYXBoLFxuICBHaXRHcmFwaEdlbmVyYXRlZE1vZHVsZSxcbiAgR2l0R3JhcGhNb2R1bGUsXG4gIEluZm8sXG4gIEluZm9HZW5lcmF0ZWRNb2R1bGUsXG4gIEluZm9Nb2R1bGUsXG4gIE1lcmdlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBNZXJtYWlkUGFyc2VFcnJvcixcbiAgUGFja2V0LFxuICBQYWNrZXRCbG9jayxcbiAgUGFja2V0R2VuZXJhdGVkTW9kdWxlLFxuICBQYWNrZXRNb2R1bGUsXG4gIFBpZSxcbiAgUGllR2VuZXJhdGVkTW9kdWxlLFxuICBQaWVNb2R1bGUsXG4gIFBpZVNlY3Rpb24sXG4gIFN0YXRlbWVudCxcbiAgY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXMsXG4gIGNyZWF0ZUdpdEdyYXBoU2VydmljZXMsXG4gIGNyZWF0ZUluZm9TZXJ2aWNlcyxcbiAgY3JlYXRlUGFja2V0U2VydmljZXMsXG4gIGNyZWF0ZVBpZVNlcnZpY2VzLFxuICBpc0FyY2hpdGVjdHVyZSxcbiAgaXNCcmFuY2gsXG4gIGlzQ29tbWl0LFxuICBpc0NvbW1vbixcbiAgaXNHaXRHcmFwaCxcbiAgaXNJbmZvLFxuICBpc01lcmdlLFxuICBpc1BhY2tldCxcbiAgaXNQYWNrZXRCbG9jayxcbiAgaXNQaWUsXG4gIGlzUGllU2VjdGlvbixcbiAgcGFyc2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///78731\n')},33394:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  kD: () => (/* reexport */ AbstractAstReflection),\n  QU: () => (/* reexport */ DefaultTokenBuilder),\n  dM: () => (/* reexport */ DefaultValueConverter),\n  DD: () => (/* reexport */ EmptyFileSystem),\n  tG: () => (/* reexport */ createDefaultCoreModule),\n  uM: () => (/* reexport */ createDefaultSharedCoreModule),\n  WQ: () => (/* reexport */ inject),\n  y0: () => (/* reexport */ loadGrammarFromJson)\n});\n\n// UNUSED EXPORTS: AbstractCstNode, AbstractLangiumParser, AbstractParserErrorMessageProvider, AbstractThreadedAsyncParser, AstUtils, BiMap, Cancellation, CompositeCstNodeImpl, ContextCache, CstNodeBuilder, CstUtils, DONE_RESULT, DatatypeSymbol, DefaultAstNodeDescriptionProvider, DefaultAstNodeLocator, DefaultAsyncParser, DefaultCommentProvider, DefaultConfigurationProvider, DefaultDocumentBuilder, DefaultDocumentValidator, DefaultHydrator, DefaultIndexManager, DefaultJsonSerializer, DefaultLangiumDocumentFactory, DefaultLangiumDocuments, DefaultLexer, DefaultLinker, DefaultNameProvider, DefaultReferenceDescriptionProvider, DefaultReferences, DefaultScopeComputation, DefaultScopeProvider, DefaultServiceRegistry, DefaultWorkspaceLock, DefaultWorkspaceManager, Deferred, Disposable, DisposableCache, DocumentCache, DocumentState, DocumentValidator, EMPTY_SCOPE, EMPTY_STREAM, Emitter, EmptyFileSystemProvider, ErrorWithLocation, Event, GrammarAST, GrammarUtils, JSDocDocumentationProvider, LangiumCompletionParser, LangiumParser, LangiumParserErrorMessageProvider, LeafCstNodeImpl, MapScope, Module, MultiMap, OperationCancelled, ParserWorker, Reduction, RegExpUtils, RootCstNodeImpl, SimpleCache, StreamImpl, StreamScope, TextDocument, TreeStreamImpl, URI, UriUtils, ValidationCategory, ValidationRegistry, ValueConverter, WorkspaceCache, __esModule, assertUnreachable, createCompletionParser, createGrammarConfig, createLangiumParser, delayNextTick, diagnosticData, eagerLoad, getDiagnosticRange, interruptAndCheck, isAstNode, isAstNodeDescription, isAstNodeWithComment, isCompositeCstNode, isIMultiModeLexerDefinition, isJSDoc, isLeafCstNode, isLinkingError, isNamed, isOperationCancelled, isReference, isRootCstNode, isTokenTypeArray, isTokenTypeDictionary, parseJSDoc, prepareLangiumParser, setInterruptionPeriod, startCancelableOperation, stream, toDiagnosticSeverity\n\n;// ./node_modules/langium/lib/syntax-tree.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nfunction syntax_tree_isAstNode(obj) {\n    return typeof obj === \'object\' && obj !== null && typeof obj.$type === \'string\';\n}\nfunction syntax_tree_isReference(obj) {\n    return typeof obj === \'object\' && obj !== null && typeof obj.$refText === \'string\';\n}\nfunction isAstNodeDescription(obj) {\n    return typeof obj === \'object\' && obj !== null\n        && typeof obj.name === \'string\'\n        && typeof obj.type === \'string\'\n        && typeof obj.path === \'string\';\n}\nfunction isLinkingError(obj) {\n    return typeof obj === \'object\' && obj !== null\n        && syntax_tree_isAstNode(obj.container)\n        && syntax_tree_isReference(obj.reference)\n        && typeof obj.message === \'string\';\n}\n/**\n * An abstract implementation of the {@link AstReflection} interface.\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\n */\nclass AbstractAstReflection {\n    constructor() {\n        this.subtypes = {};\n        this.allSubtypes = {};\n    }\n    isInstance(node, type) {\n        return syntax_tree_isAstNode(node) && this.isSubtype(node.$type, type);\n    }\n    isSubtype(subtype, supertype) {\n        if (subtype === supertype) {\n            return true;\n        }\n        let nested = this.subtypes[subtype];\n        if (!nested) {\n            nested = this.subtypes[subtype] = {};\n        }\n        const existing = nested[supertype];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            const result = this.computeIsSubtype(subtype, supertype);\n            nested[supertype] = result;\n            return result;\n        }\n    }\n    getAllSubTypes(type) {\n        const existing = this.allSubtypes[type];\n        if (existing) {\n            return existing;\n        }\n        else {\n            const allTypes = this.getAllTypes();\n            const types = [];\n            for (const possibleSubType of allTypes) {\n                if (this.isSubtype(possibleSubType, type)) {\n                    types.push(possibleSubType);\n                }\n            }\n            this.allSubtypes[type] = types;\n            return types;\n        }\n    }\n}\nfunction syntax_tree_isCompositeCstNode(node) {\n    return typeof node === \'object\' && node !== null && Array.isArray(node.content);\n}\nfunction syntax_tree_isLeafCstNode(node) {\n    return typeof node === \'object\' && node !== null && typeof node.tokenType === \'object\';\n}\nfunction isRootCstNode(node) {\n    return syntax_tree_isCompositeCstNode(node) && typeof node.fullText === \'string\';\n}\n//# sourceMappingURL=syntax-tree.js.map\n;// ./node_modules/langium/lib/utils/stream.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * The default implementation of `Stream` works with two input functions:\n *  - The first function creates the initial state of an iteration.\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\n */\nclass StreamImpl {\n    constructor(startFn, nextFn) {\n        this.startFn = startFn;\n        this.nextFn = nextFn;\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n    [Symbol.iterator]() {\n        return this.iterator();\n    }\n    isEmpty() {\n        const iterator = this.iterator();\n        return Boolean(iterator.next().done);\n    }\n    count() {\n        const iterator = this.iterator();\n        let count = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            count++;\n            next = iterator.next();\n        }\n        return count;\n    }\n    toArray() {\n        const result = [];\n        const iterator = this.iterator();\n        let next;\n        do {\n            next = iterator.next();\n            if (next.value !== undefined) {\n                result.push(next.value);\n            }\n        } while (!next.done);\n        return result;\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap(keyFn, valueFn) {\n        const entryStream = this.map(element => [\n            keyFn ? keyFn(element) : element,\n            valueFn ? valueFn(element) : element\n        ]);\n        return new Map(entryStream);\n    }\n    toString() {\n        return this.join();\n    }\n    concat(other) {\n        const iterator = other[Symbol.iterator]();\n        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false }), state => {\n            let result;\n            if (!state.firstDone) {\n                do {\n                    result = this.nextFn(state.first);\n                    if (!result.done) {\n                        return result;\n                    }\n                } while (!result.done);\n                state.firstDone = true;\n            }\n            do {\n                result = iterator.next();\n                if (!result.done) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    join(separator = \',\') {\n        const iterator = this.iterator();\n        let value = \'\';\n        let result;\n        let addSeparator = false;\n        do {\n            result = iterator.next();\n            if (!result.done) {\n                if (addSeparator) {\n                    value += separator;\n                }\n                value += stream_toString(result.value);\n            }\n            addSeparator = true;\n        } while (!result.done);\n        return value;\n    }\n    indexOf(searchElement, fromIndex = 0) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (index >= fromIndex && next.value === searchElement) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    every(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (!predicate(next.value)) {\n                return false;\n            }\n            next = iterator.next();\n        }\n        return true;\n    }\n    some(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    forEach(callbackfn) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            callbackfn(next.value, index);\n            next = iterator.next();\n            index++;\n        }\n    }\n    map(callbackfn) {\n        return new StreamImpl(this.startFn, (state) => {\n            const { done, value } = this.nextFn(state);\n            if (done) {\n                return DONE_RESULT;\n            }\n            else {\n                return { done: false, value: callbackfn(value) };\n            }\n        });\n    }\n    filter(predicate) {\n        return new StreamImpl(this.startFn, state => {\n            let result;\n            do {\n                result = this.nextFn(state);\n                if (!result.done && predicate(result.value)) {\n                    return result;\n                }\n            } while (!result.done);\n            return DONE_RESULT;\n        });\n    }\n    nonNullable() {\n        return this.filter(e => e !== undefined && e !== null);\n    }\n    reduce(callbackfn, initialValue) {\n        const iterator = this.iterator();\n        let previousValue = initialValue;\n        let next = iterator.next();\n        while (!next.done) {\n            if (previousValue === undefined) {\n                previousValue = next.value;\n            }\n            else {\n                previousValue = callbackfn(previousValue, next.value);\n            }\n            next = iterator.next();\n        }\n        return previousValue;\n    }\n    reduceRight(callbackfn, initialValue) {\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\n    }\n    recursiveReduce(iterator, callbackfn, initialValue) {\n        const next = iterator.next();\n        if (next.done) {\n            return initialValue;\n        }\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\n        if (previousValue === undefined) {\n            return next.value;\n        }\n        return callbackfn(previousValue, next.value);\n    }\n    find(predicate) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return next.value;\n            }\n            next = iterator.next();\n        }\n        return undefined;\n    }\n    findIndex(predicate) {\n        const iterator = this.iterator();\n        let index = 0;\n        let next = iterator.next();\n        while (!next.done) {\n            if (predicate(next.value)) {\n                return index;\n            }\n            next = iterator.next();\n            index++;\n        }\n        return -1;\n    }\n    includes(searchElement) {\n        const iterator = this.iterator();\n        let next = iterator.next();\n        while (!next.done) {\n            if (next.value === searchElement) {\n                return true;\n            }\n            next = iterator.next();\n        }\n        return false;\n    }\n    flatMap(callbackfn) {\n        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = this.nextFn(state.this);\n                if (!done) {\n                    const mapped = callbackfn(value);\n                    if (isIterable(mapped)) {\n                        state.iterator = mapped[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: mapped };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    flat(depth) {\n        if (depth === undefined) {\n            depth = 1;\n        }\n        if (depth <= 0) {\n            return this;\n        }\n        const stream = depth > 1 ? this.flat(depth - 1) : this;\n        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (next.done) {\n                        state.iterator = undefined;\n                    }\n                    else {\n                        return next;\n                    }\n                }\n                const { done, value } = stream.nextFn(state.this);\n                if (!done) {\n                    if (isIterable(value)) {\n                        state.iterator = value[Symbol.iterator]();\n                    }\n                    else {\n                        return { done: false, value: value };\n                    }\n                }\n            } while (state.iterator);\n            return DONE_RESULT;\n        });\n    }\n    head() {\n        const iterator = this.iterator();\n        const result = iterator.next();\n        if (result.done) {\n            return undefined;\n        }\n        return result.value;\n    }\n    tail(skipCount = 1) {\n        return new StreamImpl(() => {\n            const state = this.startFn();\n            for (let i = 0; i < skipCount; i++) {\n                const next = this.nextFn(state);\n                if (next.done) {\n                    return state;\n                }\n            }\n            return state;\n        }, this.nextFn);\n    }\n    limit(maxSize) {\n        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {\n            state.size++;\n            if (state.size > maxSize) {\n                return DONE_RESULT;\n            }\n            return this.nextFn(state.state);\n        });\n    }\n    distinct(by) {\n        const set = new Set();\n        return this.filter(e => {\n            const value = by ? by(e) : e;\n            if (set.has(value)) {\n                return false;\n            }\n            else {\n                set.add(value);\n                return true;\n            }\n        });\n    }\n    exclude(other, key) {\n        const otherKeySet = new Set();\n        for (const item of other) {\n            const value = key ? key(item) : item;\n            otherKeySet.add(value);\n        }\n        return this.filter(e => {\n            const ownKey = key ? key(e) : e;\n            return !otherKeySet.has(ownKey);\n        });\n    }\n}\nfunction stream_toString(item) {\n    if (typeof item === \'string\') {\n        return item;\n    }\n    if (typeof item === \'undefined\') {\n        return \'undefined\';\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    if (typeof item.toString === \'function\') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return item.toString();\n    }\n    return Object.prototype.toString.call(item);\n}\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === \'function\';\n}\n/**\n * An empty stream of any type.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);\n/**\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\n */\nconst DONE_RESULT = Object.freeze({ done: true, value: undefined });\n/**\n * Create a stream from one or more iterables or array-likes.\n */\nfunction stream_stream(...collections) {\n    if (collections.length === 1) {\n        const collection = collections[0];\n        if (collection instanceof StreamImpl) {\n            return collection;\n        }\n        if (isIterable(collection)) {\n            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());\n        }\n        if (typeof collection.length === \'number\') {\n            return new StreamImpl(() => ({ index: 0 }), (state) => {\n                if (state.index < collection.length) {\n                    return { done: false, value: collection[state.index++] };\n                }\n                else {\n                    return DONE_RESULT;\n                }\n            });\n        }\n    }\n    if (collections.length > 1) {\n        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {\n            do {\n                if (state.iterator) {\n                    const next = state.iterator.next();\n                    if (!next.done) {\n                        return next;\n                    }\n                    state.iterator = undefined;\n                }\n                if (state.array) {\n                    if (state.arrIndex < state.array.length) {\n                        return { done: false, value: state.array[state.arrIndex++] };\n                    }\n                    state.array = undefined;\n                    state.arrIndex = 0;\n                }\n                if (state.collIndex < collections.length) {\n                    const collection = collections[state.collIndex++];\n                    if (isIterable(collection)) {\n                        state.iterator = collection[Symbol.iterator]();\n                    }\n                    else if (collection && typeof collection.length === \'number\') {\n                        state.array = collection;\n                    }\n                }\n            } while (state.iterator || state.array || state.collIndex < collections.length);\n            return DONE_RESULT;\n        });\n    }\n    return EMPTY_STREAM;\n}\n/**\n * The default implementation of `TreeStream` takes a root element and a function that computes the\n * children of its argument. Whether the root node included in the stream is controlled with the\n * `includeRoot` option, which defaults to `false`.\n */\nclass TreeStreamImpl extends StreamImpl {\n    constructor(root, children, options) {\n        super(() => ({\n            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\n            pruned: false\n        }), state => {\n            if (state.pruned) {\n                state.iterators.pop();\n                state.pruned = false;\n            }\n            while (state.iterators.length > 0) {\n                const iterator = state.iterators[state.iterators.length - 1];\n                const next = iterator.next();\n                if (next.done) {\n                    state.iterators.pop();\n                }\n                else {\n                    state.iterators.push(children(next.value)[Symbol.iterator]());\n                    return next;\n                }\n            }\n            return DONE_RESULT;\n        });\n    }\n    iterator() {\n        const iterator = {\n            state: this.startFn(),\n            next: () => this.nextFn(iterator.state),\n            prune: () => {\n                iterator.state.pruned = true;\n            },\n            [Symbol.iterator]: () => iterator\n        };\n        return iterator;\n    }\n}\n/**\n * A set of utility functions that reduce a stream to a single value.\n */\nvar Reduction;\n(function (Reduction) {\n    /**\n     * Compute the sum of a number stream.\n     */\n    function sum(stream) {\n        return stream.reduce((a, b) => a + b, 0);\n    }\n    Reduction.sum = sum;\n    /**\n     * Compute the product of a number stream.\n     */\n    function product(stream) {\n        return stream.reduce((a, b) => a * b, 0);\n    }\n    Reduction.product = product;\n    /**\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function min(stream) {\n        return stream.reduce((a, b) => Math.min(a, b));\n    }\n    Reduction.min = min;\n    /**\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\n     */\n    function max(stream) {\n        return stream.reduce((a, b) => Math.max(a, b));\n    }\n    Reduction.max = max;\n})(Reduction || (Reduction = {}));\n//# sourceMappingURL=stream.js.map\n;// ./node_modules/langium/lib/utils/cst-utils.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nfunction streamCst(node) {\n    return new TreeStreamImpl(node, element => {\n        if (syntax_tree_isCompositeCstNode(element)) {\n            return element.content;\n        }\n        else {\n            return [];\n        }\n    }, { includeRoot: true });\n}\n/**\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\n */\nfunction flattenCst(node) {\n    return streamCst(node).filter(isLeafCstNode);\n}\n/**\n * Determines whether the specified cst node is a child of the specified parent node.\n */\nfunction isChildNode(child, parent) {\n    while (child.container) {\n        child = child.container;\n        if (child === parent) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction tokenToRange(token) {\n    // Chevrotain uses 1-based indices everywhere\n    // So we subtract 1 from every value to align with the LSP\n    return {\n        start: {\n            character: token.startColumn - 1,\n            line: token.startLine - 1\n        },\n        end: {\n            character: token.endColumn,\n            line: token.endLine - 1\n        }\n    };\n}\nfunction toDocumentSegment(node) {\n    if (!node) {\n        return undefined;\n    }\n    const { offset, end, range } = node;\n    return {\n        range,\n        offset,\n        end,\n        length: end - offset\n    };\n}\nvar RangeComparison;\n(function (RangeComparison) {\n    RangeComparison[RangeComparison["Before"] = 0] = "Before";\n    RangeComparison[RangeComparison["After"] = 1] = "After";\n    RangeComparison[RangeComparison["OverlapFront"] = 2] = "OverlapFront";\n    RangeComparison[RangeComparison["OverlapBack"] = 3] = "OverlapBack";\n    RangeComparison[RangeComparison["Inside"] = 4] = "Inside";\n})(RangeComparison || (RangeComparison = {}));\nfunction compareRange(range, to) {\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character < range.start.character)) {\n        return RangeComparison.Before;\n    }\n    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character > to.end.character)) {\n        return RangeComparison.After;\n    }\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\n    if (startInside && endInside) {\n        return RangeComparison.Inside;\n    }\n    else if (startInside) {\n        return RangeComparison.OverlapBack;\n    }\n    else {\n        return RangeComparison.OverlapFront;\n    }\n}\nfunction inRange(range, to) {\n    const comparison = compareRange(range, to);\n    return comparison > RangeComparison.After;\n}\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\n// Together with \\w it matches any kind of character which can commonly appear in IDs\nconst DefaultNameRegexp = /^[\\w\\p{L}]$/u;\n/**\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\n * it will instead return the leaf node at the `offset - 1` position.\n *\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\n */\nfunction findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {\n    if (cstNode) {\n        if (offset > 0) {\n            const localOffset = offset - cstNode.offset;\n            const textAtOffset = cstNode.text.charAt(localOffset);\n            if (!nameRegexp.test(textAtOffset)) {\n                offset--;\n            }\n        }\n        return findLeafNodeAtOffset(cstNode, offset);\n    }\n    return undefined;\n}\nfunction findCommentNode(cstNode, commentNames) {\n    if (cstNode) {\n        const previous = getPreviousNode(cstNode, true);\n        if (previous && isCommentNode(previous, commentNames)) {\n            return previous;\n        }\n        if (isRootCstNode(cstNode)) {\n            // Go from the first non-hidden node through all nodes in reverse order\n            // We do this to find the comment node which directly precedes the root node\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\n            for (let i = endIndex - 1; i >= 0; i--) {\n                const child = cstNode.content[i];\n                if (isCommentNode(child, commentNames)) {\n                    return child;\n                }\n            }\n        }\n    }\n    return undefined;\n}\nfunction isCommentNode(cstNode, commentNames) {\n    return syntax_tree_isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * Note that the given offset will be within the range of the returned leaf node.\n *\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node at the specified offset.\n */\nfunction findLeafNodeAtOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, false);\n        if (searchResult) {\n            return findLeafNodeAtOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\n/**\n * Finds the leaf CST node at the specified 0-based string offset.\n * If no CST node exists at the specified position, it will return the leaf node before it.\n *\n * If there is no leaf node before the specified offset, this method will return `undefined`.\n *\n * @param node The CST node to search through.\n * @param offset The specified offset.\n * @returns The CST node closest to the specified offset.\n */\nfunction findLeafNodeBeforeOffset(node, offset) {\n    if (isLeafCstNode(node)) {\n        return node;\n    }\n    else if (isCompositeCstNode(node)) {\n        const searchResult = binarySearch(node, offset, true);\n        if (searchResult) {\n            return findLeafNodeBeforeOffset(searchResult, offset);\n        }\n    }\n    return undefined;\n}\nfunction binarySearch(node, offset, closest) {\n    let left = 0;\n    let right = node.content.length - 1;\n    let closestNode = undefined;\n    while (left <= right) {\n        const middle = Math.floor((left + right) / 2);\n        const middleNode = node.content[middle];\n        if (middleNode.offset <= offset && middleNode.end > offset) {\n            // Found an exact match\n            return middleNode;\n        }\n        if (middleNode.end <= offset) {\n            // Update the closest node (less than offset) and move to the right half\n            closestNode = closest ? middleNode : undefined;\n            left = middle + 1;\n        }\n        else {\n            // Move to the left half\n            right = middle - 1;\n        }\n    }\n    return closestNode;\n}\nfunction getPreviousNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        while (index > 0) {\n            index--;\n            const previous = parent.content[index];\n            if (hidden || !previous.hidden) {\n                return previous;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nfunction getNextNode(node, hidden = true) {\n    while (node.container) {\n        const parent = node.container;\n        let index = parent.content.indexOf(node);\n        const last = parent.content.length - 1;\n        while (index < last) {\n            index++;\n            const next = parent.content[index];\n            if (hidden || !next.hidden) {\n                return next;\n            }\n        }\n        node = parent;\n    }\n    return undefined;\n}\nfunction getStartlineNode(node) {\n    if (node.range.start.character === 0) {\n        return node;\n    }\n    const line = node.range.start.line;\n    let last = node;\n    let index;\n    while (node.container) {\n        const parent = node.container;\n        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);\n        if (selfIndex === 0) {\n            node = parent;\n            index = undefined;\n        }\n        else {\n            index = selfIndex - 1;\n            node = parent.content[index];\n        }\n        if (node.range.start.line !== line) {\n            break;\n        }\n        last = node;\n    }\n    return last;\n}\nfunction getInteriorNodes(start, end) {\n    const commonParent = getCommonParent(start, end);\n    if (!commonParent) {\n        return [];\n    }\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\n}\nfunction getCommonParent(a, b) {\n    const aParents = getParentChain(a);\n    const bParents = getParentChain(b);\n    let current;\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\n        const aParent = aParents[i];\n        const bParent = bParents[i];\n        if (aParent.parent === bParent.parent) {\n            current = {\n                parent: aParent.parent,\n                a: aParent.index,\n                b: bParent.index\n            };\n        }\n        else {\n            break;\n        }\n    }\n    return current;\n}\nfunction getParentChain(node) {\n    const chain = [];\n    while (node.container) {\n        const parent = node.container;\n        const index = parent.content.indexOf(node);\n        chain.push({\n            parent,\n            index\n        });\n        node = parent;\n    }\n    return chain.reverse();\n}\n//# sourceMappingURL=cst-utils.js.map\n;// ./node_modules/langium/lib/utils/errors.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass ErrorWithLocation extends Error {\n    constructor(node, message) {\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\n    }\n}\nfunction assertUnreachable(_) {\n    throw new Error(\'Error! The input value was not handled.\');\n}\n//# sourceMappingURL=errors.js.map\n;// ./node_modules/langium/lib/languages/generated/ast.js\n/******************************************************************************\n * This file was generated by langium-cli 3.0.0.\n * DO NOT EDIT MANUALLY!\n ******************************************************************************/\n\nconst LangiumGrammarTerminals = {\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\n    STRING: /"(\\\\.|[^"\\\\])*"|\'(\\\\.|[^\'\\\\])*\'/,\n    NUMBER: /NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity)/,\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\n    WS: /\\s+/,\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\n};\nconst AbstractRule = \'AbstractRule\';\nfunction isAbstractRule(item) {\n    return reflection.isInstance(item, AbstractRule);\n}\nconst AbstractType = \'AbstractType\';\nfunction isAbstractType(item) {\n    return reflection.isInstance(item, AbstractType);\n}\nconst Condition = \'Condition\';\nfunction isCondition(item) {\n    return reflection.isInstance(item, Condition);\n}\nfunction isFeatureName(item) {\n    return isPrimitiveType(item) || item === \'current\' || item === \'entry\' || item === \'extends\' || item === \'false\' || item === \'fragment\' || item === \'grammar\' || item === \'hidden\' || item === \'import\' || item === \'interface\' || item === \'returns\' || item === \'terminal\' || item === \'true\' || item === \'type\' || item === \'infer\' || item === \'infers\' || item === \'with\' || (typeof item === \'string\' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\n}\nfunction isPrimitiveType(item) {\n    return item === \'string\' || item === \'number\' || item === \'boolean\' || item === \'Date\' || item === \'bigint\';\n}\nconst TypeDefinition = \'TypeDefinition\';\nfunction isTypeDefinition(item) {\n    return reflection.isInstance(item, TypeDefinition);\n}\nconst ValueLiteral = \'ValueLiteral\';\nfunction isValueLiteral(item) {\n    return reflection.isInstance(item, ValueLiteral);\n}\nconst AbstractElement = \'AbstractElement\';\nfunction isAbstractElement(item) {\n    return reflection.isInstance(item, AbstractElement);\n}\nconst ArrayLiteral = \'ArrayLiteral\';\nfunction isArrayLiteral(item) {\n    return reflection.isInstance(item, ArrayLiteral);\n}\nconst ArrayType = \'ArrayType\';\nfunction isArrayType(item) {\n    return reflection.isInstance(item, ArrayType);\n}\nconst BooleanLiteral = \'BooleanLiteral\';\nfunction isBooleanLiteral(item) {\n    return reflection.isInstance(item, BooleanLiteral);\n}\nconst Conjunction = \'Conjunction\';\nfunction isConjunction(item) {\n    return reflection.isInstance(item, Conjunction);\n}\nconst Disjunction = \'Disjunction\';\nfunction isDisjunction(item) {\n    return reflection.isInstance(item, Disjunction);\n}\nconst Grammar = \'Grammar\';\nfunction isGrammar(item) {\n    return reflection.isInstance(item, Grammar);\n}\nconst GrammarImport = \'GrammarImport\';\nfunction isGrammarImport(item) {\n    return reflection.isInstance(item, GrammarImport);\n}\nconst InferredType = \'InferredType\';\nfunction isInferredType(item) {\n    return reflection.isInstance(item, InferredType);\n}\nconst Interface = \'Interface\';\nfunction isInterface(item) {\n    return reflection.isInstance(item, Interface);\n}\nconst NamedArgument = \'NamedArgument\';\nfunction isNamedArgument(item) {\n    return reflection.isInstance(item, NamedArgument);\n}\nconst Negation = \'Negation\';\nfunction isNegation(item) {\n    return reflection.isInstance(item, Negation);\n}\nconst NumberLiteral = \'NumberLiteral\';\nfunction isNumberLiteral(item) {\n    return reflection.isInstance(item, NumberLiteral);\n}\nconst Parameter = \'Parameter\';\nfunction isParameter(item) {\n    return reflection.isInstance(item, Parameter);\n}\nconst ParameterReference = \'ParameterReference\';\nfunction isParameterReference(item) {\n    return reflection.isInstance(item, ParameterReference);\n}\nconst ParserRule = \'ParserRule\';\nfunction isParserRule(item) {\n    return reflection.isInstance(item, ParserRule);\n}\nconst ReferenceType = \'ReferenceType\';\nfunction isReferenceType(item) {\n    return reflection.isInstance(item, ReferenceType);\n}\nconst ReturnType = \'ReturnType\';\nfunction isReturnType(item) {\n    return reflection.isInstance(item, ReturnType);\n}\nconst SimpleType = \'SimpleType\';\nfunction isSimpleType(item) {\n    return reflection.isInstance(item, SimpleType);\n}\nconst StringLiteral = \'StringLiteral\';\nfunction isStringLiteral(item) {\n    return reflection.isInstance(item, StringLiteral);\n}\nconst TerminalRule = \'TerminalRule\';\nfunction isTerminalRule(item) {\n    return reflection.isInstance(item, TerminalRule);\n}\nconst Type = \'Type\';\nfunction isType(item) {\n    return reflection.isInstance(item, Type);\n}\nconst TypeAttribute = \'TypeAttribute\';\nfunction isTypeAttribute(item) {\n    return reflection.isInstance(item, TypeAttribute);\n}\nconst UnionType = \'UnionType\';\nfunction isUnionType(item) {\n    return reflection.isInstance(item, UnionType);\n}\nconst Action = \'Action\';\nfunction isAction(item) {\n    return reflection.isInstance(item, Action);\n}\nconst Alternatives = \'Alternatives\';\nfunction isAlternatives(item) {\n    return reflection.isInstance(item, Alternatives);\n}\nconst Assignment = \'Assignment\';\nfunction isAssignment(item) {\n    return reflection.isInstance(item, Assignment);\n}\nconst CharacterRange = \'CharacterRange\';\nfunction isCharacterRange(item) {\n    return reflection.isInstance(item, CharacterRange);\n}\nconst CrossReference = \'CrossReference\';\nfunction isCrossReference(item) {\n    return reflection.isInstance(item, CrossReference);\n}\nconst EndOfFile = \'EndOfFile\';\nfunction isEndOfFile(item) {\n    return reflection.isInstance(item, EndOfFile);\n}\nconst Group = \'Group\';\nfunction isGroup(item) {\n    return reflection.isInstance(item, Group);\n}\nconst Keyword = \'Keyword\';\nfunction isKeyword(item) {\n    return reflection.isInstance(item, Keyword);\n}\nconst NegatedToken = \'NegatedToken\';\nfunction isNegatedToken(item) {\n    return reflection.isInstance(item, NegatedToken);\n}\nconst RegexToken = \'RegexToken\';\nfunction isRegexToken(item) {\n    return reflection.isInstance(item, RegexToken);\n}\nconst RuleCall = \'RuleCall\';\nfunction isRuleCall(item) {\n    return reflection.isInstance(item, RuleCall);\n}\nconst TerminalAlternatives = \'TerminalAlternatives\';\nfunction isTerminalAlternatives(item) {\n    return reflection.isInstance(item, TerminalAlternatives);\n}\nconst TerminalGroup = \'TerminalGroup\';\nfunction isTerminalGroup(item) {\n    return reflection.isInstance(item, TerminalGroup);\n}\nconst TerminalRuleCall = \'TerminalRuleCall\';\nfunction isTerminalRuleCall(item) {\n    return reflection.isInstance(item, TerminalRuleCall);\n}\nconst UnorderedGroup = \'UnorderedGroup\';\nfunction isUnorderedGroup(item) {\n    return reflection.isInstance(item, UnorderedGroup);\n}\nconst UntilToken = \'UntilToken\';\nfunction isUntilToken(item) {\n    return reflection.isInstance(item, UntilToken);\n}\nconst Wildcard = \'Wildcard\';\nfunction isWildcard(item) {\n    return reflection.isInstance(item, Wildcard);\n}\nclass LangiumGrammarAstReflection extends AbstractAstReflection {\n    getAllTypes() {\n        return [\'AbstractElement\', \'AbstractRule\', \'AbstractType\', \'Action\', \'Alternatives\', \'ArrayLiteral\', \'ArrayType\', \'Assignment\', \'BooleanLiteral\', \'CharacterRange\', \'Condition\', \'Conjunction\', \'CrossReference\', \'Disjunction\', \'EndOfFile\', \'Grammar\', \'GrammarImport\', \'Group\', \'InferredType\', \'Interface\', \'Keyword\', \'NamedArgument\', \'NegatedToken\', \'Negation\', \'NumberLiteral\', \'Parameter\', \'ParameterReference\', \'ParserRule\', \'ReferenceType\', \'RegexToken\', \'ReturnType\', \'RuleCall\', \'SimpleType\', \'StringLiteral\', \'TerminalAlternatives\', \'TerminalGroup\', \'TerminalRule\', \'TerminalRuleCall\', \'Type\', \'TypeAttribute\', \'TypeDefinition\', \'UnionType\', \'UnorderedGroup\', \'UntilToken\', \'ValueLiteral\', \'Wildcard\'];\n    }\n    computeIsSubtype(subtype, supertype) {\n        switch (subtype) {\n            case Action:\n            case Alternatives:\n            case Assignment:\n            case CharacterRange:\n            case CrossReference:\n            case EndOfFile:\n            case Group:\n            case Keyword:\n            case NegatedToken:\n            case RegexToken:\n            case RuleCall:\n            case TerminalAlternatives:\n            case TerminalGroup:\n            case TerminalRuleCall:\n            case UnorderedGroup:\n            case UntilToken:\n            case Wildcard: {\n                return this.isSubtype(AbstractElement, supertype);\n            }\n            case ArrayLiteral:\n            case NumberLiteral:\n            case StringLiteral: {\n                return this.isSubtype(ValueLiteral, supertype);\n            }\n            case ArrayType:\n            case ReferenceType:\n            case SimpleType:\n            case UnionType: {\n                return this.isSubtype(TypeDefinition, supertype);\n            }\n            case BooleanLiteral: {\n                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);\n            }\n            case Conjunction:\n            case Disjunction:\n            case Negation:\n            case ParameterReference: {\n                return this.isSubtype(Condition, supertype);\n            }\n            case InferredType:\n            case Interface:\n            case Type: {\n                return this.isSubtype(AbstractType, supertype);\n            }\n            case ParserRule: {\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\n            }\n            case TerminalRule: {\n                return this.isSubtype(AbstractRule, supertype);\n            }\n            default: {\n                return false;\n            }\n        }\n    }\n    getReferenceType(refInfo) {\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\n        switch (referenceId) {\n            case \'Action:type\':\n            case \'CrossReference:type\':\n            case \'Interface:superTypes\':\n            case \'ParserRule:returnType\':\n            case \'SimpleType:typeRef\': {\n                return AbstractType;\n            }\n            case \'Grammar:hiddenTokens\':\n            case \'ParserRule:hiddenTokens\':\n            case \'RuleCall:rule\': {\n                return AbstractRule;\n            }\n            case \'Grammar:usedGrammars\': {\n                return Grammar;\n            }\n            case \'NamedArgument:parameter\':\n            case \'ParameterReference:parameter\': {\n                return Parameter;\n            }\n            case \'TerminalRuleCall:rule\': {\n                return TerminalRule;\n            }\n            default: {\n                throw new Error(`${referenceId} is not a valid reference id.`);\n            }\n        }\n    }\n    getTypeMetaData(type) {\n        switch (type) {\n            case \'AbstractElement\': {\n                return {\n                    name: \'AbstractElement\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'ArrayLiteral\': {\n                return {\n                    name: \'ArrayLiteral\',\n                    properties: [\n                        { name: \'elements\', defaultValue: [] }\n                    ]\n                };\n            }\n            case \'ArrayType\': {\n                return {\n                    name: \'ArrayType\',\n                    properties: [\n                        { name: \'elementType\' }\n                    ]\n                };\n            }\n            case \'BooleanLiteral\': {\n                return {\n                    name: \'BooleanLiteral\',\n                    properties: [\n                        { name: \'true\', defaultValue: false }\n                    ]\n                };\n            }\n            case \'Conjunction\': {\n                return {\n                    name: \'Conjunction\',\n                    properties: [\n                        { name: \'left\' },\n                        { name: \'right\' }\n                    ]\n                };\n            }\n            case \'Disjunction\': {\n                return {\n                    name: \'Disjunction\',\n                    properties: [\n                        { name: \'left\' },\n                        { name: \'right\' }\n                    ]\n                };\n            }\n            case \'Grammar\': {\n                return {\n                    name: \'Grammar\',\n                    properties: [\n                        { name: \'definesHiddenTokens\', defaultValue: false },\n                        { name: \'hiddenTokens\', defaultValue: [] },\n                        { name: \'imports\', defaultValue: [] },\n                        { name: \'interfaces\', defaultValue: [] },\n                        { name: \'isDeclared\', defaultValue: false },\n                        { name: \'name\' },\n                        { name: \'rules\', defaultValue: [] },\n                        { name: \'types\', defaultValue: [] },\n                        { name: \'usedGrammars\', defaultValue: [] }\n                    ]\n                };\n            }\n            case \'GrammarImport\': {\n                return {\n                    name: \'GrammarImport\',\n                    properties: [\n                        { name: \'path\' }\n                    ]\n                };\n            }\n            case \'InferredType\': {\n                return {\n                    name: \'InferredType\',\n                    properties: [\n                        { name: \'name\' }\n                    ]\n                };\n            }\n            case \'Interface\': {\n                return {\n                    name: \'Interface\',\n                    properties: [\n                        { name: \'attributes\', defaultValue: [] },\n                        { name: \'name\' },\n                        { name: \'superTypes\', defaultValue: [] }\n                    ]\n                };\n            }\n            case \'NamedArgument\': {\n                return {\n                    name: \'NamedArgument\',\n                    properties: [\n                        { name: \'calledByName\', defaultValue: false },\n                        { name: \'parameter\' },\n                        { name: \'value\' }\n                    ]\n                };\n            }\n            case \'Negation\': {\n                return {\n                    name: \'Negation\',\n                    properties: [\n                        { name: \'value\' }\n                    ]\n                };\n            }\n            case \'NumberLiteral\': {\n                return {\n                    name: \'NumberLiteral\',\n                    properties: [\n                        { name: \'value\' }\n                    ]\n                };\n            }\n            case \'Parameter\': {\n                return {\n                    name: \'Parameter\',\n                    properties: [\n                        { name: \'name\' }\n                    ]\n                };\n            }\n            case \'ParameterReference\': {\n                return {\n                    name: \'ParameterReference\',\n                    properties: [\n                        { name: \'parameter\' }\n                    ]\n                };\n            }\n            case \'ParserRule\': {\n                return {\n                    name: \'ParserRule\',\n                    properties: [\n                        { name: \'dataType\' },\n                        { name: \'definesHiddenTokens\', defaultValue: false },\n                        { name: \'definition\' },\n                        { name: \'entry\', defaultValue: false },\n                        { name: \'fragment\', defaultValue: false },\n                        { name: \'hiddenTokens\', defaultValue: [] },\n                        { name: \'inferredType\' },\n                        { name: \'name\' },\n                        { name: \'parameters\', defaultValue: [] },\n                        { name: \'returnType\' },\n                        { name: \'wildcard\', defaultValue: false }\n                    ]\n                };\n            }\n            case \'ReferenceType\': {\n                return {\n                    name: \'ReferenceType\',\n                    properties: [\n                        { name: \'referenceType\' }\n                    ]\n                };\n            }\n            case \'ReturnType\': {\n                return {\n                    name: \'ReturnType\',\n                    properties: [\n                        { name: \'name\' }\n                    ]\n                };\n            }\n            case \'SimpleType\': {\n                return {\n                    name: \'SimpleType\',\n                    properties: [\n                        { name: \'primitiveType\' },\n                        { name: \'stringType\' },\n                        { name: \'typeRef\' }\n                    ]\n                };\n            }\n            case \'StringLiteral\': {\n                return {\n                    name: \'StringLiteral\',\n                    properties: [\n                        { name: \'value\' }\n                    ]\n                };\n            }\n            case \'TerminalRule\': {\n                return {\n                    name: \'TerminalRule\',\n                    properties: [\n                        { name: \'definition\' },\n                        { name: \'fragment\', defaultValue: false },\n                        { name: \'hidden\', defaultValue: false },\n                        { name: \'name\' },\n                        { name: \'type\' }\n                    ]\n                };\n            }\n            case \'Type\': {\n                return {\n                    name: \'Type\',\n                    properties: [\n                        { name: \'name\' },\n                        { name: \'type\' }\n                    ]\n                };\n            }\n            case \'TypeAttribute\': {\n                return {\n                    name: \'TypeAttribute\',\n                    properties: [\n                        { name: \'defaultValue\' },\n                        { name: \'isOptional\', defaultValue: false },\n                        { name: \'name\' },\n                        { name: \'type\' }\n                    ]\n                };\n            }\n            case \'UnionType\': {\n                return {\n                    name: \'UnionType\',\n                    properties: [\n                        { name: \'types\', defaultValue: [] }\n                    ]\n                };\n            }\n            case \'Action\': {\n                return {\n                    name: \'Action\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'feature\' },\n                        { name: \'inferredType\' },\n                        { name: \'lookahead\' },\n                        { name: \'operator\' },\n                        { name: \'type\' }\n                    ]\n                };\n            }\n            case \'Alternatives\': {\n                return {\n                    name: \'Alternatives\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'elements\', defaultValue: [] },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'Assignment\': {\n                return {\n                    name: \'Assignment\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'feature\' },\n                        { name: \'lookahead\' },\n                        { name: \'operator\' },\n                        { name: \'terminal\' }\n                    ]\n                };\n            }\n            case \'CharacterRange\': {\n                return {\n                    name: \'CharacterRange\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'left\' },\n                        { name: \'lookahead\' },\n                        { name: \'right\' }\n                    ]\n                };\n            }\n            case \'CrossReference\': {\n                return {\n                    name: \'CrossReference\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'deprecatedSyntax\', defaultValue: false },\n                        { name: \'lookahead\' },\n                        { name: \'terminal\' },\n                        { name: \'type\' }\n                    ]\n                };\n            }\n            case \'EndOfFile\': {\n                return {\n                    name: \'EndOfFile\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'Group\': {\n                return {\n                    name: \'Group\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'elements\', defaultValue: [] },\n                        { name: \'guardCondition\' },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'Keyword\': {\n                return {\n                    name: \'Keyword\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'value\' }\n                    ]\n                };\n            }\n            case \'NegatedToken\': {\n                return {\n                    name: \'NegatedToken\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'terminal\' }\n                    ]\n                };\n            }\n            case \'RegexToken\': {\n                return {\n                    name: \'RegexToken\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'regex\' }\n                    ]\n                };\n            }\n            case \'RuleCall\': {\n                return {\n                    name: \'RuleCall\',\n                    properties: [\n                        { name: \'arguments\', defaultValue: [] },\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'rule\' }\n                    ]\n                };\n            }\n            case \'TerminalAlternatives\': {\n                return {\n                    name: \'TerminalAlternatives\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'elements\', defaultValue: [] },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'TerminalGroup\': {\n                return {\n                    name: \'TerminalGroup\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'elements\', defaultValue: [] },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'TerminalRuleCall\': {\n                return {\n                    name: \'TerminalRuleCall\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'rule\' }\n                    ]\n                };\n            }\n            case \'UnorderedGroup\': {\n                return {\n                    name: \'UnorderedGroup\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'elements\', defaultValue: [] },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            case \'UntilToken\': {\n                return {\n                    name: \'UntilToken\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' },\n                        { name: \'terminal\' }\n                    ]\n                };\n            }\n            case \'Wildcard\': {\n                return {\n                    name: \'Wildcard\',\n                    properties: [\n                        { name: \'cardinality\' },\n                        { name: \'lookahead\' }\n                    ]\n                };\n            }\n            default: {\n                return {\n                    name: type,\n                    properties: []\n                };\n            }\n        }\n    }\n}\nconst reflection = new LangiumGrammarAstReflection();\n//# sourceMappingURL=ast.js.map\n;// ./node_modules/langium/lib/utils/ast-utils.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n/**\n * Link the `$container` and other related properties of every AST node that is directly contained\n * in the given `node`.\n */\nfunction linkContentToContainer(node) {\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith(\'$\')) {\n            if (Array.isArray(value)) {\n                value.forEach((item, index) => {\n                    if (syntax_tree_isAstNode(item)) {\n                        item.$container = node;\n                        item.$containerProperty = name;\n                        item.$containerIndex = index;\n                    }\n                });\n            }\n            else if (syntax_tree_isAstNode(value)) {\n                value.$container = node;\n                value.$containerProperty = name;\n            }\n        }\n    }\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\n * node that matches the type predicate. If the start node itself matches, it is returned.\n * If no container matches, `undefined` is returned.\n */\nfunction getContainerOfType(node, typePredicate) {\n    let item = node;\n    while (item) {\n        if (typePredicate(item)) {\n            return item;\n        }\n        item = item.$container;\n    }\n    return undefined;\n}\n/**\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\n * of a container that matches the given predicate. The start node is included in the checks.\n */\nfunction hasContainerOfType(node, predicate) {\n    let item = node;\n    while (item) {\n        if (predicate(item)) {\n            return true;\n        }\n        item = item.$container;\n    }\n    return false;\n}\n/**\n * Retrieve the document in which the given AST node is contained. A reference to the document is\n * usually held by the root node of the AST.\n *\n * @throws an error if the node is not contained in a document.\n */\nfunction getDocument(node) {\n    const rootNode = findRootNode(node);\n    const result = rootNode.$document;\n    if (!result) {\n        throw new Error(\'AST node has no document.\');\n    }\n    return result;\n}\n/**\n * Returns the root node of the given AST node by following the `$container` references.\n */\nfunction findRootNode(node) {\n    while (node.$container) {\n        node = node.$container;\n    }\n    return node;\n}\n/**\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nfunction streamContents(node, options) {\n    if (!node) {\n        throw new Error(\'Node must be an AstNode.\');\n    }\n    const range = options === null || options === void 0 ? void 0 : options.range;\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith(\'$\')) {\n                const value = node[property];\n                if (syntax_tree_isAstNode(value)) {\n                    state.keyIndex++;\n                    if (isAstNodeInRange(value, range)) {\n                        return { done: false, value };\n                    }\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (syntax_tree_isAstNode(element) && isAstNodeInRange(element, range)) {\n                            return { done: false, value: element };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\n * This does not include the root node itself.\n */\nfunction ast_utils_streamAllContents(root, options) {\n    if (!root) {\n        throw new Error(\'Root node must be an AstNode.\');\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options));\n}\n/**\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\n * including the root node itself.\n */\nfunction streamAst(root, options) {\n    if (!root) {\n        throw new Error(\'Root node must be an AstNode.\');\n    }\n    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {\n        // Return an empty stream if the root node isn\'t in range\n        return new TreeStreamImpl(root, () => []);\n    }\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\n}\nfunction isAstNodeInRange(astNode, range) {\n    var _a;\n    if (!range) {\n        return true;\n    }\n    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;\n    if (!nodeRange) {\n        return false;\n    }\n    return inRange(nodeRange, range);\n}\n/**\n * Create a stream of all cross-references that are held by the given AST node. This includes\n * single-valued as well as multi-valued (array) properties.\n */\nfunction streamReferences(node) {\n    return new StreamImpl(() => ({\n        keys: Object.keys(node),\n        keyIndex: 0,\n        arrayIndex: 0\n    }), state => {\n        while (state.keyIndex < state.keys.length) {\n            const property = state.keys[state.keyIndex];\n            if (!property.startsWith(\'$\')) {\n                const value = node[property];\n                if (syntax_tree_isReference(value)) {\n                    state.keyIndex++;\n                    return { done: false, value: { reference: value, container: node, property } };\n                }\n                else if (Array.isArray(value)) {\n                    while (state.arrayIndex < value.length) {\n                        const index = state.arrayIndex++;\n                        const element = value[index];\n                        if (syntax_tree_isReference(element)) {\n                            return { done: false, value: { reference: element, container: node, property, index } };\n                        }\n                    }\n                    state.arrayIndex = 0;\n                }\n            }\n            state.keyIndex++;\n        }\n        return DONE_RESULT;\n    });\n}\n/**\n * Returns a Stream of references to the target node from the AstNode tree\n *\n * @param targetNode AstNode we are looking for\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\n */\nfunction findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {\n    const refs = [];\n    streamAst(lookup).forEach(node => {\n        streamReferences(node).forEach(refInfo => {\n            if (refInfo.reference.ref === targetNode) {\n                refs.push(refInfo.reference);\n            }\n        });\n    });\n    return stream(refs);\n}\n/**\n * Assigns all mandatory AST properties to the specified node.\n *\n * @param reflection Reflection object used to gather mandatory properties for the node.\n * @param node Specified node is modified in place and properties are directly assigned.\n */\nfunction assignMandatoryProperties(reflection, node) {\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\n    const genericNode = node;\n    for (const property of typeMetaData.properties) {\n        // Only set the value if the property is not already set and if it has a default value\n        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {\n            genericNode[property.name] = copyDefaultValue(property.defaultValue);\n        }\n    }\n}\nfunction copyDefaultValue(propertyType) {\n    if (Array.isArray(propertyType)) {\n        return [...propertyType.map(copyDefaultValue)];\n    }\n    else {\n        return propertyType;\n    }\n}\n/**\n * Creates a deep copy of the specified AST node.\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\n *\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\n */\nfunction copyAstNode(node, buildReference) {\n    const copy = { $type: node.$type };\n    for (const [name, value] of Object.entries(node)) {\n        if (!name.startsWith(\'$\')) {\n            if (isAstNode(value)) {\n                copy[name] = copyAstNode(value, buildReference);\n            }\n            else if (isReference(value)) {\n                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);\n            }\n            else if (Array.isArray(value)) {\n                const copiedArray = [];\n                for (const element of value) {\n                    if (isAstNode(element)) {\n                        copiedArray.push(copyAstNode(element, buildReference));\n                    }\n                    else if (isReference(element)) {\n                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));\n                    }\n                    else {\n                        copiedArray.push(element);\n                    }\n                }\n                copy[name] = copiedArray;\n            }\n            else {\n                copy[name] = value;\n            }\n        }\n    }\n    linkContentToContainer(copy);\n    return copy;\n}\n//# sourceMappingURL=ast-utils.js.map\n;// ./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js\nfunction cc(char) {\n    return char.charCodeAt(0);\n}\nfunction insertToSet(item, set) {\n    if (Array.isArray(item)) {\n        item.forEach(function (subItem) {\n            set.push(subItem);\n        });\n    }\n    else {\n        set.push(item);\n    }\n}\nfunction addFlag(flagObj, flagKey) {\n    if (flagObj[flagKey] === true) {\n        throw "duplicate flag " + flagKey;\n    }\n    const x = flagObj[flagKey];\n    flagObj[flagKey] = true;\n}\nfunction ASSERT_EXISTS(obj) {\n    // istanbul ignore next\n    if (obj === undefined) {\n        throw Error("Internal Error - Should never get here!");\n    }\n    return true;\n}\n// istanbul ignore next\nfunction ASSERT_NEVER_REACH_HERE() {\n    throw Error("Internal Error - Should never get here!");\n}\nfunction isCharacter(obj) {\n    return obj["type"] === "Character";\n}\n//# sourceMappingURL=utils.js.map\n;// ./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js\n\nconst digitsCharCodes = [];\nfor (let i = cc("0"); i <= cc("9"); i++) {\n    digitsCharCodes.push(i);\n}\nconst wordCharCodes = [cc("_")].concat(digitsCharCodes);\nfor (let i = cc("a"); i <= cc("z"); i++) {\n    wordCharCodes.push(i);\n}\nfor (let i = cc("A"); i <= cc("Z"); i++) {\n    wordCharCodes.push(i);\n}\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\nconst whitespaceCodes = [\n    cc(" "),\n    cc("\\f"),\n    cc("\\n"),\n    cc("\\r"),\n    cc("\\t"),\n    cc("\\v"),\n    cc("\\t"),\n    cc("\\u00a0"),\n    cc("\\u1680"),\n    cc("\\u2000"),\n    cc("\\u2001"),\n    cc("\\u2002"),\n    cc("\\u2003"),\n    cc("\\u2004"),\n    cc("\\u2005"),\n    cc("\\u2006"),\n    cc("\\u2007"),\n    cc("\\u2008"),\n    cc("\\u2009"),\n    cc("\\u200a"),\n    cc("\\u2028"),\n    cc("\\u2029"),\n    cc("\\u202f"),\n    cc("\\u205f"),\n    cc("\\u3000"),\n    cc("\\ufeff"),\n];\n//# sourceMappingURL=character-classes.js.map\n;// ./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js\n\n\n// consts and utilities\nconst hexDigitPattern = /[0-9a-fA-F]/;\nconst decimalPattern = /[0-9]/;\nconst decimalPatternNoZero = /[1-9]/;\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\nclass RegExpParser {\n    constructor() {\n        this.idx = 0;\n        this.input = "";\n        this.groupIdx = 0;\n    }\n    saveState() {\n        return {\n            idx: this.idx,\n            input: this.input,\n            groupIdx: this.groupIdx,\n        };\n    }\n    restoreState(newState) {\n        this.idx = newState.idx;\n        this.input = newState.input;\n        this.groupIdx = newState.groupIdx;\n    }\n    pattern(input) {\n        // parser state\n        this.idx = 0;\n        this.input = input;\n        this.groupIdx = 0;\n        this.consumeChar("/");\n        const value = this.disjunction();\n        this.consumeChar("/");\n        const flags = {\n            type: "Flags",\n            loc: { begin: this.idx, end: input.length },\n            global: false,\n            ignoreCase: false,\n            multiLine: false,\n            unicode: false,\n            sticky: false,\n        };\n        while (this.isRegExpFlag()) {\n            switch (this.popChar()) {\n                case "g":\n                    addFlag(flags, "global");\n                    break;\n                case "i":\n                    addFlag(flags, "ignoreCase");\n                    break;\n                case "m":\n                    addFlag(flags, "multiLine");\n                    break;\n                case "u":\n                    addFlag(flags, "unicode");\n                    break;\n                case "y":\n                    addFlag(flags, "sticky");\n                    break;\n            }\n        }\n        if (this.idx !== this.input.length) {\n            throw Error("Redundant input: " + this.input.substring(this.idx));\n        }\n        return {\n            type: "Pattern",\n            flags: flags,\n            value: value,\n            loc: this.loc(0),\n        };\n    }\n    disjunction() {\n        const alts = [];\n        const begin = this.idx;\n        alts.push(this.alternative());\n        while (this.peekChar() === "|") {\n            this.consumeChar("|");\n            alts.push(this.alternative());\n        }\n        return { type: "Disjunction", value: alts, loc: this.loc(begin) };\n    }\n    alternative() {\n        const terms = [];\n        const begin = this.idx;\n        while (this.isTerm()) {\n            terms.push(this.term());\n        }\n        return { type: "Alternative", value: terms, loc: this.loc(begin) };\n    }\n    term() {\n        if (this.isAssertion()) {\n            return this.assertion();\n        }\n        else {\n            return this.atom();\n        }\n    }\n    assertion() {\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case "^":\n                return {\n                    type: "StartAnchor",\n                    loc: this.loc(begin),\n                };\n            case "$":\n                return { type: "EndAnchor", loc: this.loc(begin) };\n            // \'\\b\' or \'\\B\'\n            case "\\\\":\n                switch (this.popChar()) {\n                    case "b":\n                        return {\n                            type: "WordBoundary",\n                            loc: this.loc(begin),\n                        };\n                    case "B":\n                        return {\n                            type: "NonWordBoundary",\n                            loc: this.loc(begin),\n                        };\n                }\n                // istanbul ignore next\n                throw Error("Invalid Assertion Escape");\n            // \'(?=\' or \'(?!\'\n            case "(":\n                this.consumeChar("?");\n                let type;\n                switch (this.popChar()) {\n                    case "=":\n                        type = "Lookahead";\n                        break;\n                    case "!":\n                        type = "NegativeLookahead";\n                        break;\n                }\n                ASSERT_EXISTS(type);\n                const disjunction = this.disjunction();\n                this.consumeChar(")");\n                return {\n                    type: type,\n                    value: disjunction,\n                    loc: this.loc(begin),\n                };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    quantifier(isBacktracking = false) {\n        let range = undefined;\n        const begin = this.idx;\n        switch (this.popChar()) {\n            case "*":\n                range = {\n                    atLeast: 0,\n                    atMost: Infinity,\n                };\n                break;\n            case "+":\n                range = {\n                    atLeast: 1,\n                    atMost: Infinity,\n                };\n                break;\n            case "?":\n                range = {\n                    atLeast: 0,\n                    atMost: 1,\n                };\n                break;\n            case "{":\n                const atLeast = this.integerIncludingZero();\n                switch (this.popChar()) {\n                    case "}":\n                        range = {\n                            atLeast: atLeast,\n                            atMost: atLeast,\n                        };\n                        break;\n                    case ",":\n                        let atMost;\n                        if (this.isDigit()) {\n                            atMost = this.integerIncludingZero();\n                            range = {\n                                atLeast: atLeast,\n                                atMost: atMost,\n                            };\n                        }\n                        else {\n                            range = {\n                                atLeast: atLeast,\n                                atMost: Infinity,\n                            };\n                        }\n                        this.consumeChar("}");\n                        break;\n                }\n                // throwing exceptions from "ASSERT_EXISTS" during backtracking\n                // causes severe performance degradations\n                if (isBacktracking === true && range === undefined) {\n                    return undefined;\n                }\n                ASSERT_EXISTS(range);\n                break;\n        }\n        // throwing exceptions from "ASSERT_EXISTS" during backtracking\n        // causes severe performance degradations\n        if (isBacktracking === true && range === undefined) {\n            return undefined;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(range)) {\n            if (this.peekChar(0) === "?") {\n                this.consumeChar("?");\n                range.greedy = false;\n            }\n            else {\n                range.greedy = true;\n            }\n            range.type = "Quantifier";\n            range.loc = this.loc(begin);\n            return range;\n        }\n    }\n    atom() {\n        let atom;\n        const begin = this.idx;\n        switch (this.peekChar()) {\n            case ".":\n                atom = this.dotAll();\n                break;\n            case "\\\\":\n                atom = this.atomEscape();\n                break;\n            case "[":\n                atom = this.characterClass();\n                break;\n            case "(":\n                atom = this.group();\n                break;\n        }\n        if (atom === undefined && this.isPatternCharacter()) {\n            atom = this.patternCharacter();\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(atom)) {\n            atom.loc = this.loc(begin);\n            if (this.isQuantifier()) {\n                atom.quantifier = this.quantifier();\n            }\n            return atom;\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    dotAll() {\n        this.consumeChar(".");\n        return {\n            type: "Set",\n            complement: true,\n            value: [cc("\\n"), cc("\\r"), cc("\\u2028"), cc("\\u2029")],\n        };\n    }\n    atomEscape() {\n        this.consumeChar("\\\\");\n        switch (this.peekChar()) {\n            case "1":\n            case "2":\n            case "3":\n            case "4":\n            case "5":\n            case "6":\n            case "7":\n            case "8":\n            case "9":\n                return this.decimalEscapeAtom();\n            case "d":\n            case "D":\n            case "s":\n            case "S":\n            case "w":\n            case "W":\n                return this.characterClassEscape();\n            case "f":\n            case "n":\n            case "r":\n            case "t":\n            case "v":\n                return this.controlEscapeAtom();\n            case "c":\n                return this.controlLetterEscapeAtom();\n            case "0":\n                return this.nulCharacterAtom();\n            case "x":\n                return this.hexEscapeSequenceAtom();\n            case "u":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    decimalEscapeAtom() {\n        const value = this.positiveInteger();\n        return { type: "GroupBackReference", value: value };\n    }\n    characterClassEscape() {\n        let set;\n        let complement = false;\n        switch (this.popChar()) {\n            case "d":\n                set = digitsCharCodes;\n                break;\n            case "D":\n                set = digitsCharCodes;\n                complement = true;\n                break;\n            case "s":\n                set = whitespaceCodes;\n                break;\n            case "S":\n                set = whitespaceCodes;\n                complement = true;\n                break;\n            case "w":\n                set = wordCharCodes;\n                break;\n            case "W":\n                set = wordCharCodes;\n                complement = true;\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(set)) {\n            return { type: "Set", value: set, complement: complement };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlEscapeAtom() {\n        let escapeCode;\n        switch (this.popChar()) {\n            case "f":\n                escapeCode = cc("\\f");\n                break;\n            case "n":\n                escapeCode = cc("\\n");\n                break;\n            case "r":\n                escapeCode = cc("\\r");\n                break;\n            case "t":\n                escapeCode = cc("\\t");\n                break;\n            case "v":\n                escapeCode = cc("\\v");\n                break;\n        }\n        // istanbul ignore else\n        if (ASSERT_EXISTS(escapeCode)) {\n            return { type: "Character", value: escapeCode };\n        }\n        // istanbul ignore next\n        return ASSERT_NEVER_REACH_HERE();\n    }\n    controlLetterEscapeAtom() {\n        this.consumeChar("c");\n        const letter = this.popChar();\n        if (/[a-zA-Z]/.test(letter) === false) {\n            throw Error("Invalid ");\n        }\n        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\n        return { type: "Character", value: letterCode };\n    }\n    nulCharacterAtom() {\n        // TODO implement \'[lookahead \u2209 DecimalDigit]\'\n        // TODO: for the deprecated octal escape sequence\n        this.consumeChar("0");\n        return { type: "Character", value: cc("\\0") };\n    }\n    hexEscapeSequenceAtom() {\n        this.consumeChar("x");\n        return this.parseHexDigits(2);\n    }\n    regExpUnicodeEscapeSequenceAtom() {\n        this.consumeChar("u");\n        return this.parseHexDigits(4);\n    }\n    identityEscapeAtom() {\n        // TODO: implement "SourceCharacter but not UnicodeIDContinue"\n        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\n        const escapedChar = this.popChar();\n        return { type: "Character", value: cc(escapedChar) };\n    }\n    classPatternCharacterAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case "\\n":\n            // istanbul ignore next\n            case "\\r":\n            // istanbul ignore next\n            case "\\u2028":\n            // istanbul ignore next\n            case "\\u2029":\n            // istanbul ignore next\n            case "\\\\":\n            // istanbul ignore next\n            case "]":\n                throw Error("TBD");\n            default:\n                const nextChar = this.popChar();\n                return { type: "Character", value: cc(nextChar) };\n        }\n    }\n    characterClass() {\n        const set = [];\n        let complement = false;\n        this.consumeChar("[");\n        if (this.peekChar(0) === "^") {\n            this.consumeChar("^");\n            complement = true;\n        }\n        while (this.isClassAtom()) {\n            const from = this.classAtom();\n            const isFromSingleChar = from.type === "Character";\n            if (isCharacter(from) && this.isRangeDash()) {\n                this.consumeChar("-");\n                const to = this.classAtom();\n                const isToSingleChar = to.type === "Character";\n                // a range can only be used when both sides are single characters\n                if (isCharacter(to)) {\n                    if (to.value < from.value) {\n                        throw Error("Range out of order in character class");\n                    }\n                    set.push({ from: from.value, to: to.value });\n                }\n                else {\n                    // literal dash\n                    insertToSet(from.value, set);\n                    set.push(cc("-"));\n                    insertToSet(to.value, set);\n                }\n            }\n            else {\n                insertToSet(from.value, set);\n            }\n        }\n        this.consumeChar("]");\n        return { type: "Set", complement: complement, value: set };\n    }\n    classAtom() {\n        switch (this.peekChar()) {\n            // istanbul ignore next\n            case "]":\n            // istanbul ignore next\n            case "\\n":\n            // istanbul ignore next\n            case "\\r":\n            // istanbul ignore next\n            case "\\u2028":\n            // istanbul ignore next\n            case "\\u2029":\n                throw Error("TBD");\n            case "\\\\":\n                return this.classEscape();\n            default:\n                return this.classPatternCharacterAtom();\n        }\n    }\n    classEscape() {\n        this.consumeChar("\\\\");\n        switch (this.peekChar()) {\n            // Matches a backspace.\n            // (Not to be confused with \\b word boundary outside characterClass)\n            case "b":\n                this.consumeChar("b");\n                return { type: "Character", value: cc("\\u0008") };\n            case "d":\n            case "D":\n            case "s":\n            case "S":\n            case "w":\n            case "W":\n                return this.characterClassEscape();\n            case "f":\n            case "n":\n            case "r":\n            case "t":\n            case "v":\n                return this.controlEscapeAtom();\n            case "c":\n                return this.controlLetterEscapeAtom();\n            case "0":\n                return this.nulCharacterAtom();\n            case "x":\n                return this.hexEscapeSequenceAtom();\n            case "u":\n                return this.regExpUnicodeEscapeSequenceAtom();\n            default:\n                return this.identityEscapeAtom();\n        }\n    }\n    group() {\n        let capturing = true;\n        this.consumeChar("(");\n        switch (this.peekChar(0)) {\n            case "?":\n                this.consumeChar("?");\n                this.consumeChar(":");\n                capturing = false;\n                break;\n            default:\n                this.groupIdx++;\n                break;\n        }\n        const value = this.disjunction();\n        this.consumeChar(")");\n        const groupAst = {\n            type: "Group",\n            capturing: capturing,\n            value: value,\n        };\n        if (capturing) {\n            groupAst["idx"] = this.groupIdx;\n        }\n        return groupAst;\n    }\n    positiveInteger() {\n        let number = this.popChar();\n        // istanbul ignore next - can\'t ever get here due to previous lookahead checks\n        // still implementing this error checking in case this ever changes.\n        if (decimalPatternNoZero.test(number) === false) {\n            throw Error("Expecting a positive integer");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    integerIncludingZero() {\n        let number = this.popChar();\n        if (decimalPattern.test(number) === false) {\n            throw Error("Expecting an integer");\n        }\n        while (decimalPattern.test(this.peekChar(0))) {\n            number += this.popChar();\n        }\n        return parseInt(number, 10);\n    }\n    patternCharacter() {\n        const nextChar = this.popChar();\n        switch (nextChar) {\n            // istanbul ignore next\n            case "\\n":\n            // istanbul ignore next\n            case "\\r":\n            // istanbul ignore next\n            case "\\u2028":\n            // istanbul ignore next\n            case "\\u2029":\n            // istanbul ignore next\n            case "^":\n            // istanbul ignore next\n            case "$":\n            // istanbul ignore next\n            case "\\\\":\n            // istanbul ignore next\n            case ".":\n            // istanbul ignore next\n            case "*":\n            // istanbul ignore next\n            case "+":\n            // istanbul ignore next\n            case "?":\n            // istanbul ignore next\n            case "(":\n            // istanbul ignore next\n            case ")":\n            // istanbul ignore next\n            case "[":\n            // istanbul ignore next\n            case "|":\n                // istanbul ignore next\n                throw Error("TBD");\n            default:\n                return { type: "Character", value: cc(nextChar) };\n        }\n    }\n    isRegExpFlag() {\n        switch (this.peekChar(0)) {\n            case "g":\n            case "i":\n            case "m":\n            case "u":\n            case "y":\n                return true;\n            default:\n                return false;\n        }\n    }\n    isRangeDash() {\n        return this.peekChar() === "-" && this.isClassAtom(1);\n    }\n    isDigit() {\n        return decimalPattern.test(this.peekChar(0));\n    }\n    isClassAtom(howMuch = 0) {\n        switch (this.peekChar(howMuch)) {\n            case "]":\n            case "\\n":\n            case "\\r":\n            case "\\u2028":\n            case "\\u2029":\n                return false;\n            default:\n                return true;\n        }\n    }\n    isTerm() {\n        return this.isAtom() || this.isAssertion();\n    }\n    isAtom() {\n        if (this.isPatternCharacter()) {\n            return true;\n        }\n        switch (this.peekChar(0)) {\n            case ".":\n            case "\\\\": // atomEscape\n            case "[": // characterClass\n            // TODO: isAtom must be called before isAssertion - disambiguate\n            case "(": // group\n                return true;\n            default:\n                return false;\n        }\n    }\n    isAssertion() {\n        switch (this.peekChar(0)) {\n            case "^":\n            case "$":\n                return true;\n            // \'\\b\' or \'\\B\'\n            case "\\\\":\n                switch (this.peekChar(1)) {\n                    case "b":\n                    case "B":\n                        return true;\n                    default:\n                        return false;\n                }\n            // \'(?=\' or \'(?!\'\n            case "(":\n                return (this.peekChar(1) === "?" &&\n                    (this.peekChar(2) === "=" || this.peekChar(2) === "!"));\n            default:\n                return false;\n        }\n    }\n    isQuantifier() {\n        const prevState = this.saveState();\n        try {\n            return this.quantifier(true) !== undefined;\n        }\n        catch (e) {\n            return false;\n        }\n        finally {\n            this.restoreState(prevState);\n        }\n    }\n    isPatternCharacter() {\n        switch (this.peekChar()) {\n            case "^":\n            case "$":\n            case "\\\\":\n            case ".":\n            case "*":\n            case "+":\n            case "?":\n            case "(":\n            case ")":\n            case "[":\n            case "|":\n            case "/":\n            case "\\n":\n            case "\\r":\n            case "\\u2028":\n            case "\\u2029":\n                return false;\n            default:\n                return true;\n        }\n    }\n    parseHexDigits(howMany) {\n        let hexString = "";\n        for (let i = 0; i < howMany; i++) {\n            const hexChar = this.popChar();\n            if (hexDigitPattern.test(hexChar) === false) {\n                throw Error("Expecting a HexDecimal digits");\n            }\n            hexString += hexChar;\n        }\n        const charCode = parseInt(hexString, 16);\n        return { type: "Character", value: charCode };\n    }\n    peekChar(howMuch = 0) {\n        return this.input[this.idx + howMuch];\n    }\n    popChar() {\n        const nextChar = this.peekChar(0);\n        this.consumeChar(undefined);\n        return nextChar;\n    }\n    consumeChar(char) {\n        if (char !== undefined && this.input[this.idx] !== char) {\n            throw Error("Expected: \'" +\n                char +\n                "\' but found: \'" +\n                this.input[this.idx] +\n                "\' at offset: " +\n                this.idx);\n        }\n        if (this.idx >= this.input.length) {\n            throw Error("Unexpected end of input");\n        }\n        this.idx++;\n    }\n    loc(begin) {\n        return { begin: begin, end: this.idx };\n    }\n}\n//# sourceMappingURL=regexp-parser.js.map\n;// ./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js\nclass BaseRegExpVisitor {\n    visitChildren(node) {\n        for (const key in node) {\n            const child = node[key];\n            /* istanbul ignore else */\n            if (node.hasOwnProperty(key)) {\n                if (child.type !== undefined) {\n                    this.visit(child);\n                }\n                else if (Array.isArray(child)) {\n                    child.forEach((subChild) => {\n                        this.visit(subChild);\n                    }, this);\n                }\n            }\n        }\n    }\n    visit(node) {\n        switch (node.type) {\n            case "Pattern":\n                this.visitPattern(node);\n                break;\n            case "Flags":\n                this.visitFlags(node);\n                break;\n            case "Disjunction":\n                this.visitDisjunction(node);\n                break;\n            case "Alternative":\n                this.visitAlternative(node);\n                break;\n            case "StartAnchor":\n                this.visitStartAnchor(node);\n                break;\n            case "EndAnchor":\n                this.visitEndAnchor(node);\n                break;\n            case "WordBoundary":\n                this.visitWordBoundary(node);\n                break;\n            case "NonWordBoundary":\n                this.visitNonWordBoundary(node);\n                break;\n            case "Lookahead":\n                this.visitLookahead(node);\n                break;\n            case "NegativeLookahead":\n                this.visitNegativeLookahead(node);\n                break;\n            case "Character":\n                this.visitCharacter(node);\n                break;\n            case "Set":\n                this.visitSet(node);\n                break;\n            case "Group":\n                this.visitGroup(node);\n                break;\n            case "GroupBackReference":\n                this.visitGroupBackReference(node);\n                break;\n            case "Quantifier":\n                this.visitQuantifier(node);\n                break;\n        }\n        this.visitChildren(node);\n    }\n    visitPattern(node) { }\n    visitFlags(node) { }\n    visitDisjunction(node) { }\n    visitAlternative(node) { }\n    // Assertion\n    visitStartAnchor(node) { }\n    visitEndAnchor(node) { }\n    visitWordBoundary(node) { }\n    visitNonWordBoundary(node) { }\n    visitLookahead(node) { }\n    visitNegativeLookahead(node) { }\n    // atoms\n    visitCharacter(node) { }\n    visitSet(node) { }\n    visitGroup(node) { }\n    visitGroupBackReference(node) { }\n    visitQuantifier(node) { }\n}\n//# sourceMappingURL=base-regexp-visitor.js.map\n;// ./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js\n\n\n//# sourceMappingURL=api.js.map\n;// ./node_modules/langium/lib/utils/regexp-utils.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nconst NEWLINE_REGEXP = /\\r?\\n/gm;\nconst regexpParser = new RegExpParser();\n/**\n * This class is in charge of heuristically identifying start/end tokens of terminals.\n *\n * The way this works is by doing the following:\n * 1. Traverse the regular expression in the "start state"\n * 2. Add any encountered sets/single characters to the "start regexp"\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the "end state"\n * 4. In the end state, any sets/single characters are added to an "end stack".\n * 5. If we re-encounter any variable-length content we reset the end stack\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\n *\n * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal\n */\nclass TerminalRegExpVisitor extends BaseRegExpVisitor {\n    constructor() {\n        super(...arguments);\n        this.isStarting = true;\n        this.endRegexpStack = [];\n        this.multiline = false;\n    }\n    get endRegex() {\n        return this.endRegexpStack.join(\'\');\n    }\n    reset(regex) {\n        this.multiline = false;\n        this.regex = regex;\n        this.startRegexp = \'\';\n        this.isStarting = true;\n        this.endRegexpStack = [];\n    }\n    visitGroup(node) {\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n    }\n    visitCharacter(node) {\n        const char = String.fromCharCode(node.value);\n        if (!this.multiline && char === \'\\n\') {\n            this.multiline = true;\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const escapedChar = escapeRegExp(char);\n            this.endRegexpStack.push(escapedChar);\n            if (this.isStarting) {\n                this.startRegexp += escapedChar;\n            }\n        }\n    }\n    visitSet(node) {\n        if (!this.multiline) {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            const regex = new RegExp(set);\n            this.multiline = Boolean(\'\\n\'.match(regex));\n        }\n        if (node.quantifier) {\n            this.isStarting = false;\n            this.endRegexpStack = [];\n        }\n        else {\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\n            this.endRegexpStack.push(set);\n            if (this.isStarting) {\n                this.startRegexp += set;\n            }\n        }\n    }\n    visitChildren(node) {\n        if (node.type === \'Group\') {\n            // Ignore children of groups with quantifier (+/*/?)\n            // These groups are unrelated to start/end tokens of terminals\n            const group = node;\n            if (group.quantifier) {\n                return;\n            }\n        }\n        super.visitChildren(node);\n    }\n}\nconst visitor = new TerminalRegExpVisitor();\nfunction getTerminalParts(regexp) {\n    try {\n        if (typeof regexp !== \'string\') {\n            regexp = regexp.source;\n        }\n        regexp = `/${regexp}/`;\n        const pattern = regexpParser.pattern(regexp);\n        const parts = [];\n        for (const alternative of pattern.value.value) {\n            visitor.reset(regexp);\n            visitor.visit(alternative);\n            parts.push({\n                start: visitor.startRegexp,\n                end: visitor.endRegex\n            });\n        }\n        return parts;\n    }\n    catch (_a) {\n        return [];\n    }\n}\nfunction isMultilineComment(regexp) {\n    try {\n        if (typeof regexp === \'string\') {\n            regexp = new RegExp(regexp);\n        }\n        regexp = regexp.toString();\n        visitor.reset(regexp);\n        // Parsing the pattern might fail (since it\'s user code)\n        visitor.visit(regexpParser.pattern(regexp));\n        return visitor.multiline;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction isWhitespace(value) {\n    const regexp = typeof value === \'string\' ? new RegExp(value) : value;\n    return regexp.test(\' \');\n}\nfunction escapeRegExp(value) {\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, \'\\\\$&\');\n}\nfunction getCaseInsensitivePattern(keyword) {\n    return Array.prototype.map.call(keyword, letter => /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join(\'\');\n}\n/**\n * Determines whether the given input has a partial match with the specified regex.\n * @param regex The regex to partially match against\n * @param input The input string\n * @returns Whether any match exists.\n */\nfunction partialMatches(regex, input) {\n    const partial = partialRegExp(regex);\n    const match = input.match(partial);\n    return !!match && match[0].length > 0;\n}\n/**\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won\'t match `b` alone.\n * @param regex The input regex to be converted.\n * @returns A partial regex constructed from the input regex.\n */\nfunction partialRegExp(regex) {\n    if (typeof regex === \'string\') {\n        regex = new RegExp(regex);\n    }\n    const re = regex, source = regex.source;\n    let i = 0;\n    function process() {\n        let result = \'\', tmp;\n        function appendRaw(nbChars) {\n            result += source.substr(i, nbChars);\n            i += nbChars;\n        }\n        function appendOptional(nbChars) {\n            result += \'(?:\' + source.substr(i, nbChars) + \'|$)\';\n            i += nbChars;\n        }\n        while (i < source.length) {\n            switch (source[i]) {\n                case \'\\\\\':\n                    switch (source[i + 1]) {\n                        case \'c\':\n                            appendOptional(3);\n                            break;\n                        case \'x\':\n                            appendOptional(4);\n                            break;\n                        case \'u\':\n                            if (re.unicode) {\n                                if (source[i + 2] === \'{\') {\n                                    appendOptional(source.indexOf(\'}\', i) - i + 1);\n                                }\n                                else {\n                                    appendOptional(6);\n                                }\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case \'p\':\n                        case \'P\':\n                            if (re.unicode) {\n                                appendOptional(source.indexOf(\'}\', i) - i + 1);\n                            }\n                            else {\n                                appendOptional(2);\n                            }\n                            break;\n                        case \'k\':\n                            appendOptional(source.indexOf(\'>\', i) - i + 1);\n                            break;\n                        default:\n                            appendOptional(2);\n                            break;\n                    }\n                    break;\n                case \'[\':\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source) || [];\n                    appendOptional(tmp[0].length);\n                    break;\n                case \'|\':\n                case \'^\':\n                case \'$\':\n                case \'*\':\n                case \'+\':\n                case \'?\':\n                    appendRaw(1);\n                    break;\n                case \'{\':\n                    tmp = /\\{\\d+,?\\d*\\}/g;\n                    tmp.lastIndex = i;\n                    tmp = tmp.exec(source);\n                    if (tmp) {\n                        appendRaw(tmp[0].length);\n                    }\n                    else {\n                        appendOptional(1);\n                    }\n                    break;\n                case \'(\':\n                    if (source[i + 1] === \'?\') {\n                        switch (source[i + 2]) {\n                            case \':\':\n                                result += \'(?:\';\n                                i += 3;\n                                result += process() + \'|$)\';\n                                break;\n                            case \'=\':\n                                result += \'(?=\';\n                                i += 3;\n                                result += process() + \')\';\n                                break;\n                            case \'!\':\n                                tmp = i;\n                                i += 3;\n                                process();\n                                result += source.substr(tmp, i - tmp);\n                                break;\n                            case \'<\':\n                                switch (source[i + 3]) {\n                                    case \'=\':\n                                    case \'!\':\n                                        tmp = i;\n                                        i += 4;\n                                        process();\n                                        result += source.substr(tmp, i - tmp);\n                                        break;\n                                    default:\n                                        appendRaw(source.indexOf(\'>\', i) - i + 1);\n                                        result += process() + \'|$)\';\n                                        break;\n                                }\n                                break;\n                        }\n                    }\n                    else {\n                        appendRaw(1);\n                        result += process() + \'|$)\';\n                    }\n                    break;\n                case \')\':\n                    ++i;\n                    return result;\n                default:\n                    appendOptional(1);\n                    break;\n            }\n        }\n        return result;\n    }\n    return new RegExp(process(), regex.flags);\n}\n//# sourceMappingURL=regexp-utils.js.map\n;// ./node_modules/langium/lib/utils/grammar-utils.js\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n/**\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\n * the result is `undefined`.\n */\nfunction getEntryRule(grammar) {\n    return grammar.rules.find(e => isParserRule(e) && e.entry);\n}\n/**\n * Returns all hidden terminal rules of the given grammar, if any.\n */\nfunction getHiddenRules(grammar) {\n    return grammar.rules.filter((e) => isTerminalRule(e) && e.hidden);\n}\n/**\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\n *\n * @param grammar The grammar that contains all rules\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\n *      this function returns all rules of the specified grammar.\n */\nfunction getAllReachableRules(grammar, allTerminals) {\n    const ruleNames = new Set();\n    const entryRule = getEntryRule(grammar);\n    if (!entryRule) {\n        return new Set(grammar.rules);\n    }\n    const topMostRules = [entryRule].concat(getHiddenRules(grammar));\n    for (const rule of topMostRules) {\n        ruleDfs(rule, ruleNames, allTerminals);\n    }\n    const rules = new Set();\n    for (const rule of grammar.rules) {\n        if (ruleNames.has(rule.name) || (isTerminalRule(rule) && rule.hidden)) {\n            rules.add(rule);\n        }\n    }\n    return rules;\n}\nfunction ruleDfs(rule, visitedSet, allTerminals) {\n    visitedSet.add(rule.name);\n    ast_utils_streamAllContents(rule).forEach(node => {\n        if (isRuleCall(node) || (allTerminals && isTerminalRuleCall(node))) {\n            const refRule = node.rule.ref;\n            if (refRule && !visitedSet.has(refRule.name)) {\n                ruleDfs(refRule, visitedSet, allTerminals);\n            }\n        }\n    });\n}\n/**\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\n *\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\n * and cannot be inferred.\n */\nfunction getCrossReferenceTerminal(crossRef) {\n    if (crossRef.terminal) {\n        return crossRef.terminal;\n    }\n    else if (crossRef.type.ref) {\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\n        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;\n    }\n    return undefined;\n}\n/**\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\n * that contains visible characters is considered a comment.\n */\nfunction isCommentTerminal(terminalRule) {\n    return terminalRule.hidden && !terminalRegex(terminalRule).test(\' \');\n}\n/**\n * Find all CST nodes within the given node that contribute to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\n */\nfunction findNodesForProperty(node, property) {\n    if (!node || !property) {\n        return [];\n    }\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\n}\n/**\n * Find a single CST node within the given node that contributes to the specified property.\n *\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nfunction findNodeForProperty(node, property, index) {\n    if (!node || !property) {\n        return undefined;\n    }\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForPropertyInternal(node, property, element, first) {\n    if (!first) {\n        const nodeFeature = getContainerOfType(node.grammarSource, isAssignment);\n        if (nodeFeature && nodeFeature.feature === property) {\n            return [node];\n        }\n    }\n    if (syntax_tree_isCompositeCstNode(node) && node.astNode === element) {\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\n    }\n    return [];\n}\n/**\n * Find all CST nodes within the given node that correspond to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\n * @param keyword A keyword as specified in the grammar.\n */\nfunction findNodesForKeyword(node, keyword) {\n    if (!node) {\n        return [];\n    }\n    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n}\n/**\n * Find a single CST node within the given node that corresponds to the specified keyword.\n *\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\n * @param keyword A keyword as specified in the grammar.\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\n *        the node with the specified index is returned.\n */\nfunction findNodeForKeyword(node, keyword, index) {\n    if (!node) {\n        return undefined;\n    }\n    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);\n    if (nodes.length === 0) {\n        return undefined;\n    }\n    if (index !== undefined) {\n        index = Math.max(0, Math.min(index, nodes.length - 1));\n    }\n    else {\n        index = 0;\n    }\n    return nodes[index];\n}\nfunction findNodesForKeywordInternal(node, keyword, element) {\n    if (node.astNode !== element) {\n        return [];\n    }\n    if (isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\n        return [node];\n    }\n    const treeIterator = streamCst(node).iterator();\n    let result;\n    const keywordNodes = [];\n    do {\n        result = treeIterator.next();\n        if (!result.done) {\n            const childNode = result.value;\n            if (childNode.astNode === element) {\n                if (isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\n                    keywordNodes.push(childNode);\n                }\n            }\n            else {\n                treeIterator.prune();\n            }\n        }\n    } while (!result.done);\n    return keywordNodes;\n}\n/**\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\n * node is returned. If no assignment is found, the result is `undefined`.\n *\n * @param cstNode A CST node for which to find a property assignment.\n */\nfunction findAssignment(cstNode) {\n    var _a;\n    const astNode = cstNode.astNode;\n    // Only search until the ast node of the parent cst node is no longer the original ast node\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\n    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {\n        const assignment = getContainerOfType(cstNode.grammarSource, isAssignment);\n        if (assignment) {\n            return assignment;\n        }\n        cstNode = cstNode.container;\n    }\n    return undefined;\n}\n/**\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\n * this function returns `undefined`.\n */\nfunction findNameAssignment(type) {\n    let startNode = type;\n    if (isInferredType(startNode)) {\n        // for inferred types, the location to start searching for the name-assignment is different\n        if (isAction(startNode.$container)) {\n            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action\'s parent\n            startNode = startNode.$container.$container;\n        }\n        else if (isParserRule(startNode.$container)) {\n            // investigate the parser rule with the explicitly inferred type\n            startNode = startNode.$container;\n        }\n        else {\n            assertUnreachable(startNode.$container);\n        }\n    }\n    return findNameAssignmentInternal(type, startNode, new Map());\n}\nfunction findNameAssignmentInternal(type, startNode, cache) {\n    var _a;\n    // the cache is only required to prevent infinite loops\n    function go(node, refType) {\n        let childAssignment = undefined;\n        const parentAssignment = getContainerOfType(node, isAssignment);\n        // No parent assignment implies unassigned rule call\n        if (!parentAssignment) {\n            childAssignment = findNameAssignmentInternal(refType, refType, cache);\n        }\n        cache.set(type, childAssignment);\n        return childAssignment;\n    }\n    if (cache.has(type)) {\n        return cache.get(type);\n    }\n    cache.set(type, undefined);\n    for (const node of ast_utils_streamAllContents(startNode)) {\n        if (isAssignment(node) && node.feature.toLowerCase() === \'name\') {\n            cache.set(type, node);\n            return node;\n        }\n        else if (isRuleCall(node) && isParserRule(node.rule.ref)) {\n            return go(node, node.rule.ref);\n        }\n        else if (isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {\n            return go(node, node.typeRef.ref);\n        }\n    }\n    return undefined;\n}\nfunction getActionAtElement(element) {\n    const parent = element.$container;\n    if (ast.isGroup(parent)) {\n        const elements = parent.elements;\n        const index = elements.indexOf(element);\n        for (let i = index - 1; i >= 0; i--) {\n            const item = elements[i];\n            if (ast.isAction(item)) {\n                return item;\n            }\n            else {\n                const action = streamAllContents(elements[i]).find(ast.isAction);\n                if (action) {\n                    return action;\n                }\n            }\n        }\n    }\n    if (ast.isAbstractElement(parent)) {\n        return getActionAtElement(parent);\n    }\n    else {\n        return undefined;\n    }\n}\nfunction isOptionalCardinality(cardinality, element) {\n    return cardinality === \'?\' || cardinality === \'*\' || (ast.isGroup(element) && Boolean(element.guardCondition));\n}\nfunction isArrayCardinality(cardinality) {\n    return cardinality === \'*\' || cardinality === \'+\';\n}\nfunction isArrayOperator(operator) {\n    return operator === \'+=\';\n}\n/**\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\n * primitive return type like `number`, `boolean`, etc.\n */\nfunction isDataTypeRule(rule) {\n    return isDataTypeRuleInternal(rule, new Set());\n}\nfunction isDataTypeRuleInternal(rule, visited) {\n    if (visited.has(rule)) {\n        return true;\n    }\n    else {\n        visited.add(rule);\n    }\n    for (const node of ast_utils_streamAllContents(rule)) {\n        if (isRuleCall(node)) {\n            if (!node.rule.ref) {\n                // RuleCall to unresolved rule. Don\'t assume `rule` is a DataType rule.\n                return false;\n            }\n            if (isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\n                return false;\n            }\n        }\n        else if (isAssignment(node)) {\n            return false;\n        }\n        else if (isAction(node)) {\n            return false;\n        }\n    }\n    return Boolean(rule.definition);\n}\nfunction isDataType(type) {\n    return isDataTypeInternal(type.type, new Set());\n}\nfunction isDataTypeInternal(type, visited) {\n    if (visited.has(type)) {\n        return true;\n    }\n    else {\n        visited.add(type);\n    }\n    if (ast.isArrayType(type)) {\n        return false;\n    }\n    else if (ast.isReferenceType(type)) {\n        return false;\n    }\n    else if (ast.isUnionType(type)) {\n        return type.types.every(e => isDataTypeInternal(e, visited));\n    }\n    else if (ast.isSimpleType(type)) {\n        if (type.primitiveType !== undefined) {\n            return true;\n        }\n        else if (type.stringType !== undefined) {\n            return true;\n        }\n        else if (type.typeRef !== undefined) {\n            const ref = type.typeRef.ref;\n            if (ast.isType(ref)) {\n                return isDataTypeInternal(ref.type, visited);\n            }\n            else {\n                return false;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n    else {\n        return false;\n    }\n}\nfunction getExplicitRuleType(rule) {\n    if (rule.inferredType) {\n        return rule.inferredType.name;\n    }\n    else if (rule.dataType) {\n        return rule.dataType;\n    }\n    else if (rule.returnType) {\n        const refType = rule.returnType.ref;\n        if (refType) {\n            // check if we need to check Action as return type\n            if (isParserRule(refType)) {\n                return refType.name;\n            }\n            else if (isInterface(refType) || isType(refType)) {\n                return refType.name;\n            }\n        }\n    }\n    return undefined;\n}\nfunction getTypeName(type) {\n    var _a;\n    if (isParserRule(type)) {\n        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;\n    }\n    else if (isInterface(type) || isType(type) || isReturnType(type)) {\n        return type.name;\n    }\n    else if (isAction(type)) {\n        const actionType = getActionType(type);\n        if (actionType) {\n            return actionType;\n        }\n    }\n    else if (isInferredType(type)) {\n        return type.name;\n    }\n    throw new Error(\'Cannot get name of Unknown Type\');\n}\nfunction getActionType(action) {\n    var _a;\n    if (action.inferredType) {\n        return action.inferredType.name;\n    }\n    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {\n        return getTypeName(action.type.ref);\n    }\n    return undefined; // not inferring and not referencing a valid type\n}\nfunction getRuleType(rule) {\n    var _a, _b, _c;\n    if (isTerminalRule(rule)) {\n        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \'string\';\n    }\n    else {\n        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;\n    }\n}\nfunction terminalRegex(terminalRule) {\n    const flags = {\n        s: false,\n        i: false,\n        u: false\n    };\n    const source = abstractElementToRegex(terminalRule.definition, flags);\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join(\'\');\n    return new RegExp(source, flagText);\n}\n// Using [\\s\\S]* allows to match everything, compared to . which doesn\'t match line terminators\nconst WILDCARD = /[\\s\\S]/.source;\nfunction abstractElementToRegex(element, flags) {\n    if (isTerminalAlternatives(element)) {\n        return terminalAlternativesToRegex(element);\n    }\n    else if (isTerminalGroup(element)) {\n        return terminalGroupToRegex(element);\n    }\n    else if (isCharacterRange(element)) {\n        return characterRangeToRegex(element);\n    }\n    else if (isTerminalRuleCall(element)) {\n        const rule = element.rule.ref;\n        if (!rule) {\n            throw new Error(\'Missing rule reference.\');\n        }\n        return withCardinality(abstractElementToRegex(rule.definition), {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else if (isNegatedToken(element)) {\n        return negateTokenToRegex(element);\n    }\n    else if (isUntilToken(element)) {\n        return untilTokenToRegex(element);\n    }\n    else if (isRegexToken(element)) {\n        const lastSlash = element.regex.lastIndexOf(\'/\');\n        const source = element.regex.substring(1, lastSlash);\n        const regexFlags = element.regex.substring(lastSlash + 1);\n        if (flags) {\n            flags.i = regexFlags.includes(\'i\');\n            flags.s = regexFlags.includes(\'s\');\n            flags.u = regexFlags.includes(\'u\');\n        }\n        return withCardinality(source, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead,\n            wrap: false\n        });\n    }\n    else if (isWildcard(element)) {\n        return withCardinality(WILDCARD, {\n            cardinality: element.cardinality,\n            lookahead: element.lookahead\n        });\n    }\n    else {\n        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);\n    }\n}\nfunction terminalAlternativesToRegex(alternatives) {\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join(\'|\'), {\n        cardinality: alternatives.cardinality,\n        lookahead: alternatives.lookahead\n    });\n}\nfunction terminalGroupToRegex(group) {\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(\'\'), {\n        cardinality: group.cardinality,\n        lookahead: group.lookahead\n    });\n}\nfunction untilTokenToRegex(until) {\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\n        cardinality: until.cardinality,\n        lookahead: until.lookahead\n    });\n}\nfunction negateTokenToRegex(negate) {\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\n        cardinality: negate.cardinality,\n        lookahead: negate.lookahead\n    });\n}\nfunction characterRangeToRegex(range) {\n    if (range.right) {\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\n            cardinality: range.cardinality,\n            lookahead: range.lookahead,\n            wrap: false\n        });\n    }\n    return withCardinality(keywordToRegex(range.left), {\n        cardinality: range.cardinality,\n        lookahead: range.lookahead,\n        wrap: false\n    });\n}\nfunction keywordToRegex(keyword) {\n    return escapeRegExp(keyword.value);\n}\nfunction withCardinality(regex, options) {\n    var _a;\n    if (options.wrap !== false || options.lookahead) {\n        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : \'\'}${regex})`;\n    }\n    if (options.cardinality) {\n        return `${regex}${options.cardinality}`;\n    }\n    return regex;\n}\n//# sourceMappingURL=grammar-utils.js.map\n;// ./node_modules/langium/lib/languages/grammar-config.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n/**\n * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a\n * language-specific module.\n */\nfunction createGrammarConfig(services) {\n    const rules = [];\n    const grammar = services.Grammar;\n    for (const rule of grammar.rules) {\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\n            rules.push(rule.name);\n        }\n    }\n    return {\n        multilineCommentRules: rules,\n        nameRegexp: DefaultNameRegexp\n    };\n}\n//# sourceMappingURL=grammar-config.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/forEach.js\nvar forEach = __webpack_require__(8058);\n// EXTERNAL MODULE: ./node_modules/lodash-es/values.js + 1 modules\nvar lodash_es_values = __webpack_require__(38207);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isEmpty.js\nvar isEmpty = __webpack_require__(66401);\n// EXTERNAL MODULE: ./node_modules/lodash-es/map.js\nvar lodash_es_map = __webpack_require__(74722);\n// EXTERNAL MODULE: ./node_modules/lodash-es/has.js + 1 modules\nvar has = __webpack_require__(48585);\n// EXTERNAL MODULE: ./node_modules/lodash-es/clone.js\nvar clone = __webpack_require__(50053);\n;// ./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js\n// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\nfunction toFastProperties(toBecomeFast) {\n    function FakeConstructor() { }\n    // If our object is used as a constructor, it would receive\n    FakeConstructor.prototype = toBecomeFast;\n    const fakeInstance = new FakeConstructor();\n    function fakeAccess() {\n        return typeof fakeInstance.bar;\n    }\n    // help V8 understand this is a "real" prototype by actually using\n    // the fake instance.\n    fakeAccess();\n    fakeAccess();\n    // Always true condition to suppress the Firefox warning of unreachable\n    // code after a return statement.\n    if (true)\n        return toBecomeFast;\n    // Eval prevents optimization of this method (even though this is dead code)\n    // - https://esbuild.github.io/content-types/#direct-eval\n    /* istanbul ignore next */\n    // tslint:disable-next-line\n    (0, eval)(toBecomeFast);\n}\n//# sourceMappingURL=to-fast-properties.js.map\n;// ./node_modules/lodash-es/_baseSlice.js\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/* harmony default export */ const _baseSlice = (baseSlice);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/toInteger.js\nvar toInteger = __webpack_require__(18593);\n;// ./node_modules/lodash-es/drop.js\n\n\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the beginning.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.drop([1, 2, 3]);\n * // => [2, 3]\n *\n * _.drop([1, 2, 3], 2);\n * // => [3]\n *\n * _.drop([1, 2, 3], 5);\n * // => []\n *\n * _.drop([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction drop(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : (0,toInteger/* default */.A)(n);\n  return _baseSlice(array, n < 0 ? 0 : n, length);\n}\n\n/* harmony default export */ const lodash_es_drop = (drop);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/isString.js\nvar isString = __webpack_require__(9703);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_assignValue.js\nvar _assignValue = __webpack_require__(52851);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_copyObject.js\nvar _copyObject = __webpack_require__(22031);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_createAssigner.js\nvar _createAssigner = __webpack_require__(3767);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLike.js\nvar isArrayLike = __webpack_require__(38446);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_isPrototype.js\nvar _isPrototype = __webpack_require__(97271);\n// EXTERNAL MODULE: ./node_modules/lodash-es/keys.js\nvar keys = __webpack_require__(27422);\n;// ./node_modules/lodash-es/assign.js\n\n\n\n\n\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar assign_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own enumerable string keyed properties of source objects to the\n * destination object. Source objects are applied from left to right.\n * Subsequent sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object` and is loosely based on\n * [`Object.assign`](https://mdn.io/Object/assign).\n *\n * @static\n * @memberOf _\n * @since 0.10.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.assignIn\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * function Bar() {\n *   this.c = 3;\n * }\n *\n * Foo.prototype.b = 2;\n * Bar.prototype.d = 4;\n *\n * _.assign({ \'a\': 0 }, new Foo, new Bar);\n * // => { \'a\': 1, \'c\': 3 }\n */\nvar assign_assign = (0,_createAssigner/* default */.A)(function(object, source) {\n  if ((0,_isPrototype/* default */.A)(source) || (0,isArrayLike/* default */.A)(source)) {\n    (0,_copyObject/* default */.A)(source, (0,keys/* default */.A)(source), object);\n    return;\n  }\n  for (var key in source) {\n    if (assign_hasOwnProperty.call(source, key)) {\n      (0,_assignValue/* default */.A)(object, key, source[key]);\n    }\n  }\n});\n\n/* harmony default export */ const lodash_es_assign = (assign_assign);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayMap.js\nvar _arrayMap = __webpack_require__(45572);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIteratee.js + 15 modules\nvar _baseIteratee = __webpack_require__(23958);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_basePickBy.js + 1 modules\nvar _basePickBy = __webpack_require__(99354);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_getAllKeysIn.js\nvar _getAllKeysIn = __webpack_require__(83973);\n;// ./node_modules/lodash-es/pickBy.js\n\n\n\n\n\n/**\n * Creates an object composed of the `object` properties `predicate` returns\n * truthy for. The predicate is invoked with two arguments: (value, key).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The source object.\n * @param {Function} [predicate=_.identity] The function invoked per property.\n * @returns {Object} Returns the new object.\n * @example\n *\n * var object = { \'a\': 1, \'b\': \'2\', \'c\': 3 };\n *\n * _.pickBy(object, _.isNumber);\n * // => { \'a\': 1, \'c\': 3 }\n */\nfunction pickBy(object, predicate) {\n  if (object == null) {\n    return {};\n  }\n  var props = (0,_arrayMap/* default */.A)((0,_getAllKeysIn/* default */.A)(object), function(prop) {\n    return [prop];\n  });\n  predicate = (0,_baseIteratee/* default */.A)(predicate);\n  return (0,_basePickBy/* default */.A)(object, props, function(value, path) {\n    return predicate(value, path[0]);\n  });\n}\n\n/* harmony default export */ const lodash_es_pickBy = (pickBy);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGetTag.js + 2 modules\nvar _baseGetTag = __webpack_require__(88496);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isObjectLike.js\nvar isObjectLike = __webpack_require__(53098);\n;// ./node_modules/lodash-es/_baseIsRegExp.js\n\n\n\n/** `Object#toString` result references. */\nvar regexpTag = \'[object RegExp]\';\n\n/**\n * The base implementation of `_.isRegExp` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n */\nfunction baseIsRegExp(value) {\n  return (0,isObjectLike/* default */.A)(value) && (0,_baseGetTag/* default */.A)(value) == regexpTag;\n}\n\n/* harmony default export */ const _baseIsRegExp = (baseIsRegExp);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseUnary.js\nvar _baseUnary = __webpack_require__(52789);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js\nvar _nodeUtil = __webpack_require__(64841);\n;// ./node_modules/lodash-es/isRegExp.js\n\n\n\n\n/* Node.js helper references. */\nvar nodeIsRegExp = _nodeUtil/* default */.A && _nodeUtil/* default */.A.isRegExp;\n\n/**\n * Checks if `value` is classified as a `RegExp` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n * @example\n *\n * _.isRegExp(/abc/);\n * // => true\n *\n * _.isRegExp(\'/abc/\');\n * // => false\n */\nvar isRegExp = nodeIsRegExp ? (0,_baseUnary/* default */.A)(nodeIsRegExp) : _baseIsRegExp;\n\n/* harmony default export */ const lodash_es_isRegExp = (isRegExp);\n\n;// ./node_modules/@chevrotain/gast/lib/src/model.js\n\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction tokenLabel(tokType) {\n    if (hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\nfunction hasTokenLabel(obj) {\n    return (0,isString/* default */.A)(obj.LABEL) && obj.LABEL !== "";\n}\nclass AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(_definition) {\n        this._definition = _definition;\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        (0,forEach/* default */.A)(this.definition, (prod) => {\n            prod.accept(visitor);\n        });\n    }\n}\nclass model_NonTerminal extends AbstractProduction {\n    constructor(options) {\n        super([]);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n    set definition(definition) {\n        // immutable\n    }\n    get definition() {\n        if (this.referencedRule !== undefined) {\n            return this.referencedRule.definition;\n        }\n        return [];\n    }\n    accept(visitor) {\n        visitor.visit(this);\n        // don\'t visit children of a reference, we will get cyclic infinite loops if we do so\n    }\n}\nclass Rule extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.orgText = "";\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass Alternative extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.ignoreAmbiguities = false;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass Option extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass RepetitionMandatory extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass RepetitionMandatoryWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass Repetition extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass RepetitionWithSeparator extends AbstractProduction {\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass Alternation extends AbstractProduction {\n    get definition() {\n        return this._definition;\n    }\n    set definition(value) {\n        this._definition = value;\n    }\n    constructor(options) {\n        super(options.definition);\n        this.idx = 1;\n        this.ignoreAmbiguities = false;\n        this.hasPredicates = false;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n}\nclass Terminal {\n    constructor(options) {\n        this.idx = 1;\n        lodash_es_assign(this, lodash_es_pickBy(options, (v) => v !== undefined));\n    }\n    accept(visitor) {\n        visitor.visit(this);\n    }\n}\nfunction serializeGrammar(topRules) {\n    return (0,lodash_es_map/* default */.A)(topRules, serializeProduction);\n}\nfunction serializeProduction(node) {\n    function convertDefinition(definition) {\n        return (0,lodash_es_map/* default */.A)(definition, serializeProduction);\n    }\n    /* istanbul ignore else */\n    if (node instanceof model_NonTerminal) {\n        const serializedNonTerminal = {\n            type: "NonTerminal",\n            name: node.nonTerminalName,\n            idx: node.idx,\n        };\n        if ((0,isString/* default */.A)(node.label)) {\n            serializedNonTerminal.label = node.label;\n        }\n        return serializedNonTerminal;\n    }\n    else if (node instanceof Alternative) {\n        return {\n            type: "Alternative",\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Option) {\n        return {\n            type: "Option",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatory) {\n        return {\n            type: "RepetitionMandatory",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionMandatoryWithSeparator) {\n        return {\n            type: "RepetitionMandatoryWithSeparator",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof RepetitionWithSeparator) {\n        return {\n            type: "RepetitionWithSeparator",\n            idx: node.idx,\n            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Repetition) {\n        return {\n            type: "Repetition",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Alternation) {\n        return {\n            type: "Alternation",\n            idx: node.idx,\n            definition: convertDefinition(node.definition),\n        };\n    }\n    else if (node instanceof Terminal) {\n        const serializedTerminal = {\n            type: "Terminal",\n            name: node.terminalType.name,\n            label: tokenLabel(node.terminalType),\n            idx: node.idx,\n        };\n        if ((0,isString/* default */.A)(node.label)) {\n            serializedTerminal.terminalLabel = node.label;\n        }\n        const pattern = node.terminalType.PATTERN;\n        if (node.terminalType.PATTERN) {\n            serializedTerminal.pattern = lodash_es_isRegExp(pattern)\n                ? pattern.source\n                : pattern;\n        }\n        return serializedTerminal;\n    }\n    else if (node instanceof Rule) {\n        return {\n            type: "Rule",\n            name: node.name,\n            orgText: node.orgText,\n            definition: convertDefinition(node.definition),\n        };\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\n//# sourceMappingURL=model.js.map\n;// ./node_modules/@chevrotain/gast/lib/src/visitor.js\n\nclass visitor_GAstVisitor {\n    visit(node) {\n        const nodeAny = node;\n        switch (nodeAny.constructor) {\n            case model_NonTerminal:\n                return this.visitNonTerminal(nodeAny);\n            case Alternative:\n                return this.visitAlternative(nodeAny);\n            case Option:\n                return this.visitOption(nodeAny);\n            case RepetitionMandatory:\n                return this.visitRepetitionMandatory(nodeAny);\n            case RepetitionMandatoryWithSeparator:\n                return this.visitRepetitionMandatoryWithSeparator(nodeAny);\n            case RepetitionWithSeparator:\n                return this.visitRepetitionWithSeparator(nodeAny);\n            case Repetition:\n                return this.visitRepetition(nodeAny);\n            case Alternation:\n                return this.visitAlternation(nodeAny);\n            case Terminal:\n                return this.visitTerminal(nodeAny);\n            case Rule:\n                return this.visitRule(nodeAny);\n            /* c8 ignore next 2 */\n            default:\n                throw Error("non exhaustive match");\n        }\n    }\n    /* c8 ignore next */\n    visitNonTerminal(node) { }\n    /* c8 ignore next */\n    visitAlternative(node) { }\n    /* c8 ignore next */\n    visitOption(node) { }\n    /* c8 ignore next */\n    visitRepetition(node) { }\n    /* c8 ignore next */\n    visitRepetitionMandatory(node) { }\n    /* c8 ignore next 3 */\n    visitRepetitionMandatoryWithSeparator(node) { }\n    /* c8 ignore next */\n    visitRepetitionWithSeparator(node) { }\n    /* c8 ignore next */\n    visitAlternation(node) { }\n    /* c8 ignore next */\n    visitTerminal(node) { }\n    /* c8 ignore next */\n    visitRule(node) { }\n}\n//# sourceMappingURL=visitor.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/_arraySome.js\nvar _arraySome = __webpack_require__(63736);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseEach.js + 1 modules\nvar _baseEach = __webpack_require__(6240);\n;// ./node_modules/lodash-es/_baseSome.js\n\n\n/**\n * The base implementation of `_.some` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction baseSome(collection, predicate) {\n  var result;\n\n  (0,_baseEach/* default */.A)(collection, function(value, index, collection) {\n    result = predicate(value, index, collection);\n    return !result;\n  });\n  return !!result;\n}\n\n/* harmony default export */ const _baseSome = (baseSome);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/isArray.js\nvar isArray = __webpack_require__(92049);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_isIterateeCall.js\nvar _isIterateeCall = __webpack_require__(6832);\n;// ./node_modules/lodash-es/some.js\n\n\n\n\n\n\n/**\n * Checks if `predicate` returns truthy for **any** element of `collection`.\n * Iteration is stopped once `predicate` returns truthy. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n * @example\n *\n * _.some([null, 0, \'yes\', false], Boolean);\n * // => true\n *\n * var users = [\n *   { \'user\': \'barney\', \'active\': true },\n *   { \'user\': \'fred\',   \'active\': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.some(users, { \'user\': \'barney\', \'active\': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.some(users, [\'active\', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.some(users, \'active\');\n * // => true\n */\nfunction some_some(collection, predicate, guard) {\n  var func = (0,isArray/* default */.A)(collection) ? _arraySome/* default */.A : _baseSome;\n  if (guard && (0,_isIterateeCall/* default */.A)(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, (0,_baseIteratee/* default */.A)(predicate, 3));\n}\n\n/* harmony default export */ const lodash_es_some = (some_some);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIndexOf.js + 2 modules\nvar _baseIndexOf = __webpack_require__(60818);\n;// ./node_modules/lodash-es/includes.js\n\n\n\n\n\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Checks if `value` is in `collection`. If `collection` is a string, it\'s\n * checked for a substring of `value`, otherwise\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * is used for equality comparisons. If `fromIndex` is negative, it\'s used as\n * the offset from the end of `collection`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object|string} collection The collection to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\n * @example\n *\n * _.includes([1, 2, 3], 1);\n * // => true\n *\n * _.includes([1, 2, 3], 1, 2);\n * // => false\n *\n * _.includes({ \'a\': 1, \'b\': 2 }, 1);\n * // => true\n *\n * _.includes(\'abcd\', \'bc\');\n * // => true\n */\nfunction includes(collection, value, fromIndex, guard) {\n  collection = (0,isArrayLike/* default */.A)(collection) ? collection : (0,lodash_es_values/* default */.A)(collection);\n  fromIndex = (fromIndex && !guard) ? (0,toInteger/* default */.A)(fromIndex) : 0;\n\n  var length = collection.length;\n  if (fromIndex < 0) {\n    fromIndex = nativeMax(length + fromIndex, 0);\n  }\n  return (0,isString/* default */.A)(collection)\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n    : (!!length && (0,_baseIndexOf/* default */.A)(collection, value, fromIndex) > -1);\n}\n\n/* harmony default export */ const lodash_es_includes = (includes);\n\n;// ./node_modules/lodash-es/_arrayEvery.js\n/**\n * A specialized version of `_.every` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n */\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/* harmony default export */ const _arrayEvery = (arrayEvery);\n\n;// ./node_modules/lodash-es/_baseEvery.js\n\n\n/**\n * The base implementation of `_.every` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`\n */\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  (0,_baseEach/* default */.A)(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\n/* harmony default export */ const _baseEvery = (baseEvery);\n\n;// ./node_modules/lodash-es/every.js\n\n\n\n\n\n\n/**\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\n * Iteration is stopped once `predicate` returns falsey. The predicate is\n * invoked with three arguments: (value, index|key, collection).\n *\n * **Note:** This method returns `true` for\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n * elements of empty collections.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\n *  else `false`.\n * @example\n *\n * _.every([true, 1, null, \'yes\'], Boolean);\n * // => false\n *\n * var users = [\n *   { \'user\': \'barney\', \'age\': 36, \'active\': false },\n *   { \'user\': \'fred\',   \'age\': 40, \'active\': false }\n * ];\n *\n * // The `_.matches` iteratee shorthand.\n * _.every(users, { \'user\': \'barney\', \'active\': false });\n * // => false\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.every(users, [\'active\', false]);\n * // => true\n *\n * // The `_.property` iteratee shorthand.\n * _.every(users, \'active\');\n * // => false\n */\nfunction every(collection, predicate, guard) {\n  var func = (0,isArray/* default */.A)(collection) ? _arrayEvery : _baseEvery;\n  if (guard && (0,_isIterateeCall/* default */.A)(collection, predicate, guard)) {\n    predicate = undefined;\n  }\n  return func(collection, (0,_baseIteratee/* default */.A)(predicate, 3));\n}\n\n/* harmony default export */ const lodash_es_every = (every);\n\n;// ./node_modules/@chevrotain/gast/lib/src/helpers.js\n\n\nfunction isSequenceProd(prod) {\n    return (prod instanceof Alternative ||\n        prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionMandatory ||\n        prod instanceof RepetitionMandatoryWithSeparator ||\n        prod instanceof RepetitionWithSeparator ||\n        prod instanceof Terminal ||\n        prod instanceof Rule);\n}\nfunction isOptionalProd(prod, alreadyVisited = []) {\n    const isDirectlyOptional = prod instanceof Option ||\n        prod instanceof Repetition ||\n        prod instanceof RepetitionWithSeparator;\n    if (isDirectlyOptional) {\n        return true;\n    }\n    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\n    // empty optional top rule\n    // may be indirectly optional ((A?B?C?) | (D?E?F?))\n    if (prod instanceof Alternation) {\n        // for OR its enough for just one of the alternatives to be optional\n        return lodash_es_some(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else if (prod instanceof model_NonTerminal && lodash_es_includes(alreadyVisited, prod)) {\n        // avoiding stack overflow due to infinite recursion\n        return false;\n    }\n    else if (prod instanceof AbstractProduction) {\n        if (prod instanceof model_NonTerminal) {\n            alreadyVisited.push(prod);\n        }\n        return lodash_es_every(prod.definition, (subProd) => {\n            return isOptionalProd(subProd, alreadyVisited);\n        });\n    }\n    else {\n        return false;\n    }\n}\nfunction isBranchingProd(prod) {\n    return prod instanceof Alternation;\n}\nfunction getProductionDslName(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof model_NonTerminal) {\n        return "SUBRULE";\n    }\n    else if (prod instanceof Option) {\n        return "OPTION";\n    }\n    else if (prod instanceof Alternation) {\n        return "OR";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return "AT_LEAST_ONE";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return "AT_LEAST_ONE_SEP";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return "MANY_SEP";\n    }\n    else if (prod instanceof Repetition) {\n        return "MANY";\n    }\n    else if (prod instanceof Terminal) {\n        return "CONSUME";\n        /* c8 ignore next 3 */\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\n//# sourceMappingURL=helpers.js.map\n;// ./node_modules/@chevrotain/gast/lib/src/api.js\n\n\n\n//# sourceMappingURL=api.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/rest.js\n\n\n/**\n *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.\n */\nclass RestWalker {\n    walk(prod, prevRest = []) {\n        (0,forEach/* default */.A)(prod.definition, (subProd, index) => {\n            const currRest = lodash_es_drop(prod.definition, index + 1);\n            /* istanbul ignore else */\n            if (subProd instanceof model_NonTerminal) {\n                this.walkProdRef(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Terminal) {\n                this.walkTerminal(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternative) {\n                this.walkFlat(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Option) {\n                this.walkOption(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatory) {\n                this.walkAtLeastOne(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionMandatoryWithSeparator) {\n                this.walkAtLeastOneSep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof RepetitionWithSeparator) {\n                this.walkManySep(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Repetition) {\n                this.walkMany(subProd, currRest, prevRest);\n            }\n            else if (subProd instanceof Alternation) {\n                this.walkOr(subProd, currRest, prevRest);\n            }\n            else {\n                throw Error("non exhaustive match");\n            }\n        });\n    }\n    walkTerminal(terminal, currRest, prevRest) { }\n    walkProdRef(refProd, currRest, prevRest) { }\n    walkFlat(flatProd, currRest, prevRest) {\n        // ABCDEF => after the D the rest is EF\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(flatProd, fullOrRest);\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        // ABC(DE)?F => after the (DE)? the rest is F\n        const fullOrRest = currRest.concat(prevRest);\n        this.walk(optionProd, fullOrRest);\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\n        const fullAtLeastOneRest = [\n            new Option({ definition: atLeastOneProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(atLeastOneProd, fullAtLeastOneRest);\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\n        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);\n        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        // ABC(DE)*F => after the (DE)* the rest is (DE)?F\n        const fullManyRest = [\n            new Option({ definition: manyProd.definition }),\n        ].concat(currRest, prevRest);\n        this.walk(manyProd, fullManyRest);\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\n        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);\n        this.walk(manySepProd, fullManySepRest);\n    }\n    walkOr(orProd, currRest, prevRest) {\n        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\n        const fullOrRest = currRest.concat(prevRest);\n        // walk all different alternatives\n        (0,forEach/* default */.A)(orProd.definition, (alt) => {\n            // wrapping each alternative in a single definition wrapper\n            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\n            // (otherwise for OR([alt1,alt2]) alt2 will be considered in \'rest\' of alt1\n            const prodWrapper = new Alternative({ definition: [alt] });\n            this.walk(prodWrapper, fullOrRest);\n        });\n    }\n}\nfunction restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {\n    const repSepRest = [\n        new Option({\n            definition: [\n                new Terminal({ terminalType: repSepProd.separator }),\n            ].concat(repSepProd.definition),\n        }),\n    ];\n    const fullRepSepRest = repSepRest.concat(currRest, prevRest);\n    return fullRepSepRest;\n}\n//# sourceMappingURL=rest.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseUniq.js + 1 modules\nvar _baseUniq = __webpack_require__(99902);\n;// ./node_modules/lodash-es/uniq.js\n\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? (0,_baseUniq/* default */.A)(array) : [];\n}\n\n/* harmony default export */ const lodash_es_uniq = (uniq);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/flatten.js\nvar lodash_es_flatten = __webpack_require__(34098);\n;// ./node_modules/chevrotain/lib/src/parse/grammar/first.js\n\n\nfunction first(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof model_NonTerminal) {\n        // this could in theory cause infinite loops if\n        // (1) prod A refs prod B.\n        // (2) prod B refs prod A\n        // (3) AB can match the empty set\n        // in other words a cycle where everything is optional so the first will keep\n        // looking ahead for the next optional part and will never exit\n        // currently there is no safeguard for this unique edge case because\n        // (1) not sure a grammar in which this can happen is useful for anything (productive)\n        return first(prod.referencedRule);\n    }\n    else if (prod instanceof Terminal) {\n        return firstForTerminal(prod);\n    }\n    else if (isSequenceProd(prod)) {\n        return firstForSequence(prod);\n    }\n    else if (isBranchingProd(prod)) {\n        return firstForBranching(prod);\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction firstForSequence(prod) {\n    let firstSet = [];\n    const seq = prod.definition;\n    let nextSubProdIdx = 0;\n    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    let currSubProd;\n    // so we enter the loop at least once (if the definition is not empty\n    let isLastInnerProdOptional = true;\n    // scan a sequence until it\'s end or until we have found a NONE optional production in it\n    while (hasInnerProdsRemaining && isLastInnerProdOptional) {\n        currSubProd = seq[nextSubProdIdx];\n        isLastInnerProdOptional = isOptionalProd(currSubProd);\n        firstSet = firstSet.concat(first(currSubProd));\n        nextSubProdIdx = nextSubProdIdx + 1;\n        hasInnerProdsRemaining = seq.length > nextSubProdIdx;\n    }\n    return lodash_es_uniq(firstSet);\n}\nfunction firstForBranching(prod) {\n    const allAlternativesFirsts = (0,lodash_es_map/* default */.A)(prod.definition, (innerProd) => {\n        return first(innerProd);\n    });\n    return lodash_es_uniq((0,lodash_es_flatten/* default */.A)(allAlternativesFirsts));\n}\nfunction firstForTerminal(terminal) {\n    return [terminal.terminalType];\n}\n//# sourceMappingURL=first.js.map\n;// ./node_modules/chevrotain/lib/src/parse/constants.js\n// TODO: can this be removed? where is it used?\nconst constants_IN = "_~IN~_";\n//# sourceMappingURL=constants.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/follow.js\n\n\n\n\n\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\n// (skipping reference production).\nclass ResyncFollowsWalker extends RestWalker {\n    constructor(topProd) {\n        super();\n        this.topProd = topProd;\n        this.follows = {};\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.follows;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        // do nothing! just like in the public sector after 13:00\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\n            this.topProd.name;\n        const fullRest = currRest.concat(prevRest);\n        const restProd = new Alternative({ definition: fullRest });\n        const t_in_topProd_follows = first(restProd);\n        this.follows[followName] = t_in_topProd_follows;\n    }\n}\nfunction computeAllProdsFollows(topProductions) {\n    const reSyncFollows = {};\n    (0,forEach/* default */.A)(topProductions, (topProd) => {\n        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\n        lodash_es_assign(reSyncFollows, currRefsFollow);\n    });\n    return reSyncFollows;\n}\nfunction buildBetweenProdsFollowPrefix(inner, occurenceInParent) {\n    return inner.name + occurenceInParent + constants_IN;\n}\nfunction buildInProdFollowPrefix(terminal) {\n    const terminalName = terminal.terminalType.name;\n    return terminalName + terminal.idx + IN;\n}\n//# sourceMappingURL=follow.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/isUndefined.js\nvar isUndefined = __webpack_require__(69592);\n// EXTERNAL MODULE: ./node_modules/lodash-es/defaults.js\nvar defaults = __webpack_require__(23068);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayFilter.js\nvar _arrayFilter = __webpack_require__(2634);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseFilter.js\nvar _baseFilter = __webpack_require__(51790);\n;// ./node_modules/lodash-es/negate.js\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = \'Expected a function\';\n\n/**\n * Creates a function that negates the result of the predicate `func`. The\n * `func` predicate is invoked with the `this` binding and arguments of the\n * created function.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Function\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n * @example\n *\n * function isEven(n) {\n *   return n % 2 == 0;\n * }\n *\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n * // => [1, 3, 5]\n */\nfunction negate(predicate) {\n  if (typeof predicate != \'function\') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  return function() {\n    var args = arguments;\n    switch (args.length) {\n      case 0: return !predicate.call(this);\n      case 1: return !predicate.call(this, args[0]);\n      case 2: return !predicate.call(this, args[0], args[1]);\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\n    }\n    return !predicate.apply(this, args);\n  };\n}\n\n/* harmony default export */ const lodash_es_negate = (negate);\n\n;// ./node_modules/lodash-es/reject.js\n\n\n\n\n\n\n/**\n * The opposite of `_.filter`; this method returns the elements of `collection`\n * that `predicate` does **not** return truthy for.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.filter\n * @example\n *\n * var users = [\n *   { \'user\': \'barney\', \'age\': 36, \'active\': false },\n *   { \'user\': \'fred\',   \'age\': 40, \'active\': true }\n * ];\n *\n * _.reject(users, function(o) { return !o.active; });\n * // => objects for [\'fred\']\n *\n * // The `_.matches` iteratee shorthand.\n * _.reject(users, { \'age\': 40, \'active\': true });\n * // => objects for [\'barney\']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.reject(users, [\'active\', false]);\n * // => objects for [\'fred\']\n *\n * // The `_.property` iteratee shorthand.\n * _.reject(users, \'active\');\n * // => objects for [\'barney\']\n */\nfunction reject(collection, predicate) {\n  var func = (0,isArray/* default */.A)(collection) ? _arrayFilter/* default */.A : _baseFilter/* default */.A;\n  return func(collection, lodash_es_negate((0,_baseIteratee/* default */.A)(predicate, 3)));\n}\n\n/* harmony default export */ const lodash_es_reject = (reject);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/isFunction.js\nvar isFunction = __webpack_require__(89610);\n;// ./node_modules/lodash-es/indexOf.js\n\n\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar indexOf_nativeMax = Math.max;\n\n/**\n * Gets the index at which the first occurrence of `value` is found in `array`\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. If `fromIndex` is negative, it\'s used as the\n * offset from the end of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n * @example\n *\n * _.indexOf([1, 2, 1, 2], 2);\n * // => 1\n *\n * // Search from the `fromIndex`.\n * _.indexOf([1, 2, 1, 2], 2, 2);\n * // => 3\n */\nfunction indexOf(array, value, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : (0,toInteger/* default */.A)(fromIndex);\n  if (index < 0) {\n    index = indexOf_nativeMax(length + index, 0);\n  }\n  return (0,_baseIndexOf/* default */.A)(array, value, index);\n}\n\n/* harmony default export */ const lodash_es_indexOf = (indexOf);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/reduce.js + 2 modules\nvar reduce = __webpack_require__(89463);\n// EXTERNAL MODULE: ./node_modules/lodash-es/filter.js\nvar filter = __webpack_require__(94092);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_SetCache.js + 2 modules\nvar _SetCache = __webpack_require__(62062);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayIncludes.js\nvar _arrayIncludes = __webpack_require__(83149);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_arrayIncludesWith.js\nvar _arrayIncludesWith = __webpack_require__(87809);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_cacheHas.js\nvar _cacheHas = __webpack_require__(64099);\n;// ./node_modules/lodash-es/_baseDifference.js\n\n\n\n\n\n\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/**\n * The base implementation of methods like `_.difference` without support\n * for excluding multiple arrays or iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Array} values The values to exclude.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of filtered values.\n */\nfunction baseDifference(array, values, iteratee, comparator) {\n  var index = -1,\n      includes = _arrayIncludes/* default */.A,\n      isCommon = true,\n      length = array.length,\n      result = [],\n      valuesLength = values.length;\n\n  if (!length) {\n    return result;\n  }\n  if (iteratee) {\n    values = (0,_arrayMap/* default */.A)(values, (0,_baseUnary/* default */.A)(iteratee));\n  }\n  if (comparator) {\n    includes = _arrayIncludesWith/* default */.A;\n    isCommon = false;\n  }\n  else if (values.length >= LARGE_ARRAY_SIZE) {\n    includes = _cacheHas/* default */.A;\n    isCommon = false;\n    values = new _SetCache/* default */.A(values);\n  }\n  outer:\n  while (++index < length) {\n    var value = array[index],\n        computed = iteratee == null ? value : iteratee(value);\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (isCommon && computed === computed) {\n      var valuesIndex = valuesLength;\n      while (valuesIndex--) {\n        if (values[valuesIndex] === computed) {\n          continue outer;\n        }\n      }\n      result.push(value);\n    }\n    else if (!includes(values, computed, comparator)) {\n      result.push(value);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _baseDifference = (baseDifference);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseFlatten.js + 1 modules\nvar _baseFlatten = __webpack_require__(13588);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseRest.js\nvar _baseRest = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLikeObject.js\nvar isArrayLikeObject = __webpack_require__(53533);\n;// ./node_modules/lodash-es/difference.js\n\n\n\n\n\n/**\n * Creates an array of `array` values not included in the other given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {...Array} [values] The values to exclude.\n * @returns {Array} Returns the new array of filtered values.\n * @see _.without, _.xor\n * @example\n *\n * _.difference([2, 1], [2, 3]);\n * // => [1]\n */\nvar difference = (0,_baseRest/* default */.A)(function(array, values) {\n  return (0,isArrayLikeObject/* default */.A)(array)\n    ? _baseDifference(array, (0,_baseFlatten/* default */.A)(values, 1, isArrayLikeObject/* default */.A, true))\n    : [];\n});\n\n/* harmony default export */ const lodash_es_difference = (difference);\n\n;// ./node_modules/lodash-es/compact.js\n/**\n * Creates an array with all falsey values removed. The values `false`, `null`,\n * `0`, `""`, `undefined`, and `NaN` are falsey.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to compact.\n * @returns {Array} Returns the new array of filtered values.\n * @example\n *\n * _.compact([0, 1, false, 2, \'\', 3]);\n * // => [1, 2, 3]\n */\nfunction compact(array) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (value) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const lodash_es_compact = (compact);\n\n;// ./node_modules/lodash-es/head.js\n/**\n * Gets the first element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @alias first\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the first element of `array`.\n * @example\n *\n * _.head([1, 2, 3]);\n * // => 1\n *\n * _.head([]);\n * // => undefined\n */\nfunction head(array) {\n  return (array && array.length) ? array[0] : undefined;\n}\n\n/* harmony default export */ const lodash_es_head = (head);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/find.js + 2 modules\nvar find = __webpack_require__(16145);\n;// ./node_modules/@chevrotain/utils/lib/src/print.js\nfunction PRINT_ERROR(msg) {\n    /* istanbul ignore else - can\'t override global.console in node.js */\n    if (console && console.error) {\n        console.error(`Error: ${msg}`);\n    }\n}\nfunction PRINT_WARNING(msg) {\n    /* istanbul ignore else - can\'t override global.console in node.js*/\n    if (console && console.warn) {\n        // TODO: modify docs accordingly\n        console.warn(`Warning: ${msg}`);\n    }\n}\n//# sourceMappingURL=print.js.map\n;// ./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js\n\nlet regExpAstCache = {};\nconst regExpParser = new RegExpParser();\nfunction getRegExpAst(regExp) {\n    const regExpStr = regExp.toString();\n    if (regExpAstCache.hasOwnProperty(regExpStr)) {\n        return regExpAstCache[regExpStr];\n    }\n    else {\n        const regExpAst = regExpParser.pattern(regExpStr);\n        regExpAstCache[regExpStr] = regExpAst;\n        return regExpAst;\n    }\n}\nfunction clearRegExpParserCache() {\n    regExpAstCache = {};\n}\n//# sourceMappingURL=reg_exp_parser.js.map\n;// ./node_modules/chevrotain/lib/src/scan/reg_exp.js\n\n\n\n\n\nconst complementErrorMessage = "Complement Sets are not supported for first char optimization";\nconst failedOptimizationPrefixMsg = \'Unable to use "first char" lexer optimizations:\\n\';\nfunction getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {\n    try {\n        const ast = getRegExpAst(regExp);\n        const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);\n        return firstChars;\n    }\n    catch (e) {\n        /* istanbul ignore next */\n        // Testing this relies on the regexp-to-ast library having a bug... */\n        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\n        if (e.message === complementErrorMessage) {\n            if (ensureOptimizations) {\n                PRINT_WARNING(`${failedOptimizationPrefixMsg}` +\n                    `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\n                    "\\tComplement Sets cannot be automatically optimized.\\n" +\n                    "\\tThis will disable the lexer\'s first char optimizations.\\n" +\n                    "\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");\n            }\n        }\n        else {\n            let msgSuffix = "";\n            if (ensureOptimizations) {\n                msgSuffix =\n                    "\\n\\tThis will disable the lexer\'s first char optimizations.\\n" +\n                        "\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";\n            }\n            PRINT_ERROR(`${failedOptimizationPrefixMsg}\\n` +\n                `\\tFailed parsing: < ${regExp.toString()} >\\n` +\n                `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\n                "\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues" +\n                msgSuffix);\n        }\n    }\n    return [];\n}\nfunction firstCharOptimizedIndices(ast, result, ignoreCase) {\n    switch (ast.type) {\n        case "Disjunction":\n            for (let i = 0; i < ast.value.length; i++) {\n                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\n            }\n            break;\n        case "Alternative":\n            const terms = ast.value;\n            for (let i = 0; i < terms.length; i++) {\n                const term = terms[i];\n                // skip terms that cannot effect the first char results\n                switch (term.type) {\n                    case "EndAnchor":\n                    // A group back reference cannot affect potential starting char.\n                    // because if a back reference is the first production than automatically\n                    // the group being referenced has had to come BEFORE so its codes have already been added\n                    case "GroupBackReference":\n                    // assertions do not affect potential starting codes\n                    case "Lookahead":\n                    case "NegativeLookahead":\n                    case "StartAnchor":\n                    case "WordBoundary":\n                    case "NonWordBoundary":\n                        continue;\n                }\n                const atom = term;\n                switch (atom.type) {\n                    case "Character":\n                        addOptimizedIdxToResult(atom.value, result, ignoreCase);\n                        break;\n                    case "Set":\n                        if (atom.complement === true) {\n                            throw Error(complementErrorMessage);\n                        }\n                        (0,forEach/* default */.A)(atom.value, (code) => {\n                            if (typeof code === "number") {\n                                addOptimizedIdxToResult(code, result, ignoreCase);\n                            }\n                            else {\n                                // range\n                                const range = code;\n                                // cannot optimize when ignoreCase is\n                                if (ignoreCase === true) {\n                                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                }\n                                // Optimization (2 orders of magnitude less work for very large ranges)\n                                else {\n                                    // handle unoptimized values\n                                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < minOptimizationVal; rangeCode++) {\n                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);\n                                    }\n                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"\n                                    if (range.to >= minOptimizationVal) {\n                                        const minUnOptVal = range.from >= minOptimizationVal\n                                            ? range.from\n                                            : minOptimizationVal;\n                                        const maxUnOptVal = range.to;\n                                        const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\n                                        const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\n                                        for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {\n                                            result[currOptIdx] = currOptIdx;\n                                        }\n                                    }\n                                }\n                            }\n                        });\n                        break;\n                    case "Group":\n                        firstCharOptimizedIndices(atom.value, result, ignoreCase);\n                        break;\n                    /* istanbul ignore next */\n                    default:\n                        throw Error("Non Exhaustive Match");\n                }\n                // reached a mandatory production, no more **start** codes can be found on this alternative\n                const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\n                if (\n                // A group may be optional due to empty contents /(?:)/\n                // or if everything inside it is optional /((a)?)/\n                (atom.type === "Group" && isWholeOptional(atom) === false) ||\n                    // If this term is not a group it may only be optional if it has an optional quantifier\n                    (atom.type !== "Group" && isOptionalQuantifier === false)) {\n                    break;\n                }\n            }\n            break;\n        /* istanbul ignore next */\n        default:\n            throw Error("non exhaustive match!");\n    }\n    // console.log(Object.keys(result).length)\n    return (0,lodash_es_values/* default */.A)(result);\n}\nfunction addOptimizedIdxToResult(code, result, ignoreCase) {\n    const optimizedCharIdx = charCodeToOptimizedIndex(code);\n    result[optimizedCharIdx] = optimizedCharIdx;\n    if (ignoreCase === true) {\n        handleIgnoreCase(code, result);\n    }\n}\nfunction handleIgnoreCase(code, result) {\n    const char = String.fromCharCode(code);\n    const upperChar = char.toUpperCase();\n    /* istanbul ignore else */\n    if (upperChar !== char) {\n        const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\n        result[optimizedCharIdx] = optimizedCharIdx;\n    }\n    else {\n        const lowerChar = char.toLowerCase();\n        if (lowerChar !== char) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));\n            result[optimizedCharIdx] = optimizedCharIdx;\n        }\n    }\n}\nfunction findCode(setNode, targetCharCodes) {\n    return (0,find/* default */.A)(setNode.value, (codeOrRange) => {\n        if (typeof codeOrRange === "number") {\n            return lodash_es_includes(targetCharCodes, codeOrRange);\n        }\n        else {\n            // range\n            const range = codeOrRange;\n            return ((0,find/* default */.A)(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined);\n        }\n    });\n}\nfunction isWholeOptional(ast) {\n    const quantifier = ast.quantifier;\n    if (quantifier && quantifier.atLeast === 0) {\n        return true;\n    }\n    if (!ast.value) {\n        return false;\n    }\n    return (0,isArray/* default */.A)(ast.value)\n        ? lodash_es_every(ast.value, isWholeOptional)\n        : isWholeOptional(ast.value);\n}\nclass CharCodeFinder extends BaseRegExpVisitor {\n    constructor(targetCharCodes) {\n        super();\n        this.targetCharCodes = targetCharCodes;\n        this.found = false;\n    }\n    visitChildren(node) {\n        // No need to keep looking...\n        if (this.found === true) {\n            return;\n        }\n        // switch lookaheads as they do not actually consume any characters thus\n        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\n        switch (node.type) {\n            case "Lookahead":\n                this.visitLookahead(node);\n                return;\n            case "NegativeLookahead":\n                this.visitNegativeLookahead(node);\n                return;\n        }\n        super.visitChildren(node);\n    }\n    visitCharacter(node) {\n        if (lodash_es_includes(this.targetCharCodes, node.value)) {\n            this.found = true;\n        }\n    }\n    visitSet(node) {\n        if (node.complement) {\n            if (findCode(node, this.targetCharCodes) === undefined) {\n                this.found = true;\n            }\n        }\n        else {\n            if (findCode(node, this.targetCharCodes) !== undefined) {\n                this.found = true;\n            }\n        }\n    }\n}\nfunction canMatchCharCode(charCodes, pattern) {\n    if (pattern instanceof RegExp) {\n        const ast = getRegExpAst(pattern);\n        const charCodeFinder = new CharCodeFinder(charCodes);\n        charCodeFinder.visit(ast);\n        return charCodeFinder.found;\n    }\n    else {\n        return ((0,find/* default */.A)(pattern, (char) => {\n            return lodash_es_includes(charCodes, char.charCodeAt(0));\n        }) !== undefined);\n    }\n}\n//# sourceMappingURL=reg_exp.js.map\n;// ./node_modules/chevrotain/lib/src/scan/lexer.js\n\n\n\n\n\n\nconst PATTERN = "PATTERN";\nconst DEFAULT_MODE = "defaultMode";\nconst MODES = "modes";\nlet SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";\nfunction disableSticky() {\n    SUPPORT_STICKY = false;\n}\nfunction enableSticky() {\n    SUPPORT_STICKY = true;\n}\nfunction analyzeTokenTypes(tokenTypes, options) {\n    options = (0,defaults/* default */.A)(options, {\n        useSticky: SUPPORT_STICKY,\n        debug: false,\n        safeMode: false,\n        positionTracking: "full",\n        lineTerminatorCharacters: ["\\r", "\\n"],\n        tracer: (msg, action) => action(),\n    });\n    const tracer = options.tracer;\n    tracer("initCharCodeToOptimizedIndexMap", () => {\n        initCharCodeToOptimizedIndexMap();\n    });\n    let onlyRelevantTypes;\n    tracer("Reject Lexer.NA", () => {\n        onlyRelevantTypes = lodash_es_reject(tokenTypes, (currType) => {\n            return currType[PATTERN] === Lexer.NA;\n        });\n    });\n    let hasCustom = false;\n    let allTransformedPatterns;\n    tracer("Transform Patterns", () => {\n        hasCustom = false;\n        allTransformedPatterns = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (currType) => {\n            const currPattern = currType[PATTERN];\n            /* istanbul ignore else */\n            if (lodash_es_isRegExp(currPattern)) {\n                const regExpSource = currPattern.source;\n                if (regExpSource.length === 1 &&\n                    // only these regExp meta characters which can appear in a length one regExp\n                    regExpSource !== "^" &&\n                    regExpSource !== "$" &&\n                    regExpSource !== "." &&\n                    !currPattern.ignoreCase) {\n                    return regExpSource;\n                }\n                else if (regExpSource.length === 2 &&\n                    regExpSource[0] === "\\\\" &&\n                    // not a meta character\n                    !lodash_es_includes([\n                        "d",\n                        "D",\n                        "s",\n                        "S",\n                        "t",\n                        "r",\n                        "n",\n                        "t",\n                        "0",\n                        "c",\n                        "b",\n                        "B",\n                        "f",\n                        "v",\n                        "w",\n                        "W",\n                    ], regExpSource[1])) {\n                    // escaped meta Characters: /\\+/ /\\[/\n                    // or redundant escaping: /\\a/\n                    // without the escaping "\\"\n                    return regExpSource[1];\n                }\n                else {\n                    return options.useSticky\n                        ? addStickyFlag(currPattern)\n                        : addStartOfInput(currPattern);\n                }\n            }\n            else if ((0,isFunction/* default */.A)(currPattern)) {\n                hasCustom = true;\n                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n                return { exec: currPattern };\n            }\n            else if (typeof currPattern === "object") {\n                hasCustom = true;\n                // ICustomPattern\n                return currPattern;\n            }\n            else if (typeof currPattern === "string") {\n                if (currPattern.length === 1) {\n                    return currPattern;\n                }\n                else {\n                    const escapedRegExpString = currPattern.replace(/[\\\\^$.*+?()[\\]{}|]/g, "\\\\$&");\n                    const wrappedRegExp = new RegExp(escapedRegExpString);\n                    return options.useSticky\n                        ? addStickyFlag(wrappedRegExp)\n                        : addStartOfInput(wrappedRegExp);\n                }\n            }\n            else {\n                throw Error("non exhaustive match");\n            }\n        });\n    });\n    let patternIdxToType;\n    let patternIdxToGroup;\n    let patternIdxToLongerAltIdxArr;\n    let patternIdxToPushMode;\n    let patternIdxToPopMode;\n    tracer("misc mapping", () => {\n        patternIdxToType = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);\n        patternIdxToGroup = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (clazz) => {\n            const groupName = clazz.GROUP;\n            /* istanbul ignore next */\n            if (groupName === Lexer.SKIPPED) {\n                return undefined;\n            }\n            else if ((0,isString/* default */.A)(groupName)) {\n                return groupName;\n            }\n            else if ((0,isUndefined/* default */.A)(groupName)) {\n                return false;\n            }\n            else {\n                throw Error("non exhaustive match");\n            }\n        });\n        patternIdxToLongerAltIdxArr = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (clazz) => {\n            const longerAltType = clazz.LONGER_ALT;\n            if (longerAltType) {\n                const longerAltIdxArr = (0,isArray/* default */.A)(longerAltType)\n                    ? (0,lodash_es_map/* default */.A)(longerAltType, (type) => lodash_es_indexOf(onlyRelevantTypes, type))\n                    : [lodash_es_indexOf(onlyRelevantTypes, longerAltType)];\n                return longerAltIdxArr;\n            }\n        });\n        patternIdxToPushMode = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);\n        patternIdxToPopMode = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (clazz) => (0,has/* default */.A)(clazz, "POP_MODE"));\n    });\n    let patternIdxToCanLineTerminator;\n    tracer("Line Terminator Handling", () => {\n        const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);\n        patternIdxToCanLineTerminator = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (tokType) => false);\n        if (options.positionTracking !== "onlyOffset") {\n            patternIdxToCanLineTerminator = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, (tokType) => {\n                if ((0,has/* default */.A)(tokType, "LINE_BREAKS")) {\n                    return !!tokType.LINE_BREAKS;\n                }\n                else {\n                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\n                        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN));\n                }\n            });\n        }\n    });\n    let patternIdxToIsCustom;\n    let patternIdxToShort;\n    let emptyGroups;\n    let patternIdxToConfig;\n    tracer("Misc Mapping #2", () => {\n        patternIdxToIsCustom = (0,lodash_es_map/* default */.A)(onlyRelevantTypes, isCustomPattern);\n        patternIdxToShort = (0,lodash_es_map/* default */.A)(allTransformedPatterns, isShortPattern);\n        emptyGroups = (0,reduce/* default */.A)(onlyRelevantTypes, (acc, clazz) => {\n            const groupName = clazz.GROUP;\n            if ((0,isString/* default */.A)(groupName) && !(groupName === Lexer.SKIPPED)) {\n                acc[groupName] = [];\n            }\n            return acc;\n        }, {});\n        patternIdxToConfig = (0,lodash_es_map/* default */.A)(allTransformedPatterns, (x, idx) => {\n            return {\n                pattern: allTransformedPatterns[idx],\n                longerAlt: patternIdxToLongerAltIdxArr[idx],\n                canLineTerminator: patternIdxToCanLineTerminator[idx],\n                isCustom: patternIdxToIsCustom[idx],\n                short: patternIdxToShort[idx],\n                group: patternIdxToGroup[idx],\n                push: patternIdxToPushMode[idx],\n                pop: patternIdxToPopMode[idx],\n                tokenTypeIdx: patternIdxToType[idx],\n                tokenType: onlyRelevantTypes[idx],\n            };\n        });\n    });\n    let canBeOptimized = true;\n    let charCodeToPatternIdxToConfig = [];\n    if (!options.safeMode) {\n        tracer("First Char Optimization", () => {\n            charCodeToPatternIdxToConfig = (0,reduce/* default */.A)(onlyRelevantTypes, (result, currTokType, idx) => {\n                if (typeof currTokType.PATTERN === "string") {\n                    const charCode = currTokType.PATTERN.charCodeAt(0);\n                    const optimizedIdx = charCodeToOptimizedIndex(charCode);\n                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\n                }\n                else if ((0,isArray/* default */.A)(currTokType.START_CHARS_HINT)) {\n                    let lastOptimizedIdx;\n                    (0,forEach/* default */.A)(currTokType.START_CHARS_HINT, (charOrInt) => {\n                        const charCode = typeof charOrInt === "string"\n                            ? charOrInt.charCodeAt(0)\n                            : charOrInt;\n                        const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\n                        // Avoid adding the config multiple times\n                        /* istanbul ignore else */\n                        // - Difficult to check this scenario effects as it is only a performance\n                        //   optimization that does not change correctness\n                        if (lastOptimizedIdx !== currOptimizedIdx) {\n                            lastOptimizedIdx = currOptimizedIdx;\n                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);\n                        }\n                    });\n                }\n                else if (lodash_es_isRegExp(currTokType.PATTERN)) {\n                    if (currTokType.PATTERN.unicode) {\n                        canBeOptimized = false;\n                        if (options.ensureOptimizations) {\n                            PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                                `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\n                                "\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n" +\n                                "\\tThis will disable the lexer\'s first char optimizations.\\n" +\n                                "\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");\n                        }\n                    }\n                    else {\n                        const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);\n                        /* istanbul ignore if */\n                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library\n                        // the first should be a different validation and the second cannot be tested.\n                        if ((0,isEmpty/* default */.A)(optimizedCodes)) {\n                            // we cannot understand what codes may start possible matches\n                            // The optimization correctness requires knowing start codes for ALL patterns.\n                            // Not actually sure this is an error, no debug message\n                            canBeOptimized = false;\n                        }\n                        (0,forEach/* default */.A)(optimizedCodes, (code) => {\n                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);\n                        });\n                    }\n                }\n                else {\n                    if (options.ensureOptimizations) {\n                        PRINT_ERROR(`${failedOptimizationPrefixMsg}` +\n                            `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\n                            "\\tThis will disable the lexer\'s first char optimizations.\\n" +\n                            "\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");\n                    }\n                    canBeOptimized = false;\n                }\n                return result;\n            }, []);\n        });\n    }\n    return {\n        emptyGroups: emptyGroups,\n        patternIdxToConfig: patternIdxToConfig,\n        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\n        hasCustom: hasCustom,\n        canBeOptimized: canBeOptimized,\n    };\n}\nfunction validatePatterns(tokenTypes, validModesNames) {\n    let errors = [];\n    const missingResult = findMissingPatterns(tokenTypes);\n    errors = errors.concat(missingResult.errors);\n    const invalidResult = findInvalidPatterns(missingResult.valid);\n    const validTokenTypes = invalidResult.valid;\n    errors = errors.concat(invalidResult.errors);\n    errors = errors.concat(validateRegExpPattern(validTokenTypes));\n    errors = errors.concat(findInvalidGroupType(validTokenTypes));\n    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));\n    errors = errors.concat(findUnreachablePatterns(validTokenTypes));\n    return errors;\n}\nfunction validateRegExpPattern(tokenTypes) {\n    let errors = [];\n    const withRegExpPatterns = (0,filter/* default */.A)(tokenTypes, (currTokType) => lodash_es_isRegExp(currTokType[PATTERN]));\n    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\n    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\n    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\n    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\n    return errors;\n}\nfunction findMissingPatterns(tokenTypes) {\n    const tokenTypesWithMissingPattern = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        return !(0,has/* default */.A)(currType, PATTERN);\n    });\n    const errors = (0,lodash_es_map/* default */.A)(tokenTypesWithMissingPattern, (currType) => {\n        return {\n            message: "Token Type: ->" +\n                currType.name +\n                "<- missing static \'PATTERN\' property",\n            type: LexerDefinitionErrorType.MISSING_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = lodash_es_difference(tokenTypes, tokenTypesWithMissingPattern);\n    return { errors, valid };\n}\nfunction findInvalidPatterns(tokenTypes) {\n    const tokenTypesWithInvalidPattern = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return (!lodash_es_isRegExp(pattern) &&\n            !(0,isFunction/* default */.A)(pattern) &&\n            !(0,has/* default */.A)(pattern, "exec") &&\n            !(0,isString/* default */.A)(pattern));\n    });\n    const errors = (0,lodash_es_map/* default */.A)(tokenTypesWithInvalidPattern, (currType) => {\n        return {\n            message: "Token Type: ->" +\n                currType.name +\n                "<- static \'PATTERN\' can only be a RegExp, a" +\n                " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",\n            type: LexerDefinitionErrorType.INVALID_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    const valid = lodash_es_difference(tokenTypes, tokenTypesWithInvalidPattern);\n    return { errors, valid };\n}\nconst end_of_input = /[^\\\\][$]/;\nfunction findEndOfInputAnchor(tokenTypes) {\n    class EndAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitEndAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const endAnchorVisitor = new EndAnchorFinder();\n            endAnchorVisitor.visit(regexpAst);\n            return endAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return end_of_input.test(pattern.source);\n        }\n    });\n    const errors = (0,lodash_es_map/* default */.A)(invalidRegex, (currType) => {\n        return {\n            message: "Unexpected RegExp Anchor Error:\\n" +\n                "\\tToken Type: ->" +\n                currType.name +\n                "<- static \'PATTERN\' cannot contain end of input anchor \'$\'\\n" +\n                "\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" +\n                "\\tfor details.",\n            type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nfunction findEmptyMatchRegExps(tokenTypes) {\n    const matchesEmptyString = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        return pattern.test("");\n    });\n    const errors = (0,lodash_es_map/* default */.A)(matchesEmptyString, (currType) => {\n        return {\n            message: "Token Type: ->" +\n                currType.name +\n                "<- static \'PATTERN\' must not match an empty string",\n            type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\nfunction findStartOfInputAnchor(tokenTypes) {\n    class StartAnchorFinder extends BaseRegExpVisitor {\n        constructor() {\n            super(...arguments);\n            this.found = false;\n        }\n        visitStartAnchor(node) {\n            this.found = true;\n        }\n    }\n    const invalidRegex = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        const pattern = currType.PATTERN;\n        try {\n            const regexpAst = getRegExpAst(pattern);\n            const startAnchorVisitor = new StartAnchorFinder();\n            startAnchorVisitor.visit(regexpAst);\n            return startAnchorVisitor.found;\n        }\n        catch (e) {\n            // old behavior in case of runtime exceptions with regexp-to-ast.\n            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\n            return start_of_input.test(pattern.source);\n        }\n    });\n    const errors = (0,lodash_es_map/* default */.A)(invalidRegex, (currType) => {\n        return {\n            message: "Unexpected RegExp Anchor Error:\\n" +\n                "\\tToken Type: ->" +\n                currType.name +\n                "<- static \'PATTERN\' cannot contain start of input anchor \'^\'\\n" +\n                "\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" +\n                "\\tfor details.",\n            type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nfunction findUnsupportedFlags(tokenTypes) {\n    const invalidFlags = (0,filter/* default */.A)(tokenTypes, (currType) => {\n        const pattern = currType[PATTERN];\n        return pattern instanceof RegExp && (pattern.multiline || pattern.global);\n    });\n    const errors = (0,lodash_es_map/* default */.A)(invalidFlags, (currType) => {\n        return {\n            message: "Token Type: ->" +\n                currType.name +\n                "<- static \'PATTERN\' may NOT contain global(\'g\') or multiline(\'m\')",\n            type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\nfunction findDuplicatePatterns(tokenTypes) {\n    const found = [];\n    let identicalPatterns = (0,lodash_es_map/* default */.A)(tokenTypes, (outerType) => {\n        return (0,reduce/* default */.A)(tokenTypes, (result, innerType) => {\n            if (outerType.PATTERN.source === innerType.PATTERN.source &&\n                !lodash_es_includes(found, innerType) &&\n                innerType.PATTERN !== Lexer.NA) {\n                // this avoids duplicates in the result, each Token Type may only appear in one "set"\n                // in essence we are creating Equivalence classes on equality relation.\n                found.push(innerType);\n                result.push(innerType);\n                return result;\n            }\n            return result;\n        }, []);\n    });\n    identicalPatterns = lodash_es_compact(identicalPatterns);\n    const duplicatePatterns = (0,filter/* default */.A)(identicalPatterns, (currIdenticalSet) => {\n        return currIdenticalSet.length > 1;\n    });\n    const errors = (0,lodash_es_map/* default */.A)(duplicatePatterns, (setOfIdentical) => {\n        const tokenTypeNames = (0,lodash_es_map/* default */.A)(setOfIdentical, (currType) => {\n            return currType.name;\n        });\n        const dupPatternSrc = lodash_es_head(setOfIdentical).PATTERN;\n        return {\n            message: `The same RegExp pattern ->${dupPatternSrc}<-` +\n                `has been used in all of the following Token Types: ${tokenTypeNames.join(", ")} <-`,\n            type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\n            tokenTypes: setOfIdentical,\n        };\n    });\n    return errors;\n}\nfunction findInvalidGroupType(tokenTypes) {\n    const invalidTypes = (0,filter/* default */.A)(tokenTypes, (clazz) => {\n        if (!(0,has/* default */.A)(clazz, "GROUP")) {\n            return false;\n        }\n        const group = clazz.GROUP;\n        return group !== Lexer.SKIPPED && group !== Lexer.NA && !(0,isString/* default */.A)(group);\n    });\n    const errors = (0,lodash_es_map/* default */.A)(invalidTypes, (currType) => {\n        return {\n            message: "Token Type: ->" +\n                currType.name +\n                "<- static \'GROUP\' can only be Lexer.SKIPPED/Lexer.NA/A String",\n            type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\n            tokenTypes: [currType],\n        };\n    });\n    return errors;\n}\nfunction findModesThatDoNotExist(tokenTypes, validModes) {\n    const invalidModes = (0,filter/* default */.A)(tokenTypes, (clazz) => {\n        return (clazz.PUSH_MODE !== undefined && !lodash_es_includes(validModes, clazz.PUSH_MODE));\n    });\n    const errors = (0,lodash_es_map/* default */.A)(invalidModes, (tokType) => {\n        const msg = `Token Type: ->${tokType.name}<- static \'PUSH_MODE\' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\n            `which does not exist`;\n        return {\n            message: msg,\n            type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\n            tokenTypes: [tokType],\n        };\n    });\n    return errors;\n}\nfunction findUnreachablePatterns(tokenTypes) {\n    const errors = [];\n    const canBeTested = (0,reduce/* default */.A)(tokenTypes, (result, tokType, idx) => {\n        const pattern = tokType.PATTERN;\n        if (pattern === Lexer.NA) {\n            return result;\n        }\n        // a more comprehensive validation for all forms of regExps would require\n        // deeper regExp analysis capabilities\n        if ((0,isString/* default */.A)(pattern)) {\n            result.push({ str: pattern, idx, tokenType: tokType });\n        }\n        else if (lodash_es_isRegExp(pattern) && noMetaChar(pattern)) {\n            result.push({ str: pattern.source, idx, tokenType: tokType });\n        }\n        return result;\n    }, []);\n    (0,forEach/* default */.A)(tokenTypes, (tokType, testIdx) => {\n        (0,forEach/* default */.A)(canBeTested, ({ str, idx, tokenType }) => {\n            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\n                const msg = `Token: ->${tokenType.name}<- can never be matched.\\n` +\n                    `Because it appears AFTER the Token Type ->${tokType.name}<-` +\n                    `in the lexer\'s definition.\\n` +\n                    `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\n                errors.push({\n                    message: msg,\n                    type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\n                    tokenTypes: [tokType, tokenType],\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction testTokenType(str, pattern) {\n    /* istanbul ignore else */\n    if (lodash_es_isRegExp(pattern)) {\n        const regExpArray = pattern.exec(str);\n        return regExpArray !== null && regExpArray.index === 0;\n    }\n    else if ((0,isFunction/* default */.A)(pattern)) {\n        // maintain the API of custom patterns\n        return pattern(str, 0, [], {});\n    }\n    else if ((0,has/* default */.A)(pattern, "exec")) {\n        // maintain the API of custom patterns\n        return pattern.exec(str, 0, [], {});\n    }\n    else if (typeof pattern === "string") {\n        return pattern === str;\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction noMetaChar(regExp) {\n    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n    const metaChars = [\n        ".",\n        "\\\\",\n        "[",\n        "]",\n        "|",\n        "^",\n        "$",\n        "(",\n        ")",\n        "?",\n        "*",\n        "+",\n        "{",\n    ];\n    return ((0,find/* default */.A)(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined);\n}\nfunction addStartOfInput(pattern) {\n    const flags = pattern.ignoreCase ? "i" : "";\n    // always wrapping in a none capturing group preceded by \'^\' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`^(?:${pattern.source})`, flags);\n}\nfunction addStickyFlag(pattern) {\n    const flags = pattern.ignoreCase ? "iy" : "y";\n    // always wrapping in a none capturing group preceded by \'^\' to make sure matching can only work on start of input.\n    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\n    return new RegExp(`${pattern.source}`, flags);\n}\nfunction performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const errors = [];\n    // some run time checks to help the end users.\n    if (!(0,has/* default */.A)(lexerDefinition, DEFAULT_MODE)) {\n        errors.push({\n            message: "A MultiMode Lexer cannot be initialized without a <" +\n                DEFAULT_MODE +\n                "> property in its definition\\n",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\n        });\n    }\n    if (!(0,has/* default */.A)(lexerDefinition, MODES)) {\n        errors.push({\n            message: "A MultiMode Lexer cannot be initialized without a <" +\n                MODES +\n                "> property in its definition\\n",\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\n        });\n    }\n    if ((0,has/* default */.A)(lexerDefinition, MODES) &&\n        (0,has/* default */.A)(lexerDefinition, DEFAULT_MODE) &&\n        !(0,has/* default */.A)(lexerDefinition.modes, lexerDefinition.defaultMode)) {\n        errors.push({\n            message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\n                `which does not exist\\n`,\n            type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\n        });\n    }\n    if ((0,has/* default */.A)(lexerDefinition, MODES)) {\n        (0,forEach/* default */.A)(lexerDefinition.modes, (currModeValue, currModeName) => {\n            (0,forEach/* default */.A)(currModeValue, (currTokType, currIdx) => {\n                if ((0,isUndefined/* default */.A)(currTokType)) {\n                    errors.push({\n                        message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\n                            `<${currModeName}> at index: <${currIdx}>\\n`,\n                        type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\n                    });\n                }\n                else if ((0,has/* default */.A)(currTokType, "LONGER_ALT")) {\n                    const longerAlt = (0,isArray/* default */.A)(currTokType.LONGER_ALT)\n                        ? currTokType.LONGER_ALT\n                        : [currTokType.LONGER_ALT];\n                    (0,forEach/* default */.A)(longerAlt, (currLongerAlt) => {\n                        if (!(0,isUndefined/* default */.A)(currLongerAlt) &&\n                            !lodash_es_includes(currModeValue, currLongerAlt)) {\n                            errors.push({\n                                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\n                                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\n                            });\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return errors;\n}\nfunction performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {\n    const warnings = [];\n    let hasAnyLineBreak = false;\n    const allTokenTypes = lodash_es_compact((0,lodash_es_flatten/* default */.A)((0,lodash_es_values/* default */.A)(lexerDefinition.modes)));\n    const concreteTokenTypes = lodash_es_reject(allTokenTypes, (currType) => currType[PATTERN] === Lexer.NA);\n    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\n    if (trackLines) {\n        (0,forEach/* default */.A)(concreteTokenTypes, (tokType) => {\n            const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\n            if (currIssue !== false) {\n                const message = buildLineBreakIssueMessage(tokType, currIssue);\n                const warningDescriptor = {\n                    message,\n                    type: currIssue.issue,\n                    tokenType: tokType,\n                };\n                warnings.push(warningDescriptor);\n            }\n            else {\n                // we don\'t want to attempt to scan if the user explicitly specified the line_breaks option.\n                if ((0,has/* default */.A)(tokType, "LINE_BREAKS")) {\n                    if (tokType.LINE_BREAKS === true) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n                else {\n                    if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {\n                        hasAnyLineBreak = true;\n                    }\n                }\n            }\n        });\n    }\n    if (trackLines && !hasAnyLineBreak) {\n        warnings.push({\n            message: "Warning: No LINE_BREAKS Found.\\n" +\n                "\\tThis Lexer has been defined to track line and column information,\\n" +\n                "\\tBut none of the Token Types can be identified as matching a line terminator.\\n" +\n                "\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n" +\n                "\\tfor details.",\n            type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\n        });\n    }\n    return warnings;\n}\nfunction cloneEmptyGroups(emptyGroups) {\n    const clonedResult = {};\n    const groupKeys = (0,keys/* default */.A)(emptyGroups);\n    (0,forEach/* default */.A)(groupKeys, (currKey) => {\n        const currGroupValue = emptyGroups[currKey];\n        /* istanbul ignore else */\n        if ((0,isArray/* default */.A)(currGroupValue)) {\n            clonedResult[currKey] = [];\n        }\n        else {\n            throw Error("non exhaustive match");\n        }\n    });\n    return clonedResult;\n}\n// TODO: refactor to avoid duplication\nfunction isCustomPattern(tokenType) {\n    const pattern = tokenType.PATTERN;\n    /* istanbul ignore else */\n    if (lodash_es_isRegExp(pattern)) {\n        return false;\n    }\n    else if ((0,isFunction/* default */.A)(pattern)) {\n        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\n        return true;\n    }\n    else if ((0,has/* default */.A)(pattern, "exec")) {\n        // ICustomPattern\n        return true;\n    }\n    else if ((0,isString/* default */.A)(pattern)) {\n        return false;\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction isShortPattern(pattern) {\n    if ((0,isString/* default */.A)(pattern) && pattern.length === 1) {\n        return pattern.charCodeAt(0);\n    }\n    else {\n        return false;\n    }\n}\n/**\n * Faster than using a RegExp for default newline detection during lexing.\n */\nconst LineTerminatorOptimizedTester = {\n    // implements /\\n|\\r\\n?/g.test\n    test: function (text) {\n        const len = text.length;\n        for (let i = this.lastIndex; i < len; i++) {\n            const c = text.charCodeAt(i);\n            if (c === 10) {\n                this.lastIndex = i + 1;\n                return true;\n            }\n            else if (c === 13) {\n                if (text.charCodeAt(i + 1) === 10) {\n                    this.lastIndex = i + 2;\n                }\n                else {\n                    this.lastIndex = i + 1;\n                }\n                return true;\n            }\n        }\n        return false;\n    },\n    lastIndex: 0,\n};\nfunction checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {\n    if ((0,has/* default */.A)(tokType, "LINE_BREAKS")) {\n        // if the user explicitly declared the line_breaks option we will respect their choice\n        // and assume it is correct.\n        return false;\n    }\n    else {\n        /* istanbul ignore else */\n        if (lodash_es_isRegExp(tokType.PATTERN)) {\n            try {\n                // TODO: why is the casting suddenly needed?\n                canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);\n            }\n            catch (e) {\n                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\n                return {\n                    issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\n                    errMsg: e.message,\n                };\n            }\n            return false;\n        }\n        else if ((0,isString/* default */.A)(tokType.PATTERN)) {\n            // string literal patterns can always be analyzed to detect line terminator usage\n            return false;\n        }\n        else if (isCustomPattern(tokType)) {\n            // custom token types\n            return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\n        }\n        else {\n            throw Error("non exhaustive match");\n        }\n    }\n}\nfunction buildLineBreakIssueMessage(tokType, details) {\n    /* istanbul ignore else */\n    if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\n        return ("Warning: unable to identify line terminator usage in pattern.\\n" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            `\\t Root cause: ${details.errMsg}.\\n` +\n            "\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR");\n    }\n    else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\n        return ("Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n" +\n            `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\n            "\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK");\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction getCharCodes(charsOrCodes) {\n    const charCodes = (0,lodash_es_map/* default */.A)(charsOrCodes, (numOrString) => {\n        if ((0,isString/* default */.A)(numOrString)) {\n            return numOrString.charCodeAt(0);\n        }\n        else {\n            return numOrString;\n        }\n    });\n    return charCodes;\n}\nfunction addToMapOfArrays(map, key, value) {\n    if (map[key] === undefined) {\n        map[key] = [value];\n    }\n    else {\n        map[key].push(value);\n    }\n}\nconst minOptimizationVal = 256;\n/**\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\n * This is because ASCI are the most common start chars so each one of those will get its own\n * possible token configs vector.\n *\n * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"\n * to place these into buckets of possible token configs, What we gain from\n * this is avoiding the case of creating an optimization \'charCodeToPatternIdxToConfig\'\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\n * Our \'charCodeToPatternIdxToConfig\' max size will now be:\n * 256 + (2^16 / 2^8) - 1 === 511\n *\n * note the hack for fast division integer part extraction\n * See: https://stackoverflow.com/a/4228528\n */\nlet charCodeToOptimizedIdxMap = [];\nfunction charCodeToOptimizedIndex(charCode) {\n    return charCode < minOptimizationVal\n        ? charCode\n        : charCodeToOptimizedIdxMap[charCode];\n}\n/**\n * This is a compromise between cold start / hot running performance\n * Creating this array takes ~3ms on a modern machine,\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\n * performance degrades by ~10%\n *\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\n */\nfunction initCharCodeToOptimizedIndexMap() {\n    if ((0,isEmpty/* default */.A)(charCodeToOptimizedIdxMap)) {\n        charCodeToOptimizedIdxMap = new Array(65536);\n        for (let i = 0; i < 65536; i++) {\n            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\n        }\n    }\n}\n//# sourceMappingURL=lexer.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/identity.js\nvar identity = __webpack_require__(29008);\n// EXTERNAL MODULE: ./node_modules/lodash-es/noop.js\nvar noop = __webpack_require__(42302);\n// EXTERNAL MODULE: ./node_modules/lodash-es/last.js\nvar last = __webpack_require__(26666);\n;// ./node_modules/@chevrotain/utils/lib/src/timer.js\nfunction timer(func) {\n    const start = new Date().getTime();\n    const val = func();\n    const end = new Date().getTime();\n    const total = end - start;\n    return { time: total, value: val };\n}\n//# sourceMappingURL=timer.js.map\n;// ./node_modules/chevrotain/lib/src/scan/tokens.js\n\nfunction tokenStructuredMatcher(tokInstance, tokConstructor) {\n    const instanceType = tokInstance.tokenTypeIdx;\n    if (instanceType === tokConstructor.tokenTypeIdx) {\n        return true;\n    }\n    else {\n        return (tokConstructor.isParent === true &&\n            tokConstructor.categoryMatchesMap[instanceType] === true);\n    }\n}\n// Optimized tokenMatcher in case our grammar does not use token categories\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\nfunction tokenStructuredMatcherNoCategories(token, tokType) {\n    return token.tokenTypeIdx === tokType.tokenTypeIdx;\n}\nlet tokenShortNameIdx = 1;\nconst tokenIdxToClass = {};\nfunction augmentTokenTypes(tokenTypes) {\n    // collect the parent Token Types as well.\n    const tokenTypesAndParents = expandCategories(tokenTypes);\n    // add required tokenType and categoryMatches properties\n    assignTokenDefaultProps(tokenTypesAndParents);\n    // fill up the categoryMatches\n    assignCategoriesMapProp(tokenTypesAndParents);\n    assignCategoriesTokensProp(tokenTypesAndParents);\n    (0,forEach/* default */.A)(tokenTypesAndParents, (tokType) => {\n        tokType.isParent = tokType.categoryMatches.length > 0;\n    });\n}\nfunction expandCategories(tokenTypes) {\n    let result = (0,clone/* default */.A)(tokenTypes);\n    let categories = tokenTypes;\n    let searching = true;\n    while (searching) {\n        categories = lodash_es_compact((0,lodash_es_flatten/* default */.A)((0,lodash_es_map/* default */.A)(categories, (currTokType) => currTokType.CATEGORIES)));\n        const newCategories = lodash_es_difference(categories, result);\n        result = result.concat(newCategories);\n        if ((0,isEmpty/* default */.A)(newCategories)) {\n            searching = false;\n        }\n        else {\n            categories = newCategories;\n        }\n    }\n    return result;\n}\nfunction assignTokenDefaultProps(tokenTypes) {\n    (0,forEach/* default */.A)(tokenTypes, (currTokType) => {\n        if (!hasShortKeyProperty(currTokType)) {\n            tokenIdxToClass[tokenShortNameIdx] = currTokType;\n            currTokType.tokenTypeIdx = tokenShortNameIdx++;\n        }\n        // CATEGORIES? : TokenType | TokenType[]\n        if (hasCategoriesProperty(currTokType) &&\n            !(0,isArray/* default */.A)(currTokType.CATEGORIES)\n        // &&\n        // !isUndefined(currTokType.CATEGORIES.PATTERN)\n        ) {\n            currTokType.CATEGORIES = [currTokType.CATEGORIES];\n        }\n        if (!hasCategoriesProperty(currTokType)) {\n            currTokType.CATEGORIES = [];\n        }\n        if (!hasExtendingTokensTypesProperty(currTokType)) {\n            currTokType.categoryMatches = [];\n        }\n        if (!hasExtendingTokensTypesMapProperty(currTokType)) {\n            currTokType.categoryMatchesMap = {};\n        }\n    });\n}\nfunction assignCategoriesTokensProp(tokenTypes) {\n    (0,forEach/* default */.A)(tokenTypes, (currTokType) => {\n        // avoid duplications\n        currTokType.categoryMatches = [];\n        (0,forEach/* default */.A)(currTokType.categoryMatchesMap, (val, key) => {\n            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);\n        });\n    });\n}\nfunction assignCategoriesMapProp(tokenTypes) {\n    (0,forEach/* default */.A)(tokenTypes, (currTokType) => {\n        singleAssignCategoriesToksMap([], currTokType);\n    });\n}\nfunction singleAssignCategoriesToksMap(path, nextNode) {\n    (0,forEach/* default */.A)(path, (pathNode) => {\n        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;\n    });\n    (0,forEach/* default */.A)(nextNode.CATEGORIES, (nextCategory) => {\n        const newPath = path.concat(nextNode);\n        // avoids infinite loops due to cyclic categories.\n        if (!lodash_es_includes(newPath, nextCategory)) {\n            singleAssignCategoriesToksMap(newPath, nextCategory);\n        }\n    });\n}\nfunction hasShortKeyProperty(tokType) {\n    return (0,has/* default */.A)(tokType, "tokenTypeIdx");\n}\nfunction hasCategoriesProperty(tokType) {\n    return (0,has/* default */.A)(tokType, "CATEGORIES");\n}\nfunction hasExtendingTokensTypesProperty(tokType) {\n    return (0,has/* default */.A)(tokType, "categoryMatches");\n}\nfunction hasExtendingTokensTypesMapProperty(tokType) {\n    return (0,has/* default */.A)(tokType, "categoryMatchesMap");\n}\nfunction isTokenType(tokType) {\n    return (0,has/* default */.A)(tokType, "tokenTypeIdx");\n}\n//# sourceMappingURL=tokens.js.map\n;// ./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js\nconst defaultLexerErrorProvider = {\n    buildUnableToPopLexerModeMessage(token) {\n        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\n    },\n    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {\n        return (`unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` + ` skipped ${length} characters.`);\n    },\n};\n//# sourceMappingURL=lexer_errors_public.js.map\n;// ./node_modules/chevrotain/lib/src/scan/lexer_public.js\n\n\n\n\n\n\nvar LexerDefinitionErrorType;\n(function (LexerDefinitionErrorType) {\n    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";\n    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";\n})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));\nconst DEFAULT_LEXER_CONFIG = {\n    deferDefinitionErrorsHandling: false,\n    positionTracking: "full",\n    lineTerminatorsPattern: /\\n|\\r\\n?/g,\n    lineTerminatorCharacters: ["\\n", "\\r"],\n    ensureOptimizations: false,\n    safeMode: false,\n    errorMessageProvider: defaultLexerErrorProvider,\n    traceInitPerf: false,\n    skipValidations: false,\n    recoveryEnabled: true,\n};\nObject.freeze(DEFAULT_LEXER_CONFIG);\nclass Lexer {\n    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {\n        this.lexerDefinition = lexerDefinition;\n        this.lexerDefinitionErrors = [];\n        this.lexerDefinitionWarning = [];\n        this.patternIdxToConfig = {};\n        this.charCodeToPatternIdxToConfig = {};\n        this.modes = [];\n        this.emptyGroups = {};\n        this.trackStartLines = true;\n        this.trackEndLines = true;\n        this.hasCustom = false;\n        this.canModeBeOptimized = {};\n        // Duplicated from the parser\'s perf trace trait to allow future extraction\n        // of the lexer to a separate package.\n        this.TRACE_INIT = (phaseDesc, phaseImpl) => {\n            // No need to optimize this using NOOP pattern because\n            // It is not called in a hot spot...\n            if (this.traceInitPerf === true) {\n                this.traceInitIndent++;\n                const indent = new Array(this.traceInitIndent + 1).join("\\t");\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    console.log(`${indent}--\x3e <${phaseDesc}>`);\n                }\n                const { time, value } = timer(phaseImpl);\n                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n                const traceMethod = time > 10 ? console.warn : console.log;\n                if (this.traceInitIndent < this.traceInitMaxIdent) {\n                    traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n                }\n                this.traceInitIndent--;\n                return value;\n            }\n            else {\n                return phaseImpl();\n            }\n        };\n        if (typeof config === "boolean") {\n            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\\n" +\n                "a boolean 2nd argument is no longer supported");\n        }\n        // todo: defaults func?\n        this.config = lodash_es_assign({}, DEFAULT_LEXER_CONFIG, config);\n        const traceInitVal = this.config.traceInitPerf;\n        if (traceInitVal === true) {\n            this.traceInitMaxIdent = Infinity;\n            this.traceInitPerf = true;\n        }\n        else if (typeof traceInitVal === "number") {\n            this.traceInitMaxIdent = traceInitVal;\n            this.traceInitPerf = true;\n        }\n        this.traceInitIndent = -1;\n        this.TRACE_INIT("Lexer Constructor", () => {\n            let actualDefinition;\n            let hasOnlySingleMode = true;\n            this.TRACE_INIT("Lexer Config handling", () => {\n                if (this.config.lineTerminatorsPattern ===\n                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {\n                    // optimized built-in implementation for the defaults definition of lineTerminators\n                    this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\n                }\n                else {\n                    if (this.config.lineTerminatorCharacters ===\n                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {\n                        throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n" +\n                            "\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");\n                    }\n                }\n                if (config.safeMode && config.ensureOptimizations) {\n                    throw Error(\'"safeMode" and "ensureOptimizations" flags are mutually exclusive.\');\n                }\n                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);\n                this.trackEndLines = /full/i.test(this.config.positionTracking);\n                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\n                if ((0,isArray/* default */.A)(lexerDefinition)) {\n                    actualDefinition = {\n                        modes: { defaultMode: (0,clone/* default */.A)(lexerDefinition) },\n                        defaultMode: DEFAULT_MODE,\n                    };\n                }\n                else {\n                    // no conversion needed, input should already be a IMultiModeLexerDefinition\n                    hasOnlySingleMode = false;\n                    actualDefinition = (0,clone/* default */.A)(lexerDefinition);\n                }\n            });\n            if (this.config.skipValidations === false) {\n                this.TRACE_INIT("performRuntimeChecks", () => {\n                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n                this.TRACE_INIT("performWarningRuntimeChecks", () => {\n                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));\n                });\n            }\n            // for extra robustness to avoid throwing an none informative error message\n            actualDefinition.modes = actualDefinition.modes\n                ? actualDefinition.modes\n                : {};\n            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.\n            // this transformation is to increase robustness in the case of partially invalid lexer definition.\n            (0,forEach/* default */.A)(actualDefinition.modes, (currModeValue, currModeName) => {\n                actualDefinition.modes[currModeName] = lodash_es_reject(currModeValue, (currTokType) => (0,isUndefined/* default */.A)(currTokType));\n            });\n            const allModeNames = (0,keys/* default */.A)(actualDefinition.modes);\n            (0,forEach/* default */.A)(actualDefinition.modes, (currModDef, currModName) => {\n                this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\n                    this.modes.push(currModName);\n                    if (this.config.skipValidations === false) {\n                        this.TRACE_INIT(`validatePatterns`, () => {\n                            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));\n                        });\n                    }\n                    // If definition errors were encountered, the analysis phase may fail unexpectedly/\n                    // Considering a lexer with definition errors may never be used, there is no point\n                    // to performing the analysis anyhow...\n                    if ((0,isEmpty/* default */.A)(this.lexerDefinitionErrors)) {\n                        augmentTokenTypes(currModDef);\n                        let currAnalyzeResult;\n                        this.TRACE_INIT(`analyzeTokenTypes`, () => {\n                            currAnalyzeResult = analyzeTokenTypes(currModDef, {\n                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,\n                                positionTracking: config.positionTracking,\n                                ensureOptimizations: config.ensureOptimizations,\n                                safeMode: config.safeMode,\n                                tracer: this.TRACE_INIT,\n                            });\n                        });\n                        this.patternIdxToConfig[currModName] =\n                            currAnalyzeResult.patternIdxToConfig;\n                        this.charCodeToPatternIdxToConfig[currModName] =\n                            currAnalyzeResult.charCodeToPatternIdxToConfig;\n                        this.emptyGroups = lodash_es_assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);\n                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\n                        this.canModeBeOptimized[currModName] =\n                            currAnalyzeResult.canBeOptimized;\n                    }\n                });\n            });\n            this.defaultMode = actualDefinition.defaultMode;\n            if (!(0,isEmpty/* default */.A)(this.lexerDefinitionErrors) &&\n                !this.config.deferDefinitionErrorsHandling) {\n                const allErrMessages = (0,lodash_es_map/* default */.A)(this.lexerDefinitionErrors, (error) => {\n                    return error.message;\n                });\n                const allErrMessagesString = allErrMessages.join("-----------------------\\n");\n                throw new Error("Errors detected in definition of Lexer:\\n" + allErrMessagesString);\n            }\n            // Only print warning if there are no errors, This will avoid pl\n            (0,forEach/* default */.A)(this.lexerDefinitionWarning, (warningDescriptor) => {\n                PRINT_WARNING(warningDescriptor.message);\n            });\n            this.TRACE_INIT("Choosing sub-methods implementations", () => {\n                // Choose the relevant internal implementations for this specific parser.\n                // These implementations should be in-lined by the JavaScript engine\n                // to provide optimal performance in each scenario.\n                if (SUPPORT_STICKY) {\n                    this.chopInput = identity/* default */.A;\n                    this.match = this.matchWithTest;\n                }\n                else {\n                    this.updateLastIndex = noop/* default */.A;\n                    this.match = this.matchWithExec;\n                }\n                if (hasOnlySingleMode) {\n                    this.handleModes = noop/* default */.A;\n                }\n                if (this.trackStartLines === false) {\n                    this.computeNewColumn = identity/* default */.A;\n                }\n                if (this.trackEndLines === false) {\n                    this.updateTokenEndLineColumnLocation = noop/* default */.A;\n                }\n                if (/full/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createFullToken;\n                }\n                else if (/onlyStart/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createStartOnlyToken;\n                }\n                else if (/onlyOffset/i.test(this.config.positionTracking)) {\n                    this.createTokenInstance = this.createOffsetOnlyToken;\n                }\n                else {\n                    throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);\n                }\n                if (this.hasCustom) {\n                    this.addToken = this.addTokenUsingPush;\n                    this.handlePayload = this.handlePayloadWithCustom;\n                }\n                else {\n                    this.addToken = this.addTokenUsingMemberAccess;\n                    this.handlePayload = this.handlePayloadNoCustom;\n                }\n            });\n            this.TRACE_INIT("Failed Optimization Warnings", () => {\n                const unOptimizedModes = (0,reduce/* default */.A)(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {\n                    if (canBeOptimized === false) {\n                        cannotBeOptimized.push(modeName);\n                    }\n                    return cannotBeOptimized;\n                }, []);\n                if (config.ensureOptimizations && !(0,isEmpty/* default */.A)(unOptimizedModes)) {\n                    throw Error(`Lexer Modes: < ${unOptimizedModes.join(", ")} > cannot be optimized.\\n` +\n                        \'\\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n\' +\n                        "\\t Or inspect the console log for details on how to resolve these issues.");\n                }\n            });\n            this.TRACE_INIT("clearRegExpParserCache", () => {\n                clearRegExpParserCache();\n            });\n            this.TRACE_INIT("toFastProperties", () => {\n                toFastProperties(this);\n            });\n        });\n    }\n    tokenize(text, initialMode = this.defaultMode) {\n        if (!(0,isEmpty/* default */.A)(this.lexerDefinitionErrors)) {\n            const allErrMessages = (0,lodash_es_map/* default */.A)(this.lexerDefinitionErrors, (error) => {\n                return error.message;\n            });\n            const allErrMessagesString = allErrMessages.join("-----------------------\\n");\n            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\\n" +\n                allErrMessagesString);\n        }\n        return this.tokenizeInternal(text, initialMode);\n    }\n    // There is quite a bit of duplication between this and "tokenizeInternalLazy"\n    // This is intentional due to performance considerations.\n    // this method also used quite a bit of `!` none null assertions because it is too optimized\n    // for `tsc` to always understand it is "safe"\n    tokenizeInternal(text, initialMode) {\n        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;\n        const orgText = text;\n        const orgLength = orgText.length;\n        let offset = 0;\n        let matchedTokensIndex = 0;\n        // initializing the tokensArray to the "guessed" size.\n        // guessing too little will still reduce the number of array re-sizes on pushes.\n        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\n        // but would still have a faster runtime by avoiding (All but one) array resizing.\n        const guessedNumberOfTokens = this.hasCustom\n            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\n            : Math.floor(text.length / 10);\n        const matchedTokens = new Array(guessedNumberOfTokens);\n        const errors = [];\n        let line = this.trackStartLines ? 1 : undefined;\n        let column = this.trackStartLines ? 1 : undefined;\n        const groups = cloneEmptyGroups(this.emptyGroups);\n        const trackLines = this.trackStartLines;\n        const lineTerminatorPattern = this.config.lineTerminatorsPattern;\n        let currModePatternsLength = 0;\n        let patternIdxToConfig = [];\n        let currCharCodeToPatternIdxToConfig = [];\n        const modeStack = [];\n        const emptyArray = [];\n        Object.freeze(emptyArray);\n        let getPossiblePatterns;\n        function getPossiblePatternsSlow() {\n            return patternIdxToConfig;\n        }\n        function getPossiblePatternsOptimized(charCode) {\n            const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\n            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];\n            if (possiblePatterns === undefined) {\n                return emptyArray;\n            }\n            else {\n                return possiblePatterns;\n            }\n        }\n        const pop_mode = (popToken) => {\n            // TODO: perhaps avoid this error in the edge case there is no more input?\n            if (modeStack.length === 1 &&\n                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"\n                // So no error should occur.\n                popToken.tokenType.PUSH_MODE === undefined) {\n                // if we try to pop the last mode there lexer will no longer have ANY mode.\n                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\n                const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);\n                errors.push({\n                    offset: popToken.startOffset,\n                    line: popToken.startLine,\n                    column: popToken.startColumn,\n                    length: popToken.image.length,\n                    message: msg,\n                });\n            }\n            else {\n                modeStack.pop();\n                const newMode = (0,last/* default */.A)(modeStack);\n                patternIdxToConfig = this.patternIdxToConfig[newMode];\n                currCharCodeToPatternIdxToConfig =\n                    this.charCodeToPatternIdxToConfig[newMode];\n                currModePatternsLength = patternIdxToConfig.length;\n                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                    getPossiblePatterns = getPossiblePatternsOptimized;\n                }\n                else {\n                    getPossiblePatterns = getPossiblePatternsSlow;\n                }\n            }\n        };\n        function push_mode(newMode) {\n            modeStack.push(newMode);\n            currCharCodeToPatternIdxToConfig =\n                this.charCodeToPatternIdxToConfig[newMode];\n            patternIdxToConfig = this.patternIdxToConfig[newMode];\n            currModePatternsLength = patternIdxToConfig.length;\n            currModePatternsLength = patternIdxToConfig.length;\n            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;\n            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\n                getPossiblePatterns = getPossiblePatternsOptimized;\n            }\n            else {\n                getPossiblePatterns = getPossiblePatternsSlow;\n            }\n        }\n        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\n        // seem to matter performance wise.\n        push_mode.call(this, initialMode);\n        let currConfig;\n        const recoveryEnabled = this.config.recoveryEnabled;\n        while (offset < orgLength) {\n            matchedImage = null;\n            const nextCharCode = orgText.charCodeAt(offset);\n            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\n            const chosenPatternsLength = chosenPatternIdxToConfig.length;\n            for (i = 0; i < chosenPatternsLength; i++) {\n                currConfig = chosenPatternIdxToConfig[i];\n                const currPattern = currConfig.pattern;\n                payload = null;\n                // manually in-lined because > 600 chars won\'t be in-lined in V8\n                const singleCharCode = currConfig.short;\n                if (singleCharCode !== false) {\n                    if (nextCharCode === singleCharCode) {\n                        // single character string\n                        matchedImage = currPattern;\n                    }\n                }\n                else if (currConfig.isCustom === true) {\n                    match = currPattern.exec(orgText, offset, matchedTokens, groups);\n                    if (match !== null) {\n                        matchedImage = match[0];\n                        if (match.payload !== undefined) {\n                            payload = match.payload;\n                        }\n                    }\n                    else {\n                        matchedImage = null;\n                    }\n                }\n                else {\n                    this.updateLastIndex(currPattern, offset);\n                    matchedImage = this.match(currPattern, text, offset);\n                }\n                if (matchedImage !== null) {\n                    // even though this pattern matched we must try a another longer alternative.\n                    // this can be used to prioritize keywords over identifiers\n                    longerAlt = currConfig.longerAlt;\n                    if (longerAlt !== undefined) {\n                        // TODO: micro optimize, avoid extra prop access\n                        // by saving/linking longerAlt on the original config?\n                        const longerAltLength = longerAlt.length;\n                        for (k = 0; k < longerAltLength; k++) {\n                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];\n                            const longerAltPattern = longerAltConfig.pattern;\n                            altPayload = null;\n                            // single Char can never be a longer alt so no need to test it.\n                            // manually in-lined because > 600 chars won\'t be in-lined in V8\n                            if (longerAltConfig.isCustom === true) {\n                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);\n                                if (match !== null) {\n                                    matchAltImage = match[0];\n                                    if (match.payload !== undefined) {\n                                        altPayload = match.payload;\n                                    }\n                                }\n                                else {\n                                    matchAltImage = null;\n                                }\n                            }\n                            else {\n                                this.updateLastIndex(longerAltPattern, offset);\n                                matchAltImage = this.match(longerAltPattern, text, offset);\n                            }\n                            if (matchAltImage && matchAltImage.length > matchedImage.length) {\n                                matchedImage = matchAltImage;\n                                payload = altPayload;\n                                currConfig = longerAltConfig;\n                                // Exit the loop early after matching one of the longer alternatives\n                                // The first matched alternative takes precedence\n                                break;\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            // successful match\n            if (matchedImage !== null) {\n                imageLength = matchedImage.length;\n                group = currConfig.group;\n                if (group !== undefined) {\n                    tokType = currConfig.tokenTypeIdx;\n                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside\n                    // createFullToken method\n                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);\n                    this.handlePayload(newToken, payload);\n                    // TODO: optimize NOOP in case there are no special groups?\n                    if (group === false) {\n                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);\n                    }\n                    else {\n                        groups[group].push(newToken);\n                    }\n                }\n                text = this.chopInput(text, imageLength);\n                offset = offset + imageLength;\n                // TODO: with newlines the column may be assigned twice\n                column = this.computeNewColumn(column, imageLength);\n                if (trackLines === true && currConfig.canLineTerminator === true) {\n                    let numOfLTsInMatch = 0;\n                    let foundTerminator;\n                    let lastLTEndOffset;\n                    lineTerminatorPattern.lastIndex = 0;\n                    do {\n                        foundTerminator = lineTerminatorPattern.test(matchedImage);\n                        if (foundTerminator === true) {\n                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\n                            numOfLTsInMatch++;\n                        }\n                    } while (foundTerminator === true);\n                    if (numOfLTsInMatch !== 0) {\n                        line = line + numOfLTsInMatch;\n                        column = imageLength - lastLTEndOffset;\n                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);\n                    }\n                }\n                // will be NOOP if no modes present\n                this.handleModes(currConfig, pop_mode, push_mode, newToken);\n            }\n            else {\n                // error recovery, drop characters until we identify a valid token\'s start point\n                const errorStartOffset = offset;\n                const errorLine = line;\n                const errorColumn = column;\n                let foundResyncPoint = recoveryEnabled === false;\n                while (foundResyncPoint === false && offset < orgLength) {\n                    // Identity Func (when sticky flag is enabled)\n                    text = this.chopInput(text, 1);\n                    offset++;\n                    for (j = 0; j < currModePatternsLength; j++) {\n                        const currConfig = patternIdxToConfig[j];\n                        const currPattern = currConfig.pattern;\n                        // manually in-lined because > 600 chars won\'t be in-lined in V8\n                        const singleCharCode = currConfig.short;\n                        if (singleCharCode !== false) {\n                            if (orgText.charCodeAt(offset) === singleCharCode) {\n                                // single character string\n                                foundResyncPoint = true;\n                            }\n                        }\n                        else if (currConfig.isCustom === true) {\n                            foundResyncPoint =\n                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;\n                        }\n                        else {\n                            this.updateLastIndex(currPattern, offset);\n                            foundResyncPoint = currPattern.exec(text) !== null;\n                        }\n                        if (foundResyncPoint === true) {\n                            break;\n                        }\n                    }\n                }\n                errLength = offset - errorStartOffset;\n                column = this.computeNewColumn(column, errLength);\n                // at this point we either re-synced or reached the end of the input text\n                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);\n                errors.push({\n                    offset: errorStartOffset,\n                    line: errorLine,\n                    column: errorColumn,\n                    length: errLength,\n                    message: msg,\n                });\n                if (recoveryEnabled === false) {\n                    break;\n                }\n            }\n        }\n        // if we do have custom patterns which push directly into the\n        // TODO: custom tokens should not push directly??\n        if (!this.hasCustom) {\n            // if we guessed a too large size for the tokens array this will shrink it to the right size.\n            matchedTokens.length = matchedTokensIndex;\n        }\n        return {\n            tokens: matchedTokens,\n            groups: groups,\n            errors: errors,\n        };\n    }\n    handleModes(config, pop_mode, push_mode, newToken) {\n        if (config.pop === true) {\n            // need to save the PUSH_MODE property as if the mode is popped\n            // patternIdxToPopMode is updated to reflect the new mode after popping the stack\n            const pushMode = config.push;\n            pop_mode(newToken);\n            if (pushMode !== undefined) {\n                push_mode.call(this, pushMode);\n            }\n        }\n        else if (config.push !== undefined) {\n            push_mode.call(this, config.push);\n        }\n    }\n    chopInput(text, length) {\n        return text.substring(length);\n    }\n    updateLastIndex(regExp, newLastIndex) {\n        regExp.lastIndex = newLastIndex;\n    }\n    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\n    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {\n        let lastCharIsLT, fixForEndingInLT;\n        if (group !== undefined) {\n            // a none skipped multi line Token, need to update endLine/endColumn\n            lastCharIsLT = lastLTIdx === imageLength - 1;\n            fixForEndingInLT = lastCharIsLT ? -1 : 0;\n            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\n                // if a token ends in a LT that last LT only affects the line numbering of following Tokens\n                newToken.endLine = line + fixForEndingInLT;\n                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\n                // inclusive to exclusive range.\n                newToken.endColumn = column - 1 + -fixForEndingInLT;\n            }\n            // else single LT in the last character of a token, no need to modify the endLine/EndColumn\n        }\n    }\n    computeNewColumn(oldColumn, imageLength) {\n        return oldColumn + imageLength;\n    }\n    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {\n        return {\n            image,\n            startOffset,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {\n        return {\n            image,\n            startOffset,\n            startLine,\n            startColumn,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {\n        return {\n            image,\n            startOffset,\n            endOffset: startOffset + imageLength - 1,\n            startLine,\n            endLine: startLine,\n            startColumn,\n            endColumn: startColumn + imageLength - 1,\n            tokenTypeIdx,\n            tokenType,\n        };\n    }\n    addTokenUsingPush(tokenVector, index, tokenToAdd) {\n        tokenVector.push(tokenToAdd);\n        return index;\n    }\n    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {\n        tokenVector[index] = tokenToAdd;\n        index++;\n        return index;\n    }\n    handlePayloadNoCustom(token, payload) { }\n    handlePayloadWithCustom(token, payload) {\n        if (payload !== null) {\n            token.payload = payload;\n        }\n    }\n    matchWithTest(pattern, text, offset) {\n        const found = pattern.test(text);\n        if (found === true) {\n            return text.substring(offset, pattern.lastIndex);\n        }\n        return null;\n    }\n    matchWithExec(pattern, text) {\n        const regExpArray = pattern.exec(text);\n        return regExpArray !== null ? regExpArray[0] : null;\n    }\n}\nLexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" +\n    "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";\nLexer.NA = /NOT_APPLICABLE/;\n//# sourceMappingURL=lexer_public.js.map\n;// ./node_modules/chevrotain/lib/src/scan/tokens_public.js\n\n\n\nfunction tokens_public_tokenLabel(tokType) {\n    if (tokens_public_hasTokenLabel(tokType)) {\n        return tokType.LABEL;\n    }\n    else {\n        return tokType.name;\n    }\n}\nfunction tokenName(tokType) {\n    return tokType.name;\n}\nfunction tokens_public_hasTokenLabel(obj) {\n    return (0,isString/* default */.A)(obj.LABEL) && obj.LABEL !== "";\n}\nconst PARENT = "parent";\nconst CATEGORIES = "categories";\nconst LABEL = "label";\nconst GROUP = "group";\nconst PUSH_MODE = "push_mode";\nconst POP_MODE = "pop_mode";\nconst LONGER_ALT = "longer_alt";\nconst LINE_BREAKS = "line_breaks";\nconst START_CHARS_HINT = "start_chars_hint";\nfunction createToken(config) {\n    return createTokenInternal(config);\n}\nfunction createTokenInternal(config) {\n    const pattern = config.pattern;\n    const tokenType = {};\n    tokenType.name = config.name;\n    if (!(0,isUndefined/* default */.A)(pattern)) {\n        tokenType.PATTERN = pattern;\n    }\n    if ((0,has/* default */.A)(config, PARENT)) {\n        throw ("The parent property is no longer supported.\\n" +\n            "See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.");\n    }\n    if ((0,has/* default */.A)(config, CATEGORIES)) {\n        // casting to ANY as this will be fixed inside `augmentTokenTypes``\n        tokenType.CATEGORIES = config[CATEGORIES];\n    }\n    augmentTokenTypes([tokenType]);\n    if ((0,has/* default */.A)(config, LABEL)) {\n        tokenType.LABEL = config[LABEL];\n    }\n    if ((0,has/* default */.A)(config, GROUP)) {\n        tokenType.GROUP = config[GROUP];\n    }\n    if ((0,has/* default */.A)(config, POP_MODE)) {\n        tokenType.POP_MODE = config[POP_MODE];\n    }\n    if ((0,has/* default */.A)(config, PUSH_MODE)) {\n        tokenType.PUSH_MODE = config[PUSH_MODE];\n    }\n    if ((0,has/* default */.A)(config, LONGER_ALT)) {\n        tokenType.LONGER_ALT = config[LONGER_ALT];\n    }\n    if ((0,has/* default */.A)(config, LINE_BREAKS)) {\n        tokenType.LINE_BREAKS = config[LINE_BREAKS];\n    }\n    if ((0,has/* default */.A)(config, START_CHARS_HINT)) {\n        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\n    }\n    return tokenType;\n}\nconst EOF = createToken({ name: "EOF", pattern: Lexer.NA });\naugmentTokenTypes([EOF]);\nfunction createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {\n    return {\n        image,\n        startOffset,\n        endOffset,\n        startLine,\n        endLine,\n        startColumn,\n        endColumn,\n        tokenTypeIdx: tokType.tokenTypeIdx,\n        tokenType: tokType,\n    };\n}\nfunction tokenMatcher(token, tokType) {\n    return tokenStructuredMatcher(token, tokType);\n}\n//# sourceMappingURL=tokens_public.js.map\n;// ./node_modules/chevrotain/lib/src/parse/errors_public.js\n\n\n\nconst defaultParserErrorProvider = {\n    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {\n        const hasLabel = tokens_public_hasTokenLabel(expected);\n        const expectedMsg = hasLabel\n            ? `--\x3e ${tokens_public_tokenLabel(expected)} <--`\n            : `token of type --\x3e ${expected.name} <--`;\n        const msg = `Expecting ${expectedMsg} but found --\x3e \'${actual.image}\' <--`;\n        return msg;\n    },\n    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {\n        return "Redundant input, expecting EOF but found: " + firstRedundant.image;\n    },\n    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {\n        const errPrefix = "Expecting: ";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = lodash_es_head(actual).image;\n        const errSuffix = "\\nbut found: \'" + actualText + "\'";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const allLookAheadPaths = (0,reduce/* default */.A)(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);\n            const nextValidTokenSequences = (0,lodash_es_map/* default */.A)(allLookAheadPaths, (currPath) => `[${(0,lodash_es_map/* default */.A)(currPath, (currTokenType) => tokens_public_tokenLabel(currTokenType)).join(", ")}]`);\n            const nextValidSequenceItems = (0,lodash_es_map/* default */.A)(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);\n            const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join("\\n")}`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {\n        const errPrefix = "Expecting: ";\n        // TODO: issue: No Viable Alternative Error may have incomplete details. #502\n        const actualText = lodash_es_head(actual).image;\n        const errSuffix = "\\nbut found: \'" + actualText + "\'";\n        if (customUserDescription) {\n            return errPrefix + customUserDescription + errSuffix;\n        }\n        else {\n            const nextValidTokenSequences = (0,lodash_es_map/* default */.A)(expectedIterationPaths, (currPath) => `[${(0,lodash_es_map/* default */.A)(currPath, (currTokenType) => tokens_public_tokenLabel(currTokenType)).join(",")}]`);\n            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\n                `<${nextValidTokenSequences.join(" ,")}>`;\n            return errPrefix + calculatedDescription + errSuffix;\n        }\n    },\n};\nObject.freeze(defaultParserErrorProvider);\nconst defaultGrammarResolverErrorProvider = {\n    buildRuleNotFoundError(topLevelRule, undefinedRule) {\n        const msg = "Invalid grammar, reference to a rule which is not defined: ->" +\n            undefinedRule.nonTerminalName +\n            "<-\\n" +\n            "inside top level rule: ->" +\n            topLevelRule.name +\n            "<-";\n        return msg;\n    },\n};\nconst defaultGrammarValidatorErrorProvider = {\n    buildDuplicateFoundError(topLevelRule, duplicateProds) {\n        function getExtraProductionArgument(prod) {\n            if (prod instanceof Terminal) {\n                return prod.terminalType.name;\n            }\n            else if (prod instanceof model_NonTerminal) {\n                return prod.nonTerminalName;\n            }\n            else {\n                return "";\n            }\n        }\n        const topLevelName = topLevelRule.name;\n        const duplicateProd = lodash_es_head(duplicateProds);\n        const index = duplicateProd.idx;\n        const dslName = getProductionDslName(duplicateProd);\n        const extraArgument = getExtraProductionArgument(duplicateProd);\n        const hasExplicitIndex = index > 0;\n        let msg = `->${dslName}${hasExplicitIndex ? index : ""}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : ""}\n                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  `;\n        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\n        msg = msg.replace(/[ \\t]+/g, " ");\n        msg = msg.replace(/\\s\\s+/g, "\\n");\n        return msg;\n    },\n    buildNamespaceConflictError(rule) {\n        const errMsg = `Namespace conflict found in grammar.\\n` +\n            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\n            `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\n            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\n            `and Non-Terminal names start with a lower case letter.`;\n        return errMsg;\n    },\n    buildAlternationPrefixAmbiguityError(options) {\n        const pathMsg = (0,lodash_es_map/* default */.A)(options.prefixPath, (currTok) => tokens_public_tokenLabel(currTok)).join(", ");\n        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;\n        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(" ,")}> due to common lookahead prefix\\n` +\n            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\n            `For Further details.`;\n        return errMsg;\n    },\n    buildAlternationAmbiguityError(options) {\n        const pathMsg = (0,lodash_es_map/* default */.A)(options.prefixPath, (currtok) => tokens_public_tokenLabel(currtok)).join(", ");\n        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;\n        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(" ,")}> in <OR${occurrence}>` +\n            ` inside <${options.topLevelRule.name}> Rule,\\n` +\n            `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n        currMessage =\n            currMessage +\n                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n                `For Further details.`;\n        return currMessage;\n    },\n    buildEmptyRepetitionError(options) {\n        let dslName = getProductionDslName(options.repetition);\n        if (options.repetition.idx !== 0) {\n            dslName += options.repetition.idx;\n        }\n        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\n            `This could lead to an infinite loop.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildTokenNameError(options) {\n        /* istanbul ignore next */\n        return "deprecated";\n    },\n    buildEmptyAlternationError(options) {\n        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\n            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\n            `Only the last alternative may be an empty alternative.`;\n        return errMsg;\n    },\n    buildTooManyAlternativesError(options) {\n        const errMsg = `An Alternation cannot have more than 256 alternatives:\\n` +\n            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n has ${options.alternation.definition.length + 1} alternatives.`;\n        return errMsg;\n    },\n    buildLeftRecursionError(options) {\n        const ruleName = options.topLevelRule.name;\n        const pathNames = (0,lodash_es_map/* default */.A)(options.leftRecursionPath, (currRule) => currRule.name);\n        const leftRecursivePath = `${ruleName} --\x3e ${pathNames\n            .concat([ruleName])\n            .join(" --\x3e ")}`;\n        const errMsg = `Left Recursion found in grammar.\\n` +\n            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\n            `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\n            ` To fix this refactor your grammar to remove the left recursion.\\n` +\n            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\n        return errMsg;\n    },\n    // TODO: remove - `errors_public` from nyc.config.js exclude\n    //       once this method is fully removed from this file\n    buildInvalidRuleNameError(options) {\n        /* istanbul ignore next */\n        return "deprecated";\n    },\n    buildDuplicateRuleNameError(options) {\n        let ruleName;\n        if (options.topLevelRule instanceof Rule) {\n            ruleName = options.topLevelRule.name;\n        }\n        else {\n            ruleName = options.topLevelRule;\n        }\n        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\n        return errMsg;\n    },\n};\n//# sourceMappingURL=errors_public.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/resolver.js\n\n\n\nfunction resolveGrammar(topLevels, errMsgProvider) {\n    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\n    refResolver.resolveRefs();\n    return refResolver.errors;\n}\nclass GastRefResolverVisitor extends visitor_GAstVisitor {\n    constructor(nameToTopRule, errMsgProvider) {\n        super();\n        this.nameToTopRule = nameToTopRule;\n        this.errMsgProvider = errMsgProvider;\n        this.errors = [];\n    }\n    resolveRefs() {\n        (0,forEach/* default */.A)((0,lodash_es_values/* default */.A)(this.nameToTopRule), (prod) => {\n            this.currTopLevel = prod;\n            prod.accept(this);\n        });\n    }\n    visitNonTerminal(node) {\n        const ref = this.nameToTopRule[node.nonTerminalName];\n        if (!ref) {\n            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);\n            this.errors.push({\n                message: msg,\n                type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\n                ruleName: this.currTopLevel.name,\n                unresolvedRefName: node.nonTerminalName,\n            });\n        }\n        else {\n            node.referencedRule = ref;\n        }\n    }\n}\n//# sourceMappingURL=resolver.js.map\n;// ./node_modules/lodash-es/flatMap.js\n\n\n\n/**\n * Creates a flattened array of values by running each element in `collection`\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n * with three arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * function duplicate(n) {\n *   return [n, n];\n * }\n *\n * _.flatMap([1, 2], duplicate);\n * // => [1, 1, 2, 2]\n */\nfunction flatMap(collection, iteratee) {\n  return (0,_baseFlatten/* default */.A)((0,lodash_es_map/* default */.A)(collection, iteratee), 1);\n}\n\n/* harmony default export */ const lodash_es_flatMap = (flatMap);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseAssignValue.js\nvar _baseAssignValue = __webpack_require__(52528);\n;// ./node_modules/lodash-es/_arrayAggregator.js\n/**\n * A specialized version of `baseAggregator` for arrays.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    var value = array[index];\n    setter(accumulator, value, iteratee(value), array);\n  }\n  return accumulator;\n}\n\n/* harmony default export */ const _arrayAggregator = (arrayAggregator);\n\n;// ./node_modules/lodash-es/_baseAggregator.js\n\n\n/**\n * Aggregates elements of `collection` on `accumulator` with keys transformed\n * by `iteratee` and values set by `setter`.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} setter The function to set `accumulator` values.\n * @param {Function} iteratee The iteratee to transform keys.\n * @param {Object} accumulator The initial aggregated object.\n * @returns {Function} Returns `accumulator`.\n */\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\n  (0,_baseEach/* default */.A)(collection, function(value, key, collection) {\n    setter(accumulator, value, iteratee(value), collection);\n  });\n  return accumulator;\n}\n\n/* harmony default export */ const _baseAggregator = (baseAggregator);\n\n;// ./node_modules/lodash-es/_createAggregator.js\n\n\n\n\n\n/**\n * Creates a function like `_.groupBy`.\n *\n * @private\n * @param {Function} setter The function to set accumulator values.\n * @param {Function} [initializer] The accumulator object initializer.\n * @returns {Function} Returns the new aggregator function.\n */\nfunction createAggregator(setter, initializer) {\n  return function(collection, iteratee) {\n    var func = (0,isArray/* default */.A)(collection) ? _arrayAggregator : _baseAggregator,\n        accumulator = initializer ? initializer() : {};\n\n    return func(collection, setter, (0,_baseIteratee/* default */.A)(iteratee, 2), accumulator);\n  };\n}\n\n/* harmony default export */ const _createAggregator = (createAggregator);\n\n;// ./node_modules/lodash-es/groupBy.js\n\n\n\n/** Used for built-in method references. */\nvar groupBy_objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar groupBy_hasOwnProperty = groupBy_objectProto.hasOwnProperty;\n\n/**\n * Creates an object composed of keys generated from the results of running\n * each element of `collection` thru `iteratee`. The order of grouped values\n * is determined by the order they occur in `collection`. The corresponding\n * value of each key is an array of elements responsible for generating the\n * key. The iteratee is invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n * @returns {Object} Returns the composed aggregate object.\n * @example\n *\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n * // => { \'4\': [4.2], \'6\': [6.1, 6.3] }\n *\n * // The `_.property` iteratee shorthand.\n * _.groupBy([\'one\', \'two\', \'three\'], \'length\');\n * // => { \'3\': [\'one\', \'two\'], \'5\': [\'three\'] }\n */\nvar groupBy_groupBy = _createAggregator(function(result, value, key) {\n  if (groupBy_hasOwnProperty.call(result, key)) {\n    result[key].push(value);\n  } else {\n    (0,_baseAssignValue/* default */.A)(result, key, [value]);\n  }\n});\n\n/* harmony default export */ const lodash_es_groupBy = (groupBy_groupBy);\n\n;// ./node_modules/lodash-es/dropRight.js\n\n\n\n/**\n * Creates a slice of `array` with `n` elements dropped from the end.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Array\n * @param {Array} array The array to query.\n * @param {number} [n=1] The number of elements to drop.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {Array} Returns the slice of `array`.\n * @example\n *\n * _.dropRight([1, 2, 3]);\n * // => [1, 2]\n *\n * _.dropRight([1, 2, 3], 2);\n * // => [1]\n *\n * _.dropRight([1, 2, 3], 5);\n * // => []\n *\n * _.dropRight([1, 2, 3], 0);\n * // => [1, 2, 3]\n */\nfunction dropRight(array, n, guard) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  n = (guard || n === undefined) ? 1 : (0,toInteger/* default */.A)(n);\n  n = length - n;\n  return _baseSlice(array, 0, n < 0 ? 0 : n);\n}\n\n/* harmony default export */ const lodash_es_dropRight = (dropRight);\n\n;// ./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js\n\n\n\n\nclass AbstractNextPossibleTokensWalker extends RestWalker {\n    constructor(topProd, path) {\n        super();\n        this.topProd = topProd;\n        this.path = path;\n        this.possibleTokTypes = [];\n        this.nextProductionName = "";\n        this.nextProductionOccurrence = 0;\n        this.found = false;\n        this.isAtEndOfPath = false;\n    }\n    startWalking() {\n        this.found = false;\n        if (this.path.ruleStack[0] !== this.topProd.name) {\n            throw Error("The path does not start with the walker\'s top Rule!");\n        }\n        // immutable for the win\n        this.ruleStack = (0,clone/* default */.A)(this.path.ruleStack).reverse(); // intelij bug requires assertion\n        this.occurrenceStack = (0,clone/* default */.A)(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\n        // already verified that the first production is valid, we now seek the 2nd production\n        this.ruleStack.pop();\n        this.occurrenceStack.pop();\n        this.updateExpectedNext();\n        this.walk(this.topProd);\n        return this.possibleTokTypes;\n    }\n    walk(prod, prevRest = []) {\n        // stop scanning once we found the path\n        if (!this.found) {\n            super.walk(prod, prevRest);\n        }\n    }\n    walkProdRef(refProd, currRest, prevRest) {\n        // found the next production, need to keep walking in it\n        if (refProd.referencedRule.name === this.nextProductionName &&\n            refProd.idx === this.nextProductionOccurrence) {\n            const fullRest = currRest.concat(prevRest);\n            this.updateExpectedNext();\n            this.walk(refProd.referencedRule, fullRest);\n        }\n    }\n    updateExpectedNext() {\n        // need to consume the Terminal\n        if ((0,isEmpty/* default */.A)(this.ruleStack)) {\n            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\n            // really seeking is the last Terminal...\n            this.nextProductionName = "";\n            this.nextProductionOccurrence = 0;\n            this.isAtEndOfPath = true;\n        }\n        else {\n            this.nextProductionName = this.ruleStack.pop();\n            this.nextProductionOccurrence = this.occurrenceStack.pop();\n        }\n    }\n}\nclass NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\n    constructor(topProd, path) {\n        super(topProd, path);\n        this.path = path;\n        this.nextTerminalName = "";\n        this.nextTerminalOccurrence = 0;\n        this.nextTerminalName = this.path.lastTok.name;\n        this.nextTerminalOccurrence = this.path.lastTokOccurrence;\n    }\n    walkTerminal(terminal, currRest, prevRest) {\n        if (this.isAtEndOfPath &&\n            terminal.terminalType.name === this.nextTerminalName &&\n            terminal.idx === this.nextTerminalOccurrence &&\n            !this.found) {\n            const fullRest = currRest.concat(prevRest);\n            const restProd = new Alternative({ definition: fullRest });\n            this.possibleTokTypes = first(restProd);\n            this.found = true;\n        }\n    }\n}\n/**\n * This walker only "walks" a single "TOP" level in the Grammar Ast, this means\n * it never "follows" production refs\n */\nclass AbstractNextTerminalAfterProductionWalker extends RestWalker {\n    constructor(topRule, occurrence) {\n        super();\n        this.topRule = topRule;\n        this.occurrence = occurrence;\n        this.result = {\n            token: undefined,\n            occurrence: undefined,\n            isEndOfRule: undefined,\n        };\n    }\n    startWalking() {\n        this.walk(this.topRule);\n        return this.result;\n    }\n}\nclass NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkMany(manyProd, currRest, prevRest) {\n        if (manyProd.idx === this.occurrence) {\n            const firstAfterMany = lodash_es_head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterMany === undefined;\n            if (firstAfterMany instanceof Terminal) {\n                this.result.token = firstAfterMany.terminalType;\n                this.result.occurrence = firstAfterMany.idx;\n            }\n        }\n        else {\n            super.walkMany(manyProd, currRest, prevRest);\n        }\n    }\n}\nclass NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (manySepProd.idx === this.occurrence) {\n            const firstAfterManySep = lodash_es_head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterManySep === undefined;\n            if (firstAfterManySep instanceof Terminal) {\n                this.result.token = firstAfterManySep.terminalType;\n                this.result.occurrence = firstAfterManySep.idx;\n            }\n        }\n        else {\n            super.walkManySep(manySepProd, currRest, prevRest);\n        }\n    }\n}\nclass NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (atLeastOneProd.idx === this.occurrence) {\n            const firstAfterAtLeastOne = lodash_es_head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\n            if (firstAfterAtLeastOne instanceof Terminal) {\n                this.result.token = firstAfterAtLeastOne.terminalType;\n                this.result.occurrence = firstAfterAtLeastOne.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\n        }\n    }\n}\n// TODO: reduce code duplication in the AfterWalkers\nclass NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\n    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {\n        if (atleastOneSepProd.idx === this.occurrence) {\n            const firstAfterfirstAfterAtLeastOneSep = lodash_es_head(currRest.concat(prevRest));\n            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\n            if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\n                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\n                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\n            }\n        }\n        else {\n            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\n        }\n    }\n}\nfunction possiblePathsFrom(targetDef, maxLength, currPath = []) {\n    // avoid side effects\n    currPath = (0,clone/* default */.A)(currPath);\n    let result = [];\n    let i = 0;\n    // TODO: avoid inner funcs\n    function remainingPathWith(nextDef) {\n        return nextDef.concat(lodash_es_drop(targetDef, i + 1));\n    }\n    // TODO: avoid inner funcs\n    function getAlternativesForProd(definition) {\n        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);\n        return result.concat(alternatives);\n    }\n    /**\n     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\n     * following (rest) of the targetDef.\n     *\n     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\n     * the optional production.\n     */\n    while (currPath.length < maxLength && i < targetDef.length) {\n        const prod = targetDef[i];\n        /* istanbul ignore else */\n        if (prod instanceof Alternative) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof model_NonTerminal) {\n            return getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof Option) {\n            result = getAlternativesForProd(prod.definition);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            const newDef = [\n                new Alternative({ definition: prod.definition }),\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ];\n            return getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Repetition) {\n            const newDef = prod.definition.concat([\n                new Repetition({\n                    definition: prod.definition,\n                }),\n            ]);\n            result = getAlternativesForProd(newDef);\n        }\n        else if (prod instanceof Alternation) {\n            (0,forEach/* default */.A)(prod.definition, (currAlt) => {\n                // TODO: this is a limited check for empty alternatives\n                //   It would prevent a common case of infinite loops during parser initialization.\n                //   However **in-directly** empty alternatives may still cause issues.\n                if ((0,isEmpty/* default */.A)(currAlt.definition) === false) {\n                    result = getAlternativesForProd(currAlt.definition);\n                }\n            });\n            return result;\n        }\n        else if (prod instanceof Terminal) {\n            currPath.push(prod.terminalType);\n        }\n        else {\n            throw Error("non exhaustive match");\n        }\n        i++;\n    }\n    result.push({\n        partialPath: currPath,\n        suffixDef: lodash_es_drop(targetDef, i),\n    });\n    return result;\n}\nfunction nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {\n    const EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";\n    // to avoid creating a new Array each time.\n    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\n    const EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";\n    let foundCompletePath = false;\n    const tokenVectorLength = tokenVector.length;\n    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\n    const result = [];\n    const possiblePaths = [];\n    possiblePaths.push({\n        idx: -1,\n        def: initialDef,\n        ruleStack: [],\n        occurrenceStack: [],\n    });\n    while (!(0,isEmpty/* default */.A)(possiblePaths)) {\n        const currPath = possiblePaths.pop();\n        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\n        if (currPath === EXIT_ALTERNATIVE) {\n            if (foundCompletePath &&\n                (0,last/* default */.A)(possiblePaths).idx <= minimalAlternativesIndex) {\n                // remove irrelevant alternative\n                possiblePaths.pop();\n            }\n            continue;\n        }\n        const currDef = currPath.def;\n        const currIdx = currPath.idx;\n        const currRuleStack = currPath.ruleStack;\n        const currOccurrenceStack = currPath.occurrenceStack;\n        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\n        if ((0,isEmpty/* default */.A)(currDef)) {\n            continue;\n        }\n        const prod = currDef[0];\n        /* istanbul ignore else */\n        if (prod === EXIT_NON_TERMINAL) {\n            const nextPath = {\n                idx: currIdx,\n                def: lodash_es_drop(currDef),\n                ruleStack: lodash_es_dropRight(currRuleStack),\n                occurrenceStack: lodash_es_dropRight(currOccurrenceStack),\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Terminal) {\n            /* istanbul ignore else */\n            if (currIdx < tokenVectorLength - 1) {\n                const nextIdx = currIdx + 1;\n                const actualToken = tokenVector[nextIdx];\n                if (tokMatcher(actualToken, prod.terminalType)) {\n                    const nextPath = {\n                        idx: nextIdx,\n                        def: lodash_es_drop(currDef),\n                        ruleStack: currRuleStack,\n                        occurrenceStack: currOccurrenceStack,\n                    };\n                    possiblePaths.push(nextPath);\n                }\n                // end of the line\n            }\n            else if (currIdx === tokenVectorLength - 1) {\n                // IGNORE ABOVE ELSE\n                result.push({\n                    nextTokenType: prod.terminalType,\n                    nextTokenOccurrence: prod.idx,\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                });\n                foundCompletePath = true;\n            }\n            else {\n                throw Error("non exhaustive match");\n            }\n        }\n        else if (prod instanceof model_NonTerminal) {\n            const newRuleStack = (0,clone/* default */.A)(currRuleStack);\n            newRuleStack.push(prod.nonTerminalName);\n            const newOccurrenceStack = (0,clone/* default */.A)(currOccurrenceStack);\n            newOccurrenceStack.push(prod.idx);\n            const nextPath = {\n                idx: currIdx,\n                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, lodash_es_drop(currDef)),\n                ruleStack: newRuleStack,\n                occurrenceStack: newOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof Option) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: lodash_es_drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const nextPathWith = {\n                idx: currIdx,\n                def: prod.definition.concat(lodash_es_drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof RepetitionMandatory) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const secondIteration = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], lodash_es_drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionMandatoryWithSeparator) {\n            // TODO:(THE NEW operators here take a while...) (convert once?)\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const secondIteration = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([secondIteration], lodash_es_drop(currDef));\n            const nextPath = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPath);\n        }\n        else if (prod instanceof RepetitionWithSeparator) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: lodash_es_drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            const separatorGast = new Terminal({\n                terminalType: prod.separator,\n            });\n            const nthRepetition = new Repetition({\n                definition: [separatorGast].concat(prod.definition),\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], lodash_es_drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Repetition) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            const nextPathWithout = {\n                idx: currIdx,\n                def: lodash_es_drop(currDef),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWithout);\n            // required marker to avoid backtracking paths whose higher priority alternatives already matched\n            possiblePaths.push(EXIT_ALTERNATIVE);\n            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\n            const nthRepetition = new Repetition({\n                definition: prod.definition,\n                idx: prod.idx,\n            });\n            const nextDef = prod.definition.concat([nthRepetition], lodash_es_drop(currDef));\n            const nextPathWith = {\n                idx: currIdx,\n                def: nextDef,\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            };\n            possiblePaths.push(nextPathWith);\n        }\n        else if (prod instanceof Alternation) {\n            // the order of alternatives is meaningful, FILO (Last path will be traversed first).\n            for (let i = prod.definition.length - 1; i >= 0; i--) {\n                const currAlt = prod.definition[i];\n                const currAltPath = {\n                    idx: currIdx,\n                    def: currAlt.definition.concat(lodash_es_drop(currDef)),\n                    ruleStack: currRuleStack,\n                    occurrenceStack: currOccurrenceStack,\n                };\n                possiblePaths.push(currAltPath);\n                possiblePaths.push(EXIT_ALTERNATIVE);\n            }\n        }\n        else if (prod instanceof Alternative) {\n            possiblePaths.push({\n                idx: currIdx,\n                def: prod.definition.concat(lodash_es_drop(currDef)),\n                ruleStack: currRuleStack,\n                occurrenceStack: currOccurrenceStack,\n            });\n        }\n        else if (prod instanceof Rule) {\n            // last because we should only encounter at most a single one of these per invocation.\n            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));\n        }\n        else {\n            throw Error("non exhaustive match");\n        }\n    }\n    return result;\n}\nfunction expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {\n    const newRuleStack = (0,clone/* default */.A)(currRuleStack);\n    newRuleStack.push(topRule.name);\n    const newCurrOccurrenceStack = (0,clone/* default */.A)(currOccurrenceStack);\n    // top rule is always assumed to have been called with occurrence index 1\n    newCurrOccurrenceStack.push(1);\n    return {\n        idx: currIdx,\n        def: topRule.definition,\n        ruleStack: newRuleStack,\n        occurrenceStack: newCurrOccurrenceStack,\n    };\n}\n//# sourceMappingURL=interpreter.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js\n\n\n\n\n\nvar PROD_TYPE;\n(function (PROD_TYPE) {\n    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";\n    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";\n    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";\n    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";\n    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";\n    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";\n})(PROD_TYPE || (PROD_TYPE = {}));\nfunction getProdType(prod) {\n    /* istanbul ignore else */\n    if (prod instanceof Option || prod === "Option") {\n        return PROD_TYPE.OPTION;\n    }\n    else if (prod instanceof Repetition || prod === "Repetition") {\n        return PROD_TYPE.REPETITION;\n    }\n    else if (prod instanceof RepetitionMandatory ||\n        prod === "RepetitionMandatory") {\n        return PROD_TYPE.REPETITION_MANDATORY;\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator ||\n        prod === "RepetitionMandatoryWithSeparator") {\n        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\n    }\n    else if (prod instanceof RepetitionWithSeparator ||\n        prod === "RepetitionWithSeparator") {\n        return PROD_TYPE.REPETITION_WITH_SEPARATOR;\n    }\n    else if (prod instanceof Alternation || prod === "Alternation") {\n        return PROD_TYPE.ALTERNATION;\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction getLookaheadPaths(options) {\n    const { occurrence, rule, prodType, maxLookahead } = options;\n    const type = getProdType(prodType);\n    if (type === PROD_TYPE.ALTERNATION) {\n        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\n    }\n    else {\n        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);\n    }\n}\nfunction buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);\n}\n/**\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\n *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).\n *\n *  Example: given a production:\n *  ABC(DE)?DF\n *\n *  The optional \'(DE)?\' should only be entered if we see \'DE\'. a single Token \'D\' is not sufficient to distinguish between the two\n *  alternatives.\n *\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\n */\nfunction buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {\n    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);\n    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\n        ? tokenStructuredMatcherNoCategories\n        : tokenStructuredMatcher;\n    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);\n}\nfunction buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {\n    const numOfAlts = alts.length;\n    const areAllOneTokenLookahead = lodash_es_every(alts, (currAlt) => {\n        return lodash_es_every(currAlt, (currPath) => {\n            return currPath.length === 1;\n        });\n    });\n    // This version takes into account the predicates as well.\n    if (hasPredicates) {\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function (orAlts) {\n            // unfortunately the predicates must be extracted every single time\n            // as they cannot be cached due to references to parameters(vars) which are no longer valid.\n            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\n            const predicates = (0,lodash_es_map/* default */.A)(orAlts, (currAlt) => currAlt.GATE);\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                const currPredicate = predicates[t];\n                if (currPredicate !== undefined && currPredicate.call(this) === false) {\n                    // if the predicate does not match there is no point in checking the paths\n                    continue;\n                }\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        // optimized (common) case of all the lookaheads paths requiring only\n        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\n        const singleTokenAlts = (0,lodash_es_map/* default */.A)(alts, (currAlt) => {\n            return (0,lodash_es_flatten/* default */.A)(currAlt);\n        });\n        const choiceToAlt = (0,reduce/* default */.A)(singleTokenAlts, (result, currAlt, idx) => {\n            (0,forEach/* default */.A)(currAlt, (currTokType) => {\n                if (!(0,has/* default */.A)(result, currTokType.tokenTypeIdx)) {\n                    result[currTokType.tokenTypeIdx] = idx;\n                }\n                (0,forEach/* default */.A)(currTokType.categoryMatches, (currExtendingType) => {\n                    if (!(0,has/* default */.A)(result, currExtendingType)) {\n                        result[currExtendingType] = idx;\n                    }\n                });\n            });\n            return result;\n        }, {});\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            const nextToken = this.LA(1);\n            return choiceToAlt[nextToken.tokenTypeIdx];\n        };\n    }\n    else {\n        // optimized lookahead without needing to check the predicates at all.\n        // this causes code duplication which is intentional to improve performance.\n        /**\n         * @returns {number} - The chosen alternative index\n         */\n        return function () {\n            for (let t = 0; t < numOfAlts; t++) {\n                const currAlt = alts[t];\n                const currNumOfPaths = currAlt.length;\n                nextPath: for (let j = 0; j < currNumOfPaths; j++) {\n                    const currPath = currAlt[j];\n                    const currPathLength = currPath.length;\n                    for (let i = 0; i < currPathLength; i++) {\n                        const nextToken = this.LA(i + 1);\n                        if (tokenMatcher(nextToken, currPath[i]) === false) {\n                            // mismatch in current path\n                            // try the next pth\n                            continue nextPath;\n                        }\n                    }\n                    // found a full path that matches.\n                    // this will also work for an empty ALT as the loop will be skipped\n                    return t;\n                }\n                // none of the paths for the current alternative matched\n                // try the next alternative\n            }\n            // none of the alternatives could be matched\n            return undefined;\n        };\n    }\n}\nfunction buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {\n    const areAllOneTokenLookahead = lodash_es_every(alt, (currPath) => {\n        return currPath.length === 1;\n    });\n    const numOfPaths = alt.length;\n    // optimized (common) case of all the lookaheads paths requiring only\n    // a single token lookahead.\n    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\n        const singleTokensTypes = (0,lodash_es_flatten/* default */.A)(alt);\n        if (singleTokensTypes.length === 1 &&\n            (0,isEmpty/* default */.A)(singleTokensTypes[0].categoryMatches)) {\n            const expectedTokenType = singleTokensTypes[0];\n            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n            return function () {\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n            };\n        }\n        else {\n            const choiceToAlt = (0,reduce/* default */.A)(singleTokensTypes, (result, currTokType, idx) => {\n                result[currTokType.tokenTypeIdx] = true;\n                (0,forEach/* default */.A)(currTokType.categoryMatches, (currExtendingType) => {\n                    result[currExtendingType] = true;\n                });\n                return result;\n            }, []);\n            return function () {\n                const nextToken = this.LA(1);\n                return choiceToAlt[nextToken.tokenTypeIdx] === true;\n            };\n        }\n    }\n    else {\n        return function () {\n            nextPath: for (let j = 0; j < numOfPaths; j++) {\n                const currPath = alt[j];\n                const currPathLength = currPath.length;\n                for (let i = 0; i < currPathLength; i++) {\n                    const nextToken = this.LA(i + 1);\n                    if (tokenMatcher(nextToken, currPath[i]) === false) {\n                        // mismatch in current path\n                        // try the next pth\n                        continue nextPath;\n                    }\n                }\n                // found a full path that matches.\n                return true;\n            }\n            // none of the paths matched\n            return false;\n        };\n    }\n}\nclass RestDefinitionFinderWalker extends RestWalker {\n    constructor(topProd, targetOccurrence, targetProdType) {\n        super();\n        this.topProd = topProd;\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n    }\n    startWalking() {\n        this.walk(this.topProd);\n        return this.restDef;\n    }\n    checkIsTarget(node, expectedProdType, currRest, prevRest) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdType) {\n            this.restDef = currRest.concat(prevRest);\n            return true;\n        }\n        // performance optimization, do not iterate over the entire Grammar ast after we have found the target\n        return false;\n    }\n    walkOption(optionProd, currRest, prevRest) {\n        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\n            super.walkOption(optionProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {\n            super.walkOption(atLeastOneProd, currRest, prevRest);\n        }\n    }\n    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(atLeastOneSepProd, currRest, prevRest);\n        }\n    }\n    walkMany(manyProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {\n            super.walkOption(manyProd, currRest, prevRest);\n        }\n    }\n    walkManySep(manySepProd, currRest, prevRest) {\n        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {\n            super.walkOption(manySepProd, currRest, prevRest);\n        }\n    }\n}\n/**\n * Returns the definition of a target production in a top level level rule.\n */\nclass InsideDefinitionFinderVisitor extends visitor_GAstVisitor {\n    constructor(targetOccurrence, targetProdType, targetRef) {\n        super();\n        this.targetOccurrence = targetOccurrence;\n        this.targetProdType = targetProdType;\n        this.targetRef = targetRef;\n        this.result = [];\n    }\n    checkIsTarget(node, expectedProdName) {\n        if (node.idx === this.targetOccurrence &&\n            this.targetProdType === expectedProdName &&\n            (this.targetRef === undefined || node === this.targetRef)) {\n            this.result = node.definition;\n        }\n    }\n    visitOption(node) {\n        this.checkIsTarget(node, PROD_TYPE.OPTION);\n    }\n    visitRepetition(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION);\n    }\n    visitRepetitionMandatory(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\n    }\n    visitRepetitionWithSeparator(node) {\n        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\n    }\n    visitAlternation(node) {\n        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\n    }\n}\nfunction initializeArrayOfArrays(size) {\n    const result = new Array(size);\n    for (let i = 0; i < size; i++) {\n        result[i] = [];\n    }\n    return result;\n}\n/**\n * A sort of hash function between a Path in the grammar and a string.\n * Note that this returns multiple "hashes" to support the scenario of token categories.\n * -  A single path with categories may match multiple **actual** paths.\n */\nfunction pathToHashKeys(path) {\n    let keys = [""];\n    for (let i = 0; i < path.length; i++) {\n        const tokType = path[i];\n        const longerKeys = [];\n        for (let j = 0; j < keys.length; j++) {\n            const currShorterKey = keys[j];\n            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);\n            for (let t = 0; t < tokType.categoryMatches.length; t++) {\n                const categoriesKeySuffix = "_" + tokType.categoryMatches[t];\n                longerKeys.push(currShorterKey + categoriesKeySuffix);\n            }\n        }\n        keys = longerKeys;\n    }\n    return keys;\n}\n/**\n * Imperative style due to being called from a hot spot\n */\nfunction isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {\n    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {\n        // We only want to test vs the other alternatives\n        if (currAltIdx === idx) {\n            continue;\n        }\n        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\n        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\n            const searchKey = searchPathKeys[searchIdx];\n            if (otherAltKnownPathsKeys[searchKey] === true) {\n                return false;\n            }\n        }\n    }\n    // None of the SearchPathKeys were found in any of the other alternatives\n    return true;\n}\nfunction lookAheadSequenceFromAlternatives(altsDefs, k) {\n    const partialAlts = (0,lodash_es_map/* default */.A)(altsDefs, (currAlt) => possiblePathsFrom([currAlt], 1));\n    const finalResult = initializeArrayOfArrays(partialAlts.length);\n    const altsHashes = (0,lodash_es_map/* default */.A)(partialAlts, (currAltPaths) => {\n        const dict = {};\n        (0,forEach/* default */.A)(currAltPaths, (item) => {\n            const keys = pathToHashKeys(item.partialPath);\n            (0,forEach/* default */.A)(keys, (currKey) => {\n                dict[currKey] = true;\n            });\n        });\n        return dict;\n    });\n    let newData = partialAlts;\n    // maxLookahead loop\n    for (let pathLength = 1; pathLength <= k; pathLength++) {\n        const currDataset = newData;\n        newData = initializeArrayOfArrays(currDataset.length);\n        // alternatives loop\n        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\n            const currAltPathsAndSuffixes = currDataset[altIdx];\n            // paths in current alternative loop\n            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {\n                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\n                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\n                const prefixKeys = pathToHashKeys(currPathPrefix);\n                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\n                // End of the line for this path.\n                if (isUnique || (0,isEmpty/* default */.A)(suffixDef) || currPathPrefix.length === k) {\n                    const currAltResult = finalResult[altIdx];\n                    // TODO: Can we implement a containsPath using Maps/Dictionaries?\n                    if (containsPath(currAltResult, currPathPrefix) === false) {\n                        currAltResult.push(currPathPrefix);\n                        // Update all new  keys for the current path.\n                        for (let j = 0; j < prefixKeys.length; j++) {\n                            const currKey = prefixKeys[j];\n                            altsHashes[altIdx][currKey] = true;\n                        }\n                    }\n                }\n                // Expand longer paths\n                else {\n                    const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);\n                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\n                    // Update keys for new known paths\n                    (0,forEach/* default */.A)(newPartialPathsAndSuffixes, (item) => {\n                        const prefixKeys = pathToHashKeys(item.partialPath);\n                        (0,forEach/* default */.A)(prefixKeys, (key) => {\n                            altsHashes[altIdx][key] = true;\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return finalResult;\n}\nfunction getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {\n    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);\n    ruleGrammar.accept(visitor);\n    return lookAheadSequenceFromAlternatives(visitor.result, k);\n}\nfunction getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {\n    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);\n    ruleGrammar.accept(insideDefVisitor);\n    const insideDef = insideDefVisitor.result;\n    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);\n    const afterDef = afterDefWalker.startWalking();\n    const insideFlat = new Alternative({ definition: insideDef });\n    const afterFlat = new Alternative({ definition: afterDef });\n    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\n}\nfunction containsPath(alternative, searchPath) {\n    compareOtherPath: for (let i = 0; i < alternative.length; i++) {\n        const otherPath = alternative[i];\n        if (otherPath.length !== searchPath.length) {\n            continue;\n        }\n        for (let j = 0; j < otherPath.length; j++) {\n            const searchTok = searchPath[j];\n            const otherTok = otherPath[j];\n            const matchingTokens = searchTok === otherTok ||\n                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;\n            if (matchingTokens === false) {\n                continue compareOtherPath;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction isStrictPrefixOfPath(prefix, other) {\n    return (prefix.length < other.length &&\n        lodash_es_every(prefix, (tokType, idx) => {\n            const otherTokType = other[idx];\n            return (tokType === otherTokType ||\n                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);\n        }));\n}\nfunction areTokenCategoriesNotUsed(lookAheadPaths) {\n    return lodash_es_every(lookAheadPaths, (singleAltPaths) => lodash_es_every(singleAltPaths, (singlePath) => lodash_es_every(singlePath, (token) => (0,isEmpty/* default */.A)(token.categoryMatches))));\n}\n//# sourceMappingURL=lookahead.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/checks.js\n\n\n\n\n\n\nfunction validateLookahead(options) {\n    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\n        rules: options.rules,\n        tokenTypes: options.tokenTypes,\n        grammarName: options.grammarName,\n    });\n    return (0,lodash_es_map/* default */.A)(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));\n}\nfunction validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {\n    const duplicateErrors = lodash_es_flatMap(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));\n    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);\n    const tooManyAltsErrors = lodash_es_flatMap(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));\n    const duplicateRulesError = lodash_es_flatMap(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));\n    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);\n}\nfunction validateDuplicateProductions(topLevelRule, errMsgProvider) {\n    const collectorVisitor = new OccurrenceValidationCollector();\n    topLevelRule.accept(collectorVisitor);\n    const allRuleProductions = collectorVisitor.allProductions;\n    const productionGroups = lodash_es_groupBy(allRuleProductions, identifyProductionForDuplicates);\n    const duplicates = lodash_es_pickBy(productionGroups, (currGroup) => {\n        return currGroup.length > 1;\n    });\n    const errors = (0,lodash_es_map/* default */.A)((0,lodash_es_values/* default */.A)(duplicates), (currDuplicates) => {\n        const firstProd = lodash_es_head(currDuplicates);\n        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);\n        const dslName = getProductionDslName(firstProd);\n        const defError = {\n            message: msg,\n            type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\n            ruleName: topLevelRule.name,\n            dslName: dslName,\n            occurrence: firstProd.idx,\n        };\n        const param = getExtraProductionArgument(firstProd);\n        if (param) {\n            defError.parameter = param;\n        }\n        return defError;\n    });\n    return errors;\n}\nfunction identifyProductionForDuplicates(prod) {\n    return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;\n}\nfunction getExtraProductionArgument(prod) {\n    if (prod instanceof Terminal) {\n        return prod.terminalType.name;\n    }\n    else if (prod instanceof model_NonTerminal) {\n        return prod.nonTerminalName;\n    }\n    else {\n        return "";\n    }\n}\nclass OccurrenceValidationCollector extends visitor_GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitNonTerminal(subrule) {\n        this.allProductions.push(subrule);\n    }\n    visitOption(option) {\n        this.allProductions.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n    visitAlternation(or) {\n        this.allProductions.push(or);\n    }\n    visitTerminal(terminal) {\n        this.allProductions.push(terminal);\n    }\n}\nfunction validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {\n    const errors = [];\n    const occurrences = (0,reduce/* default */.A)(allRules, (result, curRule) => {\n        if (curRule.name === rule.name) {\n            return result + 1;\n        }\n        return result;\n    }, 0);\n    if (occurrences > 1) {\n        const errMsg = errMsgProvider.buildDuplicateRuleNameError({\n            topLevelRule: rule,\n            grammarName: className,\n        });\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n            ruleName: rule.name,\n        });\n    }\n    return errors;\n}\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\n// The grammar structure, only at runtime.\nfunction validateRuleIsOverridden(ruleName, definedRulesNames, className) {\n    const errors = [];\n    let errMsg;\n    if (!lodash_es_includes(definedRulesNames, ruleName)) {\n        errMsg =\n            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\n                `as it is not defined in any of the super grammars `;\n        errors.push({\n            message: errMsg,\n            type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\n            ruleName: ruleName,\n        });\n    }\n    return errors;\n}\nfunction validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {\n    const errors = [];\n    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\n    if ((0,isEmpty/* default */.A)(nextNonTerminals)) {\n        return [];\n    }\n    else {\n        const ruleName = topRule.name;\n        const foundLeftRecursion = lodash_es_includes(nextNonTerminals, topRule);\n        if (foundLeftRecursion) {\n            errors.push({\n                message: errMsgProvider.buildLeftRecursionError({\n                    topLevelRule: topRule,\n                    leftRecursionPath: path,\n                }),\n                type: ParserDefinitionErrorType.LEFT_RECURSION,\n                ruleName: ruleName,\n            });\n        }\n        // we are only looking for cyclic paths leading back to the specific topRule\n        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\n        const validNextSteps = lodash_es_difference(nextNonTerminals, path.concat([topRule]));\n        const errorsFromNextSteps = lodash_es_flatMap(validNextSteps, (currRefRule) => {\n            const newPath = (0,clone/* default */.A)(path);\n            newPath.push(currRefRule);\n            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);\n        });\n        return errors.concat(errorsFromNextSteps);\n    }\n}\nfunction getFirstNoneTerminal(definition) {\n    let result = [];\n    if ((0,isEmpty/* default */.A)(definition)) {\n        return result;\n    }\n    const firstProd = lodash_es_head(definition);\n    /* istanbul ignore else */\n    if (firstProd instanceof model_NonTerminal) {\n        result.push(firstProd.referencedRule);\n    }\n    else if (firstProd instanceof Alternative ||\n        firstProd instanceof Option ||\n        firstProd instanceof RepetitionMandatory ||\n        firstProd instanceof RepetitionMandatoryWithSeparator ||\n        firstProd instanceof RepetitionWithSeparator ||\n        firstProd instanceof Repetition) {\n        result = result.concat(getFirstNoneTerminal(firstProd.definition));\n    }\n    else if (firstProd instanceof Alternation) {\n        // each sub definition in alternation is a FLAT\n        result = (0,lodash_es_flatten/* default */.A)((0,lodash_es_map/* default */.A)(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));\n    }\n    else if (firstProd instanceof Terminal) {\n        // nothing to see, move along\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n    const isFirstOptional = isOptionalProd(firstProd);\n    const hasMore = definition.length > 1;\n    if (isFirstOptional && hasMore) {\n        const rest = lodash_es_drop(definition);\n        return result.concat(getFirstNoneTerminal(rest));\n    }\n    else {\n        return result;\n    }\n}\nclass OrCollector extends visitor_GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.alternations = [];\n    }\n    visitAlternation(node) {\n        this.alternations.push(node);\n    }\n}\nfunction validateEmptyOrAlternative(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = lodash_es_flatMap(ors, (currOr) => {\n        const exceptLast = lodash_es_dropRight(currOr.definition);\n        return lodash_es_flatMap(exceptLast, (currAlternative, currAltIdx) => {\n            const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);\n            if ((0,isEmpty/* default */.A)(possibleFirstInAlt)) {\n                return [\n                    {\n                        message: errMsgProvider.buildEmptyAlternationError({\n                            topLevelRule: topLevelRule,\n                            alternation: currOr,\n                            emptyChoiceIdx: currAltIdx,\n                        }),\n                        type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\n                        ruleName: topLevelRule.name,\n                        occurrence: currOr.idx,\n                        alternative: currAltIdx + 1,\n                    },\n                ];\n            }\n            else {\n                return [];\n            }\n        });\n    });\n    return errors;\n}\nfunction validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    let ors = orCollector.alternations;\n    // New Handling of ignoring ambiguities\n    // - https://github.com/chevrotain/chevrotain/issues/869\n    ors = lodash_es_reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\n    const errors = lodash_es_flatMap(ors, (currOr) => {\n        const currOccurrence = currOr.idx;\n        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\n        const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);\n        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);\n        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\n    });\n    return errors;\n}\nclass RepetitionCollector extends visitor_GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.allProductions = [];\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.allProductions.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.allProductions.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.allProductions.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.allProductions.push(many);\n    }\n}\nfunction validateTooManyAlts(topLevelRule, errMsgProvider) {\n    const orCollector = new OrCollector();\n    topLevelRule.accept(orCollector);\n    const ors = orCollector.alternations;\n    const errors = lodash_es_flatMap(ors, (currOr) => {\n        if (currOr.definition.length > 255) {\n            return [\n                {\n                    message: errMsgProvider.buildTooManyAlternativesError({\n                        topLevelRule: topLevelRule,\n                        alternation: currOr,\n                    }),\n                    type: ParserDefinitionErrorType.TOO_MANY_ALTS,\n                    ruleName: topLevelRule.name,\n                    occurrence: currOr.idx,\n                },\n            ];\n        }\n        else {\n            return [];\n        }\n    });\n    return errors;\n}\nfunction validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {\n    const errors = [];\n    (0,forEach/* default */.A)(topLevelRules, (currTopRule) => {\n        const collectorVisitor = new RepetitionCollector();\n        currTopRule.accept(collectorVisitor);\n        const allRuleProductions = collectorVisitor.allProductions;\n        (0,forEach/* default */.A)(allRuleProductions, (currProd) => {\n            const prodType = getProdType(currProd);\n            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\n            const currOccurrence = currProd.idx;\n            const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);\n            const pathsInsideProduction = paths[0];\n            if ((0,isEmpty/* default */.A)((0,lodash_es_flatten/* default */.A)(pathsInsideProduction))) {\n                const errMsg = errMsgProvider.buildEmptyRepetitionError({\n                    topLevelRule: currTopRule,\n                    repetition: currProd,\n                });\n                errors.push({\n                    message: errMsg,\n                    type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\n                    ruleName: currTopRule.name,\n                });\n            }\n        });\n    });\n    return errors;\n}\nfunction checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    const foundAmbiguousPaths = [];\n    const identicalAmbiguities = (0,reduce/* default */.A)(alternatives, (result, currAlt, currAltIdx) => {\n        // ignore (skip) ambiguities with this alternative\n        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\n            return result;\n        }\n        (0,forEach/* default */.A)(currAlt, (currPath) => {\n            const altsCurrPathAppearsIn = [currAltIdx];\n            (0,forEach/* default */.A)(alternatives, (currOtherAlt, currOtherAltIdx) => {\n                if (currAltIdx !== currOtherAltIdx &&\n                    containsPath(currOtherAlt, currPath) &&\n                    // ignore (skip) ambiguities with this "other" alternative\n                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {\n                    altsCurrPathAppearsIn.push(currOtherAltIdx);\n                }\n            });\n            if (altsCurrPathAppearsIn.length > 1 &&\n                !containsPath(foundAmbiguousPaths, currPath)) {\n                foundAmbiguousPaths.push(currPath);\n                result.push({\n                    alts: altsCurrPathAppearsIn,\n                    path: currPath,\n                });\n            }\n        });\n        return result;\n    }, []);\n    const currErrors = (0,lodash_es_map/* default */.A)(identicalAmbiguities, (currAmbDescriptor) => {\n        const ambgIndices = (0,lodash_es_map/* default */.A)(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);\n        const currMessage = errMsgProvider.buildAlternationAmbiguityError({\n            topLevelRule: rule,\n            alternation: alternation,\n            ambiguityIndices: ambgIndices,\n            prefixPath: currAmbDescriptor.path,\n        });\n        return {\n            message: currMessage,\n            type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\n            ruleName: rule.name,\n            occurrence: alternation.idx,\n            alternatives: currAmbDescriptor.alts,\n        };\n    });\n    return currErrors;\n}\nfunction checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {\n    // flatten\n    const pathsAndIndices = (0,reduce/* default */.A)(alternatives, (result, currAlt, idx) => {\n        const currPathsAndIdx = (0,lodash_es_map/* default */.A)(currAlt, (currPath) => {\n            return { idx: idx, path: currPath };\n        });\n        return result.concat(currPathsAndIdx);\n    }, []);\n    const errors = lodash_es_compact(lodash_es_flatMap(pathsAndIndices, (currPathAndIdx) => {\n        const alternativeGast = alternation.definition[currPathAndIdx.idx];\n        // ignore (skip) ambiguities with this alternative\n        if (alternativeGast.ignoreAmbiguities === true) {\n            return [];\n        }\n        const targetIdx = currPathAndIdx.idx;\n        const targetPath = currPathAndIdx.path;\n        const prefixAmbiguitiesPathsAndIndices = (0,filter/* default */.A)(pathsAndIndices, (searchPathAndIdx) => {\n            // prefix ambiguity can only be created from lower idx (higher priority) path\n            return (\n            // ignore (skip) ambiguities with this "other" alternative\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\n                true &&\n                searchPathAndIdx.idx < targetIdx &&\n                // checking for strict prefix because identical lookaheads\n                // will be be detected using a different validation.\n                isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));\n        });\n        const currPathPrefixErrors = (0,lodash_es_map/* default */.A)(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {\n            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\n            const occurrence = alternation.idx === 0 ? "" : alternation.idx;\n            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\n                topLevelRule: rule,\n                alternation: alternation,\n                ambiguityIndices: ambgIndices,\n                prefixPath: currAmbPathAndIdx.path,\n            });\n            return {\n                message: message,\n                type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\n                ruleName: rule.name,\n                occurrence: occurrence,\n                alternatives: ambgIndices,\n            };\n        });\n        return currPathPrefixErrors;\n    }));\n    return errors;\n}\nfunction checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {\n    const errors = [];\n    const tokenNames = (0,lodash_es_map/* default */.A)(tokenTypes, (currToken) => currToken.name);\n    (0,forEach/* default */.A)(topLevels, (currRule) => {\n        const currRuleName = currRule.name;\n        if (lodash_es_includes(tokenNames, currRuleName)) {\n            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\n            errors.push({\n                message: errMsg,\n                type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\n                ruleName: currRuleName,\n            });\n        }\n    });\n    return errors;\n}\n//# sourceMappingURL=checks.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js\n\n\n\n\nfunction gast_resolver_public_resolveGrammar(options) {\n    const actualOptions = (0,defaults/* default */.A)(options, {\n        errMsgProvider: defaultGrammarResolverErrorProvider,\n    });\n    const topRulesTable = {};\n    (0,forEach/* default */.A)(options.rules, (rule) => {\n        topRulesTable[rule.name] = rule;\n    });\n    return resolveGrammar(topRulesTable, actualOptions.errMsgProvider);\n}\nfunction gast_resolver_public_validateGrammar(options) {\n    options = (0,defaults/* default */.A)(options, {\n        errMsgProvider: defaultGrammarValidatorErrorProvider,\n    });\n    return validateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);\n}\n//# sourceMappingURL=gast_resolver_public.js.map\n;// ./node_modules/chevrotain/lib/src/parse/exceptions_public.js\n\nconst MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";\nconst NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";\nconst EARLY_EXIT_EXCEPTION = "EarlyExitException";\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";\nconst RECOGNITION_EXCEPTION_NAMES = [\n    MISMATCHED_TOKEN_EXCEPTION,\n    NO_VIABLE_ALT_EXCEPTION,\n    EARLY_EXIT_EXCEPTION,\n    NOT_ALL_INPUT_PARSED_EXCEPTION,\n];\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\n// hacks to bypass no support for custom Errors in javascript/typescript\nfunction isRecognitionException(error) {\n    // can\'t do instanceof on hacked custom js exceptions\n    return lodash_es_includes(RECOGNITION_EXCEPTION_NAMES, error.name);\n}\nclass RecognitionException extends Error {\n    constructor(message, token) {\n        super(message);\n        this.token = token;\n        this.resyncedTokens = [];\n        // fix prototype chain when typescript target is ES5\n        Object.setPrototypeOf(this, new.target.prototype);\n        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nclass MismatchedTokenException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = MISMATCHED_TOKEN_EXCEPTION;\n    }\n}\nclass NoViableAltException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = NO_VIABLE_ALT_EXCEPTION;\n    }\n}\nclass NotAllInputParsedException extends RecognitionException {\n    constructor(message, token) {\n        super(message, token);\n        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\n    }\n}\nclass EarlyExitException extends RecognitionException {\n    constructor(message, token, previousToken) {\n        super(message, token);\n        this.previousToken = previousToken;\n        this.name = EARLY_EXIT_EXCEPTION;\n    }\n}\n//# sourceMappingURL=exceptions_public.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js\n\n\n\n\n\nconst EOF_FOLLOW_KEY = {};\nconst IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";\nclass InRuleRecoveryException extends Error {\n    constructor(message) {\n        super(message);\n        this.name = IN_RULE_RECOVERY_EXCEPTION;\n    }\n}\n/**\n * This trait is responsible for the error recovery and fault tolerant logic\n */\nclass Recoverable {\n    initRecoverable(config) {\n        this.firstAfterRepMap = {};\n        this.resyncFollows = {};\n        this.recoveryEnabled = (0,has/* default */.A)(config, "recoveryEnabled")\n            ? config.recoveryEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.recoveryEnabled;\n        // performance optimization, NOOP will be inlined which\n        // effectively means that this optional feature does not exist\n        // when not used.\n        if (this.recoveryEnabled) {\n            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\n        }\n    }\n    getTokenToInsert(tokType) {\n        const tokToInsert = createTokenInstance(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);\n        tokToInsert.isInsertedInRecovery = true;\n        return tokToInsert;\n    }\n    canTokenTypeBeInsertedInRecovery(tokType) {\n        return true;\n    }\n    canTokenTypeBeDeletedInRecovery(tokType) {\n        return true;\n    }\n    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {\n        // TODO: can the resyncTokenType be cached?\n        const reSyncTokType = this.findReSyncTokenType();\n        const savedLexerState = this.exportLexerState();\n        const resyncedTokens = [];\n        let passedResyncPoint = false;\n        const nextTokenWithoutResync = this.LA(1);\n        let currToken = this.LA(1);\n        const generateErrorMessage = () => {\n            const previousToken = this.LA(0);\n            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\n            // the error that would have been thrown\n            const msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: expectedTokType,\n                actual: nextTokenWithoutResync,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));\n            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\n            error.resyncedTokens = lodash_es_dropRight(resyncedTokens);\n            this.SAVE_ERROR(error);\n        };\n        while (!passedResyncPoint) {\n            // re-synced to a point where we can safely exit the repetition/\n            if (this.tokenMatcher(currToken, expectedTokType)) {\n                generateErrorMessage();\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (lookAheadFunc.call(this)) {\n                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\n                generateErrorMessage();\n                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\n                grammarRule.apply(this, grammarRuleArgs);\n                return; // must return here to avoid reverting the inputIdx\n            }\n            else if (this.tokenMatcher(currToken, reSyncTokType)) {\n                passedResyncPoint = true;\n            }\n            else {\n                currToken = this.SKIP_TOKEN();\n                this.addToResyncTokens(currToken, resyncedTokens);\n            }\n        }\n        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\n        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\n        // "between rules" resync recovery later in the flow.\n        this.importLexerState(savedLexerState);\n    }\n    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {\n        // Edge case of arriving from a MANY repetition which is stuck\n        // Attempting recovery in this case could cause an infinite loop\n        if (notStuck === false) {\n            return false;\n        }\n        // no need to recover, next token is what we expect...\n        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\n            return false;\n        }\n        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\n        // and prefer some backtracking path that includes recovered errors.\n        if (this.isBackTracking()) {\n            return false;\n        }\n        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\n        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\n        //noinspection RedundantIfStatementJS\n        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {\n            return false;\n        }\n        return true;\n    }\n    // Error Recovery functionality\n    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {\n        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\n        const follows = this.getNextPossibleTokenTypes(grammarPath);\n        return follows;\n    }\n    tryInRuleRecovery(expectedTokType, follows) {\n        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\n            const tokToInsert = this.getTokenToInsert(expectedTokType);\n            return tokToInsert;\n        }\n        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\n            const nextTok = this.SKIP_TOKEN();\n            this.consumeToken();\n            return nextTok;\n        }\n        throw new InRuleRecoveryException("sad sad panda");\n    }\n    canPerformInRuleRecovery(expectedToken, follows) {\n        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\n            this.canRecoverWithSingleTokenDeletion(expectedToken));\n    }\n    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {\n        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\n            return false;\n        }\n        // must know the possible following tokens to perform single token insertion\n        if ((0,isEmpty/* default */.A)(follows)) {\n            return false;\n        }\n        const mismatchedTok = this.LA(1);\n        const isMisMatchedTokInFollows = (0,find/* default */.A)(follows, (possibleFollowsTokType) => {\n            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\n        }) !== undefined;\n        return isMisMatchedTokInFollows;\n    }\n    canRecoverWithSingleTokenDeletion(expectedTokType) {\n        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\n            return false;\n        }\n        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);\n        return isNextTokenWhatIsExpected;\n    }\n    isInCurrentRuleReSyncSet(tokenTypeIdx) {\n        const followKey = this.getCurrFollowKey();\n        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\n        return lodash_es_includes(currentRuleReSyncSet, tokenTypeIdx);\n    }\n    findReSyncTokenType() {\n        const allPossibleReSyncTokTypes = this.flattenFollowSet();\n        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\n        let nextToken = this.LA(1);\n        let k = 2;\n        while (true) {\n            const foundMatch = (0,find/* default */.A)(allPossibleReSyncTokTypes, (resyncTokType) => {\n                const canMatch = tokenMatcher(nextToken, resyncTokType);\n                return canMatch;\n            });\n            if (foundMatch !== undefined) {\n                return foundMatch;\n            }\n            nextToken = this.LA(k);\n            k++;\n        }\n    }\n    getCurrFollowKey() {\n        // the length is at least one as we always add the ruleName to the stack before invoking the rule.\n        if (this.RULE_STACK.length === 1) {\n            return EOF_FOLLOW_KEY;\n        }\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\n        const prevRuleShortName = this.getPreviousExplicitRuleShortName();\n        return {\n            ruleName: this.shortRuleNameToFullName(currRuleShortName),\n            idxInCallingRule: currRuleIdx,\n            inRule: this.shortRuleNameToFullName(prevRuleShortName),\n        };\n    }\n    buildFullFollowKeyStack() {\n        const explicitRuleStack = this.RULE_STACK;\n        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return (0,lodash_es_map/* default */.A)(explicitRuleStack, (ruleName, idx) => {\n            if (idx === 0) {\n                return EOF_FOLLOW_KEY;\n            }\n            return {\n                ruleName: this.shortRuleNameToFullName(ruleName),\n                idxInCallingRule: explicitOccurrenceStack[idx],\n                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\n            };\n        });\n    }\n    flattenFollowSet() {\n        const followStack = (0,lodash_es_map/* default */.A)(this.buildFullFollowKeyStack(), (currKey) => {\n            return this.getFollowSetFromFollowKey(currKey);\n        });\n        return (0,lodash_es_flatten/* default */.A)(followStack);\n    }\n    getFollowSetFromFollowKey(followKey) {\n        if (followKey === EOF_FOLLOW_KEY) {\n            return [EOF];\n        }\n        const followName = followKey.ruleName + followKey.idxInCallingRule + constants_IN + followKey.inRule;\n        return this.resyncFollows[followName];\n    }\n    // It does not make any sense to include a virtual EOF token in the list of resynced tokens\n    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\n    addToResyncTokens(token, resyncTokens) {\n        if (!this.tokenMatcher(token, EOF)) {\n            resyncTokens.push(token);\n        }\n        return resyncTokens;\n    }\n    reSyncTo(tokType) {\n        const resyncedTokens = [];\n        let nextTok = this.LA(1);\n        while (this.tokenMatcher(nextTok, tokType) === false) {\n            nextTok = this.SKIP_TOKEN();\n            this.addToResyncTokens(nextTok, resyncedTokens);\n        }\n        // the last token is not part of the error.\n        return lodash_es_dropRight(resyncedTokens);\n    }\n    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n        // by default this is a NO-OP\n        // The actual implementation is with the function(not method) below\n    }\n    getCurrentGrammarPath(tokType, tokIdxInRule) {\n        const pathRuleStack = this.getHumanReadableRuleStack();\n        const pathOccurrenceStack = (0,clone/* default */.A)(this.RULE_OCCURRENCE_STACK);\n        const grammarPath = {\n            ruleStack: pathRuleStack,\n            occurrenceStack: pathOccurrenceStack,\n            lastTok: tokType,\n            lastTokOccurrence: tokIdxInRule,\n        };\n        return grammarPath;\n    }\n    getHumanReadableRuleStack() {\n        return (0,lodash_es_map/* default */.A)(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));\n    }\n}\nfunction attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {\n    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\n    let firstAfterRepInfo = this.firstAfterRepMap[key];\n    if (firstAfterRepInfo === undefined) {\n        const currRuleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[currRuleName];\n        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);\n        firstAfterRepInfo = walker.startWalking();\n        this.firstAfterRepMap[key] = firstAfterRepInfo;\n    }\n    let expectTokAfterLastMatch = firstAfterRepInfo.token;\n    let nextTokIdx = firstAfterRepInfo.occurrence;\n    const isEndOfRule = firstAfterRepInfo.isEndOfRule;\n    // special edge case of a TOP most repetition after which the input should END.\n    // this will force an attempt for inRule recovery in that scenario.\n    if (this.RULE_STACK.length === 1 &&\n        isEndOfRule &&\n        expectTokAfterLastMatch === undefined) {\n        expectTokAfterLastMatch = EOF;\n        nextTokIdx = 1;\n    }\n    // We don\'t have anything to re-sync to...\n    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\n    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\n        return;\n    }\n    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {\n        // TODO: performance optimization: instead of passing the original args here, we modify\n        // the args param (or create a new one) and make sure the lookahead func is explicitly provided\n        // to avoid searching the cache for it once more.\n        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);\n    }\n}\n//# sourceMappingURL=recoverable.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/keys.js\n// Lookahead keys are 32Bit integers in the form\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\n// XXXX -> Occurrence Index bitmap.\n// YYYY -> DSL Method Type bitmap.\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\n// TTTTTTTTT -> alternation alternative index bitmap\nconst BITS_FOR_METHOD_TYPE = 4;\nconst BITS_FOR_OCCURRENCE_IDX = 8;\nconst BITS_FOR_RULE_IDX = 12;\n// TODO: validation, this means that there may at most 2^8 --\x3e 256 alternatives for an alternation.\nconst BITS_FOR_ALT_IDX = 8;\n// short string used as part of mapping keys.\n// being short improves the performance when composing KEYS for maps out of these\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\nconst OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\nconst OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\nconst MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\nconst AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\nconst MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\nconst AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\n// this actually returns a number, but it is always used as a string (object prop key)\nfunction getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {\n    return occurrence | dslMethodIdx | ruleIdx;\n}\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\n//# sourceMappingURL=keys.js.map\n;// ./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js\n\n\n\n\n\nclass LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        this.maxLookahead =\n            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;\n    }\n    validate(options) {\n        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\n        if ((0,isEmpty/* default */.A)(leftRecursionErrors)) {\n            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\n            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);\n            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);\n            const allErrors = [\n                ...leftRecursionErrors,\n                ...emptyAltErrors,\n                ...ambiguousAltsErrors,\n                ...emptyRepetitionErrors,\n            ];\n            return allErrors;\n        }\n        return leftRecursionErrors;\n    }\n    validateNoLeftRecursion(rules) {\n        return lodash_es_flatMap(rules, (currTopRule) => validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateEmptyOrAlternatives(rules) {\n        return lodash_es_flatMap(rules, (currTopRule) => validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));\n    }\n    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {\n        return lodash_es_flatMap(rules, (currTopRule) => validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));\n    }\n    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {\n        return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);\n    }\n    buildLookaheadForAlternation(options) {\n        return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);\n    }\n    buildLookaheadForOptional(options) {\n        return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);\n    }\n}\n//# sourceMappingURL=llk_lookahead.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js\n\n\n\n\n\n/**\n * Trait responsible for the lookahead related utilities and optimizations.\n */\nclass LooksAhead {\n    initLooksAhead(config) {\n        this.dynamicTokensEnabled = (0,has/* default */.A)(config, "dynamicTokensEnabled")\n            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\n        this.maxLookahead = (0,has/* default */.A)(config, "maxLookahead")\n            ? config.maxLookahead // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.maxLookahead;\n        this.lookaheadStrategy = (0,has/* default */.A)(config, "lookaheadStrategy")\n            ? config.lookaheadStrategy // assumes end user provides the correct config value/type\n            : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\n        this.lookAheadFuncsCache = new Map();\n    }\n    preComputeLookaheadFunctions(rules) {\n        (0,forEach/* default */.A)(rules, (currRule) => {\n            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\n                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);\n                (0,forEach/* default */.A)(alternation, (currProd) => {\n                    const prodIdx = currProd.idx === 0 ? "" : currProd.idx;\n                    this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\n                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\n                            prodOccurrence: currProd.idx,\n                            rule: currRule,\n                            maxLookahead: currProd.maxLookahead || this.maxLookahead,\n                            hasPredicates: currProd.hasPredicates,\n                            dynamicTokensEnabled: this.dynamicTokensEnabled,\n                        });\n                        const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);\n                        this.setLaFuncCache(key, laFunc);\n                    });\n                });\n                (0,forEach/* default */.A)(repetition, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, "Repetition", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                (0,forEach/* default */.A)(option, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, "Option", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                (0,forEach/* default */.A)(repetitionMandatory, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                (0,forEach/* default */.A)(repetitionMandatoryWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n                (0,forEach/* default */.A)(repetitionWithSeparator, (currProd) => {\n                    this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, getProductionDslName(currProd));\n                });\n            });\n        });\n    }\n    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {\n        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? "" : prodOccurrence}`, () => {\n            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\n                prodOccurrence,\n                rule,\n                maxLookahead: prodMaxLookahead || this.maxLookahead,\n                dynamicTokensEnabled: this.dynamicTokensEnabled,\n                prodType,\n            });\n            const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);\n            this.setLaFuncCache(key, laFunc);\n        });\n    }\n    // this actually returns a number, but it is always used as a string (object prop key)\n    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {\n        const currRuleShortName = this.getLastExplicitRuleShortName();\n        return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);\n    }\n    getLaFuncFromCache(key) {\n        return this.lookAheadFuncsCache.get(key);\n    }\n    /* istanbul ignore next */\n    setLaFuncCache(key, value) {\n        this.lookAheadFuncsCache.set(key, value);\n    }\n}\nclass DslMethodsCollectorVisitor extends visitor_GAstVisitor {\n    constructor() {\n        super(...arguments);\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    reset() {\n        this.dslMethods = {\n            option: [],\n            alternation: [],\n            repetition: [],\n            repetitionWithSeparator: [],\n            repetitionMandatory: [],\n            repetitionMandatoryWithSeparator: [],\n        };\n    }\n    visitOption(option) {\n        this.dslMethods.option.push(option);\n    }\n    visitRepetitionWithSeparator(manySep) {\n        this.dslMethods.repetitionWithSeparator.push(manySep);\n    }\n    visitRepetitionMandatory(atLeastOne) {\n        this.dslMethods.repetitionMandatory.push(atLeastOne);\n    }\n    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {\n        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\n    }\n    visitRepetition(many) {\n        this.dslMethods.repetition.push(many);\n    }\n    visitAlternation(or) {\n        this.dslMethods.alternation.push(or);\n    }\n}\nconst collectorVisitor = new DslMethodsCollectorVisitor();\nfunction collectMethods(rule) {\n    collectorVisitor.reset();\n    rule.accept(collectorVisitor);\n    const dslMethods = collectorVisitor.dslMethods;\n    // avoid uncleaned references\n    collectorVisitor.reset();\n    return dslMethods;\n}\n//# sourceMappingURL=looksahead.js.map\n;// ./node_modules/chevrotain/lib/src/parse/cst/cst.js\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (both start/end offsets exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n    // Once the startOffset has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n    }\n}\n/**\n * This nodeLocation tracking is not efficient and should only be used\n * when error recovery is enabled or the Token Vector contains virtual Tokens\n * (e.g, Python Indent/Outdent)\n * As it executes the calculation for every single terminal/nonTerminal\n * and does not rely on the fact the token vector is **sorted**\n */\nfunction setNodeLocationFull(currNodeLocation, newLocationInfo) {\n    // First (valid) update for this cst node\n    if (isNaN(currNodeLocation.startOffset) === true) {\n        // assumption1: Token location information is either NaN or a valid number\n        // assumption2: Token location information is fully valid if it exist\n        // (all start/end props exist and are numbers).\n        currNodeLocation.startOffset = newLocationInfo.startOffset;\n        currNodeLocation.startColumn = newLocationInfo.startColumn;\n        currNodeLocation.startLine = newLocationInfo.startLine;\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n    // Once the start props has been updated with a valid number it should never receive\n    // any farther updates as the Token vector is sorted.\n    // We still have to check this this condition for every new possible location info\n    // because with error recovery enabled we may encounter invalid tokens (NaN location props)\n    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {\n        currNodeLocation.endOffset = newLocationInfo.endOffset;\n        currNodeLocation.endColumn = newLocationInfo.endColumn;\n        currNodeLocation.endLine = newLocationInfo.endLine;\n    }\n}\nfunction addTerminalToCst(node, token, tokenTypeName) {\n    if (node.children[tokenTypeName] === undefined) {\n        node.children[tokenTypeName] = [token];\n    }\n    else {\n        node.children[tokenTypeName].push(token);\n    }\n}\nfunction addNoneTerminalToCst(node, ruleName, ruleResult) {\n    if (node.children[ruleName] === undefined) {\n        node.children[ruleName] = [ruleResult];\n    }\n    else {\n        node.children[ruleName].push(ruleResult);\n    }\n}\n//# sourceMappingURL=cst.js.map\n;// ./node_modules/chevrotain/lib/src/lang/lang_extensions.js\nconst NAME = "name";\nfunction defineNameProp(obj, nameValue) {\n    Object.defineProperty(obj, NAME, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: nameValue,\n    });\n}\n//# sourceMappingURL=lang_extensions.js.map\n;// ./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js\n\n\nfunction defaultVisit(ctx, param) {\n    const childrenNames = (0,keys/* default */.A)(ctx);\n    const childrenNamesLength = childrenNames.length;\n    for (let i = 0; i < childrenNamesLength; i++) {\n        const currChildName = childrenNames[i];\n        const currChildArray = ctx[currChildName];\n        const currChildArrayLength = currChildArray.length;\n        for (let j = 0; j < currChildArrayLength; j++) {\n            const currChild = currChildArray[j];\n            // distinction between Tokens Children and CstNode children\n            if (currChild.tokenTypeIdx === undefined) {\n                this[currChild.name](currChild.children, param);\n            }\n        }\n    }\n    // defaultVisit does not support generic out param\n}\nfunction createBaseSemanticVisitorConstructor(grammarName, ruleNames) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + "BaseSemantics");\n    const semanticProto = {\n        visit: function (cstNode, param) {\n            // enables writing more concise visitor methods when CstNode has only a single child\n            if ((0,isArray/* default */.A)(cstNode)) {\n                // A CST Node\'s children dictionary can never have empty arrays as values\n                // If a key is defined there will be at least one element in the corresponding value array.\n                cstNode = cstNode[0];\n            }\n            // enables passing optional CstNodes concisely.\n            if ((0,isUndefined/* default */.A)(cstNode)) {\n                return undefined;\n            }\n            return this[cstNode.name](cstNode.children, param);\n        },\n        validateVisitor: function () {\n            const semanticDefinitionErrors = validateVisitor(this, ruleNames);\n            if (!(0,isEmpty/* default */.A)(semanticDefinitionErrors)) {\n                const errorMessages = (0,lodash_es_map/* default */.A)(semanticDefinitionErrors, (currDefError) => currDefError.msg);\n                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\n                    `${errorMessages.join("\\n\\n").replace(/\\n/g, "\\n\\t")}`);\n            }\n        },\n    };\n    derivedConstructor.prototype = semanticProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    derivedConstructor._RULE_NAMES = ruleNames;\n    return derivedConstructor;\n}\nfunction createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {\n    const derivedConstructor = function () { };\n    // can be overwritten according to:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\n    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\n    defineNameProp(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");\n    const withDefaultsProto = Object.create(baseConstructor.prototype);\n    (0,forEach/* default */.A)(ruleNames, (ruleName) => {\n        withDefaultsProto[ruleName] = defaultVisit;\n    });\n    derivedConstructor.prototype = withDefaultsProto;\n    derivedConstructor.prototype.constructor = derivedConstructor;\n    return derivedConstructor;\n}\nvar CstVisitorDefinitionError;\n(function (CstVisitorDefinitionError) {\n    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";\n    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";\n})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));\nfunction validateVisitor(visitorInstance, ruleNames) {\n    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\n    return missingErrors;\n}\nfunction validateMissingCstMethods(visitorInstance, ruleNames) {\n    const missingRuleNames = (0,filter/* default */.A)(ruleNames, (currRuleName) => {\n        return (0,isFunction/* default */.A)(visitorInstance[currRuleName]) === false;\n    });\n    const errors = (0,lodash_es_map/* default */.A)(missingRuleNames, (currRuleName) => {\n        return {\n            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,\n            type: CstVisitorDefinitionError.MISSING_METHOD,\n            methodName: currRuleName,\n        };\n    });\n    return lodash_es_compact(errors);\n}\n//# sourceMappingURL=cst_visitor.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js\n\n\n\n\n/**\n * This trait is responsible for the CST building logic.\n */\nclass TreeBuilder {\n    initTreeBuilder(config) {\n        this.CST_STACK = [];\n        // outputCst is no longer exposed/defined in the pubic API\n        this.outputCst = config.outputCst;\n        this.nodeLocationTracking = (0,has/* default */.A)(config, "nodeLocationTracking")\n            ? config.nodeLocationTracking // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\n        if (!this.outputCst) {\n            this.cstInvocationStateUpdate = noop/* default */.A;\n            this.cstFinallyStateUpdate = noop/* default */.A;\n            this.cstPostTerminal = noop/* default */.A;\n            this.cstPostNonTerminal = noop/* default */.A;\n            this.cstPostRule = noop/* default */.A;\n        }\n        else {\n            if (/full/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationFull;\n                    this.setNodeLocationFromNode = setNodeLocationFull;\n                    this.cstPostRule = noop/* default */.A;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop/* default */.A;\n                    this.setNodeLocationFromNode = noop/* default */.A;\n                    this.cstPostRule = this.cstPostRuleFull;\n                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\n                }\n            }\n            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\n                if (this.recoveryEnabled) {\n                    this.setNodeLocationFromToken = setNodeLocationOnlyOffset;\n                    this.setNodeLocationFromNode = setNodeLocationOnlyOffset;\n                    this.cstPostRule = noop/* default */.A;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRecovery;\n                }\n                else {\n                    this.setNodeLocationFromToken = noop/* default */.A;\n                    this.setNodeLocationFromNode = noop/* default */.A;\n                    this.cstPostRule = this.cstPostRuleOnlyOffset;\n                    this.setInitialNodeLocation =\n                        this.setInitialNodeLocationOnlyOffsetRegular;\n                }\n            }\n            else if (/none/i.test(this.nodeLocationTracking)) {\n                this.setNodeLocationFromToken = noop/* default */.A;\n                this.setNodeLocationFromNode = noop/* default */.A;\n                this.cstPostRule = noop/* default */.A;\n                this.setInitialNodeLocation = noop/* default */.A;\n            }\n            else {\n                throw Error(`Invalid <nodeLocationTracking> config option: "${config.nodeLocationTracking}"`);\n            }\n        }\n    }\n    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationOnlyOffsetRegular(cstNode) {\n        cstNode.location = {\n            // without error recovery the starting Location of a new CstNode is guaranteed\n            // To be the next Token\'s startOffset (for valid inputs).\n            // For invalid inputs there won\'t be any CSTOutput so this potential\n            // inaccuracy does not matter\n            startOffset: this.LA(1).startOffset,\n            endOffset: NaN,\n        };\n    }\n    setInitialNodeLocationFullRecovery(cstNode) {\n        cstNode.location = {\n            startOffset: NaN,\n            startLine: NaN,\n            startColumn: NaN,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    /**\n       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\n  \n       * @param cstNode\n       */\n    setInitialNodeLocationFullRegular(cstNode) {\n        const nextToken = this.LA(1);\n        cstNode.location = {\n            startOffset: nextToken.startOffset,\n            startLine: nextToken.startLine,\n            startColumn: nextToken.startColumn,\n            endOffset: NaN,\n            endLine: NaN,\n            endColumn: NaN,\n        };\n    }\n    cstInvocationStateUpdate(fullRuleName) {\n        const cstNode = {\n            name: fullRuleName,\n            children: Object.create(null),\n        };\n        this.setInitialNodeLocation(cstNode);\n        this.CST_STACK.push(cstNode);\n    }\n    cstFinallyStateUpdate() {\n        this.CST_STACK.pop();\n    }\n    cstPostRuleFull(ruleCstNode) {\n        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\n        const prevToken = this.LA(0);\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n            loc.endLine = prevToken.endLine;\n            loc.endColumn = prevToken.endColumn;\n        }\n        // "empty" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n            loc.startLine = NaN;\n            loc.startColumn = NaN;\n        }\n    }\n    cstPostRuleOnlyOffset(ruleCstNode) {\n        const prevToken = this.LA(0);\n        // `location\' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\n        const loc = ruleCstNode.location;\n        // If this condition is true it means we consumed at least one Token\n        // In this CstNode.\n        if (loc.startOffset <= prevToken.startOffset === true) {\n            loc.endOffset = prevToken.endOffset;\n        }\n        // "empty" CstNode edge case\n        else {\n            loc.startOffset = NaN;\n        }\n    }\n    cstPostTerminal(key, consumedToken) {\n        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\n        addTerminalToCst(rootCst, consumedToken, key);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromToken(rootCst.location, consumedToken);\n    }\n    cstPostNonTerminal(ruleCstResult, ruleName) {\n        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\n        addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\n        // This is only used when **both** error recovery and CST Output are enabled.\n        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);\n    }\n    getBaseCstVisitorConstructor() {\n        if ((0,isUndefined/* default */.A)(this.baseCstVisitorConstructor)) {\n            const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, (0,keys/* default */.A)(this.gastProductionsCache));\n            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\n            return newBaseCstVisitorConstructor;\n        }\n        return this.baseCstVisitorConstructor;\n    }\n    getBaseCstVisitorConstructorWithDefaults() {\n        if ((0,isUndefined/* default */.A)(this.baseCstVisitorWithDefaultsConstructor)) {\n            const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, (0,keys/* default */.A)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());\n            this.baseCstVisitorWithDefaultsConstructor = newConstructor;\n            return newConstructor;\n        }\n        return this.baseCstVisitorWithDefaultsConstructor;\n    }\n    getLastExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 1];\n    }\n    getPreviousExplicitRuleShortName() {\n        const ruleStack = this.RULE_STACK;\n        return ruleStack[ruleStack.length - 2];\n    }\n    getLastExplicitRuleOccurrenceIndex() {\n        const occurrenceStack = this.RULE_OCCURRENCE_STACK;\n        return occurrenceStack[occurrenceStack.length - 1];\n    }\n}\n//# sourceMappingURL=tree_builder.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js\n\n/**\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\n *\n * This could be generalized to support other kinds of lexers, e.g.\n * - Just in Time Lexing / Lexer-Less parsing.\n * - Streaming Lexer.\n */\nclass LexerAdapter {\n    initLexerAdapter() {\n        this.tokVector = [];\n        this.tokVectorLength = 0;\n        this.currIdx = -1;\n    }\n    set input(newInput) {\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        if (this.selfAnalysisDone !== true) {\n            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser\'s constructor.`);\n        }\n        // @ts-ignore - `this parameter` not supported in setters/getters\n        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\n        this.reset();\n        this.tokVector = newInput;\n        this.tokVectorLength = newInput.length;\n    }\n    get input() {\n        return this.tokVector;\n    }\n    // skips a token and returns the next token\n    SKIP_TOKEN() {\n        if (this.currIdx <= this.tokVector.length - 2) {\n            this.consumeToken();\n            return this.LA(1);\n        }\n        else {\n            return END_OF_FILE;\n        }\n    }\n    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\n    // or lexers dependent on parser context.\n    LA(howMuch) {\n        const soughtIdx = this.currIdx + howMuch;\n        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\n            return END_OF_FILE;\n        }\n        else {\n            return this.tokVector[soughtIdx];\n        }\n    }\n    consumeToken() {\n        this.currIdx++;\n    }\n    exportLexerState() {\n        return this.currIdx;\n    }\n    importLexerState(newState) {\n        this.currIdx = newState;\n    }\n    resetLexerState() {\n        this.currIdx = -1;\n    }\n    moveToTerminatedState() {\n        this.currIdx = this.tokVector.length - 1;\n    }\n    getLexerPosition() {\n        return this.exportLexerState();\n    }\n}\n//# sourceMappingURL=lexer_adapter.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js\n\n\n\n\n\n\n/**\n * This trait is responsible for implementing the public API\n * for defining Chevrotain parsers, i.e:\n * - CONSUME\n * - RULE\n * - OPTION\n * - ...\n */\nclass RecognizerApi {\n    ACTION(impl) {\n        return impl.call(this);\n    }\n    consume(idx, tokType, options) {\n        return this.consumeInternal(tokType, idx, options);\n    }\n    subrule(idx, ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, idx, options);\n    }\n    option(idx, actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, idx);\n    }\n    or(idx, altsOrOpts) {\n        return this.orInternal(altsOrOpts, idx);\n    }\n    many(idx, actionORMethodDef) {\n        return this.manyInternal(idx, actionORMethodDef);\n    }\n    atLeastOne(idx, actionORMethodDef) {\n        return this.atLeastOneInternal(idx, actionORMethodDef);\n    }\n    CONSUME(tokType, options) {\n        return this.consumeInternal(tokType, 0, options);\n    }\n    CONSUME1(tokType, options) {\n        return this.consumeInternal(tokType, 1, options);\n    }\n    CONSUME2(tokType, options) {\n        return this.consumeInternal(tokType, 2, options);\n    }\n    CONSUME3(tokType, options) {\n        return this.consumeInternal(tokType, 3, options);\n    }\n    CONSUME4(tokType, options) {\n        return this.consumeInternal(tokType, 4, options);\n    }\n    CONSUME5(tokType, options) {\n        return this.consumeInternal(tokType, 5, options);\n    }\n    CONSUME6(tokType, options) {\n        return this.consumeInternal(tokType, 6, options);\n    }\n    CONSUME7(tokType, options) {\n        return this.consumeInternal(tokType, 7, options);\n    }\n    CONSUME8(tokType, options) {\n        return this.consumeInternal(tokType, 8, options);\n    }\n    CONSUME9(tokType, options) {\n        return this.consumeInternal(tokType, 9, options);\n    }\n    SUBRULE(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 0, options);\n    }\n    SUBRULE1(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 1, options);\n    }\n    SUBRULE2(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 2, options);\n    }\n    SUBRULE3(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 3, options);\n    }\n    SUBRULE4(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 4, options);\n    }\n    SUBRULE5(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 5, options);\n    }\n    SUBRULE6(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 6, options);\n    }\n    SUBRULE7(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 7, options);\n    }\n    SUBRULE8(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 8, options);\n    }\n    SUBRULE9(ruleToCall, options) {\n        return this.subruleInternal(ruleToCall, 9, options);\n    }\n    OPTION(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 0);\n    }\n    OPTION1(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 1);\n    }\n    OPTION2(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 2);\n    }\n    OPTION3(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 3);\n    }\n    OPTION4(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 4);\n    }\n    OPTION5(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 5);\n    }\n    OPTION6(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 6);\n    }\n    OPTION7(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 7);\n    }\n    OPTION8(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 8);\n    }\n    OPTION9(actionORMethodDef) {\n        return this.optionInternal(actionORMethodDef, 9);\n    }\n    OR(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 0);\n    }\n    OR1(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 1);\n    }\n    OR2(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 2);\n    }\n    OR3(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 3);\n    }\n    OR4(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 4);\n    }\n    OR5(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 5);\n    }\n    OR6(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 6);\n    }\n    OR7(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 7);\n    }\n    OR8(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 8);\n    }\n    OR9(altsOrOpts) {\n        return this.orInternal(altsOrOpts, 9);\n    }\n    MANY(actionORMethodDef) {\n        this.manyInternal(0, actionORMethodDef);\n    }\n    MANY1(actionORMethodDef) {\n        this.manyInternal(1, actionORMethodDef);\n    }\n    MANY2(actionORMethodDef) {\n        this.manyInternal(2, actionORMethodDef);\n    }\n    MANY3(actionORMethodDef) {\n        this.manyInternal(3, actionORMethodDef);\n    }\n    MANY4(actionORMethodDef) {\n        this.manyInternal(4, actionORMethodDef);\n    }\n    MANY5(actionORMethodDef) {\n        this.manyInternal(5, actionORMethodDef);\n    }\n    MANY6(actionORMethodDef) {\n        this.manyInternal(6, actionORMethodDef);\n    }\n    MANY7(actionORMethodDef) {\n        this.manyInternal(7, actionORMethodDef);\n    }\n    MANY8(actionORMethodDef) {\n        this.manyInternal(8, actionORMethodDef);\n    }\n    MANY9(actionORMethodDef) {\n        this.manyInternal(9, actionORMethodDef);\n    }\n    MANY_SEP(options) {\n        this.manySepFirstInternal(0, options);\n    }\n    MANY_SEP1(options) {\n        this.manySepFirstInternal(1, options);\n    }\n    MANY_SEP2(options) {\n        this.manySepFirstInternal(2, options);\n    }\n    MANY_SEP3(options) {\n        this.manySepFirstInternal(3, options);\n    }\n    MANY_SEP4(options) {\n        this.manySepFirstInternal(4, options);\n    }\n    MANY_SEP5(options) {\n        this.manySepFirstInternal(5, options);\n    }\n    MANY_SEP6(options) {\n        this.manySepFirstInternal(6, options);\n    }\n    MANY_SEP7(options) {\n        this.manySepFirstInternal(7, options);\n    }\n    MANY_SEP8(options) {\n        this.manySepFirstInternal(8, options);\n    }\n    MANY_SEP9(options) {\n        this.manySepFirstInternal(9, options);\n    }\n    AT_LEAST_ONE(actionORMethodDef) {\n        this.atLeastOneInternal(0, actionORMethodDef);\n    }\n    AT_LEAST_ONE1(actionORMethodDef) {\n        return this.atLeastOneInternal(1, actionORMethodDef);\n    }\n    AT_LEAST_ONE2(actionORMethodDef) {\n        this.atLeastOneInternal(2, actionORMethodDef);\n    }\n    AT_LEAST_ONE3(actionORMethodDef) {\n        this.atLeastOneInternal(3, actionORMethodDef);\n    }\n    AT_LEAST_ONE4(actionORMethodDef) {\n        this.atLeastOneInternal(4, actionORMethodDef);\n    }\n    AT_LEAST_ONE5(actionORMethodDef) {\n        this.atLeastOneInternal(5, actionORMethodDef);\n    }\n    AT_LEAST_ONE6(actionORMethodDef) {\n        this.atLeastOneInternal(6, actionORMethodDef);\n    }\n    AT_LEAST_ONE7(actionORMethodDef) {\n        this.atLeastOneInternal(7, actionORMethodDef);\n    }\n    AT_LEAST_ONE8(actionORMethodDef) {\n        this.atLeastOneInternal(8, actionORMethodDef);\n    }\n    AT_LEAST_ONE9(actionORMethodDef) {\n        this.atLeastOneInternal(9, actionORMethodDef);\n    }\n    AT_LEAST_ONE_SEP(options) {\n        this.atLeastOneSepFirstInternal(0, options);\n    }\n    AT_LEAST_ONE_SEP1(options) {\n        this.atLeastOneSepFirstInternal(1, options);\n    }\n    AT_LEAST_ONE_SEP2(options) {\n        this.atLeastOneSepFirstInternal(2, options);\n    }\n    AT_LEAST_ONE_SEP3(options) {\n        this.atLeastOneSepFirstInternal(3, options);\n    }\n    AT_LEAST_ONE_SEP4(options) {\n        this.atLeastOneSepFirstInternal(4, options);\n    }\n    AT_LEAST_ONE_SEP5(options) {\n        this.atLeastOneSepFirstInternal(5, options);\n    }\n    AT_LEAST_ONE_SEP6(options) {\n        this.atLeastOneSepFirstInternal(6, options);\n    }\n    AT_LEAST_ONE_SEP7(options) {\n        this.atLeastOneSepFirstInternal(7, options);\n    }\n    AT_LEAST_ONE_SEP8(options) {\n        this.atLeastOneSepFirstInternal(8, options);\n    }\n    AT_LEAST_ONE_SEP9(options) {\n        this.atLeastOneSepFirstInternal(9, options);\n    }\n    RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {\n        if (lodash_es_includes(this.definedRulesNames, name)) {\n            const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\n                topLevelRule: name,\n                grammarName: this.className,\n            });\n            const error = {\n                message: errMsg,\n                type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\n                ruleName: name,\n            };\n            this.definitionErrors.push(error);\n        }\n        this.definedRulesNames.push(name);\n        const ruleImplementation = this.defineRule(name, implementation, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {\n        const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);\n        this.definitionErrors = this.definitionErrors.concat(ruleErrors);\n        const ruleImplementation = this.defineRule(name, impl, config);\n        this[name] = ruleImplementation;\n        return ruleImplementation;\n    }\n    BACKTRACK(grammarRule, args) {\n        return function () {\n            // save org state\n            this.isBackTrackingStack.push(1);\n            const orgState = this.saveRecogState();\n            try {\n                grammarRule.apply(this, args);\n                // if no exception was thrown we have succeed parsing the rule.\n                return true;\n            }\n            catch (e) {\n                if (isRecognitionException(e)) {\n                    return false;\n                }\n                else {\n                    throw e;\n                }\n            }\n            finally {\n                this.reloadRecogState(orgState);\n                this.isBackTrackingStack.pop();\n            }\n        };\n    }\n    // GAST export APIs\n    getGAstProductions() {\n        return this.gastProductionsCache;\n    }\n    getSerializedGastProductions() {\n        return serializeGrammar((0,lodash_es_values/* default */.A)(this.gastProductionsCache));\n    }\n}\n//# sourceMappingURL=recognizer_api.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js\nvar isObject = __webpack_require__(23149);\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js\n\n\n\n\n\n\n\n\n\n/**\n * This trait is responsible for the runtime parsing engine\n * Used by the official API (recognizer_api.ts)\n */\nclass RecognizerEngine {\n    initRecognizerEngine(tokenVocabulary, config) {\n        this.className = this.constructor.name;\n        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\n        this.shortRuleNameToFull = {};\n        this.fullRuleNameToShort = {};\n        this.ruleShortNameIdx = 256;\n        this.tokenMatcher = tokenStructuredMatcherNoCategories;\n        this.subruleIdx = 0;\n        this.definedRulesNames = [];\n        this.tokensMap = {};\n        this.isBackTrackingStack = [];\n        this.RULE_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n        this.gastProductionsCache = {};\n        if ((0,has/* default */.A)(config, "serializedGrammar")) {\n            throw Error("The Parser\'s configuration can no longer contain a <serializedGrammar> property.\\n" +\n                "\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n" +\n                "\\tFor Further details.");\n        }\n        if ((0,isArray/* default */.A)(tokenVocabulary)) {\n            // This only checks for Token vocabularies provided as arrays.\n            // That is good enough because the main objective is to detect users of pre-V4.0 APIs\n            // rather than all edge cases of empty Token vocabularies.\n            if ((0,isEmpty/* default */.A)(tokenVocabulary)) {\n                throw Error("A Token Vocabulary cannot be empty.\\n" +\n                    "\\tNote that the first argument for the parser constructor\\n" +\n                    "\\tis no longer a Token vector (since v4.0).");\n            }\n            if (typeof tokenVocabulary[0].startOffset === "number") {\n                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\\n" +\n                    "\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n" +\n                    "\\tFor Further details.");\n            }\n        }\n        if ((0,isArray/* default */.A)(tokenVocabulary)) {\n            this.tokensMap = (0,reduce/* default */.A)(tokenVocabulary, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0,has/* default */.A)(tokenVocabulary, "modes") &&\n            lodash_es_every((0,lodash_es_flatten/* default */.A)((0,lodash_es_values/* default */.A)(tokenVocabulary.modes)), isTokenType)) {\n            const allTokenTypes = (0,lodash_es_flatten/* default */.A)((0,lodash_es_values/* default */.A)(tokenVocabulary.modes));\n            const uniqueTokens = lodash_es_uniq(allTokenTypes);\n            this.tokensMap = (0,reduce/* default */.A)(uniqueTokens, (acc, tokType) => {\n                acc[tokType.name] = tokType;\n                return acc;\n            }, {});\n        }\n        else if ((0,isObject/* default */.A)(tokenVocabulary)) {\n            this.tokensMap = (0,clone/* default */.A)(tokenVocabulary);\n        }\n        else {\n            throw new Error("<tokensDictionary> argument must be An Array of Token constructors," +\n                " A dictionary of Token constructors or an IMultiModeLexerDefinition");\n        }\n        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\n        // parsed with a clear error message ("expecting EOF but found ...")\n        this.tokensMap["EOF"] = EOF;\n        const allTokenTypes = (0,has/* default */.A)(tokenVocabulary, "modes")\n            ? (0,lodash_es_flatten/* default */.A)((0,lodash_es_values/* default */.A)(tokenVocabulary.modes))\n            : (0,lodash_es_values/* default */.A)(tokenVocabulary);\n        const noTokenCategoriesUsed = lodash_es_every(allTokenTypes, (tokenConstructor) => (0,isEmpty/* default */.A)(tokenConstructor.categoryMatches));\n        this.tokenMatcher = noTokenCategoriesUsed\n            ? tokenStructuredMatcherNoCategories\n            : tokenStructuredMatcher;\n        // Because ES2015+ syntax should be supported for creating Token classes\n        // We cannot assume that the Token classes were created using the "extendToken" utilities\n        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\n        augmentTokenTypes((0,lodash_es_values/* default */.A)(this.tokensMap));\n    }\n    defineRule(ruleName, impl, config) {\n        if (this.selfAnalysisDone) {\n            throw Error(`Grammar rule <${ruleName}> may not be defined after the \'performSelfAnalysis\' method has been called\'\\n` +\n                `Make sure that all grammar rule definitions are done before \'performSelfAnalysis\' is called.`);\n        }\n        const resyncEnabled = (0,has/* default */.A)(config, "resyncEnabled")\n            ? config.resyncEnabled // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.resyncEnabled;\n        const recoveryValueFunc = (0,has/* default */.A)(config, "recoveryValueFunc")\n            ? config.recoveryValueFunc // assumes end user provides the correct config value/type\n            : DEFAULT_RULE_CONFIG.recoveryValueFunc;\n        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.\n        // this greatly improves Map access time (as much as 8% for some performance benchmarks).\n        const shortName = this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\n        this.ruleShortNameIdx++;\n        this.shortRuleNameToFull[shortName] = ruleName;\n        this.fullRuleNameToShort[ruleName] = shortName;\n        let invokeRuleWithTry;\n        // Micro optimization, only check the condition **once** on rule definition\n        // instead of **every single** rule invocation.\n        if (this.outputCst === true) {\n            invokeRuleWithTry = function invokeRuleWithTry(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    impl.apply(this, args);\n                    const cst = this.CST_STACK[this.CST_STACK.length - 1];\n                    this.cstPostRule(cst);\n                    return cst;\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        else {\n            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {\n                try {\n                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\n                    return impl.apply(this, args);\n                }\n                catch (e) {\n                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);\n                }\n                finally {\n                    this.ruleFinallyStateUpdate();\n                }\n            };\n        }\n        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });\n        return wrappedGrammarRule;\n    }\n    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {\n        const isFirstInvokedRule = this.RULE_STACK.length === 1;\n        // note the reSync is always enabled for the first rule invocation, because we must always be able to\n        // reSync with EOF and just output some INVALID ParseTree\n        // during backtracking reSync recovery is disabled, otherwise we can\'t be certain the backtracking\n        // path is really the most valid one\n        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\n        if (isRecognitionException(e)) {\n            const recogError = e;\n            if (reSyncEnabled) {\n                const reSyncTokType = this.findReSyncTokenType();\n                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\n                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        return partialCstResult;\n                    }\n                    else {\n                        return recoveryValueFunc(e);\n                    }\n                }\n                else {\n                    if (this.outputCst) {\n                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];\n                        partialCstResult.recoveredNode = true;\n                        recogError.partialCstResult = partialCstResult;\n                    }\n                    // to be handled Further up the call stack\n                    throw recogError;\n                }\n            }\n            else if (isFirstInvokedRule) {\n                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\n                this.moveToTerminatedState();\n                // the parser should never throw one of its own errors outside its flow.\n                // even if error recovery is disabled\n                return recoveryValueFunc(e);\n            }\n            else {\n                // to be recovered Further up the call stack\n                throw recogError;\n            }\n        }\n        else {\n            // some other Error type which we don\'t know how to handle (for example a built in JavaScript Error)\n            throw e;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternal(actionORMethodDef, occurrence) {\n        const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\n        return this.optionInternalLogic(actionORMethodDef, occurrence, key);\n    }\n    optionInternalLogic(actionORMethodDef, occurrence, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== "function") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            return action.call(this);\n        }\n        return undefined;\n    }\n    atLeastOneInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);\n        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookAheadFunc = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== "function") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookAheadFunc;\n                lookAheadFunc = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        if (lookAheadFunc.call(this) === true) {\n            let notStuck = this.doSingleRepetition(action);\n            while (lookAheadFunc.call(this) === true &&\n                notStuck === true) {\n                notStuck = this.doSingleRepetition(action);\n            }\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);\n        }\n        // note that while it may seem that this can cause an error because by using a recursive call to\n        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\n        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\n        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);\n    }\n    atLeastOneSepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);\n        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLookaheadFunc.call(this) === true) {\n            action.call(this);\n            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"\n            //  because it is only needed in error recovery scenarios.\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterAtLeastOneSepWalker,\n            ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);\n        }\n        else {\n            throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);\n        }\n    }\n    manyInternal(prodOccurrence, actionORMethodDef) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\n        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\n    }\n    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {\n        let lookaheadFunction = this.getLaFuncFromCache(key);\n        let action;\n        if (typeof actionORMethodDef !== "function") {\n            action = actionORMethodDef.DEF;\n            const predicate = actionORMethodDef.GATE;\n            // predicate present\n            if (predicate !== undefined) {\n                const orgLookaheadFunction = lookaheadFunction;\n                lookaheadFunction = () => {\n                    return predicate.call(this) && orgLookaheadFunction.call(this);\n                };\n            }\n        }\n        else {\n            action = actionORMethodDef;\n        }\n        let notStuck = true;\n        while (lookaheadFunction.call(this) === true && notStuck === true) {\n            notStuck = this.doSingleRepetition(action);\n        }\n        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled\n        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, \n        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"\n        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\n        // An infinite loop cannot occur as:\n        // - Either the lookahead is guaranteed to consume something (Single Token Separator)\n        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\n        notStuck);\n    }\n    manySepFirstInternal(prodOccurrence, options) {\n        const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);\n        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\n    }\n    manySepFirstInternalLogic(prodOccurrence, options, key) {\n        const action = options.DEF;\n        const separator = options.SEP;\n        const firstIterationLaFunc = this.getLaFuncFromCache(key);\n        // 1st iteration\n        if (firstIterationLaFunc.call(this) === true) {\n            action.call(this);\n            const separatorLookAheadFunc = () => {\n                return this.tokenMatcher(this.LA(1), separator);\n            };\n            // 2nd..nth iterations\n            while (this.tokenMatcher(this.LA(1), separator) === true) {\n                // note that this CONSUME will never enter recovery because\n                // the separatorLookAheadFunc checks that the separator really does exist.\n                this.CONSUME(separator);\n                // No need for checking infinite loop here due to consuming the separator.\n                action.call(this);\n            }\n            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled\n            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n                prodOccurrence,\n                separator,\n                separatorLookAheadFunc,\n                action,\n                NextTerminalAfterManySepWalker,\n            ], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);\n        }\n    }\n    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {\n        while (separatorLookAheadFunc()) {\n            // note that this CONSUME will never enter recovery because\n            // the separatorLookAheadFunc checks that the separator really does exist.\n            this.CONSUME(separator);\n            action.call(this);\n        }\n        // we can only arrive to this function after an error\n        // has occurred (hence the name \'second\') so the following\n        // IF will always be entered, its possible to remove it...\n        // however it is kept to avoid confusion and be consistent.\n        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled\n        /* istanbul ignore else */\n        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [\n            prodOccurrence,\n            separator,\n            separatorLookAheadFunc,\n            action,\n            nextTerminalAfterWalker,\n        ], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);\n    }\n    doSingleRepetition(action) {\n        const beforeIteration = this.getLexerPosition();\n        action.call(this);\n        const afterIteration = this.getLexerPosition();\n        // This boolean will indicate if this repetition progressed\n        // or if we are "stuck" (potential infinite loop in the repetition).\n        return afterIteration > beforeIteration;\n    }\n    orInternal(altsOrOpts, occurrence) {\n        const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\n        const alts = (0,isArray/* default */.A)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\n        const laFunc = this.getLaFuncFromCache(laKey);\n        const altIdxToTake = laFunc.call(this, alts);\n        if (altIdxToTake !== undefined) {\n            const chosenAlternative = alts[altIdxToTake];\n            return chosenAlternative.ALT.call(this);\n        }\n        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);\n    }\n    ruleFinallyStateUpdate() {\n        this.RULE_STACK.pop();\n        this.RULE_OCCURRENCE_STACK.pop();\n        // NOOP when cst is disabled\n        this.cstFinallyStateUpdate();\n        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\n            const firstRedundantTok = this.LA(1);\n            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\n                firstRedundant: firstRedundantTok,\n                ruleName: this.getCurrRuleFullName(),\n            });\n            this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));\n        }\n    }\n    subruleInternal(ruleToCall, idx, options) {\n        let ruleResult;\n        try {\n            const args = options !== undefined ? options.ARGS : undefined;\n            this.subruleIdx = idx;\n            ruleResult = ruleToCall.apply(this, args);\n            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleToCall.ruleName);\n            return ruleResult;\n        }\n        catch (e) {\n            throw this.subruleInternalError(e, options, ruleToCall.ruleName);\n        }\n    }\n    subruleInternalError(e, options, ruleName) {\n        if (isRecognitionException(e) && e.partialCstResult !== undefined) {\n            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined\n                ? options.LABEL\n                : ruleName);\n            delete e.partialCstResult;\n        }\n        throw e;\n    }\n    consumeInternal(tokType, idx, options) {\n        let consumedToken;\n        try {\n            const nextToken = this.LA(1);\n            if (this.tokenMatcher(nextToken, tokType) === true) {\n                this.consumeToken();\n                consumedToken = nextToken;\n            }\n            else {\n                this.consumeInternalError(tokType, nextToken, options);\n            }\n        }\n        catch (eFromConsumption) {\n            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);\n        }\n        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined\n            ? options.LABEL\n            : tokType.name, consumedToken);\n        return consumedToken;\n    }\n    consumeInternalError(tokType, nextToken, options) {\n        let msg;\n        const previousToken = this.LA(0);\n        if (options !== undefined && options.ERR_MSG) {\n            msg = options.ERR_MSG;\n        }\n        else {\n            msg = this.errorMessageProvider.buildMismatchTokenMessage({\n                expected: tokType,\n                actual: nextToken,\n                previous: previousToken,\n                ruleName: this.getCurrRuleFullName(),\n            });\n        }\n        throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));\n    }\n    consumeInternalRecovery(tokType, idx, eFromConsumption) {\n        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\n        // but the original syntax could have been parsed successfully without any backtracking + recovery\n        if (this.recoveryEnabled &&\n            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\n            eFromConsumption.name === "MismatchedTokenException" &&\n            !this.isBackTracking()) {\n            const follows = this.getFollowsForInRuleRecovery(tokType, idx);\n            try {\n                return this.tryInRuleRecovery(tokType, follows);\n            }\n            catch (eFromInRuleRecovery) {\n                if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\n                    // failed in RuleRecovery.\n                    // throw the original error in order to trigger reSync error recovery\n                    throw eFromConsumption;\n                }\n                else {\n                    throw eFromInRuleRecovery;\n                }\n            }\n        }\n        else {\n            throw eFromConsumption;\n        }\n    }\n    saveRecogState() {\n        // errors is a getter which will clone the errors array\n        const savedErrors = this.errors;\n        const savedRuleStack = (0,clone/* default */.A)(this.RULE_STACK);\n        return {\n            errors: savedErrors,\n            lexerState: this.exportLexerState(),\n            RULE_STACK: savedRuleStack,\n            CST_STACK: this.CST_STACK,\n        };\n    }\n    reloadRecogState(newState) {\n        this.errors = newState.errors;\n        this.importLexerState(newState.lexerState);\n        this.RULE_STACK = newState.RULE_STACK;\n    }\n    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {\n        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\n        this.RULE_STACK.push(shortName);\n        // NOOP when cst is disabled\n        this.cstInvocationStateUpdate(fullName);\n    }\n    isBackTracking() {\n        return this.isBackTrackingStack.length !== 0;\n    }\n    getCurrRuleFullName() {\n        const shortName = this.getLastExplicitRuleShortName();\n        return this.shortRuleNameToFull[shortName];\n    }\n    shortRuleNameToFullName(shortName) {\n        return this.shortRuleNameToFull[shortName];\n    }\n    isAtEndOfInput() {\n        return this.tokenMatcher(this.LA(1), EOF);\n    }\n    reset() {\n        this.resetLexerState();\n        this.subruleIdx = 0;\n        this.isBackTrackingStack = [];\n        this.errors = [];\n        this.RULE_STACK = [];\n        // TODO: extract a specific reset for TreeBuilder trait\n        this.CST_STACK = [];\n        this.RULE_OCCURRENCE_STACK = [];\n    }\n}\n//# sourceMappingURL=recognizer_engine.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js\n\n\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nclass ErrorHandler {\n    initErrorHandler(config) {\n        this._errors = [];\n        this.errorMessageProvider = (0,has/* default */.A)(config, "errorMessageProvider")\n            ? config.errorMessageProvider // assumes end user provides the correct config value/type\n            : DEFAULT_PARSER_CONFIG.errorMessageProvider;\n    }\n    SAVE_ERROR(error) {\n        if (isRecognitionException(error)) {\n            error.context = {\n                ruleStack: this.getHumanReadableRuleStack(),\n                ruleOccurrenceStack: (0,clone/* default */.A)(this.RULE_OCCURRENCE_STACK),\n            };\n            this._errors.push(error);\n            return error;\n        }\n        else {\n            throw Error("Trying to save an Error which is not a RecognitionException");\n        }\n    }\n    get errors() {\n        return (0,clone/* default */.A)(this._errors);\n    }\n    set errors(newErrors) {\n        this._errors = newErrors;\n    }\n    // TODO: consider caching the error message computed information\n    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);\n        const insideProdPaths = lookAheadPathsPerAlternative[0];\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const msg = this.errorMessageProvider.buildEarlyExitMessage({\n            expectedIterationPaths: insideProdPaths,\n            actual: actualTokens,\n            previous: this.LA(0),\n            customUserDescription: userDefinedErrMsg,\n            ruleName: ruleName,\n        });\n        throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\n    }\n    // TODO: consider caching the error message computed information\n    raiseNoAltException(occurrence, errMsgTypes) {\n        const ruleName = this.getCurrRuleFullName();\n        const ruleGrammar = this.getGAstProductions()[ruleName];\n        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\n        const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);\n        const actualTokens = [];\n        for (let i = 1; i <= this.maxLookahead; i++) {\n            actualTokens.push(this.LA(i));\n        }\n        const previousToken = this.LA(0);\n        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\n            expectedPathsPerAlt: lookAheadPathsPerAlternative,\n            actual: actualTokens,\n            previous: previousToken,\n            customUserDescription: errMsgTypes,\n            ruleName: this.getCurrRuleFullName(),\n        });\n        throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));\n    }\n}\n//# sourceMappingURL=error_handler.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js\n\n\nclass ContentAssist {\n    initContentAssist() { }\n    computeContentAssist(startRuleName, precedingInput) {\n        const startRuleGast = this.gastProductionsCache[startRuleName];\n        if ((0,isUndefined/* default */.A)(startRuleGast)) {\n            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\n        }\n        return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);\n    }\n    // TODO: should this be a member method or a utility? it does not have any state or usage of \'this\'...\n    // TODO: should this be more explicitly part of the public API?\n    getNextPossibleTokenTypes(grammarPath) {\n        const topRuleName = lodash_es_head(grammarPath.ruleStack);\n        const gastProductions = this.getGAstProductions();\n        const topProduction = gastProductions[topRuleName];\n        const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();\n        return nextPossibleTokenTypes;\n    }\n}\n//# sourceMappingURL=context_assist.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js\n\n\n\n\n\n\n\nconst RECORDING_NULL_OBJECT = {\n    description: "This Object indicates the Parser is during Recording Phase",\n};\nObject.freeze(RECORDING_NULL_OBJECT);\nconst HANDLE_SEPARATOR = true;\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\nconst RFT = createToken({ name: "RECORDING_PHASE_TOKEN", pattern: Lexer.NA });\naugmentTokenTypes([RFT]);\nconst RECORDING_PHASE_TOKEN = createTokenInstance(RFT, "This IToken indicates the Parser is in Recording Phase\\n\\t" +\n    "" +\n    "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details", \n// Using "-1" instead of NaN (as in EOF) because an actual number is less likely to\n// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\n-1, -1, -1, -1, -1, -1);\nObject.freeze(RECORDING_PHASE_TOKEN);\nconst RECORDING_PHASE_CSTNODE = {\n    name: "This CSTNode indicates the Parser is in Recording Phase\\n\\t" +\n        "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",\n    children: {},\n};\n/**\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\n */\nclass GastRecorder {\n    initGastRecorder(config) {\n        this.recordingProdStack = [];\n        this.RECORDING_PHASE = false;\n    }\n    enableRecording() {\n        this.RECORDING_PHASE = true;\n        this.TRACE_INIT("Enable Recording", () => {\n            /**\n             * Warning Dark Voodoo Magic upcoming!\n             * We are "replacing" the public parsing DSL methods API\n             * With **new** alternative implementations on the Parser **instance**\n             *\n             * So far this is the only way I\'ve found to avoid performance regressions during parsing time.\n             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"\n             *   implementations directly instead.\n             */\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : "";\n                this[`CONSUME${idx}`] = function (arg1, arg2) {\n                    return this.consumeInternalRecord(arg1, i, arg2);\n                };\n                this[`SUBRULE${idx}`] = function (arg1, arg2) {\n                    return this.subruleInternalRecord(arg1, i, arg2);\n                };\n                this[`OPTION${idx}`] = function (arg1) {\n                    return this.optionInternalRecord(arg1, i);\n                };\n                this[`OR${idx}`] = function (arg1) {\n                    return this.orInternalRecord(arg1, i);\n                };\n                this[`MANY${idx}`] = function (arg1) {\n                    this.manyInternalRecord(i, arg1);\n                };\n                this[`MANY_SEP${idx}`] = function (arg1) {\n                    this.manySepFirstInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE${idx}`] = function (arg1) {\n                    this.atLeastOneInternalRecord(i, arg1);\n                };\n                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {\n                    this.atLeastOneSepFirstInternalRecord(i, arg1);\n                };\n            }\n            // DSL methods with the idx(suffix) as an argument\n            this[`consume`] = function (idx, arg1, arg2) {\n                return this.consumeInternalRecord(arg1, idx, arg2);\n            };\n            this[`subrule`] = function (idx, arg1, arg2) {\n                return this.subruleInternalRecord(arg1, idx, arg2);\n            };\n            this[`option`] = function (idx, arg1) {\n                return this.optionInternalRecord(arg1, idx);\n            };\n            this[`or`] = function (idx, arg1) {\n                return this.orInternalRecord(arg1, idx);\n            };\n            this[`many`] = function (idx, arg1) {\n                this.manyInternalRecord(idx, arg1);\n            };\n            this[`atLeastOne`] = function (idx, arg1) {\n                this.atLeastOneInternalRecord(idx, arg1);\n            };\n            this.ACTION = this.ACTION_RECORD;\n            this.BACKTRACK = this.BACKTRACK_RECORD;\n            this.LA = this.LA_RECORD;\n        });\n    }\n    disableRecording() {\n        this.RECORDING_PHASE = false;\n        // By deleting these **instance** properties, any future invocation\n        // will be deferred to the original methods on the **prototype** object\n        // This seems to get rid of any incorrect optimizations that V8 may\n        // do during the recording phase.\n        this.TRACE_INIT("Deleting Recording methods", () => {\n            const that = this;\n            for (let i = 0; i < 10; i++) {\n                const idx = i > 0 ? i : "";\n                delete that[`CONSUME${idx}`];\n                delete that[`SUBRULE${idx}`];\n                delete that[`OPTION${idx}`];\n                delete that[`OR${idx}`];\n                delete that[`MANY${idx}`];\n                delete that[`MANY_SEP${idx}`];\n                delete that[`AT_LEAST_ONE${idx}`];\n                delete that[`AT_LEAST_ONE_SEP${idx}`];\n            }\n            delete that[`consume`];\n            delete that[`subrule`];\n            delete that[`option`];\n            delete that[`or`];\n            delete that[`many`];\n            delete that[`atLeastOne`];\n            delete that.ACTION;\n            delete that.BACKTRACK;\n            delete that.LA;\n        });\n    }\n    //   Parser methods are called inside an ACTION?\n    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\n    // @ts-expect-error -- noop place holder\n    ACTION_RECORD(impl) {\n        // NO-OP during recording\n    }\n    // Executing backtracking logic will break our recording logic assumptions\n    BACKTRACK_RECORD(grammarRule, args) {\n        return () => true;\n    }\n    // LA is part of the official API and may be used for custom lookahead logic\n    // by end users who may forget to wrap it in ACTION or inside a GATE\n    LA_RECORD(howMuch) {\n        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\n        // On LA return EOF at the end of the input so an infinite loop may occur.\n        return END_OF_FILE;\n    }\n    topLevelRuleRecord(name, def) {\n        try {\n            const newTopLevelRule = new Rule({ definition: [], name: name });\n            newTopLevelRule.name = name;\n            this.recordingProdStack.push(newTopLevelRule);\n            def.call(this);\n            this.recordingProdStack.pop();\n            return newTopLevelRule;\n        }\n        catch (originalError) {\n            if (originalError.KNOWN_RECORDER_ERROR !== true) {\n                try {\n                    originalError.message =\n                        originalError.message +\n                            \'\\n\\t This error was thrown during the "grammar recording phase" For more info see:\\n\\t\' +\n                            "https://chevrotain.io/docs/guide/internals.html#grammar-recording";\n                }\n                catch (mutabilityError) {\n                    // We may not be able to modify the original error object\n                    throw originalError;\n                }\n            }\n            throw originalError;\n        }\n    }\n    // Implementation of parsing DSL\n    optionInternalRecord(actionORMethodDef, occurrence) {\n        return recordProd.call(this, Option, actionORMethodDef, occurrence);\n    }\n    atLeastOneInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\n    }\n    atLeastOneSepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    manyInternalRecord(occurrence, actionORMethodDef) {\n        recordProd.call(this, Repetition, actionORMethodDef, occurrence);\n    }\n    manySepFirstInternalRecord(occurrence, options) {\n        recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);\n    }\n    orInternalRecord(altsOrOpts, occurrence) {\n        return recordOrProd.call(this, altsOrOpts, occurrence);\n    }\n    subruleInternalRecord(ruleToCall, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!ruleToCall || (0,has/* default */.A)(ruleToCall, "ruleName") === false) {\n            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = (0,last/* default */.A)(this.recordingProdStack);\n        const ruleName = ruleToCall.ruleName;\n        const newNoneTerminal = new model_NonTerminal({\n            idx: occurrence,\n            nonTerminalName: ruleName,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n            // The resolving of the `referencedRule` property will be done once all the Rule\'s GASTs have been created\n            referencedRule: undefined,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return this.outputCst\n            ? RECORDING_PHASE_CSTNODE\n            : RECORDING_NULL_OBJECT;\n    }\n    consumeInternalRecord(tokType, occurrence, options) {\n        assertMethodIdxIsValid(occurrence);\n        if (!hasShortKeyProperty(tokType)) {\n            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\n                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +\n                `\\n inside top level rule: <${this.recordingProdStack[0].name}>`);\n            error.KNOWN_RECORDER_ERROR = true;\n            throw error;\n        }\n        const prevProd = (0,last/* default */.A)(this.recordingProdStack);\n        const newNoneTerminal = new Terminal({\n            idx: occurrence,\n            terminalType: tokType,\n            label: options === null || options === void 0 ? void 0 : options.LABEL,\n        });\n        prevProd.definition.push(newNoneTerminal);\n        return RECORDING_PHASE_TOKEN;\n    }\n}\nfunction recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = (0,last/* default */.A)(this.recordingProdStack);\n    const grammarAction = (0,isFunction/* default */.A)(mainProdArg) ? mainProdArg : mainProdArg.DEF;\n    const newProd = new prodConstructor({ definition: [], idx: occurrence });\n    if (handleSep) {\n        newProd.separator = mainProdArg.SEP;\n    }\n    if ((0,has/* default */.A)(mainProdArg, "MAX_LOOKAHEAD")) {\n        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    this.recordingProdStack.push(newProd);\n    grammarAction.call(this);\n    prevProd.definition.push(newProd);\n    this.recordingProdStack.pop();\n    return RECORDING_NULL_OBJECT;\n}\nfunction recordOrProd(mainProdArg, occurrence) {\n    assertMethodIdxIsValid(occurrence);\n    const prevProd = (0,last/* default */.A)(this.recordingProdStack);\n    // Only an array of alternatives\n    const hasOptions = (0,isArray/* default */.A)(mainProdArg) === false;\n    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;\n    const newOrProd = new Alternation({\n        definition: [],\n        idx: occurrence,\n        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\n    });\n    if ((0,has/* default */.A)(mainProdArg, "MAX_LOOKAHEAD")) {\n        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\n    }\n    const hasPredicates = lodash_es_some(alts, (currAlt) => (0,isFunction/* default */.A)(currAlt.GATE));\n    newOrProd.hasPredicates = hasPredicates;\n    prevProd.definition.push(newOrProd);\n    (0,forEach/* default */.A)(alts, (currAlt) => {\n        const currAltFlat = new Alternative({ definition: [] });\n        newOrProd.definition.push(currAltFlat);\n        if ((0,has/* default */.A)(currAlt, "IGNORE_AMBIGUITIES")) {\n            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type\n        }\n        // **implicit** ignoreAmbiguities due to usage of gate\n        else if ((0,has/* default */.A)(currAlt, "GATE")) {\n            currAltFlat.ignoreAmbiguities = true;\n        }\n        this.recordingProdStack.push(currAltFlat);\n        currAlt.ALT.call(this);\n        this.recordingProdStack.pop();\n    });\n    return RECORDING_NULL_OBJECT;\n}\nfunction getIdxSuffix(idx) {\n    return idx === 0 ? "" : `${idx}`;\n}\nfunction assertMethodIdxIsValid(idx) {\n    if (idx < 0 || idx > MAX_METHOD_IDX) {\n        const error = new Error(\n        // The stack trace will contain all the needed details\n        `Invalid DSL Method idx value: <${idx}>\\n\\t` +\n            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);\n        error.KNOWN_RECORDER_ERROR = true;\n        throw error;\n    }\n}\n//# sourceMappingURL=gast_recorder.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js\n\n\n\n/**\n * Trait responsible for runtime parsing errors.\n */\nclass PerformanceTracer {\n    initPerformanceTracer(config) {\n        if ((0,has/* default */.A)(config, "traceInitPerf")) {\n            const userTraceInitPerf = config.traceInitPerf;\n            const traceIsNumber = typeof userTraceInitPerf === "number";\n            this.traceInitMaxIdent = traceIsNumber\n                ? userTraceInitPerf\n                : Infinity;\n            this.traceInitPerf = traceIsNumber\n                ? userTraceInitPerf > 0\n                : userTraceInitPerf; // assumes end user provides the correct config value/type\n        }\n        else {\n            this.traceInitMaxIdent = 0;\n            this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\n        }\n        this.traceInitIndent = -1;\n    }\n    TRACE_INIT(phaseDesc, phaseImpl) {\n        // No need to optimize this using NOOP pattern because\n        // It is not called in a hot spot...\n        if (this.traceInitPerf === true) {\n            this.traceInitIndent++;\n            const indent = new Array(this.traceInitIndent + 1).join("\\t");\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                console.log(`${indent}--\x3e <${phaseDesc}>`);\n            }\n            const { time, value } = timer(phaseImpl);\n            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\n            const traceMethod = time > 10 ? console.warn : console.log;\n            if (this.traceInitIndent < this.traceInitMaxIdent) {\n                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\n            }\n            this.traceInitIndent--;\n            return value;\n        }\n        else {\n            return phaseImpl();\n        }\n    }\n}\n//# sourceMappingURL=perf_tracer.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js\nfunction applyMixins(derivedCtor, baseCtors) {\n    baseCtors.forEach((baseCtor) => {\n        const baseProto = baseCtor.prototype;\n        Object.getOwnPropertyNames(baseProto).forEach((propName) => {\n            if (propName === "constructor") {\n                return;\n            }\n            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);\n            // Handle Accessors\n            if (basePropDescriptor &&\n                (basePropDescriptor.get || basePropDescriptor.set)) {\n                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);\n            }\n            else {\n                derivedCtor.prototype[propName] = baseCtor.prototype[propName];\n            }\n        });\n    });\n}\n//# sourceMappingURL=apply_mixins.js.map\n;// ./node_modules/chevrotain/lib/src/parse/parser/parser.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst END_OF_FILE = createTokenInstance(EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);\nObject.freeze(END_OF_FILE);\nconst DEFAULT_PARSER_CONFIG = Object.freeze({\n    recoveryEnabled: false,\n    maxLookahead: 3,\n    dynamicTokensEnabled: false,\n    outputCst: true,\n    errorMessageProvider: defaultParserErrorProvider,\n    nodeLocationTracking: "none",\n    traceInitPerf: false,\n    skipValidations: false,\n});\nconst DEFAULT_RULE_CONFIG = Object.freeze({\n    recoveryValueFunc: () => undefined,\n    resyncEnabled: true,\n});\nvar ParserDefinitionErrorType;\n(function (ParserDefinitionErrorType) {\n    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";\n    ParserDefinitionErrorType[ParserDefinitionErrorType["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";\n})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));\nfunction EMPTY_ALT(value = undefined) {\n    return function () {\n        return value;\n    };\n}\nclass Parser {\n    /**\n     *  @deprecated use the **instance** method with the same name instead\n     */\n    static performSelfAnalysis(parserInstance) {\n        throw Error("The **static** `performSelfAnalysis` method has been deprecated." +\n            "\\t\\nUse the **instance** method with the same name instead.");\n    }\n    performSelfAnalysis() {\n        this.TRACE_INIT("performSelfAnalysis", () => {\n            let defErrorsMsgs;\n            this.selfAnalysisDone = true;\n            const className = this.className;\n            this.TRACE_INIT("toFastProps", () => {\n                // Without this voodoo magic the parser would be x3-x4 slower\n                // It seems it is better to invoke `toFastProperties` **before**\n                // Any manipulations of the `this` object done during the recording phase.\n                toFastProperties(this);\n            });\n            this.TRACE_INIT("Grammar Recording", () => {\n                try {\n                    this.enableRecording();\n                    // Building the GAST\n                    (0,forEach/* default */.A)(this.definedRulesNames, (currRuleName) => {\n                        const wrappedRule = this[currRuleName];\n                        const originalGrammarAction = wrappedRule["originalGrammarAction"];\n                        let recordedRuleGast;\n                        this.TRACE_INIT(`${currRuleName} Rule`, () => {\n                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);\n                        });\n                        this.gastProductionsCache[currRuleName] = recordedRuleGast;\n                    });\n                }\n                finally {\n                    this.disableRecording();\n                }\n            });\n            let resolverErrors = [];\n            this.TRACE_INIT("Grammar Resolving", () => {\n                resolverErrors = gast_resolver_public_resolveGrammar({\n                    rules: (0,lodash_es_values/* default */.A)(this.gastProductionsCache),\n                });\n                this.definitionErrors = this.definitionErrors.concat(resolverErrors);\n            });\n            this.TRACE_INIT("Grammar Validations", () => {\n                // only perform additional grammar validations IFF no resolving errors have occurred.\n                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\n                if ((0,isEmpty/* default */.A)(resolverErrors) && this.skipValidations === false) {\n                    const validationErrors = gast_resolver_public_validateGrammar({\n                        rules: (0,lodash_es_values/* default */.A)(this.gastProductionsCache),\n                        tokenTypes: (0,lodash_es_values/* default */.A)(this.tokensMap),\n                        errMsgProvider: defaultGrammarValidatorErrorProvider,\n                        grammarName: className,\n                    });\n                    const lookaheadValidationErrors = validateLookahead({\n                        lookaheadStrategy: this.lookaheadStrategy,\n                        rules: (0,lodash_es_values/* default */.A)(this.gastProductionsCache),\n                        tokenTypes: (0,lodash_es_values/* default */.A)(this.tokensMap),\n                        grammarName: className,\n                    });\n                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);\n                }\n            });\n            // this analysis may fail if the grammar is not perfectly valid\n            if ((0,isEmpty/* default */.A)(this.definitionErrors)) {\n                // The results of these computations are not needed unless error recovery is enabled.\n                if (this.recoveryEnabled) {\n                    this.TRACE_INIT("computeAllProdsFollows", () => {\n                        const allFollows = computeAllProdsFollows((0,lodash_es_values/* default */.A)(this.gastProductionsCache));\n                        this.resyncFollows = allFollows;\n                    });\n                }\n                this.TRACE_INIT("ComputeLookaheadFunctions", () => {\n                    var _a, _b;\n                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {\n                        rules: (0,lodash_es_values/* default */.A)(this.gastProductionsCache),\n                    });\n                    this.preComputeLookaheadFunctions((0,lodash_es_values/* default */.A)(this.gastProductionsCache));\n                });\n            }\n            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\n                !(0,isEmpty/* default */.A)(this.definitionErrors)) {\n                defErrorsMsgs = (0,lodash_es_map/* default */.A)(this.definitionErrors, (defError) => defError.message);\n                throw new Error(`Parser Definition Errors detected:\\n ${defErrorsMsgs.join("\\n-------------------------------\\n")}`);\n            }\n        });\n    }\n    constructor(tokenVocabulary, config) {\n        this.definitionErrors = [];\n        this.selfAnalysisDone = false;\n        const that = this;\n        that.initErrorHandler(config);\n        that.initLexerAdapter();\n        that.initLooksAhead(config);\n        that.initRecognizerEngine(tokenVocabulary, config);\n        that.initRecoverable(config);\n        that.initTreeBuilder(config);\n        that.initContentAssist();\n        that.initGastRecorder(config);\n        that.initPerformanceTracer(config);\n        if ((0,has/* default */.A)(config, "ignoredIssues")) {\n            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t" +\n                "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t" +\n                "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t" +\n                "For further details.");\n        }\n        this.skipValidations = (0,has/* default */.A)(config, "skipValidations")\n            ? config.skipValidations // casting assumes the end user passing the correct type\n            : DEFAULT_PARSER_CONFIG.skipValidations;\n    }\n}\n// Set this flag to true if you don\'t want the Parser to throw error when problems in it\'s definition are detected.\n// (normally during the parser\'s constructor).\n// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\n// for example: duplicate rule names, referencing an unresolved subrule, ect...\n// This flag should not be enabled during normal usage, it is used in special situations, for example when\n// needing to display the parser definition errors in some GUI(online playground).\nParser.DEFER_DEFINITION_ERRORS_HANDLING = false;\napplyMixins(Parser, [\n    Recoverable,\n    LooksAhead,\n    TreeBuilder,\n    LexerAdapter,\n    RecognizerEngine,\n    RecognizerApi,\n    ErrorHandler,\n    ContentAssist,\n    GastRecorder,\n    PerformanceTracer,\n]);\nclass CstParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = (0,clone/* default */.A)(config);\n        configClone.outputCst = true;\n        super(tokenVocabulary, configClone);\n    }\n}\nclass EmbeddedActionsParser extends Parser {\n    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {\n        const configClone = (0,clone/* default */.A)(config);\n        configClone.outputCst = false;\n        super(tokenVocabulary, configClone);\n    }\n}\n//# sourceMappingURL=parser.js.map\n;// ./node_modules/@chevrotain/cst-dts-gen/lib/src/model.js\n\n\nfunction model_buildModel(productions) {\n    const generator = new CstNodeDefinitionGenerator();\n    const allRules = values(productions);\n    return map(allRules, (rule) => generator.visitRule(rule));\n}\nclass CstNodeDefinitionGenerator extends (/* unused pure expression or super */ null && (GAstVisitor)) {\n    visitRule(node) {\n        const rawElements = this.visitEach(node.definition);\n        const grouped = groupBy(rawElements, (el) => el.propertyName);\n        const properties = map(grouped, (group, propertyName) => {\n            const allNullable = !some(group, (el) => !el.canBeNull);\n            // In an alternation with a label a property name can have\n            // multiple types.\n            let propertyType = group[0].type;\n            if (group.length > 1) {\n                propertyType = map(group, (g) => g.type);\n            }\n            return {\n                name: propertyName,\n                type: propertyType,\n                optional: allNullable,\n            };\n        });\n        return {\n            name: node.name,\n            properties: properties,\n        };\n    }\n    visitAlternative(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitOption(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetition(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitRepetitionMandatory(node) {\n        return this.visitEach(node.definition);\n    }\n    visitRepetitionMandatoryWithSeparator(node) {\n        return this.visitEach(node.definition).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator),\n        });\n    }\n    visitRepetitionWithSeparator(node) {\n        return this.visitEachAndOverrideWith(node.definition, {\n            canBeNull: true,\n        }).concat({\n            propertyName: node.separator.name,\n            canBeNull: true,\n            type: getType(node.separator),\n        });\n    }\n    visitAlternation(node) {\n        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });\n    }\n    visitTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.terminalType.name,\n                canBeNull: false,\n                type: getType(node),\n            },\n        ];\n    }\n    visitNonTerminal(node) {\n        return [\n            {\n                propertyName: node.label || node.nonTerminalName,\n                canBeNull: false,\n                type: getType(node),\n            },\n        ];\n    }\n    visitEachAndOverrideWith(definition, override) {\n        return map(this.visitEach(definition), (definition) => assign({}, definition, override));\n    }\n    visitEach(definition) {\n        return flatten(map(definition, (definition) => this.visit(definition)));\n    }\n}\nfunction getType(production) {\n    if (production instanceof NonTerminal) {\n        return {\n            kind: "rule",\n            name: production.referencedRule.name,\n        };\n    }\n    return { kind: "token" };\n}\n//# sourceMappingURL=model.js.map\n;// ./node_modules/@chevrotain/cst-dts-gen/lib/src/api.js\n\n\nconst defaultOptions = {\n    includeVisitorInterface: true,\n    visitorInterfaceName: "ICstNodeVisitor",\n};\nfunction generateCstDts(productions, options) {\n    const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);\n    const model = buildModel(productions);\n    return genDts(model, effectiveOptions);\n}\n//# sourceMappingURL=api.js.map\n;// ./node_modules/chevrotain/lib/src/api.js\n/* istanbul ignore file - tricky to import some things from this module during testing */\n// semantic version\n\n\n\n// Tokens utilities\n\n// Lookahead\n\n\n// Other Utilities\n\n\n\n// grammar reflection API\n\n// GAST Utilities\n\n\n/* istanbul ignore next */\nfunction clearCache() {\n    console.warn("The clearCache function was \'soft\' removed from the Chevrotain API." +\n        "\\n\\t It performs no action other than printing this message." +\n        "\\n\\t Please avoid using it as it will be completely removed in the future");\n}\n\nclass api_Parser {\n    constructor() {\n        throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\\t\\n" +\n            "See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");\n    }\n}\n//# sourceMappingURL=api.js.map\n;// ./node_modules/chevrotain-allstar/lib/atn.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nfunction buildATNKey(rule, type, occurrence) {\n    return `${rule.name}_${type}_${occurrence}`;\n}\nconst ATN_INVALID_TYPE = 0;\nconst ATN_BASIC = 1;\nconst ATN_RULE_START = 2;\nconst ATN_PLUS_BLOCK_START = 4;\nconst ATN_STAR_BLOCK_START = 5;\n// Currently unused as the ATN is not used for lexing\nconst ATN_TOKEN_START = 6;\nconst ATN_RULE_STOP = 7;\nconst ATN_BLOCK_END = 8;\nconst ATN_STAR_LOOP_BACK = 9;\nconst ATN_STAR_LOOP_ENTRY = 10;\nconst ATN_PLUS_LOOP_BACK = 11;\nconst ATN_LOOP_END = 12;\nclass AbstractTransition {\n    constructor(target) {\n        this.target = target;\n    }\n    isEpsilon() {\n        return false;\n    }\n}\nclass AtomTransition extends AbstractTransition {\n    constructor(target, tokenType) {\n        super(target);\n        this.tokenType = tokenType;\n    }\n}\nclass EpsilonTransition extends AbstractTransition {\n    constructor(target) {\n        super(target);\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nclass RuleTransition extends AbstractTransition {\n    constructor(ruleStart, rule, followState) {\n        super(ruleStart);\n        this.rule = rule;\n        this.followState = followState;\n    }\n    isEpsilon() {\n        return true;\n    }\n}\nfunction createATN(rules) {\n    const atn = {\n        decisionMap: {},\n        decisionStates: [],\n        ruleToStartState: new Map(),\n        ruleToStopState: new Map(),\n        states: []\n    };\n    createRuleStartAndStopATNStates(atn, rules);\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const ruleBlock = block(atn, rule, rule);\n        if (ruleBlock === undefined) {\n            continue;\n        }\n        buildRuleHandle(atn, rule, ruleBlock);\n    }\n    return atn;\n}\nfunction createRuleStartAndStopATNStates(atn, rules) {\n    const ruleLength = rules.length;\n    for (let i = 0; i < ruleLength; i++) {\n        const rule = rules[i];\n        const start = newState(atn, rule, undefined, {\n            type: ATN_RULE_START\n        });\n        const stop = newState(atn, rule, undefined, {\n            type: ATN_RULE_STOP\n        });\n        start.stop = stop;\n        atn.ruleToStartState.set(rule, start);\n        atn.ruleToStopState.set(rule, stop);\n    }\n}\nfunction atom(atn, rule, production) {\n    if (production instanceof Terminal) {\n        return tokenRef(atn, rule, production.terminalType, production);\n    }\n    else if (production instanceof model_NonTerminal) {\n        return ruleRef(atn, rule, production);\n    }\n    else if (production instanceof Alternation) {\n        return alternation(atn, rule, production);\n    }\n    else if (production instanceof Option) {\n        return atn_option(atn, rule, production);\n    }\n    else if (production instanceof Repetition) {\n        return repetition(atn, rule, production);\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return repetitionSep(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return repetitionMandatory(atn, rule, production);\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return repetitionMandatorySep(atn, rule, production);\n    }\n    else {\n        return block(atn, rule, production);\n    }\n}\nfunction repetition(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    return star(atn, rule, repetition, handle);\n}\nfunction repetitionSep(atn, rule, repetition) {\n    const starState = newState(atn, rule, repetition, {\n        type: ATN_STAR_BLOCK_START\n    });\n    defineDecisionState(atn, starState);\n    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return star(atn, rule, repetition, handle, sep);\n}\nfunction repetitionMandatory(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    return plus(atn, rule, repetition, handle);\n}\nfunction repetitionMandatorySep(atn, rule, repetition) {\n    const plusState = newState(atn, rule, repetition, {\n        type: ATN_PLUS_BLOCK_START\n    });\n    defineDecisionState(atn, plusState);\n    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));\n    const sep = tokenRef(atn, rule, repetition.separator, repetition);\n    return plus(atn, rule, repetition, handle, sep);\n}\nfunction alternation(atn, rule, alternation) {\n    const start = newState(atn, rule, alternation, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const alts = (0,lodash_es_map/* default */.A)(alternation.definition, (e) => atom(atn, rule, e));\n    const handle = makeAlts(atn, rule, start, alternation, ...alts);\n    return handle;\n}\nfunction atn_option(atn, rule, option) {\n    const start = newState(atn, rule, option, {\n        type: ATN_BASIC\n    });\n    defineDecisionState(atn, start);\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));\n    return optional(atn, rule, option, handle);\n}\nfunction block(atn, rule, block) {\n    const handles = (0,filter/* default */.A)((0,lodash_es_map/* default */.A)(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);\n    if (handles.length === 1) {\n        return handles[0];\n    }\n    else if (handles.length === 0) {\n        return undefined;\n    }\n    else {\n        return makeBlock(atn, handles);\n    }\n}\nfunction plus(atn, rule, plus, handle, sep) {\n    const blkStart = handle.left;\n    const blkEnd = handle.right;\n    const loop = newState(atn, rule, plus, {\n        type: ATN_PLUS_LOOP_BACK\n    });\n    defineDecisionState(atn, loop);\n    const end = newState(atn, rule, plus, {\n        type: ATN_LOOP_END\n    });\n    blkStart.loopback = loop;\n    end.loopback = loop;\n    atn.decisionMap[buildATNKey(rule, sep ? \'RepetitionMandatoryWithSeparator\' : \'RepetitionMandatory\', plus.idx)] = loop;\n    epsilon(blkEnd, loop); // block can see loop back\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\n    // This influences the chosen option in the lookahead DFA\n    if (sep === undefined) {\n        epsilon(loop, blkStart); // loop back to start\n        epsilon(loop, end); // exit\n    }\n    else {\n        epsilon(loop, end); // exit\n        // loop back to start with separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, blkStart);\n    }\n    return {\n        left: blkStart,\n        right: end\n    };\n}\nfunction star(atn, rule, star, handle, sep) {\n    const start = handle.left;\n    const end = handle.right;\n    const entry = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_ENTRY\n    });\n    defineDecisionState(atn, entry);\n    const loopEnd = newState(atn, rule, star, {\n        type: ATN_LOOP_END\n    });\n    const loop = newState(atn, rule, star, {\n        type: ATN_STAR_LOOP_BACK\n    });\n    entry.loopback = loop;\n    loopEnd.loopback = loop;\n    epsilon(entry, start); // loop enter edge (alt 2)\n    epsilon(entry, loopEnd); // bypass loop edge (alt 1)\n    epsilon(end, loop); // block end hits loop back\n    if (sep !== undefined) {\n        epsilon(loop, loopEnd); // end loop\n        // loop back to start of handle using separator\n        epsilon(loop, sep.left);\n        epsilon(sep.right, start);\n    }\n    else {\n        epsilon(loop, entry); // loop back to entry/exit decision\n    }\n    atn.decisionMap[buildATNKey(rule, sep ? \'RepetitionWithSeparator\' : \'Repetition\', star.idx)] = entry;\n    return {\n        left: entry,\n        right: loopEnd\n    };\n}\nfunction optional(atn, rule, optional, handle) {\n    const start = handle.left;\n    const end = handle.right;\n    epsilon(start, end);\n    atn.decisionMap[buildATNKey(rule, \'Option\', optional.idx)] = start;\n    return handle;\n}\nfunction defineDecisionState(atn, state) {\n    atn.decisionStates.push(state);\n    state.decision = atn.decisionStates.length - 1;\n    return state.decision;\n}\nfunction makeAlts(atn, rule, start, production, ...alts) {\n    const end = newState(atn, rule, production, {\n        type: ATN_BLOCK_END,\n        start\n    });\n    start.end = end;\n    for (const alt of alts) {\n        if (alt !== undefined) {\n            // hook alts up to decision block\n            epsilon(start, alt.left);\n            epsilon(alt.right, end);\n        }\n        else {\n            epsilon(start, end);\n        }\n    }\n    const handle = {\n        left: start,\n        right: end\n    };\n    atn.decisionMap[buildATNKey(rule, atn_getProdType(production), production.idx)] = start;\n    return handle;\n}\nfunction atn_getProdType(production) {\n    if (production instanceof Alternation) {\n        return \'Alternation\';\n    }\n    else if (production instanceof Option) {\n        return \'Option\';\n    }\n    else if (production instanceof Repetition) {\n        return \'Repetition\';\n    }\n    else if (production instanceof RepetitionWithSeparator) {\n        return \'RepetitionWithSeparator\';\n    }\n    else if (production instanceof RepetitionMandatory) {\n        return \'RepetitionMandatory\';\n    }\n    else if (production instanceof RepetitionMandatoryWithSeparator) {\n        return \'RepetitionMandatoryWithSeparator\';\n    }\n    else {\n        throw new Error(\'Invalid production type encountered\');\n    }\n}\nfunction makeBlock(atn, alts) {\n    const altsLength = alts.length;\n    for (let i = 0; i < altsLength - 1; i++) {\n        const handle = alts[i];\n        let transition;\n        if (handle.left.transitions.length === 1) {\n            transition = handle.left.transitions[0];\n        }\n        const isRuleTransition = transition instanceof RuleTransition;\n        const ruleTransition = transition;\n        const next = alts[i + 1].left;\n        if (handle.left.type === ATN_BASIC &&\n            handle.right.type === ATN_BASIC &&\n            transition !== undefined &&\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\n                transition.target === handle.right)) {\n            // we can avoid epsilon edge to next element\n            if (isRuleTransition) {\n                ruleTransition.followState = next;\n            }\n            else {\n                transition.target = next;\n            }\n            removeState(atn, handle.right); // we skipped over this state\n        }\n        else {\n            // need epsilon if previous block\'s right end node is complex\n            epsilon(handle.right, next);\n        }\n    }\n    const first = alts[0];\n    const last = alts[altsLength - 1];\n    return {\n        left: first.left,\n        right: last.right\n    };\n}\nfunction tokenRef(atn, rule, tokenType, production) {\n    const left = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, rule, production, {\n        type: ATN_BASIC\n    });\n    addTransition(left, new AtomTransition(right, tokenType));\n    return {\n        left,\n        right\n    };\n}\nfunction ruleRef(atn, currentRule, nonTerminal) {\n    const rule = nonTerminal.referencedRule;\n    const start = atn.ruleToStartState.get(rule);\n    const left = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const right = newState(atn, currentRule, nonTerminal, {\n        type: ATN_BASIC\n    });\n    const call = new RuleTransition(start, rule, right);\n    addTransition(left, call);\n    return {\n        left,\n        right\n    };\n}\nfunction buildRuleHandle(atn, rule, block) {\n    const start = atn.ruleToStartState.get(rule);\n    epsilon(start, block.left);\n    const stop = atn.ruleToStopState.get(rule);\n    epsilon(block.right, stop);\n    const handle = {\n        left: start,\n        right: stop\n    };\n    return handle;\n}\nfunction epsilon(a, b) {\n    const transition = new EpsilonTransition(b);\n    addTransition(a, transition);\n}\nfunction newState(atn, rule, production, partial) {\n    const t = Object.assign({ atn,\n        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);\n    atn.states.push(t);\n    return t;\n}\nfunction addTransition(state, transition) {\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\n    // Because they are never mixed, only setting the property for the first transition is fine\n    if (state.transitions.length === 0) {\n        state.epsilonOnlyTransitions = transition.isEpsilon();\n    }\n    state.transitions.push(transition);\n}\nfunction removeState(atn, state) {\n    atn.states.splice(atn.states.indexOf(state), 1);\n}\n//# sourceMappingURL=atn.js.map\n;// ./node_modules/chevrotain-allstar/lib/dfa.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nconst DFA_ERROR = {};\nclass ATNConfigSet {\n    constructor() {\n        this.map = {};\n        this.configs = [];\n    }\n    get size() {\n        return this.configs.length;\n    }\n    finalize() {\n        // Empties the map to free up memory\n        this.map = {};\n    }\n    add(config) {\n        const key = getATNConfigKey(config);\n        // Only add configs which don\'t exist in our map already\n        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\n        if (!(key in this.map)) {\n            this.map[key] = this.configs.length;\n            this.configs.push(config);\n        }\n    }\n    get elements() {\n        return this.configs;\n    }\n    get alts() {\n        return (0,lodash_es_map/* default */.A)(this.configs, (e) => e.alt);\n    }\n    get key() {\n        let value = "";\n        for (const k in this.map) {\n            value += k + ":";\n        }\n        return value;\n    }\n}\nfunction getATNConfigKey(config, alt = true) {\n    return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join("_")}`;\n}\n//# sourceMappingURL=dfa.js.map\n// EXTERNAL MODULE: ./node_modules/lodash-es/min.js\nvar min = __webpack_require__(86452);\n;// ./node_modules/lodash-es/uniqBy.js\n\n\n\n/**\n * This method is like `_.uniq` except that it accepts `iteratee` which is\n * invoked for each element in `array` to generate the criterion by which\n * uniqueness is computed. The order of result values is determined by the\n * order they occur in the array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n * // => [2.1, 1.2]\n *\n * // The `_.property` iteratee shorthand.\n * _.uniqBy([{ \'x\': 1 }, { \'x\': 2 }, { \'x\': 1 }], \'x\');\n * // => [{ \'x\': 1 }, { \'x\': 2 }]\n */\nfunction uniqBy(array, iteratee) {\n  return (array && array.length) ? (0,_baseUniq/* default */.A)(array, (0,_baseIteratee/* default */.A)(iteratee, 2)) : [];\n}\n\n/* harmony default export */ const lodash_es_uniqBy = (uniqBy);\n\n;// ./node_modules/chevrotain-allstar/lib/all-star-lookahead.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\nfunction createDFACache(startState, decision) {\n    const map = {};\n    return (predicateSet) => {\n        const key = predicateSet.toString();\n        let existing = map[key];\n        if (existing !== undefined) {\n            return existing;\n        }\n        else {\n            existing = {\n                atnStartState: startState,\n                decision,\n                states: {}\n            };\n            map[key] = existing;\n            return existing;\n        }\n    };\n}\nclass PredicateSet {\n    constructor() {\n        this.predicates = [];\n    }\n    is(index) {\n        return index >= this.predicates.length || this.predicates[index];\n    }\n    set(index, value) {\n        this.predicates[index] = value;\n    }\n    toString() {\n        let value = "";\n        const size = this.predicates.length;\n        for (let i = 0; i < size; i++) {\n            value += this.predicates[i] === true ? "1" : "0";\n        }\n        return value;\n    }\n}\nconst EMPTY_PREDICATES = new PredicateSet();\nclass LLStarLookaheadStrategy extends LLkLookaheadStrategy {\n    constructor(options) {\n        var _a;\n        super();\n        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));\n    }\n    initialize(options) {\n        this.atn = createATN(options.rules);\n        this.dfas = initATNSimulator(this.atn);\n    }\n    validateAmbiguousAlternationAlternatives() {\n        return [];\n    }\n    validateEmptyOrAlternatives() {\n        return [];\n    }\n    buildLookaheadForAlternation(options) {\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, \'Alternation\', prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const partialAlts = (0,lodash_es_map/* default */.A)(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType: "Alternation",\n            rule: rule\n        }), (currAlt) => (0,lodash_es_map/* default */.A)(currAlt, (path) => path[0]));\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\n            const choiceToAlt = (0,reduce/* default */.A)(partialAlts, (result, currAlt, idx) => {\n                (0,forEach/* default */.A)(currAlt, (currTokType) => {\n                    if (currTokType) {\n                        result[currTokType.tokenTypeIdx] = idx;\n                        (0,forEach/* default */.A)(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = idx;\n                        });\n                    }\n                });\n                return result;\n            }, {});\n            if (hasPredicates) {\n                return function (orAlts) {\n                    var _a;\n                    const nextToken = this.LA(1);\n                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];\n                    if (orAlts !== undefined && prediction !== undefined) {\n                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;\n                        if (gate !== undefined && gate.call(this) === false) {\n                            return undefined;\n                        }\n                    }\n                    return prediction;\n                };\n            }\n            else {\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx];\n                };\n            }\n        }\n        else if (hasPredicates) {\n            return function (orAlts) {\n                const predicates = new PredicateSet();\n                const length = orAlts === undefined ? 0 : orAlts.length;\n                for (let i = 0; i < length; i++) {\n                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;\n                    predicates.set(i, gate === undefined || gate.call(this));\n                }\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\n                return typeof result === \'number\' ? result : undefined;\n            };\n        }\n        else {\n            return function () {\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n                return typeof result === \'number\' ? result : undefined;\n            };\n        }\n    }\n    buildLookaheadForOptional(options) {\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\n        const dfas = this.dfas;\n        const logging = this.logging;\n        const key = buildATNKey(rule, prodType, prodOccurrence);\n        const decisionState = this.atn.decisionMap[key];\n        const decisionIndex = decisionState.decision;\n        const alts = (0,lodash_es_map/* default */.A)(getLookaheadPaths({\n            maxLookahead: 1,\n            occurrence: prodOccurrence,\n            prodType,\n            rule\n        }), (e) => {\n            return (0,lodash_es_map/* default */.A)(e, (g) => g[0]);\n        });\n        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\n            const alt = alts[0];\n            const singleTokensTypes = (0,lodash_es_flatten/* default */.A)(alt);\n            if (singleTokensTypes.length === 1 &&\n                (0,isEmpty/* default */.A)(singleTokensTypes[0].categoryMatches)) {\n                const expectedTokenType = singleTokensTypes[0];\n                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;\n                return function () {\n                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\n                };\n            }\n            else {\n                const choiceToAlt = (0,reduce/* default */.A)(singleTokensTypes, (result, currTokType) => {\n                    if (currTokType !== undefined) {\n                        result[currTokType.tokenTypeIdx] = true;\n                        (0,forEach/* default */.A)(currTokType.categoryMatches, (currExtendingType) => {\n                            result[currExtendingType] = true;\n                        });\n                    }\n                    return result;\n                }, {});\n                return function () {\n                    const nextToken = this.LA(1);\n                    return choiceToAlt[nextToken.tokenTypeIdx] === true;\n                };\n            }\n        }\n        return function () {\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\n            return typeof result === "object" ? false : result === 0;\n        };\n    }\n}\nfunction isLL1Sequence(sequences, allowEmpty = true) {\n    const fullSet = new Set();\n    for (const alt of sequences) {\n        const altSet = new Set();\n        for (const tokType of alt) {\n            if (tokType === undefined) {\n                if (allowEmpty) {\n                    // Epsilon production encountered\n                    break;\n                }\n                else {\n                    return false;\n                }\n            }\n            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);\n            for (const index of indices) {\n                if (fullSet.has(index)) {\n                    if (!altSet.has(index)) {\n                        return false;\n                    }\n                }\n                else {\n                    fullSet.add(index);\n                    altSet.add(index);\n                }\n            }\n        }\n    }\n    return true;\n}\nfunction initATNSimulator(atn) {\n    const decisionLength = atn.decisionStates.length;\n    const decisionToDFA = Array(decisionLength);\n    for (let i = 0; i < decisionLength; i++) {\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);\n    }\n    return decisionToDFA;\n}\nfunction adaptivePredict(dfaCaches, decision, predicateSet, logging) {\n    const dfa = dfaCaches[decision](predicateSet);\n    let start = dfa.start;\n    if (start === undefined) {\n        const closure = computeStartState(dfa.atnStartState);\n        start = addDFAState(dfa, newDFAState(closure));\n        dfa.start = start;\n    }\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);\n    return alt;\n}\nfunction performLookahead(dfa, s0, predicateSet, logging) {\n    let previousD = s0;\n    let i = 1;\n    const path = [];\n    let t = this.LA(i++);\n    while (true) {\n        let d = getExistingTargetState(previousD, t);\n        if (d === undefined) {\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);\n        }\n        if (d === DFA_ERROR) {\n            return buildAdaptivePredictError(path, previousD, t);\n        }\n        if (d.isAcceptState === true) {\n            return d.prediction;\n        }\n        previousD = d;\n        path.push(t);\n        t = this.LA(i++);\n    }\n}\nfunction computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {\n    const reach = computeReachSet(previousD.configs, token, predicateSet);\n    if (reach.size === 0) {\n        addDFAEdge(dfa, previousD, token, DFA_ERROR);\n        return DFA_ERROR;\n    }\n    let newState = newDFAState(reach);\n    const predictedAlt = getUniqueAlt(reach, predicateSet);\n    if (predictedAlt !== undefined) {\n        newState.isAcceptState = true;\n        newState.prediction = predictedAlt;\n        newState.configs.uniqueAlt = predictedAlt;\n    }\n    else if (hasConflictTerminatingPrediction(reach)) {\n        const prediction = (0,min/* default */.A)(reach.alts);\n        newState.isAcceptState = true;\n        newState.prediction = prediction;\n        newState.configs.uniqueAlt = prediction;\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);\n    }\n    newState = addDFAEdge(dfa, previousD, token, newState);\n    return newState;\n}\nfunction reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {\n    const prefixPath = [];\n    for (let i = 1; i <= lookahead; i++) {\n        prefixPath.push(this.LA(i).tokenType);\n    }\n    const atnState = dfa.atnStartState;\n    const topLevelRule = atnState.rule;\n    const production = atnState.production;\n    const message = buildAmbiguityError({\n        topLevelRule,\n        ambiguityIndices,\n        production,\n        prefixPath\n    });\n    logging(message);\n}\nfunction buildAmbiguityError(options) {\n    const pathMsg = (0,lodash_es_map/* default */.A)(options.prefixPath, (currtok) => tokens_public_tokenLabel(currtok)).join(", ");\n    const occurrence = options.production.idx === 0 ? "" : options.production.idx;\n    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${all_star_lookahead_getProductionDslName(options.production)}${occurrence}>` +\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\n    currMessage =\n        currMessage +\n            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\n            `For Further details.`;\n    return currMessage;\n}\nfunction all_star_lookahead_getProductionDslName(prod) {\n    if (prod instanceof model_NonTerminal) {\n        return "SUBRULE";\n    }\n    else if (prod instanceof Option) {\n        return "OPTION";\n    }\n    else if (prod instanceof Alternation) {\n        return "OR";\n    }\n    else if (prod instanceof RepetitionMandatory) {\n        return "AT_LEAST_ONE";\n    }\n    else if (prod instanceof RepetitionMandatoryWithSeparator) {\n        return "AT_LEAST_ONE_SEP";\n    }\n    else if (prod instanceof RepetitionWithSeparator) {\n        return "MANY_SEP";\n    }\n    else if (prod instanceof Repetition) {\n        return "MANY";\n    }\n    else if (prod instanceof Terminal) {\n        return "CONSUME";\n    }\n    else {\n        throw Error("non exhaustive match");\n    }\n}\nfunction buildAdaptivePredictError(path, previous, current) {\n    const nextTransitions = lodash_es_flatMap(previous.configs.elements, (e) => e.state.transitions);\n    const nextTokenTypes = lodash_es_uniqBy(nextTransitions\n        .filter((e) => e instanceof AtomTransition)\n        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);\n    return {\n        actualToken: current,\n        possibleTokenTypes: nextTokenTypes,\n        tokenPath: path\n    };\n}\nfunction getExistingTargetState(state, token) {\n    return state.edges[token.tokenTypeIdx];\n}\nfunction computeReachSet(configs, token, predicateSet) {\n    const intermediate = new ATNConfigSet();\n    const skippedStopStates = [];\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === false) {\n            continue;\n        }\n        if (c.state.type === ATN_RULE_STOP) {\n            skippedStopStates.push(c);\n            continue;\n        }\n        const transitionLength = c.state.transitions.length;\n        for (let i = 0; i < transitionLength; i++) {\n            const transition = c.state.transitions[i];\n            const target = getReachableTarget(transition, token);\n            if (target !== undefined) {\n                intermediate.add({\n                    state: target,\n                    alt: c.alt,\n                    stack: c.stack\n                });\n            }\n        }\n    }\n    let reach;\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\n        reach = intermediate;\n    }\n    if (reach === undefined) {\n        reach = new ATNConfigSet();\n        for (const c of intermediate.elements) {\n            closure(c, reach);\n        }\n    }\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\n        for (const c of skippedStopStates) {\n            reach.add(c);\n        }\n    }\n    return reach;\n}\nfunction getReachableTarget(transition, token) {\n    if (transition instanceof AtomTransition &&\n        tokenMatcher(token, transition.tokenType)) {\n        return transition.target;\n    }\n    return undefined;\n}\nfunction getUniqueAlt(configs, predicateSet) {\n    let alt;\n    for (const c of configs.elements) {\n        if (predicateSet.is(c.alt) === true) {\n            if (alt === undefined) {\n                alt = c.alt;\n            }\n            else if (alt !== c.alt) {\n                return undefined;\n            }\n        }\n    }\n    return alt;\n}\nfunction newDFAState(closure) {\n    return {\n        configs: closure,\n        edges: {},\n        isAcceptState: false,\n        prediction: -1\n    };\n}\nfunction addDFAEdge(dfa, from, token, to) {\n    to = addDFAState(dfa, to);\n    from.edges[token.tokenTypeIdx] = to;\n    return to;\n}\nfunction addDFAState(dfa, state) {\n    if (state === DFA_ERROR) {\n        return state;\n    }\n    // Repetitions have the same config set\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\n    const mapKey = state.configs.key;\n    const existing = dfa.states[mapKey];\n    if (existing !== undefined) {\n        return existing;\n    }\n    state.configs.finalize();\n    dfa.states[mapKey] = state;\n    return state;\n}\nfunction computeStartState(atnState) {\n    const configs = new ATNConfigSet();\n    const numberOfTransitions = atnState.transitions.length;\n    for (let i = 0; i < numberOfTransitions; i++) {\n        const target = atnState.transitions[i].target;\n        const config = {\n            state: target,\n            alt: i,\n            stack: []\n        };\n        closure(config, configs);\n    }\n    return configs;\n}\nfunction closure(config, configs) {\n    const p = config.state;\n    if (p.type === ATN_RULE_STOP) {\n        if (config.stack.length > 0) {\n            const atnStack = [...config.stack];\n            const followState = atnStack.pop();\n            const followConfig = {\n                state: followState,\n                alt: config.alt,\n                stack: atnStack\n            };\n            closure(followConfig, configs);\n        }\n        else {\n            // Dipping into outer context, simply add the config\n            // This will stop computation once every config is at the rule stop state\n            configs.add(config);\n        }\n        return;\n    }\n    if (!p.epsilonOnlyTransitions) {\n        configs.add(config);\n    }\n    const transitionLength = p.transitions.length;\n    for (let i = 0; i < transitionLength; i++) {\n        const transition = p.transitions[i];\n        const c = getEpsilonTarget(config, transition);\n        if (c !== undefined) {\n            closure(c, configs);\n        }\n    }\n}\nfunction getEpsilonTarget(config, transition) {\n    if (transition instanceof EpsilonTransition) {\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack: config.stack\n        };\n    }\n    else if (transition instanceof RuleTransition) {\n        const stack = [...config.stack, transition.followState];\n        return {\n            state: transition.target,\n            alt: config.alt,\n            stack\n        };\n    }\n    return undefined;\n}\nfunction hasConfigInRuleStopState(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type === ATN_RULE_STOP) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction allConfigsInRuleStopStates(configs) {\n    for (const c of configs.elements) {\n        if (c.state.type !== ATN_RULE_STOP) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction hasConflictTerminatingPrediction(configs) {\n    if (allConfigsInRuleStopStates(configs)) {\n        return true;\n    }\n    const altSets = getConflictingAltSets(configs.elements);\n    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);\n    return heuristic;\n}\nfunction getConflictingAltSets(configs) {\n    const configToAlts = new Map();\n    for (const c of configs) {\n        const key = getATNConfigKey(c, false);\n        let alts = configToAlts.get(key);\n        if (alts === undefined) {\n            alts = {};\n            configToAlts.set(key, alts);\n        }\n        alts[c.alt] = true;\n    }\n    return configToAlts;\n}\nfunction hasConflictingAltSet(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length > 1) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction hasStateAssociatedWithOneAlt(altSets) {\n    for (const value of Array.from(altSets.values())) {\n        if (Object.keys(value).length === 1) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=all-star-lookahead.js.map\n;// ./node_modules/chevrotain-allstar/lib/index.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/vscode-languageserver-types/lib/esm/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nvar DocumentUri;\n(function (DocumentUri) {\n    function is(value) {\n        return typeof value === \'string\';\n    }\n    DocumentUri.is = is;\n})(DocumentUri || (DocumentUri = {}));\nvar URI;\n(function (URI) {\n    function is(value) {\n        return typeof value === \'string\';\n    }\n    URI.is = is;\n})(URI || (URI = {}));\nvar integer;\n(function (integer) {\n    integer.MIN_VALUE = -2147483648;\n    integer.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \'number\' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\n    }\n    integer.is = is;\n})(integer || (integer = {}));\nvar uinteger;\n(function (uinteger) {\n    uinteger.MIN_VALUE = 0;\n    uinteger.MAX_VALUE = 2147483647;\n    function is(value) {\n        return typeof value === \'number\' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\n    }\n    uinteger.is = is;\n})(uinteger || (uinteger = {}));\n/**\n * The Position namespace provides helper functions to work with\n * {@link Position} literals.\n */\nvar Position;\n(function (Position) {\n    /**\n     * Creates a new Position literal from the given line and character.\n     * @param line The position\'s line.\n     * @param character The position\'s character.\n     */\n    function create(line, character) {\n        if (line === Number.MAX_VALUE) {\n            line = uinteger.MAX_VALUE;\n        }\n        if (character === Number.MAX_VALUE) {\n            character = uinteger.MAX_VALUE;\n        }\n        return { line, character };\n    }\n    Position.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Position} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\n    }\n    Position.is = is;\n})(Position || (Position = {}));\n/**\n * The Range namespace provides helper functions to work with\n * {@link Range} literals.\n */\nvar Range;\n(function (Range) {\n    function create(one, two, three, four) {\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\n            return { start: Position.create(one, two), end: Position.create(three, four) };\n        }\n        else if (Position.is(one) && Position.is(two)) {\n            return { start: one, end: two };\n        }\n        else {\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\n        }\n    }\n    Range.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Range} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\n    }\n    Range.is = is;\n})(Range || (Range = {}));\n/**\n * The Location namespace provides helper functions to work with\n * {@link Location} literals.\n */\nvar Location;\n(function (Location) {\n    /**\n     * Creates a Location literal.\n     * @param uri The location\'s uri.\n     * @param range The location\'s range.\n     */\n    function create(uri, range) {\n        return { uri, range };\n    }\n    Location.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Location} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\n    }\n    Location.is = is;\n})(Location || (Location = {}));\n/**\n * The LocationLink namespace provides helper functions to work with\n * {@link LocationLink} literals.\n */\nvar LocationLink;\n(function (LocationLink) {\n    /**\n     * Creates a LocationLink literal.\n     * @param targetUri The definition\'s uri.\n     * @param targetRange The full range of the definition.\n     * @param targetSelectionRange The span of the symbol definition at the target.\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\n     */\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\n    }\n    LocationLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\n            && Range.is(candidate.targetSelectionRange)\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\n    }\n    LocationLink.is = is;\n})(LocationLink || (LocationLink = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link Color} literals.\n */\nvar Color;\n(function (Color) {\n    /**\n     * Creates a new Color literal.\n     */\n    function create(red, green, blue, alpha) {\n        return {\n            red,\n            green,\n            blue,\n            alpha,\n        };\n    }\n    Color.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Color} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\n            && Is.numberRange(candidate.green, 0, 1)\n            && Is.numberRange(candidate.blue, 0, 1)\n            && Is.numberRange(candidate.alpha, 0, 1);\n    }\n    Color.is = is;\n})(Color || (Color = {}));\n/**\n * The ColorInformation namespace provides helper functions to work with\n * {@link ColorInformation} literals.\n */\nvar ColorInformation;\n(function (ColorInformation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(range, color) {\n        return {\n            range,\n            color,\n        };\n    }\n    ColorInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\n    }\n    ColorInformation.is = is;\n})(ColorInformation || (ColorInformation = {}));\n/**\n * The Color namespace provides helper functions to work with\n * {@link ColorPresentation} literals.\n */\nvar ColorPresentation;\n(function (ColorPresentation) {\n    /**\n     * Creates a new ColorInformation literal.\n     */\n    function create(label, textEdit, additionalTextEdits) {\n        return {\n            label,\n            textEdit,\n            additionalTextEdits,\n        };\n    }\n    ColorPresentation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\n    }\n    ColorPresentation.is = is;\n})(ColorPresentation || (ColorPresentation = {}));\n/**\n * A set of predefined range kinds.\n */\nvar FoldingRangeKind;\n(function (FoldingRangeKind) {\n    /**\n     * Folding range for a comment\n     */\n    FoldingRangeKind.Comment = \'comment\';\n    /**\n     * Folding range for an import or include\n     */\n    FoldingRangeKind.Imports = \'imports\';\n    /**\n     * Folding range for a region (e.g. `#region`)\n     */\n    FoldingRangeKind.Region = \'region\';\n})(FoldingRangeKind || (FoldingRangeKind = {}));\n/**\n * The folding range namespace provides helper functions to work with\n * {@link FoldingRange} literals.\n */\nvar FoldingRange;\n(function (FoldingRange) {\n    /**\n     * Creates a new FoldingRange literal.\n     */\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\n        const result = {\n            startLine,\n            endLine\n        };\n        if (Is.defined(startCharacter)) {\n            result.startCharacter = startCharacter;\n        }\n        if (Is.defined(endCharacter)) {\n            result.endCharacter = endCharacter;\n        }\n        if (Is.defined(kind)) {\n            result.kind = kind;\n        }\n        if (Is.defined(collapsedText)) {\n            result.collapsedText = collapsedText;\n        }\n        return result;\n    }\n    FoldingRange.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\n    }\n    FoldingRange.is = is;\n})(FoldingRange || (FoldingRange = {}));\n/**\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\n * {@link DiagnosticRelatedInformation} literals.\n */\nvar DiagnosticRelatedInformation;\n(function (DiagnosticRelatedInformation) {\n    /**\n     * Creates a new DiagnosticRelatedInformation literal.\n     */\n    function create(location, message) {\n        return {\n            location,\n            message\n        };\n    }\n    DiagnosticRelatedInformation.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\n    }\n    DiagnosticRelatedInformation.is = is;\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\n/**\n * The diagnostic\'s severity.\n */\nvar DiagnosticSeverity;\n(function (DiagnosticSeverity) {\n    /**\n     * Reports an error.\n     */\n    DiagnosticSeverity.Error = 1;\n    /**\n     * Reports a warning.\n     */\n    DiagnosticSeverity.Warning = 2;\n    /**\n     * Reports an information.\n     */\n    DiagnosticSeverity.Information = 3;\n    /**\n     * Reports a hint.\n     */\n    DiagnosticSeverity.Hint = 4;\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\n/**\n * The diagnostic tags.\n *\n * @since 3.15.0\n */\nvar DiagnosticTag;\n(function (DiagnosticTag) {\n    /**\n     * Unused or unnecessary code.\n     *\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\n     * an error squiggle.\n     */\n    DiagnosticTag.Unnecessary = 1;\n    /**\n     * Deprecated or obsolete code.\n     *\n     * Clients are allowed to rendered diagnostics with this tag strike through.\n     */\n    DiagnosticTag.Deprecated = 2;\n})(DiagnosticTag || (DiagnosticTag = {}));\n/**\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\n *\n * @since 3.16.0\n */\nvar CodeDescription;\n(function (CodeDescription) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\n    }\n    CodeDescription.is = is;\n})(CodeDescription || (CodeDescription = {}));\n/**\n * The Diagnostic namespace provides helper functions to work with\n * {@link Diagnostic} literals.\n */\nvar Diagnostic;\n(function (Diagnostic) {\n    /**\n     * Creates a new Diagnostic literal.\n     */\n    function create(range, message, severity, code, source, relatedInformation) {\n        let result = { range, message };\n        if (Is.defined(severity)) {\n            result.severity = severity;\n        }\n        if (Is.defined(code)) {\n            result.code = code;\n        }\n        if (Is.defined(source)) {\n            result.source = source;\n        }\n        if (Is.defined(relatedInformation)) {\n            result.relatedInformation = relatedInformation;\n        }\n        return result;\n    }\n    Diagnostic.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\n     */\n    function is(value) {\n        var _a;\n        let candidate = value;\n        return Is.defined(candidate)\n            && Range.is(candidate.range)\n            && Is.string(candidate.message)\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\n    }\n    Diagnostic.is = is;\n})(Diagnostic || (Diagnostic = {}));\n/**\n * The Command namespace provides helper functions to work with\n * {@link Command} literals.\n */\nvar Command;\n(function (Command) {\n    /**\n     * Creates a new Command literal.\n     */\n    function create(title, command, ...args) {\n        let result = { title, command };\n        if (Is.defined(args) && args.length > 0) {\n            result.arguments = args;\n        }\n        return result;\n    }\n    Command.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link Command} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\n    }\n    Command.is = is;\n})(Command || (Command = {}));\n/**\n * The TextEdit namespace provides helper function to create replace,\n * insert and delete edits more easily.\n */\nvar TextEdit;\n(function (TextEdit) {\n    /**\n     * Creates a replace text edit.\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     */\n    function replace(range, newText) {\n        return { range, newText };\n    }\n    TextEdit.replace = replace;\n    /**\n     * Creates an insert text edit.\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     */\n    function insert(position, newText) {\n        return { range: { start: position, end: position }, newText };\n    }\n    TextEdit.insert = insert;\n    /**\n     * Creates a delete text edit.\n     * @param range The range of text to be deleted.\n     */\n    function del(range) {\n        return { range, newText: \'\' };\n    }\n    TextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && Is.string(candidate.newText)\n            && Range.is(candidate.range);\n    }\n    TextEdit.is = is;\n})(TextEdit || (TextEdit = {}));\nvar ChangeAnnotation;\n(function (ChangeAnnotation) {\n    function create(label, needsConfirmation, description) {\n        const result = { label };\n        if (needsConfirmation !== undefined) {\n            result.needsConfirmation = needsConfirmation;\n        }\n        if (description !== undefined) {\n            result.description = description;\n        }\n        return result;\n    }\n    ChangeAnnotation.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    ChangeAnnotation.is = is;\n})(ChangeAnnotation || (ChangeAnnotation = {}));\nvar ChangeAnnotationIdentifier;\n(function (ChangeAnnotationIdentifier) {\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate);\n    }\n    ChangeAnnotationIdentifier.is = is;\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\nvar AnnotatedTextEdit;\n(function (AnnotatedTextEdit) {\n    /**\n     * Creates an annotated replace text edit.\n     *\n     * @param range The range of text to be replaced.\n     * @param newText The new text.\n     * @param annotation The annotation.\n     */\n    function replace(range, newText, annotation) {\n        return { range, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.replace = replace;\n    /**\n     * Creates an annotated insert text edit.\n     *\n     * @param position The position to insert the text at.\n     * @param newText The text to be inserted.\n     * @param annotation The annotation.\n     */\n    function insert(position, newText, annotation) {\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\n    }\n    AnnotatedTextEdit.insert = insert;\n    /**\n     * Creates an annotated delete text edit.\n     *\n     * @param range The range of text to be deleted.\n     * @param annotation The annotation.\n     */\n    function del(range, annotation) {\n        return { range, newText: \'\', annotationId: annotation };\n    }\n    AnnotatedTextEdit.del = del;\n    function is(value) {\n        const candidate = value;\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    AnnotatedTextEdit.is = is;\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\n/**\n * The TextDocumentEdit namespace provides helper function to create\n * an edit that manipulates a text document.\n */\nvar TextDocumentEdit;\n(function (TextDocumentEdit) {\n    /**\n     * Creates a new `TextDocumentEdit`\n     */\n    function create(textDocument, edits) {\n        return { textDocument, edits };\n    }\n    TextDocumentEdit.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate)\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\n            && Array.isArray(candidate.edits);\n    }\n    TextDocumentEdit.is = is;\n})(TextDocumentEdit || (TextDocumentEdit = {}));\nvar CreateFile;\n(function (CreateFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \'create\',\n            uri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    CreateFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \'create\' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    CreateFile.is = is;\n})(CreateFile || (CreateFile = {}));\nvar RenameFile;\n(function (RenameFile) {\n    function create(oldUri, newUri, options, annotation) {\n        let result = {\n            kind: \'rename\',\n            oldUri,\n            newUri\n        };\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    RenameFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \'rename\' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    RenameFile.is = is;\n})(RenameFile || (RenameFile = {}));\nvar DeleteFile;\n(function (DeleteFile) {\n    function create(uri, options, annotation) {\n        let result = {\n            kind: \'delete\',\n            uri\n        };\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\n            result.options = options;\n        }\n        if (annotation !== undefined) {\n            result.annotationId = annotation;\n        }\n        return result;\n    }\n    DeleteFile.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && candidate.kind === \'delete\' && Is.string(candidate.uri) && (candidate.options === undefined ||\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\n    }\n    DeleteFile.is = is;\n})(DeleteFile || (DeleteFile = {}));\nvar WorkspaceEdit;\n(function (WorkspaceEdit) {\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\n                if (Is.string(change.kind)) {\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\n                }\n                else {\n                    return TextDocumentEdit.is(change);\n                }\n            }));\n    }\n    WorkspaceEdit.is = is;\n})(WorkspaceEdit || (WorkspaceEdit = {}));\nclass TextEditChangeImpl {\n    constructor(edits, changeAnnotations) {\n        this.edits = edits;\n        this.changeAnnotations = changeAnnotations;\n    }\n    insert(position, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.insert(position, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.insert(position, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    replace(range, newText, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.replace(range, newText);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.replace(range, newText, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    delete(range, annotation) {\n        let edit;\n        let id;\n        if (annotation === undefined) {\n            edit = TextEdit.del(range);\n        }\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\n            id = annotation;\n            edit = AnnotatedTextEdit.del(range, annotation);\n        }\n        else {\n            this.assertChangeAnnotations(this.changeAnnotations);\n            id = this.changeAnnotations.manage(annotation);\n            edit = AnnotatedTextEdit.del(range, id);\n        }\n        this.edits.push(edit);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    add(edit) {\n        this.edits.push(edit);\n    }\n    all() {\n        return this.edits;\n    }\n    clear() {\n        this.edits.splice(0, this.edits.length);\n    }\n    assertChangeAnnotations(value) {\n        if (value === undefined) {\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\n        }\n    }\n}\n/**\n * A helper class\n */\nclass ChangeAnnotations {\n    constructor(annotations) {\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\n        this._counter = 0;\n        this._size = 0;\n    }\n    all() {\n        return this._annotations;\n    }\n    get size() {\n        return this._size;\n    }\n    manage(idOrAnnotation, annotation) {\n        let id;\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\n            id = idOrAnnotation;\n        }\n        else {\n            id = this.nextId();\n            annotation = idOrAnnotation;\n        }\n        if (this._annotations[id] !== undefined) {\n            throw new Error(`Id ${id} is already in use.`);\n        }\n        if (annotation === undefined) {\n            throw new Error(`No annotation provided for id ${id}`);\n        }\n        this._annotations[id] = annotation;\n        this._size++;\n        return id;\n    }\n    nextId() {\n        this._counter++;\n        return this._counter.toString();\n    }\n}\n/**\n * A workspace change helps constructing changes to a workspace.\n */\nclass WorkspaceChange {\n    constructor(workspaceEdit) {\n        this._textEditChanges = Object.create(null);\n        if (workspaceEdit !== undefined) {\n            this._workspaceEdit = workspaceEdit;\n            if (workspaceEdit.documentChanges) {\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n                workspaceEdit.documentChanges.forEach((change) => {\n                    if (TextDocumentEdit.is(change)) {\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\n                    }\n                });\n            }\n            else if (workspaceEdit.changes) {\n                Object.keys(workspaceEdit.changes).forEach((key) => {\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\n                    this._textEditChanges[key] = textEditChange;\n                });\n            }\n        }\n        else {\n            this._workspaceEdit = {};\n        }\n    }\n    /**\n     * Returns the underlying {@link WorkspaceEdit} literal\n     * use to be returned from a workspace edit operation like rename.\n     */\n    get edit() {\n        this.initDocumentChanges();\n        if (this._changeAnnotations !== undefined) {\n            if (this._changeAnnotations.size === 0) {\n                this._workspaceEdit.changeAnnotations = undefined;\n            }\n            else {\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n            }\n        }\n        return this._workspaceEdit;\n    }\n    getTextEditChange(key) {\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\n            this.initDocumentChanges();\n            if (this._workspaceEdit.documentChanges === undefined) {\n                throw new Error(\'Workspace edit is not configured for document changes.\');\n            }\n            const textDocument = { uri: key.uri, version: key.version };\n            let result = this._textEditChanges[textDocument.uri];\n            if (!result) {\n                const edits = [];\n                const textDocumentEdit = {\n                    textDocument,\n                    edits\n                };\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\n                this._textEditChanges[textDocument.uri] = result;\n            }\n            return result;\n        }\n        else {\n            this.initChanges();\n            if (this._workspaceEdit.changes === undefined) {\n                throw new Error(\'Workspace edit is not configured for normal text edit changes.\');\n            }\n            let result = this._textEditChanges[key];\n            if (!result) {\n                let edits = [];\n                this._workspaceEdit.changes[key] = edits;\n                result = new TextEditChangeImpl(edits);\n                this._textEditChanges[key] = result;\n            }\n            return result;\n        }\n    }\n    initDocumentChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._changeAnnotations = new ChangeAnnotations();\n            this._workspaceEdit.documentChanges = [];\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\n        }\n    }\n    initChanges() {\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\n            this._workspaceEdit.changes = Object.create(null);\n        }\n    }\n    createFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = CreateFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = CreateFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = RenameFile.create(oldUri, newUri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = RenameFile.create(oldUri, newUri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n    deleteFile(uri, optionsOrAnnotation, options) {\n        this.initDocumentChanges();\n        if (this._workspaceEdit.documentChanges === undefined) {\n            throw new Error(\'Workspace edit is not configured for document changes.\');\n        }\n        let annotation;\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\n            annotation = optionsOrAnnotation;\n        }\n        else {\n            options = optionsOrAnnotation;\n        }\n        let operation;\n        let id;\n        if (annotation === undefined) {\n            operation = DeleteFile.create(uri, options);\n        }\n        else {\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\n            operation = DeleteFile.create(uri, options, id);\n        }\n        this._workspaceEdit.documentChanges.push(operation);\n        if (id !== undefined) {\n            return id;\n        }\n    }\n}\n/**\n * The TextDocumentIdentifier namespace provides helper functions to work with\n * {@link TextDocumentIdentifier} literals.\n */\nvar TextDocumentIdentifier;\n(function (TextDocumentIdentifier) {\n    /**\n     * Creates a new TextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     */\n    function create(uri) {\n        return { uri };\n    }\n    TextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri);\n    }\n    TextDocumentIdentifier.is = is;\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\n/**\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link VersionedTextDocumentIdentifier} literals.\n */\nvar VersionedTextDocumentIdentifier;\n(function (VersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new VersionedTextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     * @param version The document\'s version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    VersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\n    }\n    VersionedTextDocumentIdentifier.is = is;\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\n/**\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\n */\nvar OptionalVersionedTextDocumentIdentifier;\n(function (OptionalVersionedTextDocumentIdentifier) {\n    /**\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\n     * @param uri The document\'s uri.\n     * @param version The document\'s version.\n     */\n    function create(uri, version) {\n        return { uri, version };\n    }\n    OptionalVersionedTextDocumentIdentifier.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\n    }\n    OptionalVersionedTextDocumentIdentifier.is = is;\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\n/**\n * The TextDocumentItem namespace provides helper functions to work with\n * {@link TextDocumentItem} literals.\n */\nvar TextDocumentItem;\n(function (TextDocumentItem) {\n    /**\n     * Creates a new TextDocumentItem literal.\n     * @param uri The document\'s uri.\n     * @param languageId The document\'s language identifier.\n     * @param version The document\'s version number.\n     * @param text The document\'s text.\n     */\n    function create(uri, languageId, version, text) {\n        return { uri, languageId, version, text };\n    }\n    TextDocumentItem.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\n    }\n    TextDocumentItem.is = is;\n})(TextDocumentItem || (TextDocumentItem = {}));\n/**\n * Describes the content type that a client supports in various\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\n *\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\n * are reserved for internal usage.\n */\nvar MarkupKind;\n(function (MarkupKind) {\n    /**\n     * Plain text is supported as a content format\n     */\n    MarkupKind.PlainText = \'plaintext\';\n    /**\n     * Markdown is supported as a content format\n     */\n    MarkupKind.Markdown = \'markdown\';\n    /**\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\n    }\n    MarkupKind.is = is;\n})(MarkupKind || (MarkupKind = {}));\nvar MarkupContent;\n(function (MarkupContent) {\n    /**\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\n    }\n    MarkupContent.is = is;\n})(MarkupContent || (MarkupContent = {}));\n/**\n * The kind of a completion entry.\n */\nvar CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind.Text = 1;\n    CompletionItemKind.Method = 2;\n    CompletionItemKind.Function = 3;\n    CompletionItemKind.Constructor = 4;\n    CompletionItemKind.Field = 5;\n    CompletionItemKind.Variable = 6;\n    CompletionItemKind.Class = 7;\n    CompletionItemKind.Interface = 8;\n    CompletionItemKind.Module = 9;\n    CompletionItemKind.Property = 10;\n    CompletionItemKind.Unit = 11;\n    CompletionItemKind.Value = 12;\n    CompletionItemKind.Enum = 13;\n    CompletionItemKind.Keyword = 14;\n    CompletionItemKind.Snippet = 15;\n    CompletionItemKind.Color = 16;\n    CompletionItemKind.File = 17;\n    CompletionItemKind.Reference = 18;\n    CompletionItemKind.Folder = 19;\n    CompletionItemKind.EnumMember = 20;\n    CompletionItemKind.Constant = 21;\n    CompletionItemKind.Struct = 22;\n    CompletionItemKind.Event = 23;\n    CompletionItemKind.Operator = 24;\n    CompletionItemKind.TypeParameter = 25;\n})(CompletionItemKind || (CompletionItemKind = {}));\n/**\n * Defines whether the insert text in a completion item should be interpreted as\n * plain text or a snippet.\n */\nvar InsertTextFormat;\n(function (InsertTextFormat) {\n    /**\n     * The primary text to be inserted is treated as a plain string.\n     */\n    InsertTextFormat.PlainText = 1;\n    /**\n     * The primary text to be inserted is treated as a snippet.\n     *\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\n     * the end of the snippet. Placeholders with equal identifiers are linked,\n     * that is typing in one will update others too.\n     *\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\n     */\n    InsertTextFormat.Snippet = 2;\n})(InsertTextFormat || (InsertTextFormat = {}));\n/**\n * Completion item tags are extra annotations that tweak the rendering of a completion\n * item.\n *\n * @since 3.15.0\n */\nvar CompletionItemTag;\n(function (CompletionItemTag) {\n    /**\n     * Render a completion as obsolete, usually using a strike-out.\n     */\n    CompletionItemTag.Deprecated = 1;\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\n *\n * @since 3.16.0\n */\nvar InsertReplaceEdit;\n(function (InsertReplaceEdit) {\n    /**\n     * Creates a new insert / replace edit\n     */\n    function create(newText, insert, replace) {\n        return { newText, insert, replace };\n    }\n    InsertReplaceEdit.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\n    }\n    InsertReplaceEdit.is = is;\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\n/**\n * How whitespace and indentation is handled during completion\n * item insertion.\n *\n * @since 3.16.0\n */\nvar InsertTextMode;\n(function (InsertTextMode) {\n    /**\n     * The insertion or replace strings is taken as it is. If the\n     * value is multi line the lines below the cursor will be\n     * inserted using the indentation defined in the string value.\n     * The client will not apply any kind of adjustments to the\n     * string.\n     */\n    InsertTextMode.asIs = 1;\n    /**\n     * The editor adjusts leading whitespace of new lines so that\n     * they match the indentation up to the cursor of the line for\n     * which the item is accepted.\n     *\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\n     * multi line completion item is indented using 2 tabs and all\n     * following lines inserted will be indented using 2 tabs as well.\n     */\n    InsertTextMode.adjustIndentation = 2;\n})(InsertTextMode || (InsertTextMode = {}));\nvar CompletionItemLabelDetails;\n(function (CompletionItemLabelDetails) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\n            (Is.string(candidate.description) || candidate.description === undefined);\n    }\n    CompletionItemLabelDetails.is = is;\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\n/**\n * The CompletionItem namespace provides functions to deal with\n * completion items.\n */\nvar CompletionItem;\n(function (CompletionItem) {\n    /**\n     * Create a completion item and seed it with a label.\n     * @param label The completion item\'s label\n     */\n    function create(label) {\n        return { label };\n    }\n    CompletionItem.create = create;\n})(CompletionItem || (CompletionItem = {}));\n/**\n * The CompletionList namespace provides functions to deal with\n * completion lists.\n */\nvar CompletionList;\n(function (CompletionList) {\n    /**\n     * Creates a new completion list.\n     *\n     * @param items The completion items.\n     * @param isIncomplete The list is not complete.\n     */\n    function create(items, isIncomplete) {\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\n    }\n    CompletionList.create = create;\n})(CompletionList || (CompletionList = {}));\nvar MarkedString;\n(function (MarkedString) {\n    /**\n     * Creates a marked string from plain text.\n     *\n     * @param plainText The plain text.\n     */\n    function fromPlainText(plainText) {\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \'\\\\$&\'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    }\n    MarkedString.fromPlainText = fromPlainText;\n    /**\n     * Checks whether the given value conforms to the {@link MarkedString} type.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\n    }\n    MarkedString.is = is;\n})(MarkedString || (MarkedString = {}));\nvar Hover;\n(function (Hover) {\n    /**\n     * Checks whether the given value conforms to the {@link Hover} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\n            MarkedString.is(candidate.contents) ||\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\n    }\n    Hover.is = is;\n})(Hover || (Hover = {}));\n/**\n * The ParameterInformation namespace provides helper functions to work with\n * {@link ParameterInformation} literals.\n */\nvar ParameterInformation;\n(function (ParameterInformation) {\n    /**\n     * Creates a new parameter information literal.\n     *\n     * @param label A label string.\n     * @param documentation A doc string.\n     */\n    function create(label, documentation) {\n        return documentation ? { label, documentation } : { label };\n    }\n    ParameterInformation.create = create;\n})(ParameterInformation || (ParameterInformation = {}));\n/**\n * The SignatureInformation namespace provides helper functions to work with\n * {@link SignatureInformation} literals.\n */\nvar SignatureInformation;\n(function (SignatureInformation) {\n    function create(label, documentation, ...parameters) {\n        let result = { label };\n        if (Is.defined(documentation)) {\n            result.documentation = documentation;\n        }\n        if (Is.defined(parameters)) {\n            result.parameters = parameters;\n        }\n        else {\n            result.parameters = [];\n        }\n        return result;\n    }\n    SignatureInformation.create = create;\n})(SignatureInformation || (SignatureInformation = {}));\n/**\n * A document highlight kind.\n */\nvar DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind.Text = 1;\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind.Read = 2;\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind.Write = 3;\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * DocumentHighlight namespace to provide helper functions to work with\n * {@link DocumentHighlight} literals.\n */\nvar DocumentHighlight;\n(function (DocumentHighlight) {\n    /**\n     * Create a DocumentHighlight object.\n     * @param range The range the highlight applies to.\n     * @param kind The highlight kind\n     */\n    function create(range, kind) {\n        let result = { range };\n        if (Is.number(kind)) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    DocumentHighlight.create = create;\n})(DocumentHighlight || (DocumentHighlight = {}));\n/**\n * A symbol kind.\n */\nvar SymbolKind;\n(function (SymbolKind) {\n    SymbolKind.File = 1;\n    SymbolKind.Module = 2;\n    SymbolKind.Namespace = 3;\n    SymbolKind.Package = 4;\n    SymbolKind.Class = 5;\n    SymbolKind.Method = 6;\n    SymbolKind.Property = 7;\n    SymbolKind.Field = 8;\n    SymbolKind.Constructor = 9;\n    SymbolKind.Enum = 10;\n    SymbolKind.Interface = 11;\n    SymbolKind.Function = 12;\n    SymbolKind.Variable = 13;\n    SymbolKind.Constant = 14;\n    SymbolKind.String = 15;\n    SymbolKind.Number = 16;\n    SymbolKind.Boolean = 17;\n    SymbolKind.Array = 18;\n    SymbolKind.Object = 19;\n    SymbolKind.Key = 20;\n    SymbolKind.Null = 21;\n    SymbolKind.EnumMember = 22;\n    SymbolKind.Struct = 23;\n    SymbolKind.Event = 24;\n    SymbolKind.Operator = 25;\n    SymbolKind.TypeParameter = 26;\n})(SymbolKind || (SymbolKind = {}));\n/**\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\n *\n * @since 3.16\n */\nvar SymbolTag;\n(function (SymbolTag) {\n    /**\n     * Render a symbol as obsolete, usually using a strike-out.\n     */\n    SymbolTag.Deprecated = 1;\n})(SymbolTag || (SymbolTag = {}));\nvar SymbolInformation;\n(function (SymbolInformation) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the location of the symbol.\n     * @param uri The resource of the location of symbol.\n     * @param containerName The name of the symbol containing the symbol.\n     */\n    function create(name, kind, range, uri, containerName) {\n        let result = {\n            name,\n            kind,\n            location: { uri, range }\n        };\n        if (containerName) {\n            result.containerName = containerName;\n        }\n        return result;\n    }\n    SymbolInformation.create = create;\n})(SymbolInformation || (SymbolInformation = {}));\nvar WorkspaceSymbol;\n(function (WorkspaceSymbol) {\n    /**\n     * Create a new workspace symbol.\n     *\n     * @param name The name of the symbol.\n     * @param kind The kind of the symbol.\n     * @param uri The resource of the location of the symbol.\n     * @param range An options range of the location.\n     * @returns A WorkspaceSymbol.\n     */\n    function create(name, kind, uri, range) {\n        return range !== undefined\n            ? { name, kind, location: { uri, range } }\n            : { name, kind, location: { uri } };\n    }\n    WorkspaceSymbol.create = create;\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\nvar DocumentSymbol;\n(function (DocumentSymbol) {\n    /**\n     * Creates a new symbol information literal.\n     *\n     * @param name The name of the symbol.\n     * @param detail The detail of the symbol.\n     * @param kind The kind of the symbol.\n     * @param range The range of the symbol.\n     * @param selectionRange The selectionRange of the symbol.\n     * @param children Children of the symbol.\n     */\n    function create(name, detail, kind, range, selectionRange, children) {\n        let result = {\n            name,\n            detail,\n            kind,\n            range,\n            selectionRange\n        };\n        if (children !== undefined) {\n            result.children = children;\n        }\n        return result;\n    }\n    DocumentSymbol.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return candidate &&\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\n    }\n    DocumentSymbol.is = is;\n})(DocumentSymbol || (DocumentSymbol = {}));\n/**\n * A set of predefined code action kinds\n */\nvar CodeActionKind;\n(function (CodeActionKind) {\n    /**\n     * Empty kind.\n     */\n    CodeActionKind.Empty = \'\';\n    /**\n     * Base kind for quickfix actions: \'quickfix\'\n     */\n    CodeActionKind.QuickFix = \'quickfix\';\n    /**\n     * Base kind for refactoring actions: \'refactor\'\n     */\n    CodeActionKind.Refactor = \'refactor\';\n    /**\n     * Base kind for refactoring extraction actions: \'refactor.extract\'\n     *\n     * Example extract actions:\n     *\n     * - Extract method\n     * - Extract function\n     * - Extract variable\n     * - Extract interface from class\n     * - ...\n     */\n    CodeActionKind.RefactorExtract = \'refactor.extract\';\n    /**\n     * Base kind for refactoring inline actions: \'refactor.inline\'\n     *\n     * Example inline actions:\n     *\n     * - Inline function\n     * - Inline variable\n     * - Inline constant\n     * - ...\n     */\n    CodeActionKind.RefactorInline = \'refactor.inline\';\n    /**\n     * Base kind for refactoring rewrite actions: \'refactor.rewrite\'\n     *\n     * Example rewrite actions:\n     *\n     * - Convert JavaScript function to class\n     * - Add or remove parameter\n     * - Encapsulate field\n     * - Make method static\n     * - Move method to base class\n     * - ...\n     */\n    CodeActionKind.RefactorRewrite = \'refactor.rewrite\';\n    /**\n     * Base kind for source actions: `source`\n     *\n     * Source code actions apply to the entire file.\n     */\n    CodeActionKind.Source = \'source\';\n    /**\n     * Base kind for an organize imports source action: `source.organizeImports`\n     */\n    CodeActionKind.SourceOrganizeImports = \'source.organizeImports\';\n    /**\n     * Base kind for auto-fix source actions: `source.fixAll`.\n     *\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\n     *\n     * @since 3.15.0\n     */\n    CodeActionKind.SourceFixAll = \'source.fixAll\';\n})(CodeActionKind || (CodeActionKind = {}));\n/**\n * The reason why code actions were requested.\n *\n * @since 3.17.0\n */\nvar CodeActionTriggerKind;\n(function (CodeActionTriggerKind) {\n    /**\n     * Code actions were explicitly requested by the user or by an extension.\n     */\n    CodeActionTriggerKind.Invoked = 1;\n    /**\n     * Code actions were requested automatically.\n     *\n     * This typically happens when current selection in a file changes, but can\n     * also be triggered when file content changes.\n     */\n    CodeActionTriggerKind.Automatic = 2;\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\n/**\n * The CodeActionContext namespace provides helper functions to work with\n * {@link CodeActionContext} literals.\n */\nvar CodeActionContext;\n(function (CodeActionContext) {\n    /**\n     * Creates a new CodeActionContext literal.\n     */\n    function create(diagnostics, only, triggerKind) {\n        let result = { diagnostics };\n        if (only !== undefined && only !== null) {\n            result.only = only;\n        }\n        if (triggerKind !== undefined && triggerKind !== null) {\n            result.triggerKind = triggerKind;\n        }\n        return result;\n    }\n    CodeActionContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\n    }\n    CodeActionContext.is = is;\n})(CodeActionContext || (CodeActionContext = {}));\nvar CodeAction;\n(function (CodeAction) {\n    function create(title, kindOrCommandOrEdit, kind) {\n        let result = { title };\n        let checkKind = true;\n        if (typeof kindOrCommandOrEdit === \'string\') {\n            checkKind = false;\n            result.kind = kindOrCommandOrEdit;\n        }\n        else if (Command.is(kindOrCommandOrEdit)) {\n            result.command = kindOrCommandOrEdit;\n        }\n        else {\n            result.edit = kindOrCommandOrEdit;\n        }\n        if (checkKind && kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    CodeAction.create = create;\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.string(candidate.title) &&\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\n            (candidate.command === undefined || Command.is(candidate.command)) &&\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\n    }\n    CodeAction.is = is;\n})(CodeAction || (CodeAction = {}));\n/**\n * The CodeLens namespace provides helper functions to work with\n * {@link CodeLens} literals.\n */\nvar CodeLens;\n(function (CodeLens) {\n    /**\n     * Creates a new CodeLens literal.\n     */\n    function create(range, data) {\n        let result = { range };\n        if (Is.defined(data)) {\n            result.data = data;\n        }\n        return result;\n    }\n    CodeLens.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\n    }\n    CodeLens.is = is;\n})(CodeLens || (CodeLens = {}));\n/**\n * The FormattingOptions namespace provides helper functions to work with\n * {@link FormattingOptions} literals.\n */\nvar FormattingOptions;\n(function (FormattingOptions) {\n    /**\n     * Creates a new FormattingOptions literal.\n     */\n    function create(tabSize, insertSpaces) {\n        return { tabSize, insertSpaces };\n    }\n    FormattingOptions.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\n    }\n    FormattingOptions.is = is;\n})(FormattingOptions || (FormattingOptions = {}));\n/**\n * The DocumentLink namespace provides helper functions to work with\n * {@link DocumentLink} literals.\n */\nvar DocumentLink;\n(function (DocumentLink) {\n    /**\n     * Creates a new DocumentLink literal.\n     */\n    function create(range, target, data) {\n        return { range, target, data };\n    }\n    DocumentLink.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\n    }\n    DocumentLink.is = is;\n})(DocumentLink || (DocumentLink = {}));\n/**\n * The SelectionRange namespace provides helper function to work with\n * SelectionRange literals.\n */\nvar SelectionRange;\n(function (SelectionRange) {\n    /**\n     * Creates a new SelectionRange\n     * @param range the range.\n     * @param parent an optional parent.\n     */\n    function create(range, parent) {\n        return { range, parent };\n    }\n    SelectionRange.create = create;\n    function is(value) {\n        let candidate = value;\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\n    }\n    SelectionRange.is = is;\n})(SelectionRange || (SelectionRange = {}));\n/**\n * A set of predefined token types. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nvar SemanticTokenTypes;\n(function (SemanticTokenTypes) {\n    SemanticTokenTypes["namespace"] = "namespace";\n    /**\n     * Represents a generic type. Acts as a fallback for types which can\'t be mapped to\n     * a specific type like class or enum.\n     */\n    SemanticTokenTypes["type"] = "type";\n    SemanticTokenTypes["class"] = "class";\n    SemanticTokenTypes["enum"] = "enum";\n    SemanticTokenTypes["interface"] = "interface";\n    SemanticTokenTypes["struct"] = "struct";\n    SemanticTokenTypes["typeParameter"] = "typeParameter";\n    SemanticTokenTypes["parameter"] = "parameter";\n    SemanticTokenTypes["variable"] = "variable";\n    SemanticTokenTypes["property"] = "property";\n    SemanticTokenTypes["enumMember"] = "enumMember";\n    SemanticTokenTypes["event"] = "event";\n    SemanticTokenTypes["function"] = "function";\n    SemanticTokenTypes["method"] = "method";\n    SemanticTokenTypes["macro"] = "macro";\n    SemanticTokenTypes["keyword"] = "keyword";\n    SemanticTokenTypes["modifier"] = "modifier";\n    SemanticTokenTypes["comment"] = "comment";\n    SemanticTokenTypes["string"] = "string";\n    SemanticTokenTypes["number"] = "number";\n    SemanticTokenTypes["regexp"] = "regexp";\n    SemanticTokenTypes["operator"] = "operator";\n    /**\n     * @since 3.17.0\n     */\n    SemanticTokenTypes["decorator"] = "decorator";\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\n/**\n * A set of predefined token modifiers. This set is not fixed\n * an clients can specify additional token types via the\n * corresponding client capabilities.\n *\n * @since 3.16.0\n */\nvar SemanticTokenModifiers;\n(function (SemanticTokenModifiers) {\n    SemanticTokenModifiers["declaration"] = "declaration";\n    SemanticTokenModifiers["definition"] = "definition";\n    SemanticTokenModifiers["readonly"] = "readonly";\n    SemanticTokenModifiers["static"] = "static";\n    SemanticTokenModifiers["deprecated"] = "deprecated";\n    SemanticTokenModifiers["abstract"] = "abstract";\n    SemanticTokenModifiers["async"] = "async";\n    SemanticTokenModifiers["modification"] = "modification";\n    SemanticTokenModifiers["documentation"] = "documentation";\n    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\n/**\n * @since 3.16.0\n */\nvar SemanticTokens;\n(function (SemanticTokens) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === \'string\') &&\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === \'number\');\n    }\n    SemanticTokens.is = is;\n})(SemanticTokens || (SemanticTokens = {}));\n/**\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\n *\n * @since 3.17.0\n */\nvar InlineValueText;\n(function (InlineValueText) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, text) {\n        return { range, text };\n    }\n    InlineValueText.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\n    }\n    InlineValueText.is = is;\n})(InlineValueText || (InlineValueText = {}));\n/**\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\n *\n * @since 3.17.0\n */\nvar InlineValueVariableLookup;\n(function (InlineValueVariableLookup) {\n    /**\n     * Creates a new InlineValueText literal.\n     */\n    function create(range, variableName, caseSensitiveLookup) {\n        return { range, variableName, caseSensitiveLookup };\n    }\n    InlineValueVariableLookup.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\n    }\n    InlineValueVariableLookup.is = is;\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\n/**\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\n *\n * @since 3.17.0\n */\nvar InlineValueEvaluatableExpression;\n(function (InlineValueEvaluatableExpression) {\n    /**\n     * Creates a new InlineValueEvaluatableExpression literal.\n     */\n    function create(range, expression) {\n        return { range, expression };\n    }\n    InlineValueEvaluatableExpression.create = create;\n    function is(value) {\n        const candidate = value;\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\n    }\n    InlineValueEvaluatableExpression.is = is;\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\n/**\n * The InlineValueContext namespace provides helper functions to work with\n * {@link InlineValueContext} literals.\n *\n * @since 3.17.0\n */\nvar InlineValueContext;\n(function (InlineValueContext) {\n    /**\n     * Creates a new InlineValueContext literal.\n     */\n    function create(frameId, stoppedLocation) {\n        return { frameId, stoppedLocation };\n    }\n    InlineValueContext.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\n     */\n    function is(value) {\n        const candidate = value;\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\n    }\n    InlineValueContext.is = is;\n})(InlineValueContext || (InlineValueContext = {}));\n/**\n * Inlay hint kinds.\n *\n * @since 3.17.0\n */\nvar InlayHintKind;\n(function (InlayHintKind) {\n    /**\n     * An inlay hint that for a type annotation.\n     */\n    InlayHintKind.Type = 1;\n    /**\n     * An inlay hint that is for a parameter.\n     */\n    InlayHintKind.Parameter = 2;\n    function is(value) {\n        return value === 1 || value === 2;\n    }\n    InlayHintKind.is = is;\n})(InlayHintKind || (InlayHintKind = {}));\nvar InlayHintLabelPart;\n(function (InlayHintLabelPart) {\n    function create(value) {\n        return { value };\n    }\n    InlayHintLabelPart.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.location === undefined || Location.is(candidate.location))\n            && (candidate.command === undefined || Command.is(candidate.command));\n    }\n    InlayHintLabelPart.is = is;\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\nvar InlayHint;\n(function (InlayHint) {\n    function create(position, label, kind) {\n        const result = { position, label };\n        if (kind !== undefined) {\n            result.kind = kind;\n        }\n        return result;\n    }\n    InlayHint.create = create;\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\n    }\n    InlayHint.is = is;\n})(InlayHint || (InlayHint = {}));\nvar StringValue;\n(function (StringValue) {\n    function createSnippet(value) {\n        return { kind: \'snippet\', value };\n    }\n    StringValue.createSnippet = createSnippet;\n})(StringValue || (StringValue = {}));\nvar InlineCompletionItem;\n(function (InlineCompletionItem) {\n    function create(insertText, filterText, range, command) {\n        return { insertText, filterText, range, command };\n    }\n    InlineCompletionItem.create = create;\n})(InlineCompletionItem || (InlineCompletionItem = {}));\nvar InlineCompletionList;\n(function (InlineCompletionList) {\n    function create(items) {\n        return { items };\n    }\n    InlineCompletionList.create = create;\n})(InlineCompletionList || (InlineCompletionList = {}));\n/**\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\n *\n * @since 3.18.0\n * @proposed\n */\nvar InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     */\n    InlineCompletionTriggerKind.Invoked = 0;\n    /**\n     * Completion was triggered automatically while editing.\n     */\n    InlineCompletionTriggerKind.Automatic = 1;\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nvar SelectedCompletionInfo;\n(function (SelectedCompletionInfo) {\n    function create(range, text) {\n        return { range, text };\n    }\n    SelectedCompletionInfo.create = create;\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\nvar InlineCompletionContext;\n(function (InlineCompletionContext) {\n    function create(triggerKind, selectedCompletionInfo) {\n        return { triggerKind, selectedCompletionInfo };\n    }\n    InlineCompletionContext.create = create;\n})(InlineCompletionContext || (InlineCompletionContext = {}));\nvar WorkspaceFolder;\n(function (WorkspaceFolder) {\n    function is(value) {\n        const candidate = value;\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\n    }\n    WorkspaceFolder.is = is;\n})(WorkspaceFolder || (WorkspaceFolder = {}));\nconst EOL = (/* unused pure expression or super */ null && ([\'\\n\', \'\\r\\n\', \'\\r\']));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nvar TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new ITextDocument literal from the given uri and content.\n     * @param uri The document\'s uri.\n     * @param languageId The document\'s language Id.\n     * @param version The document\'s version.\n     * @param content The document\'s content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\n     */\n    function is(value) {\n        let candidate = value;\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\n    }\n    TextDocument.is = is;\n    function applyEdits(document, edits) {\n        let text = document.getText();\n        let sortedEdits = mergeSort(edits, (a, b) => {\n            let diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = text.length;\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\n            let e = sortedEdits[i];\n            let startOffset = document.offsetAt(e.range.start);\n            let endOffset = document.offsetAt(e.range.end);\n            if (endOffset <= lastModifiedOffset) {\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\n            }\n            else {\n                throw new Error(\'Overlapping edit\');\n            }\n            lastModifiedOffset = startOffset;\n        }\n        return text;\n    }\n    TextDocument.applyEdits = applyEdits;\n    function mergeSort(data, compare) {\n        if (data.length <= 1) {\n            // sorted\n            return data;\n        }\n        const p = (data.length / 2) | 0;\n        const left = data.slice(0, p);\n        const right = data.slice(p);\n        mergeSort(left, compare);\n        mergeSort(right, compare);\n        let leftIdx = 0;\n        let rightIdx = 0;\n        let i = 0;\n        while (leftIdx < left.length && rightIdx < right.length) {\n            let ret = compare(left[leftIdx], right[rightIdx]);\n            if (ret <= 0) {\n                // smaller_equal -> take left to preserve order\n                data[i++] = left[leftIdx++];\n            }\n            else {\n                // greater -> take right\n                data[i++] = right[rightIdx++];\n            }\n        }\n        while (leftIdx < left.length) {\n            data[i++] = left[leftIdx++];\n        }\n        while (rightIdx < right.length) {\n            data[i++] = right[rightIdx++];\n        }\n        return data;\n    }\n})(TextDocument || (TextDocument = {}));\n/**\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\n */\nclass FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            let start = this.offsetAt(range.start);\n            let end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(event, version) {\n        this._content = event.text;\n        this._version = version;\n        this._lineOffsets = undefined;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            let lineOffsets = [];\n            let text = this._content;\n            let isLineStart = true;\n            for (let i = 0; i < text.length; i++) {\n                if (isLineStart) {\n                    lineOffsets.push(i);\n                    isLineStart = false;\n                }\n                let ch = text.charAt(i);\n                isLineStart = (ch === \'\\r\' || ch === \'\\n\');\n                if (ch === \'\\r\' && i + 1 < text.length && text.charAt(i + 1) === \'\\n\') {\n                    i++;\n                }\n            }\n            if (isLineStart && text.length > 0) {\n                lineOffsets.push(text.length);\n            }\n            this._lineOffsets = lineOffsets;\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        let lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return Position.create(0, offset);\n        }\n        while (low < high) {\n            let mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        let line = low - 1;\n        return Position.create(line, offset - lineOffsets[line]);\n    }\n    offsetAt(position) {\n        let lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        let lineOffset = lineOffsets[position.line];\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n}\nvar Is;\n(function (Is) {\n    const toString = Object.prototype.toString;\n    function defined(value) {\n        return typeof value !== \'undefined\';\n    }\n    Is.defined = defined;\n    function undefined(value) {\n        return typeof value === \'undefined\';\n    }\n    Is.undefined = undefined;\n    function boolean(value) {\n        return value === true || value === false;\n    }\n    Is.boolean = boolean;\n    function string(value) {\n        return toString.call(value) === \'[object String]\';\n    }\n    Is.string = string;\n    function number(value) {\n        return toString.call(value) === \'[object Number]\';\n    }\n    Is.number = number;\n    function numberRange(value, min, max) {\n        return toString.call(value) === \'[object Number]\' && min <= value && value <= max;\n    }\n    Is.numberRange = numberRange;\n    function integer(value) {\n        return toString.call(value) === \'[object Number]\' && -2147483648 <= value && value <= 2147483647;\n    }\n    Is.integer = integer;\n    function uinteger(value) {\n        return toString.call(value) === \'[object Number]\' && 0 <= value && value <= 2147483647;\n    }\n    Is.uinteger = uinteger;\n    function func(value) {\n        return toString.call(value) === \'[object Function]\';\n    }\n    Is.func = func;\n    function objectLiteral(value) {\n        // Strictly speaking class instances pass this check as well. Since the LSP\n        // doesn\'t use classes we ignore this for now. If we do we need to add something\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\n        return value !== null && typeof value === \'object\';\n    }\n    Is.objectLiteral = objectLiteral;\n    function typedArray(value, check) {\n        return Array.isArray(value) && value.every(check);\n    }\n    Is.typedArray = typedArray;\n})(Is || (Is = {}));\n\n;// ./node_modules/langium/lib/parser/cst-node-builder.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nclass CstNodeBuilder {\n    constructor() {\n        this.nodeStack = [];\n    }\n    get current() {\n        return this.nodeStack[this.nodeStack.length - 1];\n    }\n    buildRootNode(input) {\n        this.rootNode = new RootCstNodeImpl(input);\n        this.rootNode.root = this.rootNode;\n        this.nodeStack = [this.rootNode];\n        return this.rootNode;\n    }\n    buildCompositeNode(feature) {\n        const compositeNode = new CompositeCstNodeImpl();\n        compositeNode.grammarSource = feature;\n        compositeNode.root = this.rootNode;\n        this.current.content.push(compositeNode);\n        this.nodeStack.push(compositeNode);\n        return compositeNode;\n    }\n    buildLeafNode(token, feature) {\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, false);\n        leafNode.grammarSource = feature;\n        leafNode.root = this.rootNode;\n        this.current.content.push(leafNode);\n        return leafNode;\n    }\n    removeNode(node) {\n        const parent = node.container;\n        if (parent) {\n            const index = parent.content.indexOf(node);\n            if (index >= 0) {\n                parent.content.splice(index, 1);\n            }\n        }\n    }\n    construct(item) {\n        const current = this.current;\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\n        // Only if the $type is a string, we actually assign the element\n        if (typeof item.$type === \'string\') {\n            this.current.astNode = item;\n        }\n        item.$cstNode = current;\n        const node = this.nodeStack.pop();\n        // Empty composite nodes are not valid\n        // Simply remove the node from the tree\n        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {\n            this.removeNode(node);\n        }\n    }\n    addHiddenTokens(hiddenTokens) {\n        for (const token of hiddenTokens) {\n            const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\n            hiddenNode.root = this.rootNode;\n            this.addHiddenToken(this.rootNode, hiddenNode);\n        }\n    }\n    addHiddenToken(node, token) {\n        const { offset: tokenStart, end: tokenEnd } = token;\n        for (let i = 0; i < node.content.length; i++) {\n            const child = node.content[i];\n            const { offset: childStart, end: childEnd } = child;\n            if (syntax_tree_isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {\n                this.addHiddenToken(child, token);\n                return;\n            }\n            else if (tokenEnd <= childStart) {\n                node.content.splice(i, 0, token);\n                return;\n            }\n        }\n        // We know that we haven\'t found a suited position for the token\n        // So we simply add it to the end of the current node\n        node.content.push(token);\n    }\n}\nclass AbstractCstNode {\n    /** @deprecated use `container` instead. */\n    get parent() {\n        return this.container;\n    }\n    /** @deprecated use `grammarSource` instead. */\n    get feature() {\n        return this.grammarSource;\n    }\n    get hidden() {\n        return false;\n    }\n    get astNode() {\n        var _a, _b;\n        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === \'string\' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;\n        if (!node) {\n            throw new Error(\'This node has no associated AST element\');\n        }\n        return node;\n    }\n    set astNode(value) {\n        this._astNode = value;\n    }\n    /** @deprecated use `astNode` instead. */\n    get element() {\n        return this.astNode;\n    }\n    get text() {\n        return this.root.fullText.substring(this.offset, this.end);\n    }\n}\nclass LeafCstNodeImpl extends AbstractCstNode {\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return this._length;\n    }\n    get end() {\n        return this._offset + this._length;\n    }\n    get hidden() {\n        return this._hidden;\n    }\n    get tokenType() {\n        return this._tokenType;\n    }\n    get range() {\n        return this._range;\n    }\n    constructor(offset, length, range, tokenType, hidden = false) {\n        super();\n        this._hidden = hidden;\n        this._offset = offset;\n        this._tokenType = tokenType;\n        this._length = length;\n        this._range = range;\n    }\n}\nclass CompositeCstNodeImpl extends AbstractCstNode {\n    constructor() {\n        super(...arguments);\n        this.content = new CstNodeContainer(this);\n    }\n    /** @deprecated use `content` instead. */\n    get children() {\n        return this.content;\n    }\n    get offset() {\n        var _a, _b;\n        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;\n    }\n    get length() {\n        return this.end - this.offset;\n    }\n    get end() {\n        var _a, _b;\n        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;\n    }\n    get range() {\n        const firstNode = this.firstNonHiddenNode;\n        const lastNode = this.lastNonHiddenNode;\n        if (firstNode && lastNode) {\n            if (this._rangeCache === undefined) {\n                const { range: firstRange } = firstNode;\n                const { range: lastRange } = lastNode;\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\n            }\n            return this._rangeCache;\n        }\n        else {\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\n        }\n    }\n    get firstNonHiddenNode() {\n        for (const child of this.content) {\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[0];\n    }\n    get lastNonHiddenNode() {\n        for (let i = this.content.length - 1; i >= 0; i--) {\n            const child = this.content[i];\n            if (!child.hidden) {\n                return child;\n            }\n        }\n        return this.content[this.content.length - 1];\n    }\n}\nclass CstNodeContainer extends Array {\n    constructor(parent) {\n        super();\n        this.parent = parent;\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\n    }\n    push(...items) {\n        this.addParents(items);\n        return super.push(...items);\n    }\n    unshift(...items) {\n        this.addParents(items);\n        return super.unshift(...items);\n    }\n    splice(start, count, ...items) {\n        this.addParents(items);\n        return super.splice(start, count, ...items);\n    }\n    addParents(items) {\n        for (const item of items) {\n            item.container = this.parent;\n        }\n    }\n}\nclass RootCstNodeImpl extends CompositeCstNodeImpl {\n    get text() {\n        return this._text.substring(this.offset, this.end);\n    }\n    get fullText() {\n        return this._text;\n    }\n    constructor(input) {\n        super();\n        this._text = \'\';\n        this._text = input !== null && input !== void 0 ? input : \'\';\n    }\n}\n//# sourceMappingURL=cst-node-builder.js.map\n;// ./node_modules/langium/lib/parser/langium-parser.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nconst DatatypeSymbol = Symbol(\'Datatype\');\nfunction isDataTypeNode(node) {\n    return node.$type === DatatypeSymbol;\n}\nconst ruleSuffix = \'\\u200B\';\nconst withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\nclass AbstractLangiumParser {\n    constructor(services) {\n        this._unorderedGroups = new Map();\n        this.lexer = services.parser.Lexer;\n        const tokens = this.lexer.definition;\n        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { errorMessageProvider: services.parser.ParserErrorMessageProvider }));\n    }\n    alternatives(idx, choices) {\n        this.wrapper.wrapOr(idx, choices);\n    }\n    optional(idx, callback) {\n        this.wrapper.wrapOption(idx, callback);\n    }\n    many(idx, callback) {\n        this.wrapper.wrapMany(idx, callback);\n    }\n    atLeastOne(idx, callback) {\n        this.wrapper.wrapAtLeastOne(idx, callback);\n    }\n    isRecording() {\n        return this.wrapper.IS_RECORDING;\n    }\n    get unorderedGroups() {\n        return this._unorderedGroups;\n    }\n    getRuleStack() {\n        return this.wrapper.RULE_STACK;\n    }\n    finalize() {\n        this.wrapper.wrapSelfAnalysis();\n    }\n}\nclass LangiumParser extends AbstractLangiumParser {\n    get current() {\n        return this.stack[this.stack.length - 1];\n    }\n    constructor(services) {\n        super(services);\n        this.nodeBuilder = new CstNodeBuilder();\n        this.stack = [];\n        this.assignmentMap = new Map();\n        this.linker = services.references.Linker;\n        this.converter = services.parser.ValueConverter;\n        this.astReflection = services.shared.AstReflection;\n    }\n    rule(rule, impl) {\n        const type = rule.fragment ? undefined : isDataTypeRule(rule) ? DatatypeSymbol : getTypeName(rule);\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    parse(input) {\n        this.nodeBuilder.buildRootNode(input);\n        const lexerResult = this.lexer.tokenize(input);\n        this.wrapper.input = lexerResult.tokens;\n        const result = this.mainRule.call(this.wrapper, {});\n        this.nodeBuilder.addHiddenTokens(lexerResult.hidden);\n        this.unorderedGroups.clear();\n        return {\n            value: result,\n            lexerErrors: lexerResult.errors,\n            parserErrors: this.wrapper.errors\n        };\n    }\n    startImplementation($type, implementation) {\n        return (args) => {\n            if (!this.isRecording()) {\n                const node = { $type };\n                this.stack.push(node);\n                if ($type === DatatypeSymbol) {\n                    node.value = \'\';\n                }\n            }\n            let result;\n            try {\n                result = implementation(args);\n            }\n            catch (err) {\n                result = undefined;\n            }\n            if (!this.isRecording() && result === undefined) {\n                result = this.construct();\n            }\n            return result;\n        };\n    }\n    consume(idx, tokenType, feature) {\n        const token = this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording() && this.isValidToken(token)) {\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\n            const { assignment, isCrossRef } = this.getAssignment(feature);\n            const current = this.current;\n            if (assignment) {\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\n            }\n            else if (isDataTypeNode(current)) {\n                let text = token.image;\n                if (!isKeyword(feature)) {\n                    text = this.converter.convert(text, leafNode).toString();\n                }\n                current.value += text;\n            }\n        }\n    }\n    /**\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\n     *\n     * 1. They were inserted during error recovery by the parser. These tokens don\'t really exist and should not be further processed\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\n     */\n    isValidToken(token) {\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === \'number\' && !isNaN(token.endOffset);\n    }\n    subrule(idx, rule, feature, args) {\n        let cstNode;\n        if (!this.isRecording()) {\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\n        }\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\n        }\n    }\n    performSubruleAssignment(result, feature, cstNode) {\n        const { assignment, isCrossRef } = this.getAssignment(feature);\n        if (assignment) {\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\n        }\n        else if (!assignment) {\n            // If we call a subrule without an assignment we either:\n            // 1. append the result of the subrule (data type rule)\n            // 2. override the current object with the newly parsed object\n            // If the current element is an AST node and the result of the subrule\n            // is a data type rule, we can safely discard the results.\n            const current = this.current;\n            if (isDataTypeNode(current)) {\n                current.value += result.toString();\n            }\n            else if (typeof result === \'object\' && result) {\n                const resultKind = result.$type;\n                const object = this.assignWithoutOverride(result, current);\n                if (resultKind) {\n                    object.$type = resultKind;\n                }\n                const newItem = object;\n                this.stack.pop();\n                this.stack.push(newItem);\n            }\n        }\n    }\n    action($type, action) {\n        if (!this.isRecording()) {\n            let last = this.current;\n            // This branch is used for left recursive grammar rules.\n            // Those don\'t call `construct` before another action.\n            // Therefore, we need to call it here.\n            if (!last.$cstNode && action.feature && action.operator) {\n                last = this.construct(false);\n                const feature = last.$cstNode.feature;\n                this.nodeBuilder.buildCompositeNode(feature);\n            }\n            const newItem = { $type };\n            this.stack.pop();\n            this.stack.push(newItem);\n            if (action.feature && action.operator) {\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\n            }\n        }\n    }\n    construct(pop = true) {\n        if (this.isRecording()) {\n            return undefined;\n        }\n        const obj = this.current;\n        linkContentToContainer(obj);\n        this.nodeBuilder.construct(obj);\n        if (pop) {\n            this.stack.pop();\n        }\n        if (isDataTypeNode(obj)) {\n            return this.converter.convert(obj.value, obj.$cstNode);\n        }\n        else {\n            assignMandatoryProperties(this.astReflection, obj);\n        }\n        return obj;\n    }\n    getAssignment(feature) {\n        if (!this.assignmentMap.has(feature)) {\n            const assignment = getContainerOfType(feature, isAssignment);\n            this.assignmentMap.set(feature, {\n                assignment: assignment,\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\n            });\n        }\n        return this.assignmentMap.get(feature);\n    }\n    assign(operator, feature, value, cstNode, isCrossRef) {\n        const obj = this.current;\n        let item;\n        if (isCrossRef && typeof value === \'string\') {\n            item = this.linker.buildReference(obj, feature, cstNode, value);\n        }\n        else {\n            item = value;\n        }\n        switch (operator) {\n            case \'=\': {\n                obj[feature] = item;\n                break;\n            }\n            case \'?=\': {\n                obj[feature] = true;\n                break;\n            }\n            case \'+=\': {\n                if (!Array.isArray(obj[feature])) {\n                    obj[feature] = [];\n                }\n                obj[feature].push(item);\n            }\n        }\n    }\n    assignWithoutOverride(target, source) {\n        for (const [name, existingValue] of Object.entries(source)) {\n            const newValue = target[name];\n            if (newValue === undefined) {\n                target[name] = existingValue;\n            }\n            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\n                existingValue.push(...newValue);\n                target[name] = existingValue;\n            }\n        }\n        return target;\n    }\n    get definitionErrors() {\n        return this.wrapper.definitionErrors;\n    }\n}\nclass AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage(options) {\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\n    }\n    buildNotAllInputParsedMessage(options) {\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n    }\n    buildNoViableAltMessage(options) {\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    }\n    buildEarlyExitMessage(options) {\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\nclass LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\n    buildMismatchTokenMessage({ expected, actual }) {\n        const expectedMsg = expected.LABEL\n            ? \'`\' + expected.LABEL + \'`\'\n            : expected.name.endsWith(\':KW\')\n                ? `keyword \'${expected.name.substring(0, expected.name.length - 3)}\'`\n                : `token of type \'${expected.name}\'`;\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\n    }\n    buildNotAllInputParsedMessage({ firstRedundant }) {\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\n    }\n}\nclass LangiumCompletionParser extends AbstractLangiumParser {\n    constructor() {\n        super(...arguments);\n        this.tokens = [];\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    action() {\n        // NOOP\n    }\n    construct() {\n        // NOOP\n        return undefined;\n    }\n    parse(input) {\n        this.resetState();\n        const tokens = this.lexer.tokenize(input);\n        this.tokens = tokens.tokens;\n        this.wrapper.input = [...this.tokens];\n        this.mainRule.call(this.wrapper, {});\n        this.unorderedGroups.clear();\n        return {\n            tokens: this.tokens,\n            elementStack: [...this.lastElementStack],\n            tokenIndex: this.nextTokenIndex\n        };\n    }\n    rule(rule, impl) {\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\n        if (rule.entry) {\n            this.mainRule = ruleMethod;\n        }\n        return ruleMethod;\n    }\n    resetState() {\n        this.elementStack = [];\n        this.lastElementStack = [];\n        this.nextTokenIndex = 0;\n        this.stackSize = 0;\n    }\n    startImplementation(implementation) {\n        return (args) => {\n            const size = this.keepStackSize();\n            try {\n                implementation(args);\n            }\n            finally {\n                this.resetStackSize(size);\n            }\n        };\n    }\n    removeUnexpectedElements() {\n        this.elementStack.splice(this.stackSize);\n    }\n    keepStackSize() {\n        const size = this.elementStack.length;\n        this.stackSize = size;\n        return size;\n    }\n    resetStackSize(size) {\n        this.removeUnexpectedElements();\n        this.stackSize = size;\n    }\n    consume(idx, tokenType, feature) {\n        this.wrapper.wrapConsume(idx, tokenType);\n        if (!this.isRecording()) {\n            this.lastElementStack = [...this.elementStack, feature];\n            this.nextTokenIndex = this.currIdx + 1;\n        }\n    }\n    subrule(idx, rule, feature, args) {\n        this.before(feature);\n        this.wrapper.wrapSubrule(idx, rule, args);\n        this.after(feature);\n    }\n    before(element) {\n        if (!this.isRecording()) {\n            this.elementStack.push(element);\n        }\n    }\n    after(element) {\n        if (!this.isRecording()) {\n            const index = this.elementStack.lastIndexOf(element);\n            if (index >= 0) {\n                this.elementStack.splice(index);\n            }\n        }\n    }\n    get currIdx() {\n        return this.wrapper.currIdx;\n    }\n}\nconst defaultConfig = {\n    recoveryEnabled: true,\n    nodeLocationTracking: \'full\',\n    skipValidations: true,\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\n};\n/**\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\n * This way, we can build the `LangiumParser` as a composition.\n */\nclass ChevrotainWrapper extends EmbeddedActionsParser {\n    constructor(tokens, config) {\n        const useDefaultLookahead = config && \'maxLookahead\' in config;\n        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\n                : new LLStarLookaheadStrategy() }), config));\n    }\n    get IS_RECORDING() {\n        return this.RECORDING_PHASE;\n    }\n    DEFINE_RULE(name, impl) {\n        return this.RULE(name, impl);\n    }\n    wrapSelfAnalysis() {\n        this.performSelfAnalysis();\n    }\n    wrapConsume(idx, tokenType) {\n        return this.consume(idx, tokenType);\n    }\n    wrapSubrule(idx, rule, args) {\n        return this.subrule(idx, rule, {\n            ARGS: [args]\n        });\n    }\n    wrapOr(idx, choices) {\n        this.or(idx, choices);\n    }\n    wrapOption(idx, callback) {\n        this.option(idx, callback);\n    }\n    wrapMany(idx, callback) {\n        this.many(idx, callback);\n    }\n    wrapAtLeastOne(idx, callback) {\n        this.atLeastOne(idx, callback);\n    }\n}\n//# sourceMappingURL=langium-parser.js.map\n;// ./node_modules/langium/lib/parser/parser-builder-base.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nfunction createParser(grammar, parser, tokens) {\n    const rules = new Map();\n    const parserContext = {\n        parser,\n        tokens,\n        rules,\n        ruleNames: new Map()\n    };\n    buildRules(parserContext, grammar);\n    return parser;\n}\nfunction buildRules(parserContext, grammar) {\n    const reachable = getAllReachableRules(grammar, false);\n    const parserRules = stream_stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\n    for (const rule of parserRules) {\n        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });\n        ctx.rules.set(rule.name, parserContext.parser.rule(rule, buildElement(ctx, rule.definition)));\n    }\n}\nfunction buildElement(ctx, element, ignoreGuard = false) {\n    let method;\n    if (isKeyword(element)) {\n        method = buildKeyword(ctx, element);\n    }\n    else if (isAction(element)) {\n        method = buildAction(ctx, element);\n    }\n    else if (isAssignment(element)) {\n        method = buildElement(ctx, element.terminal);\n    }\n    else if (isCrossReference(element)) {\n        method = buildCrossReference(ctx, element);\n    }\n    else if (isRuleCall(element)) {\n        method = buildRuleCall(ctx, element);\n    }\n    else if (isAlternatives(element)) {\n        method = buildAlternatives(ctx, element);\n    }\n    else if (isUnorderedGroup(element)) {\n        method = buildUnorderedGroup(ctx, element);\n    }\n    else if (isGroup(element)) {\n        method = buildGroup(ctx, element);\n    }\n    else if (isEndOfFile(element)) {\n        const idx = ctx.consume++;\n        method = () => ctx.parser.consume(idx, EOF, element);\n    }\n    else {\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\n    }\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\n}\nfunction buildAction(ctx, action) {\n    const actionType = getTypeName(action);\n    return () => ctx.parser.action(actionType, action);\n}\nfunction buildRuleCall(ctx, ruleCall) {\n    const rule = ruleCall.rule.ref;\n    if (isParserRule(rule)) {\n        const idx = ctx.subrule++;\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));\n    }\n    else if (isTerminalRule(rule)) {\n        const idx = ctx.consume++;\n        const method = getToken(ctx, rule.name);\n        return () => ctx.parser.consume(idx, method, ruleCall);\n    }\n    else if (!rule) {\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);\n    }\n    else {\n        assertUnreachable(rule);\n    }\n}\nfunction buildRuleCallPredicate(rule, namedArgs) {\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\n    return (args) => {\n        const ruleArgs = {};\n        for (let i = 0; i < predicates.length; i++) {\n            const ruleTarget = rule.parameters[i];\n            const predicate = predicates[i];\n            ruleArgs[ruleTarget.name] = predicate(args);\n        }\n        return ruleArgs;\n    };\n}\nfunction buildPredicate(condition) {\n    if (isDisjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) || right(args));\n    }\n    else if (isConjunction(condition)) {\n        const left = buildPredicate(condition.left);\n        const right = buildPredicate(condition.right);\n        return (args) => (left(args) && right(args));\n    }\n    else if (isNegation(condition)) {\n        const value = buildPredicate(condition.value);\n        return (args) => !value(args);\n    }\n    else if (isParameterReference(condition)) {\n        const name = condition.parameter.ref.name;\n        return (args) => args !== undefined && args[name] === true;\n    }\n    else if (isBooleanLiteral(condition)) {\n        const value = Boolean(condition.true);\n        return () => value;\n    }\n    assertUnreachable(condition);\n}\nfunction buildAlternatives(ctx, alternatives) {\n    if (alternatives.elements.length === 1) {\n        return buildElement(ctx, alternatives.elements[0]);\n    }\n    else {\n        const methods = [];\n        for (const element of alternatives.elements) {\n            const predicatedMethod = {\n                // Since we handle the guard condition in the alternative already\n                // We can ignore the group guard condition inside\n                ALT: buildElement(ctx, element, true)\n            };\n            const guard = getGuardCondition(element);\n            if (guard) {\n                predicatedMethod.GATE = buildPredicate(guard);\n            }\n            methods.push(predicatedMethod);\n        }\n        const idx = ctx.or++;\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\n            const alt = {\n                ALT: () => method.ALT(args)\n            };\n            const gate = method.GATE;\n            if (gate) {\n                alt.GATE = () => gate(args);\n            }\n            return alt;\n        }));\n    }\n}\nfunction buildUnorderedGroup(ctx, group) {\n    if (group.elements.length === 1) {\n        return buildElement(ctx, group.elements[0]);\n    }\n    const methods = [];\n    for (const element of group.elements) {\n        const predicatedMethod = {\n            // Since we handle the guard condition in the alternative already\n            // We can ignore the group guard condition inside\n            ALT: buildElement(ctx, element, true)\n        };\n        const guard = getGuardCondition(element);\n        if (guard) {\n            predicatedMethod.GATE = buildPredicate(guard);\n        }\n        methods.push(predicatedMethod);\n    }\n    const orIdx = ctx.or++;\n    const idFunc = (groupIdx, lParser) => {\n        const stackId = lParser.getRuleStack().join(\'-\');\n        return `uGroup_${groupIdx}_${stackId}`;\n    };\n    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\n        const alt = { ALT: () => true };\n        const parser = ctx.parser;\n        alt.ALT = () => {\n            method.ALT(args);\n            if (!parser.isRecording()) {\n                const key = idFunc(orIdx, parser);\n                if (!parser.unorderedGroups.get(key)) {\n                    // init after clear state\n                    parser.unorderedGroups.set(key, []);\n                }\n                const groupState = parser.unorderedGroups.get(key);\n                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === \'undefined\') {\n                    // Not accessed yet\n                    groupState[idx] = true;\n                }\n            }\n        };\n        const gate = method.GATE;\n        if (gate) {\n            alt.GATE = () => gate(args);\n        }\n        else {\n            alt.GATE = () => {\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\n                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);\n                return allow;\n            };\n        }\n        return alt;\n    }));\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, \'*\');\n    return (args) => {\n        wrapped(args);\n        if (!ctx.parser.isRecording()) {\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\n        }\n    };\n}\nfunction buildGroup(ctx, group) {\n    const methods = group.elements.map(e => buildElement(ctx, e));\n    return (args) => methods.forEach(method => method(args));\n}\nfunction getGuardCondition(element) {\n    if (isGroup(element)) {\n        return element.guardCondition;\n    }\n    return undefined;\n}\nfunction buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {\n    if (!terminal) {\n        if (!crossRef.type.ref) {\n            throw new Error(\'Could not resolve reference to type: \' + crossRef.type.$refText);\n        }\n        const assignment = findNameAssignment(crossRef.type.ref);\n        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;\n        if (!assignTerminal) {\n            throw new Error(\'Could not find name assignment for type: \' + getTypeName(crossRef.type.ref));\n        }\n        return buildCrossReference(ctx, crossRef, assignTerminal);\n    }\n    else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\n        const idx = ctx.subrule++;\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref), crossRef, args);\n    }\n    else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\n        const idx = ctx.consume++;\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\n    }\n    else if (isKeyword(terminal)) {\n        const idx = ctx.consume++;\n        const keyword = getToken(ctx, terminal.value);\n        return () => ctx.parser.consume(idx, keyword, crossRef);\n    }\n    else {\n        throw new Error(\'Could not build cross reference parser\');\n    }\n}\nfunction buildKeyword(ctx, keyword) {\n    const idx = ctx.consume++;\n    const token = ctx.tokens[keyword.value];\n    if (!token) {\n        throw new Error(\'Could not find token for keyword: \' + keyword.value);\n    }\n    return () => ctx.parser.consume(idx, token, keyword);\n}\nfunction wrap(ctx, guard, method, cardinality) {\n    const gate = guard && buildPredicate(guard);\n    if (!cardinality) {\n        if (gate) {\n            const idx = ctx.or++;\n            return (args) => ctx.parser.alternatives(idx, [\n                {\n                    ALT: () => method(args),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return method;\n        }\n    }\n    if (cardinality === \'*\') {\n        const idx = ctx.many++;\n        return (args) => ctx.parser.many(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else if (cardinality === \'+\') {\n        const idx = ctx.many++;\n        if (gate) {\n            const orIdx = ctx.or++;\n            // In the case of a guard condition for the `+` group\n            // We combine it with an empty alternative\n            // If the condition returns true, it needs to parse at least a single iteration\n            // If its false, it is not allowed to parse anything\n            return (args) => ctx.parser.alternatives(orIdx, [\n                {\n                    ALT: () => ctx.parser.atLeastOne(idx, {\n                        DEF: () => method(args)\n                    }),\n                    GATE: () => gate(args)\n                },\n                {\n                    ALT: EMPTY_ALT(),\n                    GATE: () => !gate(args)\n                }\n            ]);\n        }\n        else {\n            return (args) => ctx.parser.atLeastOne(idx, {\n                DEF: () => method(args),\n            });\n        }\n    }\n    else if (cardinality === \'?\') {\n        const idx = ctx.optional++;\n        return (args) => ctx.parser.optional(idx, {\n            DEF: () => method(args),\n            GATE: gate ? () => gate(args) : undefined\n        });\n    }\n    else {\n        assertUnreachable(cardinality);\n    }\n}\nfunction getRule(ctx, element) {\n    const name = getRuleName(ctx, element);\n    const rule = ctx.rules.get(name);\n    if (!rule)\n        throw new Error(`Rule "${name}" not found."`);\n    return rule;\n}\nfunction getRuleName(ctx, element) {\n    if (isParserRule(element)) {\n        return element.name;\n    }\n    else if (ctx.ruleNames.has(element)) {\n        return ctx.ruleNames.get(element);\n    }\n    else {\n        let item = element;\n        let parent = item.$container;\n        let ruleName = element.$type;\n        while (!isParserRule(parent)) {\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\n                const index = parent.elements.indexOf(item);\n                ruleName = index.toString() + \':\' + ruleName;\n            }\n            item = parent;\n            parent = parent.$container;\n        }\n        const rule = parent;\n        ruleName = rule.name + \':\' + ruleName;\n        ctx.ruleNames.set(element, ruleName);\n        return ruleName;\n    }\n}\nfunction getToken(ctx, name) {\n    const token = ctx.tokens[name];\n    if (!token)\n        throw new Error(`Token "${name}" not found."`);\n    return token;\n}\n//# sourceMappingURL=parser-builder-base.js.map\n;// ./node_modules/langium/lib/parser/completion-parser-builder.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nfunction createCompletionParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumCompletionParser(services);\n    createParser(grammar, parser, lexer.definition);\n    parser.finalize();\n    return parser;\n}\n//# sourceMappingURL=completion-parser-builder.js.map\n;// ./node_modules/langium/lib/parser/langium-parser-builder.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\n * available at `services.Grammar`.\n */\nfunction createLangiumParser(services) {\n    const parser = prepareLangiumParser(services);\n    parser.finalize();\n    return parser;\n}\n/**\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\n * information when the parser is initially validated.\n */\nfunction prepareLangiumParser(services) {\n    const grammar = services.Grammar;\n    const lexer = services.parser.Lexer;\n    const parser = new LangiumParser(services);\n    return createParser(grammar, parser, lexer.definition);\n}\n//# sourceMappingURL=langium-parser-builder.js.map\n;// ./node_modules/langium/lib/parser/token-builder.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultTokenBuilder {\n    buildTokens(grammar, options) {\n        const reachableRules = stream_stream(getAllReachableRules(grammar, false));\n        const terminalTokens = this.buildTerminalTokens(reachableRules);\n        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);\n        terminalTokens.forEach(terminalToken => {\n            const pattern = terminalToken.PATTERN;\n            if (typeof pattern === \'object\' && pattern && \'test\' in pattern && isWhitespace(pattern)) {\n                tokens.unshift(terminalToken);\n            }\n            else {\n                tokens.push(terminalToken);\n            }\n        });\n        // We don\'t need to add the EOF token explicitly.\n        // It is automatically available at the end of the token stream.\n        return tokens;\n    }\n    buildTerminalTokens(rules) {\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\n    }\n    buildTerminalToken(terminal) {\n        const regex = terminalRegex(terminal);\n        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;\n        const tokenType = {\n            name: terminal.name,\n            PATTERN: pattern,\n            LINE_BREAKS: true\n        };\n        if (terminal.hidden) {\n            // Only skip tokens that are able to accept whitespace\n            tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : \'hidden\';\n        }\n        return tokenType;\n    }\n    requiresCustomPattern(regex) {\n        if (regex.flags.includes(\'u\')) {\n            // Unicode regexes are not supported by Chevrotain.\n            return true;\n        }\n        else if (regex.source.includes(\'?<=\') || regex.source.includes(\'?<!\')) {\n            // Negative and positive lookbehind are not supported by Chevrotain yet.\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    regexPatternFunction(regex) {\n        const stickyRegex = new RegExp(regex, regex.flags + \'y\');\n        return (text, offset) => {\n            stickyRegex.lastIndex = offset;\n            const execResult = stickyRegex.exec(text);\n            return execResult;\n        };\n    }\n    buildKeywordTokens(rules, terminalTokens, options) {\n        return rules\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\n            .filter(isParserRule)\n            .flatMap(rule => ast_utils_streamAllContents(rule).filter(isKeyword))\n            .distinct(e => e.value).toArray()\n            // Sort keywords by descending length\n            .sort((a, b) => b.value.length - a.value.length)\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));\n    }\n    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {\n        return {\n            name: keyword.value,\n            PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\n        };\n    }\n    buildKeywordPattern(keyword, caseInsensitive) {\n        return caseInsensitive ?\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\n            keyword.value;\n    }\n    findLongerAlt(keyword, terminalTokens) {\n        return terminalTokens.reduce((longerAlts, token) => {\n            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;\n            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && partialMatches(\'^\' + pattern.source + \'$\', keyword.value)) {\n                longerAlts.push(token);\n            }\n            return longerAlts;\n        }, []);\n    }\n}\n//# sourceMappingURL=token-builder.js.map\n;// ./node_modules/langium/lib/parser/value-converter.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultValueConverter {\n    convert(input, cstNode) {\n        let feature = cstNode.grammarSource;\n        if (isCrossReference(feature)) {\n            feature = getCrossReferenceTerminal(feature);\n        }\n        if (isRuleCall(feature)) {\n            const rule = feature.rule.ref;\n            if (!rule) {\n                throw new Error(\'This cst node was not parsed by a rule.\');\n            }\n            return this.runConverter(rule, input, cstNode);\n        }\n        return input;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    runConverter(rule, input, cstNode) {\n        var _a;\n        switch (rule.name.toUpperCase()) {\n            case \'INT\': return ValueConverter.convertInt(input);\n            case \'STRING\': return ValueConverter.convertString(input);\n            case \'ID\': return ValueConverter.convertID(input);\n        }\n        switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {\n            case \'number\': return ValueConverter.convertNumber(input);\n            case \'boolean\': return ValueConverter.convertBoolean(input);\n            case \'bigint\': return ValueConverter.convertBigint(input);\n            case \'date\': return ValueConverter.convertDate(input);\n            default: return input;\n        }\n    }\n}\nvar ValueConverter;\n(function (ValueConverter) {\n    function convertString(input) {\n        let result = \'\';\n        for (let i = 1; i < input.length - 1; i++) {\n            const c = input.charAt(i);\n            if (c === \'\\\\\') {\n                const c1 = input.charAt(++i);\n                result += convertEscapeCharacter(c1);\n            }\n            else {\n                result += c;\n            }\n        }\n        return result;\n    }\n    ValueConverter.convertString = convertString;\n    function convertEscapeCharacter(char) {\n        switch (char) {\n            case \'b\': return \'\\b\';\n            case \'f\': return \'\\f\';\n            case \'n\': return \'\\n\';\n            case \'r\': return \'\\r\';\n            case \'t\': return \'\\t\';\n            case \'v\': return \'\\v\';\n            case \'0\': return \'\\0\';\n            default: return char;\n        }\n    }\n    function convertID(input) {\n        if (input.charAt(0) === \'^\') {\n            return input.substring(1);\n        }\n        else {\n            return input;\n        }\n    }\n    ValueConverter.convertID = convertID;\n    function convertInt(input) {\n        return parseInt(input);\n    }\n    ValueConverter.convertInt = convertInt;\n    function convertBigint(input) {\n        return BigInt(input);\n    }\n    ValueConverter.convertBigint = convertBigint;\n    function convertDate(input) {\n        return new Date(input);\n    }\n    ValueConverter.convertDate = convertDate;\n    function convertNumber(input) {\n        return Number(input);\n    }\n    ValueConverter.convertNumber = convertNumber;\n    function convertBoolean(input) {\n        return input.toLowerCase() === \'true\';\n    }\n    ValueConverter.convertBoolean = convertBoolean;\n})(ValueConverter || (ValueConverter = {}));\n//# sourceMappingURL=value-converter.js.map\n// EXTERNAL MODULE: ./node_modules/vscode-jsonrpc/lib/common/cancellation.js\nvar cancellation = __webpack_require__(59850);\n;// ./node_modules/langium/lib/utils/cancellation.js\n/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n// eslint-disable-next-line no-restricted-imports\n\n//# sourceMappingURL=cancellation.js.map\n;// ./node_modules/langium/lib/utils/promise-utils.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Delays the execution of the current code to the next tick of the event loop.\n * Don\'t call this method directly in a tight loop to prevent too many promises from being created.\n */\nfunction delayNextTick() {\n    return new Promise(resolve => {\n        // In case we are running in a non-node environment, `setImmediate` isn\'t available.\n        // Using `setTimeout` of the browser API accomplishes the same result.\n        if (typeof setImmediate === \'undefined\') {\n            setTimeout(resolve, 0);\n        }\n        else {\n            setImmediate(resolve);\n        }\n    });\n}\nlet lastTick = 0;\nlet globalInterruptionPeriod = 10;\n/**\n * Reset the global interruption period and create a cancellation token source.\n */\nfunction startCancelableOperation() {\n    lastTick = Date.now();\n    return new CancellationTokenSource();\n}\n/**\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\n * The default value is 10ms.\n */\nfunction setInterruptionPeriod(period) {\n    globalInterruptionPeriod = period;\n}\n/**\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\n * this symbol as rejection reason.\n */\nconst promise_utils_OperationCancelled = Symbol(\'OperationCancelled\');\n/**\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\n * has been cancelled.\n */\nfunction isOperationCancelled(err) {\n    return err === promise_utils_OperationCancelled;\n}\n/**\n * This function does two things:\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\n *\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\n * the promise) to avoid that event being exposed as an error.\n */\nasync function interruptAndCheck(token) {\n    if (token === cancellation/* CancellationToken */.XO.None) {\n        // Early exit in case cancellation was disabled by the caller\n        return;\n    }\n    const current = Date.now();\n    if (current - lastTick >= globalInterruptionPeriod) {\n        lastTick = current;\n        await delayNextTick();\n    }\n    if (token.isCancellationRequested) {\n        throw promise_utils_OperationCancelled;\n    }\n}\n/**\n * Simple implementation of the deferred pattern.\n * An object that exposes a promise and functions to resolve and reject it.\n */\nclass promise_utils_Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = (arg) => {\n                resolve(arg);\n                return this;\n            };\n            this.reject = (err) => {\n                reject(err);\n                return this;\n            };\n        });\n    }\n}\n//# sourceMappingURL=promise-utils.js.map\n;// ./node_modules/vscode-languageserver-textdocument/lib/esm/main.js\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n\nclass main_FullTextDocument {\n    constructor(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    get uri() {\n        return this._uri;\n    }\n    get languageId() {\n        return this._languageId;\n    }\n    get version() {\n        return this._version;\n    }\n    getText(range) {\n        if (range) {\n            const start = this.offsetAt(range.start);\n            const end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    }\n    update(changes, version) {\n        for (const change of changes) {\n            if (main_FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                const range = getWellformedRange(change.range);\n                // update content\n                const startOffset = this.offsetAt(range.start);\n                const endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                const startLine = Math.max(range.start.line, 0);\n                const endLine = Math.max(range.end.line, 0);\n                let lineOffsets = this._lineOffsets;\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                const diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (main_FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error(\'Unknown change event received\');\n            }\n        }\n        this._version = version;\n    }\n    getLineOffsets() {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    }\n    positionAt(offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        const lineOffsets = this.getLineOffsets();\n        let low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            const mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        const line = low - 1;\n        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);\n        return { line, character: offset - lineOffsets[line] };\n    }\n    offsetAt(position) {\n        const lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        const lineOffset = lineOffsets[position.line];\n        if (position.character <= 0) {\n            return lineOffset;\n        }\n        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        const offset = Math.min(lineOffset + position.character, nextLineOffset);\n        return this.ensureBeforeEOL(offset, lineOffset);\n    }\n    ensureBeforeEOL(offset, lineOffset) {\n        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {\n            offset--;\n        }\n        return offset;\n    }\n    get lineCount() {\n        return this.getLineOffsets().length;\n    }\n    static isIncremental(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === \'string\' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === \'number\');\n    }\n    static isFull(event) {\n        const candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === \'string\' && candidate.range === undefined && candidate.rangeLength === undefined;\n    }\n}\nvar main_TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document\'s uri.\n     * @param languageId  The document\'s language Id.\n     * @param version The document\'s initial version number.\n     * @param content The document\'s content.\n     */\n    function create(uri, languageId, version, content) {\n        return new main_FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That\'s the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof main_FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error(\'TextDocument.update: document must be created by TextDocument.create\');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        const text = document.getText();\n        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\n            const diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        let lastModifiedOffset = 0;\n        const spans = [];\n        for (const e of sortedEdits) {\n            const startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error(\'Overlapping edit\');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join(\'\');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(main_TextDocument || (main_TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    const p = (data.length / 2) | 0;\n    const left = data.slice(0, p);\n    const right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    let leftIdx = 0;\n    let rightIdx = 0;\n    let i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        const ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\n    const result = isAtLineStart ? [textOffset] : [];\n    for (let i = 0; i < text.length; i++) {\n        const ch = text.charCodeAt(i);\n        if (isEOL(ch)) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction isEOL(char) {\n    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;\n}\nfunction getWellformedRange(range) {\n    const start = range.start;\n    const end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    const range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range };\n    }\n    return textEdit;\n}\n\n;// ./node_modules/vscode-uri/lib/esm/index.mjs\nvar LIB;(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf("/");if(a!==n.length-1){-1===a?(n="",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf("/"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=h,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2)}else n.length>0?n+="/"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+="..":g+="/..");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError(\'"ext" argument must be a string\');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError(\'The "pathObject" argument must be of type Object. Received type \'+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),"object"==typeof process)t="win32"===process.platform;else if("object"==typeof navigator){let e=navigator.userAgent;t=e.indexOf("Windows")>=0}const e=/^\\w[\\w\\d+.-]*$/,i=/^\\//,o=/^\\/\\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!e.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error(\'[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character\')}else if(o.test(t.path))throw new Error(\'[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")\')}const h="",a="/",c=/^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l("file",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&"file"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\\//g,"\\\\")),n}function y(t,e){const r=e?p:d;let n="",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=a,n+=a),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=":",n+=r(e.substr(t+1),!1,!0)),n+="@"}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+="?",n+=r(h,!1,!1)),c&&(n+="#",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x="/";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();const{URI: esm_URI,Utils}=LIB;\n//# sourceMappingURL=index.mjs.map\n;// ./node_modules/langium/lib/utils/uri-utils.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nvar UriUtils;\n(function (UriUtils) {\n    UriUtils.basename = Utils.basename;\n    UriUtils.dirname = Utils.dirname;\n    UriUtils.extname = Utils.extname;\n    UriUtils.joinPath = Utils.joinPath;\n    UriUtils.resolvePath = Utils.resolvePath;\n    function equals(a, b) {\n        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());\n    }\n    UriUtils.equals = equals;\n    function relative(from, to) {\n        const fromPath = typeof from === \'string\' ? from : from.path;\n        const toPath = typeof to === \'string\' ? to : to.path;\n        const fromParts = fromPath.split(\'/\').filter(e => e.length > 0);\n        const toParts = toPath.split(\'/\').filter(e => e.length > 0);\n        let i = 0;\n        for (; i < fromParts.length; i++) {\n            if (fromParts[i] !== toParts[i]) {\n                break;\n            }\n        }\n        const backPart = \'../\'.repeat(fromParts.length - i);\n        const toPart = toParts.slice(i).join(\'/\');\n        return backPart + toPart;\n    }\n    UriUtils.relative = relative;\n})(UriUtils || (UriUtils = {}));\n//# sourceMappingURL=uri-utils.js.map\n;// ./node_modules/langium/lib/workspace/documents.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n/**\n * Re-export \'TextDocument\' from \'vscode-languageserver-textdocument\' for convenience,\n *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,\n *  the overhead is very small, just a few kilobytes.\n * Everything else of that package (at the time contributing) is also defined\n *  in \'vscode-languageserver-protocol\' or \'vscode-languageserver-types\'.\n */\n\n\n\n\n\n/**\n * A document is subject to several phases that are run in predefined order. Any state value implies that\n * smaller state values are finished as well.\n */\nvar DocumentState;\n(function (DocumentState) {\n    /**\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\n     * document instance is no longer valid.\n     */\n    DocumentState[DocumentState["Changed"] = 0] = "Changed";\n    /**\n     * An AST has been created from the text content. The document structure can be traversed,\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\n     * at this stage as a preprocessing step.\n     */\n    DocumentState[DocumentState["Parsed"] = 1] = "Parsed";\n    /**\n     * The `IndexManager` service has processed AST nodes of this document. This means the\n     * exported symbols are available in the global scope and can be resolved from other documents.\n     */\n    DocumentState[DocumentState["IndexedContent"] = 2] = "IndexedContent";\n    /**\n     * The `ScopeComputation` service has processed this document. This means the local symbols\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\n     * Once a document has reached this state, you may follow every reference - it will lazily\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\n     * the target is not in scope.\n     */\n    DocumentState[DocumentState["ComputedScopes"] = 3] = "ComputedScopes";\n    /**\n     * The `Linker` service has processed this document. All outgoing references have been\n     * resolved or marked as erroneous.\n     */\n    DocumentState[DocumentState["Linked"] = 4] = "Linked";\n    /**\n     * The `IndexManager` service has processed AST node references of this document. This is\n     * necessary to determine which documents are affected by a change in one of the workspace\n     * documents.\n     */\n    DocumentState[DocumentState["IndexedReferences"] = 5] = "IndexedReferences";\n    /**\n     * The `DocumentValidator` service has processed this document. The language server listens\n     * to the results of this phase and sends diagnostics to the client.\n     */\n    DocumentState[DocumentState["Validated"] = 6] = "Validated";\n})(DocumentState || (DocumentState = {}));\nclass DefaultLangiumDocumentFactory {\n    constructor(services) {\n        this.serviceRegistry = services.ServiceRegistry;\n        this.textDocuments = services.workspace.TextDocuments;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n    }\n    async fromUri(uri, cancellationToken = cancellation/* CancellationToken */.XO.None) {\n        const content = await this.fileSystemProvider.readFile(uri);\n        return this.createAsync(uri, content, cancellationToken);\n    }\n    fromTextDocument(textDocument, uri, cancellationToken) {\n        uri = uri !== null && uri !== void 0 ? uri : esm_URI.parse(textDocument.uri);\n        if (cancellationToken) {\n            return this.createAsync(uri, textDocument, cancellationToken);\n        }\n        else {\n            return this.create(uri, textDocument);\n        }\n    }\n    fromString(text, uri, cancellationToken) {\n        if (cancellationToken) {\n            return this.createAsync(uri, text, cancellationToken);\n        }\n        else {\n            return this.create(uri, text);\n        }\n    }\n    fromModel(model, uri) {\n        return this.create(uri, { $model: model });\n    }\n    create(uri, content) {\n        if (typeof content === \'string\') {\n            const parseResult = this.parse(uri, content);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else if (\'$model\' in content) {\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\n            return this.createLangiumDocument(parseResult, uri);\n        }\n        else {\n            const parseResult = this.parse(uri, content.getText());\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    async createAsync(uri, content, cancelToken) {\n        if (typeof content === \'string\') {\n            const parseResult = await this.parseAsync(uri, content, cancelToken);\n            return this.createLangiumDocument(parseResult, uri, undefined, content);\n        }\n        else {\n            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);\n            return this.createLangiumDocument(parseResult, uri, content);\n        }\n    }\n    /**\n     * Create a LangiumDocument from a given parse result.\n     *\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\n     * should not be necessary because the main purpose of the TextDocument is to convert between\n     * text ranges and offsets, which is done solely in LSP request handling.\n     *\n     * With the introduction of {@link update} below this method is supposed to be mainly called\n     * during workspace initialization and on addition/recognition of new files, while changes in\n     * existing documents are processed via {@link update}.\n     */\n    createLangiumDocument(parseResult, uri, textDocument, text) {\n        let document;\n        if (textDocument) {\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                textDocument\n            };\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\n            document = {\n                parseResult,\n                uri,\n                state: DocumentState.Parsed,\n                references: [],\n                get textDocument() {\n                    return textDocumentGetter();\n                }\n            };\n        }\n        parseResult.value.$document = document;\n        return document;\n    }\n    async update(document, cancellationToken) {\n        var _a, _b;\n        // The CST full text property contains the original text that was used to create the AST.\n        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;\n        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());\n        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);\n        if (textDocument) {\n            Object.defineProperty(document, \'textDocument\', {\n                value: textDocument\n            });\n        }\n        else {\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\n            Object.defineProperty(document, \'textDocument\', {\n                get: textDocumentGetter\n            });\n        }\n        // Some of these documents can be pretty large, so parsing them again can be quite expensive.\n        // Therefore, we only parse if the text has actually changed.\n        if (oldText !== text) {\n            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);\n            document.parseResult.value.$document = document;\n        }\n        document.state = DocumentState.Parsed;\n        return document;\n    }\n    parse(uri, text) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.LangiumParser.parse(text);\n    }\n    parseAsync(uri, text, cancellationToken) {\n        const services = this.serviceRegistry.getServices(uri);\n        return services.parser.AsyncParser.parse(text, cancellationToken);\n    }\n    createTextDocumentGetter(uri, text) {\n        const serviceRegistry = this.serviceRegistry;\n        let textDoc = undefined;\n        return () => {\n            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = main_TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : \'\'));\n        };\n    }\n}\nclass DefaultLangiumDocuments {\n    constructor(services) {\n        this.documentMap = new Map();\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n    }\n    get all() {\n        return stream_stream(this.documentMap.values());\n    }\n    addDocument(document) {\n        const uriString = document.uri.toString();\n        if (this.documentMap.has(uriString)) {\n            throw new Error(`A document with the URI \'${uriString}\' is already present.`);\n        }\n        this.documentMap.set(uriString, document);\n    }\n    getDocument(uri) {\n        const uriString = uri.toString();\n        return this.documentMap.get(uriString);\n    }\n    async getOrCreateDocument(uri, cancellationToken) {\n        let document = this.getDocument(uri);\n        if (document) {\n            return document;\n        }\n        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);\n        this.addDocument(document);\n        return document;\n    }\n    createDocument(uri, text, cancellationToken) {\n        if (cancellationToken) {\n            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {\n                this.addDocument(document);\n                return document;\n            });\n        }\n        else {\n            const document = this.langiumDocumentFactory.fromString(text, uri);\n            this.addDocument(document);\n            return document;\n        }\n    }\n    hasDocument(uri) {\n        return this.documentMap.has(uri.toString());\n    }\n    invalidateDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            langiumDoc.precomputedScopes = undefined;\n            langiumDoc.references = [];\n            langiumDoc.diagnostics = undefined;\n        }\n        return langiumDoc;\n    }\n    deleteDocument(uri) {\n        const uriString = uri.toString();\n        const langiumDoc = this.documentMap.get(uriString);\n        if (langiumDoc) {\n            langiumDoc.state = DocumentState.Changed;\n            this.documentMap.delete(uriString);\n        }\n        return langiumDoc;\n    }\n}\n//# sourceMappingURL=documents.js.map\n;// ./node_modules/langium/lib/references/linker.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nclass DefaultLinker {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\n        this.scopeProvider = services.references.ScopeProvider;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n    }\n    async link(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        for (const node of streamAst(document.parseResult.value)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\n        }\n    }\n    doLink(refInfo, document) {\n        const ref = refInfo.reference;\n        // The reference may already have been resolved lazily by accessing its `ref` property.\n        if (ref._ref === undefined) {\n            try {\n                const description = this.getCandidate(refInfo);\n                if (isLinkingError(description)) {\n                    ref._ref = description;\n                }\n                else {\n                    ref._nodeDescription = description;\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\n                        // The target document is already loaded\n                        const linkedNode = this.loadAstNode(description);\n                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);\n                    }\n                }\n            }\n            catch (err) {\n                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to \'${ref.$refText}\': ${err}` });\n            }\n        }\n        // Add the reference to the document\'s array of references\n        document.references.push(ref);\n    }\n    unlink(document) {\n        for (const ref of document.references) {\n            delete ref._ref;\n            delete ref._nodeDescription;\n        }\n        document.references = [];\n    }\n    getCandidate(refInfo) {\n        const scope = this.scopeProvider.getScope(refInfo);\n        const description = scope.getElement(refInfo.reference.$refText);\n        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);\n    }\n    buildReference(node, property, refNode, refText) {\n        // See behavior description in doc of Linker, update that on changes in here.\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const linker = this;\n        const reference = {\n            $refNode: refNode,\n            $refText: refText,\n            get ref() {\n                var _a;\n                if (syntax_tree_isAstNode(this._ref)) {\n                    // Most frequent case: the target is already resolved.\n                    return this._ref;\n                }\n                else if (isAstNodeDescription(this._nodeDescription)) {\n                    // A candidate has been found before, but it is not loaded yet.\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\n                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\n                }\n                else if (this._ref === undefined) {\n                    // The reference has not been linked yet, so do that now.\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\n                    if (refData.error && getDocument(node).state < DocumentState.ComputedScopes) {\n                        // Document scope is not ready, don\'t set `this._ref` so linker can retry later.\n                        return undefined;\n                    }\n                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;\n                    this._nodeDescription = refData.descr;\n                }\n                return syntax_tree_isAstNode(this._ref) ? this._ref : undefined;\n            },\n            get $nodeDescription() {\n                return this._nodeDescription;\n            },\n            get error() {\n                return isLinkingError(this._ref) ? this._ref : undefined;\n            }\n        };\n        return reference;\n    }\n    getLinkedNode(refInfo) {\n        try {\n            const description = this.getCandidate(refInfo);\n            if (isLinkingError(description)) {\n                return { error: description };\n            }\n            const linkedNode = this.loadAstNode(description);\n            if (linkedNode) {\n                return { node: linkedNode, descr: description };\n            }\n            else {\n                return {\n                    descr: description,\n                    error: this.createLinkingError(refInfo, description)\n                };\n            }\n        }\n        catch (err) {\n            return {\n                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to \'${refInfo.reference.$refText}\': ${err}` })\n            };\n        }\n    }\n    loadAstNode(nodeDescription) {\n        if (nodeDescription.node) {\n            return nodeDescription.node;\n        }\n        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);\n        if (!doc) {\n            return undefined;\n        }\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\n    }\n    createLinkingError(refInfo, targetDescription) {\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\n        // in the language implementation.\n        const document = getDocument(refInfo.container);\n        if (document.state < DocumentState.ComputedScopes) {\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\n        }\n        const referenceType = this.reflection.getReferenceType(refInfo);\n        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named \'${refInfo.reference.$refText}\'.`, targetDescription });\n    }\n}\n//# sourceMappingURL=linker.js.map\n;// ./node_modules/langium/lib/references/name-provider.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nfunction isNamed(node) {\n    return typeof node.name === \'string\';\n}\nclass DefaultNameProvider {\n    getName(node) {\n        if (isNamed(node)) {\n            return node.name;\n        }\n        return undefined;\n    }\n    getNameNode(node) {\n        return findNodeForProperty(node.$cstNode, \'name\');\n    }\n}\n//# sourceMappingURL=name-provider.js.map\n;// ./node_modules/langium/lib/references/references.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultReferences {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.index = services.shared.workspace.IndexManager;\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    findDeclaration(sourceCstNode) {\n        if (sourceCstNode) {\n            const assignment = findAssignment(sourceCstNode);\n            const nodeElem = sourceCstNode.astNode;\n            if (assignment && nodeElem) {\n                const reference = nodeElem[assignment.feature];\n                if (syntax_tree_isReference(reference)) {\n                    return reference.ref;\n                }\n                else if (Array.isArray(reference)) {\n                    for (const ref of reference) {\n                        if (syntax_tree_isReference(ref) && ref.$refNode\n                            && ref.$refNode.offset <= sourceCstNode.offset\n                            && ref.$refNode.end >= sourceCstNode.end) {\n                            return ref.ref;\n                        }\n                    }\n                }\n            }\n            if (nodeElem) {\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\n                if (nameNode && (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {\n                    return nodeElem;\n                }\n            }\n        }\n        return undefined;\n    }\n    findDeclarationNode(sourceCstNode) {\n        const astNode = this.findDeclaration(sourceCstNode);\n        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {\n            const targetNode = this.nameProvider.getNameNode(astNode);\n            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;\n        }\n        return undefined;\n    }\n    findReferences(targetNode, options) {\n        const refs = [];\n        if (options.includeDeclaration) {\n            const ref = this.getReferenceToSelf(targetNode);\n            if (ref) {\n                refs.push(ref);\n            }\n        }\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\n        if (options.documentUri) {\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\n        }\n        refs.push(...indexReferences);\n        return stream_stream(refs);\n    }\n    getReferenceToSelf(targetNode) {\n        const nameNode = this.nameProvider.getNameNode(targetNode);\n        if (nameNode) {\n            const doc = getDocument(targetNode);\n            const path = this.nodeLocator.getAstNodePath(targetNode);\n            return {\n                sourceUri: doc.uri,\n                sourcePath: path,\n                targetUri: doc.uri,\n                targetPath: path,\n                segment: toDocumentSegment(nameNode),\n                local: true\n            };\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=references.js.map\n;// ./node_modules/langium/lib/utils/collections.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * A multimap is a variation of a Map that has potentially multiple values for every key.\n */\nclass MultiMap {\n    constructor(elements) {\n        this.map = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.add(key, value);\n            }\n        }\n    }\n    /**\n     * The total number of values in the multimap.\n     */\n    get size() {\n        return Reduction.sum(stream_stream(this.map.values()).map(a => a.length));\n    }\n    /**\n     * Clear all entries in the multimap.\n     */\n    clear() {\n        this.map.clear();\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\n     *  * Without a value, all values associated with the given key are deleted.\n     *\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\n     *     key / value does not exist.\n     */\n    delete(key, value) {\n        if (value === undefined) {\n            return this.map.delete(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                const index = values.indexOf(value);\n                if (index >= 0) {\n                    if (values.length === 1) {\n                        this.map.delete(key);\n                    }\n                    else {\n                        values.splice(index, 1);\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    /**\n     * Returns an array of all values associated with the given key. If no value exists,\n     * an empty array is returned.\n     *\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\n     * value and `delete` to remove a value from the multimap.\n     */\n    get(key) {\n        var _a;\n        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];\n    }\n    /**\n     * Operates differently depending on whether a `value` is given:\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\n     */\n    has(key, value) {\n        if (value === undefined) {\n            return this.map.has(key);\n        }\n        else {\n            const values = this.map.get(key);\n            if (values) {\n                return values.indexOf(value) >= 0;\n            }\n            return false;\n        }\n    }\n    /**\n     * Add the given key / value pair to the multimap.\n     */\n    add(key, value) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(value);\n        }\n        else {\n            this.map.set(key, [value]);\n        }\n        return this;\n    }\n    /**\n     * Add the given set of key / value pairs to the multimap.\n     */\n    addAll(key, values) {\n        if (this.map.has(key)) {\n            this.map.get(key).push(...values);\n        }\n        else {\n            this.map.set(key, Array.from(values));\n        }\n        return this;\n    }\n    /**\n     * Invokes the given callback function for every key / value pair in the multimap.\n     */\n    forEach(callbackfn) {\n        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));\n    }\n    /**\n     * Returns an iterator of key, value pairs for every entry in the map.\n     */\n    [Symbol.iterator]() {\n        return this.entries().iterator();\n    }\n    /**\n     * Returns a stream of key, value pairs for every entry in the map.\n     */\n    entries() {\n        return stream_stream(this.map.entries())\n            .flatMap(([key, array]) => array.map(value => [key, value]));\n    }\n    /**\n     * Returns a stream of keys in the map.\n     */\n    keys() {\n        return stream_stream(this.map.keys());\n    }\n    /**\n     * Returns a stream of values in the map.\n     */\n    values() {\n        return stream_stream(this.map.values()).flat();\n    }\n    /**\n     * Returns a stream of key, value set pairs for every key in the map.\n     */\n    entriesGroupedByKey() {\n        return stream_stream(this.map.entries());\n    }\n}\nclass BiMap {\n    get size() {\n        return this.map.size;\n    }\n    constructor(elements) {\n        this.map = new Map();\n        this.inverse = new Map();\n        if (elements) {\n            for (const [key, value] of elements) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this.map.clear();\n        this.inverse.clear();\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.inverse.set(value, key);\n        return this;\n    }\n    get(key) {\n        return this.map.get(key);\n    }\n    getKey(value) {\n        return this.inverse.get(value);\n    }\n    delete(key) {\n        const value = this.map.get(key);\n        if (value !== undefined) {\n            this.map.delete(key);\n            this.inverse.delete(value);\n            return true;\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=collections.js.map\n;// ./node_modules/langium/lib/references/scope-computation.js\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n/**\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\n * _global_ scope from the given document. By default those are the document\'s root AST node and its directly\n * contained child nodes.\n *\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents\' siblings)\n * are _invisible_ by default, but that can be changed by customizing this service.\n */\nclass DefaultScopeComputation {\n    constructor(services) {\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n    }\n    async computeExports(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\n    }\n    /**\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\n     * The list of children to be considered is determined by the function parameter {@link children}.\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\n     *\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\n     * @param document The document containing the AST node to be exported.\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\n     * @param cancelToken Indicates when to cancel the current operation.\n     * @throws `OperationCanceled` if a user action occurs during execution.\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\n     */\n    async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const exports = [];\n        this.exportNode(parentNode, exports, document);\n        for (const node of children(parentNode)) {\n            await interruptAndCheck(cancelToken);\n            this.exportNode(node, exports, document);\n        }\n        return exports;\n    }\n    /**\n     * Add a single node to the list of exports if it has a name. Override this method to change how\n     * symbols are exported, e.g. by modifying their exported name.\n     */\n    exportNode(node, exports, document) {\n        const name = this.nameProvider.getName(node);\n        if (name) {\n            exports.push(this.descriptions.createDescription(node, name, document));\n        }\n    }\n    async computeLocalScopes(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const rootNode = document.parseResult.value;\n        const scopes = new MultiMap();\n        // Here we navigate the full AST - local scopes shall be available in the whole document\n        for (const node of ast_utils_streamAllContents(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            this.processNode(node, document, scopes);\n        }\n        return scopes;\n    }\n    /**\n     * Process a single node during scopes computation. The default implementation makes the node visible\n     * in the subtree of its container (if the node has a name). Override this method to change this,\n     * e.g. by increasing the visibility to a higher level in the AST.\n     */\n    processNode(node, document, scopes) {\n        const container = node.$container;\n        if (container) {\n            const name = this.nameProvider.getName(node);\n            if (name) {\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\n            }\n        }\n    }\n}\n//# sourceMappingURL=scope-computation.js.map\n;// ./node_modules/langium/lib/references/scope.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\n * the next level of elements, which are queried when a target element is not found in the stream provided\n * to this scope.\n */\nclass StreamScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = elements;\n        this.outerScope = outerScope;\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n    }\n    getAllElements() {\n        if (this.outerScope) {\n            return this.elements.concat(this.outerScope.getAllElements());\n        }\n        else {\n            return this.elements;\n        }\n    }\n    getElement(name) {\n        const local = this.caseInsensitive\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\n            : this.elements.find(e => e.name === name);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n}\nclass MapScope {\n    constructor(elements, outerScope, options) {\n        var _a;\n        this.elements = new Map();\n        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;\n        for (const element of elements) {\n            const name = this.caseInsensitive\n                ? element.name.toLowerCase()\n                : element.name;\n            this.elements.set(name, element);\n        }\n        this.outerScope = outerScope;\n    }\n    getElement(name) {\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\n        const local = this.elements.get(localName);\n        if (local) {\n            return local;\n        }\n        if (this.outerScope) {\n            return this.outerScope.getElement(name);\n        }\n        return undefined;\n    }\n    getAllElements() {\n        let elementStream = stream_stream(this.elements.values());\n        if (this.outerScope) {\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\n        }\n        return elementStream;\n    }\n}\nconst EMPTY_SCOPE = {\n    getElement() {\n        return undefined;\n    },\n    getAllElements() {\n        return EMPTY_STREAM;\n    }\n};\n//# sourceMappingURL=scope.js.map\n;// ./node_modules/langium/lib/utils/caching.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass DisposableCache {\n    constructor() {\n        this.toDispose = [];\n        this.isDisposed = false;\n    }\n    onDispose(disposable) {\n        this.toDispose.push(disposable);\n    }\n    dispose() {\n        this.throwIfDisposed();\n        this.clear();\n        this.isDisposed = true;\n        this.toDispose.forEach(disposable => disposable.dispose());\n    }\n    throwIfDisposed() {\n        if (this.isDisposed) {\n            throw new Error(\'This cache has already been disposed\');\n        }\n    }\n}\nclass SimpleCache extends DisposableCache {\n    constructor() {\n        super(...arguments);\n        this.cache = new Map();\n    }\n    has(key) {\n        this.throwIfDisposed();\n        return this.cache.has(key);\n    }\n    set(key, value) {\n        this.throwIfDisposed();\n        this.cache.set(key, value);\n    }\n    get(key, provider) {\n        this.throwIfDisposed();\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            this.cache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(key) {\n        this.throwIfDisposed();\n        return this.cache.delete(key);\n    }\n    clear() {\n        this.throwIfDisposed();\n        this.cache.clear();\n    }\n}\nclass ContextCache extends DisposableCache {\n    constructor(converter) {\n        super();\n        this.cache = new Map();\n        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);\n    }\n    has(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).has(key);\n    }\n    set(contextKey, key, value) {\n        this.throwIfDisposed();\n        this.cacheForContext(contextKey).set(key, value);\n    }\n    get(contextKey, key, provider) {\n        this.throwIfDisposed();\n        const contextCache = this.cacheForContext(contextKey);\n        if (contextCache.has(key)) {\n            return contextCache.get(key);\n        }\n        else if (provider) {\n            const value = provider();\n            contextCache.set(key, value);\n            return value;\n        }\n        else {\n            return undefined;\n        }\n    }\n    delete(contextKey, key) {\n        this.throwIfDisposed();\n        return this.cacheForContext(contextKey).delete(key);\n    }\n    clear(contextKey) {\n        this.throwIfDisposed();\n        if (contextKey) {\n            const mapKey = this.converter(contextKey);\n            this.cache.delete(mapKey);\n        }\n        else {\n            this.cache.clear();\n        }\n    }\n    cacheForContext(contextKey) {\n        const mapKey = this.converter(contextKey);\n        let documentCache = this.cache.get(mapKey);\n        if (!documentCache) {\n            documentCache = new Map();\n            this.cache.set(mapKey, documentCache);\n        }\n        return documentCache;\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to a document.\n * If this document is changed or deleted, all associated key/value pairs are deleted.\n */\nclass DocumentCache extends ContextCache {\n    constructor(sharedServices) {\n        super(uri => uri.toString());\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\n            const allUris = changed.concat(deleted);\n            for (const uri of allUris) {\n                this.clear(uri);\n            }\n        }));\n    }\n}\n/**\n * Every key/value pair in this cache is scoped to the whole workspace.\n * If any document in the workspace changes, the whole cache is evicted.\n */\nclass WorkspaceCache extends SimpleCache {\n    constructor(sharedServices) {\n        super();\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\n            this.clear();\n        }));\n    }\n}\n//# sourceMappingURL=caching.js.map\n;// ./node_modules/langium/lib/references/scope-provider.js\n/******************************************************************************\n * Copyright 2021-2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\nclass DefaultScopeProvider {\n    constructor(services) {\n        this.reflection = services.shared.AstReflection;\n        this.nameProvider = services.references.NameProvider;\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.globalScopeCache = new WorkspaceCache(services.shared);\n    }\n    getScope(context) {\n        const scopes = [];\n        const referenceType = this.reflection.getReferenceType(context);\n        const precomputed = getDocument(context.container).precomputedScopes;\n        if (precomputed) {\n            let currentNode = context.container;\n            do {\n                const allDescriptions = precomputed.get(currentNode);\n                if (allDescriptions.length > 0) {\n                    scopes.push(stream_stream(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));\n                }\n                currentNode = currentNode.$container;\n            } while (currentNode);\n        }\n        let result = this.getGlobalScope(referenceType, context);\n        for (let i = scopes.length - 1; i >= 0; i--) {\n            result = this.createScope(scopes[i], result);\n        }\n        return result;\n    }\n    /**\n     * Create a scope for the given collection of AST node descriptions.\n     */\n    createScope(elements, outerScope, options) {\n        return new StreamScope(stream_stream(elements), outerScope, options);\n    }\n    /**\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\n     */\n    createScopeForNodes(elements, outerScope, options) {\n        const s = stream_stream(elements).map(e => {\n            const name = this.nameProvider.getName(e);\n            if (name) {\n                return this.descriptions.createDescription(e, name);\n            }\n            return undefined;\n        }).nonNullable();\n        return new StreamScope(s, outerScope, options);\n    }\n    /**\n     * Create a global scope filtered for the given reference type.\n     */\n    getGlobalScope(referenceType, _context) {\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\n    }\n}\n//# sourceMappingURL=scope-provider.js.map\n;// ./node_modules/langium/lib/serializer/json-serializer.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\nfunction isAstNodeWithComment(node) {\n    return typeof node.$comment === \'string\';\n}\nfunction isIntermediateReference(obj) {\n    return typeof obj === \'object\' && !!obj && (\'$ref\' in obj || \'$error\' in obj);\n}\nclass DefaultJsonSerializer {\n    constructor(services) {\n        /** The set of AstNode properties to be ignored by the serializer. */\n        this.ignoreProperties = new Set([\'$container\', \'$containerProperty\', \'$containerIndex\', \'$document\', \'$cstNode\']);\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    serialize(node, options = {}) {\n        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;\n        const defaultReplacer = (key, value) => this.replacer(key, value, options);\n        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\n        try {\n            this.currentDocument = getDocument(node);\n            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);\n        }\n        finally {\n            this.currentDocument = undefined;\n        }\n    }\n    deserialize(content, options = {}) {\n        const root = JSON.parse(content);\n        this.linkNode(root, root, options);\n        return root;\n    }\n    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {\n        var _a, _b, _c, _d;\n        if (this.ignoreProperties.has(key)) {\n            return undefined;\n        }\n        else if (syntax_tree_isReference(value)) {\n            const refValue = value.ref;\n            const $refText = refText ? value.$refText : undefined;\n            if (refValue) {\n                const targetDocument = getDocument(refValue);\n                let targetUri = \'\';\n                if (this.currentDocument && this.currentDocument !== targetDocument) {\n                    if (uriConverter) {\n                        targetUri = uriConverter(targetDocument.uri, value);\n                    }\n                    else {\n                        targetUri = targetDocument.uri.toString();\n                    }\n                }\n                const targetPath = this.astNodeLocator.getAstNodePath(refValue);\n                return {\n                    $ref: `${targetUri}#${targetPath}`,\n                    $refText\n                };\n            }\n            else {\n                return {\n                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : \'Could not resolve reference\',\n                    $refText\n                };\n            }\n        }\n        else if (syntax_tree_isAstNode(value)) {\n            let astNode = undefined;\n            if (textRegions) {\n                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));\n                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {\n                    // The document URI is added to the root node of the resulting JSON tree\n                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();\n                }\n            }\n            if (sourceText && !key) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;\n            }\n            if (comments) {\n                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));\n                const comment = this.commentProvider.getComment(value);\n                if (comment) {\n                    astNode.$comment = comment.replace(/\\r/g, \'\');\n                }\n            }\n            return astNode !== null && astNode !== void 0 ? astNode : value;\n        }\n        else {\n            return value;\n        }\n    }\n    addAstNodeRegionWithAssignmentsTo(node) {\n        const createDocumentSegment = cstNode => ({\n            offset: cstNode.offset,\n            end: cstNode.end,\n            length: cstNode.length,\n            range: cstNode.range,\n        });\n        if (node.$cstNode) {\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\n            const assignments = textRegion.assignments = {};\n            Object.keys(node).filter(key => !key.startsWith(\'$\')).forEach(key => {\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\n                if (propertyAssignments.length !== 0) {\n                    assignments[key] = propertyAssignments;\n                }\n            });\n            return node;\n        }\n        return undefined;\n    }\n    linkNode(node, root, options, container, containerProperty, containerIndex) {\n        for (const [propertyName, item] of Object.entries(node)) {\n            if (Array.isArray(item)) {\n                for (let index = 0; index < item.length; index++) {\n                    const element = item[index];\n                    if (isIntermediateReference(element)) {\n                        item[index] = this.reviveReference(node, propertyName, root, element, options);\n                    }\n                    else if (syntax_tree_isAstNode(element)) {\n                        this.linkNode(element, root, options, node, propertyName, index);\n                    }\n                }\n            }\n            else if (isIntermediateReference(item)) {\n                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);\n            }\n            else if (syntax_tree_isAstNode(item)) {\n                this.linkNode(item, root, options, node, propertyName);\n            }\n        }\n        const mutable = node;\n        mutable.$container = container;\n        mutable.$containerProperty = containerProperty;\n        mutable.$containerIndex = containerIndex;\n    }\n    reviveReference(container, property, root, reference, options) {\n        let refText = reference.$refText;\n        let error = reference.$error;\n        if (reference.$ref) {\n            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);\n            if (syntax_tree_isAstNode(ref)) {\n                if (!refText) {\n                    refText = this.nameProvider.getName(ref);\n                }\n                return {\n                    $refText: refText !== null && refText !== void 0 ? refText : \'\',\n                    ref\n                };\n            }\n            else {\n                error = ref;\n            }\n        }\n        if (error) {\n            const ref = {\n                $refText: refText !== null && refText !== void 0 ? refText : \'\'\n            };\n            ref.error = {\n                container,\n                property,\n                message: error,\n                reference: ref\n            };\n            return ref;\n        }\n        else {\n            return undefined;\n        }\n    }\n    getRefNode(root, uri, uriConverter) {\n        try {\n            const fragmentIndex = uri.indexOf(\'#\');\n            if (fragmentIndex === 0) {\n                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));\n                if (!node) {\n                    return \'Could not resolve path: \' + uri;\n                }\n                return node;\n            }\n            if (fragmentIndex < 0) {\n                const documentUri = uriConverter ? uriConverter(uri) : esm_URI.parse(uri);\n                const document = this.langiumDocuments.getDocument(documentUri);\n                if (!document) {\n                    return \'Could not find document for URI: \' + uri;\n                }\n                return document.parseResult.value;\n            }\n            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : esm_URI.parse(uri.substring(0, fragmentIndex));\n            const document = this.langiumDocuments.getDocument(documentUri);\n            if (!document) {\n                return \'Could not find document for URI: \' + uri;\n            }\n            if (fragmentIndex === uri.length - 1) {\n                return document.parseResult.value;\n            }\n            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));\n            if (!node) {\n                return \'Could not resolve URI: \' + uri;\n            }\n            return node;\n        }\n        catch (err) {\n            return String(err);\n        }\n    }\n}\n//# sourceMappingURL=json-serializer.js.map\n;// ./node_modules/langium/lib/service-registry.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)\n */\nclass DefaultServiceRegistry {\n    register(language) {\n        if (!this.singleton && !this.map) {\n            // This is the first language to be registered; store it as singleton.\n            this.singleton = language;\n            return;\n        }\n        if (!this.map) {\n            this.map = {};\n            if (this.singleton) {\n                // Move the previous singleton instance to the new map.\n                for (const ext of this.singleton.LanguageMetaData.fileExtensions) {\n                    this.map[ext] = this.singleton;\n                }\n                this.singleton = undefined;\n            }\n        }\n        // Store the language services in the map.\n        for (const ext of language.LanguageMetaData.fileExtensions) {\n            if (this.map[ext] !== undefined && this.map[ext] !== language) {\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to \'${language.LanguageMetaData.languageId}\'.`);\n            }\n            this.map[ext] = language;\n        }\n    }\n    getServices(uri) {\n        if (this.singleton !== undefined) {\n            return this.singleton;\n        }\n        if (this.map === undefined) {\n            throw new Error(\'The service registry is empty. Use `register` to register the services of a language.\');\n        }\n        const ext = UriUtils.extname(uri);\n        const services = this.map[ext];\n        if (!services) {\n            throw new Error(`The service registry contains no services for the extension \'${ext}\'.`);\n        }\n        return services;\n    }\n    get all() {\n        if (this.singleton !== undefined) {\n            return [this.singleton];\n        }\n        if (this.map !== undefined) {\n            return Object.values(this.map);\n        }\n        return [];\n    }\n}\n//# sourceMappingURL=service-registry.js.map\n;// ./node_modules/langium/lib/validation/validation-registry.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n/**\n * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.\n */\nfunction diagnosticData(code) {\n    return { code };\n}\nvar ValidationCategory;\n(function (ValidationCategory) {\n    ValidationCategory.all = [\'fast\', \'slow\', \'built-in\'];\n})(ValidationCategory || (ValidationCategory = {}));\n/**\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\n */\nclass ValidationRegistry {\n    constructor(services) {\n        this.entries = new MultiMap();\n        this.reflection = services.shared.AstReflection;\n    }\n    /**\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\n     * or an array of validation checks.\n     *\n     * @param checksRecord Set of validation checks to register.\n     * @param category Optional category for the validation checks (defaults to `\'fast\'`).\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\n     */\n    register(checksRecord, thisObj = this, category = \'fast\') {\n        if (category === \'built-in\') {\n            throw new Error("The \'built-in\' category is reserved for lexer, parser, and linker errors.");\n        }\n        for (const [type, ch] of Object.entries(checksRecord)) {\n            const callbacks = ch;\n            if (Array.isArray(callbacks)) {\n                for (const check of callbacks) {\n                    const entry = {\n                        check: this.wrapValidationException(check, thisObj),\n                        category\n                    };\n                    this.addEntry(type, entry);\n                }\n            }\n            else if (typeof callbacks === \'function\') {\n                const entry = {\n                    check: this.wrapValidationException(callbacks, thisObj),\n                    category\n                };\n                this.addEntry(type, entry);\n            }\n        }\n    }\n    wrapValidationException(check, thisObj) {\n        return async (node, accept, cancelToken) => {\n            try {\n                await check.call(thisObj, node, accept, cancelToken);\n            }\n            catch (err) {\n                if (isOperationCancelled(err)) {\n                    throw err;\n                }\n                console.error(\'An error occurred during validation:\', err);\n                const message = err instanceof Error ? err.message : String(err);\n                if (err instanceof Error && err.stack) {\n                    console.error(err.stack);\n                }\n                accept(\'error\', \'An error occurred during validation: \' + message, { node });\n            }\n        };\n    }\n    addEntry(type, entry) {\n        if (type === \'AstNode\') {\n            this.entries.add(\'AstNode\', entry);\n            return;\n        }\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\n            this.entries.add(subtype, entry);\n        }\n    }\n    getChecks(type, categories) {\n        let checks = stream_stream(this.entries.get(type))\n            .concat(this.entries.get(\'AstNode\'));\n        if (categories) {\n            checks = checks.filter(entry => categories.includes(entry.category));\n        }\n        return checks.map(entry => entry.check);\n    }\n}\n//# sourceMappingURL=validation-registry.js.map\n;// ./node_modules/langium/lib/validation/document-validator.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultDocumentValidator {\n    constructor(services) {\n        this.validationRegistry = services.validation.ValidationRegistry;\n        this.metadata = services.LanguageMetaData;\n    }\n    async validateDocument(document, options = {}, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const parseResult = document.parseResult;\n        const diagnostics = [];\n        await interruptAndCheck(cancelToken);\n        if (!options.categories || options.categories.includes(\'built-in\')) {\n            this.processLexingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {\n                return diagnostics;\n            }\n            this.processParsingErrors(parseResult, diagnostics, options);\n            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {\n                return diagnostics;\n            }\n            this.processLinkingErrors(document, diagnostics, options);\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {\n                return diagnostics;\n            }\n        }\n        // Process custom validations\n        try {\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\n        }\n        catch (err) {\n            if (isOperationCancelled(err)) {\n                throw err;\n            }\n            console.error(\'An error occurred during validation:\', err);\n        }\n        await interruptAndCheck(cancelToken);\n        return diagnostics;\n    }\n    processLexingErrors(parseResult, diagnostics, _options) {\n        for (const lexerError of parseResult.lexerErrors) {\n            const diagnostic = {\n                severity: toDiagnosticSeverity(\'error\'),\n                range: {\n                    start: {\n                        line: lexerError.line - 1,\n                        character: lexerError.column - 1\n                    },\n                    end: {\n                        line: lexerError.line - 1,\n                        character: lexerError.column + lexerError.length - 1\n                    }\n                },\n                message: lexerError.message,\n                data: diagnosticData(DocumentValidator.LexingError),\n                source: this.getSource()\n            };\n            diagnostics.push(diagnostic);\n        }\n    }\n    processParsingErrors(parseResult, diagnostics, _options) {\n        for (const parserError of parseResult.parserErrors) {\n            let range = undefined;\n            // We can run into the chevrotain error recovery here\n            // The token contained in the parser error might be automatically inserted\n            // In this case every position value will be `NaN`\n            if (isNaN(parserError.token.startOffset)) {\n                // Some special parser error types contain a `previousToken`\n                // We can simply append our diagnostic to that token\n                if (\'previousToken\' in parserError) {\n                    const token = parserError.previousToken;\n                    if (!isNaN(token.startOffset)) {\n                        const position = { line: token.endLine - 1, character: token.endColumn };\n                        range = { start: position, end: position };\n                    }\n                    else {\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\n                        // Point to document start\n                        const position = { line: 0, character: 0 };\n                        range = { start: position, end: position };\n                    }\n                }\n            }\n            else {\n                range = tokenToRange(parserError.token);\n            }\n            if (range) {\n                const diagnostic = {\n                    severity: toDiagnosticSeverity(\'error\'),\n                    range,\n                    message: parserError.message,\n                    data: diagnosticData(DocumentValidator.ParsingError),\n                    source: this.getSource()\n                };\n                diagnostics.push(diagnostic);\n            }\n        }\n    }\n    processLinkingErrors(document, diagnostics, _options) {\n        for (const reference of document.references) {\n            const linkingError = reference.error;\n            if (linkingError) {\n                const info = {\n                    node: linkingError.container,\n                    property: linkingError.property,\n                    index: linkingError.index,\n                    data: {\n                        code: DocumentValidator.LinkingError,\n                        containerType: linkingError.container.$type,\n                        property: linkingError.property,\n                        refText: linkingError.reference.$refText\n                    }\n                };\n                diagnostics.push(this.toDiagnostic(\'error\', linkingError.message, info));\n            }\n        }\n    }\n    async validateAst(rootNode, options, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const validationItems = [];\n        const acceptor = (severity, message, info) => {\n            validationItems.push(this.toDiagnostic(severity, message, info));\n        };\n        await Promise.all(streamAst(rootNode).map(async (node) => {\n            await interruptAndCheck(cancelToken);\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\n            for (const check of checks) {\n                await check(node, acceptor, cancelToken);\n            }\n        }));\n        return validationItems;\n    }\n    toDiagnostic(severity, message, info) {\n        return {\n            message,\n            range: getDiagnosticRange(info),\n            severity: toDiagnosticSeverity(severity),\n            code: info.code,\n            codeDescription: info.codeDescription,\n            tags: info.tags,\n            relatedInformation: info.relatedInformation,\n            data: info.data,\n            source: this.getSource()\n        };\n    }\n    getSource() {\n        return this.metadata.languageId;\n    }\n}\nfunction getDiagnosticRange(info) {\n    if (info.range) {\n        return info.range;\n    }\n    let cstNode;\n    if (typeof info.property === \'string\') {\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\n    }\n    else if (typeof info.keyword === \'string\') {\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\n    }\n    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);\n    if (!cstNode) {\n        return {\n            start: { line: 0, character: 0 },\n            end: { line: 0, character: 0 }\n        };\n    }\n    return cstNode.range;\n}\nfunction toDiagnosticSeverity(severity) {\n    switch (severity) {\n        case \'error\':\n            return 1; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Error\n        case \'warning\':\n            return 2; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Warning\n        case \'info\':\n            return 3; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Information\n        case \'hint\':\n            return 4; // according to vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity.Hint\n        default:\n            throw new Error(\'Invalid diagnostic severity: \' + severity);\n    }\n}\nvar DocumentValidator;\n(function (DocumentValidator) {\n    DocumentValidator.LexingError = \'lexing-error\';\n    DocumentValidator.ParsingError = \'parsing-error\';\n    DocumentValidator.LinkingError = \'linking-error\';\n})(DocumentValidator || (DocumentValidator = {}));\n//# sourceMappingURL=document-validator.js.map\n;// ./node_modules/langium/lib/workspace/ast-descriptions.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultAstNodeDescriptionProvider {\n    constructor(services) {\n        this.astNodeLocator = services.workspace.AstNodeLocator;\n        this.nameProvider = services.references.NameProvider;\n    }\n    createDescription(node, name, document = getDocument(node)) {\n        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));\n        const path = this.astNodeLocator.getAstNodePath(node);\n        if (!name) {\n            throw new Error(`Node at path ${path} has no name.`);\n        }\n        let nameNodeSegment;\n        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };\n        return {\n            node,\n            name,\n            get nameSegment() {\n                return nameSegmentGetter();\n            },\n            selectionSegment: toDocumentSegment(node.$cstNode),\n            type: node.$type,\n            documentUri: document.uri,\n            path\n        };\n    }\n}\nclass DefaultReferenceDescriptionProvider {\n    constructor(services) {\n        this.nodeLocator = services.workspace.AstNodeLocator;\n    }\n    async createDescriptions(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const descr = [];\n        const rootNode = document.parseResult.value;\n        for (const astNode of streamAst(rootNode)) {\n            await interruptAndCheck(cancelToken);\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\n                const description = this.createDescription(refInfo);\n                if (description) {\n                    descr.push(description);\n                }\n            });\n        }\n        return descr;\n    }\n    createDescription(refInfo) {\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\n        const refCstNode = refInfo.reference.$refNode;\n        if (!targetNodeDescr || !refCstNode) {\n            return undefined;\n        }\n        const docUri = getDocument(refInfo.container).uri;\n        return {\n            sourceUri: docUri,\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\n            targetUri: targetNodeDescr.documentUri,\n            targetPath: targetNodeDescr.path,\n            segment: toDocumentSegment(refCstNode),\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\n        };\n    }\n}\n//# sourceMappingURL=ast-descriptions.js.map\n;// ./node_modules/langium/lib/workspace/ast-node-locator.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass DefaultAstNodeLocator {\n    constructor() {\n        this.segmentSeparator = \'/\';\n        this.indexSeparator = \'@\';\n    }\n    getAstNodePath(node) {\n        if (node.$container) {\n            const containerPath = this.getAstNodePath(node.$container);\n            const newSegment = this.getPathSegment(node);\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\n            return nodePath;\n        }\n        return \'\';\n    }\n    getPathSegment({ $containerProperty, $containerIndex }) {\n        if (!$containerProperty) {\n            throw new Error("Missing \'$containerProperty\' in AST node.");\n        }\n        if ($containerIndex !== undefined) {\n            return $containerProperty + this.indexSeparator + $containerIndex;\n        }\n        return $containerProperty;\n    }\n    getAstNode(node, path) {\n        const segments = path.split(this.segmentSeparator);\n        return segments.reduce((previousValue, currentValue) => {\n            if (!previousValue || currentValue.length === 0) {\n                return previousValue;\n            }\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\n            if (propertyIndex > 0) {\n                const property = currentValue.substring(0, propertyIndex);\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\n                const array = previousValue[property];\n                return array === null || array === void 0 ? void 0 : array[arrayIndex];\n            }\n            return previousValue[currentValue];\n        }, node);\n    }\n}\n//# sourceMappingURL=ast-node-locator.js.map\n;// ./node_modules/langium/lib/workspace/configuration.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n/**\n * Base configuration provider for building up other configuration providers\n */\nclass DefaultConfigurationProvider {\n    constructor(services) {\n        this._ready = new promise_utils_Deferred();\n        this.settings = {};\n        this.workspaceConfig = false;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a, _b;\n        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;\n    }\n    async initialized(params) {\n        if (this.workspaceConfig) {\n            if (params.register) {\n                // params.register(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const languages = this.serviceRegistry.all;\n                params.register({\n                    // Listen to configuration changes for all languages\n                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\n                });\n            }\n            if (params.fetchConfiguration) {\n                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of\n                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection\n                const configToUpdate = this.serviceRegistry.all.map(lang => ({\n                    // Fetch the configuration changes for all languages\n                    section: this.toSectionName(lang.LanguageMetaData.languageId)\n                }));\n                // get workspace configurations (default scope URI)\n                const configs = await params.fetchConfiguration(configToUpdate);\n                configToUpdate.forEach((conf, idx) => {\n                    this.updateSectionConfiguration(conf.section, configs[idx]);\n                });\n            }\n        }\n        this._ready.resolve();\n    }\n    /**\n     *  Updates the cached configurations using the `change` notification parameters.\n     *\n     * @param change The parameters of a change configuration notification.\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\n     */\n    updateConfiguration(change) {\n        if (!change.settings) {\n            return;\n        }\n        Object.keys(change.settings).forEach(section => {\n            this.updateSectionConfiguration(section, change.settings[section]);\n        });\n    }\n    updateSectionConfiguration(section, configuration) {\n        this.settings[section] = configuration;\n    }\n    /**\n    * Returns a configuration value stored for the given language.\n    *\n    * @param language The language id\n    * @param configuration Configuration name\n    */\n    async getConfiguration(language, configuration) {\n        await this.ready;\n        const sectionName = this.toSectionName(language);\n        if (this.settings[sectionName]) {\n            return this.settings[sectionName][configuration];\n        }\n    }\n    toSectionName(languageId) {\n        return `${languageId}`;\n    }\n}\n//# sourceMappingURL=configuration.js.map\n;// ./node_modules/langium/lib/utils/disposable.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nvar Disposable;\n(function (Disposable) {\n    function create(callback) {\n        return {\n            dispose: async () => await callback()\n        };\n    }\n    Disposable.create = create;\n})(Disposable || (Disposable = {}));\n//# sourceMappingURL=disposable.js.map\n;// ./node_modules/langium/lib/workspace/document-builder.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\nclass DefaultDocumentBuilder {\n    constructor(services) {\n        this.updateBuildOptions = {\n            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\n            validation: {\n                categories: [\'built-in\', \'fast\']\n            }\n        };\n        this.updateListeners = [];\n        this.buildPhaseListeners = new MultiMap();\n        this.buildState = new Map();\n        this.documentBuildWaiters = new Map();\n        this.currentState = DocumentState.Changed;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\n        this.indexManager = services.workspace.IndexManager;\n        this.serviceRegistry = services.ServiceRegistry;\n    }\n    async build(documents, options = {}, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        var _a, _b;\n        for (const document of documents) {\n            const key = document.uri.toString();\n            if (document.state === DocumentState.Validated) {\n                if (typeof options.validation === \'boolean\' && options.validation) {\n                    // Force re-running all validation checks\n                    document.state = DocumentState.IndexedReferences;\n                    document.diagnostics = undefined;\n                    this.buildState.delete(key);\n                }\n                else if (typeof options.validation === \'object\') {\n                    const buildState = this.buildState.get(key);\n                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;\n                    if (previousCategories) {\n                        // Validation with explicit options was requested for a document that has already been partly validated.\n                        // In this case, we need to merge the previous validation categories with the new ones.\n                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\n                        if (categories.length > 0) {\n                            this.buildState.set(key, {\n                                completed: false,\n                                options: {\n                                    validation: Object.assign(Object.assign({}, options.validation), { categories })\n                                },\n                                result: buildState.result\n                            });\n                            document.state = DocumentState.IndexedReferences;\n                        }\n                    }\n                }\n            }\n            else {\n                // Default: forget any previous build options\n                this.buildState.delete(key);\n            }\n        }\n        this.currentState = DocumentState.Changed;\n        await this.emitUpdate(documents.map(e => e.uri), []);\n        await this.buildDocuments(documents, options, cancelToken);\n    }\n    async update(changed, deleted, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        this.currentState = DocumentState.Changed;\n        // Remove all metadata of documents that are reported as deleted\n        for (const deletedUri of deleted) {\n            this.langiumDocuments.deleteDocument(deletedUri);\n            this.buildState.delete(deletedUri.toString());\n            this.indexManager.remove(deletedUri);\n        }\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\n        for (const changedUri of changed) {\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\n            if (!invalidated) {\n                // We create an unparsed, invalid document.\n                // This will be parsed as soon as we reach the first document builder phase.\n                // This allows to cancel the parsing process later in case we need it.\n                const newDocument = this.langiumDocumentFactory.fromModel({ $type: \'INVALID\' }, changedUri);\n                newDocument.state = DocumentState.Changed;\n                this.langiumDocuments.addDocument(newDocument);\n            }\n            this.buildState.delete(changedUri.toString());\n        }\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\n        const allChangedUris = stream_stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\n        this.langiumDocuments.all\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\n            .forEach(doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            linker.unlink(doc);\n            doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\n            doc.diagnostics = undefined;\n        });\n        // Notify listeners of the update\n        await this.emitUpdate(changed, deleted);\n        // Only allow interrupting the execution after all state changes are done\n        await interruptAndCheck(cancelToken);\n        // Collect all documents that we should rebuild\n        const rebuildDocuments = this.langiumDocuments.all\n            .filter(doc => {\n            var _a;\n            // This includes those that were reported as changed and those that we selected for relinking\n            return doc.state < DocumentState.Linked\n                // This includes those for which a previous build has been cancelled\n                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);\n        })\n            .toArray();\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\n    }\n    async emitUpdate(changed, deleted) {\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\n    }\n    /**\n     * Check whether the given document should be relinked after changes were found in the given URIs.\n     */\n    shouldRelink(document, changedUris) {\n        // Relink documents with linking errors -- maybe those references can be resolved now\n        if (document.references.some(ref => ref.error !== undefined)) {\n            return true;\n        }\n        // Check whether the document is affected by any of the changed URIs\n        return this.indexManager.isAffected(document, changedUris);\n    }\n    onUpdate(callback) {\n        this.updateListeners.push(callback);\n        return Disposable.create(() => {\n            const index = this.updateListeners.indexOf(callback);\n            if (index >= 0) {\n                this.updateListeners.splice(index, 1);\n            }\n        });\n    }\n    /**\n     * Build the given documents by stepping through all build phases. If a document\'s state indicates\n     * that a certain build phase is already done, the phase is skipped for that document.\n     */\n    async buildDocuments(documents, options, cancelToken) {\n        this.prepareBuild(documents, options);\n        // 0. Parse content\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));\n        // 1. Index content\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));\n        // 2. Compute scopes\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) => {\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\n        });\n        // 3. Linking\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\n            return linker.link(doc, cancelToken);\n        });\n        // 4. Index references\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));\n        // 5. Validation\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));\n        // If we\'ve made it to this point without being cancelled, we can mark the build state as completed.\n        for (const doc of documents) {\n            const state = this.buildState.get(doc.uri.toString());\n            if (state) {\n                state.completed = true;\n            }\n        }\n    }\n    prepareBuild(documents, options) {\n        for (const doc of documents) {\n            const key = doc.uri.toString();\n            const state = this.buildState.get(key);\n            // If the document has no previous build state, we set it. If it has one, but it\'s already marked\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\n            // and continue where it was cancelled.\n            if (!state || state.completed) {\n                this.buildState.set(key, {\n                    completed: false,\n                    options,\n                    result: state === null || state === void 0 ? void 0 : state.result\n                });\n            }\n        }\n    }\n    async runCancelable(documents, targetState, cancelToken, callback) {\n        const filtered = documents.filter(e => e.state < targetState);\n        for (const document of filtered) {\n            await interruptAndCheck(cancelToken);\n            await callback(document);\n            document.state = targetState;\n        }\n        await this.notifyBuildPhase(filtered, targetState, cancelToken);\n        this.currentState = targetState;\n    }\n    onBuildPhase(targetState, callback) {\n        this.buildPhaseListeners.add(targetState, callback);\n        return Disposable.create(() => {\n            this.buildPhaseListeners.delete(targetState, callback);\n        });\n    }\n    waitUntil(state, uriOrToken, cancelToken) {\n        let uri = undefined;\n        if (uriOrToken && \'path\' in uriOrToken) {\n            uri = uriOrToken;\n        }\n        else {\n            cancelToken = uriOrToken;\n        }\n        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = cancellation/* CancellationToken */.XO.None);\n        if (uri) {\n            const document = this.langiumDocuments.getDocument(uri);\n            if (document && document.state > state) {\n                return Promise.resolve(uri);\n            }\n        }\n        if (this.currentState >= state) {\n            return Promise.resolve(undefined);\n        }\n        else if (cancelToken.isCancellationRequested) {\n            return Promise.reject(promise_utils_OperationCancelled);\n        }\n        return new Promise((resolve, reject) => {\n            const buildDisposable = this.onBuildPhase(state, () => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                if (uri) {\n                    const document = this.langiumDocuments.getDocument(uri);\n                    resolve(document === null || document === void 0 ? void 0 : document.uri);\n                }\n                else {\n                    resolve(undefined);\n                }\n            });\n            const cancelDisposable = cancelToken.onCancellationRequested(() => {\n                buildDisposable.dispose();\n                cancelDisposable.dispose();\n                reject(promise_utils_OperationCancelled);\n            });\n        });\n    }\n    async notifyBuildPhase(documents, state, cancelToken) {\n        if (documents.length === 0) {\n            // Don\'t notify when no document has been processed\n            return;\n        }\n        const listeners = this.buildPhaseListeners.get(state);\n        for (const listener of listeners) {\n            await interruptAndCheck(cancelToken);\n            await listener(documents, cancelToken);\n        }\n    }\n    /**\n     * Determine whether the given document should be validated during a build. The default\n     * implementation checks the `validation` property of the build options. If it\'s set to `true`\n     * or a `ValidationOptions` object, the document is included in the validation phase.\n     */\n    shouldValidate(document) {\n        return Boolean(this.getBuildOptions(document).validation);\n    }\n    /**\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\n     * If the document already contains diagnostics, the new ones are added to the list.\n     */\n    async validate(document, cancelToken) {\n        var _a, _b;\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\n        const validationSetting = this.getBuildOptions(document).validation;\n        const options = typeof validationSetting === \'object\' ? validationSetting : undefined;\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\n        if (document.diagnostics) {\n            document.diagnostics.push(...diagnostics);\n        }\n        else {\n            document.diagnostics = diagnostics;\n        }\n        // Store information about the executed validation in the build state\n        const state = this.buildState.get(document.uri.toString());\n        if (state) {\n            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});\n            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : ValidationCategory.all;\n            if (state.result.validationChecks) {\n                state.result.validationChecks.push(...newCategories);\n            }\n            else {\n                state.result.validationChecks = [...newCategories];\n            }\n        }\n    }\n    getBuildOptions(document) {\n        var _a, _b;\n        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};\n    }\n}\n//# sourceMappingURL=document-builder.js.map\n;// ./node_modules/langium/lib/workspace/index-manager.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nclass DefaultIndexManager {\n    constructor(services) {\n        /**\n         * The symbol index stores all `AstNodeDescription` items exported by a document.\n         * The key used in this map is the string representation of the specific document URI.\n         */\n        this.symbolIndex = new Map();\n        /**\n         * This is a cache for the `allElements()` method.\n         * It caches the descriptions from `symbolIndex` grouped by types.\n         */\n        this.symbolByTypeIndex = new ContextCache();\n        /**\n         * This index keeps track of all `ReferenceDescription` items exported by a document.\n         * This is used to compute which elements are affected by a document change\n         * and for finding references to an AST node.\n         */\n        this.referenceIndex = new Map();\n        this.documents = services.workspace.LangiumDocuments;\n        this.serviceRegistry = services.ServiceRegistry;\n        this.astReflection = services.AstReflection;\n    }\n    findAllReferences(targetNode, astNodePath) {\n        const targetDocUri = getDocument(targetNode).uri;\n        const result = [];\n        this.referenceIndex.forEach(docRefs => {\n            docRefs.forEach(refDescr => {\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\n                    result.push(refDescr);\n                }\n            });\n        });\n        return stream_stream(result);\n    }\n    allElements(nodeType, uris) {\n        let documentUris = stream_stream(this.symbolIndex.keys());\n        if (uris) {\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\n        }\n        return documentUris\n            .map(uri => this.getFileDescriptions(uri, nodeType))\n            .flat();\n    }\n    getFileDescriptions(uri, nodeType) {\n        var _a;\n        if (!nodeType) {\n            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n        }\n        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {\n            var _a;\n            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\n        });\n        return descriptions;\n    }\n    remove(uri) {\n        const uriString = uri.toString();\n        this.symbolIndex.delete(uriString);\n        this.symbolByTypeIndex.clear(uriString);\n        this.referenceIndex.delete(uriString);\n    }\n    async updateContent(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);\n        const uri = document.uri.toString();\n        this.symbolIndex.set(uri, exports);\n        this.symbolByTypeIndex.clear(uri);\n    }\n    async updateReferences(document, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const services = this.serviceRegistry.getServices(document.uri);\n        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\n        this.referenceIndex.set(document.uri.toString(), indexData);\n    }\n    isAffected(document, changedUris) {\n        const references = this.referenceIndex.get(document.uri.toString());\n        if (!references) {\n            return false;\n        }\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\n    }\n}\n//# sourceMappingURL=index-manager.js.map\n;// ./node_modules/langium/lib/workspace/workspace-manager.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nclass DefaultWorkspaceManager {\n    constructor(services) {\n        this.initialBuildOptions = {};\n        this._ready = new promise_utils_Deferred();\n        this.serviceRegistry = services.ServiceRegistry;\n        this.langiumDocuments = services.workspace.LangiumDocuments;\n        this.documentBuilder = services.workspace.DocumentBuilder;\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\n        this.mutex = services.workspace.WorkspaceLock;\n    }\n    get ready() {\n        return this._ready.promise;\n    }\n    initialize(params) {\n        var _a;\n        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;\n    }\n    initialized(_params) {\n        // Initialize the workspace even if there are no workspace folders\n        // We still want to load additional documents (language library or similar) during initialization\n        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });\n    }\n    async initializeWorkspace(folders, cancelToken = cancellation/* CancellationToken */.XO.None) {\n        const documents = await this.performStartup(folders);\n        // Only after creating all documents do we check whether we need to cancel the initialization\n        // The document builder will later pick up on all unprocessed documents\n        await interruptAndCheck(cancelToken);\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\n    }\n    /**\n     * Performs the uninterruptable startup sequence of the workspace manager.\n     * This methods loads all documents in the workspace and other documents and returns them.\n     */\n    async performStartup(folders) {\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\n        const documents = [];\n        const collector = (document) => {\n            documents.push(document);\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\n                this.langiumDocuments.addDocument(document);\n            }\n        };\n        // Even though we don\'t await the initialization of the workspace manager,\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\n        await this.loadAdditionalDocuments(folders, collector);\n        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])\n            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));\n        this._ready.resolve();\n        return documents;\n    }\n    /**\n     * Load all additional documents that shall be visible in the context of the given workspace\n     * folders and add them to the collector. This can be used to include built-in libraries of\n     * your language, which can be either loaded from provided files or constructed in memory.\n     */\n    loadAdditionalDocuments(_folders, _collector) {\n        return Promise.resolve();\n    }\n    /**\n     * Determine the root folder of the source documents in the given workspace folder.\n     * The default implementation returns the URI of the workspace folder, but you can override\n     * this to return a subfolder like `src` instead.\n     */\n    getRootFolder(workspaceFolder) {\n        return esm_URI.parse(workspaceFolder.uri);\n    }\n    /**\n     * Traverse the file system folder identified by the given URI and its subfolders. All\n     * contained files that match the file extensions are added to the collector.\n     */\n    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\n        await Promise.all(content.map(async (entry) => {\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\n                if (entry.isDirectory) {\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\n                }\n                else if (entry.isFile) {\n                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);\n                    collector(document);\n                }\n            }\n        }));\n    }\n    /**\n     * Determine whether the given folder entry shall be included while indexing the workspace.\n     */\n    includeEntry(_workspaceFolder, entry, fileExtensions) {\n        const name = UriUtils.basename(entry.uri);\n        if (name.startsWith(\'.\')) {\n            return false;\n        }\n        if (entry.isDirectory) {\n            return name !== \'node_modules\' && name !== \'out\';\n        }\n        else if (entry.isFile) {\n            const extname = UriUtils.extname(entry.uri);\n            return fileExtensions.includes(extname);\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=workspace-manager.js.map\n;// ./node_modules/langium/lib/parser/lexer.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\nclass DefaultLexer {\n    constructor(services) {\n        const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\n        });\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\n        this.chevrotainLexer = new Lexer(lexerTokens, {\n            positionTracking: \'full\'\n        });\n    }\n    get definition() {\n        return this.tokenTypes;\n    }\n    tokenize(text) {\n        var _a;\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\n        return {\n            tokens: chevrotainResult.tokens,\n            errors: chevrotainResult.errors,\n            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : []\n        };\n    }\n    toTokenTypeDictionary(buildTokens) {\n        if (isTokenTypeDictionary(buildTokens))\n            return buildTokens;\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\n        const res = {};\n        tokens.forEach(token => res[token.name] = token);\n        return res;\n    }\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenType array\n */\nfunction isTokenTypeArray(tokenVocabulary) {\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || \'name\' in tokenVocabulary[0]);\n}\n/**\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\n */\nfunction isIMultiModeLexerDefinition(tokenVocabulary) {\n    return tokenVocabulary && \'modes\' in tokenVocabulary && \'defaultMode\' in tokenVocabulary;\n}\n/**\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\n */\nfunction isTokenTypeDictionary(tokenVocabulary) {\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\n}\n//# sourceMappingURL=lexer.js.map\n;// ./node_modules/langium/lib/documentation/jsdoc.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\nfunction parseJSDoc(node, start, options) {\n    let opts;\n    let position;\n    if (typeof node === \'string\') {\n        position = start;\n        opts = options;\n    }\n    else {\n        position = node.range.start;\n        opts = start;\n    }\n    if (!position) {\n        position = Position.create(0, 0);\n    }\n    const lines = getLines(node);\n    const normalizedOptions = normalizeOptions(opts);\n    const tokens = tokenize({\n        lines,\n        position,\n        options: normalizedOptions\n    });\n    return parseJSDocComment({\n        index: 0,\n        tokens,\n        position\n    });\n}\nfunction isJSDoc(node, options) {\n    const normalizedOptions = normalizeOptions(options);\n    const lines = getLines(node);\n    if (lines.length === 0) {\n        return false;\n    }\n    const first = lines[0];\n    const last = lines[lines.length - 1];\n    const firstRegex = normalizedOptions.start;\n    const lastRegex = normalizedOptions.end;\n    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));\n}\nfunction getLines(node) {\n    let content = \'\';\n    if (typeof node === \'string\') {\n        content = node;\n    }\n    else {\n        content = node.text;\n    }\n    const lines = content.split(NEWLINE_REGEXP);\n    return lines;\n}\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\nfunction tokenize(context) {\n    var _a, _b, _c;\n    const tokens = [];\n    let currentLine = context.position.line;\n    let currentCharacter = context.position.character;\n    for (let i = 0; i < context.lines.length; i++) {\n        const first = i === 0;\n        const last = i === context.lines.length - 1;\n        let line = context.lines[i];\n        let index = 0;\n        if (first && context.options.start) {\n            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        else {\n            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);\n            if (match) {\n                index = match.index + match[0].length;\n            }\n        }\n        if (last) {\n            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);\n            if (match) {\n                line = line.substring(0, match.index);\n            }\n        }\n        line = line.substring(0, lastCharacter(line));\n        const whitespaceEnd = skipWhitespace(line, index);\n        if (whitespaceEnd >= line.length) {\n            // Only create a break token when we already have previous tokens\n            if (tokens.length > 0) {\n                const position = Position.create(currentLine, currentCharacter);\n                tokens.push({\n                    type: \'break\',\n                    content: \'\',\n                    range: Range.create(position, position)\n                });\n            }\n        }\n        else {\n            tagRegex.lastIndex = index;\n            const tagMatch = tagRegex.exec(line);\n            if (tagMatch) {\n                const fullMatch = tagMatch[0];\n                const value = tagMatch[1];\n                const start = Position.create(currentLine, currentCharacter + index);\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\n                tokens.push({\n                    type: \'tag\',\n                    content: value,\n                    range: Range.create(start, end)\n                });\n                index += fullMatch.length;\n                index = skipWhitespace(line, index);\n            }\n            if (index < line.length) {\n                const rest = line.substring(index);\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\n            }\n        }\n        currentLine++;\n        currentCharacter = 0;\n    }\n    // Remove last break token if there is one\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === \'break\') {\n        return tokens.slice(0, -1);\n    }\n    return tokens;\n}\nfunction buildInlineTokens(tags, line, lineIndex, characterIndex) {\n    const tokens = [];\n    if (tags.length === 0) {\n        const start = Position.create(lineIndex, characterIndex);\n        const end = Position.create(lineIndex, characterIndex + line.length);\n        tokens.push({\n            type: \'text\',\n            content: line,\n            range: Range.create(start, end)\n        });\n    }\n    else {\n        let lastIndex = 0;\n        for (const match of tags) {\n            const matchIndex = match.index;\n            const startContent = line.substring(lastIndex, matchIndex);\n            if (startContent.length > 0) {\n                tokens.push({\n                    type: \'text\',\n                    content: line.substring(lastIndex, matchIndex),\n                    range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))\n                });\n            }\n            let offset = startContent.length + 1;\n            const tagName = match[1];\n            tokens.push({\n                type: \'inline-tag\',\n                content: tagName,\n                range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))\n            });\n            offset += tagName.length;\n            if (match.length === 4) {\n                offset += match[2].length;\n                const value = match[3];\n                tokens.push({\n                    type: \'text\',\n                    content: value,\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))\n                });\n            }\n            else {\n                tokens.push({\n                    type: \'text\',\n                    content: \'\',\n                    range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))\n                });\n            }\n            lastIndex = matchIndex + match[0].length;\n        }\n        const endContent = line.substring(lastIndex);\n        if (endContent.length > 0) {\n            tokens.push({\n                type: \'text\',\n                content: endContent,\n                range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))\n            });\n        }\n    }\n    return tokens;\n}\nconst nonWhitespaceRegex = /\\S/;\nconst whitespaceEndRegex = /\\s*$/;\nfunction skipWhitespace(line, index) {\n    const match = line.substring(index).match(nonWhitespaceRegex);\n    if (match) {\n        return index + match.index;\n    }\n    else {\n        return line.length;\n    }\n}\nfunction lastCharacter(line) {\n    const match = line.match(whitespaceEndRegex);\n    if (match && typeof match.index === \'number\') {\n        return match.index;\n    }\n    return undefined;\n}\n// Parsing\nfunction parseJSDocComment(context) {\n    var _a, _b, _c, _d;\n    const startPosition = Position.create(context.position.line, context.position.character);\n    if (context.tokens.length === 0) {\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\n    }\n    const elements = [];\n    while (context.index < context.tokens.length) {\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\n        if (element) {\n            elements.push(element);\n        }\n    }\n    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;\n    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;\n    return new JSDocCommentImpl(elements, Range.create(start, end));\n}\nfunction parseJSDocElement(context, last) {\n    const next = context.tokens[context.index];\n    if (next.type === \'tag\') {\n        return parseJSDocTag(context, false);\n    }\n    else if (next.type === \'text\' || next.type === \'inline-tag\') {\n        return parseJSDocText(context);\n    }\n    else {\n        appendEmptyLine(next, last);\n        context.index++;\n        return undefined;\n    }\n}\nfunction appendEmptyLine(token, element) {\n    if (element) {\n        const line = new JSDocLineImpl(\'\', token.range);\n        if (\'inlines\' in element) {\n            element.inlines.push(line);\n        }\n        else {\n            element.content.inlines.push(line);\n        }\n    }\n}\nfunction parseJSDocText(context) {\n    let token = context.tokens[context.index];\n    const firstToken = token;\n    let lastToken = token;\n    const lines = [];\n    while (token && token.type !== \'break\' && token.type !== \'tag\') {\n        lines.push(parseJSDocInline(context));\n        lastToken = token;\n        token = context.tokens[context.index];\n    }\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\n}\nfunction parseJSDocInline(context) {\n    const token = context.tokens[context.index];\n    if (token.type === \'inline-tag\') {\n        return parseJSDocTag(context, true);\n    }\n    else {\n        return parseJSDocLine(context);\n    }\n}\nfunction parseJSDocTag(context, inline) {\n    const tagToken = context.tokens[context.index++];\n    const name = tagToken.content.substring(1);\n    const nextToken = context.tokens[context.index];\n    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === \'text\') {\n        if (inline) {\n            const docLine = parseJSDocLine(context);\n            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));\n        }\n        else {\n            const textDoc = parseJSDocText(context);\n            return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));\n        }\n    }\n    else {\n        const range = tagToken.range;\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\n    }\n}\nfunction parseJSDocLine(context) {\n    const token = context.tokens[context.index++];\n    return new JSDocLineImpl(token.content, token.range);\n}\nfunction normalizeOptions(options) {\n    if (!options) {\n        return normalizeOptions({\n            start: \'/**\',\n            end: \'*/\',\n            line: \'*\'\n        });\n    }\n    const { start, end, line } = options;\n    return {\n        start: normalizeOption(start, true),\n        end: normalizeOption(end, false),\n        line: normalizeOption(line, true)\n    };\n}\nfunction normalizeOption(option, start) {\n    if (typeof option === \'string\' || typeof option === \'object\') {\n        const escaped = typeof option === \'string\' ? escapeRegExp(option) : option.source;\n        if (start) {\n            return new RegExp(`^\\\\s*${escaped}`);\n        }\n        else {\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\n        }\n    }\n    else {\n        return option;\n    }\n}\nclass JSDocCommentImpl {\n    constructor(elements, range) {\n        this.elements = elements;\n        this.range = range;\n    }\n    getTag(name) {\n        return this.getAllTags().find(e => e.name === name);\n    }\n    getTags(name) {\n        return this.getAllTags().filter(e => e.name === name);\n    }\n    getAllTags() {\n        return this.elements.filter((e) => \'name\' in e);\n    }\n    toString() {\n        let value = \'\';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toString();\n            }\n            else {\n                const text = element.toString();\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n    toMarkdown(options) {\n        let value = \'\';\n        for (const element of this.elements) {\n            if (value.length === 0) {\n                value = element.toMarkdown(options);\n            }\n            else {\n                const text = element.toMarkdown(options);\n                value += fillNewlines(value) + text;\n            }\n        }\n        return value.trim();\n    }\n}\nclass JSDocTagImpl {\n    constructor(name, content, inline, range) {\n        this.name = name;\n        this.content = content;\n        this.inline = inline;\n        this.range = range;\n    }\n    toString() {\n        let text = `@${this.name}`;\n        const content = this.content.toString();\n        if (this.content.inlines.length === 1) {\n            text = `${text} ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n    toMarkdown(options) {\n        var _a, _b;\n        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);\n    }\n    toMarkdownDefault(options) {\n        const content = this.content.toMarkdown(options);\n        if (this.inline) {\n            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});\n            if (typeof rendered === \'string\') {\n                return rendered;\n            }\n        }\n        let marker = \'\';\n        if ((options === null || options === void 0 ? void 0 : options.tag) === \'italic\' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {\n            marker = \'*\';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === \'bold\') {\n            marker = \'**\';\n        }\n        else if ((options === null || options === void 0 ? void 0 : options.tag) === \'bold-italic\') {\n            marker = \'***\';\n        }\n        let text = `${marker}@${this.name}${marker}`;\n        if (this.content.inlines.length === 1) {\n            text = `${text} \u2014 ${content}`;\n        }\n        else if (this.content.inlines.length > 1) {\n            text = `${text}\\n${content}`;\n        }\n        if (this.inline) {\n            // Inline tags are surrounded by curly braces\n            return `{${text}}`;\n        }\n        else {\n            return text;\n        }\n    }\n}\nfunction renderInlineTag(tag, content, options) {\n    var _a, _b;\n    if (tag === \'linkplain\' || tag === \'linkcode\' || tag === \'link\') {\n        const index = content.indexOf(\' \');\n        let display = content;\n        if (index > 0) {\n            const displayStart = skipWhitespace(content, index);\n            display = content.substring(displayStart);\n            content = content.substring(0, index);\n        }\n        if (tag === \'linkcode\' || (tag === \'link\' && options.link === \'code\')) {\n            // Surround the display value in a markdown inline code block\n            display = `\\`${display}\\``;\n        }\n        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);\n        return renderedLink;\n    }\n    return undefined;\n}\nfunction renderLinkDefault(content, display) {\n    try {\n        esm_URI.parse(content, true);\n        return `[${display}](${content})`;\n    }\n    catch (_a) {\n        return content;\n    }\n}\nclass JSDocTextImpl {\n    constructor(lines, range) {\n        this.inlines = lines;\n        this.range = range;\n    }\n    toString() {\n        let text = \'\';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toString();\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += \'\\n\';\n            }\n        }\n        return text;\n    }\n    toMarkdown(options) {\n        let text = \'\';\n        for (let i = 0; i < this.inlines.length; i++) {\n            const inline = this.inlines[i];\n            const next = this.inlines[i + 1];\n            text += inline.toMarkdown(options);\n            if (next && next.range.start.line > inline.range.start.line) {\n                text += \'\\n\';\n            }\n        }\n        return text;\n    }\n}\nclass JSDocLineImpl {\n    constructor(text, range) {\n        this.text = text;\n        this.range = range;\n    }\n    toString() {\n        return this.text;\n    }\n    toMarkdown() {\n        return this.text;\n    }\n}\nfunction fillNewlines(text) {\n    if (text.endsWith(\'\\n\')) {\n        return \'\\n\';\n    }\n    else {\n        return \'\\n\\n\';\n    }\n}\n//# sourceMappingURL=jsdoc.js.map\n;// ./node_modules/langium/lib/documentation/documentation-provider.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass JSDocDocumentationProvider {\n    constructor(services) {\n        this.indexManager = services.shared.workspace.IndexManager;\n        this.commentProvider = services.documentation.CommentProvider;\n    }\n    getDocumentation(node) {\n        const comment = this.commentProvider.getComment(node);\n        if (comment && isJSDoc(comment)) {\n            const parsedJSDoc = parseJSDoc(comment);\n            return parsedJSDoc.toMarkdown({\n                renderLink: (link, display) => {\n                    return this.documentationLinkRenderer(node, link, display);\n                },\n                renderTag: (tag) => {\n                    return this.documentationTagRenderer(node, tag);\n                }\n            });\n        }\n        return undefined;\n    }\n    documentationLinkRenderer(node, name, display) {\n        var _a;\n        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);\n        if (description && description.nameSegment) {\n            const line = description.nameSegment.range.start.line + 1;\n            const character = description.nameSegment.range.start.character + 1;\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\n            return `[${display}](${uri.toString()})`;\n        }\n        else {\n            return undefined;\n        }\n    }\n    documentationTagRenderer(_node, _tag) {\n        // Fall back to the default tag rendering\n        return undefined;\n    }\n    findNameInPrecomputedScopes(node, name) {\n        const document = getDocument(node);\n        const precomputed = document.precomputedScopes;\n        if (!precomputed) {\n            return undefined;\n        }\n        let currentNode = node;\n        do {\n            const allDescriptions = precomputed.get(currentNode);\n            const description = allDescriptions.find(e => e.name === name);\n            if (description) {\n                return description;\n            }\n            currentNode = currentNode.$container;\n        } while (currentNode);\n        return undefined;\n    }\n    findNameInGlobalScope(node, name) {\n        const description = this.indexManager.allElements().find(e => e.name === name);\n        return description;\n    }\n}\n//# sourceMappingURL=documentation-provider.js.map\n;// ./node_modules/langium/lib/documentation/comment-provider.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultCommentProvider {\n    constructor(services) {\n        this.grammarConfig = () => services.parser.GrammarConfig;\n    }\n    getComment(node) {\n        var _a;\n        if (isAstNodeWithComment(node)) {\n            return node.$comment;\n        }\n        return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;\n    }\n}\n//# sourceMappingURL=comment-provider.js.map\n// EXTERNAL MODULE: ./node_modules/vscode-jsonrpc/lib/common/events.js\nvar events = __webpack_require__(62676);\n;// ./node_modules/langium/lib/utils/event.js\n/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n// eslint-disable-next-line no-restricted-imports\n\n//# sourceMappingURL=event.js.map\n;// ./node_modules/langium/lib/parser/async-parser.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n/**\n * Default implementation of the async parser. This implementation only wraps the sync parser in a promise.\n *\n * A real implementation would create worker threads or web workers to offload the parsing work.\n */\nclass DefaultAsyncParser {\n    constructor(services) {\n        this.syncParser = services.parser.LangiumParser;\n    }\n    parse(text) {\n        return Promise.resolve(this.syncParser.parse(text));\n    }\n}\nclass AbstractThreadedAsyncParser {\n    constructor(services) {\n        /**\n         * The thread count determines how many threads are used to parse files in parallel.\n         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.\n         */\n        this.threadCount = 8;\n        /**\n         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.\n         * The default value is 200(ms).\n         */\n        this.terminationDelay = 200;\n        this.workerPool = [];\n        this.queue = [];\n        this.hydrator = services.serializer.Hydrator;\n    }\n    initializeWorkers() {\n        while (this.workerPool.length < this.threadCount) {\n            const worker = this.createWorker();\n            worker.onReady(() => {\n                if (this.queue.length > 0) {\n                    const deferred = this.queue.shift();\n                    if (deferred) {\n                        worker.lock();\n                        deferred.resolve(worker);\n                    }\n                }\n            });\n            this.workerPool.push(worker);\n        }\n    }\n    async parse(text, cancelToken) {\n        const worker = await this.acquireParserWorker(cancelToken);\n        const deferred = new Deferred();\n        let timeout;\n        // If the cancellation token is requested, we wait for a certain time before terminating the worker.\n        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.\n        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.\n        const cancellation = cancelToken.onCancellationRequested(() => {\n            timeout = setTimeout(() => {\n                this.terminateWorker(worker);\n            }, this.terminationDelay);\n        });\n        worker.parse(text).then(result => {\n            const hydrated = this.hydrator.hydrate(result);\n            deferred.resolve(hydrated);\n        }).catch(err => {\n            deferred.reject(err);\n        }).finally(() => {\n            cancellation.dispose();\n            clearTimeout(timeout);\n        });\n        return deferred.promise;\n    }\n    terminateWorker(worker) {\n        worker.terminate();\n        const index = this.workerPool.indexOf(worker);\n        if (index >= 0) {\n            this.workerPool.splice(index, 1);\n        }\n    }\n    async acquireParserWorker(cancelToken) {\n        this.initializeWorkers();\n        for (const worker of this.workerPool) {\n            if (worker.ready) {\n                worker.lock();\n                return worker;\n            }\n        }\n        const deferred = new Deferred();\n        cancelToken.onCancellationRequested(() => {\n            const index = this.queue.indexOf(deferred);\n            if (index >= 0) {\n                this.queue.splice(index, 1);\n            }\n            deferred.reject(OperationCancelled);\n        });\n        this.queue.push(deferred);\n        return deferred.promise;\n    }\n}\nclass ParserWorker {\n    get ready() {\n        return this._ready;\n    }\n    get onReady() {\n        return this.onReadyEmitter.event;\n    }\n    constructor(sendMessage, onMessage, onError, terminate) {\n        this.onReadyEmitter = new Emitter();\n        this.deferred = new Deferred();\n        this._ready = true;\n        this._parsing = false;\n        this.sendMessage = sendMessage;\n        this._terminate = terminate;\n        onMessage(result => {\n            const parseResult = result;\n            this.deferred.resolve(parseResult);\n            this.unlock();\n        });\n        onError(error => {\n            this.deferred.reject(error);\n            this.unlock();\n        });\n    }\n    terminate() {\n        this.deferred.reject(OperationCancelled);\n        this._terminate();\n    }\n    lock() {\n        this._ready = false;\n    }\n    unlock() {\n        this._parsing = false;\n        this._ready = true;\n        this.onReadyEmitter.fire();\n    }\n    parse(text) {\n        if (this._parsing) {\n            throw new Error(\'Parser worker is busy\');\n        }\n        this._parsing = true;\n        this.deferred = new Deferred();\n        this.sendMessage(text);\n        return this.deferred.promise;\n    }\n}\n//# sourceMappingURL=async-parser.js.map\n;// ./node_modules/langium/lib/workspace/workspace-lock.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\nclass DefaultWorkspaceLock {\n    constructor() {\n        this.previousTokenSource = new cancellation/* CancellationTokenSource */.Qi();\n        this.writeQueue = [];\n        this.readQueue = [];\n        this.done = true;\n    }\n    write(action) {\n        this.cancelWrite();\n        const tokenSource = new cancellation/* CancellationTokenSource */.Qi();\n        this.previousTokenSource = tokenSource;\n        return this.enqueue(this.writeQueue, action, tokenSource.token);\n    }\n    read(action) {\n        return this.enqueue(this.readQueue, action);\n    }\n    enqueue(queue, action, cancellationToken) {\n        const deferred = new promise_utils_Deferred();\n        const entry = {\n            action,\n            deferred,\n            cancellationToken: cancellationToken !== null && cancellationToken !== void 0 ? cancellationToken : cancellation/* CancellationToken */.XO.None\n        };\n        queue.push(entry);\n        this.performNextOperation();\n        return deferred.promise;\n    }\n    async performNextOperation() {\n        if (!this.done) {\n            return;\n        }\n        const entries = [];\n        if (this.writeQueue.length > 0) {\n            // Just perform the next write action\n            entries.push(this.writeQueue.shift());\n        }\n        else if (this.readQueue.length > 0) {\n            // Empty the read queue and perform all actions in parallel\n            entries.push(...this.readQueue.splice(0, this.readQueue.length));\n        }\n        else {\n            return;\n        }\n        this.done = false;\n        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {\n            try {\n                // Move the execution of the action to the next event loop tick via `Promise.resolve()`\n                const result = await Promise.resolve().then(() => action(cancellationToken));\n                deferred.resolve(result);\n            }\n            catch (err) {\n                if (isOperationCancelled(err)) {\n                    // If the operation was cancelled, we don\'t want to reject the promise\n                    deferred.resolve(undefined);\n                }\n                else {\n                    deferred.reject(err);\n                }\n            }\n        }));\n        this.done = true;\n        this.performNextOperation();\n    }\n    cancelWrite() {\n        this.previousTokenSource.cancel();\n    }\n}\n//# sourceMappingURL=workspace-lock.js.map\n;// ./node_modules/langium/lib/serializer/hydrator.js\n/******************************************************************************\n * Copyright 2024 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\nclass DefaultHydrator {\n    constructor(services) {\n        this.grammarElementIdMap = new BiMap();\n        this.tokenTypeIdMap = new BiMap();\n        this.grammar = services.Grammar;\n        this.lexer = services.parser.Lexer;\n        this.linker = services.references.Linker;\n    }\n    dehydrate(result) {\n        return {\n            // We need to create shallow copies of the errors\n            // The original errors inherit from the `Error` class, which is not transferable across worker threads\n            lexerErrors: result.lexerErrors.map(e => (Object.assign({}, e))),\n            parserErrors: result.parserErrors.map(e => (Object.assign({}, e))),\n            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))\n        };\n    }\n    createDehyrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                cstNodes.set(cstNode, {});\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    dehydrateAstNode(node, context) {\n        const obj = context.astNodes.get(node);\n        obj.$type = node.$type;\n        obj.$containerIndex = node.$containerIndex;\n        obj.$containerProperty = node.$containerProperty;\n        if (node.$cstNode !== undefined) {\n            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith(\'$\')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                obj[name] = arr;\n                for (const item of value) {\n                    if (syntax_tree_isAstNode(item)) {\n                        arr.push(this.dehydrateAstNode(item, context));\n                    }\n                    else if (syntax_tree_isReference(item)) {\n                        arr.push(this.dehydrateReference(item, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (syntax_tree_isAstNode(value)) {\n                obj[name] = this.dehydrateAstNode(value, context);\n            }\n            else if (syntax_tree_isReference(value)) {\n                obj[name] = this.dehydrateReference(value, context);\n            }\n            else if (value !== undefined) {\n                obj[name] = value;\n            }\n        }\n        return obj;\n    }\n    dehydrateReference(reference, context) {\n        const obj = {};\n        obj.$refText = reference.$refText;\n        if (reference.$refNode) {\n            obj.$refNode = context.cstNodes.get(reference.$refNode);\n        }\n        return obj;\n    }\n    dehydrateCstNode(node, context) {\n        const cstNode = context.cstNodes.get(node);\n        if (isRootCstNode(node)) {\n            cstNode.fullText = node.fullText;\n        }\n        else {\n            // Note: This returns undefined for hidden nodes (i.e. comments)\n            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);\n        }\n        cstNode.hidden = node.hidden;\n        cstNode.astNode = context.astNodes.get(node.astNode);\n        if (syntax_tree_isCompositeCstNode(node)) {\n            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));\n        }\n        else if (syntax_tree_isLeafCstNode(node)) {\n            cstNode.tokenType = node.tokenType.name;\n            cstNode.offset = node.offset;\n            cstNode.length = node.length;\n            cstNode.startLine = node.range.start.line;\n            cstNode.startColumn = node.range.start.character;\n            cstNode.endLine = node.range.end.line;\n            cstNode.endColumn = node.range.end.character;\n        }\n        return cstNode;\n    }\n    hydrate(result) {\n        const node = result.value;\n        const context = this.createHydrationContext(node);\n        if (\'$cstNode\' in node) {\n            this.hydrateCstNode(node.$cstNode, context);\n        }\n        return {\n            lexerErrors: result.lexerErrors,\n            parserErrors: result.parserErrors,\n            value: this.hydrateAstNode(node, context)\n        };\n    }\n    createHydrationContext(node) {\n        const astNodes = new Map();\n        const cstNodes = new Map();\n        for (const astNode of streamAst(node)) {\n            astNodes.set(astNode, {});\n        }\n        let root;\n        if (node.$cstNode) {\n            for (const cstNode of streamCst(node.$cstNode)) {\n                let cst;\n                if (\'fullText\' in cstNode) {\n                    cst = new RootCstNodeImpl(cstNode.fullText);\n                    root = cst;\n                }\n                else if (\'content\' in cstNode) {\n                    cst = new CompositeCstNodeImpl();\n                }\n                else if (\'tokenType\' in cstNode) {\n                    cst = this.hydrateCstLeafNode(cstNode);\n                }\n                if (cst) {\n                    cstNodes.set(cstNode, cst);\n                    cst.root = root;\n                }\n            }\n        }\n        return {\n            astNodes,\n            cstNodes\n        };\n    }\n    hydrateAstNode(node, context) {\n        const astNode = context.astNodes.get(node);\n        astNode.$type = node.$type;\n        astNode.$containerIndex = node.$containerIndex;\n        astNode.$containerProperty = node.$containerProperty;\n        if (node.$cstNode) {\n            astNode.$cstNode = context.cstNodes.get(node.$cstNode);\n        }\n        for (const [name, value] of Object.entries(node)) {\n            if (name.startsWith(\'$\')) {\n                continue;\n            }\n            if (Array.isArray(value)) {\n                const arr = [];\n                astNode[name] = arr;\n                for (const item of value) {\n                    if (syntax_tree_isAstNode(item)) {\n                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));\n                    }\n                    else if (syntax_tree_isReference(item)) {\n                        arr.push(this.hydrateReference(item, astNode, name, context));\n                    }\n                    else {\n                        arr.push(item);\n                    }\n                }\n            }\n            else if (syntax_tree_isAstNode(value)) {\n                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);\n            }\n            else if (syntax_tree_isReference(value)) {\n                astNode[name] = this.hydrateReference(value, astNode, name, context);\n            }\n            else if (value !== undefined) {\n                astNode[name] = value;\n            }\n        }\n        return astNode;\n    }\n    setParent(node, parent) {\n        node.$container = parent;\n        return node;\n    }\n    hydrateReference(reference, node, name, context) {\n        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);\n    }\n    hydrateCstNode(cstNode, context, num = 0) {\n        const cstNodeObj = context.cstNodes.get(cstNode);\n        if (typeof cstNode.grammarSource === \'number\') {\n            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);\n        }\n        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);\n        if (syntax_tree_isCompositeCstNode(cstNodeObj)) {\n            for (const child of cstNode.content) {\n                const hydrated = this.hydrateCstNode(child, context, num++);\n                cstNodeObj.content.push(hydrated);\n            }\n        }\n        return cstNodeObj;\n    }\n    hydrateCstLeafNode(cstNode) {\n        const tokenType = this.getTokenType(cstNode.tokenType);\n        const offset = cstNode.offset;\n        const length = cstNode.length;\n        const startLine = cstNode.startLine;\n        const startColumn = cstNode.startColumn;\n        const endLine = cstNode.endLine;\n        const endColumn = cstNode.endColumn;\n        const hidden = cstNode.hidden;\n        const node = new LeafCstNodeImpl(offset, length, {\n            start: {\n                line: startLine,\n                character: startColumn\n            },\n            end: {\n                line: endLine,\n                character: endColumn\n            }\n        }, tokenType, hidden);\n        return node;\n    }\n    getTokenType(name) {\n        return this.lexer.definition[name];\n    }\n    getGrammarElementId(node) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        return this.grammarElementIdMap.get(node);\n    }\n    getGrammarElement(id) {\n        if (this.grammarElementIdMap.size === 0) {\n            this.createGrammarElementIdMap();\n        }\n        const element = this.grammarElementIdMap.getKey(id);\n        if (element) {\n            return element;\n        }\n        else {\n            throw new Error(\'Invalid grammar element id: \' + id);\n        }\n    }\n    createGrammarElementIdMap() {\n        let id = 0;\n        for (const element of streamAst(this.grammar)) {\n            if (isAbstractElement(element)) {\n                this.grammarElementIdMap.set(element, id++);\n            }\n        }\n    }\n}\n//# sourceMappingURL=hydrator.js.map\n;// ./node_modules/langium/lib/default-module.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Creates a dependency injection module configuring the default core services.\n * This is a set of services that are dedicated to a specific language.\n */\nfunction createDefaultCoreModule(context) {\n    return {\n        documentation: {\n            CommentProvider: (services) => new DefaultCommentProvider(services),\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\n        },\n        parser: {\n            AsyncParser: (services) => new DefaultAsyncParser(services),\n            GrammarConfig: (services) => createGrammarConfig(services),\n            LangiumParser: (services) => createLangiumParser(services),\n            CompletionParser: (services) => createCompletionParser(services),\n            ValueConverter: () => new DefaultValueConverter(),\n            TokenBuilder: () => new DefaultTokenBuilder(),\n            Lexer: (services) => new DefaultLexer(services),\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider()\n        },\n        workspace: {\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\n        },\n        references: {\n            Linker: (services) => new DefaultLinker(services),\n            NameProvider: () => new DefaultNameProvider(),\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\n            References: (services) => new DefaultReferences(services)\n        },\n        serializer: {\n            Hydrator: (services) => new DefaultHydrator(services),\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\n        },\n        validation: {\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\n            ValidationRegistry: (services) => new ValidationRegistry(services)\n        },\n        shared: () => context.shared\n    };\n}\n/**\n * Creates a dependency injection module configuring the default shared core services.\n * This is the set of services that are shared between multiple languages.\n */\nfunction createDefaultSharedCoreModule(context) {\n    return {\n        ServiceRegistry: () => new DefaultServiceRegistry(),\n        workspace: {\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\n            IndexManager: (services) => new DefaultIndexManager(services),\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\n            WorkspaceLock: () => new DefaultWorkspaceLock(),\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\n        }\n    };\n}\n//# sourceMappingURL=default-module.js.map\n;// ./node_modules/langium/lib/dependency-injection.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nvar Module;\n(function (Module) {\n    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);\n})(Module || (Module = {}));\n/**\n * Given a set of modules, the inject function returns a lazily evaluated injector\n * that injects dependencies into the requested service when it is requested the\n * first time. Subsequent requests will return the same service.\n *\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\n * by injecting a provider `() => T` instead of a `T`.\n *\n * Please note that the arguments may be objects or arrays. However, the result will\n * be an object. Using it with for..of will have no effect.\n *\n * @param module1 first Module\n * @param module2 (optional) second Module\n * @param module3 (optional) third Module\n * @param module4 (optional) fourth Module\n * @param module5 (optional) fifth Module\n * @param module6 (optional) sixth Module\n * @param module7 (optional) seventh Module\n * @param module8 (optional) eighth Module\n * @param module9 (optional) ninth Module\n * @returns a new object of type I\n */\nfunction inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {\n    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});\n    return _inject(module);\n}\nconst isProxy = Symbol(\'isProxy\');\n/**\n * Eagerly load all services in the given dependency injection container. This is sometimes\n * necessary because services can register event listeners in their constructors.\n */\nfunction eagerLoad(item) {\n    if (item && item[isProxy]) {\n        for (const value of Object.values(item)) {\n            eagerLoad(value);\n        }\n    }\n    return item;\n}\n/**\n * Helper function that returns an injector by creating a proxy.\n * Invariant: injector is of type I. If injector is undefined, then T = I.\n */\nfunction _inject(module, injector) {\n    const proxy = new Proxy({}, {\n        deleteProperty: () => false,\n        get: (obj, prop) => _resolve(obj, prop, module, injector || proxy),\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)),\n        has: (_, prop) => prop in module,\n        ownKeys: () => [...Reflect.ownKeys(module), isProxy] // used by for..in\n    });\n    proxy[isProxy] = true;\n    return proxy;\n}\n/**\n * Internally used to tag a requested dependency, directly before calling the factory.\n * This allows us to find cycles during instance creation.\n */\nconst __requested__ = Symbol();\n/**\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\n * the module description. The result of service factories is cached. Groups are\n * recursively proxied.\n *\n * @param obj an object holding all group proxies and services\n * @param prop the key of a value within obj\n * @param module an object containing groups and service factories\n * @param injector the first level proxy that provides access to all values\n * @returns the requested value `obj[prop]`\n * @throws Error if a dependency cycle is detected\n */\nfunction _resolve(obj, prop, module, injector) {\n    if (prop in obj) {\n        if (obj[prop] instanceof Error) {\n            throw new Error(\'Construction failure. Please make sure that your dependencies are constructable.\', { cause: obj[prop] });\n        }\n        if (obj[prop] === __requested__) {\n            throw new Error(\'Cycle detected. Please make "\' + String(prop) + \'" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies\');\n        }\n        return obj[prop];\n    }\n    else if (prop in module) {\n        const value = module[prop];\n        obj[prop] = __requested__;\n        try {\n            obj[prop] = (typeof value === \'function\') ? value(injector) : _inject(value, injector);\n        }\n        catch (error) {\n            obj[prop] = error instanceof Error ? error : undefined;\n            throw error;\n        }\n        return obj[prop];\n    }\n    else {\n        return undefined;\n    }\n}\n/**\n * Performs a deep-merge of two modules by writing source entries into the target module.\n *\n * @param target the module which is written\n * @param source the module which is read\n * @returns the target module\n */\nfunction _merge(target, source) {\n    if (source) {\n        for (const [key, value2] of Object.entries(source)) {\n            if (value2 !== undefined) {\n                const value1 = target[key];\n                if (value1 !== null && value2 !== null && typeof value1 === \'object\' && typeof value2 === \'object\') {\n                    target[key] = _merge(value1, value2);\n                }\n                else {\n                    target[key] = value2;\n                }\n            }\n        }\n    }\n    return target;\n}\n//# sourceMappingURL=dependency-injection.js.map\n;// ./node_modules/langium/lib/documentation/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/languages/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/parser/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/references/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/serializer/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/workspace/file-system-provider.js\n/******************************************************************************\n * Copyright 2022 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\nclass EmptyFileSystemProvider {\n    readFile() {\n        throw new Error(\'No file system is available.\');\n    }\n    async readDirectory() {\n        return [];\n    }\n}\nconst EmptyFileSystem = {\n    fileSystemProvider: () => new EmptyFileSystemProvider()\n};\n//# sourceMappingURL=file-system-provider.js.map\n;// ./node_modules/langium/lib/utils/grammar-loader.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\nconst minimalGrammarModule = {\n    Grammar: () => undefined,\n    LanguageMetaData: () => ({\n        caseInsensitive: false,\n        fileExtensions: [\'.langium\'],\n        languageId: \'langium\'\n    })\n};\nconst minimalSharedGrammarModule = {\n    AstReflection: () => new LangiumGrammarAstReflection()\n};\nfunction createMinimalGrammarServices() {\n    const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);\n    const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);\n    shared.ServiceRegistry.register(grammar);\n    return grammar;\n}\n/**\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\n * most notably the parser builder which interprets the grammar to create a parser.\n */\nfunction loadGrammarFromJson(json) {\n    var _a;\n    const services = createMinimalGrammarServices();\n    const astNode = services.serializer.JsonSerializer.deserialize(json);\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, esm_URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : \'grammar\'}.langium`));\n    return astNode;\n}\n//# sourceMappingURL=grammar-loader.js.map\n;// ./node_modules/langium/lib/utils/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/validation/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/workspace/index.js\n/******************************************************************************\n * Copyright 2023 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n;// ./node_modules/langium/lib/index.js\n/******************************************************************************\n * Copyright 2021 TypeFox GmbH\n * This program and the accompanying materials are made available under the\n * terms of the MIT License, which is available in the project root.\n ******************************************************************************/\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Export the Langium Grammar AST definitions in the `GrammarAST` namespace\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEIsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCOzs7QUM3cUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3VEO0FBQ0E7QUFDRjtBQUM5QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixZQUFZO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLFlBQVk7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBLG9CQUFvQixvQ0FBb0M7QUFDeEQsZ0JBQWdCLDhCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsd0JBQXdCLG1CQUFtQjtBQUMzQyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxRQUFRLG9CQUFvQixRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7QUMzT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNxRztBQUN4QztBQUM2QjtBQUNsQjtBQUNzQztBQUN2RDtBQUNoRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLG1DQUFtQyxrRUFBa0U7QUFDeEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGNBQWMsMEJBQTBCLFdBQVc7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtCQUFrQixVQUFVLFlBQVk7QUFDdkU7QUFDQTtBQUNBLHlDQUF5QyxnQkFBZ0I7QUFDekQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QztBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDTztBQUNQLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFEQUFxRDtBQUNuRixvQ0FBb0MsY0FBYztBQUNsRCw0QkFBNEIsYUFBYSxjQUFjLGFBQWE7QUFDcEU7QUFDQSxvQ0FBb0MsZ0JBQWdCO0FBQ3BELG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBLGtFQUFrRSxvQkFBb0I7QUFDdEYsc0JBQXNCLG9CQUFvQixHQUFHLG1DQUFtQztBQUNoRixzQkFBc0IsdUJBQXVCLElBQUk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDOztBQzVhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQzRPO0FBQzlNO0FBQzlCO0FBQ3NEO0FBQzNGO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUMsd0JBQXdCLGFBQU0sdUJBQXVCLFlBQVk7QUFDakU7QUFDQSxrREFBa0Qsb0JBQW9CLHFEQUFxRDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQSwrQ0FBK0MsR0FBRztBQUNsRDtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQiwrQ0FBK0MsY0FBYztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZO0FBQ3BCO0FBQ0Esc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUIsNENBQTRDLGVBQWU7QUFDOUY7QUFDQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsYUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlCQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVMsR0FBRyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQSwwRUFBMEUsV0FBVztBQUNyRjtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVUsY0FBYyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVSxjQUFjLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHlCQUF5QixTQUFTO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsZ0JBQWdCLE9BQU8sWUFBWSxjQUFjLFlBQVksZ0JBQWdCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQSwrQzs7QUMvV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RDtBQUNOO0FBQ2pEO0FBQ1A7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUMsSUFBSSxZQUFZO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHFEOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDSTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLFdBQVcsWUFBWTtBQUN2QjtBQUNBLGtEOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ21DO0FBQ3FEO0FBQzlCO0FBQ3NCO0FBQ21CO0FBQ3ZEO0FBQ3JDO0FBQ1A7QUFDQSwrQkFBK0IsYUFBTSxDQUFDLG9CQUFvQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWSxVQUFVLEtBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsNkJBQTZCLDJCQUFpQixjQUFjLFNBQVM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixjQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUM7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkU7QUFDTTtBQUM1RTtBQUNQO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QixzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekMsMkM7Ozs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzBEO0FBQzFELHdDOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLE1BQU0sZ0NBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxtQkFBbUIsZ0NBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0JBQWtCLHNDQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdDQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxNQUFNLHNCQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5Qzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLE1BQU0scUJBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csU0FBUztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxJQUFJLGlCQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLGlCQUFZLEtBQUssaUJBQVksS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOzs7QUN2UUEsUUFBUSxNQUFNLGFBQWEsT0FBTyxRQUFRLGNBQWMsZ0dBQWdHLGdCQUFnQixnQ0FBZ0MsWUFBWSxLQUFLLGdDQUFnQyxLQUFLLGdCQUFnQixLQUFLLFdBQVcsbUJBQW1CLHdCQUF3QixrR0FBa0cseUJBQXlCLG1CQUFtQix5RUFBeUUsVUFBVSxvQ0FBb0MsaUJBQWlCLFNBQVMsb0NBQW9DLCtEQUErRCxRQUFRLDZCQUE2QixTQUFTLE9BQU8sbUJBQW1CLHlDQUF5QyxVQUFVLEtBQUssTUFBTSw4R0FBOEcseURBQXlELHVCQUF1QiwrQkFBK0IsMkRBQTJELDRFQUE0RSx3QkFBd0IsNkNBQTZDLGlCQUFpQixrQ0FBa0MsY0FBYyxtQkFBbUIsS0FBSyxtQkFBbUIsMkNBQTJDLHFDQUFxQyx3QkFBd0IsNEJBQTRCLGdEQUFnRCxZQUFZLGlDQUFpQyxLQUFLLDZCQUE2QixpQ0FBaUMsS0FBSyx3Q0FBd0MsS0FBSyxLQUFLLFVBQVUsUUFBUSxnREFBZ0QsNkJBQTZCLG9EQUFvRCxNQUFNLHdCQUF3QiwrQkFBK0IsY0FBYyxTQUFTLFlBQVksS0FBSyxpRUFBaUUsNkVBQTZFLHVCQUF1QixTQUFTLHFCQUFxQiwrQkFBK0IsMERBQTBELEtBQUssaUNBQWlDLE9BQU8sSUFBSSxPQUFPLFVBQVUsa0RBQWtELHdCQUF3Qix5RkFBeUYsS0FBSyxvQkFBb0IsK0NBQStDLHVDQUF1QyxzQkFBc0IsaUJBQWlCLEtBQUssS0FBSyxzQkFBc0IsV0FBVyxPQUFPLE1BQU0sT0FBTywrRUFBK0UsbURBQW1ELGlCQUFpQixLQUFLLDZCQUE2QixPQUFPLE1BQU0sT0FBTyx5QkFBeUIsNkJBQTZCLHFCQUFxQixLQUFLLDRDQUE0QyxLQUFLLEtBQUssc0JBQXNCLDZFQUE2RSxZQUFZLE1BQU0sT0FBTyxxRUFBcUUsb0JBQW9CLGlJQUFpSSxxQkFBcUIsdURBQXVELGtDQUFrQyxNQUFNLG1CQUFtQixLQUFLLE9BQU8sdUNBQXVDLHlCQUF5QixpQ0FBaUMsdUJBQXVCLDRDQUE0QyxLQUFLLG1HQUFtRyxZQUFZLE1BQU0sTUFBTSw0UUFBNFEsOENBQThDLHVCQUF1QixNQUFNLGNBQWMsV0FBVywrQkFBK0IsWUFBWSxZQUFZLHFDQUFxQyxZQUFZLCtEQUErRCx1QkFBdUIsRUFBRSw4REFBOEQsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsR0FBRyxTQUFTLE1BQU0sTUFBTSxpQkFBaUIsc0JBQXNCLHdEQUF3RCxvQ0FBb0MsMEJBQTBCLDBCQUEwQiwyQ0FBMkMsZ0JBQWdCLGlFQUFpRSwwQkFBMEIsWUFBWSxZQUFZLE9BQU8sYUFBYSxRQUFRLGdCQUFnQixXQUFXLEVBQUUsR0FBRyxrR0FBa0csMEJBQTBCLCtLQUErSyxvS0FBb0ssa0ZBQWtGLFFBQVEsZ0JBQWdCLHlQQUF5UCxPQUFPLFVBQVUsS0FBSyxNQUFNLFNBQVMsNEJBQTRCLDRLQUE0SyxxQkFBcUIsa0RBQWtELFVBQVUsMERBQTBELFNBQVMsaUVBQWlFLGFBQWEsa0JBQWtCLFFBQVEsa0JBQWtCLElBQUksK0NBQStDLEdBQUcsa1VBQWtVLHFCQUFxQixrQkFBa0IsdUZBQXVGLGVBQWUsUUFBUSxpREFBaUQsdUJBQXVCLHVFQUF1RSw2QkFBNkIsZUFBZSw4REFBOEQsaUJBQWlCLGVBQWUsaUJBQWlCLFNBQVMsWUFBWSxpQkFBaUIsTUFBTSw0QkFBNEIsaUJBQWlCLHFFQUFxRSxVQUFVLG1CQUFtQixrQkFBa0IsZ0JBQWdCLGFBQWEsYUFBYSw0REFBNEQsZUFBZSxvRkFBb0YsU0FBUyxTQUFTLFFBQVEsaVNBQWlTLFNBQVMsNEtBQTRLLGtCQUFrQixXQUFXLFlBQVksV0FBVyxLQUFLLHdCQUF3Qiw4TUFBOE0sS0FBSyw4QkFBOEIsYUFBYSx3RkFBd0YscUVBQXFFLGNBQWMsTUFBTSxZQUFZLFdBQVcsS0FBSyx3QkFBd0IsNkVBQTZFLHNCQUFzQixnQkFBZ0IsTUFBTSw4REFBOEQsWUFBWSxFQUFFLE9BQU8sb1FBQW9RLGdCQUFnQixjQUFjLFVBQVUsK0NBQStDLEdBQUcsb0RBQW9ELHFCQUFxQixXQUFXLHNCQUFzQiw4SEFBOEgsdUdBQXVHLE1BQU0sNERBQTRELHdCQUF3QixxQkFBcUIsMEJBQTBCLEdBQUcsWUFBWSxHQUFHLDJDQUEyQyx3QkFBd0Isb0JBQW9CLDBCQUEwQixHQUFHLFlBQVksR0FBRyxjQUFjLGlFQUFpRSxjQUFjLElBQUksNkJBQTZCLE1BQU0sa0RBQWtELHNDQUFzQyxjQUFjLDJDQUEyQyxhQUFhLHlCQUF5QixNQUFNLGFBQWEsNEJBQTRCLGVBQWUseUJBQXlCLEVBQUUsZ0NBQWdDLGtCQUFrQix1QkFBdUIsd0JBQXdCLDZEQUE2RCxPQUFPLEVBQUUsdUJBQXVCLDBDQUEwQyx3QkFBd0IsMERBQTBELE9BQU8sRUFBRSx3QkFBd0IsMEJBQTBCLHVCQUF1QiwwQkFBMEIsU0FBUyxHQUFHLFVBQVUsSUFBVyxNQUFNLEdBQUcsZ0JBQU87QUFDOThVLGtDOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0M7QUFDekI7QUFDUjtBQUNQO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0IsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLEtBQUs7QUFDNUIsd0JBQXdCLEtBQUs7QUFDN0IsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QixxQzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tFO0FBQ3BCO0FBQ2U7QUFDakI7QUFDQTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ2hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxzQ0FBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxjQUFjO0FBQy9DO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsaUJBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUM7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDdUI7QUFDSDtBQUNuQjtBQUNKO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFpQjtBQUN4RCwyQkFBMkIsU0FBUztBQUNwQyxrQkFBa0IsaUJBQWlCO0FBQ25DLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsY0FBYyw0REFBNEQsYUFBYSxLQUFLLElBQUksR0FBRztBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBLHdIQUF3SCxzQ0FBc0M7QUFDOUo7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHNDQUFzQztBQUNqRyx5Q0FBeUMsV0FBVyxlQUFlLGFBQWE7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFTO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWMsNERBQTRELDJCQUEyQixLQUFLLElBQUksR0FBRztBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixXQUFXO0FBQ3BDLDZCQUE2QixhQUFhO0FBQzFDLHlHQUF5RyxhQUFhO0FBQ3RIO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYywyQ0FBMkMsZUFBZSxTQUFTLDJCQUEyQix3QkFBd0I7QUFDakw7QUFDQTtBQUNBLGtDOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dFO0FBQ3pEO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0EseUM7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMkQ7QUFDWDtBQUNJO0FBQ21CO0FBQzNCO0FBQ0s7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxXQUFXO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxRQUFRO0FBQ3BFO0FBQ0E7QUFDQSxlQUFlLGFBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDOztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLEtBQUssYUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQU07QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qzs7QUMzTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUNhO0FBQ3ZCO0FBQ1c7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0NBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBOEMsZUFBZSwwQkFBMEI7QUFDdkcsc0ZBQXNGLGVBQWU7QUFDckcsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBLHFFQUFxRSwwQkFBMEI7QUFDL0Y7QUFDQSwrQ0FBK0Msa0JBQWtCLHFDQUFxQyxnQkFBZ0IsMkZBQTJGLGlCQUFpQjtBQUNsTztBQUNBO0FBQ0EsMkJBQTJCLDhDQUE4QztBQUN6RTtBQUNBLGlFQUFpRSxjQUFjLGdCQUFnQixzQ0FBaUI7QUFDaEg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNDQUFpQjtBQUN0RTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0EsMkJBQTJCLDJCQUFpQjtBQUM1QyxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLGlDOztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUM7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDbUQ7QUFDQztBQUNSO0FBQ1M7QUFDOUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGNBQWM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGFBQU07QUFDdEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXLENBQUMsYUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsUUFBUTtBQUMxRTtBQUNBO0FBQ0EsMEM7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDaUM7QUFDMEI7QUFDUDtBQUNhO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwREFBMEQ7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVLEdBQUcsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBUztBQUMxQjtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsT0FBRztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsT0FBRztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQzs7QUN2TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsS0FBSyx3REFBd0QscUNBQXFDO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsNEZBQTRGLElBQUk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Qzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtRDtBQUNjO0FBQ3JCO0FBQzVDO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixNQUFNO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQzs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM2RDtBQUN1QjtBQUNsQztBQUNHO0FBQytCO0FBQzFCO0FBQ25EO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCLHNDQUFpQjtBQUNsRjtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBLHlFQUF5RSxRQUFRLHdHQUF3RztBQUN6TDtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsUUFBUSx5R0FBeUc7QUFDM0w7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFFBQVEseUdBQXlHO0FBQzNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQ0FBaUI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQyxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DLDhDOztBQ3BNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1Y7QUFDOEI7QUFDdkI7QUFDSTtBQUNiO0FBQzFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsV0FBVztBQUN4RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0EsMENBQTBDLFFBQVEscUdBQXFHLGlCQUFpQjtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsc0NBQWlCO0FBQ3RFO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QyxrQkFBa0IsaUJBQWlCO0FBQ25DLFlBQVksZ0JBQWdCLDZCQUE2QixjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEMsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEM7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEM7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDBCQUEwQixzQkFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQSx5Qzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQyxzQzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZEO0FBQ1Q7QUFDRDtBQUMrQjtBQUN0QztBQUM4QjtBQUMzQjtBQUN4QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0Isc0NBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSEFBb0gsa0JBQWtCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUseUJBQXlCLFlBQVk7QUFDbkgsaUNBQWlDO0FBQ2pDO0FBQ0EsNkJBQTZCO0FBQzdCLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxzQ0FBaUI7QUFDbEUsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsa0JBQWtCO0FBQzlGLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNENBQTRDLGFBQWE7QUFDekQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysc0NBQWlCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdDQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFrQjtBQUN6QyxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRiwrSUFBK0ksa0JBQWtCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEM7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDRDtBQUNVO0FBQ2pCO0FBQ0s7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxlQUFlLGFBQU07QUFDckI7QUFDQTtBQUNBLDJCQUEyQixhQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0NBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxzQ0FBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUM7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDVztBQUNsQjtBQUMvQztBQUNQO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUSxrR0FBa0c7QUFDcko7QUFDQSxxREFBcUQsc0NBQWlCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkM7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDL0M7QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQyxLQUFlO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUM7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEQ7QUFDVTtBQUM1QjtBQUNyQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsNEJBQTRCLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRTtBQUMxQywwQkFBMEIsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLE1BQU07QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0Qyw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUIsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssUUFBUSxRQUFRLGdEQUFnRCxRQUFRO0FBQ3hHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsS0FBSyxRQUFRLFFBQVEseURBQXlELFFBQVE7QUFDN0csYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssUUFBUSxRQUFRLHlEQUF5RCxRQUFRO0FBQ2pILGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssUUFBUSxRQUFRLHlEQUF5RCxRQUFRO0FBQ2pILGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUssUUFBUSxRQUFRLGdEQUFnRCxRQUFRO0FBQ3BHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsS0FBSztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLEtBQUs7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsWUFBWTtBQUNqRTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLFFBQVE7QUFDdEM7QUFDQTtBQUNBLHNCQUFzQixLQUFLLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsRUFBRSxNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sR0FBRyxVQUFVLEVBQUUsT0FBTztBQUNuRDtBQUNBLHNCQUFzQixNQUFNLElBQUksUUFBUTtBQUN4QztBQUNBO0FBQ0Esc0JBQXNCLEtBQUssSUFBSSxRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixFQUFFLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBRztBQUNYLG1CQUFtQixRQUFRLElBQUksUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ0g7QUFDMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QixnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjLEtBQUssR0FBRyxVQUFVLEdBQUc7QUFDMUYsdUJBQXVCLFFBQVEsSUFBSSxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFdBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0Q7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDd0U7QUFDaEI7QUFDakQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQSw0Qzs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0Q7QUFDcEQsaUM7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN5RTtBQUM3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0M7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Y7QUFDWDtBQUNwRTtBQUNQO0FBQ0EsdUNBQXVDLDRDQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQXVCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdIQUFnSCxzQ0FBaUI7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQzs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RztBQUNyQztBQUMyQztBQUMzRDtBQUNGO0FBQ0U7QUFDM0M7QUFDUDtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0Msd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQVM7QUFDakM7QUFDQTtBQUNBLDZCQUE2Qix1QkFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBUztBQUM5QjtBQUNBO0FBQ0EscUJBQXFCLHVCQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBa0I7QUFDOUI7QUFDQTtBQUNBLGlCQUFpQix5QkFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0EsOEJBQThCLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9CQUFvQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBUztBQUNqQztBQUNBO0FBQ0EsNkJBQTZCLHVCQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFTO0FBQzlCO0FBQ0E7QUFDQSxxQkFBcUIsdUJBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4QkFBa0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQzs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNvRTtBQUNXO0FBQ047QUFDVDtBQUNJO0FBQ2I7QUFDYTtBQUNMO0FBQ2E7QUFDTjtBQUNFO0FBQ1Q7QUFDZTtBQUNMO0FBQ2dEO0FBQ2pEO0FBQ0k7QUFDSDtBQUN5QjtBQUMvQjtBQUNRO0FBQzFCO0FBQ3NDO0FBQ1Y7QUFDRTtBQUNqQjtBQUNPO0FBQ1Y7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFLHFEQUFxRCwwQkFBMEI7QUFDL0UsU0FBUztBQUNUO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RCx5Q0FBeUMsbUJBQW1CO0FBQzVELHlDQUF5QyxtQkFBbUI7QUFDNUQsNENBQTRDLHNCQUFzQjtBQUNsRSxzQ0FBc0MscUJBQXFCO0FBQzNELG9DQUFvQyxtQkFBbUI7QUFDdkQscUNBQXFDLFlBQVk7QUFDakQsa0RBQWtELGlDQUFpQztBQUNuRixTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNELDBEQUEwRCxpQ0FBaUM7QUFDM0YsNERBQTRELG1DQUFtQztBQUMvRixTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MsYUFBYTtBQUNuRCxvQ0FBb0MsbUJBQW1CO0FBQ3ZELDZDQUE2QyxvQkFBb0I7QUFDakUsZ0RBQWdELHVCQUF1QjtBQUN2RSwwQ0FBMEMsaUJBQWlCO0FBQzNELFNBQVM7QUFDVDtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELDhDQUE4QyxxQkFBcUI7QUFDbkUsU0FBUztBQUNUO0FBQ0EsaURBQWlELHdCQUF3QjtBQUN6RSxrREFBa0Qsa0JBQWtCO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0EsZ0RBQWdELHVCQUF1QjtBQUN2RSxzREFBc0QsNkJBQTZCO0FBQ25GLCtDQUErQyxzQkFBc0I7QUFDckUsNENBQTRDLG1CQUFtQjtBQUMvRCxnREFBZ0QsdUJBQXVCO0FBQ3ZFO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RCxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLDBDOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtDQUErQztBQUMvQyxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0hBQXNIO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRDs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUNNO0FBQ2pCO0FBQzNCLGlDOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDSTtBQUN4QyxpQzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2tDO0FBQ2E7QUFDVDtBQUNNO0FBQ1I7QUFDVDtBQUNRO0FBQ0E7QUFDRTtBQUNyQyxpQzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRCO0FBQ087QUFDSDtBQUNMO0FBQ1k7QUFDSDtBQUNwQyxpQzs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhCO0FBQ087QUFDckMsaUM7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnRDs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4RjtBQUMxQztBQUNDO0FBQ2tCO0FBQ2xDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkJBQTZCLDJCQUErQjtBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxlQUFlO0FBQ3ZFLG9CQUFvQixNQUFNLENBQUMsdUJBQXVCLEdBQUcsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQUcsbUJBQW1CLCtEQUErRDtBQUM3SjtBQUNBO0FBQ0EsMEM7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkI7QUFDRjtBQUNNO0FBQ0Q7QUFDSjtBQUNRO0FBQ0Q7QUFDUDtBQUNHO0FBQ1k7QUFDTztBQUNQO0FBQ1E7QUFDRjtBQUNzQjtBQUN2RSxpQzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3QztBQUNDO0FBQ3pDLGlDOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0M7QUFDQTtBQUNIO0FBQ0c7QUFDUDtBQUNXO0FBQ1A7QUFDQztBQUNHO0FBQ3ZDLGlDOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0M7QUFDTTtBQUNKO0FBQ1I7QUFDRztBQUNRO0FBQ0o7QUFDSDtBQUNJO0FBQ0E7QUFDTDtBQUNLO0FBQ0Q7QUFDckM7QUFDMkQ7QUFDckM7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3N5bnRheC10cmVlLmpzP2IwMjgiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9zdHJlYW0uanM/NTE4MyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2NzdC11dGlscy5qcz9lODk4Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZXJyb3JzLmpzPzJkNWEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcz9lNDdlIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvYXN0LXV0aWxzLmpzPzQ2ZGMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0L2xpYi9zcmMvdXRpbHMuanM/ZjUwMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL3JlZ2V4cC10by1hc3QvbGliL3NyYy9jaGFyYWN0ZXItY2xhc3Nlcy5qcz9jYzZmIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdC9saWIvc3JjL3JlZ2V4cC1wYXJzZXIuanM/NWRiNSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL3JlZ2V4cC10by1hc3QvbGliL3NyYy9iYXNlLXJlZ2V4cC12aXNpdG9yLmpzP2MwMjkiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0L2xpYi9zcmMvYXBpLmpzP2JkNzkiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9yZWdleHAtdXRpbHMuanM/ZDljOSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2dyYW1tYXItdXRpbHMuanM/YWJlOCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2xhbmd1YWdlcy9ncmFtbWFyLWNvbmZpZy5qcz82OWQxIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vdXRpbHMvbGliL3NyYy90by1mYXN0LXByb3BlcnRpZXMuanM/M2RjMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNsaWNlLmpzPzg3YjAiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZHJvcC5qcz8xYzU2Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbi5qcz8wNTkxIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3BpY2tCeS5qcz9mZmMxIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNSZWdFeHAuanM/YjYxNCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1JlZ0V4cC5qcz9kMjc5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vZ2FzdC9saWIvc3JjL21vZGVsLmpzP2Y1YzIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9nYXN0L2xpYi9zcmMvdmlzaXRvci5qcz82Nzg5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU29tZS5qcz9mZTdkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NvbWUuanM/YTM5NiIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pbmNsdWRlcy5qcz83YjJjIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUV2ZXJ5LmpzP2QxMTQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VFdmVyeS5qcz82M2Y4Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2V2ZXJ5LmpzPzNhMzQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9nYXN0L2xpYi9zcmMvaGVscGVycy5qcz9iZjdlIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vZ2FzdC9saWIvc3JjL2FwaS5qcz8zMWE3Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvcmVzdC5qcz9kYzVhIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3VuaXEuanM/MjM0NyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2ZpcnN0LmpzPzE1OTkiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvY29uc3RhbnRzLmpzP2RkOTYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9mb2xsb3cuanM/OTZlMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9uZWdhdGUuanM/NDgxMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9yZWplY3QuanM/YTlmNCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pbmRleE9mLmpzPzczYTIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VEaWZmZXJlbmNlLmpzP2Y4NzciLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGlmZmVyZW5jZS5qcz85MmE4Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2NvbXBhY3QuanM/ODY0NSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9oZWFkLmpzP2MyNWIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi91dGlscy9saWIvc3JjL3ByaW50LmpzP2ZkNDciLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9yZWdfZXhwX3BhcnNlci5qcz9jYjE0Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vcmVnX2V4cC5qcz8yNjAzIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXIuanM/MGYyNyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL3V0aWxzL2xpYi9zcmMvdGltZXIuanM/NjQ1MSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9zY2FuL3Rva2Vucy5qcz85MDkzIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qcz81YmM4Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfcHVibGljLmpzP2RkZDgiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi90b2tlbnNfcHVibGljLmpzPzE4YTEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZXJyb3JzX3B1YmxpYy5qcz9hMGU2Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvcmVzb2x2ZXIuanM/YTM1ZSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mbGF0TWFwLmpzP2IyNDYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5QWdncmVnYXRvci5qcz81YjZiIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQWdncmVnYXRvci5qcz9mODk1Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVBZ2dyZWdhdG9yLmpzPzgyMmEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ3JvdXBCeS5qcz9jNTJiIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Ryb3BSaWdodC5qcz81NzhjIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanM/MDM4NyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2xvb2thaGVhZC5qcz81NzFkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2dyYW1tYXIvY2hlY2tzLmpzPzQzY2IiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljLmpzPzY3NDYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZXhjZXB0aW9uc19wdWJsaWMuanM/MmM2ZCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY292ZXJhYmxlLmpzPzUzMjMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9rZXlzLmpzPzZkNzMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9sbGtfbG9va2FoZWFkLmpzPzMxNGQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9sb29rc2FoZWFkLmpzP2JiNDEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvY3N0L2NzdC5qcz80OWNkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL2xhbmcvbGFuZ19leHRlbnNpb25zLmpzPzUwNjgiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvY3N0L2NzdF92aXNpdG9yLmpzP2Q2N2YiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy90cmVlX2J1aWxkZXIuanM/NDVjNSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xleGVyX2FkYXB0ZXIuanM/NzlmNiIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY29nbml6ZXJfYXBpLmpzPzliMmIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvZ25pemVyX2VuZ2luZS5qcz9hNmZkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvZXJyb3JfaGFuZGxlci5qcz83MTljIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvY29udGV4dF9hc3Npc3QuanM/M2YwNSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2dhc3RfcmVjb3JkZXIuanM/NWVlNyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3BlcmZfdHJhY2VyLmpzP2UwYWIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3V0aWxzL2FwcGx5X21peGlucy5qcz80YjIwIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci9wYXJzZXIuanM/ZjczNCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2NzdC1kdHMtZ2VuL2xpYi9zcmMvbW9kZWwuanM/ZWIwYSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2NzdC1kdHMtZ2VuL2xpYi9zcmMvYXBpLmpzPzVkYmUiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvYXBpLmpzP2NmNGEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluLWFsbHN0YXIvbGliL2F0bi5qcz85ZmJkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9kZmEuanM/ZWNmNSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91bmlxQnkuanM/MWE3OCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvYWxsLXN0YXItbG9va2FoZWFkLmpzP2EwODciLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluLWFsbHN0YXIvbGliL2luZGV4LmpzPzQyYjIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbGliL2VzbS9tYWluLmpzPzkxNGMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvY3N0LW5vZGUtYnVpbGRlci5qcz82MDE5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2xhbmdpdW0tcGFyc2VyLmpzPzI3ZDYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvcGFyc2VyLWJ1aWxkZXItYmFzZS5qcz83OTJkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2NvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanM/ZGI4YyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3BhcnNlci9sYW5naXVtLXBhcnNlci1idWlsZGVyLmpzPzNhNDkiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvdG9rZW4tYnVpbGRlci5qcz8yN2MyIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL3ZhbHVlLWNvbnZlcnRlci5qcz9lOTc1Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY2FuY2VsbGF0aW9uLmpzP2YyMWEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9wcm9taXNlLXV0aWxzLmpzPzNhN2YiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50L2xpYi9lc20vbWFpbi5qcz8xZTVlIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvdnNjb2RlLXVyaS9saWIvZXNtL2luZGV4Lm1qcz9iNDI0Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvdXJpLXV0aWxzLmpzPzU5ZmUiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2UvZG9jdW1lbnRzLmpzP2RhZWEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL2xpbmtlci5qcz8zMjE1Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9uYW1lLXByb3ZpZGVyLmpzP2NmYWIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3JlZmVyZW5jZXMuanM/OWI3NSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2NvbGxlY3Rpb25zLmpzP2U5NDIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLWNvbXB1dGF0aW9uLmpzP2U5ZjQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLmpzPzFiZmMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9jYWNoaW5nLmpzP2U5ZGUiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLXByb3ZpZGVyLmpzP2ViMmIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9zZXJpYWxpemVyL2pzb24tc2VyaWFsaXplci5qcz9hODM4Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc2VydmljZS1yZWdpc3RyeS5qcz9mMGFjIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdmFsaWRhdGlvbi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzP2YwMGIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi92YWxpZGF0aW9uL2RvY3VtZW50LXZhbGlkYXRvci5qcz81ZjM5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2FzdC1kZXNjcmlwdGlvbnMuanM/OGM3YyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9hc3Qtbm9kZS1sb2NhdG9yLmpzPzBjZDgiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2UvY29uZmlndXJhdGlvbi5qcz8zYjhhIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZGlzcG9zYWJsZS5qcz81MjJiIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2RvY3VtZW50LWJ1aWxkZXIuanM/YzczMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9pbmRleC1tYW5hZ2VyLmpzPzNkZWQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2Uvd29ya3NwYWNlLW1hbmFnZXIuanM/NmE4MyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3BhcnNlci9sZXhlci5qcz84OTg3Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9qc2RvYy5qcz85ODlkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9kb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzP2FlOTkiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9kb2N1bWVudGF0aW9uL2NvbW1lbnQtcHJvdmlkZXIuanM/MmIzMCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2V2ZW50LmpzPzM2NDEiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvYXN5bmMtcGFyc2VyLmpzPzQ2YjYiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2Uvd29ya3NwYWNlLWxvY2suanM/YTg0NiIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3NlcmlhbGl6ZXIvaHlkcmF0b3IuanM/ZTg3NSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2RlZmF1bHQtbW9kdWxlLmpzPzczYzMiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9kZXBlbmRlbmN5LWluamVjdGlvbi5qcz82ODI5Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9pbmRleC5qcz8xNWNkIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvbGFuZ3VhZ2VzL2luZGV4LmpzPzYwYTIiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvaW5kZXguanM/MWM4YyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3JlZmVyZW5jZXMvaW5kZXguanM/OGM1ZCIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3NlcmlhbGl6ZXIvaW5kZXguanM/ZWJlOSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9maWxlLXN5c3RlbS1wcm92aWRlci5qcz82ZTlhIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZ3JhbW1hci1sb2FkZXIuanM/MGI1MiIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2luZGV4LmpzPzU5OGUiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi92YWxpZGF0aW9uL2luZGV4LmpzPzkwMWQiLCJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2UvaW5kZXguanM/NjRlNSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2luZGV4LmpzPzczNWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN0Tm9kZShvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmouJHR5cGUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iai4kcmVmVGV4dCA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc3ROb2RlRGVzY3JpcHRpb24ob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbFxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgdHlwZW9mIG9iai5wYXRoID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0xpbmtpbmdFcnJvcihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsXG4gICAgICAgICYmIGlzQXN0Tm9kZShvYmouY29udGFpbmVyKVxuICAgICAgICAmJiBpc1JlZmVyZW5jZShvYmoucmVmZXJlbmNlKVxuICAgICAgICAmJiB0eXBlb2Ygb2JqLm1lc3NhZ2UgPT09ICdzdHJpbmcnO1xufVxuLyoqXG4gKiBBbiBhYnN0cmFjdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIEFzdFJlZmxlY3Rpb259IGludGVyZmFjZS5cbiAqIFNlcnZlcyB0byBjYWNoZSBzdWJ0eXBlIGNvbXB1dGF0aW9uIHJlc3VsdHMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSB0aHJvdWdob3V0IGRpZmZlcmVudCBwYXJ0cyBvZiBMYW5naXVtLlxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJ0eXBlcyA9IHt9O1xuICAgICAgICB0aGlzLmFsbFN1YnR5cGVzID0ge307XG4gICAgfVxuICAgIGlzSW5zdGFuY2Uobm9kZSwgdHlwZSkge1xuICAgICAgICByZXR1cm4gaXNBc3ROb2RlKG5vZGUpICYmIHRoaXMuaXNTdWJ0eXBlKG5vZGUuJHR5cGUsIHR5cGUpO1xuICAgIH1cbiAgICBpc1N1YnR5cGUoc3VidHlwZSwgc3VwZXJ0eXBlKSB7XG4gICAgICAgIGlmIChzdWJ0eXBlID09PSBzdXBlcnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBuZXN0ZWQgPSB0aGlzLnN1YnR5cGVzW3N1YnR5cGVdO1xuICAgICAgICBpZiAoIW5lc3RlZCkge1xuICAgICAgICAgICAgbmVzdGVkID0gdGhpcy5zdWJ0eXBlc1tzdWJ0eXBlXSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gbmVzdGVkW3N1cGVydHlwZV07XG4gICAgICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNvbXB1dGVJc1N1YnR5cGUoc3VidHlwZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIG5lc3RlZFtzdXBlcnR5cGVdID0gcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBbGxTdWJUeXBlcyh0eXBlKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5hbGxTdWJ0eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBhbGxUeXBlcyA9IHRoaXMuZ2V0QWxsVHlwZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvc3NpYmxlU3ViVHlwZSBvZiBhbGxUeXBlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3VidHlwZShwb3NzaWJsZVN1YlR5cGUsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVzLnB1c2gocG9zc2libGVTdWJUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFsbFN1YnR5cGVzW3R5cGVdID0gdHlwZXM7XG4gICAgICAgICAgICByZXR1cm4gdHlwZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGUgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShub2RlLmNvbnRlbnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGVhZkNzdE5vZGUobm9kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCAmJiB0eXBlb2Ygbm9kZS50b2tlblR5cGUgPT09ICdvYmplY3QnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUm9vdENzdE5vZGUobm9kZSkge1xuICAgIHJldHVybiBpc0NvbXBvc2l0ZUNzdE5vZGUobm9kZSkgJiYgdHlwZW9mIG5vZGUuZnVsbFRleHQgPT09ICdzdHJpbmcnO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ludGF4LXRyZWUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgU3RyZWFtYCB3b3JrcyB3aXRoIHR3byBpbnB1dCBmdW5jdGlvbnM6XG4gKiAgLSBUaGUgZmlyc3QgZnVuY3Rpb24gY3JlYXRlcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBhbiBpdGVyYXRpb24uXG4gKiAgLSBUaGUgc2Vjb25kIGZ1bmN0aW9uIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gYEl0ZXJhdG9yUmVzdWx0YC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0Rm4sIG5leHRGbikge1xuICAgICAgICB0aGlzLnN0YXJ0Rm4gPSBzdGFydEZuO1xuICAgICAgICB0aGlzLm5leHRGbiA9IG5leHRGbjtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IGl0ZXJhdG9yXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVyYXRvci5uZXh0KCkuZG9uZSk7XG4gICAgfVxuICAgIGNvdW50KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCFuZXh0LmRvbmUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1NldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcyk7XG4gICAgfVxuICAgIHRvTWFwKGtleUZuLCB2YWx1ZUZuKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5U3RyZWFtID0gdGhpcy5tYXAoZWxlbWVudCA9PiBbXG4gICAgICAgICAgICBrZXlGbiA/IGtleUZuKGVsZW1lbnQpIDogZWxlbWVudCxcbiAgICAgICAgICAgIHZhbHVlRm4gPyB2YWx1ZUZuKGVsZW1lbnQpIDogZWxlbWVudFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoZW50cnlTdHJlYW0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbigpO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBvdGhlcltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgoKSA9PiAoeyBmaXJzdDogdGhpcy5zdGFydEZuKCksIGZpcnN0RG9uZTogZmFsc2UgfSksIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmZpcnN0RG9uZSkge1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0Rm4oc3RhdGUuZmlyc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoIXJlc3VsdC5kb25lKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5maXJzdERvbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoIXJlc3VsdC5kb25lKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGpvaW4oc2VwYXJhdG9yID0gJywnKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgbGV0IGFkZFNlcGFyYXRvciA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFkZFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlICs9IHRvU3RyaW5nKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRTZXBhcmF0b3IgPSB0cnVlO1xuICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGluZGV4T2Yoc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4ID0gMCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gZnJvbUluZGV4ICYmIG5leHQudmFsdWUgPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGV2ZXJ5KHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNvbWUocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobmV4dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgY2FsbGJhY2tmbihuZXh0LnZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXAoY2FsbGJhY2tmbikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5zdGFydEZuLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHRoaXMubmV4dEZuKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBjYWxsYmFja2ZuKHZhbHVlKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmlsdGVyKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5zdGFydEZuLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubmV4dEZuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lICYmIHByZWRpY2F0ZShyZXN1bHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAoIXJlc3VsdC5kb25lKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbk51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZSA9PiBlICE9PSB1bmRlZmluZWQgJiYgZSAhPT0gbnVsbCk7XG4gICAgfVxuICAgIHJlZHVjZShjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gbmV4dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFja2ZuKHByZXZpb3VzVmFsdWUsIG5leHQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgICB9XG4gICAgcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZVJlZHVjZSh0aGlzLml0ZXJhdG9yKCksIGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSk7XG4gICAgfVxuICAgIHJlY3Vyc2l2ZVJlZHVjZShpdGVyYXRvciwgY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IHRoaXMucmVjdXJzaXZlUmVkdWNlKGl0ZXJhdG9yLCBjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpO1xuICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2tmbihwcmV2aW91c1ZhbHVlLCBuZXh0LnZhbHVlKTtcbiAgICB9XG4gICAgZmluZChwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobmV4dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGluY2x1ZGVzKHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKG5leHQudmFsdWUgPT09IHNlYXJjaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmbGF0TWFwKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IHRoaXM6IHRoaXMuc3RhcnRGbigpIH0pLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHN0YXRlLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSB0aGlzLm5leHRGbihzdGF0ZS50aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFwcGVkID0gY2FsbGJhY2tmbih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0l0ZXJhYmxlKG1hcHBlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gbWFwcGVkW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogbWFwcGVkIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5pdGVyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmbGF0KGRlcHRoKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZXB0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGRlcHRoID4gMSA/IHRoaXMuZmxhdChkZXB0aCAtIDEpIDogdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IHRoaXM6IHN0cmVhbS5zdGFydEZuKCkgfSksIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pdGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHN0cmVhbS5uZXh0Rm4oc3RhdGUudGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3IgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5pdGVyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoZWFkKCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgdGFpbChza2lwQ291bnQgPSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhcnRGbigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBza2lwQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRGbihzdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LCB0aGlzLm5leHRGbik7XG4gICAgfVxuICAgIGxpbWl0KG1heFNpemUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IHNpemU6IDAsIHN0YXRlOiB0aGlzLnN0YXJ0Rm4oKSB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuc2l6ZSsrO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dEZuKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3RpbmN0KGJ5KSB7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBieSA/IGJ5KGUpIDogZTtcbiAgICAgICAgICAgIGlmIChzZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZShvdGhlciwga2V5KSB7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ga2V5ID8ga2V5KGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgIG90aGVyS2V5U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3duS2V5ID0ga2V5ID8ga2V5KGUpIDogZTtcbiAgICAgICAgICAgIHJldHVybiAhb3RoZXJLZXlTZXQuaGFzKG93bktleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAodHlwZW9mIGl0ZW0udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQW4gZW1wdHkgc3RyZWFtIG9mIGFueSB0eXBlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUkVBTSA9IG5ldyBTdHJlYW1JbXBsKCgpID0+IHVuZGVmaW5lZCwgKCkgPT4gRE9ORV9SRVNVTFQpO1xuLyoqXG4gKiBVc2UgdGhpcyBgSXRlcmF0b3JSZXN1bHRgIHdoZW4gaW1wbGVtZW50aW5nIGEgYFN0cmVhbUltcGxgIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmUgZWxlbWVudHMgaW4gdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNvbnN0IERPTkVfUkVTVUxUID0gT2JqZWN0LmZyZWV6ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBmcm9tIG9uZSBvciBtb3JlIGl0ZXJhYmxlcyBvciBhcnJheS1saWtlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbSguLi5jb2xsZWN0aW9ucykge1xuICAgIGlmIChjb2xsZWN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zWzBdO1xuICAgICAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFN0cmVhbUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCksIChpdGVyYXRvcikgPT4gaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IGluZGV4OiAwIH0pLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5kZXggPCBjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGNvbGxlY3Rpb25bc3RhdGUuaW5kZXgrK10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgY29sbEluZGV4OiAwLCBhcnJJbmRleDogMCB9KSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hcnJJbmRleCA8IHN0YXRlLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzdGF0ZS5hcnJheVtzdGF0ZS5hcnJJbmRleCsrXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFycmF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zW3N0YXRlLmNvbGxJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJheSA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5pdGVyYXRvciB8fCBzdGF0ZS5hcnJheSB8fCBzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX1NUUkVBTTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYFRyZWVTdHJlYW1gIHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZCBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG4gKiBjaGlsZHJlbiBvZiBpdHMgYXJndW1lbnQuIFdoZXRoZXIgdGhlIHJvb3Qgbm9kZSBpbmNsdWRlZCBpbiB0aGUgc3RyZWFtIGlzIGNvbnRyb2xsZWQgd2l0aCB0aGVcbiAqIGBpbmNsdWRlUm9vdGAgb3B0aW9uLCB3aGljaCBkZWZhdWx0cyB0byBgZmFsc2VgLlxuICovXG5leHBvcnQgY2xhc3MgVHJlZVN0cmVhbUltcGwgZXh0ZW5kcyBTdHJlYW1JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigoKSA9PiAoe1xuICAgICAgICAgICAgaXRlcmF0b3JzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVSb290KSA/IFtbcm9vdF1bU3ltYm9sLml0ZXJhdG9yXSgpXSA6IFtjaGlsZHJlbihyb290KVtTeW1ib2wuaXRlcmF0b3JdKCldLFxuICAgICAgICAgICAgcHJ1bmVkOiBmYWxzZVxuICAgICAgICB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnBydW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcnVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5pdGVyYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3JzW3N0YXRlLml0ZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnB1c2goY2hpbGRyZW4obmV4dC52YWx1ZSlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgcHJ1bmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zdGF0ZS5wcnVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiBpdGVyYXRvclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHJlZHVjZSBhIHN0cmVhbSB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IHZhciBSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKFJlZHVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHN1bSBvZiBhIG51bWJlciBzdHJlYW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIH1cbiAgICBSZWR1Y3Rpb24uc3VtID0gc3VtO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYSBudW1iZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2R1Y3Qoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMCk7XG4gICAgfVxuICAgIFJlZHVjdGlvbi5wcm9kdWN0ID0gcHJvZHVjdDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtaW5pbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1pbiA9IG1pbjtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1heCA9IG1heDtcbn0pKFJlZHVjdGlvbiB8fCAoUmVkdWN0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBpc0NvbXBvc2l0ZUNzdE5vZGUsIGlzTGVhZkNzdE5vZGUsIGlzUm9vdENzdE5vZGUgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBUcmVlU3RyZWFtSW1wbCB9IGZyb20gJy4vc3RyZWFtLmpzJztcbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBDU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUsXG4gKiBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1Dc3Qobm9kZSkge1xuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwobm9kZSwgZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9LCB7IGluY2x1ZGVSb290OiB0cnVlIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJlYW0gb2YgYWxsIGxlYWYgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgYW5kIGluZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiByb290IG5vZGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuQ3N0KG5vZGUpIHtcbiAgICByZXR1cm4gc3RyZWFtQ3N0KG5vZGUpLmZpbHRlcihpc0xlYWZDc3ROb2RlKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgY3N0IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgc3BlY2lmaWVkIHBhcmVudCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDaGlsZE5vZGUoY2hpbGQsIHBhcmVudCkge1xuICAgIHdoaWxlIChjaGlsZC5jb250YWluZXIpIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5jb250YWluZXI7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5Ub1JhbmdlKHRva2VuKSB7XG4gICAgLy8gQ2hldnJvdGFpbiB1c2VzIDEtYmFzZWQgaW5kaWNlcyBldmVyeXdoZXJlXG4gICAgLy8gU28gd2Ugc3VidHJhY3QgMSBmcm9tIGV2ZXJ5IHZhbHVlIHRvIGFsaWduIHdpdGggdGhlIExTUFxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHRva2VuLnN0YXJ0Q29sdW1uIC0gMSxcbiAgICAgICAgICAgIGxpbmU6IHRva2VuLnN0YXJ0TGluZSAtIDFcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBjaGFyYWN0ZXI6IHRva2VuLmVuZENvbHVtbixcbiAgICAgICAgICAgIGxpbmU6IHRva2VuLmVuZExpbmUgLSAxXG4gICAgICAgIH1cbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvRG9jdW1lbnRTZWdtZW50KG5vZGUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgeyBvZmZzZXQsIGVuZCwgcmFuZ2UgfSA9IG5vZGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZW5kLFxuICAgICAgICBsZW5ndGg6IGVuZCAtIG9mZnNldFxuICAgIH07XG59XG5leHBvcnQgdmFyIFJhbmdlQ29tcGFyaXNvbjtcbihmdW5jdGlvbiAoUmFuZ2VDb21wYXJpc29uKSB7XG4gICAgUmFuZ2VDb21wYXJpc29uW1JhbmdlQ29tcGFyaXNvbltcIkJlZm9yZVwiXSA9IDBdID0gXCJCZWZvcmVcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiQWZ0ZXJcIl0gPSAxXSA9IFwiQWZ0ZXJcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiT3ZlcmxhcEZyb250XCJdID0gMl0gPSBcIk92ZXJsYXBGcm9udFwiO1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJPdmVybGFwQmFja1wiXSA9IDNdID0gXCJPdmVybGFwQmFja1wiO1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJJbnNpZGVcIl0gPSA0XSA9IFwiSW5zaWRlXCI7XG59KShSYW5nZUNvbXBhcmlzb24gfHwgKFJhbmdlQ29tcGFyaXNvbiA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVJhbmdlKHJhbmdlLCB0bykge1xuICAgIGlmIChyYW5nZS5lbmQubGluZSA8IHRvLnN0YXJ0LmxpbmUgfHwgKHJhbmdlLmVuZC5saW5lID09PSB0by5zdGFydC5saW5lICYmIHJhbmdlLmVuZC5jaGFyYWN0ZXIgPCByYW5nZS5zdGFydC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uQmVmb3JlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5nZS5zdGFydC5saW5lID4gdG8uZW5kLmxpbmUgfHwgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IHRvLmVuZC5saW5lICYmIHJhbmdlLnN0YXJ0LmNoYXJhY3RlciA+IHRvLmVuZC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uQWZ0ZXI7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5zaWRlID0gcmFuZ2Uuc3RhcnQubGluZSA+IHRvLnN0YXJ0LmxpbmUgfHwgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IHRvLnN0YXJ0LmxpbmUgJiYgcmFuZ2Uuc3RhcnQuY2hhcmFjdGVyID49IHRvLnN0YXJ0LmNoYXJhY3Rlcik7XG4gICAgY29uc3QgZW5kSW5zaWRlID0gcmFuZ2UuZW5kLmxpbmUgPCB0by5lbmQubGluZSB8fCAocmFuZ2UuZW5kLmxpbmUgPT09IHRvLmVuZC5saW5lICYmIHJhbmdlLmVuZC5jaGFyYWN0ZXIgPD0gdG8uZW5kLmNoYXJhY3Rlcik7XG4gICAgaWYgKHN0YXJ0SW5zaWRlICYmIGVuZEluc2lkZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VDb21wYXJpc29uLkluc2lkZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlQ29tcGFyaXNvbi5PdmVybGFwQmFjaztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uT3ZlcmxhcEZyb250O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpblJhbmdlKHJhbmdlLCB0bykge1xuICAgIGNvbnN0IGNvbXBhcmlzb24gPSBjb21wYXJlUmFuZ2UocmFuZ2UsIHRvKTtcbiAgICByZXR1cm4gY29tcGFyaXNvbiA+IFJhbmdlQ29tcGFyaXNvbi5BZnRlcjtcbn1cbi8vIFRoZSBcXHB7TH0gcmVnZXggbWF0Y2hlcyBhbnkgdW5pY29kZSBsZXR0ZXIgY2hhcmFjdGVyLCBpLmUuIGNoYXJhY3RlcnMgZnJvbSBub24tZW5nbGlzaCBhbHBoYWJldHNcbi8vIFRvZ2V0aGVyIHdpdGggXFx3IGl0IG1hdGNoZXMgYW55IGtpbmQgb2YgY2hhcmFjdGVyIHdoaWNoIGNhbiBjb21tb25seSBhcHBlYXIgaW4gSURzXG5leHBvcnQgY29uc3QgRGVmYXVsdE5hbWVSZWdleHAgPSAvXltcXHdcXHB7TH1dJC91O1xuLyoqXG4gKiBQZXJmb3JtcyBgZmluZExlYWZOb2RlQXRPZmZzZXRgIHdpdGggYSBtaW5vciBkaWZmZXJlbmNlOiBXaGVuIGVuY291bnRlcmluZyBhIGNoYXJhY3RlciB0aGF0IG1hdGNoZXMgdGhlIGBuYW1lUmVnZXhwYCBhcmd1bWVudCxcbiAqIGl0IHdpbGwgaW5zdGVhZCByZXR1cm4gdGhlIGxlYWYgbm9kZSBhdCB0aGUgYG9mZnNldCAtIDFgIHBvc2l0aW9uLlxuICpcbiAqIEZvciBMU1Agc2VydmljZXMsIHVzZXJzIGV4cGVjdCB0aGF0IHRoZSBkZWNsYXJhdGlvbiBvZiBhbiBlbGVtZW50IGlzIGF2YWlsYWJsZSBpZiB0aGUgY3Vyc29yIGlzIGRpcmVjdGx5IGFmdGVyIHRoZSBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZERlY2xhcmF0aW9uTm9kZUF0T2Zmc2V0KGNzdE5vZGUsIG9mZnNldCwgbmFtZVJlZ2V4cCA9IERlZmF1bHROYW1lUmVnZXhwKSB7XG4gICAgaWYgKGNzdE5vZGUpIHtcbiAgICAgICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsT2Zmc2V0ID0gb2Zmc2V0IC0gY3N0Tm9kZS5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QXRPZmZzZXQgPSBjc3ROb2RlLnRleHQuY2hhckF0KGxvY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghbmFtZVJlZ2V4cC50ZXN0KHRleHRBdE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZExlYWZOb2RlQXRPZmZzZXQoY3N0Tm9kZSwgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUoY3N0Tm9kZSwgY29tbWVudE5hbWVzKSB7XG4gICAgaWYgKGNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgcHJldmlvdXMgPSBnZXRQcmV2aW91c05vZGUoY3N0Tm9kZSwgdHJ1ZSk7XG4gICAgICAgIGlmIChwcmV2aW91cyAmJiBpc0NvbW1lbnROb2RlKHByZXZpb3VzLCBjb21tZW50TmFtZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUm9vdENzdE5vZGUoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIEdvIGZyb20gdGhlIGZpcnN0IG5vbi1oaWRkZW4gbm9kZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByZXZlcnNlIG9yZGVyXG4gICAgICAgICAgICAvLyBXZSBkbyB0aGlzIHRvIGZpbmQgdGhlIGNvbW1lbnQgbm9kZSB3aGljaCBkaXJlY3RseSBwcmVjZWRlcyB0aGUgcm9vdCBub2RlXG4gICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IGNzdE5vZGUuY29udGVudC5maW5kSW5kZXgoZSA9PiAhZS5oaWRkZW4pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVuZEluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNzdE5vZGUuY29udGVudFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDb21tZW50Tm9kZShjaGlsZCwgY29tbWVudE5hbWVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDb21tZW50Tm9kZShjc3ROb2RlLCBjb21tZW50TmFtZXMpIHtcbiAgICByZXR1cm4gaXNMZWFmQ3N0Tm9kZShjc3ROb2RlKSAmJiBjb21tZW50TmFtZXMuaW5jbHVkZXMoY3N0Tm9kZS50b2tlblR5cGUubmFtZSk7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBsZWFmIENTVCBub2RlIGF0IHRoZSBzcGVjaWZpZWQgMC1iYXNlZCBzdHJpbmcgb2Zmc2V0LlxuICogTm90ZSB0aGF0IHRoZSBnaXZlbiBvZmZzZXQgd2lsbCBiZSB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSByZXR1cm5lZCBsZWFmIG5vZGUuXG4gKlxuICogSWYgdGhlIG9mZnNldCBkb2VzIG5vdCBwb2ludCB0byBhIENTVCBub2RlIChidXQganVzdCB3aGl0ZSBzcGFjZSksIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBDU1Qgbm9kZSB0byBzZWFyY2ggdGhyb3VnaC5cbiAqIEBwYXJhbSBvZmZzZXQgVGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKiBAcmV0dXJucyBUaGUgQ1NUIG5vZGUgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGVhZk5vZGVBdE9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAoaXNMZWFmQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFJlc3VsdCA9IGJpbmFyeVNlYXJjaChub2RlLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRMZWFmTm9kZUF0T2Zmc2V0KHNlYXJjaFJlc3VsdCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbGVhZiBDU1Qgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIDAtYmFzZWQgc3RyaW5nIG9mZnNldC5cbiAqIElmIG5vIENTVCBub2RlIGV4aXN0cyBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLCBpdCB3aWxsIHJldHVybiB0aGUgbGVhZiBub2RlIGJlZm9yZSBpdC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBsZWFmIG5vZGUgYmVmb3JlIHRoZSBzcGVjaWZpZWQgb2Zmc2V0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgQ1NUIG5vZGUgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybnMgVGhlIENTVCBub2RlIGNsb3Nlc3QgdG8gdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGVhZk5vZGVCZWZvcmVPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKGlzTGVhZkNzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHQgPSBiaW5hcnlTZWFyY2gobm9kZSwgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRMZWFmTm9kZUJlZm9yZU9mZnNldChzZWFyY2hSZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChub2RlLCBvZmZzZXQsIGNsb3Nlc3QpIHtcbiAgICBsZXQgbGVmdCA9IDA7XG4gICAgbGV0IHJpZ2h0ID0gbm9kZS5jb250ZW50Lmxlbmd0aCAtIDE7XG4gICAgbGV0IGNsb3Nlc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1pZGRsZSA9IE1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICAgICAgY29uc3QgbWlkZGxlTm9kZSA9IG5vZGUuY29udGVudFttaWRkbGVdO1xuICAgICAgICBpZiAobWlkZGxlTm9kZS5vZmZzZXQgPD0gb2Zmc2V0ICYmIG1pZGRsZU5vZGUuZW5kID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAvLyBGb3VuZCBhbiBleGFjdCBtYXRjaFxuICAgICAgICAgICAgcmV0dXJuIG1pZGRsZU5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pZGRsZU5vZGUuZW5kIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBjbG9zZXN0IG5vZGUgKGxlc3MgdGhhbiBvZmZzZXQpIGFuZCBtb3ZlIHRvIHRoZSByaWdodCBoYWxmXG4gICAgICAgICAgICBjbG9zZXN0Tm9kZSA9IGNsb3Nlc3QgPyBtaWRkbGVOb2RlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGVmdCA9IG1pZGRsZSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBsZWZ0IGhhbGZcbiAgICAgICAgICAgIHJpZ2h0ID0gbWlkZGxlIC0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdE5vZGU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlvdXNOb2RlKG5vZGUsIGhpZGRlbiA9IHRydWUpIHtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGxldCBpbmRleCA9IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHBhcmVudC5jb250ZW50W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoaWRkZW4gfHwgIXByZXZpb3VzLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHROb2RlKG5vZGUsIGhpZGRlbiA9IHRydWUpIHtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGxldCBpbmRleCA9IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBwYXJlbnQuY29udGVudC5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsYXN0KSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBhcmVudC5jb250ZW50W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChoaWRkZW4gfHwgIW5leHQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGFydGxpbmVOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGNvbnN0IGxpbmUgPSBub2RlLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgbGV0IGxhc3QgPSBub2RlO1xuICAgIGxldCBpbmRleDtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IHNlbGZJbmRleCA9IGluZGV4ICE9PSBudWxsICYmIGluZGV4ICE9PSB2b2lkIDAgPyBpbmRleCA6IHBhcmVudC5jb250ZW50LmluZGV4T2Yobm9kZSk7XG4gICAgICAgIGlmIChzZWxmSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4ID0gc2VsZkluZGV4IC0gMTtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY29udGVudFtpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucmFuZ2Uuc3RhcnQubGluZSAhPT0gbGluZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBsYXN0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEludGVyaW9yTm9kZXMoc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IGNvbW1vblBhcmVudCA9IGdldENvbW1vblBhcmVudChzdGFydCwgZW5kKTtcbiAgICBpZiAoIWNvbW1vblBhcmVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjb21tb25QYXJlbnQucGFyZW50LmNvbnRlbnQuc2xpY2UoY29tbW9uUGFyZW50LmEgKyAxLCBjb21tb25QYXJlbnQuYik7XG59XG5mdW5jdGlvbiBnZXRDb21tb25QYXJlbnQoYSwgYikge1xuICAgIGNvbnN0IGFQYXJlbnRzID0gZ2V0UGFyZW50Q2hhaW4oYSk7XG4gICAgY29uc3QgYlBhcmVudHMgPSBnZXRQYXJlbnRDaGFpbihiKTtcbiAgICBsZXQgY3VycmVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFQYXJlbnRzLmxlbmd0aCAmJiBpIDwgYlBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYVBhcmVudCA9IGFQYXJlbnRzW2ldO1xuICAgICAgICBjb25zdCBiUGFyZW50ID0gYlBhcmVudHNbaV07XG4gICAgICAgIGlmIChhUGFyZW50LnBhcmVudCA9PT0gYlBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyZW50OiBhUGFyZW50LnBhcmVudCxcbiAgICAgICAgICAgICAgICBhOiBhUGFyZW50LmluZGV4LFxuICAgICAgICAgICAgICAgIGI6IGJQYXJlbnQuaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudENoYWluKG5vZGUpIHtcbiAgICBjb25zdCBjaGFpbiA9IFtdO1xuICAgIHdoaWxlIChub2RlLmNvbnRhaW5lcikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmNvbnRhaW5lcjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBjaGFpbi5wdXNoKHtcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gY2hhaW4ucmV2ZXJzZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LXV0aWxzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBjbGFzcyBFcnJvcldpdGhMb2NhdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG5vZGUgPyBgJHttZXNzYWdlfSBhdCAke25vZGUucmFuZ2Uuc3RhcnQubGluZX06JHtub2RlLnJhbmdlLnN0YXJ0LmNoYXJhY3Rlcn1gIDogbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFVucmVhY2hhYmxlKF8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yISBUaGUgaW5wdXQgdmFsdWUgd2FzIG5vdCBoYW5kbGVkLicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRoaXMgZmlsZSB3YXMgZ2VuZXJhdGVkIGJ5IGxhbmdpdW0tY2xpIDMuMC4wLlxuICogRE8gTk9UIEVESVQgTUFOVUFMTFkhXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIH0gZnJvbSAnLi4vLi4vc3ludGF4LXRyZWUuanMnO1xuZXhwb3J0IGNvbnN0IExhbmdpdW1HcmFtbWFyVGVybWluYWxzID0ge1xuICAgIElEOiAvXFxeP1tfYS16QS1aXVtcXHdfXSovLFxuICAgIFNUUklORzogL1wiKFxcXFwufFteXCJcXFxcXSkqXCJ8JyhcXFxcLnxbXidcXFxcXSkqJy8sXG4gICAgTlVNQkVSOiAvTmFOfC0/KChcXGQqXFwuXFxkK3xcXGQrKShbRWVdWystXT9cXGQrKT98SW5maW5pdHkpLyxcbiAgICBSZWdleExpdGVyYWw6IC9cXC8oPyFbKis/XSkoPzpbXlxcclxcblxcWy9cXFxcXXxcXFxcLnxcXFsoPzpbXlxcclxcblxcXVxcXFxdfFxcXFwuKSpcXF0pK1xcL1thLXpdKi8sXG4gICAgV1M6IC9cXHMrLyxcbiAgICBNTF9DT01NRU5UOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgU0xfQ09NTUVOVDogL1xcL1xcL1teXFxuXFxyXSovLFxufTtcbmV4cG9ydCBjb25zdCBBYnN0cmFjdFJ1bGUgPSAnQWJzdHJhY3RSdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0UnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBYnN0cmFjdFJ1bGUpO1xufVxuZXhwb3J0IGNvbnN0IEFic3RyYWN0VHlwZSA9ICdBYnN0cmFjdFR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWJzdHJhY3RUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFic3RyYWN0VHlwZSk7XG59XG5leHBvcnQgY29uc3QgQ29uZGl0aW9uID0gJ0NvbmRpdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNDb25kaXRpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29uZGl0aW9uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0ZlYXR1cmVOYW1lKGl0ZW0pIHtcbiAgICByZXR1cm4gaXNQcmltaXRpdmVUeXBlKGl0ZW0pIHx8IGl0ZW0gPT09ICdjdXJyZW50JyB8fCBpdGVtID09PSAnZW50cnknIHx8IGl0ZW0gPT09ICdleHRlbmRzJyB8fCBpdGVtID09PSAnZmFsc2UnIHx8IGl0ZW0gPT09ICdmcmFnbWVudCcgfHwgaXRlbSA9PT0gJ2dyYW1tYXInIHx8IGl0ZW0gPT09ICdoaWRkZW4nIHx8IGl0ZW0gPT09ICdpbXBvcnQnIHx8IGl0ZW0gPT09ICdpbnRlcmZhY2UnIHx8IGl0ZW0gPT09ICdyZXR1cm5zJyB8fCBpdGVtID09PSAndGVybWluYWwnIHx8IGl0ZW0gPT09ICd0cnVlJyB8fCBpdGVtID09PSAndHlwZScgfHwgaXRlbSA9PT0gJ2luZmVyJyB8fCBpdGVtID09PSAnaW5mZXJzJyB8fCBpdGVtID09PSAnd2l0aCcgfHwgKHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyAmJiAoL1xcXj9bX2EtekEtWl1bXFx3X10qLy50ZXN0KGl0ZW0pKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNQcmltaXRpdmVUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSA9PT0gJ3N0cmluZycgfHwgaXRlbSA9PT0gJ251bWJlcicgfHwgaXRlbSA9PT0gJ2Jvb2xlYW4nIHx8IGl0ZW0gPT09ICdEYXRlJyB8fCBpdGVtID09PSAnYmlnaW50Jztcbn1cbmV4cG9ydCBjb25zdCBUeXBlRGVmaW5pdGlvbiA9ICdUeXBlRGVmaW5pdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlRGVmaW5pdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUeXBlRGVmaW5pdGlvbik7XG59XG5leHBvcnQgY29uc3QgVmFsdWVMaXRlcmFsID0gJ1ZhbHVlTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNWYWx1ZUxpdGVyYWwoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVmFsdWVMaXRlcmFsKTtcbn1cbmV4cG9ydCBjb25zdCBBYnN0cmFjdEVsZW1lbnQgPSAnQWJzdHJhY3RFbGVtZW50JztcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0RWxlbWVudChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBYnN0cmFjdEVsZW1lbnQpO1xufVxuZXhwb3J0IGNvbnN0IEFycmF5TGl0ZXJhbCA9ICdBcnJheUxpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlMaXRlcmFsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFycmF5TGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgQXJyYXlUeXBlID0gJ0FycmF5VHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheVR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQXJyYXlUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBCb29sZWFuTGl0ZXJhbCA9ICdCb29sZWFuTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuTGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBCb29sZWFuTGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgQ29uanVuY3Rpb24gPSAnQ29uanVuY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uanVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29uanVuY3Rpb24pO1xufVxuZXhwb3J0IGNvbnN0IERpc2p1bmN0aW9uID0gJ0Rpc2p1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Rpc2p1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIERpc2p1bmN0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBHcmFtbWFyID0gJ0dyYW1tYXInO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JhbW1hcihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcmFtbWFyKTtcbn1cbmV4cG9ydCBjb25zdCBHcmFtbWFySW1wb3J0ID0gJ0dyYW1tYXJJbXBvcnQnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JhbW1hckltcG9ydChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcmFtbWFySW1wb3J0KTtcbn1cbmV4cG9ydCBjb25zdCBJbmZlcnJlZFR5cGUgPSAnSW5mZXJyZWRUeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0luZmVycmVkVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBJbmZlcnJlZFR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IEludGVyZmFjZSA9ICdJbnRlcmZhY2UnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZXJmYWNlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEludGVyZmFjZSk7XG59XG5leHBvcnQgY29uc3QgTmFtZWRBcmd1bWVudCA9ICdOYW1lZEFyZ3VtZW50JztcbmV4cG9ydCBmdW5jdGlvbiBpc05hbWVkQXJndW1lbnQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmFtZWRBcmd1bWVudCk7XG59XG5leHBvcnQgY29uc3QgTmVnYXRpb24gPSAnTmVnYXRpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmVnYXRpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmVnYXRpb24pO1xufVxuZXhwb3J0IGNvbnN0IE51bWJlckxpdGVyYWwgPSAnTnVtYmVyTGl0ZXJhbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXJMaXRlcmFsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIE51bWJlckxpdGVyYWwpO1xufVxuZXhwb3J0IGNvbnN0IFBhcmFtZXRlciA9ICdQYXJhbWV0ZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyYW1ldGVyKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBhcmFtZXRlcik7XG59XG5leHBvcnQgY29uc3QgUGFyYW1ldGVyUmVmZXJlbmNlID0gJ1BhcmFtZXRlclJlZmVyZW5jZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNQYXJhbWV0ZXJSZWZlcmVuY2UoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUGFyYW1ldGVyUmVmZXJlbmNlKTtcbn1cbmV4cG9ydCBjb25zdCBQYXJzZXJSdWxlID0gJ1BhcnNlclJ1bGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyc2VyUnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQYXJzZXJSdWxlKTtcbn1cbmV4cG9ydCBjb25zdCBSZWZlcmVuY2VUeXBlID0gJ1JlZmVyZW5jZVR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVmZXJlbmNlVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZWZlcmVuY2VUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBSZXR1cm5UeXBlID0gJ1JldHVyblR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmV0dXJuVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZXR1cm5UeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBTaW1wbGVUeXBlID0gJ1NpbXBsZVR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2ltcGxlVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBTaW1wbGVUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBTdHJpbmdMaXRlcmFsID0gJ1N0cmluZ0xpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RyaW5nTGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBTdHJpbmdMaXRlcmFsKTtcbn1cbmV4cG9ydCBjb25zdCBUZXJtaW5hbFJ1bGUgPSAnVGVybWluYWxSdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Rlcm1pbmFsUnVsZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUZXJtaW5hbFJ1bGUpO1xufVxuZXhwb3J0IGNvbnN0IFR5cGUgPSAnVHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IFR5cGVBdHRyaWJ1dGUgPSAnVHlwZUF0dHJpYnV0ZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlQXR0cmlidXRlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFR5cGVBdHRyaWJ1dGUpO1xufVxuZXhwb3J0IGNvbnN0IFVuaW9uVHlwZSA9ICdVbmlvblR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5pb25UeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFVuaW9uVHlwZSk7XG59XG5leHBvcnQgY29uc3QgQWN0aW9uID0gJ0FjdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNBY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQWN0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBBbHRlcm5hdGl2ZXMgPSAnQWx0ZXJuYXRpdmVzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FsdGVybmF0aXZlcyhpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBbHRlcm5hdGl2ZXMpO1xufVxuZXhwb3J0IGNvbnN0IEFzc2lnbm1lbnQgPSAnQXNzaWdubWVudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNBc3NpZ25tZW50KGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFzc2lnbm1lbnQpO1xufVxuZXhwb3J0IGNvbnN0IENoYXJhY3RlclJhbmdlID0gJ0NoYXJhY3RlclJhbmdlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0NoYXJhY3RlclJhbmdlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIENoYXJhY3RlclJhbmdlKTtcbn1cbmV4cG9ydCBjb25zdCBDcm9zc1JlZmVyZW5jZSA9ICdDcm9zc1JlZmVyZW5jZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNDcm9zc1JlZmVyZW5jZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBDcm9zc1JlZmVyZW5jZSk7XG59XG5leHBvcnQgY29uc3QgRW5kT2ZGaWxlID0gJ0VuZE9mRmlsZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNFbmRPZkZpbGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgRW5kT2ZGaWxlKTtcbn1cbmV4cG9ydCBjb25zdCBHcm91cCA9ICdHcm91cCc7XG5leHBvcnQgZnVuY3Rpb24gaXNHcm91cChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBHcm91cCk7XG59XG5leHBvcnQgY29uc3QgS2V5d29yZCA9ICdLZXl3b3JkJztcbmV4cG9ydCBmdW5jdGlvbiBpc0tleXdvcmQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgS2V5d29yZCk7XG59XG5leHBvcnQgY29uc3QgTmVnYXRlZFRva2VuID0gJ05lZ2F0ZWRUb2tlbic7XG5leHBvcnQgZnVuY3Rpb24gaXNOZWdhdGVkVG9rZW4oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgTmVnYXRlZFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBSZWdleFRva2VuID0gJ1JlZ2V4VG9rZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmVnZXhUb2tlbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSZWdleFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBSdWxlQ2FsbCA9ICdSdWxlQ2FsbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNSdWxlQ2FsbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBSdWxlQ2FsbCk7XG59XG5leHBvcnQgY29uc3QgVGVybWluYWxBbHRlcm5hdGl2ZXMgPSAnVGVybWluYWxBbHRlcm5hdGl2ZXMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGVybWluYWxBbHRlcm5hdGl2ZXMoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVGVybWluYWxBbHRlcm5hdGl2ZXMpO1xufVxuZXhwb3J0IGNvbnN0IFRlcm1pbmFsR3JvdXAgPSAnVGVybWluYWxHcm91cCc7XG5leHBvcnQgZnVuY3Rpb24gaXNUZXJtaW5hbEdyb3VwKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFRlcm1pbmFsR3JvdXApO1xufVxuZXhwb3J0IGNvbnN0IFRlcm1pbmFsUnVsZUNhbGwgPSAnVGVybWluYWxSdWxlQ2FsbCc7XG5leHBvcnQgZnVuY3Rpb24gaXNUZXJtaW5hbFJ1bGVDYWxsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFRlcm1pbmFsUnVsZUNhbGwpO1xufVxuZXhwb3J0IGNvbnN0IFVub3JkZXJlZEdyb3VwID0gJ1Vub3JkZXJlZEdyb3VwJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Vub3JkZXJlZEdyb3VwKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFVub3JkZXJlZEdyb3VwKTtcbn1cbmV4cG9ydCBjb25zdCBVbnRpbFRva2VuID0gJ1VudGlsVG9rZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW50aWxUb2tlbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBVbnRpbFRva2VuKTtcbn1cbmV4cG9ydCBjb25zdCBXaWxkY2FyZCA9ICdXaWxkY2FyZCc7XG5leHBvcnQgZnVuY3Rpb24gaXNXaWxkY2FyZChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBXaWxkY2FyZCk7XG59XG5leHBvcnQgY2xhc3MgTGFuZ2l1bUdyYW1tYXJBc3RSZWZsZWN0aW9uIGV4dGVuZHMgQWJzdHJhY3RBc3RSZWZsZWN0aW9uIHtcbiAgICBnZXRBbGxUeXBlcygpIHtcbiAgICAgICAgcmV0dXJuIFsnQWJzdHJhY3RFbGVtZW50JywgJ0Fic3RyYWN0UnVsZScsICdBYnN0cmFjdFR5cGUnLCAnQWN0aW9uJywgJ0FsdGVybmF0aXZlcycsICdBcnJheUxpdGVyYWwnLCAnQXJyYXlUeXBlJywgJ0Fzc2lnbm1lbnQnLCAnQm9vbGVhbkxpdGVyYWwnLCAnQ2hhcmFjdGVyUmFuZ2UnLCAnQ29uZGl0aW9uJywgJ0Nvbmp1bmN0aW9uJywgJ0Nyb3NzUmVmZXJlbmNlJywgJ0Rpc2p1bmN0aW9uJywgJ0VuZE9mRmlsZScsICdHcmFtbWFyJywgJ0dyYW1tYXJJbXBvcnQnLCAnR3JvdXAnLCAnSW5mZXJyZWRUeXBlJywgJ0ludGVyZmFjZScsICdLZXl3b3JkJywgJ05hbWVkQXJndW1lbnQnLCAnTmVnYXRlZFRva2VuJywgJ05lZ2F0aW9uJywgJ051bWJlckxpdGVyYWwnLCAnUGFyYW1ldGVyJywgJ1BhcmFtZXRlclJlZmVyZW5jZScsICdQYXJzZXJSdWxlJywgJ1JlZmVyZW5jZVR5cGUnLCAnUmVnZXhUb2tlbicsICdSZXR1cm5UeXBlJywgJ1J1bGVDYWxsJywgJ1NpbXBsZVR5cGUnLCAnU3RyaW5nTGl0ZXJhbCcsICdUZXJtaW5hbEFsdGVybmF0aXZlcycsICdUZXJtaW5hbEdyb3VwJywgJ1Rlcm1pbmFsUnVsZScsICdUZXJtaW5hbFJ1bGVDYWxsJywgJ1R5cGUnLCAnVHlwZUF0dHJpYnV0ZScsICdUeXBlRGVmaW5pdGlvbicsICdVbmlvblR5cGUnLCAnVW5vcmRlcmVkR3JvdXAnLCAnVW50aWxUb2tlbicsICdWYWx1ZUxpdGVyYWwnLCAnV2lsZGNhcmQnXTtcbiAgICB9XG4gICAgY29tcHV0ZUlzU3VidHlwZShzdWJ0eXBlLCBzdXBlcnR5cGUpIHtcbiAgICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEFjdGlvbjpcbiAgICAgICAgICAgIGNhc2UgQWx0ZXJuYXRpdmVzOlxuICAgICAgICAgICAgY2FzZSBBc3NpZ25tZW50OlxuICAgICAgICAgICAgY2FzZSBDaGFyYWN0ZXJSYW5nZTpcbiAgICAgICAgICAgIGNhc2UgQ3Jvc3NSZWZlcmVuY2U6XG4gICAgICAgICAgICBjYXNlIEVuZE9mRmlsZTpcbiAgICAgICAgICAgIGNhc2UgR3JvdXA6XG4gICAgICAgICAgICBjYXNlIEtleXdvcmQ6XG4gICAgICAgICAgICBjYXNlIE5lZ2F0ZWRUb2tlbjpcbiAgICAgICAgICAgIGNhc2UgUmVnZXhUb2tlbjpcbiAgICAgICAgICAgIGNhc2UgUnVsZUNhbGw6XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsQWx0ZXJuYXRpdmVzOlxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbEdyb3VwOlxuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbFJ1bGVDYWxsOlxuICAgICAgICAgICAgY2FzZSBVbm9yZGVyZWRHcm91cDpcbiAgICAgICAgICAgIGNhc2UgVW50aWxUb2tlbjpcbiAgICAgICAgICAgIGNhc2UgV2lsZGNhcmQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQWJzdHJhY3RFbGVtZW50LCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBcnJheUxpdGVyYWw6XG4gICAgICAgICAgICBjYXNlIE51bWJlckxpdGVyYWw6XG4gICAgICAgICAgICBjYXNlIFN0cmluZ0xpdGVyYWw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoVmFsdWVMaXRlcmFsLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBBcnJheVR5cGU6XG4gICAgICAgICAgICBjYXNlIFJlZmVyZW5jZVR5cGU6XG4gICAgICAgICAgICBjYXNlIFNpbXBsZVR5cGU6XG4gICAgICAgICAgICBjYXNlIFVuaW9uVHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShUeXBlRGVmaW5pdGlvbiwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbkxpdGVyYWw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQ29uZGl0aW9uLCBzdXBlcnR5cGUpIHx8IHRoaXMuaXNTdWJ0eXBlKFZhbHVlTGl0ZXJhbCwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29uanVuY3Rpb246XG4gICAgICAgICAgICBjYXNlIERpc2p1bmN0aW9uOlxuICAgICAgICAgICAgY2FzZSBOZWdhdGlvbjpcbiAgICAgICAgICAgIGNhc2UgUGFyYW1ldGVyUmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKENvbmRpdGlvbiwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSW5mZXJyZWRUeXBlOlxuICAgICAgICAgICAgY2FzZSBJbnRlcmZhY2U6XG4gICAgICAgICAgICBjYXNlIFR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQWJzdHJhY3RUeXBlLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQYXJzZXJSdWxlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEFic3RyYWN0UnVsZSwgc3VwZXJ0eXBlKSB8fCB0aGlzLmlzU3VidHlwZShBYnN0cmFjdFR5cGUsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsUnVsZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShBYnN0cmFjdFJ1bGUsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlZmVyZW5jZVR5cGUocmVmSW5mbykge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJZCA9IGAke3JlZkluZm8uY29udGFpbmVyLiR0eXBlfToke3JlZkluZm8ucHJvcGVydHl9YDtcbiAgICAgICAgc3dpdGNoIChyZWZlcmVuY2VJZCkge1xuICAgICAgICAgICAgY2FzZSAnQWN0aW9uOnR5cGUnOlxuICAgICAgICAgICAgY2FzZSAnQ3Jvc3NSZWZlcmVuY2U6dHlwZSc6XG4gICAgICAgICAgICBjYXNlICdJbnRlcmZhY2U6c3VwZXJUeXBlcyc6XG4gICAgICAgICAgICBjYXNlICdQYXJzZXJSdWxlOnJldHVyblR5cGUnOlxuICAgICAgICAgICAgY2FzZSAnU2ltcGxlVHlwZTp0eXBlUmVmJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdFR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHcmFtbWFyOmhpZGRlblRva2Vucyc6XG4gICAgICAgICAgICBjYXNlICdQYXJzZXJSdWxlOmhpZGRlblRva2Vucyc6XG4gICAgICAgICAgICBjYXNlICdSdWxlQ2FsbDpydWxlJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBBYnN0cmFjdFJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHcmFtbWFyOnVzZWRHcmFtbWFycyc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JhbW1hcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ05hbWVkQXJndW1lbnQ6cGFyYW1ldGVyJzpcbiAgICAgICAgICAgIGNhc2UgJ1BhcmFtZXRlclJlZmVyZW5jZTpwYXJhbWV0ZXInOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcmFtZXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1Rlcm1pbmFsUnVsZUNhbGw6cnVsZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVGVybWluYWxSdWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWZlcmVuY2VJZH0gaXMgbm90IGEgdmFsaWQgcmVmZXJlbmNlIGlkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFR5cGVNZXRhRGF0YSh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnQWJzdHJhY3RFbGVtZW50Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdBYnN0cmFjdEVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FycmF5TGl0ZXJhbCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQXJyYXlMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBcnJheVR5cGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FycmF5VHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VsZW1lbnRUeXBlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0Jvb2xlYW5MaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHJ1ZScsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0Nvbmp1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdDb25qdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xlZnQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdyaWdodCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0Rpc2p1bmN0aW9uJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdEaXNqdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xlZnQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdyaWdodCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0dyYW1tYXInOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0dyYW1tYXInLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbmVzSGlkZGVuVG9rZW5zJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaGlkZGVuVG9rZW5zJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaW1wb3J0cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ludGVyZmFjZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdpc0RlY2xhcmVkJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3J1bGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd1c2VkR3JhbW1hcnMnLCBkZWZhdWx0VmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHcmFtbWFySW1wb3J0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdHcmFtbWFySW1wb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGF0aCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0luZmVycmVkVHlwZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSW5mZXJyZWRUeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0ludGVyZmFjZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnSW50ZXJmYWNlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnYXR0cmlidXRlcycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdzdXBlclR5cGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTmFtZWRBcmd1bWVudCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnTmFtZWRBcmd1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhbGxlZEJ5TmFtZScsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3BhcmFtZXRlcicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbHVlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTmVnYXRpb24nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ05lZ2F0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdOdW1iZXJMaXRlcmFsJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOdW1iZXJMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQYXJhbWV0ZXInOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1BhcmFtZXRlcicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQYXJhbWV0ZXJSZWZlcmVuY2UnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1BhcmFtZXRlclJlZmVyZW5jZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3BhcmFtZXRlcicgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1BhcnNlclJ1bGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1BhcnNlclJ1bGUnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkYXRhVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlZmluZXNIaWRkZW5Ub2tlbnMnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbml0aW9uJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZW50cnknLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmcmFnbWVudCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2hpZGRlblRva2VucycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luZmVycmVkVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwYXJhbWV0ZXJzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmV0dXJuVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3dpbGRjYXJkJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnUmVmZXJlbmNlVHlwZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnUmVmZXJlbmNlVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JlZmVyZW5jZVR5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdSZXR1cm5UeXBlJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZXR1cm5UeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NpbXBsZVR5cGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1NpbXBsZVR5cGUnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdwcmltaXRpdmVUeXBlJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc3RyaW5nVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGVSZWYnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdTdHJpbmdMaXRlcmFsJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUZXJtaW5hbFJ1bGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Rlcm1pbmFsUnVsZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlZmluaXRpb24nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdmcmFnbWVudCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2hpZGRlbicsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVHlwZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVHlwZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVHlwZUF0dHJpYnV0ZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVHlwZUF0dHJpYnV0ZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHRWYWx1ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2lzT3B0aW9uYWwnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1VuaW9uVHlwZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVW5pb25UeXBlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0FjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZmVhdHVyZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2luZmVycmVkVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ29wZXJhdG9yJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FsdGVybmF0aXZlcyc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQWx0ZXJuYXRpdmVzJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0Fzc2lnbm1lbnQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0Fzc2lnbm1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ZlYXR1cmUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdvcGVyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlcm1pbmFsJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ2hhcmFjdGVyUmFuZ2UnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0NoYXJhY3RlclJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsZWZ0JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmlnaHQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDcm9zc1JlZmVyZW5jZSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnQ3Jvc3NSZWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlcHJlY2F0ZWRTeW50YXgnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0ZXJtaW5hbCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdFbmRPZkZpbGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0VuZE9mRmlsZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnR3JvdXAnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ0dyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2d1YXJkQ29uZGl0aW9uJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnS2V5d29yZCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnS2V5d29yZCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdOZWdhdGVkVG9rZW4nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ05lZ2F0ZWRUb2tlbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGVybWluYWwnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdSZWdleFRva2VuJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSZWdleFRva2VuJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdyZWdleCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1J1bGVDYWxsJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdSdWxlQ2FsbCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2FyZ3VtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncnVsZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1Rlcm1pbmFsQWx0ZXJuYXRpdmVzJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXJtaW5hbEFsdGVybmF0aXZlcycsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUZXJtaW5hbEdyb3VwJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdUZXJtaW5hbEdyb3VwJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1Rlcm1pbmFsUnVsZUNhbGwnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ1Rlcm1pbmFsUnVsZUNhbGwnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3J1bGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdVbm9yZGVyZWRHcm91cCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVW5vcmRlcmVkR3JvdXAnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VsZW1lbnRzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVW50aWxUb2tlbic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnVW50aWxUb2tlbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGVybWluYWwnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdXaWxkY2FyZCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnV2lsZGNhcmQnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgcmVmbGVjdGlvbiA9IG5ldyBMYW5naXVtR3JhbW1hckFzdFJlZmxlY3Rpb24oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBpc0FzdE5vZGUsIGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgRE9ORV9SRVNVTFQsIHN0cmVhbSwgU3RyZWFtSW1wbCwgVHJlZVN0cmVhbUltcGwgfSBmcm9tICcuL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBpblJhbmdlIH0gZnJvbSAnLi9jc3QtdXRpbHMuanMnO1xuLyoqXG4gKiBMaW5rIHRoZSBgJGNvbnRhaW5lcmAgYW5kIG90aGVyIHJlbGF0ZWQgcHJvcGVydGllcyBvZiBldmVyeSBBU1Qgbm9kZSB0aGF0IGlzIGRpcmVjdGx5IGNvbnRhaW5lZFxuICogaW4gdGhlIGdpdmVuIGBub2RlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtDb250ZW50VG9Db250YWluZXIobm9kZSkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLiRjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kY29udGFpbmVyUHJvcGVydHkgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kY29udGFpbmVySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3ROb2RlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgIHZhbHVlLiRjb250YWluZXJQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdhbGsgYWxvbmcgdGhlIGhpZXJhcmNoeSBvZiBjb250YWluZXJzIGZyb20gdGhlIGdpdmVuIEFTVCBub2RlIHRvIHRoZSByb290IGFuZCByZXR1cm4gdGhlIGZpcnN0XG4gKiBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgdHlwZSBwcmVkaWNhdGUuIElmIHRoZSBzdGFydCBub2RlIGl0c2VsZiBtYXRjaGVzLCBpdCBpcyByZXR1cm5lZC5cbiAqIElmIG5vIGNvbnRhaW5lciBtYXRjaGVzLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRhaW5lck9mVHlwZShub2RlLCB0eXBlUHJlZGljYXRlKSB7XG4gICAgbGV0IGl0ZW0gPSBub2RlO1xuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlUHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtID0gaXRlbS4kY29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBXYWxrIGFsb25nIHRoZSBoaWVyYXJjaHkgb2YgY29udGFpbmVycyBmcm9tIHRoZSBnaXZlbiBBU1Qgbm9kZSB0byB0aGUgcm9vdCBhbmQgY2hlY2sgZm9yIGV4aXN0ZW5jZVxuICogb2YgYSBjb250YWluZXIgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBwcmVkaWNhdGUuIFRoZSBzdGFydCBub2RlIGlzIGluY2x1ZGVkIGluIHRoZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250YWluZXJPZlR5cGUobm9kZSwgcHJlZGljYXRlKSB7XG4gICAgbGV0IGl0ZW0gPSBub2RlO1xuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBpdGVtLiRjb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0cmlldmUgdGhlIGRvY3VtZW50IGluIHdoaWNoIHRoZSBnaXZlbiBBU1Qgbm9kZSBpcyBjb250YWluZWQuIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCBpc1xuICogdXN1YWxseSBoZWxkIGJ5IHRoZSByb290IG5vZGUgb2YgdGhlIEFTVC5cbiAqXG4gKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBub2RlIGlzIG5vdCBjb250YWluZWQgaW4gYSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgICBjb25zdCByb290Tm9kZSA9IGZpbmRSb290Tm9kZShub2RlKTtcbiAgICBjb25zdCByZXN1bHQgPSByb290Tm9kZS4kZG9jdW1lbnQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1Qgbm9kZSBoYXMgbm8gZG9jdW1lbnQuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgZ2l2ZW4gQVNUIG5vZGUgYnkgZm9sbG93aW5nIHRoZSBgJGNvbnRhaW5lcmAgcmVmZXJlbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSb290Tm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuJGNvbnRhaW5lcikge1xuICAgICAgICBub2RlID0gbm9kZS4kY29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBBU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiBub2RlLiBUaGlzIGluY2x1ZGVzXG4gKiBzaW5nbGUtdmFsdWVkIGFzIHdlbGwgYXMgbXVsdGktdmFsdWVkIChhcnJheSkgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbUNvbnRlbnRzKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIG11c3QgYmUgYW4gQXN0Tm9kZS4nKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFuZ2U7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7XG4gICAgICAgIGtleXM6IE9iamVjdC5rZXlzKG5vZGUpLFxuICAgICAgICBrZXlJbmRleDogMCxcbiAgICAgICAgYXJyYXlJbmRleDogMFxuICAgIH0pLCBzdGF0ZSA9PiB7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5rZXlJbmRleCA8IHN0YXRlLmtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHN0YXRlLmtleXNbc3RhdGUua2V5SW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGVJblJhbmdlKHZhbHVlLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5hcnJheUluZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmFycmF5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGVsZW1lbnQpICYmIGlzQXN0Tm9kZUluUmFuZ2UoZWxlbWVudCwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBlbGVtZW50IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXJyYXlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUua2V5SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgQVNUIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSByb290IG5vZGUgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQWxsQ29udGVudHMocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3Qgbm9kZSBtdXN0IGJlIGFuIEFzdE5vZGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwocm9vdCwgbm9kZSA9PiBzdHJlYW1Db250ZW50cyhub2RlLCBvcHRpb25zKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgQVNUIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLFxuICogaW5jbHVkaW5nIHRoZSByb290IG5vZGUgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQXN0KHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG5vZGUgbXVzdCBiZSBhbiBBc3ROb2RlLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJhbmdlKSAmJiAhaXNBc3ROb2RlSW5SYW5nZShyb290LCBvcHRpb25zLnJhbmdlKSkge1xuICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgc3RyZWFtIGlmIHRoZSByb290IG5vZGUgaXNuJ3QgaW4gcmFuZ2VcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlU3RyZWFtSW1wbChyb290LCAoKSA9PiBbXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwocm9vdCwgbm9kZSA9PiBzdHJlYW1Db250ZW50cyhub2RlLCBvcHRpb25zKSwgeyBpbmNsdWRlUm9vdDogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGlzQXN0Tm9kZUluUmFuZ2UoYXN0Tm9kZSwgcmFuZ2UpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVJhbmdlID0gKF9hID0gYXN0Tm9kZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhbmdlO1xuICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGluUmFuZ2Uobm9kZVJhbmdlLCByYW5nZSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgY3Jvc3MtcmVmZXJlbmNlcyB0aGF0IGFyZSBoZWxkIGJ5IHRoZSBnaXZlbiBBU1Qgbm9kZS4gVGhpcyBpbmNsdWRlc1xuICogc2luZ2xlLXZhbHVlZCBhcyB3ZWxsIGFzIG11bHRpLXZhbHVlZCAoYXJyYXkpIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1SZWZlcmVuY2VzKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHtcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMobm9kZSksXG4gICAgICAgIGtleUluZGV4OiAwLFxuICAgICAgICBhcnJheUluZGV4OiAwXG4gICAgfSksIHN0YXRlID0+IHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmtleUluZGV4IDwgc3RhdGUua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gc3RhdGUua2V5c1tzdGF0ZS5rZXlJbmRleF07XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5LnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5rZXlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHsgcmVmZXJlbmNlOiB2YWx1ZSwgY29udGFpbmVyOiBub2RlLCBwcm9wZXJ0eSB9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5hcnJheUluZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmFycmF5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHsgcmVmZXJlbmNlOiBlbGVtZW50LCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5LCBpbmRleCB9IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXJyYXlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUua2V5SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBTdHJlYW0gb2YgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG5vZGUgZnJvbSB0aGUgQXN0Tm9kZSB0cmVlXG4gKlxuICogQHBhcmFtIHRhcmdldE5vZGUgQXN0Tm9kZSB3ZSBhcmUgbG9va2luZyBmb3JcbiAqIEBwYXJhbSBsb29rdXAgQXN0Tm9kZSB3aGVyZSB3ZSBzZWFyY2ggZm9yIHJlZmVyZW5jZXMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgZG9jdW1lbnQgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExvY2FsUmVmZXJlbmNlcyh0YXJnZXROb2RlLCBsb29rdXAgPSBnZXREb2N1bWVudCh0YXJnZXROb2RlKS5wYXJzZVJlc3VsdC52YWx1ZSkge1xuICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICBzdHJlYW1Bc3QobG9va3VwKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBzdHJlYW1SZWZlcmVuY2VzKG5vZGUpLmZvckVhY2gocmVmSW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAocmVmSW5mby5yZWZlcmVuY2UucmVmID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZkluZm8ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbShyZWZzKTtcbn1cbi8qKlxuICogQXNzaWducyBhbGwgbWFuZGF0b3J5IEFTVCBwcm9wZXJ0aWVzIHRvIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gcmVmbGVjdGlvbiBSZWZsZWN0aW9uIG9iamVjdCB1c2VkIHRvIGdhdGhlciBtYW5kYXRvcnkgcHJvcGVydGllcyBmb3IgdGhlIG5vZGUuXG4gKiBAcGFyYW0gbm9kZSBTcGVjaWZpZWQgbm9kZSBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmQgcHJvcGVydGllcyBhcmUgZGlyZWN0bHkgYXNzaWduZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25NYW5kYXRvcnlQcm9wZXJ0aWVzKHJlZmxlY3Rpb24sIG5vZGUpIHtcbiAgICBjb25zdCB0eXBlTWV0YURhdGEgPSByZWZsZWN0aW9uLmdldFR5cGVNZXRhRGF0YShub2RlLiR0eXBlKTtcbiAgICBjb25zdCBnZW5lcmljTm9kZSA9IG5vZGU7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0eXBlTWV0YURhdGEucHJvcGVydGllcykge1xuICAgICAgICAvLyBPbmx5IHNldCB0aGUgdmFsdWUgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBhbHJlYWR5IHNldCBhbmQgaWYgaXQgaGFzIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAocHJvcGVydHkuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZ2VuZXJpY05vZGVbcHJvcGVydHkubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ2VuZXJpY05vZGVbcHJvcGVydHkubmFtZV0gPSBjb3B5RGVmYXVsdFZhbHVlKHByb3BlcnR5LmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb3B5RGVmYXVsdFZhbHVlKHByb3BlcnR5VHlwZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5wcm9wZXJ0eVR5cGUubWFwKGNvcHlEZWZhdWx0VmFsdWUpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVR5cGU7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgQVNUIG5vZGUuXG4gKiBUaGUgcmVzdWx0aW5nIGNvcHkgd2lsbCBvbmx5IGNvbnRhaW4gc2VtYW50aWNhbGx5IHJlbGV2YW50IGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBgJHR5cGVgIHByb3BlcnR5IGFuZCBBU1QgcHJvcGVydGllcy5cbiAqXG4gKiBSZWZlcmVuY2VzIGFyZSBjb3BpZWQgd2l0aG91dCByZXNvbHZlZCBjcm9zcyByZWZlcmVuY2UuIFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gaXMgdXNlZCB0byByZWJ1aWxkIHRoZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5QXN0Tm9kZShub2RlLCBidWlsZFJlZmVyZW5jZSkge1xuICAgIGNvbnN0IGNvcHkgPSB7ICR0eXBlOiBub2RlLiR0eXBlIH07XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IGNvcHlBc3ROb2RlKHZhbHVlLCBidWlsZFJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZmVyZW5jZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb3B5W25hbWVdID0gYnVpbGRSZWZlcmVuY2UoY29weSwgbmFtZSwgdmFsdWUuJHJlZk5vZGUsIHZhbHVlLiRyZWZUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29waWVkQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkQXJyYXkucHVzaChjb3B5QXN0Tm9kZShlbGVtZW50LCBidWlsZFJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWRBcnJheS5wdXNoKGJ1aWxkUmVmZXJlbmNlKGNvcHksIG5hbWUsIGVsZW1lbnQuJHJlZk5vZGUsIGVsZW1lbnQuJHJlZlRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZEFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IGNvcGllZEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmtDb250ZW50VG9Db250YWluZXIoY29weSk7XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QtdXRpbHMuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGNjKGNoYXIpIHtcbiAgICByZXR1cm4gY2hhci5jaGFyQ29kZUF0KDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFRvU2V0KGl0ZW0sIHNldCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICAgIGl0ZW0uZm9yRWFjaChmdW5jdGlvbiAoc3ViSXRlbSkge1xuICAgICAgICAgICAgc2V0LnB1c2goc3ViSXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0LnB1c2goaXRlbSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZsYWcoZmxhZ09iaiwgZmxhZ0tleSkge1xuICAgIGlmIChmbGFnT2JqW2ZsYWdLZXldID09PSB0cnVlKSB7XG4gICAgICAgIHRocm93IFwiZHVwbGljYXRlIGZsYWcgXCIgKyBmbGFnS2V5O1xuICAgIH1cbiAgICBjb25zdCB4ID0gZmxhZ09ialtmbGFnS2V5XTtcbiAgICBmbGFnT2JqW2ZsYWdLZXldID0gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBBU1NFUlRfRVhJU1RTKG9iaikge1xuICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiSW50ZXJuYWwgRXJyb3IgLSBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5leHBvcnQgZnVuY3Rpb24gQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKSB7XG4gICAgdGhyb3cgRXJyb3IoXCJJbnRlcm5hbCBFcnJvciAtIFNob3VsZCBuZXZlciBnZXQgaGVyZSFcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNDaGFyYWN0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9ialtcInR5cGVcIl0gPT09IFwiQ2hhcmFjdGVyXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJpbXBvcnQgeyBjYyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5leHBvcnQgY29uc3QgZGlnaXRzQ2hhckNvZGVzID0gW107XG5mb3IgKGxldCBpID0gY2MoXCIwXCIpOyBpIDw9IGNjKFwiOVwiKTsgaSsrKSB7XG4gICAgZGlnaXRzQ2hhckNvZGVzLnB1c2goaSk7XG59XG5leHBvcnQgY29uc3Qgd29yZENoYXJDb2RlcyA9IFtjYyhcIl9cIildLmNvbmNhdChkaWdpdHNDaGFyQ29kZXMpO1xuZm9yIChsZXQgaSA9IGNjKFwiYVwiKTsgaSA8PSBjYyhcInpcIik7IGkrKykge1xuICAgIHdvcmRDaGFyQ29kZXMucHVzaChpKTtcbn1cbmZvciAobGV0IGkgPSBjYyhcIkFcIik7IGkgPD0gY2MoXCJaXCIpOyBpKyspIHtcbiAgICB3b3JkQ2hhckNvZGVzLnB1c2goaSk7XG59XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAjY2hhcmFjdGVyLWNsYXNzZXNcbmV4cG9ydCBjb25zdCB3aGl0ZXNwYWNlQ29kZXMgPSBbXG4gICAgY2MoXCIgXCIpLFxuICAgIGNjKFwiXFxmXCIpLFxuICAgIGNjKFwiXFxuXCIpLFxuICAgIGNjKFwiXFxyXCIpLFxuICAgIGNjKFwiXFx0XCIpLFxuICAgIGNjKFwiXFx2XCIpLFxuICAgIGNjKFwiXFx0XCIpLFxuICAgIGNjKFwiXFx1MDBhMFwiKSxcbiAgICBjYyhcIlxcdTE2ODBcIiksXG4gICAgY2MoXCJcXHUyMDAwXCIpLFxuICAgIGNjKFwiXFx1MjAwMVwiKSxcbiAgICBjYyhcIlxcdTIwMDJcIiksXG4gICAgY2MoXCJcXHUyMDAzXCIpLFxuICAgIGNjKFwiXFx1MjAwNFwiKSxcbiAgICBjYyhcIlxcdTIwMDVcIiksXG4gICAgY2MoXCJcXHUyMDA2XCIpLFxuICAgIGNjKFwiXFx1MjAwN1wiKSxcbiAgICBjYyhcIlxcdTIwMDhcIiksXG4gICAgY2MoXCJcXHUyMDA5XCIpLFxuICAgIGNjKFwiXFx1MjAwYVwiKSxcbiAgICBjYyhcIlxcdTIwMjhcIiksXG4gICAgY2MoXCJcXHUyMDI5XCIpLFxuICAgIGNjKFwiXFx1MjAyZlwiKSxcbiAgICBjYyhcIlxcdTIwNWZcIiksXG4gICAgY2MoXCJcXHUzMDAwXCIpLFxuICAgIGNjKFwiXFx1ZmVmZlwiKSxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFyYWN0ZXItY2xhc3Nlcy5qcy5tYXAiLCJpbXBvcnQgeyBhZGRGbGFnLCBBU1NFUlRfRVhJU1RTLCBBU1NFUlRfTkVWRVJfUkVBQ0hfSEVSRSwgY2MsIGluc2VydFRvU2V0LCBpc0NoYXJhY3RlciwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgZGlnaXRzQ2hhckNvZGVzLCB3aGl0ZXNwYWNlQ29kZXMsIHdvcmRDaGFyQ29kZXMsIH0gZnJvbSBcIi4vY2hhcmFjdGVyLWNsYXNzZXMuanNcIjtcbi8vIGNvbnN0cyBhbmQgdXRpbGl0aWVzXG5jb25zdCBoZXhEaWdpdFBhdHRlcm4gPSAvWzAtOWEtZkEtRl0vO1xuY29uc3QgZGVjaW1hbFBhdHRlcm4gPSAvWzAtOV0vO1xuY29uc3QgZGVjaW1hbFBhdHRlcm5Ob1plcm8gPSAvWzEtOV0vO1xuLy8gaHR0cHM6Ly9oYWNrZXJub29uLmNvbS90aGUtbWFkbmVzcy1vZi1wYXJzaW5nLXJlYWwtd29ybGQtamF2YXNjcmlwdC1yZWdleHBzLWQ5ZWUzMzZkZjk4M1xuLy8gaHR0cHM6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi84LjAvaW5kZXguaHRtbCNwcm9kLVBhdHRlcm5cbmV4cG9ydCBjbGFzcyBSZWdFeHBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBcIlwiO1xuICAgICAgICB0aGlzLmdyb3VwSWR4ID0gMDtcbiAgICB9XG4gICAgc2F2ZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWR4OiB0aGlzLmlkeCxcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgZ3JvdXBJZHg6IHRoaXMuZ3JvdXBJZHgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlc3RvcmVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLmlkeCA9IG5ld1N0YXRlLmlkeDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ld1N0YXRlLmlucHV0O1xuICAgICAgICB0aGlzLmdyb3VwSWR4ID0gbmV3U3RhdGUuZ3JvdXBJZHg7XG4gICAgfVxuICAgIHBhdHRlcm4oaW5wdXQpIHtcbiAgICAgICAgLy8gcGFyc2VyIHN0YXRlXG4gICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmdyb3VwSWR4ID0gMDtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIi9cIik7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5kaXNqdW5jdGlvbigpO1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiL1wiKTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIkZsYWdzXCIsXG4gICAgICAgICAgICBsb2M6IHsgYmVnaW46IHRoaXMuaWR4LCBlbmQ6IGlucHV0Lmxlbmd0aCB9LFxuICAgICAgICAgICAgZ2xvYmFsOiBmYWxzZSxcbiAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZhbHNlLFxuICAgICAgICAgICAgbXVsdGlMaW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHVuaWNvZGU6IGZhbHNlLFxuICAgICAgICAgICAgc3RpY2t5OiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNSZWdFeHBGbGFnKCkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcImdsb2JhbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJpZ25vcmVDYXNlXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcIm11bHRpTGluZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJ1bmljb2RlXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwieVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGbGFnKGZsYWdzLCBcInN0aWNreVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWR4ICE9PSB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSZWR1bmRhbnQgaW5wdXQ6IFwiICsgdGhpcy5pbnB1dC5zdWJzdHJpbmcodGhpcy5pZHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJQYXR0ZXJuXCIsXG4gICAgICAgICAgICBmbGFnczogZmxhZ3MsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBsb2M6IHRoaXMubG9jKDApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBkaXNqdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgYWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuaWR4O1xuICAgICAgICBhbHRzLnB1c2godGhpcy5hbHRlcm5hdGl2ZSgpKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGVla0NoYXIoKSA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ8XCIpO1xuICAgICAgICAgICAgYWx0cy5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJEaXNqdW5jdGlvblwiLCB2YWx1ZTogYWx0cywgbG9jOiB0aGlzLmxvYyhiZWdpbikgfTtcbiAgICB9XG4gICAgYWx0ZXJuYXRpdmUoKSB7XG4gICAgICAgIGNvbnN0IHRlcm1zID0gW107XG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5pZHg7XG4gICAgICAgIHdoaWxlICh0aGlzLmlzVGVybSgpKSB7XG4gICAgICAgICAgICB0ZXJtcy5wdXNoKHRoaXMudGVybSgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkFsdGVybmF0aXZlXCIsIHZhbHVlOiB0ZXJtcywgbG9jOiB0aGlzLmxvYyhiZWdpbikgfTtcbiAgICB9XG4gICAgdGVybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3NlcnRpb24oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXJ0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdG9tKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzZXJ0aW9uKCkge1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuaWR4O1xuICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiU3RhcnRBbmNob3JcIixcbiAgICAgICAgICAgICAgICAgICAgbG9jOiB0aGlzLmxvYyhiZWdpbiksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJFbmRBbmNob3JcIiwgbG9jOiB0aGlzLmxvYyhiZWdpbikgfTtcbiAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJXb3JkQm91bmRhcnlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKGJlZ2luKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJCXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiTm9uV29yZEJvdW5kYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiB0aGlzLmxvYyhiZWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBBc3NlcnRpb24gRXNjYXBlXCIpO1xuICAgICAgICAgICAgLy8gJyg/PScgb3IgJyg/ISdcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIik7XG4gICAgICAgICAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiPVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwiTG9va2FoZWFkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIiFcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyh0eXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNqdW5jdGlvbiA9IHRoaXMuZGlzanVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZGlzanVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogdGhpcy5sb2MoYmVnaW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgcmV0dXJuIEFTU0VSVF9ORVZFUl9SRUFDSF9IRVJFKCk7XG4gICAgfVxuICAgIHF1YW50aWZpZXIoaXNCYWNrdHJhY2tpbmcgPSBmYWxzZSkge1xuICAgICAgICBsZXQgcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5pZHg7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDEsXG4gICAgICAgICAgICAgICAgICAgIGF0TW9zdDogSW5maW5pdHksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IDAsXG4gICAgICAgICAgICAgICAgICAgIGF0TW9zdDogMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIntcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBhdExlYXN0ID0gdGhpcy5pbnRlZ2VySW5jbHVkaW5nWmVybygpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBhdExlYXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiLFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0TW9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzRGlnaXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdCA9IHRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBhdE1vc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiBhdExlYXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aHJvd2luZyBleGNlcHRpb25zIGZyb20gXCJBU1NFUlRfRVhJU1RTXCIgZHVyaW5nIGJhY2t0cmFja2luZ1xuICAgICAgICAgICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgICAgICAgICAgaWYgKGlzQmFja3RyYWNraW5nID09PSB0cnVlICYmIHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgQVNTRVJUX0VYSVNUUyhyYW5nZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhyb3dpbmcgZXhjZXB0aW9ucyBmcm9tIFwiQVNTRVJUX0VYSVNUU1wiIGR1cmluZyBiYWNrdHJhY2tpbmdcbiAgICAgICAgLy8gY2F1c2VzIHNldmVyZSBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbnNcbiAgICAgICAgaWYgKGlzQmFja3RyYWNraW5nID09PSB0cnVlICYmIHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICAgICAgaWYgKEFTU0VSVF9FWElTVFMocmFuZ2UpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZWVrQ2hhcigwKSA9PT0gXCI/XCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiP1wiKTtcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLmdyZWVkeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYW5nZS50eXBlID0gXCJRdWFudGlmaWVyXCI7XG4gICAgICAgICAgICByYW5nZS5sb2MgPSB0aGlzLmxvYyhiZWdpbik7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXRvbSgpIHtcbiAgICAgICAgbGV0IGF0b207XG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5pZHg7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmRvdEFsbCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5hdG9tRXNjYXBlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmNoYXJhY3RlckNsYXNzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIGF0b20gPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT09IHVuZGVmaW5lZCAmJiB0aGlzLmlzUGF0dGVybkNoYXJhY3RlcigpKSB7XG4gICAgICAgICAgICBhdG9tID0gdGhpcy5wYXR0ZXJuQ2hhcmFjdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICAgICAgaWYgKEFTU0VSVF9FWElTVFMoYXRvbSkpIHtcbiAgICAgICAgICAgIGF0b20ubG9jID0gdGhpcy5sb2MoYmVnaW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNRdWFudGlmaWVyKCkpIHtcbiAgICAgICAgICAgICAgICBhdG9tLnF1YW50aWZpZXIgPSB0aGlzLnF1YW50aWZpZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdG9tO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJldHVybiBBU1NFUlRfTkVWRVJfUkVBQ0hfSEVSRSgpO1xuICAgIH1cbiAgICBkb3RBbGwoKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIuXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJTZXRcIixcbiAgICAgICAgICAgIGNvbXBsZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogW2NjKFwiXFxuXCIpLCBjYyhcIlxcclwiKSwgY2MoXCJcXHUyMDI4XCIpLCBjYyhcIlxcdTIwMjlcIildLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhdG9tRXNjYXBlKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiXFxcXFwiKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsRXNjYXBlQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ3XCI6XG4gICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlckNsYXNzRXNjYXBlKCk7XG4gICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sRXNjYXBlQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcImNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5udWxDaGFyYWN0ZXJBdG9tKCk7XG4gICAgICAgICAgICBjYXNlIFwieFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhleEVzY2FwZVNlcXVlbmNlQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdFeHBVbmljb2RlRXNjYXBlU2VxdWVuY2VBdG9tKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlkZW50aXR5RXNjYXBlQXRvbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY2ltYWxFc2NhcGVBdG9tKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucG9zaXRpdmVJbnRlZ2VyKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiR3JvdXBCYWNrUmVmZXJlbmNlXCIsIHZhbHVlOiB2YWx1ZSB9O1xuICAgIH1cbiAgICBjaGFyYWN0ZXJDbGFzc0VzY2FwZSgpIHtcbiAgICAgICAgbGV0IHNldDtcbiAgICAgICAgbGV0IGNvbXBsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgICAgICBzZXQgPSBkaWdpdHNDaGFyQ29kZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgICAgIHNldCA9IGRpZ2l0c0NoYXJDb2RlcztcbiAgICAgICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNcIjpcbiAgICAgICAgICAgICAgICBzZXQgPSB3aGl0ZXNwYWNlQ29kZXM7XG4gICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgICAgIHNldCA9IHdvcmRDaGFyQ29kZXM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiV1wiOlxuICAgICAgICAgICAgICAgIHNldCA9IHdvcmRDaGFyQ29kZXM7XG4gICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICAgICAgaWYgKEFTU0VSVF9FWElTVFMoc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJTZXRcIiwgdmFsdWU6IHNldCwgY29tcGxlbWVudDogY29tcGxlbWVudCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJldHVybiBBU1NFUlRfTkVWRVJfUkVBQ0hfSEVSRSgpO1xuICAgIH1cbiAgICBjb250cm9sRXNjYXBlQXRvbSgpIHtcbiAgICAgICAgbGV0IGVzY2FwZUNvZGU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFxmXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5cIjpcbiAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIGVzY2FwZUNvZGUgPSBjYyhcIlxcclwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFx0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInZcIjpcbiAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHZcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2VcbiAgICAgICAgaWYgKEFTU0VSVF9FWElTVFMoZXNjYXBlQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBlc2NhcGVDb2RlIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgcmV0dXJuIEFTU0VSVF9ORVZFUl9SRUFDSF9IRVJFKCk7XG4gICAgfVxuICAgIGNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiY1wiKTtcbiAgICAgICAgY29uc3QgbGV0dGVyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgIGlmICgvW2EtekEtWl0vLnRlc3QobGV0dGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGV0dGVyQ29kZSA9IGxldHRlci50b1VwcGVyQ2FzZSgpLmNoYXJDb2RlQXQoMCkgLSA2NDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGxldHRlckNvZGUgfTtcbiAgICB9XG4gICAgbnVsQ2hhcmFjdGVyQXRvbSgpIHtcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgJ1tsb29rYWhlYWQg4oiJIERlY2ltYWxEaWdpdF0nXG4gICAgICAgIC8vIFRPRE86IGZvciB0aGUgZGVwcmVjYXRlZCBvY3RhbCBlc2NhcGUgc2VxdWVuY2VcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIjBcIik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhcIlxcMFwiKSB9O1xuICAgIH1cbiAgICBoZXhFc2NhcGVTZXF1ZW5jZUF0b20oKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ4XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhleERpZ2l0cygyKTtcbiAgICB9XG4gICAgcmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcInVcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSGV4RGlnaXRzKDQpO1xuICAgIH1cbiAgICBpZGVudGl0eUVzY2FwZUF0b20oKSB7XG4gICAgICAgIC8vIFRPRE86IGltcGxlbWVudCBcIlNvdXJjZUNoYXJhY3RlciBidXQgbm90IFVuaWNvZGVJRENvbnRpbnVlXCJcbiAgICAgICAgLy8gLy8gaHR0cDovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIzMS8jU3BlY2lmaWNfQ2hhcmFjdGVyX0FkanVzdG1lbnRzXG4gICAgICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhlc2NhcGVkQ2hhcikgfTtcbiAgICB9XG4gICAgY2xhc3NQYXR0ZXJuQ2hhcmFjdGVyQXRvbSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKG5leHRDaGFyKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYXJhY3RlckNsYXNzKCkge1xuICAgICAgICBjb25zdCBzZXQgPSBbXTtcbiAgICAgICAgbGV0IGNvbXBsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIltcIik7XG4gICAgICAgIGlmICh0aGlzLnBlZWtDaGFyKDApID09PSBcIl5cIikge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl5cIik7XG4gICAgICAgICAgICBjb21wbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodGhpcy5pc0NsYXNzQXRvbSgpKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5jbGFzc0F0b20oKTtcbiAgICAgICAgICAgIGNvbnN0IGlzRnJvbVNpbmdsZUNoYXIgPSBmcm9tLnR5cGUgPT09IFwiQ2hhcmFjdGVyXCI7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXIoZnJvbSkgJiYgdGhpcy5pc1JhbmdlRGFzaCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIi1cIik7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSB0aGlzLmNsYXNzQXRvbSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVG9TaW5nbGVDaGFyID0gdG8udHlwZSA9PT0gXCJDaGFyYWN0ZXJcIjtcbiAgICAgICAgICAgICAgICAvLyBhIHJhbmdlIGNhbiBvbmx5IGJlIHVzZWQgd2hlbiBib3RoIHNpZGVzIGFyZSBzaW5nbGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGlmIChpc0NoYXJhY3Rlcih0bykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvLnZhbHVlIDwgZnJvbS52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJSYW5nZSBvdXQgb2Ygb3JkZXIgaW4gY2hhcmFjdGVyIGNsYXNzXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKHsgZnJvbTogZnJvbS52YWx1ZSwgdG86IHRvLnZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCBkYXNoXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRvU2V0KGZyb20udmFsdWUsIHNldCk7XG4gICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKGNjKFwiLVwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydFRvU2V0KHRvLnZhbHVlLCBzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFRvU2V0KGZyb20udmFsdWUsIHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIl1cIik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiU2V0XCIsIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQsIHZhbHVlOiBzZXQgfTtcbiAgICB9XG4gICAgY2xhc3NBdG9tKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJdXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIik7XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzRXNjYXBlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGFzc0VzY2FwZSgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIlxcXFxcIik7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAvLyBNYXRjaGVzIGEgYmFja3NwYWNlLlxuICAgICAgICAgICAgLy8gKE5vdCB0byBiZSBjb25mdXNlZCB3aXRoIFxcYiB3b3JkIGJvdW5kYXJ5IG91dHNpZGUgY2hhcmFjdGVyQ2xhc3MpXG4gICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhcIlxcdTAwMDhcIikgfTtcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpO1xuICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVsQ2hhcmFjdGVyQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBncm91cCgpIHtcbiAgICAgICAgbGV0IGNhcHR1cmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIoXCIpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCI/XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIjpcIik7XG4gICAgICAgICAgICAgICAgY2FwdHVyaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXBJZHgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGlzanVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIilcIik7XG4gICAgICAgIGNvbnN0IGdyb3VwQXN0ID0ge1xuICAgICAgICAgICAgdHlwZTogXCJHcm91cFwiLFxuICAgICAgICAgICAgY2FwdHVyaW5nOiBjYXB0dXJpbmcsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjYXB0dXJpbmcpIHtcbiAgICAgICAgICAgIGdyb3VwQXN0W1wiaWR4XCJdID0gdGhpcy5ncm91cElkeDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXBBc3Q7XG4gICAgfVxuICAgIHBvc2l0aXZlSW50ZWdlcigpIHtcbiAgICAgICAgbGV0IG51bWJlciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNhbid0IGV2ZXIgZ2V0IGhlcmUgZHVlIHRvIHByZXZpb3VzIGxvb2thaGVhZCBjaGVja3NcbiAgICAgICAgLy8gc3RpbGwgaW1wbGVtZW50aW5nIHRoaXMgZXJyb3IgY2hlY2tpbmcgaW4gY2FzZSB0aGlzIGV2ZXIgY2hhbmdlcy5cbiAgICAgICAgaWYgKGRlY2ltYWxQYXR0ZXJuTm9aZXJvLnRlc3QobnVtYmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZGVjaW1hbFBhdHRlcm4udGVzdCh0aGlzLnBlZWtDaGFyKDApKSkge1xuICAgICAgICAgICAgbnVtYmVyICs9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUludChudW1iZXIsIDEwKTtcbiAgICB9XG4gICAgaW50ZWdlckluY2x1ZGluZ1plcm8oKSB7XG4gICAgICAgIGxldCBudW1iZXIgPSB0aGlzLnBvcENoYXIoKTtcbiAgICAgICAgaWYgKGRlY2ltYWxQYXR0ZXJuLnRlc3QobnVtYmVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlY2ltYWxQYXR0ZXJuLnRlc3QodGhpcy5wZWVrQ2hhcigwKSkpIHtcbiAgICAgICAgICAgIG51bWJlciArPSB0aGlzLnBvcENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgfVxuICAgIHBhdHRlcm5DaGFyYWN0ZXIoKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgIHN3aXRjaCAobmV4dENoYXIpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIitcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIilcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRCRFwiKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJDaGFyYWN0ZXJcIiwgdmFsdWU6IGNjKG5leHRDaGFyKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmVnRXhwRmxhZygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ1wiOlxuICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUmFuZ2VEYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZWVrQ2hhcigpID09PSBcIi1cIiAmJiB0aGlzLmlzQ2xhc3NBdG9tKDEpO1xuICAgIH1cbiAgICBpc0RpZ2l0KCkge1xuICAgICAgICByZXR1cm4gZGVjaW1hbFBhdHRlcm4udGVzdCh0aGlzLnBlZWtDaGFyKDApKTtcbiAgICB9XG4gICAgaXNDbGFzc0F0b20oaG93TXVjaCA9IDApIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKGhvd011Y2gpKSB7XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1Rlcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXRvbSgpIHx8IHRoaXMuaXNBc3NlcnRpb24oKTtcbiAgICB9XG4gICAgaXNBdG9tKCkge1xuICAgICAgICBpZiAodGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjogLy8gYXRvbUVzY2FwZVxuICAgICAgICAgICAgY2FzZSBcIltcIjogLy8gY2hhcmFjdGVyQ2xhc3NcbiAgICAgICAgICAgIC8vIFRPRE86IGlzQXRvbSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaXNBc3NlcnRpb24gLSBkaXNhbWJpZ3VhdGVcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6IC8vIGdyb3VwXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0Fzc2VydGlvbigpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIC8vICdcXGInIG9yICdcXEInXG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigxKSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gJyg/PScgb3IgJyg/ISdcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnBlZWtDaGFyKDEpID09PSBcIj9cIiAmJlxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wZWVrQ2hhcigyKSA9PT0gXCI9XCIgfHwgdGhpcy5wZWVrQ2hhcigyKSA9PT0gXCIhXCIpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUXVhbnRpZmllcigpIHtcbiAgICAgICAgY29uc3QgcHJldlN0YXRlID0gdGhpcy5zYXZlU3RhdGUoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1YW50aWZpZXIodHJ1ZSkgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGUocHJldlN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1BhdHRlcm5DaGFyYWN0ZXIoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiXlwiOlxuICAgICAgICAgICAgY2FzZSBcIiRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgY2FzZSBcIipcIjpcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICBjYXNlIFwiW1wiOlxuICAgICAgICAgICAgY2FzZSBcInxcIjpcbiAgICAgICAgICAgIGNhc2UgXCIvXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlSGV4RGlnaXRzKGhvd01hbnkpIHtcbiAgICAgICAgbGV0IGhleFN0cmluZyA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG93TWFueTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBoZXhDaGFyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgICAgICBpZiAoaGV4RGlnaXRQYXR0ZXJuLnRlc3QoaGV4Q2hhcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RpbmcgYSBIZXhEZWNpbWFsIGRpZ2l0c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhleFN0cmluZyArPSBoZXhDaGFyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoaGV4U3RyaW5nLCAxNik7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjaGFyQ29kZSB9O1xuICAgIH1cbiAgICBwZWVrQ2hhcihob3dNdWNoID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnB1dFt0aGlzLmlkeCArIGhvd011Y2hdO1xuICAgIH1cbiAgICBwb3BDaGFyKCkge1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRoaXMucGVla0NoYXIoMCk7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG5leHRDaGFyO1xuICAgIH1cbiAgICBjb25zdW1lQ2hhcihjaGFyKSB7XG4gICAgICAgIGlmIChjaGFyICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbnB1dFt0aGlzLmlkeF0gIT09IGNoYXIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0ZWQ6ICdcIiArXG4gICAgICAgICAgICAgICAgY2hhciArXG4gICAgICAgICAgICAgICAgXCInIGJ1dCBmb3VuZDogJ1wiICtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0W3RoaXMuaWR4XSArXG4gICAgICAgICAgICAgICAgXCInIGF0IG9mZnNldDogXCIgK1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pZHggPj0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVW5leHBlY3RlZCBlbmQgb2YgaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZHgrKztcbiAgICB9XG4gICAgbG9jKGJlZ2luKSB7XG4gICAgICAgIHJldHVybiB7IGJlZ2luOiBiZWdpbiwgZW5kOiB0aGlzLmlkeCB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2V4cC1wYXJzZXIuanMubWFwIiwiZXhwb3J0IGNsYXNzIEJhc2VSZWdFeHBWaXNpdG9yIHtcbiAgICB2aXNpdENoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbm9kZSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlW2tleV07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmZvckVhY2goKHN1YkNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KHN1YkNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFBhdHRlcm4obm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRmxhZ3NcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RmxhZ3Mobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRGlzanVuY3Rpb25cIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RGlzanVuY3Rpb24obm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiQWx0ZXJuYXRpdmVcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0QWx0ZXJuYXRpdmUobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU3RhcnRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0U3RhcnRBbmNob3Iobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiRW5kQW5jaG9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEVuZEFuY2hvcihub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJXb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0V29yZEJvdW5kYXJ5KG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk5vbldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXROb25Xb3JkQm91bmRhcnkobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdExvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJOZWdhdGl2ZUxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJDaGFyYWN0ZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0Q2hhcmFjdGVyKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlNldFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTZXQobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0R3JvdXAobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiR3JvdXBCYWNrUmVmZXJlbmNlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdEdyb3VwQmFja1JlZmVyZW5jZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJRdWFudGlmaWVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFF1YW50aWZpZXIobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH1cbiAgICB2aXNpdFBhdHRlcm4obm9kZSkgeyB9XG4gICAgdmlzaXRGbGFncyhub2RlKSB7IH1cbiAgICB2aXNpdERpc2p1bmN0aW9uKG5vZGUpIHsgfVxuICAgIHZpc2l0QWx0ZXJuYXRpdmUobm9kZSkgeyB9XG4gICAgLy8gQXNzZXJ0aW9uXG4gICAgdmlzaXRTdGFydEFuY2hvcihub2RlKSB7IH1cbiAgICB2aXNpdEVuZEFuY2hvcihub2RlKSB7IH1cbiAgICB2aXNpdFdvcmRCb3VuZGFyeShub2RlKSB7IH1cbiAgICB2aXNpdE5vbldvcmRCb3VuZGFyeShub2RlKSB7IH1cbiAgICB2aXNpdExvb2thaGVhZChub2RlKSB7IH1cbiAgICB2aXNpdE5lZ2F0aXZlTG9va2FoZWFkKG5vZGUpIHsgfVxuICAgIC8vIGF0b21zXG4gICAgdmlzaXRDaGFyYWN0ZXIobm9kZSkgeyB9XG4gICAgdmlzaXRTZXQobm9kZSkgeyB9XG4gICAgdmlzaXRHcm91cChub2RlKSB7IH1cbiAgICB2aXNpdEdyb3VwQmFja1JlZmVyZW5jZShub2RlKSB7IH1cbiAgICB2aXNpdFF1YW50aWZpZXIobm9kZSkgeyB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLXJlZ2V4cC12aXNpdG9yLmpzLm1hcCIsImV4cG9ydCB7IFJlZ0V4cFBhcnNlciB9IGZyb20gXCIuL3JlZ2V4cC1wYXJzZXIuanNcIjtcbmV4cG9ydCB7IEJhc2VSZWdFeHBWaXNpdG9yIH0gZnJvbSBcIi4vYmFzZS1yZWdleHAtdmlzaXRvci5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFJlZ0V4cFBhcnNlciwgQmFzZVJlZ0V4cFZpc2l0b3IgfSBmcm9tICdAY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0JztcbmV4cG9ydCBjb25zdCBORVdMSU5FX1JFR0VYUCA9IC9cXHI/XFxuL2dtO1xuY29uc3QgcmVnZXhwUGFyc2VyID0gbmV3IFJlZ0V4cFBhcnNlcigpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGluIGNoYXJnZSBvZiBoZXVyaXN0aWNhbGx5IGlkZW50aWZ5aW5nIHN0YXJ0L2VuZCB0b2tlbnMgb2YgdGVybWluYWxzLlxuICpcbiAqIFRoZSB3YXkgdGhpcyB3b3JrcyBpcyBieSBkb2luZyB0aGUgZm9sbG93aW5nOlxuICogMS4gVHJhdmVyc2UgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbiB0aGUgXCJzdGFydCBzdGF0ZVwiXG4gKiAyLiBBZGQgYW55IGVuY291bnRlcmVkIHNldHMvc2luZ2xlIGNoYXJhY3RlcnMgdG8gdGhlIFwic3RhcnQgcmVnZXhwXCJcbiAqIDMuIE9uY2Ugd2UgZW5jb3VudGVyIGFueSB2YXJpYWJsZS1sZW5ndGggY29udGVudCAoaS5lLiB3aXRoIHF1YW50aWZpZXJzIHN1Y2ggYXMgKy8/LyopLCB3ZSBlbnRlciB0aGUgXCJlbmQgc3RhdGVcIlxuICogNC4gSW4gdGhlIGVuZCBzdGF0ZSwgYW55IHNldHMvc2luZ2xlIGNoYXJhY3RlcnMgYXJlIGFkZGVkIHRvIGFuIFwiZW5kIHN0YWNrXCIuXG4gKiA1LiBJZiB3ZSByZS1lbmNvdW50ZXIgYW55IHZhcmlhYmxlLWxlbmd0aCBjb250ZW50IHdlIHJlc2V0IHRoZSBlbmQgc3RhY2tcbiAqIDYuIFdlIGNvbnRpbnVlIHZpc2l0aW5nIHRoZSByZWdleCB1bnRpbCB0aGUgZW5kLCByZXNldGluZyB0aGUgZW5kIHN0YWNrIGFuZCByZWJ1aWxkaW5nIGl0IGFzIG5lY2Vzc2FyeVxuICpcbiAqIEFmdGVyIHRyYXZlcnNpbmcgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhlIGBzdGFydFJlZ2V4cC9lbmRSZWdleHBgIHByb3BlcnRpZXMgYWxsb3cgYWNjZXNzIHRvIHRoZSBzdG9yZWQgc3RhcnQvZW5kIG9mIHRoZSB0ZXJtaW5hbFxuICovXG5jbGFzcyBUZXJtaW5hbFJlZ0V4cFZpc2l0b3IgZXh0ZW5kcyBCYXNlUmVnRXhwVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaXNTdGFydGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5tdWx0aWxpbmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGVuZFJlZ2V4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRSZWdleHBTdGFjay5qb2luKCcnKTtcbiAgICB9XG4gICAgcmVzZXQocmVnZXgpIHtcbiAgICAgICAgdGhpcy5tdWx0aWxpbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWdleCA9IHJlZ2V4O1xuICAgICAgICB0aGlzLnN0YXJ0UmVnZXhwID0gJyc7XG4gICAgICAgIHRoaXMuaXNTdGFydGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgdmlzaXRHcm91cChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnF1YW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWdleHBTdGFjayA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0Q2hhcmFjdGVyKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUobm9kZS52YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpbmUgJiYgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlUmVnRXhwKGNoYXIpO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWdleHBTdGFjay5wdXNoKGVzY2FwZWRDaGFyKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVnZXhwICs9IGVzY2FwZWRDaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZpc2l0U2V0KG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm11bHRpbGluZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5yZWdleC5zdWJzdHJpbmcobm9kZS5sb2MuYmVnaW4sIG5vZGUubG9jLmVuZCk7XG4gICAgICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc2V0KTtcbiAgICAgICAgICAgIHRoaXMubXVsdGlsaW5lID0gQm9vbGVhbignXFxuJy5tYXRjaChyZWdleCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnF1YW50aWZpZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWdleHBTdGFjayA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5yZWdleC5zdWJzdHJpbmcobm9kZS5sb2MuYmVnaW4sIG5vZGUubG9jLmVuZCk7XG4gICAgICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrLnB1c2goc2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhcnRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVnZXhwICs9IHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdENoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0dyb3VwJykge1xuICAgICAgICAgICAgLy8gSWdub3JlIGNoaWxkcmVuIG9mIGdyb3VwcyB3aXRoIHF1YW50aWZpZXIgKCsvKi8/KVxuICAgICAgICAgICAgLy8gVGhlc2UgZ3JvdXBzIGFyZSB1bnJlbGF0ZWQgdG8gc3RhcnQvZW5kIHRva2VucyBvZiB0ZXJtaW5hbHNcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChncm91cC5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgfVxufVxuY29uc3QgdmlzaXRvciA9IG5ldyBUZXJtaW5hbFJlZ0V4cFZpc2l0b3IoKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRUZXJtaW5hbFBhcnRzKHJlZ2V4cCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVnZXhwICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVnZXhwID0gcmVnZXhwLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICByZWdleHAgPSBgLyR7cmVnZXhwfS9gO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gcmVnZXhwUGFyc2VyLnBhdHRlcm4ocmVnZXhwKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhbHRlcm5hdGl2ZSBvZiBwYXR0ZXJuLnZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICB2aXNpdG9yLnJlc2V0KHJlZ2V4cCk7XG4gICAgICAgICAgICB2aXNpdG9yLnZpc2l0KGFsdGVybmF0aXZlKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiB2aXNpdG9yLnN0YXJ0UmVnZXhwLFxuICAgICAgICAgICAgICAgIGVuZDogdmlzaXRvci5lbmRSZWdleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnRzO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc011bHRpbGluZUNvbW1lbnQocmVnZXhwKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWdleHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZWdleHAgPSBuZXcgUmVnRXhwKHJlZ2V4cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVnZXhwID0gcmVnZXhwLnRvU3RyaW5nKCk7XG4gICAgICAgIHZpc2l0b3IucmVzZXQocmVnZXhwKTtcbiAgICAgICAgLy8gUGFyc2luZyB0aGUgcGF0dGVybiBtaWdodCBmYWlsIChzaW5jZSBpdCdzIHVzZXIgY29kZSlcbiAgICAgICAgdmlzaXRvci52aXNpdChyZWdleHBQYXJzZXIucGF0dGVybihyZWdleHApKTtcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IubXVsdGlsaW5lO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1doaXRlc3BhY2UodmFsdWUpIHtcbiAgICBjb25zdCByZWdleHAgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gbmV3IFJlZ0V4cCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICByZXR1cm4gcmVnZXhwLnRlc3QoJyAnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDYXNlSW5zZW5zaXRpdmVQYXR0ZXJuKGtleXdvcmQpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGtleXdvcmQsIGxldHRlciA9PiAvXFx3Ly50ZXN0KGxldHRlcikgPyBgWyR7bGV0dGVyLnRvTG93ZXJDYXNlKCl9JHtsZXR0ZXIudG9VcHBlckNhc2UoKX1dYCA6IGVzY2FwZVJlZ0V4cChsZXR0ZXIpKS5qb2luKCcnKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBpbnB1dCBoYXMgYSBwYXJ0aWFsIG1hdGNoIHdpdGggdGhlIHNwZWNpZmllZCByZWdleC5cbiAqIEBwYXJhbSByZWdleCBUaGUgcmVnZXggdG8gcGFydGlhbGx5IG1hdGNoIGFnYWluc3RcbiAqIEBwYXJhbSBpbnB1dCBUaGUgaW5wdXQgc3RyaW5nXG4gKiBAcmV0dXJucyBXaGV0aGVyIGFueSBtYXRjaCBleGlzdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsTWF0Y2hlcyhyZWdleCwgaW5wdXQpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0gcGFydGlhbFJlZ0V4cChyZWdleCk7XG4gICAgY29uc3QgbWF0Y2ggPSBpbnB1dC5tYXRjaChwYXJ0aWFsKTtcbiAgICByZXR1cm4gISFtYXRjaCAmJiBtYXRjaFswXS5sZW5ndGggPiAwO1xufVxuLyoqXG4gKiBCdWlsZHMgYSBwYXJ0aWFsIHJlZ2V4IGZyb20gdGhlIGlucHV0IHJlZ2V4LiBBIHBhcnRpYWwgcmVnZXggaXMgYWJsZSB0byBtYXRjaCBpbmNvbXBsZXRlIGlucHV0IHN0cmluZ3MuIEUuZy5cbiAqIGEgcGFydGlhbCByZWdleCBjb25zdHJ1Y3RlZCBmcm9tIGAvYWIvYCBpcyBhYmxlIHRvIG1hdGNoIHRoZSBzdHJpbmcgYGFgIHdpdGhvdXQgbmVlZGluZyBhIGZvbGxvd2luZyBgYmAgY2hhcmFjdGVyLiBIb3dldmVyIGl0IHdvbid0IG1hdGNoIGBiYCBhbG9uZS5cbiAqIEBwYXJhbSByZWdleCBUaGUgaW5wdXQgcmVnZXggdG8gYmUgY29udmVydGVkLlxuICogQHJldHVybnMgQSBwYXJ0aWFsIHJlZ2V4IGNvbnN0cnVjdGVkIGZyb20gdGhlIGlucHV0IHJlZ2V4LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbFJlZ0V4cChyZWdleCkge1xuICAgIGlmICh0eXBlb2YgcmVnZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCk7XG4gICAgfVxuICAgIGNvbnN0IHJlID0gcmVnZXgsIHNvdXJjZSA9IHJlZ2V4LnNvdXJjZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnLCB0bXA7XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZFJhdyhuYkNoYXJzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc291cmNlLnN1YnN0cihpLCBuYkNoYXJzKTtcbiAgICAgICAgICAgIGkgKz0gbmJDaGFycztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcHBlbmRPcHRpb25hbChuYkNoYXJzKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyg/OicgKyBzb3VyY2Uuc3Vic3RyKGksIG5iQ2hhcnMpICsgJ3wkKSc7XG4gICAgICAgICAgICBpICs9IG5iQ2hhcnM7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZVtpXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHNvdXJjZVtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmUudW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlW2kgKyAyXSA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbChzb3VyY2UuaW5kZXhPZignfScsIGkpIC0gaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoc291cmNlLmluZGV4T2YoJ30nLCBpKSAtIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2snOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKHNvdXJjZS5pbmRleE9mKCc+JywgaSkgLSBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgICAgICB0bXAgPSAvXFxbKD86XFxcXC58LikqP1xcXS9nO1xuICAgICAgICAgICAgICAgICAgICB0bXAubGFzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmV4ZWMoc291cmNlKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwodG1wWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgICAgIGNhc2UgJyQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcoMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgICAgICB0bXAgPSAvXFx7XFxkKyw/XFxkKlxcfS9nO1xuICAgICAgICAgICAgICAgICAgICB0bXAubGFzdEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG1wID0gdG1wLmV4ZWMoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kUmF3KHRtcFswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaSArIDFdID09PSAnPycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2kgKyAyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyg/Oic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHByb2Nlc3MoKSArICd8JCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcoPz0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBwcm9jZXNzKCkgKyAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNvdXJjZS5zdWJzdHIodG1wLCBpIC0gdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2kgKyAzXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNvdXJjZS5zdWJzdHIodG1wLCBpIC0gdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kUmF3KHNvdXJjZS5pbmRleE9mKCc+JywgaSkgLSBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHByb2Nlc3MoKSArICd8JCknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kUmF3KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHByb2Nlc3MoKSArICd8JCknO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUmVnRXhwKHByb2Nlc3MoKSwgcmVnZXguZmxhZ3MpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnZXhwLXV0aWxzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxLTIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgYXNzZXJ0VW5yZWFjaGFibGUgfSBmcm9tICcuLi91dGlscy9lcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgYXN0IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGlzQ29tcG9zaXRlQ3N0Tm9kZSB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IGdldENvbnRhaW5lck9mVHlwZSwgc3RyZWFtQWxsQ29udGVudHMgfSBmcm9tICcuL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBzdHJlYW1Dc3QgfSBmcm9tICcuL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVSZWdFeHAgfSBmcm9tICcuL3JlZ2V4cC11dGlscy5qcyc7XG4vKipcbiAqIFJldHVybnMgdGhlIGVudHJ5IHJ1bGUgb2YgdGhlIGdpdmVuIGdyYW1tYXIsIGlmIGFueS4gSWYgdGhlIGdyYW1tYXIgZmlsZSBkb2VzIG5vdCBjb250YWluIGFuIGVudHJ5IHJ1bGUsXG4gKiB0aGUgcmVzdWx0IGlzIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW50cnlSdWxlKGdyYW1tYXIpIHtcbiAgICByZXR1cm4gZ3JhbW1hci5ydWxlcy5maW5kKGUgPT4gYXN0LmlzUGFyc2VyUnVsZShlKSAmJiBlLmVudHJ5KTtcbn1cbi8qKlxuICogUmV0dXJucyBhbGwgaGlkZGVuIHRlcm1pbmFsIHJ1bGVzIG9mIHRoZSBnaXZlbiBncmFtbWFyLCBpZiBhbnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIaWRkZW5SdWxlcyhncmFtbWFyKSB7XG4gICAgcmV0dXJuIGdyYW1tYXIucnVsZXMuZmlsdGVyKChlKSA9PiBhc3QuaXNUZXJtaW5hbFJ1bGUoZSkgJiYgZS5oaWRkZW4pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFsbCBydWxlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gdGhlIHRvcG1vc3QgcnVsZXMgb2YgdGhlIHNwZWNpZmllZCBncmFtbWFyIChlbnRyeSBhbmQgaGlkZGVuIHRlcm1pbmFsIHJ1bGVzKS5cbiAqXG4gKiBAcGFyYW0gZ3JhbW1hciBUaGUgZ3JhbW1hciB0aGF0IGNvbnRhaW5zIGFsbCBydWxlc1xuICogQHBhcmFtIGFsbFRlcm1pbmFscyBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlIHRlcm1pbmFscyB0aGF0IGFyZSByZWZlcmVuY2VkIG9ubHkgYnkgb3RoZXIgdGVybWluYWxzXG4gKiBAcmV0dXJucyBBIGxpc3Qgb2YgcmVmZXJlbmNlZCBwYXJzZXIgYW5kIHRlcm1pbmFsIHJ1bGVzLiBJZiB0aGUgZ3JhbW1hciBjb250YWlucyBubyBlbnRyeSBydWxlLFxuICogICAgICB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYWxsIHJ1bGVzIG9mIHRoZSBzcGVjaWZpZWQgZ3JhbW1hci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFJlYWNoYWJsZVJ1bGVzKGdyYW1tYXIsIGFsbFRlcm1pbmFscykge1xuICAgIGNvbnN0IHJ1bGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBlbnRyeVJ1bGUgPSBnZXRFbnRyeVJ1bGUoZ3JhbW1hcik7XG4gICAgaWYgKCFlbnRyeVJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoZ3JhbW1hci5ydWxlcyk7XG4gICAgfVxuICAgIGNvbnN0IHRvcE1vc3RSdWxlcyA9IFtlbnRyeVJ1bGVdLmNvbmNhdChnZXRIaWRkZW5SdWxlcyhncmFtbWFyKSk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHRvcE1vc3RSdWxlcykge1xuICAgICAgICBydWxlRGZzKHJ1bGUsIHJ1bGVOYW1lcywgYWxsVGVybWluYWxzKTtcbiAgICB9XG4gICAgY29uc3QgcnVsZXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIGdyYW1tYXIucnVsZXMpIHtcbiAgICAgICAgaWYgKHJ1bGVOYW1lcy5oYXMocnVsZS5uYW1lKSB8fCAoYXN0LmlzVGVybWluYWxSdWxlKHJ1bGUpICYmIHJ1bGUuaGlkZGVuKSkge1xuICAgICAgICAgICAgcnVsZXMuYWRkKHJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydWxlcztcbn1cbmZ1bmN0aW9uIHJ1bGVEZnMocnVsZSwgdmlzaXRlZFNldCwgYWxsVGVybWluYWxzKSB7XG4gICAgdmlzaXRlZFNldC5hZGQocnVsZS5uYW1lKTtcbiAgICBzdHJlYW1BbGxDb250ZW50cyhydWxlKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBpZiAoYXN0LmlzUnVsZUNhbGwobm9kZSkgfHwgKGFsbFRlcm1pbmFscyAmJiBhc3QuaXNUZXJtaW5hbFJ1bGVDYWxsKG5vZGUpKSkge1xuICAgICAgICAgICAgY29uc3QgcmVmUnVsZSA9IG5vZGUucnVsZS5yZWY7XG4gICAgICAgICAgICBpZiAocmVmUnVsZSAmJiAhdmlzaXRlZFNldC5oYXMocmVmUnVsZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHJ1bGVEZnMocmVmUnVsZSwgdmlzaXRlZFNldCwgYWxsVGVybWluYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBncmFtbWFyIGV4cHJlc3Npb24gdXNlZCB0byBwYXJzZSBhIGNyb3NzLXJlZmVyZW5jZSAodXN1YWxseSBhIHJlZmVyZW5jZSB0byBhIHRlcm1pbmFsIHJ1bGUpLlxuICogQSBjcm9zcy1yZWZlcmVuY2UgY2FuIGRlY2xhcmUgdGhpcyBleHByZXNzaW9uIGV4cGxpY2l0bHkgaW4gdGhlIGZvcm0gYFtUeXBlIDogVGVybWluYWxdYCwgYnV0IGlmIGBUZXJtaW5hbGBcbiAqIGlzIG9taXR0ZWQsIHRoaXMgZnVuY3Rpb24gYXR0ZW1wdHMgdG8gaW5mZXIgaXQgZnJvbSB0aGUgbmFtZSBvZiB0aGUgcmVmZXJlbmNlZCBgVHlwZWAgKHVzaW5nIGBmaW5kTmFtZUFzc2lnbm1lbnRgKS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBncmFtbWFyIGV4cHJlc3Npb24gdXNlZCB0byBwYXJzZSB0aGUgZ2l2ZW4gY3Jvc3MtcmVmZXJlbmNlLCBvciBgdW5kZWZpbmVkYCBpZiBpdCBpcyBub3QgZGVjbGFyZWRcbiAqIGFuZCBjYW5ub3QgYmUgaW5mZXJyZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDcm9zc1JlZmVyZW5jZVRlcm1pbmFsKGNyb3NzUmVmKSB7XG4gICAgaWYgKGNyb3NzUmVmLnRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBjcm9zc1JlZi50ZXJtaW5hbDtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3Jvc3NSZWYudHlwZS5yZWYpIHtcbiAgICAgICAgY29uc3QgbmFtZUFzc2lnbWVudCA9IGZpbmROYW1lQXNzaWdubWVudChjcm9zc1JlZi50eXBlLnJlZik7XG4gICAgICAgIHJldHVybiBuYW1lQXNzaWdtZW50ID09PSBudWxsIHx8IG5hbWVBc3NpZ21lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hbWVBc3NpZ21lbnQudGVybWluYWw7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gdGVybWluYWwgcnVsZSByZXByZXNlbnRzIGEgY29tbWVudC4gVGhpcyBpcyB0cnVlIGlmIHRoZSBydWxlIGlzIG1hcmtlZFxuICogYXMgYGhpZGRlbmAgYW5kIGl0IGRvZXMgbm90IG1hdGNoIHdoaXRlIHNwYWNlLiBUaGlzIG1lYW5zIGV2ZXJ5IGhpZGRlbiB0b2tlbiAoaS5lLiBleGNsdWRlZCBmcm9tIHRoZSBBU1QpXG4gKiB0aGF0IGNvbnRhaW5zIHZpc2libGUgY2hhcmFjdGVycyBpcyBjb25zaWRlcmVkIGEgY29tbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbWVudFRlcm1pbmFsKHRlcm1pbmFsUnVsZSkge1xuICAgIHJldHVybiB0ZXJtaW5hbFJ1bGUuaGlkZGVuICYmICF0ZXJtaW5hbFJlZ2V4KHRlcm1pbmFsUnVsZSkudGVzdCgnICcpO1xufVxuLyoqXG4gKiBGaW5kIGFsbCBDU1Qgbm9kZXMgd2l0aGluIHRoZSBnaXZlbiBub2RlIHRoYXQgY29udHJpYnV0ZSB0byB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBub2RlIEEgQ1NUIG5vZGUgaW4gd2hpY2ggdG8gbG9vayBmb3IgcHJvcGVydHkgYXNzaWdubWVudHMuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IGFycmF5LlxuICogQHBhcmFtIHByb3BlcnR5IEEgcHJvcGVydHkgbmFtZSBvZiB0aGUgY29uc3RydWN0ZWQgQVNUIG5vZGUuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IGFycmF5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVzRm9yUHJvcGVydHkobm9kZSwgcHJvcGVydHkpIHtcbiAgICBpZiAoIW5vZGUgfHwgIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmROb2Rlc0ZvclByb3BlcnR5SW50ZXJuYWwobm9kZSwgcHJvcGVydHksIG5vZGUuYXN0Tm9kZSwgdHJ1ZSk7XG59XG4vKipcbiAqIEZpbmQgYSBzaW5nbGUgQ1NUIG5vZGUgd2l0aGluIHRoZSBnaXZlbiBub2RlIHRoYXQgY29udHJpYnV0ZXMgdG8gdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBIENTVCBub2RlIGluIHdoaWNoIHRvIGxvb2sgZm9yIHByb3BlcnR5IGFzc2lnbm1lbnRzLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBwcm9wZXJ0eSBBIHByb3BlcnR5IG5hbWUgb2YgdGhlIGNvbnN0cnVjdGVkIEFTVCBub2RlLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBpbmRleCBJZiBubyBpbmRleCBpcyBzcGVjaWZpZWQgb3IgdGhlIGluZGV4IGlzIGxlc3MgdGhhbiB6ZXJvLCB0aGUgZmlyc3QgZm91bmQgbm9kZSBpcyByZXR1cm5lZC4gSWYgdGhlXG4gKiAgICAgICAgc3BlY2lmaWVkIGluZGV4IGV4Y2VlZHMgdGhlIG51bWJlciBvZiBhc3NpZ25tZW50cyB0byB0aGUgcHJvcGVydHksIHRoZSBsYXN0IGZvdW5kIG5vZGUgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSxcbiAqICAgICAgICB0aGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZUZvclByb3BlcnR5KG5vZGUsIHByb3BlcnR5LCBpbmRleCkge1xuICAgIGlmICghbm9kZSB8fCAhcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBmaW5kTm9kZXNGb3JQcm9wZXJ0eUludGVybmFsKG5vZGUsIHByb3BlcnR5LCBub2RlLmFzdE5vZGUsIHRydWUpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbm9kZXMubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbaW5kZXhdO1xufVxuZnVuY3Rpb24gZmluZE5vZGVzRm9yUHJvcGVydHlJbnRlcm5hbChub2RlLCBwcm9wZXJ0eSwgZWxlbWVudCwgZmlyc3QpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG5vZGVGZWF0dXJlID0gZ2V0Q29udGFpbmVyT2ZUeXBlKG5vZGUuZ3JhbW1hclNvdXJjZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIGlmIChub2RlRmVhdHVyZSAmJiBub2RlRmVhdHVyZS5mZWF0dXJlID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpICYmIG5vZGUuYXN0Tm9kZSA9PT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbm9kZS5jb250ZW50LmZsYXRNYXAoZSA9PiBmaW5kTm9kZXNGb3JQcm9wZXJ0eUludGVybmFsKGUsIHByb3BlcnR5LCBlbGVtZW50LCBmYWxzZSkpO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG4vKipcbiAqIEZpbmQgYWxsIENTVCBub2RlcyB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb3JyZXNwb25kIHRvIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBIENTVCBub2RlIGluIHdoaWNoIHRvIGxvb2sgZm9yIGtleXdvcmRzLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBhbiBlbXB0eSBhcnJheS5cbiAqIEBwYXJhbSBrZXl3b3JkIEEga2V5d29yZCBhcyBzcGVjaWZpZWQgaW4gdGhlIGdyYW1tYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZXNGb3JLZXl3b3JkKG5vZGUsIGtleXdvcmQpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZmluZE5vZGVzRm9yS2V5d29yZEludGVybmFsKG5vZGUsIGtleXdvcmQsIG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5hc3ROb2RlKTtcbn1cbi8qKlxuICogRmluZCBhIHNpbmdsZSBDU1Qgbm9kZSB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb3JyZXNwb25kcyB0byB0aGUgc3BlY2lmaWVkIGtleXdvcmQuXG4gKlxuICogQHBhcmFtIG5vZGUgQSBDU1Qgbm9kZSBpbiB3aGljaCB0byBsb29rIGZvciBrZXl3b3Jkcy4gSWYgdGhpcyBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgYHVuZGVmaW5lZGAuXG4gKiBAcGFyYW0ga2V5d29yZCBBIGtleXdvcmQgYXMgc3BlY2lmaWVkIGluIHRoZSBncmFtbWFyLlxuICogQHBhcmFtIGluZGV4IElmIG5vIGluZGV4IGlzIHNwZWNpZmllZCBvciB0aGUgaW5kZXggaXMgbGVzcyB0aGFuIHplcm8sIHRoZSBmaXJzdCBmb3VuZCBub2RlIGlzIHJldHVybmVkLiBJZiB0aGVcbiAqICAgICAgICBzcGVjaWZpZWQgaW5kZXggZXhjZWVkcyB0aGUgbnVtYmVyIG9mIGtleXdvcmQgb2NjdXJyZW5jZXMsIHRoZSBsYXN0IGZvdW5kIG5vZGUgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSxcbiAqICAgICAgICB0aGUgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggaXMgcmV0dXJuZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZUZvcktleXdvcmQobm9kZSwga2V5d29yZCwgaW5kZXgpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBmaW5kTm9kZXNGb3JLZXl3b3JkSW50ZXJuYWwobm9kZSwga2V5d29yZCwgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmFzdE5vZGUpO1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbm9kZXMubGVuZ3RoIC0gMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXNbaW5kZXhdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2Rlc0ZvcktleXdvcmRJbnRlcm5hbChub2RlLCBrZXl3b3JkLCBlbGVtZW50KSB7XG4gICAgaWYgKG5vZGUuYXN0Tm9kZSAhPT0gZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChhc3QuaXNLZXl3b3JkKG5vZGUuZ3JhbW1hclNvdXJjZSkgJiYgbm9kZS5ncmFtbWFyU291cmNlLnZhbHVlID09PSBrZXl3b3JkKSB7XG4gICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgfVxuICAgIGNvbnN0IHRyZWVJdGVyYXRvciA9IHN0cmVhbUNzdChub2RlKS5pdGVyYXRvcigpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3Qga2V5d29yZE5vZGVzID0gW107XG4gICAgZG8ge1xuICAgICAgICByZXN1bHQgPSB0cmVlSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE5vZGUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlLmFzdE5vZGUgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXN0LmlzS2V5d29yZChjaGlsZE5vZGUuZ3JhbW1hclNvdXJjZSkgJiYgY2hpbGROb2RlLmdyYW1tYXJTb3VyY2UudmFsdWUgPT09IGtleXdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZE5vZGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmVlSXRlcmF0b3IucHJ1bmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKCFyZXN1bHQuZG9uZSk7XG4gICAgcmV0dXJuIGtleXdvcmROb2Rlcztcbn1cbi8qKlxuICogSWYgdGhlIGdpdmVuIENTVCBub2RlIHdhcyBwYXJzZWQgaW4gdGhlIGNvbnRleHQgb2YgYSBwcm9wZXJ0eSBhc3NpZ25tZW50LCB0aGUgcmVzcGVjdGl2ZSBgQXNzaWdubWVudGAgZ3JhbW1hclxuICogbm9kZSBpcyByZXR1cm5lZC4gSWYgbm8gYXNzaWdubWVudCBpcyBmb3VuZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gY3N0Tm9kZSBBIENTVCBub2RlIGZvciB3aGljaCB0byBmaW5kIGEgcHJvcGVydHkgYXNzaWdubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBc3NpZ25tZW50KGNzdE5vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXN0Tm9kZSA9IGNzdE5vZGUuYXN0Tm9kZTtcbiAgICAvLyBPbmx5IHNlYXJjaCB1bnRpbCB0aGUgYXN0IG5vZGUgb2YgdGhlIHBhcmVudCBjc3Qgbm9kZSBpcyBubyBsb25nZXIgdGhlIG9yaWdpbmFsIGFzdCBub2RlXG4gICAgLy8gVGhpcyB3b3VsZCBtYWtlIHVzIGp1bXAgdG8gYSBwcmVjZWRpbmcgcnVsZSBjYWxsLCB3aGljaCBjb250YWlucyBvbmx5IHVucmVsYXRlZCBhc3NpZ25tZW50c1xuICAgIHdoaWxlIChhc3ROb2RlID09PSAoKF9hID0gY3N0Tm9kZS5jb250YWluZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hc3ROb2RlKSkge1xuICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0gZ2V0Q29udGFpbmVyT2ZUeXBlKGNzdE5vZGUuZ3JhbW1hclNvdXJjZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYXNzaWdubWVudDtcbiAgICAgICAgfVxuICAgICAgICBjc3ROb2RlID0gY3N0Tm9kZS5jb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEZpbmQgYW4gYXNzaWdubWVudCB0byB0aGUgYG5hbWVgIHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gZ3JhbW1hciB0eXBlLiBUaGlzIHJlcXVpcmVzIHRoZSBgdHlwZWAgdG8gYmUgaW5mZXJyZWRcbiAqIGZyb20gYSBwYXJzZXIgcnVsZSwgYW5kIHRoYXQgcnVsZSBtdXN0IGNvbnRhaW4gYW4gYXNzaWdubWVudCB0byB0aGUgYG5hbWVgIHByb3BlcnR5LiBJbiBhbGwgb3RoZXIgY2FzZXMsXG4gKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTmFtZUFzc2lnbm1lbnQodHlwZSkge1xuICAgIGxldCBzdGFydE5vZGUgPSB0eXBlO1xuICAgIGlmIChhc3QuaXNJbmZlcnJlZFR5cGUoc3RhcnROb2RlKSkge1xuICAgICAgICAvLyBmb3IgaW5mZXJyZWQgdHlwZXMsIHRoZSBsb2NhdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZm9yIHRoZSBuYW1lLWFzc2lnbm1lbnQgaXMgZGlmZmVyZW50XG4gICAgICAgIGlmIChhc3QuaXNBY3Rpb24oc3RhcnROb2RlLiRjb250YWluZXIpKSB7XG4gICAgICAgICAgICAvLyBhIHR5cGUgd2hpY2ggaXMgZXhwbGljaXRseSBpbmZlcnJlZCBieSBhbiBhY3Rpb246IGludmVzdGlnYXRlIHRoZSBzaWJibGluZyBvZiB0aGUgQWN0aW9uIG5vZGUsIGkuZS4gc3RhcnQgc2VhcmNoaW5nIGF0IHRoZSBBY3Rpb24ncyBwYXJlbnRcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS4kY29udGFpbmVyLiRjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzUGFyc2VyUnVsZShzdGFydE5vZGUuJGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIC8vIGludmVzdGlnYXRlIHRoZSBwYXJzZXIgcnVsZSB3aXRoIHRoZSBleHBsaWNpdGx5IGluZmVycmVkIHR5cGVcbiAgICAgICAgICAgIHN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZS4kY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoc3RhcnROb2RlLiRjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbCh0eXBlLCBzdGFydE5vZGUsIG5ldyBNYXAoKSk7XG59XG5mdW5jdGlvbiBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbCh0eXBlLCBzdGFydE5vZGUsIGNhY2hlKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIHRoZSBjYWNoZSBpcyBvbmx5IHJlcXVpcmVkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAgICBmdW5jdGlvbiBnbyhub2RlLCByZWZUeXBlKSB7XG4gICAgICAgIGxldCBjaGlsZEFzc2lnbm1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBhcmVudEFzc2lnbm1lbnQgPSBnZXRDb250YWluZXJPZlR5cGUobm9kZSwgYXN0LmlzQXNzaWdubWVudCk7XG4gICAgICAgIC8vIE5vIHBhcmVudCBhc3NpZ25tZW50IGltcGxpZXMgdW5hc3NpZ25lZCBydWxlIGNhbGxcbiAgICAgICAgaWYgKCFwYXJlbnRBc3NpZ25tZW50KSB7XG4gICAgICAgICAgICBjaGlsZEFzc2lnbm1lbnQgPSBmaW5kTmFtZUFzc2lnbm1lbnRJbnRlcm5hbChyZWZUeXBlLCByZWZUeXBlLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FjaGUuc2V0KHR5cGUsIGNoaWxkQXNzaWdubWVudCk7XG4gICAgICAgIHJldHVybiBjaGlsZEFzc2lnbm1lbnQ7XG4gICAgfVxuICAgIGlmIChjYWNoZS5oYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmdldCh0eXBlKTtcbiAgICB9XG4gICAgY2FjaGUuc2V0KHR5cGUsIHVuZGVmaW5lZCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHN0cmVhbUFsbENvbnRlbnRzKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgaWYgKGFzdC5pc0Fzc2lnbm1lbnQobm9kZSkgJiYgbm9kZS5mZWF0dXJlLnRvTG93ZXJDYXNlKCkgPT09ICduYW1lJykge1xuICAgICAgICAgICAgY2FjaGUuc2V0KHR5cGUsIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzUnVsZUNhbGwobm9kZSkgJiYgYXN0LmlzUGFyc2VyUnVsZShub2RlLnJ1bGUucmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdvKG5vZGUsIG5vZGUucnVsZS5yZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5pc1NpbXBsZVR5cGUobm9kZSkgJiYgKChfYSA9IG5vZGUudHlwZVJlZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiBnbyhub2RlLCBub2RlLnR5cGVSZWYucmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvbkF0RWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC4kY29udGFpbmVyO1xuICAgIGlmIChhc3QuaXNHcm91cChwYXJlbnQpKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gcGFyZW50LmVsZW1lbnRzO1xuICAgICAgICBjb25zdCBpbmRleCA9IGVsZW1lbnRzLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBpZiAoYXN0LmlzQWN0aW9uKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb24gPSBzdHJlYW1BbGxDb250ZW50cyhlbGVtZW50c1tpXSkuZmluZChhc3QuaXNBY3Rpb24pO1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzdC5pc0Fic3RyYWN0RWxlbWVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBnZXRBY3Rpb25BdEVsZW1lbnQocGFyZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzT3B0aW9uYWxDYXJkaW5hbGl0eShjYXJkaW5hbGl0eSwgZWxlbWVudCkge1xuICAgIHJldHVybiBjYXJkaW5hbGl0eSA9PT0gJz8nIHx8IGNhcmRpbmFsaXR5ID09PSAnKicgfHwgKGFzdC5pc0dyb3VwKGVsZW1lbnQpICYmIEJvb2xlYW4oZWxlbWVudC5ndWFyZENvbmRpdGlvbikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlDYXJkaW5hbGl0eShjYXJkaW5hbGl0eSkge1xuICAgIHJldHVybiBjYXJkaW5hbGl0eSA9PT0gJyonIHx8IGNhcmRpbmFsaXR5ID09PSAnKyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheU9wZXJhdG9yKG9wZXJhdG9yKSB7XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSAnKz0nO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHBhcnNlciBydWxlIGlzIGEgX2RhdGEgdHlwZSBydWxlXywgbWVhbmluZyB0aGF0IGl0IGhhcyBhXG4gKiBwcmltaXRpdmUgcmV0dXJuIHR5cGUgbGlrZSBgbnVtYmVyYCwgYGJvb2xlYW5gLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFUeXBlUnVsZShydWxlKSB7XG4gICAgcmV0dXJuIGlzRGF0YVR5cGVSdWxlSW50ZXJuYWwocnVsZSwgbmV3IFNldCgpKTtcbn1cbmZ1bmN0aW9uIGlzRGF0YVR5cGVSdWxlSW50ZXJuYWwocnVsZSwgdmlzaXRlZCkge1xuICAgIGlmICh2aXNpdGVkLmhhcyhydWxlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKHJ1bGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3RyZWFtQWxsQ29udGVudHMocnVsZSkpIHtcbiAgICAgICAgaWYgKGFzdC5pc1J1bGVDYWxsKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUucnVsZS5yZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBSdWxlQ2FsbCB0byB1bnJlc29sdmVkIHJ1bGUuIERvbid0IGFzc3VtZSBgcnVsZWAgaXMgYSBEYXRhVHlwZSBydWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3QuaXNQYXJzZXJSdWxlKG5vZGUucnVsZS5yZWYpICYmICFpc0RhdGFUeXBlUnVsZUludGVybmFsKG5vZGUucnVsZS5yZWYsIHZpc2l0ZWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5pc0Fzc2lnbm1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuaXNBY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQm9vbGVhbihydWxlLmRlZmluaXRpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVR5cGUodHlwZSkge1xuICAgIHJldHVybiBpc0RhdGFUeXBlSW50ZXJuYWwodHlwZS50eXBlLCBuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gaXNEYXRhVHlwZUludGVybmFsKHR5cGUsIHZpc2l0ZWQpIHtcbiAgICBpZiAodmlzaXRlZC5oYXModHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXNpdGVkLmFkZCh0eXBlKTtcbiAgICB9XG4gICAgaWYgKGFzdC5pc0FycmF5VHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1JlZmVyZW5jZVR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNVbmlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUudHlwZXMuZXZlcnkoZSA9PiBpc0RhdGFUeXBlSW50ZXJuYWwoZSwgdmlzaXRlZCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNTaW1wbGVUeXBlKHR5cGUpKSB7XG4gICAgICAgIGlmICh0eXBlLnByaW1pdGl2ZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS5zdHJpbmdUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUudHlwZVJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0eXBlLnR5cGVSZWYucmVmO1xuICAgICAgICAgICAgaWYgKGFzdC5pc1R5cGUocmVmKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RhdGFUeXBlSW50ZXJuYWwocmVmLnR5cGUsIHZpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSkge1xuICAgIGlmIChydWxlLmluZmVycmVkVHlwZSkge1xuICAgICAgICByZXR1cm4gcnVsZS5pbmZlcnJlZFR5cGUubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocnVsZS5kYXRhVHlwZSkge1xuICAgICAgICByZXR1cm4gcnVsZS5kYXRhVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocnVsZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgIGNvbnN0IHJlZlR5cGUgPSBydWxlLnJldHVyblR5cGUucmVmO1xuICAgICAgICBpZiAocmVmVHlwZSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBjaGVjayBBY3Rpb24gYXMgcmV0dXJuIHR5cGVcbiAgICAgICAgICAgIGlmIChhc3QuaXNQYXJzZXJSdWxlKHJlZlR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZlR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFzdC5pc0ludGVyZmFjZShyZWZUeXBlKSB8fCBhc3QuaXNUeXBlKHJlZlR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZlR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFR5cGVOYW1lKHR5cGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGFzdC5pc1BhcnNlclJ1bGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0YVR5cGVSdWxlKHR5cGUpID8gdHlwZS5uYW1lIDogKF9hID0gZ2V0RXhwbGljaXRSdWxlVHlwZSh0eXBlKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNJbnRlcmZhY2UodHlwZSkgfHwgYXN0LmlzVHlwZSh0eXBlKSB8fCBhc3QuaXNSZXR1cm5UeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0FjdGlvbih0eXBlKSkge1xuICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0QWN0aW9uVHlwZSh0eXBlKTtcbiAgICAgICAgaWYgKGFjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb25UeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0luZmVycmVkVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHlwZS5uYW1lO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgbmFtZSBvZiBVbmtub3duIFR5cGUnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY3Rpb25UeXBlKGFjdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYWN0aW9uLmluZmVycmVkVHlwZSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmluZmVycmVkVHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmICgoX2EgPSBhY3Rpb24udHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZikge1xuICAgICAgICByZXR1cm4gZ2V0VHlwZU5hbWUoYWN0aW9uLnR5cGUucmVmKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gbm90IGluZmVycmluZyBhbmQgbm90IHJlZmVyZW5jaW5nIGEgdmFsaWQgdHlwZVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVUeXBlKHJ1bGUpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoYXN0LmlzVGVybWluYWxSdWxlKHJ1bGUpKSB7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBydWxlLnR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnc3RyaW5nJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc0RhdGFUeXBlUnVsZShydWxlKSA/IHJ1bGUubmFtZSA6IChfYyA9IGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHJ1bGUubmFtZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdGVybWluYWxSZWdleCh0ZXJtaW5hbFJ1bGUpIHtcbiAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgczogZmFsc2UsXG4gICAgICAgIGk6IGZhbHNlLFxuICAgICAgICB1OiBmYWxzZVxuICAgIH07XG4gICAgY29uc3Qgc291cmNlID0gYWJzdHJhY3RFbGVtZW50VG9SZWdleCh0ZXJtaW5hbFJ1bGUuZGVmaW5pdGlvbiwgZmxhZ3MpO1xuICAgIGNvbnN0IGZsYWdUZXh0ID0gT2JqZWN0LmVudHJpZXMoZmxhZ3MpLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSkubWFwKChbbmFtZV0pID0+IG5hbWUpLmpvaW4oJycpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgZmxhZ1RleHQpO1xufVxuLy8gVXNpbmcgW1xcc1xcU10qIGFsbG93cyB0byBtYXRjaCBldmVyeXRoaW5nLCBjb21wYXJlZCB0byAuIHdoaWNoIGRvZXNuJ3QgbWF0Y2ggbGluZSB0ZXJtaW5hdG9yc1xuY29uc3QgV0lMRENBUkQgPSAvW1xcc1xcU10vLnNvdXJjZTtcbmZ1bmN0aW9uIGFic3RyYWN0RWxlbWVudFRvUmVnZXgoZWxlbWVudCwgZmxhZ3MpIHtcbiAgICBpZiAoYXN0LmlzVGVybWluYWxBbHRlcm5hdGl2ZXMoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRlcm1pbmFsQWx0ZXJuYXRpdmVzVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzVGVybWluYWxHcm91cChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdGVybWluYWxHcm91cFRvUmVnZXgoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0NoYXJhY3RlclJhbmdlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJSYW5nZVRvUmVnZXgoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1Rlcm1pbmFsUnVsZUNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IGVsZW1lbnQucnVsZS5yZWY7XG4gICAgICAgIGlmICghcnVsZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJ1bGUgcmVmZXJlbmNlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYWJzdHJhY3RFbGVtZW50VG9SZWdleChydWxlLmRlZmluaXRpb24pLCB7XG4gICAgICAgICAgICBjYXJkaW5hbGl0eTogZWxlbWVudC5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogZWxlbWVudC5sb29rYWhlYWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc05lZ2F0ZWRUb2tlbihlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gbmVnYXRlVG9rZW5Ub1JlZ2V4KGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNVbnRpbFRva2VuKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB1bnRpbFRva2VuVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzUmVnZXhUb2tlbihlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBsYXN0U2xhc2ggPSBlbGVtZW50LnJlZ2V4Lmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IGVsZW1lbnQucmVnZXguc3Vic3RyaW5nKDEsIGxhc3RTbGFzaCk7XG4gICAgICAgIGNvbnN0IHJlZ2V4RmxhZ3MgPSBlbGVtZW50LnJlZ2V4LnN1YnN0cmluZyhsYXN0U2xhc2ggKyAxKTtcbiAgICAgICAgaWYgKGZsYWdzKSB7XG4gICAgICAgICAgICBmbGFncy5pID0gcmVnZXhGbGFncy5pbmNsdWRlcygnaScpO1xuICAgICAgICAgICAgZmxhZ3MucyA9IHJlZ2V4RmxhZ3MuaW5jbHVkZXMoJ3MnKTtcbiAgICAgICAgICAgIGZsYWdzLnUgPSByZWdleEZsYWdzLmluY2x1ZGVzKCd1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShzb3VyY2UsIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiBlbGVtZW50LmNhcmRpbmFsaXR5LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBlbGVtZW50Lmxvb2thaGVhZCxcbiAgICAgICAgICAgIHdyYXA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNXaWxkY2FyZChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KFdJTERDQVJELCB7XG4gICAgICAgICAgICBjYXJkaW5hbGl0eTogZWxlbWVudC5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogZWxlbWVudC5sb29rYWhlYWRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVybWluYWwgZWxlbWVudDogJHtlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuJHR5cGV9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdGVybWluYWxBbHRlcm5hdGl2ZXNUb1JlZ2V4KGFsdGVybmF0aXZlcykge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYWx0ZXJuYXRpdmVzLmVsZW1lbnRzLm1hcChlID0+IGFic3RyYWN0RWxlbWVudFRvUmVnZXgoZSkpLmpvaW4oJ3wnKSwge1xuICAgICAgICBjYXJkaW5hbGl0eTogYWx0ZXJuYXRpdmVzLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IGFsdGVybmF0aXZlcy5sb29rYWhlYWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRlcm1pbmFsR3JvdXBUb1JlZ2V4KGdyb3VwKSB7XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShncm91cC5lbGVtZW50cy5tYXAoZSA9PiBhYnN0cmFjdEVsZW1lbnRUb1JlZ2V4KGUpKS5qb2luKCcnKSwge1xuICAgICAgICBjYXJkaW5hbGl0eTogZ3JvdXAuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogZ3JvdXAubG9va2FoZWFkXG4gICAgfSk7XG59XG5mdW5jdGlvbiB1bnRpbFRva2VuVG9SZWdleCh1bnRpbCkge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYCR7V0lMRENBUkR9Kj8ke2Fic3RyYWN0RWxlbWVudFRvUmVnZXgodW50aWwudGVybWluYWwpfWAsIHtcbiAgICAgICAgY2FyZGluYWxpdHk6IHVudGlsLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IHVudGlsLmxvb2thaGVhZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbmVnYXRlVG9rZW5Ub1JlZ2V4KG5lZ2F0ZSkge1xuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYCg/ISR7YWJzdHJhY3RFbGVtZW50VG9SZWdleChuZWdhdGUudGVybWluYWwpfSkke1dJTERDQVJEfSo/YCwge1xuICAgICAgICBjYXJkaW5hbGl0eTogbmVnYXRlLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IG5lZ2F0ZS5sb29rYWhlYWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNoYXJhY3RlclJhbmdlVG9SZWdleChyYW5nZSkge1xuICAgIGlmIChyYW5nZS5yaWdodCkge1xuICAgICAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KGBbJHtrZXl3b3JkVG9SZWdleChyYW5nZS5sZWZ0KX0tJHtrZXl3b3JkVG9SZWdleChyYW5nZS5yaWdodCl9XWAsIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiByYW5nZS5jYXJkaW5hbGl0eSxcbiAgICAgICAgICAgIGxvb2thaGVhZDogcmFuZ2UubG9va2FoZWFkLFxuICAgICAgICAgICAgd3JhcDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoa2V5d29yZFRvUmVnZXgocmFuZ2UubGVmdCksIHtcbiAgICAgICAgY2FyZGluYWxpdHk6IHJhbmdlLmNhcmRpbmFsaXR5LFxuICAgICAgICBsb29rYWhlYWQ6IHJhbmdlLmxvb2thaGVhZCxcbiAgICAgICAgd3JhcDogZmFsc2VcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGtleXdvcmRUb1JlZ2V4KGtleXdvcmQpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVnRXhwKGtleXdvcmQudmFsdWUpO1xufVxuZnVuY3Rpb24gd2l0aENhcmRpbmFsaXR5KHJlZ2V4LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRpb25zLndyYXAgIT09IGZhbHNlIHx8IG9wdGlvbnMubG9va2FoZWFkKSB7XG4gICAgICAgIHJlZ2V4ID0gYCgkeyhfYSA9IG9wdGlvbnMubG9va2FoZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJ30ke3JlZ2V4fSlgO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jYXJkaW5hbGl0eSkge1xuICAgICAgICByZXR1cm4gYCR7cmVnZXh9JHtvcHRpb25zLmNhcmRpbmFsaXR5fWA7XG4gICAgfVxuICAgIHJldHVybiByZWdleDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYW1tYXItdXRpbHMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgRGVmYXVsdE5hbWVSZWdleHAgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNDb21tZW50VGVybWluYWwsIHRlcm1pbmFsUmVnZXggfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGlzTXVsdGlsaW5lQ29tbWVudCB9IGZyb20gJy4uL3V0aWxzL3JlZ2V4cC11dGlscy5qcyc7XG5pbXBvcnQgeyBpc1Rlcm1pbmFsUnVsZSB9IGZyb20gJy4vZ2VuZXJhdGVkL2FzdC5qcyc7XG4vKipcbiAqIENyZWF0ZSB0aGUgZGVmYXVsdCBncmFtbWFyIGNvbmZpZ3VyYXRpb24gKHVzZWQgYnkgYGNyZWF0ZURlZmF1bHRNb2R1bGVgKS4gVGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBhXG4gKiBsYW5ndWFnZS1zcGVjaWZpYyBtb2R1bGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVHcmFtbWFyQ29uZmlnKHNlcnZpY2VzKSB7XG4gICAgY29uc3QgcnVsZXMgPSBbXTtcbiAgICBjb25zdCBncmFtbWFyID0gc2VydmljZXMuR3JhbW1hcjtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JhbW1hci5ydWxlcykge1xuICAgICAgICBpZiAoaXNUZXJtaW5hbFJ1bGUocnVsZSkgJiYgaXNDb21tZW50VGVybWluYWwocnVsZSkgJiYgaXNNdWx0aWxpbmVDb21tZW50KHRlcm1pbmFsUmVnZXgocnVsZSkpKSB7XG4gICAgICAgICAgICBydWxlcy5wdXNoKHJ1bGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbXVsdGlsaW5lQ29tbWVudFJ1bGVzOiBydWxlcyxcbiAgICAgICAgbmFtZVJlZ2V4cDogRGVmYXVsdE5hbWVSZWdleHBcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhbW1hci1jb25maWcuanMubWFwIiwiLy8gYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvYmxvYi9iOTdjMGQyZDQ4N2U4YzUwNzZlOGJkODk3ZTBkY2Q0NjIyZDMxODQ2L3NyYy91dGlsLmpzI0wyMDEtTDIxNlxuZXhwb3J0IGZ1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXModG9CZWNvbWVGYXN0KSB7XG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLy8gSWYgb3VyIG9iamVjdCBpcyB1c2VkIGFzIGEgY29uc3RydWN0b3IsIGl0IHdvdWxkIHJlY2VpdmVcbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gdG9CZWNvbWVGYXN0O1xuICAgIGNvbnN0IGZha2VJbnN0YW5jZSA9IG5ldyBGYWtlQ29uc3RydWN0b3IoKTtcbiAgICBmdW5jdGlvbiBmYWtlQWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZha2VJbnN0YW5jZS5iYXI7XG4gICAgfVxuICAgIC8vIGhlbHAgVjggdW5kZXJzdGFuZCB0aGlzIGlzIGEgXCJyZWFsXCIgcHJvdG90eXBlIGJ5IGFjdHVhbGx5IHVzaW5nXG4gICAgLy8gdGhlIGZha2UgaW5zdGFuY2UuXG4gICAgZmFrZUFjY2VzcygpO1xuICAgIGZha2VBY2Nlc3MoKTtcbiAgICAvLyBBbHdheXMgdHJ1ZSBjb25kaXRpb24gdG8gc3VwcHJlc3MgdGhlIEZpcmVmb3ggd2FybmluZyBvZiB1bnJlYWNoYWJsZVxuICAgIC8vIGNvZGUgYWZ0ZXIgYSByZXR1cm4gc3RhdGVtZW50LlxuICAgIGlmICgxKVxuICAgICAgICByZXR1cm4gdG9CZWNvbWVGYXN0O1xuICAgIC8vIEV2YWwgcHJldmVudHMgb3B0aW1pemF0aW9uIG9mIHRoaXMgbWV0aG9kIChldmVuIHRob3VnaCB0aGlzIGlzIGRlYWQgY29kZSlcbiAgICAvLyAtIGh0dHBzOi8vZXNidWlsZC5naXRodWIuaW8vY29udGVudC10eXBlcy8jZGlyZWN0LWV2YWxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICgwLCBldmFsKSh0b0JlY29tZUZhc3QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tZmFzdC1wcm9wZXJ0aWVzLmpzLm1hcCIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBiZWdpbm5pbmcuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kcm9wKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBbMiwgM11cbiAqXG4gKiBfLmRyb3AoWzEsIDIsIDNdLCAyKTtcbiAqIC8vID0+IFszXVxuICpcbiAqIF8uZHJvcChbMSwgMiwgM10sIDUpO1xuICogLy8gPT4gW11cbiAqXG4gKiBfLmRyb3AoWzEsIDIsIDNdLCAwKTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3A7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbkluXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbjtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVBpY2tCeSBmcm9tICcuL19iYXNlUGlja0J5LmpzJztcbmltcG9ydCBnZXRBbGxLZXlzSW4gZnJvbSAnLi9fZ2V0QWxsS2V5c0luLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIFtwcm9wXTtcbiAgfSk7XG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpO1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGlja0J5O1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzUmVnRXhwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNSZWdFeHAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gcmVnZXhwVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNSZWdFeHA7XG4iLCJpbXBvcnQgYmFzZUlzUmVnRXhwIGZyb20gJy4vX2Jhc2VJc1JlZ0V4cC5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgUmVnRXhwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG5leHBvcnQgZGVmYXVsdCBpc1JlZ0V4cDtcbiIsImltcG9ydCB7IGFzc2lnbiwgZm9yRWFjaCwgaXNSZWdFeHAsIGlzU3RyaW5nLCBtYXAsIHBpY2tCeSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbi8vIFRPRE86IGR1cGxpY2F0ZWQgY29kZSB0byBhdm9pZCBleHRyYWN0aW5nIGFub3RoZXIgc3ViLXBhY2thZ2UgLS0gaG93IHRvIGF2b2lkP1xuZnVuY3Rpb24gdG9rZW5MYWJlbCh0b2tUeXBlKSB7XG4gICAgaWYgKGhhc1Rva2VuTGFiZWwodG9rVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUuTEFCRUw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5uYW1lO1xuICAgIH1cbn1cbi8vIFRPRE86IGR1cGxpY2F0ZWQgY29kZSB0byBhdm9pZCBleHRyYWN0aW5nIGFub3RoZXIgc3ViLXBhY2thZ2UgLS0gaG93IHRvIGF2b2lkP1xuZnVuY3Rpb24gaGFzVG9rZW5MYWJlbChvYmopIHtcbiAgICByZXR1cm4gaXNTdHJpbmcob2JqLkxBQkVMKSAmJiBvYmouTEFCRUwgIT09IFwiXCI7XG59XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb247XG4gICAgfVxuICAgIHNldCBkZWZpbml0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoX2RlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IF9kZWZpbml0aW9uO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgICAgICBmb3JFYWNoKHRoaXMuZGVmaW5pdGlvbiwgKHByb2QpID0+IHtcbiAgICAgICAgICAgIHByb2QuYWNjZXB0KHZpc2l0b3IpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm9uVGVybWluYWwgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoW10pO1xuICAgICAgICB0aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbih0aGlzLCBwaWNrQnkob3B0aW9ucywgKHYpID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbiAgICBzZXQgZGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIC8vIGltbXV0YWJsZVxuICAgIH1cbiAgICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmZXJlbmNlZFJ1bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmZXJlbmNlZFJ1bGUuZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXQodGhpcyk7XG4gICAgICAgIC8vIGRvbid0IHZpc2l0IGNoaWxkcmVuIG9mIGEgcmVmZXJlbmNlLCB3ZSB3aWxsIGdldCBjeWNsaWMgaW5maW5pdGUgbG9vcHMgaWYgd2UgZG8gc29cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVsZSBleHRlbmRzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLm9yZ1RleHQgPSBcIlwiO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWx0ZXJuYXRpdmUgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZ25vcmVBbWJpZ3VpdGllcyA9IGZhbHNlO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3B0aW9uIGV4dGVuZHMgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlcGV0aXRpb25NYW5kYXRvcnkgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVwZXRpdGlvbiBleHRlbmRzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbih0aGlzLCBwaWNrQnkob3B0aW9ucywgKHYpID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciBleHRlbmRzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbih0aGlzLCBwaWNrQnkob3B0aW9ucywgKHYpID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbHRlcm5hdGlvbiBleHRlbmRzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH1cbiAgICBzZXQgZGVmaW5pdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICB0aGlzLmlnbm9yZUFtYmlndWl0aWVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUHJlZGljYXRlcyA9IGZhbHNlO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVGVybWluYWwge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCh0aGlzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplR3JhbW1hcih0b3BSdWxlcykge1xuICAgIHJldHVybiBtYXAodG9wUnVsZXMsIHNlcmlhbGl6ZVByb2R1Y3Rpb24pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZVByb2R1Y3Rpb24obm9kZSkge1xuICAgIGZ1bmN0aW9uIGNvbnZlcnREZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG1hcChkZWZpbml0aW9uLCBzZXJpYWxpemVQcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWROb25UZXJtaW5hbCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiTm9uVGVybWluYWxcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubm9uVGVybWluYWxOYW1lLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKG5vZGUubGFiZWwpKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkTm9uVGVybWluYWwubGFiZWwgPSBub2RlLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkTm9uVGVybWluYWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJBbHRlcm5hdGl2ZVwiLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJPcHRpb25cIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uTWFuZGF0b3J5XCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc2VyaWFsaXplUHJvZHVjdGlvbihuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IG5vZGUuc2VwYXJhdG9yIH0pKSksXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBzZXBhcmF0b3I6IChzZXJpYWxpemVQcm9kdWN0aW9uKG5ldyBUZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogbm9kZS5zZXBhcmF0b3IgfSkpKSxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25cIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQWx0ZXJuYXRpb25cIixcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZFRlcm1pbmFsID0ge1xuICAgICAgICAgICAgdHlwZTogXCJUZXJtaW5hbFwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS50ZXJtaW5hbFR5cGUubmFtZSxcbiAgICAgICAgICAgIGxhYmVsOiB0b2tlbkxhYmVsKG5vZGUudGVybWluYWxUeXBlKSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlLmxhYmVsKSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZFRlcm1pbmFsLnRlcm1pbmFsTGFiZWwgPSBub2RlLmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBub2RlLnRlcm1pbmFsVHlwZS5QQVRURVJOO1xuICAgICAgICBpZiAobm9kZS50ZXJtaW5hbFR5cGUuUEFUVEVSTikge1xuICAgICAgICAgICAgc2VyaWFsaXplZFRlcm1pbmFsLnBhdHRlcm4gPSBpc1JlZ0V4cChwYXR0ZXJuKVxuICAgICAgICAgICAgICAgID8gcGF0dGVybi5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHBhdHRlcm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRUZXJtaW5hbDtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUnVsZVwiLFxuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgb3JnVGV4dDogbm9kZS5vcmdUZXh0LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCJpbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwsIH0gZnJvbSBcIi4vbW9kZWwuanNcIjtcbmV4cG9ydCBjbGFzcyBHQXN0VmlzaXRvciB7XG4gICAgdmlzaXQobm9kZSkge1xuICAgICAgICBjb25zdCBub2RlQW55ID0gbm9kZTtcbiAgICAgICAgc3dpdGNoIChub2RlQW55LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIE5vblRlcm1pbmFsOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0Tm9uVGVybWluYWwobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIEFsdGVybmF0aXZlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0QWx0ZXJuYXRpdmUobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIE9wdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdE9wdGlvbihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUmVwZXRpdGlvbk1hbmRhdG9yeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iobm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBBbHRlcm5hdGlvbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsdGVybmF0aW9uKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBUZXJtaW5hbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFRlcm1pbmFsKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSdWxlOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UnVsZShub2RlQW55KTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIHZpc2l0Tm9uVGVybWluYWwobm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdEFsdGVybmF0aXZlKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRPcHRpb24obm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdFJlcGV0aXRpb24obm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkobm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRBbHRlcm5hdGlvbihub2RlKSB7IH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIHZpc2l0VGVybWluYWwobm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdFJ1bGUobm9kZSkgeyB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aXNpdG9yLmpzLm1hcCIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29tZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0O1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdCA9IHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiAhcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuICEhcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU29tZTtcbiIsImltcG9ydCBhcnJheVNvbWUgZnJvbSAnLi9fYXJyYXlTb21lLmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlU29tZSBmcm9tICcuL19iYXNlU29tZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYW55KiogZWxlbWVudCBvZiBgY29sbGVjdGlvbmAuXG4gKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5LiBUaGUgcHJlZGljYXRlIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0sIEJvb2xlYW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnNvbWUodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnNvbWUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNvbWU7XG4iLCJpbXBvcnQgYmFzZUluZGV4T2YgZnJvbSAnLi9fYmFzZUluZGV4T2YuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzU3RyaW5nIGZyb20gJy4vaXNTdHJpbmcuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIGBjb2xsZWN0aW9uYC4gSWYgYGNvbGxlY3Rpb25gIGlzIGEgc3RyaW5nLCBpdCdzXG4gKiBjaGVja2VkIGZvciBhIHN1YnN0cmluZyBvZiBgdmFsdWVgLCBvdGhlcndpc2VcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBpcyB1c2VkIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhc1xuICogdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgYGNvbGxlY3Rpb25gLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgY29sbGVjdGlvbiA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gY29sbGVjdGlvbiA6IHZhbHVlcyhjb2xsZWN0aW9uKTtcbiAgZnJvbUluZGV4ID0gKGZyb21JbmRleCAmJiAhZ3VhcmQpID8gdG9JbnRlZ2VyKGZyb21JbmRleCkgOiAwO1xuXG4gIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICBmcm9tSW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgZnJvbUluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbilcbiAgICA/IChmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKVxuICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpbmNsdWRlcztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlFdmVyeTtcbiIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZXZlcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWBcbiAqL1xuZnVuY3Rpb24gYmFzZUV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0ID0gISFwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUV2ZXJ5O1xuIiwiaW1wb3J0IGFycmF5RXZlcnkgZnJvbSAnLi9fYXJyYXlFdmVyeS5qcyc7XG5pbXBvcnQgYmFzZUV2ZXJ5IGZyb20gJy4vX2Jhc2VFdmVyeS5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICogSXRlcmF0aW9uIGlzIHN0b3BwZWQgb25jZSBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBmb3JcbiAqIFtlbXB0eSBjb2xsZWN0aW9uc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRW1wdHlfc2V0KSBiZWNhdXNlXG4gKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICogZWxlbWVudHMgb2YgZW1wdHkgY29sbGVjdGlvbnMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXZlcnkoW3RydWUsIDEsIG51bGwsICd5ZXMnXSwgQm9vbGVhbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmV2ZXJ5KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBldmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGV2ZXJ5O1xuIiwiaW1wb3J0IHsgZXZlcnksIGluY2x1ZGVzLCBzb21lIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQWJzdHJhY3RQcm9kdWN0aW9uLCBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwsIH0gZnJvbSBcIi4vbW9kZWwuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpc1NlcXVlbmNlUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUnVsZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPcHRpb25hbFByb2QocHJvZCwgYWxyZWFkeVZpc2l0ZWQgPSBbXSkge1xuICAgIGNvbnN0IGlzRGlyZWN0bHlPcHRpb25hbCA9IHByb2QgaW5zdGFuY2VvZiBPcHRpb24gfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24gfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yO1xuICAgIGlmIChpc0RpcmVjdGx5T3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIG5vdGUgdGhhdCB0aGlzIGNhbiBjYXVzZSBpbmZpbml0ZSBsb29wIGlmIG9uZSBvcHRpb25hbCBlbXB0eSBUT1AgcHJvZHVjdGlvbiBoYXMgYSBjeWNsaWMgZGVwZW5kZW5jeSB3aXRoIGFub3RoZXJcbiAgICAvLyBlbXB0eSBvcHRpb25hbCB0b3AgcnVsZVxuICAgIC8vIG1heSBiZSBpbmRpcmVjdGx5IG9wdGlvbmFsICgoQT9CP0M/KSB8IChEP0U/Rj8pKVxuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgLy8gZm9yIE9SIGl0cyBlbm91Z2ggZm9yIGp1c3Qgb25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgdG8gYmUgb3B0aW9uYWxcbiAgICAgICAgcmV0dXJuIHNvbWUocHJvZC5kZWZpbml0aW9uLCAoc3ViUHJvZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWxQcm9kKHN1YlByb2QsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCAmJiBpbmNsdWRlcyhhbHJlYWR5VmlzaXRlZCwgcHJvZCkpIHtcbiAgICAgICAgLy8gYXZvaWRpbmcgc3RhY2sgb3ZlcmZsb3cgZHVlIHRvIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBYnN0cmFjdFByb2R1Y3Rpb24pIHtcbiAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgYWxyZWFkeVZpc2l0ZWQucHVzaChwcm9kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlcnkocHJvZC5kZWZpbml0aW9uLCAoc3ViUHJvZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGlzT3B0aW9uYWxQcm9kKHN1YlByb2QsIGFscmVhZHlWaXNpdGVkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJhbmNoaW5nUHJvZChwcm9kKSB7XG4gICAgcmV0dXJuIHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9kdWN0aW9uRHNsTmFtZShwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBcIlNVQlJVTEVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gXCJPUFRJT05cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9SXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgIHJldHVybiBcIkFUX0xFQVNUX09ORVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIFwiTUFOWV9TRVBcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiTUFOWVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiQ09OU1VNRVwiO1xuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIiwiZXhwb3J0IHsgUnVsZSwgVGVybWluYWwsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBzZXJpYWxpemVHcmFtbWFyLCBzZXJpYWxpemVQcm9kdWN0aW9uLCB9IGZyb20gXCIuL21vZGVsLmpzXCI7XG5leHBvcnQgeyBHQXN0VmlzaXRvciB9IGZyb20gXCIuL3Zpc2l0b3IuanNcIjtcbmV4cG9ydCB7IGdldFByb2R1Y3Rpb25Ec2xOYW1lLCBpc09wdGlvbmFsUHJvZCwgaXNCcmFuY2hpbmdQcm9kLCBpc1NlcXVlbmNlUHJvZCwgfSBmcm9tIFwiLi9oZWxwZXJzLmpzXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiaW1wb3J0IHsgZHJvcCwgZm9yRWFjaCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuLyoqXG4gKiAgQSBHcmFtbWFyIFdhbGtlciB0aGF0IGNvbXB1dGVzIHRoZSBcInJlbWFpbmluZ1wiIGdyYW1tYXIgXCJhZnRlclwiIGEgcHJvZHVjdGlvbnMgaW4gdGhlIGdyYW1tYXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZXN0V2Fsa2VyIHtcbiAgICB3YWxrKHByb2QsIHByZXZSZXN0ID0gW10pIHtcbiAgICAgICAgZm9yRWFjaChwcm9kLmRlZmluaXRpb24sIChzdWJQcm9kLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VyclJlc3QgPSBkcm9wKHByb2QuZGVmaW5pdGlvbiwgaW5kZXggKyAxKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrUHJvZFJlZihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrVGVybWluYWwoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0ZsYXQoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtPcHRpb24oc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQXRMZWFzdE9uZShzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrQXRMZWFzdE9uZVNlcChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrTWFueVNlcChzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtNYW55KHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtPcihzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhbGtUZXJtaW5hbCh0ZXJtaW5hbCwgY3VyclJlc3QsIHByZXZSZXN0KSB7IH1cbiAgICB3YWxrUHJvZFJlZihyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHsgfVxuICAgIHdhbGtGbGF0KGZsYXRQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDREVGID0+IGFmdGVyIHRoZSBEIHRoZSByZXN0IGlzIEVGXG4gICAgICAgIGNvbnN0IGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsoZmxhdFByb2QsIGZ1bGxPclJlc3QpO1xuICAgIH1cbiAgICB3YWxrT3B0aW9uKG9wdGlvblByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpP0YgPT4gYWZ0ZXIgdGhlIChERSk/IHRoZSByZXN0IGlzIEZcbiAgICAgICAgY29uc3QgZnVsbE9yUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhvcHRpb25Qcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9XG4gICAgd2Fsa0F0TGVhc3RPbmUoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpK0YgPT4gYWZ0ZXIgdGhlIChERSkrIHRoZSByZXN0IGlzIChERSk/RlxuICAgICAgICBjb25zdCBmdWxsQXRMZWFzdE9uZVJlc3QgPSBbXG4gICAgICAgICAgICBuZXcgT3B0aW9uKHsgZGVmaW5pdGlvbjogYXRMZWFzdE9uZVByb2QuZGVmaW5pdGlvbiB9KSxcbiAgICAgICAgXS5jb25jYXQoY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGF0TGVhc3RPbmVQcm9kLCBmdWxsQXRMZWFzdE9uZVJlc3QpO1xuICAgIH1cbiAgICB3YWxrQXRMZWFzdE9uZVNlcChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyBERSgsREUpKiBGID0+IGFmdGVyIHRoZSAoLERFKSsgdGhlIHJlc3QgaXMgKCxERSk/RlxuICAgICAgICBjb25zdCBmdWxsQXRMZWFzdE9uZVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lU2VwUHJvZCwgZnVsbEF0TGVhc3RPbmVTZXBSZXN0KTtcbiAgICB9XG4gICAgd2Fsa01hbnkobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoREUpKkYgPT4gYWZ0ZXIgdGhlIChERSkqIHRoZSByZXN0IGlzIChERSk/RlxuICAgICAgICBjb25zdCBmdWxsTWFueVJlc3QgPSBbXG4gICAgICAgICAgICBuZXcgT3B0aW9uKHsgZGVmaW5pdGlvbjogbWFueVByb2QuZGVmaW5pdGlvbiB9KSxcbiAgICAgICAgXS5jb25jYXQoY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKG1hbnlQcm9kLCBmdWxsTWFueVJlc3QpO1xuICAgIH1cbiAgICB3YWxrTWFueVNlcChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyAoREUoLERFKSopPyBGID0+IGFmdGVyIHRoZSAoLERFKSogdGhlIHJlc3QgaXMgKCxERSk/RlxuICAgICAgICBjb25zdCBmdWxsTWFueVNlcFJlc3QgPSByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55U2VwUHJvZCwgZnVsbE1hbnlTZXBSZXN0KTtcbiAgICB9XG4gICAgd2Fsa09yKG9yUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQyhEfEV8RilHID0+IHdoZW4gZmluZGluZyB0aGUgKER8RXxGKSB0aGUgcmVzdCBpcyBHXG4gICAgICAgIGNvbnN0IGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAvLyB3YWxrIGFsbCBkaWZmZXJlbnQgYWx0ZXJuYXRpdmVzXG4gICAgICAgIGZvckVhY2gob3JQcm9kLmRlZmluaXRpb24sIChhbHQpID0+IHtcbiAgICAgICAgICAgIC8vIHdyYXBwaW5nIGVhY2ggYWx0ZXJuYXRpdmUgaW4gYSBzaW5nbGUgZGVmaW5pdGlvbiB3cmFwcGVyXG4gICAgICAgICAgICAvLyB0byBhdm9pZCBlcnJvcnMgaW4gY29tcHV0aW5nIHRoZSByZXN0IG9mIHRoYXQgYWx0ZXJuYXRpdmUgaW4gdGhlIGludm9jYXRpb24gdG8gY29tcHV0ZUluUHJvZEZvbGxvd3NcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgZm9yIE9SKFthbHQxLGFsdDJdKSBhbHQyIHdpbGwgYmUgY29uc2lkZXJlZCBpbiAncmVzdCcgb2YgYWx0MVxuICAgICAgICAgICAgY29uc3QgcHJvZFdyYXBwZXIgPSBuZXcgQWx0ZXJuYXRpdmUoeyBkZWZpbml0aW9uOiBbYWx0XSB9KTtcbiAgICAgICAgICAgIHRoaXMud2Fsayhwcm9kV3JhcHBlciwgZnVsbE9yUmVzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3RGb3JSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihyZXBTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICBjb25zdCByZXBTZXBSZXN0ID0gW1xuICAgICAgICBuZXcgT3B0aW9uKHtcbiAgICAgICAgICAgIGRlZmluaXRpb246IFtcbiAgICAgICAgICAgICAgICBuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHJlcFNlcFByb2Quc2VwYXJhdG9yIH0pLFxuICAgICAgICAgICAgXS5jb25jYXQocmVwU2VwUHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgfSksXG4gICAgXTtcbiAgICBjb25zdCBmdWxsUmVwU2VwUmVzdCA9IHJlcFNlcFJlc3QuY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgcmV0dXJuIGZ1bGxSZXBTZXBSZXN0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzdC5qcy5tYXAiLCJpbXBvcnQgYmFzZVVuaXEgZnJvbSAnLi9fYmFzZVVuaXEuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucywgaW4gd2hpY2ggb25seSB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBlYWNoIGVsZW1lbnRcbiAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAqIGluIHRoZSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udW5pcShbMiwgMSwgMl0pO1xuICogLy8gPT4gWzIsIDFdXG4gKi9cbmZ1bmN0aW9uIHVuaXEoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXE7XG4iLCJpbXBvcnQgeyBmbGF0dGVuLCBtYXAsIHVuaXEgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBpc0JyYW5jaGluZ1Byb2QsIGlzT3B0aW9uYWxQcm9kLCBpc1NlcXVlbmNlUHJvZCwgTm9uVGVybWluYWwsIFRlcm1pbmFsLCB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG5leHBvcnQgZnVuY3Rpb24gZmlyc3QocHJvZCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGluIHRoZW9yeSBjYXVzZSBpbmZpbml0ZSBsb29wcyBpZlxuICAgICAgICAvLyAoMSkgcHJvZCBBIHJlZnMgcHJvZCBCLlxuICAgICAgICAvLyAoMikgcHJvZCBCIHJlZnMgcHJvZCBBXG4gICAgICAgIC8vICgzKSBBQiBjYW4gbWF0Y2ggdGhlIGVtcHR5IHNldFxuICAgICAgICAvLyBpbiBvdGhlciB3b3JkcyBhIGN5Y2xlIHdoZXJlIGV2ZXJ5dGhpbmcgaXMgb3B0aW9uYWwgc28gdGhlIGZpcnN0IHdpbGwga2VlcFxuICAgICAgICAvLyBsb29raW5nIGFoZWFkIGZvciB0aGUgbmV4dCBvcHRpb25hbCBwYXJ0IGFuZCB3aWxsIG5ldmVyIGV4aXRcbiAgICAgICAgLy8gY3VycmVudGx5IHRoZXJlIGlzIG5vIHNhZmVndWFyZCBmb3IgdGhpcyB1bmlxdWUgZWRnZSBjYXNlIGJlY2F1c2VcbiAgICAgICAgLy8gKDEpIG5vdCBzdXJlIGEgZ3JhbW1hciBpbiB3aGljaCB0aGlzIGNhbiBoYXBwZW4gaXMgdXNlZnVsIGZvciBhbnl0aGluZyAocHJvZHVjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGZpcnN0KHByb2QucmVmZXJlbmNlZFJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9yVGVybWluYWwocHJvZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VxdWVuY2VQcm9kKHByb2QpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEZvclNlcXVlbmNlKHByb2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JyYW5jaGluZ1Byb2QocHJvZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Rm9yQnJhbmNoaW5nKHByb2QpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RGb3JTZXF1ZW5jZShwcm9kKSB7XG4gICAgbGV0IGZpcnN0U2V0ID0gW107XG4gICAgY29uc3Qgc2VxID0gcHJvZC5kZWZpbml0aW9uO1xuICAgIGxldCBuZXh0U3ViUHJvZElkeCA9IDA7XG4gICAgbGV0IGhhc0lubmVyUHJvZHNSZW1haW5pbmcgPSBzZXEubGVuZ3RoID4gbmV4dFN1YlByb2RJZHg7XG4gICAgbGV0IGN1cnJTdWJQcm9kO1xuICAgIC8vIHNvIHdlIGVudGVyIHRoZSBsb29wIGF0IGxlYXN0IG9uY2UgKGlmIHRoZSBkZWZpbml0aW9uIGlzIG5vdCBlbXB0eVxuICAgIGxldCBpc0xhc3RJbm5lclByb2RPcHRpb25hbCA9IHRydWU7XG4gICAgLy8gc2NhbiBhIHNlcXVlbmNlIHVudGlsIGl0J3MgZW5kIG9yIHVudGlsIHdlIGhhdmUgZm91bmQgYSBOT05FIG9wdGlvbmFsIHByb2R1Y3Rpb24gaW4gaXRcbiAgICB3aGlsZSAoaGFzSW5uZXJQcm9kc1JlbWFpbmluZyAmJiBpc0xhc3RJbm5lclByb2RPcHRpb25hbCkge1xuICAgICAgICBjdXJyU3ViUHJvZCA9IHNlcVtuZXh0U3ViUHJvZElkeF07XG4gICAgICAgIGlzTGFzdElubmVyUHJvZE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoY3VyclN1YlByb2QpO1xuICAgICAgICBmaXJzdFNldCA9IGZpcnN0U2V0LmNvbmNhdChmaXJzdChjdXJyU3ViUHJvZCkpO1xuICAgICAgICBuZXh0U3ViUHJvZElkeCA9IG5leHRTdWJQcm9kSWR4ICsgMTtcbiAgICAgICAgaGFzSW5uZXJQcm9kc1JlbWFpbmluZyA9IHNlcS5sZW5ndGggPiBuZXh0U3ViUHJvZElkeDtcbiAgICB9XG4gICAgcmV0dXJuIHVuaXEoZmlyc3RTZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yQnJhbmNoaW5nKHByb2QpIHtcbiAgICBjb25zdCBhbGxBbHRlcm5hdGl2ZXNGaXJzdHMgPSBtYXAocHJvZC5kZWZpbml0aW9uLCAoaW5uZXJQcm9kKSA9PiB7XG4gICAgICAgIHJldHVybiBmaXJzdChpbm5lclByb2QpO1xuICAgIH0pO1xuICAgIHJldHVybiB1bmlxKGZsYXR0ZW4oYWxsQWx0ZXJuYXRpdmVzRmlyc3RzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmlyc3RGb3JUZXJtaW5hbCh0ZXJtaW5hbCkge1xuICAgIHJldHVybiBbdGVybWluYWwudGVybWluYWxUeXBlXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcCIsIi8vIFRPRE86IGNhbiB0aGlzIGJlIHJlbW92ZWQ/IHdoZXJlIGlzIGl0IHVzZWQ/XG5leHBvcnQgY29uc3QgSU4gPSBcIl9+SU5+X1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsImltcG9ydCB7IFJlc3RXYWxrZXIgfSBmcm9tIFwiLi9yZXN0LmpzXCI7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuL2ZpcnN0LmpzXCI7XG5pbXBvcnQgeyBhc3NpZ24sIGZvckVhY2ggfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBJTiB9IGZyb20gXCIuLi9jb25zdGFudHMuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aXZlIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbi8vIFRoaXMgUmVzeW5jRm9sbG93c1dhbGtlciBjb21wdXRlcyBhbGwgb2YgdGhlIGZvbGxvd3MgcmVxdWlyZWQgZm9yIFJFU1lOQ1xuLy8gKHNraXBwaW5nIHJlZmVyZW5jZSBwcm9kdWN0aW9uKS5cbmV4cG9ydCBjbGFzcyBSZXN5bmNGb2xsb3dzV2Fsa2VyIGV4dGVuZHMgUmVzdFdhbGtlciB7XG4gICAgY29uc3RydWN0b3IodG9wUHJvZCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICB0aGlzLmZvbGxvd3MgPSB7fTtcbiAgICB9XG4gICAgc3RhcnRXYWxraW5nKCkge1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BQcm9kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sbG93cztcbiAgICB9XG4gICAgd2Fsa1Rlcm1pbmFsKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyEganVzdCBsaWtlIGluIHRoZSBwdWJsaWMgc2VjdG9yIGFmdGVyIDEzOjAwXG4gICAgfVxuICAgIHdhbGtQcm9kUmVmKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBjb25zdCBmb2xsb3dOYW1lID0gYnVpbGRCZXR3ZWVuUHJvZHNGb2xsb3dQcmVmaXgocmVmUHJvZC5yZWZlcmVuY2VkUnVsZSwgcmVmUHJvZC5pZHgpICtcbiAgICAgICAgICAgIHRoaXMudG9wUHJvZC5uYW1lO1xuICAgICAgICBjb25zdCBmdWxsUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgIGNvbnN0IHJlc3RQcm9kID0gbmV3IEFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgIGNvbnN0IHRfaW5fdG9wUHJvZF9mb2xsb3dzID0gZmlyc3QocmVzdFByb2QpO1xuICAgICAgICB0aGlzLmZvbGxvd3NbZm9sbG93TmFtZV0gPSB0X2luX3RvcFByb2RfZm9sbG93cztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFsbFByb2RzRm9sbG93cyh0b3BQcm9kdWN0aW9ucykge1xuICAgIGNvbnN0IHJlU3luY0ZvbGxvd3MgPSB7fTtcbiAgICBmb3JFYWNoKHRvcFByb2R1Y3Rpb25zLCAodG9wUHJvZCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyUmVmc0ZvbGxvdyA9IG5ldyBSZXN5bmNGb2xsb3dzV2Fsa2VyKHRvcFByb2QpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICBhc3NpZ24ocmVTeW5jRm9sbG93cywgY3VyclJlZnNGb2xsb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZVN5bmNGb2xsb3dzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KGlubmVyLCBvY2N1cmVuY2VJblBhcmVudCkge1xuICAgIHJldHVybiBpbm5lci5uYW1lICsgb2NjdXJlbmNlSW5QYXJlbnQgKyBJTjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEluUHJvZEZvbGxvd1ByZWZpeCh0ZXJtaW5hbCkge1xuICAgIGNvbnN0IHRlcm1pbmFsTmFtZSA9IHRlcm1pbmFsLnRlcm1pbmFsVHlwZS5uYW1lO1xuICAgIHJldHVybiB0ZXJtaW5hbE5hbWUgKyB0ZXJtaW5hbC5pZHggKyBJTjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvbGxvdy5qcy5tYXAiLCIvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG5lZ2F0ZXMgdGhlIHJlc3VsdCBvZiB0aGUgcHJlZGljYXRlIGBmdW5jYC4gVGhlXG4gKiBgZnVuY2AgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBuZWdhdGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBpc0V2ZW4obikge1xuICogICByZXR1cm4gbiAlIDIgPT0gMDtcbiAqIH1cbiAqXG4gKiBfLmZpbHRlcihbMSwgMiwgMywgNCwgNSwgNl0sIF8ubmVnYXRlKGlzRXZlbikpO1xuICogLy8gPT4gWzEsIDMsIDVdXG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShwcmVkaWNhdGUpIHtcbiAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgY2FzZSAxOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0pO1xuICAgICAgY2FzZSAyOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmVnYXRlO1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBiYXNlRmlsdGVyIGZyb20gJy4vX2Jhc2VGaWx0ZXIuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBuZWdhdGUgZnJvbSAnLi9uZWdhdGUuanMnO1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5maWx0ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVqZWN0O1xuIiwiaW1wb3J0IGJhc2VJbmRleE9mIGZyb20gJy4vX2Jhc2VJbmRleE9mLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYHZhbHVlYCBpcyBmb3VuZCBpbiBgYXJyYXlgXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQncyB1c2VkIGFzIHRoZVxuICogb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4T2Y7XG4iLCJpbXBvcnQgU2V0Q2FjaGUgZnJvbSAnLi9fU2V0Q2FjaGUuanMnO1xuaW1wb3J0IGFycmF5SW5jbHVkZXMgZnJvbSAnLi9fYXJyYXlJbmNsdWRlcy5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlc1dpdGggZnJvbSAnLi9fYXJyYXlJbmNsdWRlc1dpdGguanMnO1xuaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBjYWNoZUhhcyBmcm9tICcuL19jYWNoZUhhcy5qcyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGV4Y2x1ZGluZyBtdWx0aXBsZSBhcnJheXMgb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlRGlmZmVyZW5jZShhcnJheSwgdmFsdWVzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgdmFsdWVzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aDtcblxuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgfVxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgfVxuICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gIH1cbiAgb3V0ZXI6XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpbmNsdWRlcyh2YWx1ZXMsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRGlmZmVyZW5jZTtcbiIsImltcG9ydCBiYXNlRGlmZmVyZW5jZSBmcm9tICcuL19iYXNlRGlmZmVyZW5jZS5qcyc7XG5pbXBvcnQgYmFzZUZsYXR0ZW4gZnJvbSAnLi9fYmFzZUZsYXR0ZW4uanMnO1xuaW1wb3J0IGJhc2VSZXN0IGZyb20gJy4vX2Jhc2VSZXN0LmpzJztcbmltcG9ydCBpc0FycmF5TGlrZU9iamVjdCBmcm9tICcuL2lzQXJyYXlMaWtlT2JqZWN0LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzFdXG4gKi9cbnZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgOiBbXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkaWZmZXJlbmNlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IHdpdGggYWxsIGZhbHNleSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIHZhbHVlcyBgZmFsc2VgLCBgbnVsbGAsXG4gKiBgMGAsIGBcIlwiYCwgYHVuZGVmaW5lZGAsIGFuZCBgTmFOYCBhcmUgZmFsc2V5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gKiAvLyA9PiBbMSwgMiwgM11cbiAqL1xuZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29tcGFjdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBhbGlhcyBmaXJzdFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmhlYWQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDFcbiAqXG4gKiBfLmhlYWQoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYXJyYXlbMF0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGhlYWQ7XG4iLCJleHBvcnQgZnVuY3Rpb24gUFJJTlRfRVJST1IobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBjYW4ndCBvdmVycmlkZSBnbG9iYWwuY29uc29sZSBpbiBub2RlLmpzICovXG4gICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvcjogJHttc2d9YCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIFBSSU5UX1dBUk5JTkcobXNnKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgLSBjYW4ndCBvdmVycmlkZSBnbG9iYWwuY29uc29sZSBpbiBub2RlLmpzKi9cbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgLy8gVE9ETzogbW9kaWZ5IGRvY3MgYWNjb3JkaW5nbHlcbiAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke21zZ31gKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmludC5qcy5tYXAiLCJpbXBvcnQgeyBSZWdFeHBQYXJzZXIsIH0gZnJvbSBcIkBjaGV2cm90YWluL3JlZ2V4cC10by1hc3RcIjtcbmxldCByZWdFeHBBc3RDYWNoZSA9IHt9O1xuY29uc3QgcmVnRXhwUGFyc2VyID0gbmV3IFJlZ0V4cFBhcnNlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZ0V4cEFzdChyZWdFeHApIHtcbiAgICBjb25zdCByZWdFeHBTdHIgPSByZWdFeHAudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnRXhwQXN0Q2FjaGUuaGFzT3duUHJvcGVydHkocmVnRXhwU3RyKSkge1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0Q2FjaGVbcmVnRXhwU3RyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cEFzdCA9IHJlZ0V4cFBhcnNlci5wYXR0ZXJuKHJlZ0V4cFN0cik7XG4gICAgICAgIHJlZ0V4cEFzdENhY2hlW3JlZ0V4cFN0cl0gPSByZWdFeHBBc3Q7XG4gICAgICAgIHJldHVybiByZWdFeHBBc3Q7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKSB7XG4gICAgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ19leHBfcGFyc2VyLmpzLm1hcCIsImltcG9ydCB7IEJhc2VSZWdFeHBWaXNpdG9yLCB9IGZyb20gXCJAY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBldmVyeSwgZmluZCwgZm9yRWFjaCwgaW5jbHVkZXMsIGlzQXJyYXksIHZhbHVlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IFBSSU5UX0VSUk9SLCBQUklOVF9XQVJOSU5HIH0gZnJvbSBcIkBjaGV2cm90YWluL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRSZWdFeHBBc3QgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgY2hhckNvZGVUb09wdGltaXplZEluZGV4LCBtaW5PcHRpbWl6YXRpb25WYWwgfSBmcm9tIFwiLi9sZXhlci5qc1wiO1xuY29uc3QgY29tcGxlbWVudEVycm9yTWVzc2FnZSA9IFwiQ29tcGxlbWVudCBTZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBmaXJzdCBjaGFyIG9wdGltaXphdGlvblwiO1xuZXhwb3J0IGNvbnN0IGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyA9ICdVbmFibGUgdG8gdXNlIFwiZmlyc3QgY2hhclwiIGxleGVyIG9wdGltaXphdGlvbnM6XFxuJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyhyZWdFeHAsIGVuc3VyZU9wdGltaXphdGlvbnMgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IGdldFJlZ0V4cEFzdChyZWdFeHApO1xuICAgICAgICBjb25zdCBmaXJzdENoYXJzID0gZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QudmFsdWUsIHt9LCBhc3QuZmxhZ3MuaWdub3JlQ2FzZSk7XG4gICAgICAgIHJldHVybiBmaXJzdENoYXJzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAvLyBUZXN0aW5nIHRoaXMgcmVsaWVzIG9uIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgaGF2aW5nIGEgYnVnLi4uICovXG4gICAgICAgIC8vIFRPRE86IG9ubHkgdGhlIGVsc2UgYnJhbmNoIG5lZWRzIHRvIGJlIGlnbm9yZWQsIHRyeSB0byBmaXggd2l0aCBuZXdlciBwcmV0dGllciAvIHRzY1xuICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBjb21wbGVtZW50RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIFBSSU5UX1dBUk5JTkcoYCR7ZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnfWAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0VW5hYmxlIHRvIG9wdGltaXplOiA8ICR7cmVnRXhwLnRvU3RyaW5nKCl9ID5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRDb21wbGVtZW50IFNldHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NPTVBMRU1FTlQgZm9yIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1zZ1N1ZmZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCA9XG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjUkVHRVhQX1BBUlNJTkcgZm9yIGRldGFpbHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQUklOVF9FUlJPUihgJHtmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2d9XFxuYCArXG4gICAgICAgICAgICAgICAgYFxcdEZhaWxlZCBwYXJzaW5nOiA8ICR7cmVnRXhwLnRvU3RyaW5nKCl9ID5cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0VXNpbmcgdGhlIEBjaGV2cm90YWluL3JlZ2V4cC10by1hc3QgbGlicmFyeVxcbmAgK1xuICAgICAgICAgICAgICAgIFwiXFx0UGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGV2cm90YWluL2NoZXZyb3RhaW4vaXNzdWVzXCIgK1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LCByZXN1bHQsIGlnbm9yZUNhc2UpIHtcbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJEaXNqdW5jdGlvblwiOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdC52YWx1ZVtpXSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQWx0ZXJuYXRpdmVcIjpcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gYXN0LnZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRlcm1zIHRoYXQgY2Fubm90IGVmZmVjdCB0aGUgZmlyc3QgY2hhciByZXN1bHRzXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXJtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIGJhY2sgcmVmZXJlbmNlIGNhbm5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNoYXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaWYgYSBiYWNrIHJlZmVyZW5jZSBpcyB0aGUgZmlyc3QgcHJvZHVjdGlvbiB0aGFuIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyb3VwIGJlaW5nIHJlZmVyZW5jZWQgaGFzIGhhZCB0byBjb21lIEJFRk9SRSBzbyBpdHMgY29kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwQmFja1JlZmVyZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIGRvIG5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOb25Xb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhdG9tID0gdGVybTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0b20udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQ2hhcmFjdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChhdG9tLnZhbHVlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdG9tLmNvbXBsZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihjb21wbGVtZW50RXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2goYXRvbS52YWx1ZSwgKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IG9wdGltaXplIHdoZW4gaWdub3JlQ2FzZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlQ2FzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmFuZ2VDb2RlID0gcmFuZ2UuZnJvbTsgcmFuZ2VDb2RlIDw9IHJhbmdlLnRvOyByYW5nZUNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KHJhbmdlQ29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gKDIgb3JkZXJzIG9mIG1hZ25pdHVkZSBsZXNzIHdvcmsgZm9yIHZlcnkgbGFyZ2UgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1bm9wdGltaXplZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJhbmdlQ29kZSA9IHJhbmdlLmZyb207IHJhbmdlQ29kZSA8PSByYW5nZS50byAmJiByYW5nZUNvZGUgPCBtaW5PcHRpbWl6YXRpb25WYWw7IHJhbmdlQ29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQocmFuZ2VDb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVzcyBjb21tb24gY2hhckNvZGUgd2hlcmUgd2Ugb3B0aW1pemUgZm9yIGZhc3RlciBpbml0IHRpbWUsIGJ5IHVzaW5nIGxhcmdlciBcImJ1Y2tldHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvID49IG1pbk9wdGltaXphdGlvblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblVuT3B0VmFsID0gcmFuZ2UuZnJvbSA+PSBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWluT3B0aW1pemF0aW9uVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFVuT3B0VmFsID0gcmFuZ2UudG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluT3B0SWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KG1pblVuT3B0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhPcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWF4VW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1cnJPcHRJZHggPSBtaW5PcHRJZHg7IGN1cnJPcHRJZHggPD0gbWF4T3B0SWR4OyBjdXJyT3B0SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJPcHRJZHhdID0gY3Vyck9wdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb24gRXhoYXVzdGl2ZSBNYXRjaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBhIG1hbmRhdG9yeSBwcm9kdWN0aW9uLCBubyBtb3JlICoqc3RhcnQqKiBjb2RlcyBjYW4gYmUgZm91bmQgb24gdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWxRdWFudGlmaWVyID0gYXRvbS5xdWFudGlmaWVyICE9PSB1bmRlZmluZWQgJiYgYXRvbS5xdWFudGlmaWVyLmF0TGVhc3QgPT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIEEgZ3JvdXAgbWF5IGJlIG9wdGlvbmFsIGR1ZSB0byBlbXB0eSBjb250ZW50cyAvKD86KS9cbiAgICAgICAgICAgICAgICAvLyBvciBpZiBldmVyeXRoaW5nIGluc2lkZSBpdCBpcyBvcHRpb25hbCAvKChhKT8pL1xuICAgICAgICAgICAgICAgIChhdG9tLnR5cGUgPT09IFwiR3JvdXBcIiAmJiBpc1dob2xlT3B0aW9uYWwoYXRvbSkgPT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHRlcm0gaXMgbm90IGEgZ3JvdXAgaXQgbWF5IG9ubHkgYmUgb3B0aW9uYWwgaWYgaXQgaGFzIGFuIG9wdGlvbmFsIHF1YW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgKGF0b20udHlwZSAhPT0gXCJHcm91cFwiICYmIGlzT3B0aW9uYWxRdWFudGlmaWVyID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoIVwiKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGgpXG4gICAgcmV0dXJuIHZhbHVlcyhyZXN1bHQpO1xufVxuZnVuY3Rpb24gYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKSB7XG4gICAgY29uc3Qgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjb2RlKTtcbiAgICByZXN1bHRbb3B0aW1pemVkQ2hhcklkeF0gPSBvcHRpbWl6ZWRDaGFySWR4O1xuICAgIGlmIChpZ25vcmVDYXNlID09PSB0cnVlKSB7XG4gICAgICAgIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVJZ25vcmVDYXNlKGNvZGUsIHJlc3VsdCkge1xuICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvbnN0IHVwcGVyQ2hhciA9IGNoYXIudG9VcHBlckNhc2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1cHBlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgY29uc3Qgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCh1cHBlckNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsb3dlckNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZENoYXJJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobG93ZXJDaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmVzdWx0W29wdGltaXplZENoYXJJZHhdID0gb3B0aW1pemVkQ2hhcklkeDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDb2RlKHNldE5vZGUsIHRhcmdldENoYXJDb2Rlcykge1xuICAgIHJldHVybiBmaW5kKHNldE5vZGUudmFsdWUsIChjb2RlT3JSYW5nZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVPclJhbmdlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGFyZ2V0Q2hhckNvZGVzLCBjb2RlT3JSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBjb2RlT3JSYW5nZTtcbiAgICAgICAgICAgIHJldHVybiAoZmluZCh0YXJnZXRDaGFyQ29kZXMsICh0YXJnZXRDb2RlKSA9PiByYW5nZS5mcm9tIDw9IHRhcmdldENvZGUgJiYgdGFyZ2V0Q29kZSA8PSByYW5nZS50bykgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzV2hvbGVPcHRpb25hbChhc3QpIHtcbiAgICBjb25zdCBxdWFudGlmaWVyID0gYXN0LnF1YW50aWZpZXI7XG4gICAgaWYgKHF1YW50aWZpZXIgJiYgcXVhbnRpZmllci5hdExlYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFzdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KGFzdC52YWx1ZSlcbiAgICAgICAgPyBldmVyeShhc3QudmFsdWUsIGlzV2hvbGVPcHRpb25hbClcbiAgICAgICAgOiBpc1dob2xlT3B0aW9uYWwoYXN0LnZhbHVlKTtcbn1cbmNsYXNzIENoYXJDb2RlRmluZGVyIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldENoYXJDb2Rlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhcmdldENoYXJDb2RlcyA9IHRhcmdldENoYXJDb2RlcztcbiAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdENoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBrZWVwIGxvb2tpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMuZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggbG9va2FoZWFkcyBhcyB0aGV5IGRvIG5vdCBhY3R1YWxseSBjb25zdW1lIGFueSBjaGFyYWN0ZXJzIHRodXNcbiAgICAgICAgLy8gZmluZGluZyBhIGNoYXJDb2RlIGF0IGxvb2thaGVhZCBjb250ZXh0IGRvZXMgbm90IG1lYW4gdGhhdCByZWdleHAgY2FuIGFjdHVhbGx5IGNvbnRhaW4gaXQgaW4gYSBtYXRjaC5cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJOZWdhdGl2ZUxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIudmlzaXRDaGlsZHJlbihub2RlKTtcbiAgICB9XG4gICAgdmlzaXRDaGFyYWN0ZXIobm9kZSkge1xuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy50YXJnZXRDaGFyQ29kZXMsIG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFNldChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbXBsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChmaW5kQ29kZShub2RlLCB0aGlzLnRhcmdldENoYXJDb2RlcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbmRDb2RlKG5vZGUsIHRoaXMudGFyZ2V0Q2hhckNvZGVzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuTWF0Y2hDaGFyQ29kZShjaGFyQ29kZXMsIHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBjb25zdCBhc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlRmluZGVyID0gbmV3IENoYXJDb2RlRmluZGVyKGNoYXJDb2Rlcyk7XG4gICAgICAgIGNoYXJDb2RlRmluZGVyLnZpc2l0KGFzdCk7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZUZpbmRlci5mb3VuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoZmluZChwYXR0ZXJuLCAoY2hhcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKGNoYXJDb2RlcywgY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgfSkgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnX2V4cC5qcy5tYXAiLCJpbXBvcnQgeyBCYXNlUmVnRXhwVmlzaXRvciB9IGZyb20gXCJAY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLCB9IGZyb20gXCIuL2xleGVyX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgY29tcGFjdCwgZGVmYXVsdHMsIGRpZmZlcmVuY2UsIGZpbHRlciwgZmluZCwgZmlyc3QsIGZsYXR0ZW4sIGZvckVhY2gsIGhhcywgaW5jbHVkZXMsIGluZGV4T2YsIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzUmVnRXhwLCBpc1N0cmluZywgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgcmVkdWNlLCByZWplY3QsIHZhbHVlcywgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBQUklOVF9FUlJPUiB9IGZyb20gXCJAY2hldnJvdGFpbi91dGlsc1wiO1xuaW1wb3J0IHsgY2FuTWF0Y2hDaGFyQ29kZSwgZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnLCBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcywgfSBmcm9tIFwiLi9yZWdfZXhwLmpzXCI7XG5pbXBvcnQgeyBnZXRSZWdFeHBBc3QgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlci5qc1wiO1xuY29uc3QgUEFUVEVSTiA9IFwiUEFUVEVSTlwiO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9ERSA9IFwiZGVmYXVsdE1vZGVcIjtcbmV4cG9ydCBjb25zdCBNT0RFUyA9IFwibW9kZXNcIjtcbmV4cG9ydCBsZXQgU1VQUE9SVF9TVElDS1kgPSB0eXBlb2YgbmV3IFJlZ0V4cChcIig/OilcIikuc3RpY2t5ID09PSBcImJvb2xlYW5cIjtcbmV4cG9ydCBmdW5jdGlvbiBkaXNhYmxlU3RpY2t5KCkge1xuICAgIFNVUFBPUlRfU1RJQ0tZID0gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlU3RpY2t5KCkge1xuICAgIFNVUFBPUlRfU1RJQ0tZID0gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplVG9rZW5UeXBlcyh0b2tlblR5cGVzLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgdXNlU3RpY2t5OiBTVVBQT1JUX1NUSUNLWSxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgICAgIHBvc2l0aW9uVHJhY2tpbmc6IFwiZnVsbFwiLFxuICAgICAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IFtcIlxcclwiLCBcIlxcblwiXSxcbiAgICAgICAgdHJhY2VyOiAobXNnLCBhY3Rpb24pID0+IGFjdGlvbigpLFxuICAgIH0pO1xuICAgIGNvbnN0IHRyYWNlciA9IG9wdGlvbnMudHJhY2VyO1xuICAgIHRyYWNlcihcImluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXBcIiwgKCkgPT4ge1xuICAgICAgICBpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwKCk7XG4gICAgfSk7XG4gICAgbGV0IG9ubHlSZWxldmFudFR5cGVzO1xuICAgIHRyYWNlcihcIlJlamVjdCBMZXhlci5OQVwiLCAoKSA9PiB7XG4gICAgICAgIG9ubHlSZWxldmFudFR5cGVzID0gcmVqZWN0KHRva2VuVHlwZXMsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJUeXBlW1BBVFRFUk5dID09PSBMZXhlci5OQTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IGhhc0N1c3RvbSA9IGZhbHNlO1xuICAgIGxldCBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zO1xuICAgIHRyYWNlcihcIlRyYW5zZm9ybSBQYXR0ZXJuc1wiLCAoKSA9PiB7XG4gICAgICAgIGhhc0N1c3RvbSA9IGZhbHNlO1xuICAgICAgICBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJQYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGlzUmVnRXhwKGN1cnJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ0V4cFNvdXJjZSA9IGN1cnJQYXR0ZXJuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAocmVnRXhwU291cmNlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IHRoZXNlIHJlZ0V4cCBtZXRhIGNoYXJhY3RlcnMgd2hpY2ggY2FuIGFwcGVhciBpbiBhIGxlbmd0aCBvbmUgcmVnRXhwXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCJeXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIiRcIiAmJlxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiLlwiICYmXG4gICAgICAgICAgICAgICAgICAgICFjdXJyUGF0dGVybi5pZ25vcmVDYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBTb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZ0V4cFNvdXJjZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlWzBdID09PSBcIlxcXFxcIiAmJlxuICAgICAgICAgICAgICAgICAgICAvLyBub3QgYSBtZXRhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXMoW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJXXCIsXG4gICAgICAgICAgICAgICAgICAgIF0sIHJlZ0V4cFNvdXJjZVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlZCBtZXRhIENoYXJhY3RlcnM6IC9cXCsvIC9cXFsvXG4gICAgICAgICAgICAgICAgICAgIC8vIG9yIHJlZHVuZGFudCBlc2NhcGluZzogL1xcYS9cbiAgICAgICAgICAgICAgICAgICAgLy8gd2l0aG91dCB0aGUgZXNjYXBpbmcgXCJcXFwiXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdFeHBTb3VyY2VbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy51c2VTdGlja3lcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3RpY2t5RmxhZyhjdXJyUGF0dGVybilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkU3RhcnRPZklucHV0KGN1cnJQYXR0ZXJuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGN1cnJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jIC0gY3VzdG9tIHBhdHRlcm5zIGRvIG5vdCByZXF1aXJlIGFueSB0cmFuc2Zvcm1hdGlvbnMsIG9ubHkgd3JhcHBpbmcgaW4gYSBSZWdFeHAgTGlrZSBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4geyBleGVjOiBjdXJyUGF0dGVybiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGN1cnJQYXR0ZXJuID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaGFzQ3VzdG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBJQ3VzdG9tUGF0dGVyblxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyUGF0dGVybiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyUGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJQYXR0ZXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFJlZ0V4cFN0cmluZyA9IGN1cnJQYXR0ZXJuLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCBcIlxcXFwkJlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFJlZ0V4cCA9IG5ldyBSZWdFeHAoZXNjYXBlZFJlZ0V4cFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnVzZVN0aWNreVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRTdGlja3lGbGFnKHdyYXBwZWRSZWdFeHApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dCh3cmFwcGVkUmVnRXhwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgcGF0dGVybklkeFRvVHlwZTtcbiAgICBsZXQgcGF0dGVybklkeFRvR3JvdXA7XG4gICAgbGV0IHBhdHRlcm5JZHhUb0xvbmdlckFsdElkeEFycjtcbiAgICBsZXQgcGF0dGVybklkeFRvUHVzaE1vZGU7XG4gICAgbGV0IHBhdHRlcm5JZHhUb1BvcE1vZGU7XG4gICAgdHJhY2VyKFwibWlzYyBtYXBwaW5nXCIsICgpID0+IHtcbiAgICAgICAgcGF0dGVybklkeFRvVHlwZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKGN1cnJUeXBlKSA9PiBjdXJyVHlwZS50b2tlblR5cGVJZHgpO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Hcm91cCA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKGNsYXp6KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBncm91cE5hbWUgPSBjbGF6ei5HUk9VUDtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZ3JvdXBOYW1lID09PSBMZXhlci5TS0lQUEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3RyaW5nKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVbmRlZmluZWQoZ3JvdXBOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhBcnIgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIChjbGF6eikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9uZ2VyQWx0VHlwZSA9IGNsYXp6LkxPTkdFUl9BTFQ7XG4gICAgICAgICAgICBpZiAobG9uZ2VyQWx0VHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdElkeEFyciA9IGlzQXJyYXkobG9uZ2VyQWx0VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgPyBtYXAobG9uZ2VyQWx0VHlwZSwgKHR5cGUpID0+IGluZGV4T2Yob25seVJlbGV2YW50VHlwZXMsIHR5cGUpKVxuICAgICAgICAgICAgICAgICAgICA6IFtpbmRleE9mKG9ubHlSZWxldmFudFR5cGVzLCBsb25nZXJBbHRUeXBlKV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvbmdlckFsdElkeEFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhdHRlcm5JZHhUb1B1c2hNb2RlID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCAoY2xhenopID0+IGNsYXp6LlBVU0hfTU9ERSk7XG4gICAgICAgIHBhdHRlcm5JZHhUb1BvcE1vZGUgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIChjbGF6eikgPT4gaGFzKGNsYXp6LCBcIlBPUF9NT0RFXCIpKTtcbiAgICB9KTtcbiAgICBsZXQgcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3I7XG4gICAgdHJhY2VyKFwiTGluZSBUZXJtaW5hdG9yIEhhbmRsaW5nXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMgPSBnZXRDaGFyQ29kZXMob3B0aW9ucy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpO1xuICAgICAgICBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvciA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKHRva1R5cGUpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb25UcmFja2luZyAhPT0gXCJvbmx5T2Zmc2V0XCIpIHtcbiAgICAgICAgICAgIHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCAodG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0b2tUeXBlLkxJTkVfQlJFQUtTO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMpID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuTWF0Y2hDaGFyQ29kZShsaW5lVGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgcGF0dGVybklkeFRvSXNDdXN0b207XG4gICAgbGV0IHBhdHRlcm5JZHhUb1Nob3J0O1xuICAgIGxldCBlbXB0eUdyb3VwcztcbiAgICBsZXQgcGF0dGVybklkeFRvQ29uZmlnO1xuICAgIHRyYWNlcihcIk1pc2MgTWFwcGluZyAjMlwiLCAoKSA9PiB7XG4gICAgICAgIHBhdHRlcm5JZHhUb0lzQ3VzdG9tID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCBpc0N1c3RvbVBhdHRlcm4pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9TaG9ydCA9IG1hcChhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zLCBpc1Nob3J0UGF0dGVybik7XG4gICAgICAgIGVtcHR5R3JvdXBzID0gcmVkdWNlKG9ubHlSZWxldmFudFR5cGVzLCAoYWNjLCBjbGF6eikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcoZ3JvdXBOYW1lKSAmJiAhKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkpIHtcbiAgICAgICAgICAgICAgICBhY2NbZ3JvdXBOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSBtYXAoYWxsVHJhbnNmb3JtZWRQYXR0ZXJucywgKHgsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBhbGxUcmFuc2Zvcm1lZFBhdHRlcm5zW2lkeF0sXG4gICAgICAgICAgICAgICAgbG9uZ2VyQWx0OiBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhBcnJbaWR4XSxcbiAgICAgICAgICAgICAgICBjYW5MaW5lVGVybWluYXRvcjogcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3JbaWR4XSxcbiAgICAgICAgICAgICAgICBpc0N1c3RvbTogcGF0dGVybklkeFRvSXNDdXN0b21baWR4XSxcbiAgICAgICAgICAgICAgICBzaG9ydDogcGF0dGVybklkeFRvU2hvcnRbaWR4XSxcbiAgICAgICAgICAgICAgICBncm91cDogcGF0dGVybklkeFRvR3JvdXBbaWR4XSxcbiAgICAgICAgICAgICAgICBwdXNoOiBwYXR0ZXJuSWR4VG9QdXNoTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHBvcDogcGF0dGVybklkeFRvUG9wTW9kZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZUlkeDogcGF0dGVybklkeFRvVHlwZVtpZHhdLFxuICAgICAgICAgICAgICAgIHRva2VuVHlwZTogb25seVJlbGV2YW50VHlwZXNbaWR4XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBjYW5CZU9wdGltaXplZCA9IHRydWU7XG4gICAgbGV0IGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICBpZiAoIW9wdGlvbnMuc2FmZU1vZGUpIHtcbiAgICAgICAgdHJhY2VyKFwiRmlyc3QgQ2hhciBPcHRpbWl6YXRpb25cIiwgKCkgPT4ge1xuICAgICAgICAgICAgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9IHJlZHVjZShvbmx5UmVsZXZhbnRUeXBlcywgKHJlc3VsdCwgY3VyclRva1R5cGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3VyclRva1R5cGUuUEFUVEVSTiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IGN1cnJUb2tUeXBlLlBBVFRFUk4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW1pemVkSWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIG9wdGltaXplZElkeCwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KGN1cnJUb2tUeXBlLlNUQVJUX0NIQVJTX0hJTlQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0T3B0aW1pemVkSWR4O1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLlNUQVJUX0NIQVJTX0hJTlQsIChjaGFyT3JJbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJDb2RlID0gdHlwZW9mIGNoYXJPckludCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhck9ySW50LmNoYXJDb2RlQXQoMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGNoYXJPckludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJPcHRpbWl6ZWRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYWRkaW5nIHRoZSBjb25maWcgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtIERpZmZpY3VsdCB0byBjaGVjayB0aGlzIHNjZW5hcmlvIGVmZmVjdHMgYXMgaXQgaXMgb25seSBhIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIG9wdGltaXphdGlvbiB0aGF0IGRvZXMgbm90IGNoYW5nZSBjb3JyZWN0bmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RPcHRpbWl6ZWRJZHggIT09IGN1cnJPcHRpbWl6ZWRJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0T3B0aW1pemVkSWR4ID0gY3Vyck9wdGltaXplZElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgY3Vyck9wdGltaXplZElkeCwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAoY3VyclRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJUb2tUeXBlLlBBVFRFUk4udW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQUklOVF9FUlJPUihgJHtmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2d9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcXHRVbmFibGUgdG8gYW5hbHl6ZSA8ICR7Y3VyclRva1R5cGUuUEFUVEVSTi50b1N0cmluZygpfSA+IHBhdHRlcm4uXFxuYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhlIHJlZ2V4cCB1bmljb2RlIGZsYWcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHJlZ2V4cC10by1hc3QgbGlicmFyeS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTklDT0RFX09QVElNSVpFXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW1pemVkQ29kZXMgPSBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyhjdXJyVG9rVHlwZS5QQVRURVJOLCBvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBjb2RlIHdpbGwgb25seSBiZSBlbXB0eSBnaXZlbiBhbiBlbXB0eSByZWdFeHAgb3IgZmFpbHVyZSBvZiByZWdleHAtdG8tYXN0IGxpYnJhcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBzaG91bGQgYmUgYSBkaWZmZXJlbnQgdmFsaWRhdGlvbiBhbmQgdGhlIHNlY29uZCBjYW5ub3QgYmUgdGVzdGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkob3B0aW1pemVkQ29kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2Fubm90IHVuZGVyc3RhbmQgd2hhdCBjb2RlcyBtYXkgc3RhcnQgcG9zc2libGUgbWF0Y2hlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvcHRpbWl6YXRpb24gY29ycmVjdG5lc3MgcmVxdWlyZXMga25vd2luZyBzdGFydCBjb2RlcyBmb3IgQUxMIHBhdHRlcm5zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhY3R1YWxseSBzdXJlIHRoaXMgaXMgYW4gZXJyb3IsIG5vIGRlYnVnIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZU9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChvcHRpbWl6ZWRDb2RlcywgKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRUb01hcE9mQXJyYXlzKHJlc3VsdCwgY29kZSwgcGF0dGVybklkeFRvQ29uZmlnW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFBSSU5UX0VSUk9SKGAke2ZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZ31gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFx0VG9rZW5UeXBlOiA8JHtjdXJyVG9rVHlwZS5uYW1lfT4gaXMgdXNpbmcgYSBjdXN0b20gdG9rZW4gcGF0dGVybiB3aXRob3V0IHByb3ZpZGluZyA8c3RhcnRfY2hhcnNfaGludD4gcGFyYW1ldGVyLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9PUFRJTUlaRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYW5CZU9wdGltaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW1wdHlHcm91cHM6IGVtcHR5R3JvdXBzLFxuICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWc6IHBhdHRlcm5JZHhUb0NvbmZpZyxcbiAgICAgICAgY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZzogY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyxcbiAgICAgICAgaGFzQ3VzdG9tOiBoYXNDdXN0b20sXG4gICAgICAgIGNhbkJlT3B0aW1pemVkOiBjYW5CZU9wdGltaXplZCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVybnModG9rZW5UeXBlcywgdmFsaWRNb2Rlc05hbWVzKSB7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IG1pc3NpbmdSZXN1bHQgPSBmaW5kTWlzc2luZ1BhdHRlcm5zKHRva2VuVHlwZXMpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQobWlzc2luZ1Jlc3VsdC5lcnJvcnMpO1xuICAgIGNvbnN0IGludmFsaWRSZXN1bHQgPSBmaW5kSW52YWxpZFBhdHRlcm5zKG1pc3NpbmdSZXN1bHQudmFsaWQpO1xuICAgIGNvbnN0IHZhbGlkVG9rZW5UeXBlcyA9IGludmFsaWRSZXN1bHQudmFsaWQ7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChpbnZhbGlkUmVzdWx0LmVycm9ycyk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVJlZ0V4cFBhdHRlcm4odmFsaWRUb2tlblR5cGVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kSW52YWxpZEdyb3VwVHlwZSh2YWxpZFRva2VuVHlwZXMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRNb2Rlc1RoYXREb05vdEV4aXN0KHZhbGlkVG9rZW5UeXBlcywgdmFsaWRNb2Rlc05hbWVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kVW5yZWFjaGFibGVQYXR0ZXJucyh2YWxpZFRva2VuVHlwZXMpKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHRva2VuVHlwZXMpIHtcbiAgICBsZXQgZXJyb3JzID0gW107XG4gICAgY29uc3Qgd2l0aFJlZ0V4cFBhdHRlcm5zID0gZmlsdGVyKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4gaXNSZWdFeHAoY3VyclRva1R5cGVbUEFUVEVSTl0pKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRFbmRPZklucHV0QW5jaG9yKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRVbnN1cHBvcnRlZEZsYWdzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZER1cGxpY2F0ZVBhdHRlcm5zKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEVtcHR5TWF0Y2hSZWdFeHBzKHdpdGhSZWdFeHBQYXR0ZXJucykpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1pc3NpbmdQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiA9IGZpbHRlcih0b2tlblR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuICFoYXMoY3VyclR5cGUsIFBBVFRFUk4pO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcCh0b2tlblR5cGVzV2l0aE1pc3NpbmdQYXR0ZXJuLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBtaXNzaW5nIHN0YXRpYyAnUEFUVEVSTicgcHJvcGVydHlcIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NSVNTSU5HX1BBVFRFUk4sXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHZhbGlkID0gZGlmZmVyZW5jZSh0b2tlblR5cGVzLCB0b2tlblR5cGVzV2l0aE1pc3NpbmdQYXR0ZXJuKTtcbiAgICByZXR1cm4geyBlcnJvcnMsIHZhbGlkIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEludmFsaWRQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgdG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybiA9IGZpbHRlcih0b2tlblR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICByZXR1cm4gKCFpc1JlZ0V4cChwYXR0ZXJuKSAmJlxuICAgICAgICAgICAgIWlzRnVuY3Rpb24ocGF0dGVybikgJiZcbiAgICAgICAgICAgICFoYXMocGF0dGVybiwgXCJleGVjXCIpICYmXG4gICAgICAgICAgICAhaXNTdHJpbmcocGF0dGVybikpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcCh0b2tlblR5cGVzV2l0aEludmFsaWRQYXR0ZXJuLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbiBvbmx5IGJlIGEgUmVnRXhwLCBhXCIgK1xuICAgICAgICAgICAgICAgIFwiIEZ1bmN0aW9uIG1hdGNoaW5nIHRoZSB7Q3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jfSB0eXBlIG9yIGFuIE9iamVjdCBtYXRjaGluZyB0aGUge0lDdXN0b21QYXR0ZXJufSBpbnRlcmZhY2UuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB2YWxpZCA9IGRpZmZlcmVuY2UodG9rZW5UeXBlcywgdG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybik7XG4gICAgcmV0dXJuIHsgZXJyb3JzLCB2YWxpZCB9O1xufVxuY29uc3QgZW5kX29mX2lucHV0ID0gL1teXFxcXF1bJF0vO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbmRPZklucHV0QW5jaG9yKHRva2VuVHlwZXMpIHtcbiAgICBjbGFzcyBFbmRBbmNob3JGaW5kZXIgZXh0ZW5kcyBCYXNlUmVnRXhwVmlzaXRvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdEVuZEFuY2hvcihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnZhbGlkUmVnZXggPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyVHlwZS5QQVRURVJOO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwQXN0ID0gZ2V0UmVnRXhwQXN0KHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3QgZW5kQW5jaG9yVmlzaXRvciA9IG5ldyBFbmRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIGVuZEFuY2hvclZpc2l0b3IudmlzaXQocmVnZXhwQXN0KTtcbiAgICAgICAgICAgIHJldHVybiBlbmRBbmNob3JWaXNpdG9yLmZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBvbGQgYmVoYXZpb3IgaW4gY2FzZSBvZiBydW50aW1lIGV4Y2VwdGlvbnMgd2l0aCByZWdleHAtdG8tYXN0LlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBjYW5ub3QgZW5zdXJlIGFuIGVycm9yIGluIHJlZ2V4cC10by1hc3QqL1xuICAgICAgICAgICAgcmV0dXJuIGVuZF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChpbnZhbGlkUmVnZXgsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIGVuZCBvZiBpbnB1dCBhbmNob3IgJyQnXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGNoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjQU5DSE9SU1wiICtcbiAgICAgICAgICAgICAgICBcIlxcdGZvciBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVPSV9BTkNIT1JfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZEVtcHR5TWF0Y2hSZWdFeHBzKHRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBtYXRjaGVzRW1wdHlTdHJpbmcgPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyVHlwZS5QQVRURVJOO1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KFwiXCIpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChtYXRjaGVzRW1wdHlTdHJpbmcsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnUEFUVEVSTicgbXVzdCBub3QgbWF0Y2ggYW4gZW1wdHkgc3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuRU1QVFlfTUFUQ0hfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmNvbnN0IHN0YXJ0X29mX2lucHV0ID0gL1teXFxcXFtdW1xcXl18XlxcXi87XG5leHBvcnQgZnVuY3Rpb24gZmluZFN0YXJ0T2ZJbnB1dEFuY2hvcih0b2tlblR5cGVzKSB7XG4gICAgY2xhc3MgU3RhcnRBbmNob3JGaW5kZXIgZXh0ZW5kcyBCYXNlUmVnRXhwVmlzaXRvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdFN0YXJ0QW5jaG9yKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGludmFsaWRSZWdleCA9IGZpbHRlcih0b2tlblR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJUeXBlLlBBVFRFUk47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWdleHBBc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgICAgICBjb25zdCBzdGFydEFuY2hvclZpc2l0b3IgPSBuZXcgU3RhcnRBbmNob3JGaW5kZXIoKTtcbiAgICAgICAgICAgIHN0YXJ0QW5jaG9yVmlzaXRvci52aXNpdChyZWdleHBBc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0QW5jaG9yVmlzaXRvci5mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIGluIGNhc2Ugb2YgcnVudGltZSBleGNlcHRpb25zIHdpdGggcmVnZXhwLXRvLWFzdC5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2Fubm90IGVuc3VyZSBhbiBlcnJvciBpbiByZWdleHAtdG8tYXN0Ki9cbiAgICAgICAgICAgIHJldHVybiBzdGFydF9vZl9pbnB1dC50ZXN0KHBhdHRlcm4uc291cmNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChpbnZhbGlkUmVnZXgsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJVbmV4cGVjdGVkIFJlZ0V4cCBBbmNob3IgRXJyb3I6XFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIGNhbm5vdCBjb250YWluIHN0YXJ0IG9mIGlucHV0IGFuY2hvciAnXidcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWUgaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5TT0lfQU5DSE9SX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVbnN1cHBvcnRlZEZsYWdzKHRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBpbnZhbGlkRmxhZ3MgPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgKHBhdHRlcm4ubXVsdGlsaW5lIHx8IHBhdHRlcm4uZ2xvYmFsKTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAoaW52YWxpZEZsYWdzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG1heSBOT1QgY29udGFpbiBnbG9iYWwoJ2cnKSBvciBtdWx0aWxpbmUoJ20nKVwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8gVGhpcyBjYW4gb25seSB0ZXN0IGZvciBpZGVudGljYWwgZHVwbGljYXRlIFJlZ0V4cHMsIG5vdCBzZW1hbnRpY2FsbHkgZXF1aXZhbGVudCBvbmVzLlxuZXhwb3J0IGZ1bmN0aW9uIGZpbmREdXBsaWNhdGVQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgZm91bmQgPSBbXTtcbiAgICBsZXQgaWRlbnRpY2FsUGF0dGVybnMgPSBtYXAodG9rZW5UeXBlcywgKG91dGVyVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gcmVkdWNlKHRva2VuVHlwZXMsIChyZXN1bHQsIGlubmVyVHlwZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG91dGVyVHlwZS5QQVRURVJOLnNvdXJjZSA9PT0gaW5uZXJUeXBlLlBBVFRFUk4uc291cmNlICYmXG4gICAgICAgICAgICAgICAgIWluY2x1ZGVzKGZvdW5kLCBpbm5lclR5cGUpICYmXG4gICAgICAgICAgICAgICAgaW5uZXJUeXBlLlBBVFRFUk4gIT09IExleGVyLk5BKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBhdm9pZHMgZHVwbGljYXRlcyBpbiB0aGUgcmVzdWx0LCBlYWNoIFRva2VuIFR5cGUgbWF5IG9ubHkgYXBwZWFyIGluIG9uZSBcInNldFwiXG4gICAgICAgICAgICAgICAgLy8gaW4gZXNzZW5jZSB3ZSBhcmUgY3JlYXRpbmcgRXF1aXZhbGVuY2UgY2xhc3NlcyBvbiBlcXVhbGl0eSByZWxhdGlvbi5cbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKGlubmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaW5uZXJUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgW10pO1xuICAgIH0pO1xuICAgIGlkZW50aWNhbFBhdHRlcm5zID0gY29tcGFjdChpZGVudGljYWxQYXR0ZXJucyk7XG4gICAgY29uc3QgZHVwbGljYXRlUGF0dGVybnMgPSBmaWx0ZXIoaWRlbnRpY2FsUGF0dGVybnMsIChjdXJySWRlbnRpY2FsU2V0KSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJySWRlbnRpY2FsU2V0Lmxlbmd0aCA+IDE7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JzID0gbWFwKGR1cGxpY2F0ZVBhdHRlcm5zLCAoc2V0T2ZJZGVudGljYWwpID0+IHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlTmFtZXMgPSBtYXAoc2V0T2ZJZGVudGljYWwsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJUeXBlLm5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBkdXBQYXR0ZXJuU3JjID0gZmlyc3Qoc2V0T2ZJZGVudGljYWwpLlBBVFRFUk47XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgVGhlIHNhbWUgUmVnRXhwIHBhdHRlcm4gLT4ke2R1cFBhdHRlcm5TcmN9PC1gICtcbiAgICAgICAgICAgICAgICBgaGFzIGJlZW4gdXNlZCBpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBUb2tlbiBUeXBlczogJHt0b2tlblR5cGVOYW1lcy5qb2luKFwiLCBcIil9IDwtYCxcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBzZXRPZklkZW50aWNhbCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbnZhbGlkR3JvdXBUeXBlKHRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBpbnZhbGlkVHlwZXMgPSBmaWx0ZXIodG9rZW5UeXBlcywgKGNsYXp6KSA9PiB7XG4gICAgICAgIGlmICghaGFzKGNsYXp6LCBcIkdST1VQXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ3JvdXAgPSBjbGF6ei5HUk9VUDtcbiAgICAgICAgcmV0dXJuIGdyb3VwICE9PSBMZXhlci5TS0lQUEVEICYmIGdyb3VwICE9PSBMZXhlci5OQSAmJiAhaXNTdHJpbmcoZ3JvdXApO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChpbnZhbGlkVHlwZXMsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogXCJUb2tlbiBUeXBlOiAtPlwiICtcbiAgICAgICAgICAgICAgICBjdXJyVHlwZS5uYW1lICtcbiAgICAgICAgICAgICAgICBcIjwtIHN0YXRpYyAnR1JPVVAnIGNhbiBvbmx5IGJlIExleGVyLlNLSVBQRUQvTGV4ZXIuTkEvQSBTdHJpbmdcIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JTlZBTElEX0dST1VQX1RZUEVfRk9VTkQsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1vZGVzVGhhdERvTm90RXhpc3QodG9rZW5UeXBlcywgdmFsaWRNb2Rlcykge1xuICAgIGNvbnN0IGludmFsaWRNb2RlcyA9IGZpbHRlcih0b2tlblR5cGVzLCAoY2xhenopID0+IHtcbiAgICAgICAgcmV0dXJuIChjbGF6ei5QVVNIX01PREUgIT09IHVuZGVmaW5lZCAmJiAhaW5jbHVkZXModmFsaWRNb2RlcywgY2xhenouUFVTSF9NT0RFKSk7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JzID0gbWFwKGludmFsaWRNb2RlcywgKHRva1R5cGUpID0+IHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRva2VuIFR5cGU6IC0+JHt0b2tUeXBlLm5hbWV9PC0gc3RhdGljICdQVVNIX01PREUnIHZhbHVlIGNhbm5vdCByZWZlciB0byBhIExleGVyIE1vZGUgLT4ke3Rva1R5cGUuUFVTSF9NT0RFfTwtYCArXG4gICAgICAgICAgICBgd2hpY2ggZG9lcyBub3QgZXhpc3RgO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFt0b2tUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRVbnJlYWNoYWJsZVBhdHRlcm5zKHRva2VuVHlwZXMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjYW5CZVRlc3RlZCA9IHJlZHVjZSh0b2tlblR5cGVzLCAocmVzdWx0LCB0b2tUeXBlLCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHRva1R5cGUuUEFUVEVSTjtcbiAgICAgICAgaWYgKHBhdHRlcm4gPT09IExleGVyLk5BKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgbW9yZSBjb21wcmVoZW5zaXZlIHZhbGlkYXRpb24gZm9yIGFsbCBmb3JtcyBvZiByZWdFeHBzIHdvdWxkIHJlcXVpcmVcbiAgICAgICAgLy8gZGVlcGVyIHJlZ0V4cCBhbmFseXNpcyBjYXBhYmlsaXRpZXNcbiAgICAgICAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh7IHN0cjogcGF0dGVybiwgaWR4LCB0b2tlblR5cGU6IHRva1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikgJiYgbm9NZXRhQ2hhcihwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4uc291cmNlLCBpZHgsIHRva2VuVHlwZTogdG9rVHlwZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsICh0b2tUeXBlLCB0ZXN0SWR4KSA9PiB7XG4gICAgICAgIGZvckVhY2goY2FuQmVUZXN0ZWQsICh7IHN0ciwgaWR4LCB0b2tlblR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRlc3RJZHggPCBpZHggJiYgdGVzdFRva2VuVHlwZShzdHIsIHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVG9rZW46IC0+JHt0b2tlblR5cGUubmFtZX08LSBjYW4gbmV2ZXIgYmUgbWF0Y2hlZC5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYEJlY2F1c2UgaXQgYXBwZWFycyBBRlRFUiB0aGUgVG9rZW4gVHlwZSAtPiR7dG9rVHlwZS5uYW1lfTwtYCArXG4gICAgICAgICAgICAgICAgICAgIGBpbiB0aGUgbGV4ZXIncyBkZWZpbml0aW9uLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICBgU2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNVTlJFQUNIQUJMRWA7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFQUNIQUJMRV9QQVRURVJOLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiBbdG9rVHlwZSwgdG9rZW5UeXBlXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHRlc3RUb2tlblR5cGUoc3RyLCBwYXR0ZXJuKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgICAgY29uc3QgcmVnRXhwQXJyYXkgPSBwYXR0ZXJuLmV4ZWMoc3RyKTtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cEFycmF5ICE9PSBudWxsICYmIHJlZ0V4cEFycmF5LmluZGV4ID09PSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHBhdHRlcm4pKSB7XG4gICAgICAgIC8vIG1haW50YWluIHRoZSBBUEkgb2YgY3VzdG9tIHBhdHRlcm5zXG4gICAgICAgIHJldHVybiBwYXR0ZXJuKHN0ciwgMCwgW10sIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAvLyBtYWludGFpbiB0aGUgQVBJIG9mIGN1c3RvbSBwYXR0ZXJuc1xuICAgICAgICByZXR1cm4gcGF0dGVybi5leGVjKHN0ciwgMCwgW10sIHt9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPT09IHN0cjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9NZXRhQ2hhcihyZWdFeHApIHtcbiAgICAvL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1JlZ0V4cFxuICAgIGNvbnN0IG1ldGFDaGFycyA9IFtcbiAgICAgICAgXCIuXCIsXG4gICAgICAgIFwiXFxcXFwiLFxuICAgICAgICBcIltcIixcbiAgICAgICAgXCJdXCIsXG4gICAgICAgIFwifFwiLFxuICAgICAgICBcIl5cIixcbiAgICAgICAgXCIkXCIsXG4gICAgICAgIFwiKFwiLFxuICAgICAgICBcIilcIixcbiAgICAgICAgXCI/XCIsXG4gICAgICAgIFwiKlwiLFxuICAgICAgICBcIitcIixcbiAgICAgICAgXCJ7XCIsXG4gICAgXTtcbiAgICByZXR1cm4gKGZpbmQobWV0YUNoYXJzLCAoY2hhcikgPT4gcmVnRXhwLnNvdXJjZS5pbmRleE9mKGNoYXIpICE9PSAtMSkgPT09IHVuZGVmaW5lZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkU3RhcnRPZklucHV0KHBhdHRlcm4pIHtcbiAgICBjb25zdCBmbGFncyA9IHBhdHRlcm4uaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIjtcbiAgICAvLyBhbHdheXMgd3JhcHBpbmcgaW4gYSBub25lIGNhcHR1cmluZyBncm91cCBwcmVjZWRlZCBieSAnXicgdG8gbWFrZSBzdXJlIG1hdGNoaW5nIGNhbiBvbmx5IHdvcmsgb24gc3RhcnQgb2YgaW5wdXQuXG4gICAgLy8gZHVwbGljYXRlL3JlZHVuZGFudCBzdGFydCBvZiBpbnB1dCBtYXJrZXJzIGhhdmUgbm8gbWVhbmluZyAoL15eXl5BLyA9PT0gL15BLylcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OiR7cGF0dGVybi5zb3VyY2V9KWAsIGZsYWdzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRTdGlja3lGbGFnKHBhdHRlcm4pIHtcbiAgICBjb25zdCBmbGFncyA9IHBhdHRlcm4uaWdub3JlQ2FzZSA/IFwiaXlcIiA6IFwieVwiO1xuICAgIC8vIGFsd2F5cyB3cmFwcGluZyBpbiBhIG5vbmUgY2FwdHVyaW5nIGdyb3VwIHByZWNlZGVkIGJ5ICdeJyB0byBtYWtlIHN1cmUgbWF0Y2hpbmcgY2FuIG9ubHkgd29yayBvbiBzdGFydCBvZiBpbnB1dC5cbiAgICAvLyBkdXBsaWNhdGUvcmVkdW5kYW50IHN0YXJ0IG9mIGlucHV0IG1hcmtlcnMgaGF2ZSBubyBtZWFuaW5nICgvXl5eXkEvID09PSAvXkEvKVxuICAgIHJldHVybiBuZXcgUmVnRXhwKGAke3BhdHRlcm4uc291cmNlfWAsIGZsYWdzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJmb3JtUnVudGltZUNoZWNrcyhsZXhlckRlZmluaXRpb24sIHRyYWNrTGluZXMsIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIC8vIHNvbWUgcnVuIHRpbWUgY2hlY2tzIHRvIGhlbHAgdGhlIGVuZCB1c2Vycy5cbiAgICBpZiAoIWhhcyhsZXhlckRlZmluaXRpb24sIERFRkFVTFRfTU9ERSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIiArXG4gICAgICAgICAgICAgICAgREVGQVVMVF9NT0RFICtcbiAgICAgICAgICAgICAgICBcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJBIE11bHRpTW9kZSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgd2l0aG91dCBhIDxcIiArXG4gICAgICAgICAgICAgICAgTU9ERVMgK1xuICAgICAgICAgICAgICAgIFwiPiBwcm9wZXJ0eSBpbiBpdHMgZGVmaW5pdGlvblxcblwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykgJiZcbiAgICAgICAgaGFzKGxleGVyRGVmaW5pdGlvbiwgREVGQVVMVF9NT0RFKSAmJlxuICAgICAgICAhaGFzKGxleGVyRGVmaW5pdGlvbi5tb2RlcywgbGV4ZXJEZWZpbml0aW9uLmRlZmF1bHRNb2RlKSkge1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGggYSAke0RFRkFVTFRfTU9ERX06IDwke2xleGVyRGVmaW5pdGlvbi5kZWZhdWx0TW9kZX0+YCArXG4gICAgICAgICAgICAgICAgYHdoaWNoIGRvZXMgbm90IGV4aXN0XFxuYCxcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX0RFRkFVTFRfTU9ERV9WQUxVRV9ET0VTX05PVF9FWElTVCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChoYXMobGV4ZXJEZWZpbml0aW9uLCBNT0RFUykpIHtcbiAgICAgICAgZm9yRWFjaChsZXhlckRlZmluaXRpb24ubW9kZXMsIChjdXJyTW9kZVZhbHVlLCBjdXJyTW9kZU5hbWUpID0+IHtcbiAgICAgICAgICAgIGZvckVhY2goY3Vyck1vZGVWYWx1ZSwgKGN1cnJUb2tUeXBlLCBjdXJySWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGN1cnJUb2tUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQSBMZXhlciBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQgdXNpbmcgYW4gdW5kZWZpbmVkIFRva2VuIFR5cGUuIE1vZGU6YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDwke2N1cnJNb2RlTmFtZX0+IGF0IGluZGV4OiA8JHtjdXJySWR4fT5cXG5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVELFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzKGN1cnJUb2tUeXBlLCBcIkxPTkdFUl9BTFRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9uZ2VyQWx0ID0gaXNBcnJheShjdXJyVG9rVHlwZS5MT05HRVJfQUxUKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjdXJyVG9rVHlwZS5MT05HRVJfQUxUXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtjdXJyVG9rVHlwZS5MT05HRVJfQUxUXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChsb25nZXJBbHQsIChjdXJyTG9uZ2VyQWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGN1cnJMb25nZXJBbHQpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzKGN1cnJNb2RlVmFsdWUsIGN1cnJMb25nZXJBbHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGggYSBsb25nZXJfYWx0IDwke2N1cnJMb25nZXJBbHQubmFtZX0+IG9uIHRva2VuIDwke2N1cnJUb2tUeXBlLm5hbWV9PiBvdXRzaWRlIG9mIG1vZGUgPCR7Y3Vyck1vZGVOYW1lfT5cXG5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9MT05HRVJfQUxUX05PVF9JTl9DVVJSRU5UX01PREUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MobGV4ZXJEZWZpbml0aW9uLCB0cmFja0xpbmVzLCBsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICAgIGxldCBoYXNBbnlMaW5lQnJlYWsgPSBmYWxzZTtcbiAgICBjb25zdCBhbGxUb2tlblR5cGVzID0gY29tcGFjdChmbGF0dGVuKHZhbHVlcyhsZXhlckRlZmluaXRpb24ubW9kZXMpKSk7XG4gICAgY29uc3QgY29uY3JldGVUb2tlblR5cGVzID0gcmVqZWN0KGFsbFRva2VuVHlwZXMsIChjdXJyVHlwZSkgPT4gY3VyclR5cGVbUEFUVEVSTl0gPT09IExleGVyLk5BKTtcbiAgICBjb25zdCB0ZXJtaW5hdG9yQ2hhckNvZGVzID0gZ2V0Q2hhckNvZGVzKGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyk7XG4gICAgaWYgKHRyYWNrTGluZXMpIHtcbiAgICAgICAgZm9yRWFjaChjb25jcmV0ZVRva2VuVHlwZXMsICh0b2tUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJySXNzdWUgPSBjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgdGVybWluYXRvckNoYXJDb2Rlcyk7XG4gICAgICAgICAgICBpZiAoY3Vycklzc3VlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZSh0b2tUeXBlLCBjdXJySXNzdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdEZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBjdXJySXNzdWUuaXNzdWUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZTogdG9rVHlwZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdhcm5pbmdzLnB1c2god2FybmluZ0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBhdHRlbXB0IHRvIHNjYW4gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBzcGVjaWZpZWQgdGhlIGxpbmVfYnJlYWtzIG9wdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva1R5cGUuTElORV9CUkVBS1MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FueUxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5NYXRjaENoYXJDb2RlKHRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0FueUxpbmVCcmVhayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHJhY2tMaW5lcyAmJiAhaGFzQW55TGluZUJyZWFrKSB7XG4gICAgICAgIHdhcm5pbmdzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJXYXJuaW5nOiBObyBMSU5FX0JSRUFLUyBGb3VuZC5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRUaGlzIExleGVyIGhhcyBiZWVuIGRlZmluZWQgdG8gdHJhY2sgbGluZSBhbmQgY29sdW1uIGluZm9ybWF0aW9uLFxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdEJ1dCBub25lIG9mIHRoZSBUb2tlbiBUeXBlcyBjYW4gYmUgaWRlbnRpZmllZCBhcyBtYXRjaGluZyBhIGxpbmUgdGVybWluYXRvci5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRTZWUgaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0xJTkVfQlJFQUtTIFxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdGZvciBkZXRhaWxzLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk5PX0xJTkVfQlJFQUtTX0ZMQUdTLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdhcm5pbmdzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRW1wdHlHcm91cHMoZW1wdHlHcm91cHMpIHtcbiAgICBjb25zdCBjbG9uZWRSZXN1bHQgPSB7fTtcbiAgICBjb25zdCBncm91cEtleXMgPSBrZXlzKGVtcHR5R3JvdXBzKTtcbiAgICBmb3JFYWNoKGdyb3VwS2V5cywgKGN1cnJLZXkpID0+IHtcbiAgICAgICAgY29uc3QgY3Vyckdyb3VwVmFsdWUgPSBlbXB0eUdyb3Vwc1tjdXJyS2V5XTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzQXJyYXkoY3Vyckdyb3VwVmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRSZXN1bHRbY3VycktleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmVkUmVzdWx0O1xufVxuLy8gVE9ETzogcmVmYWN0b3IgdG8gYXZvaWQgZHVwbGljYXRpb25cbmV4cG9ydCBmdW5jdGlvbiBpc0N1c3RvbVBhdHRlcm4odG9rZW5UeXBlKSB7XG4gICAgY29uc3QgcGF0dGVybiA9IHRva2VuVHlwZS5QQVRURVJOO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwYXR0ZXJuKSkge1xuICAgICAgICAvLyBDdXN0b21QYXR0ZXJuTWF0Y2hlckZ1bmMgLSBjdXN0b20gcGF0dGVybnMgZG8gbm90IHJlcXVpcmUgYW55IHRyYW5zZm9ybWF0aW9ucywgb25seSB3cmFwcGluZyBpbiBhIFJlZ0V4cCBMaWtlIG9iamVjdFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSkge1xuICAgICAgICAvLyBJQ3VzdG9tUGF0dGVyblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdHJpbmcocGF0dGVybikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTaG9ydFBhdHRlcm4ocGF0dGVybikge1xuICAgIGlmIChpc1N0cmluZyhwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGF0dGVybi5jaGFyQ29kZUF0KDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogRmFzdGVyIHRoYW4gdXNpbmcgYSBSZWdFeHAgZm9yIGRlZmF1bHQgbmV3bGluZSBkZXRlY3Rpb24gZHVyaW5nIGxleGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyID0ge1xuICAgIC8vIGltcGxlbWVudHMgL1xcbnxcXHJcXG4/L2cudGVzdFxuICAgIHRlc3Q6IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5sYXN0SW5kZXg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYyA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjID09PSAxMCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAxMykge1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09PSAxMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgbGFzdEluZGV4OiAwLFxufTtcbmZ1bmN0aW9uIGNoZWNrTGluZUJyZWFrc0lzc3Vlcyh0b2tUeXBlLCBsaW5lVGVybWluYXRvckNoYXJDb2Rlcykge1xuICAgIGlmIChoYXModG9rVHlwZSwgXCJMSU5FX0JSRUFLU1wiKSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBleHBsaWNpdGx5IGRlY2xhcmVkIHRoZSBsaW5lX2JyZWFrcyBvcHRpb24gd2Ugd2lsbCByZXNwZWN0IHRoZWlyIGNob2ljZVxuICAgICAgICAvLyBhbmQgYXNzdW1lIGl0IGlzIGNvcnJlY3QuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc1JlZ0V4cCh0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoeSBpcyB0aGUgY2FzdGluZyBzdWRkZW5seSBuZWVkZWQ/XG4gICAgICAgICAgICAgICAgY2FuTWF0Y2hDaGFyQ29kZShsaW5lVGVybWluYXRvckNoYXJDb2RlcywgdG9rVHlwZS5QQVRURVJOKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSB0byB0ZXN0IHRoaXMgd2Ugd291bGQgaGF2ZSB0byBtb2NrIDxjYW5NYXRjaENoYXJDb2RlPiB0byB0aHJvdyBhbiBlcnJvciAqL1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSURFTlRJRllfVEVSTUlOQVRPUixcbiAgICAgICAgICAgICAgICAgICAgZXJyTXNnOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyh0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAvLyBzdHJpbmcgbGl0ZXJhbCBwYXR0ZXJucyBjYW4gYWx3YXlzIGJlIGFuYWx5emVkIHRvIGRldGVjdCBsaW5lIHRlcm1pbmF0b3IgdXNhZ2VcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0N1c3RvbVBhdHRlcm4odG9rVHlwZSkpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbSB0b2tlbiB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIHsgaXNzdWU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBSyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpbmVCcmVha0lzc3VlTWVzc2FnZSh0b2tUeXBlLCBkZXRhaWxzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZGV0YWlscy5pc3N1ZSA9PT0gTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IpIHtcbiAgICAgICAgcmV0dXJuIChcIldhcm5pbmc6IHVuYWJsZSB0byBpZGVudGlmeSBsaW5lIHRlcm1pbmF0b3IgdXNhZ2UgaW4gcGF0dGVybi5cXG5cIiArXG4gICAgICAgICAgICBgXFx0VGhlIHByb2JsZW0gaXMgaW4gdGhlIDwke3Rva1R5cGUubmFtZX0+IFRva2VuIFR5cGVcXG5gICtcbiAgICAgICAgICAgIGBcXHQgUm9vdCBjYXVzZTogJHtkZXRhaWxzLmVyck1zZ30uXFxuYCArXG4gICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0lERU5USUZZX1RFUk1JTkFUT1JcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRldGFpbHMuaXNzdWUgPT09IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTElORV9CUkVBSykge1xuICAgICAgICByZXR1cm4gKFwiV2FybmluZzogQSBDdXN0b20gVG9rZW4gUGF0dGVybiBzaG91bGQgc3BlY2lmeSB0aGUgPGxpbmVfYnJlYWtzPiBvcHRpb24uXFxuXCIgK1xuICAgICAgICAgICAgYFxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8JHt0b2tUeXBlLm5hbWV9PiBUb2tlbiBUeXBlXFxuYCArXG4gICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NVU1RPTV9MSU5FX0JSRUFLXCIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDaGFyQ29kZXMoY2hhcnNPckNvZGVzKSB7XG4gICAgY29uc3QgY2hhckNvZGVzID0gbWFwKGNoYXJzT3JDb2RlcywgKG51bU9yU3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChpc1N0cmluZyhudW1PclN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1PclN0cmluZy5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bU9yU3RyaW5nO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYXJDb2Rlcztcbn1cbmZ1bmN0aW9uIGFkZFRvTWFwT2ZBcnJheXMobWFwLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKG1hcFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWFwW2tleV0gPSBbdmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWFwW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IG1pbk9wdGltaXphdGlvblZhbCA9IDI1Njtcbi8qKlxuICogV2UgYXJlIG1hcHBpbmcgY2hhckNvZGUgYWJvdmUgQVNDSSAoMjU2KSBpbnRvIGJ1Y2tldHMgZWFjaCBpbiB0aGUgc2l6ZSBvZiAyNTYuXG4gKiBUaGlzIGlzIGJlY2F1c2UgQVNDSSBhcmUgdGhlIG1vc3QgY29tbW9uIHN0YXJ0IGNoYXJzIHNvIGVhY2ggb25lIG9mIHRob3NlIHdpbGwgZ2V0IGl0cyBvd25cbiAqIHBvc3NpYmxlIHRva2VuIGNvbmZpZ3MgdmVjdG9yLlxuICpcbiAqIFRva2VucyBzdGFydGluZyB3aXRoIGNoYXJDb2RlcyBcImFib3ZlXCIgQVNDSSBhcmUgdW5jb21tb24sIHNvIHdlIGNhbiBcImFmZm9yZFwiXG4gKiB0byBwbGFjZSB0aGVzZSBpbnRvIGJ1Y2tldHMgb2YgcG9zc2libGUgdG9rZW4gY29uZmlncywgV2hhdCB3ZSBnYWluIGZyb21cbiAqIHRoaXMgaXMgYXZvaWRpbmcgdGhlIGNhc2Ugb2YgY3JlYXRpbmcgYW4gb3B0aW1pemF0aW9uICdjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnJ1xuICogd2hpY2ggd291bGQgY29udGFpbiAxMCwwMDArIGFycmF5cyBvZiBzbWFsbCBzaXplIChlLmcgdW5pY29kZSBJZGVudGlmaWVycyBzY2VuYXJpbykuXG4gKiBPdXIgJ2NoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcnIG1heCBzaXplIHdpbGwgbm93IGJlOlxuICogMjU2ICsgKDJeMTYgLyAyXjgpIC0gMSA9PT0gNTExXG4gKlxuICogbm90ZSB0aGUgaGFjayBmb3IgZmFzdCBkaXZpc2lvbiBpbnRlZ2VyIHBhcnQgZXh0cmFjdGlvblxuICogU2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDIyODUyOFxuICovXG5sZXQgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSkge1xuICAgIHJldHVybiBjaGFyQ29kZSA8IG1pbk9wdGltaXphdGlvblZhbFxuICAgICAgICA/IGNoYXJDb2RlXG4gICAgICAgIDogY2hhckNvZGVUb09wdGltaXplZElkeE1hcFtjaGFyQ29kZV07XG59XG4vKipcbiAqIFRoaXMgaXMgYSBjb21wcm9taXNlIGJldHdlZW4gY29sZCBzdGFydCAvIGhvdCBydW5uaW5nIHBlcmZvcm1hbmNlXG4gKiBDcmVhdGluZyB0aGlzIGFycmF5IHRha2VzIH4zbXMgb24gYSBtb2Rlcm4gbWFjaGluZSxcbiAqIEJ1dCBpZiB3ZSBwZXJmb3JtIHRoZSBjb21wdXRhdGlvbiBhdCBydW50aW1lIGFzIG5lZWRlZCB0aGUgQ1NTIExleGVyIGJlbmNobWFya1xuICogcGVyZm9ybWFuY2UgZGVncmFkZXMgYnkgfjEwJVxuICpcbiAqIFRPRE86IFBlcmhhcHMgaXQgc2hvdWxkIGJlIGxhenkgaW5pdGlhbGl6ZWQgb25seSBpZiBhIGNoYXJDb2RlID4gMjU1IGlzIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGluaXRDaGFyQ29kZVRvT3B0aW1pemVkSW5kZXhNYXAoKSB7XG4gICAgaWYgKGlzRW1wdHkoY2hhckNvZGVUb09wdGltaXplZElkeE1hcCkpIHtcbiAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcCA9IG5ldyBBcnJheSg2NTUzNik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgICAgICAgICAgY2hhckNvZGVUb09wdGltaXplZElkeE1hcFtpXSA9IGkgPiAyNTUgPyAyNTUgKyB+fihpIC8gMjU1KSA6IGk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlci5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gdGltZXIoZnVuYykge1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdmFsID0gZnVuYygpO1xuICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGNvbnN0IHRvdGFsID0gZW5kIC0gc3RhcnQ7XG4gICAgcmV0dXJuIHsgdGltZTogdG90YWwsIHZhbHVlOiB2YWwgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcCIsImltcG9ydCB7IGNsb25lLCBjb21wYWN0LCBkaWZmZXJlbmNlLCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGluY2x1ZGVzLCBpc0FycmF5LCBpc0VtcHR5LCBtYXAsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gdG9rSW5zdGFuY2UudG9rZW5UeXBlSWR4O1xuICAgIGlmIChpbnN0YW5jZVR5cGUgPT09IHRva0NvbnN0cnVjdG9yLnRva2VuVHlwZUlkeCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAodG9rQ29uc3RydWN0b3IuaXNQYXJlbnQgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRva0NvbnN0cnVjdG9yLmNhdGVnb3J5TWF0Y2hlc01hcFtpbnN0YW5jZVR5cGVdID09PSB0cnVlKTtcbiAgICB9XG59XG4vLyBPcHRpbWl6ZWQgdG9rZW5NYXRjaGVyIGluIGNhc2Ugb3VyIGdyYW1tYXIgZG9lcyBub3QgdXNlIHRva2VuIGNhdGVnb3JpZXNcbi8vIEJlaW5nIHNvIHRpbnkgaXQgaXMgbXVjaCBtb3JlIGxpa2VseSB0byBiZSBpbi1saW5lZCBhbmQgdGhpcyBhdm9pZCB0aGUgZnVuY3Rpb24gY2FsbCBvdmVyaGVhZFxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXModG9rZW4sIHRva1R5cGUpIHtcbiAgICByZXR1cm4gdG9rZW4udG9rZW5UeXBlSWR4ID09PSB0b2tUeXBlLnRva2VuVHlwZUlkeDtcbn1cbmV4cG9ydCBsZXQgdG9rZW5TaG9ydE5hbWVJZHggPSAxO1xuZXhwb3J0IGNvbnN0IHRva2VuSWR4VG9DbGFzcyA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnRUb2tlblR5cGVzKHRva2VuVHlwZXMpIHtcbiAgICAvLyBjb2xsZWN0IHRoZSBwYXJlbnQgVG9rZW4gVHlwZXMgYXMgd2VsbC5cbiAgICBjb25zdCB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXNBbmRQYXJlbnRzLCAodG9rVHlwZSkgPT4ge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRDYXRlZ29yaWVzKHRva2VuVHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gY2xvbmUodG9rZW5UeXBlcyk7XG4gICAgbGV0IGNhdGVnb3JpZXMgPSB0b2tlblR5cGVzO1xuICAgIGxldCBzZWFyY2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChzZWFyY2hpbmcpIHtcbiAgICAgICAgY2F0ZWdvcmllcyA9IGNvbXBhY3QoZmxhdHRlbihtYXAoY2F0ZWdvcmllcywgKGN1cnJUb2tUeXBlKSA9PiBjdXJyVG9rVHlwZS5DQVRFR09SSUVTKSkpO1xuICAgICAgICBjb25zdCBuZXdDYXRlZ29yaWVzID0gZGlmZmVyZW5jZShjYXRlZ29yaWVzLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KG5ld0NhdGVnb3JpZXMpO1xuICAgICAgICBpZiAoaXNFbXB0eShuZXdDYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgc2VhcmNoaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gbmV3Q2F0ZWdvcmllcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblRva2VuRGVmYXVsdFByb3BzKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICBpZiAoIWhhc1Nob3J0S2V5UHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICB0b2tlbklkeFRvQ2xhc3NbdG9rZW5TaG9ydE5hbWVJZHhdID0gY3VyclRva1R5cGU7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS50b2tlblR5cGVJZHggPSB0b2tlblNob3J0TmFtZUlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENBVEVHT1JJRVM/IDogVG9rZW5UeXBlIHwgVG9rZW5UeXBlW11cbiAgICAgICAgaWYgKGhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkgJiZcbiAgICAgICAgICAgICFpc0FycmF5KGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMpXG4gICAgICAgIC8vICYmXG4gICAgICAgIC8vICFpc1VuZGVmaW5lZChjdXJyVG9rVHlwZS5DQVRFR09SSUVTLlBBVFRFUk4pXG4gICAgICAgICkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuQ0FURUdPUklFUyA9IFtjdXJyVG9rVHlwZS5DQVRFR09SSUVTXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGlvbnNcbiAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzID0gW107XG4gICAgICAgIGZvckVhY2goY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcy5wdXNoKHRva2VuSWR4VG9DbGFzc1trZXldLnRva2VuVHlwZUlkeCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChbXSwgY3VyclRva1R5cGUpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwKHBhdGgsIG5leHROb2RlKSB7XG4gICAgZm9yRWFjaChwYXRoLCAocGF0aE5vZGUpID0+IHtcbiAgICAgICAgbmV4dE5vZGUuY2F0ZWdvcnlNYXRjaGVzTWFwW3BhdGhOb2RlLnRva2VuVHlwZUlkeF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGZvckVhY2gobmV4dE5vZGUuQ0FURUdPUklFUywgKG5leHRDYXRlZ29yeSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5jb25jYXQobmV4dE5vZGUpO1xuICAgICAgICAvLyBhdm9pZHMgaW5maW5pdGUgbG9vcHMgZHVlIHRvIGN5Y2xpYyBjYXRlZ29yaWVzLlxuICAgICAgICBpZiAoIWluY2x1ZGVzKG5ld1BhdGgsIG5leHRDYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIHNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwKG5ld1BhdGgsIG5leHRDYXRlZ29yeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNTaG9ydEtleVByb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwidG9rZW5UeXBlSWR4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NhdGVnb3JpZXNQcm9wZXJ0eSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIGhhcyh0b2tUeXBlLCBcIkNBVEVHT1JJRVNcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIGhhcyh0b2tUeXBlLCBcImNhdGVnb3J5TWF0Y2hlc1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzTWFwXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5UeXBlKHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwidG9rZW5UeXBlSWR4XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW5zLmpzLm1hcCIsImV4cG9ydCBjb25zdCBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkVW5hYmxlVG9Qb3BMZXhlck1vZGVNZXNzYWdlKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIHBvcCBMZXhlciBNb2RlIGFmdGVyIGVuY291bnRlcmluZyBUb2tlbiAtPiR7dG9rZW4uaW1hZ2V9PC0gVGhlIE1vZGUgU3RhY2sgaXMgZW1wdHlgO1xuICAgIH0sXG4gICAgYnVpbGRVbmV4cGVjdGVkQ2hhcmFjdGVyc01lc3NhZ2UoZnVsbFRleHQsIHN0YXJ0T2Zmc2V0LCBsZW5ndGgsIGxpbmUsIGNvbHVtbikge1xuICAgICAgICByZXR1cm4gKGB1bmV4cGVjdGVkIGNoYXJhY3RlcjogLT4ke2Z1bGxUZXh0LmNoYXJBdChzdGFydE9mZnNldCl9PC0gYXQgb2Zmc2V0OiAke3N0YXJ0T2Zmc2V0fSxgICsgYCBza2lwcGVkICR7bGVuZ3RofSBjaGFyYWN0ZXJzLmApO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfZXJyb3JzX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBhbmFseXplVG9rZW5UeXBlcywgY2hhckNvZGVUb09wdGltaXplZEluZGV4LCBjbG9uZUVtcHR5R3JvdXBzLCBERUZBVUxUX01PREUsIExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyLCBwZXJmb3JtUnVudGltZUNoZWNrcywgcGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzLCBTVVBQT1JUX1NUSUNLWSwgdmFsaWRhdGVQYXR0ZXJucywgfSBmcm9tIFwiLi9sZXhlci5qc1wiO1xuaW1wb3J0IHsgYXNzaWduLCBjbG9uZSwgZm9yRWFjaCwgaWRlbnRpdHksIGlzQXJyYXksIGlzRW1wdHksIGlzVW5kZWZpbmVkLCBrZXlzLCBsYXN0LCBtYXAsIG5vb3AsIHJlZHVjZSwgcmVqZWN0LCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IFBSSU5UX1dBUk5JTkcsIHRpbWVyLCB0b0Zhc3RQcm9wZXJ0aWVzIH0gZnJvbSBcIkBjaGV2cm90YWluL3V0aWxzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcyB9IGZyb20gXCIuL3Rva2Vucy5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdExleGVyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuL2xleGVyX2Vycm9yc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlci5qc1wiO1xuZXhwb3J0IHZhciBMZXhlckRlZmluaXRpb25FcnJvclR5cGU7XG4oZnVuY3Rpb24gKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSkge1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNSVNTSU5HX1BBVFRFUk5cIl0gPSAwXSA9IFwiTUlTU0lOR19QQVRURVJOXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfUEFUVEVSTlwiXSA9IDFdID0gXCJJTlZBTElEX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRU9JX0FOQ0hPUl9GT1VORFwiXSA9IDJdID0gXCJFT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCJdID0gM10gPSBcIlVOU1VQUE9SVEVEX0ZMQUdTX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiXSA9IDRdID0gXCJEVVBMSUNBVEVfUEFUVEVSTlNfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCJdID0gNV0gPSBcIklOVkFMSURfR1JPVVBfVFlQRV9GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIl0gPSA2XSA9IFwiUFVTSF9NT0RFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9ERUZBVUxUX01PREVcIl0gPSA3XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIl0gPSA4XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX01PREVTX1BST1BFUlRZXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCJdID0gOV0gPSBcIk1VTFRJX01PREVfTEVYRVJfREVGQVVMVF9NT0RFX1ZBTFVFX0RPRVNfTk9UX0VYSVNUXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCJdID0gMTBdID0gXCJMRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJTT0lfQU5DSE9SX0ZPVU5EXCJdID0gMTFdID0gXCJTT0lfQU5DSE9SX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkVNUFRZX01BVENIX1BBVFRFUk5cIl0gPSAxMl0gPSBcIkVNUFRZX01BVENIX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9fTElORV9CUkVBS1NfRkxBR1NcIl0gPSAxM10gPSBcIk5PX0xJTkVfQlJFQUtTX0ZMQUdTXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIl0gPSAxNF0gPSBcIlVOUkVBQ0hBQkxFX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSURFTlRJRllfVEVSTUlOQVRPUlwiXSA9IDE1XSA9IFwiSURFTlRJRllfVEVSTUlOQVRPUlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJDVVNUT01fTElORV9CUkVBS1wiXSA9IDE2XSA9IFwiQ1VTVE9NX0xJTkVfQlJFQUtcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9MT05HRVJfQUxUX05PVF9JTl9DVVJSRU5UX01PREVcIl0gPSAxN10gPSBcIk1VTFRJX01PREVfTEVYRVJfTE9OR0VSX0FMVF9OT1RfSU5fQ1VSUkVOVF9NT0RFXCI7XG59KShMZXhlckRlZmluaXRpb25FcnJvclR5cGUgfHwgKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSA9IHt9KSk7XG5jb25zdCBERUZBVUxUX0xFWEVSX0NPTkZJRyA9IHtcbiAgICBkZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZzogZmFsc2UsXG4gICAgcG9zaXRpb25UcmFja2luZzogXCJmdWxsXCIsXG4gICAgbGluZVRlcm1pbmF0b3JzUGF0dGVybjogL1xcbnxcXHJcXG4/L2csXG4gICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBbXCJcXG5cIiwgXCJcXHJcIl0sXG4gICAgZW5zdXJlT3B0aW1pemF0aW9uczogZmFsc2UsXG4gICAgc2FmZU1vZGU6IGZhbHNlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLFxuICAgIHRyYWNlSW5pdFBlcmY6IGZhbHNlLFxuICAgIHNraXBWYWxpZGF0aW9uczogZmFsc2UsXG4gICAgcmVjb3ZlcnlFbmFibGVkOiB0cnVlLFxufTtcbk9iamVjdC5mcmVlemUoREVGQVVMVF9MRVhFUl9DT05GSUcpO1xuZXhwb3J0IGNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcihsZXhlckRlZmluaXRpb24sIGNvbmZpZyA9IERFRkFVTFRfTEVYRVJfQ09ORklHKSB7XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uID0gbGV4ZXJEZWZpbml0aW9uO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcgPSBbXTtcbiAgICAgICAgdGhpcy5wYXR0ZXJuSWR4VG9Db25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0ge307XG4gICAgICAgIHRoaXMubW9kZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lbXB0eUdyb3VwcyA9IHt9O1xuICAgICAgICB0aGlzLnRyYWNrU3RhcnRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMudHJhY2tFbmRMaW5lcyA9IHRydWU7XG4gICAgICAgIHRoaXMuaGFzQ3VzdG9tID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkID0ge307XG4gICAgICAgIC8vIER1cGxpY2F0ZWQgZnJvbSB0aGUgcGFyc2VyJ3MgcGVyZiB0cmFjZSB0cmFpdCB0byBhbGxvdyBmdXR1cmUgZXh0cmFjdGlvblxuICAgICAgICAvLyBvZiB0aGUgbGV4ZXIgdG8gYSBzZXBhcmF0ZSBwYWNrYWdlLlxuICAgICAgICB0aGlzLlRSQUNFX0lOSVQgPSAocGhhc2VEZXNjLCBwaGFzZUltcGwpID0+IHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gb3B0aW1pemUgdGhpcyB1c2luZyBOT09QIHBhdHRlcm4gYmVjYXVzZVxuICAgICAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRQZXJmID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQrKztcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRlbnQgPSBuZXcgQXJyYXkodGhpcy50cmFjZUluaXRJbmRlbnQgKyAxKS5qb2luKFwiXFx0XCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYCR7aW5kZW50fS0tPiA8JHtwaGFzZURlc2N9PmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHRpbWUsIHZhbHVlIH0gPSB0aW1lcihwaGFzZUltcGwpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gRGlmZmljdWx0IHRvIHJlcHJvZHVjZSBzcGVjaWZpYyBwZXJmb3JtYW5jZSBiZWhhdmlvciAoPjEwbXMpIGluIHRlc3RzICovXG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2VNZXRob2QgPSB0aW1lID4gMTAgPyBjb25zb2xlLndhcm4gOiBjb25zb2xlLmxvZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlTWV0aG9kKGAke2luZGVudH08LS0gPCR7cGhhc2VEZXNjfT4gdGltZTogJHt0aW1lfW1zYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50LS07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBoYXNlSW1wbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgTGV4ZXIgY29uc3RydWN0b3IgaXMgbm93IGFuIElMZXhlckNvbmZpZyBPYmplY3QuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiYSBib29sZWFuIDJuZCBhcmd1bWVudCBpcyBubyBsb25nZXIgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGRlZmF1bHRzIGZ1bmM/XG4gICAgICAgIHRoaXMuY29uZmlnID0gYXNzaWduKHt9LCBERUZBVUxUX0xFWEVSX0NPTkZJRywgY29uZmlnKTtcbiAgICAgICAgY29uc3QgdHJhY2VJbml0VmFsID0gdGhpcy5jb25maWcudHJhY2VJbml0UGVyZjtcbiAgICAgICAgaWYgKHRyYWNlSW5pdFZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IEluZmluaXR5O1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdHJhY2VJbml0VmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gdHJhY2VJbml0VmFsO1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25zdHJ1Y3RvclwiLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgYWN0dWFsRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIGxldCBoYXNPbmx5U2luZ2xlTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJMZXhlciBDb25maWcgaGFuZGxpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuID09PVxuICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0xFWEVSX0NPTkZJRy5saW5lVGVybWluYXRvcnNQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGltaXplZCBidWlsdC1pbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGRlZmF1bHRzIGRlZmluaXRpb24gb2YgbGluZVRlcm1pbmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4gPSBMaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0xFWEVSX0NPTkZJRy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXJyb3I6IE1pc3NpbmcgPGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycz4gcHJvcGVydHkgb24gdGhlIExleGVyIGNvbmZpZy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNNSVNTSU5HX0xJTkVfVEVSTV9DSEFSU1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLnNhZmVNb2RlICYmIGNvbmZpZy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdcInNhZmVNb2RlXCIgYW5kIFwiZW5zdXJlT3B0aW1pemF0aW9uc1wiIGZsYWdzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tTdGFydExpbmVzID0gL2Z1bGx8b25seVN0YXJ0L2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNrRW5kTGluZXMgPSAvZnVsbC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZyk7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBTaW5nbGVNb2RlTGV4ZXJEZWZpbml0aW9uIGludG8gYSBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uLlxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGxleGVyRGVmaW5pdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVzOiB7IGRlZmF1bHRNb2RlOiBjbG9uZShsZXhlckRlZmluaXRpb24pIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TW9kZTogREVGQVVMVF9NT0RFLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY29udmVyc2lvbiBuZWVkZWQsIGlucHV0IHNob3VsZCBhbHJlYWR5IGJlIGEgSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICBoYXNPbmx5U2luZ2xlTW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uID0gY2xvbmUobGV4ZXJEZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVJ1bnRpbWVDaGVja3NcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdChwZXJmb3JtUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCB0aGlzLnRyYWNrU3RhcnRMaW5lcywgdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nID0gdGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLmNvbmNhdChwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MoYWN0dWFsRGVmaW5pdGlvbiwgdGhpcy50cmFja1N0YXJ0TGluZXMsIHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yIGV4dHJhIHJvYnVzdG5lc3MgdG8gYXZvaWQgdGhyb3dpbmcgYW4gbm9uZSBpbmZvcm1hdGl2ZSBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uLm1vZGVzID0gYWN0dWFsRGVmaW5pdGlvbi5tb2Rlc1xuICAgICAgICAgICAgICAgID8gYWN0dWFsRGVmaW5pdGlvbi5tb2Rlc1xuICAgICAgICAgICAgICAgIDoge307XG4gICAgICAgICAgICAvLyBhbiBlcnJvciBvZiB1bmRlZmluZWQgVG9rZW5UeXBlcyB3aWxsIGJlIGRldGVjdGVkIGluIFwicGVyZm9ybVJ1bnRpbWVDaGVja3NcIiBhYm92ZS5cbiAgICAgICAgICAgIC8vIHRoaXMgdHJhbnNmb3JtYXRpb24gaXMgdG8gaW5jcmVhc2Ugcm9idXN0bmVzcyBpbiB0aGUgY2FzZSBvZiBwYXJ0aWFsbHkgaW52YWxpZCBsZXhlciBkZWZpbml0aW9uLlxuICAgICAgICAgICAgZm9yRWFjaChhY3R1YWxEZWZpbml0aW9uLm1vZGVzLCAoY3Vyck1vZGVWYWx1ZSwgY3Vyck1vZGVOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgYWN0dWFsRGVmaW5pdGlvbi5tb2Rlc1tjdXJyTW9kZU5hbWVdID0gcmVqZWN0KGN1cnJNb2RlVmFsdWUsIChjdXJyVG9rVHlwZSkgPT4gaXNVbmRlZmluZWQoY3VyclRva1R5cGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWxsTW9kZU5hbWVzID0ga2V5cyhhY3R1YWxEZWZpbml0aW9uLm1vZGVzKTtcbiAgICAgICAgICAgIGZvckVhY2goYWN0dWFsRGVmaW5pdGlvbi5tb2RlcywgKGN1cnJNb2REZWYsIGN1cnJNb2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKGBNb2RlOiA8JHtjdXJyTW9kTmFtZX0+IHByb2Nlc3NpbmdgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZXMucHVzaChjdXJyTW9kTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoYHZhbGlkYXRlUGF0dGVybnNgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMgPSB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycy5jb25jYXQodmFsaWRhdGVQYXR0ZXJucyhjdXJyTW9kRGVmLCBhbGxNb2RlTmFtZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGRlZmluaXRpb24gZXJyb3JzIHdlcmUgZW5jb3VudGVyZWQsIHRoZSBhbmFseXNpcyBwaGFzZSBtYXkgZmFpbCB1bmV4cGVjdGVkbHkvXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnNpZGVyaW5nIGEgbGV4ZXIgd2l0aCBkZWZpbml0aW9uIGVycm9ycyBtYXkgbmV2ZXIgYmUgdXNlZCwgdGhlcmUgaXMgbm8gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gcGVyZm9ybWluZyB0aGUgYW5hbHlzaXMgYW55aG93Li4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXVnbWVudFRva2VuVHlwZXMoY3Vyck1vZERlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckFuYWx5emVSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoYGFuYWx5emVUb2tlblR5cGVzYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0ID0gYW5hbHl6ZVRva2VuVHlwZXMoY3Vyck1vZERlZiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25UcmFja2luZzogY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuc3VyZU9wdGltaXphdGlvbnM6IGNvbmZpZy5lbnN1cmVPcHRpbWl6YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYWZlTW9kZTogY29uZmlnLnNhZmVNb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXI6IHRoaXMuVFJBQ0VfSU5JVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdC5wYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbY3Vyck1vZE5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyQW5hbHl6ZVJlc3VsdC5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbXB0eUdyb3VwcyA9IGFzc2lnbih7fSwgdGhpcy5lbXB0eUdyb3VwcywgY3VyckFuYWx5emVSZXN1bHQuZW1wdHlHcm91cHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNDdXN0b20gPSBjdXJyQW5hbHl6ZVJlc3VsdC5oYXNDdXN0b20gfHwgdGhpcy5oYXNDdXN0b207XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbk1vZGVCZU9wdGltaXplZFtjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0LmNhbkJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdE1vZGUgPSBhY3R1YWxEZWZpbml0aW9uLmRlZmF1bHRNb2RlO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmNvbmZpZy5kZWZlckRlZmluaXRpb25FcnJvcnNIYW5kbGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbEVyck1lc3NhZ2VzID0gbWFwKHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRXJyTWVzc2FnZXNTdHJpbmcgPSBhbGxFcnJNZXNzYWdlcy5qb2luKFwiLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIgKyBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHByaW50IHdhcm5pbmcgaWYgdGhlcmUgYXJlIG5vIGVycm9ycywgVGhpcyB3aWxsIGF2b2lkIHBsXG4gICAgICAgICAgICBmb3JFYWNoKHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZywgKHdhcm5pbmdEZXNjcmlwdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgUFJJTlRfV0FSTklORyh3YXJuaW5nRGVzY3JpcHRvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiQ2hvb3Npbmcgc3ViLW1ldGhvZHMgaW1wbGVtZW50YXRpb25zXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaG9vc2UgdGhlIHJlbGV2YW50IGludGVybmFsIGltcGxlbWVudGF0aW9ucyBmb3IgdGhpcyBzcGVjaWZpYyBwYXJzZXIuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgaW1wbGVtZW50YXRpb25zIHNob3VsZCBiZSBpbi1saW5lZCBieSB0aGUgSmF2YVNjcmlwdCBlbmdpbmVcbiAgICAgICAgICAgICAgICAvLyB0byBwcm92aWRlIG9wdGltYWwgcGVyZm9ybWFuY2UgaW4gZWFjaCBzY2VuYXJpby5cbiAgICAgICAgICAgICAgICBpZiAoU1VQUE9SVF9TVElDS1kpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaG9wSW5wdXQgPSBpZGVudGl0eTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2hXaXRoVGVzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4ID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2hXaXRoRXhlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc09ubHlTaW5nbGVNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW9kZXMgPSBub29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja1N0YXJ0TGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZU5ld0NvbHVtbiA9IGlkZW50aXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFja0VuZExpbmVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uID0gbm9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9mdWxsL2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSB0aGlzLmNyZWF0ZUZ1bGxUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL29ubHlTdGFydC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gdGhpcy5jcmVhdGVTdGFydE9ubHlUb2tlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoL29ubHlPZmZzZXQvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IHRoaXMuY3JlYXRlT2Zmc2V0T25seVRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEludmFsaWQgPHBvc2l0aW9uVHJhY2tpbmc+IGNvbmZpZyBvcHRpb246IFwiJHt0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc0N1c3RvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFRva2VuID0gdGhpcy5hZGRUb2tlblVzaW5nUHVzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXlsb2FkID0gdGhpcy5oYW5kbGVQYXlsb2FkV2l0aEN1c3RvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9rZW4gPSB0aGlzLmFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGF5bG9hZCA9IHRoaXMuaGFuZGxlUGF5bG9hZE5vQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiRmFpbGVkIE9wdGltaXphdGlvbiBXYXJuaW5nc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5PcHRpbWl6ZWRNb2RlcyA9IHJlZHVjZSh0aGlzLmNhbk1vZGVCZU9wdGltaXplZCwgKGNhbm5vdEJlT3B0aW1pemVkLCBjYW5CZU9wdGltaXplZCwgbW9kZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbkJlT3B0aW1pemVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2Fubm90QmVPcHRpbWl6ZWQucHVzaChtb2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbm5vdEJlT3B0aW1pemVkO1xuICAgICAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMgJiYgIWlzRW1wdHkodW5PcHRpbWl6ZWRNb2RlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYExleGVyIE1vZGVzOiA8ICR7dW5PcHRpbWl6ZWRNb2Rlcy5qb2luKFwiLCBcIil9ID4gY2Fubm90IGJlIG9wdGltaXplZC5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXHQgRGlzYWJsZSB0aGUgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgbGV4ZXIgY29uZmlnIGZsYWcgdG8gc2lsZW50bHkgaWdub3JlIHRoaXMgYW5kIHJ1biB0aGUgbGV4ZXIgaW4gYW4gdW4tb3B0aW1pemVkIG1vZGUuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdCBPciBpbnNwZWN0IHRoZSBjb25zb2xlIGxvZyBmb3IgZGV0YWlscyBvbiBob3cgdG8gcmVzb2x2ZSB0aGVzZSBpc3N1ZXMuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiY2xlYXJSZWdFeHBQYXJzZXJDYWNoZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJ0b0Zhc3RQcm9wZXJ0aWVzXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0b0Zhc3RQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b2tlbml6ZSh0ZXh0LCBpbml0aWFsTW9kZSA9IHRoaXMuZGVmYXVsdE1vZGUpIHtcbiAgICAgICAgaWYgKCFpc0VtcHR5KHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgY29uc3QgYWxsRXJyTWVzc2FnZXMgPSBtYXAodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBUb2tlbml6ZSBiZWNhdXNlIEVycm9ycyBkZXRlY3RlZCBpbiBkZWZpbml0aW9uIG9mIExleGVyOlxcblwiICtcbiAgICAgICAgICAgICAgICBhbGxFcnJNZXNzYWdlc1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5pemVJbnRlcm5hbCh0ZXh0LCBpbml0aWFsTW9kZSk7XG4gICAgfVxuICAgIC8vIFRoZXJlIGlzIHF1aXRlIGEgYml0IG9mIGR1cGxpY2F0aW9uIGJldHdlZW4gdGhpcyBhbmQgXCJ0b2tlbml6ZUludGVybmFsTGF6eVwiXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbCBkdWUgdG8gcGVyZm9ybWFuY2UgY29uc2lkZXJhdGlvbnMuXG4gICAgLy8gdGhpcyBtZXRob2QgYWxzbyB1c2VkIHF1aXRlIGEgYml0IG9mIGAhYCBub25lIG51bGwgYXNzZXJ0aW9ucyBiZWNhdXNlIGl0IGlzIHRvbyBvcHRpbWl6ZWRcbiAgICAvLyBmb3IgYHRzY2AgdG8gYWx3YXlzIHVuZGVyc3RhbmQgaXQgaXMgXCJzYWZlXCJcbiAgICB0b2tlbml6ZUludGVybmFsKHRleHQsIGluaXRpYWxNb2RlKSB7XG4gICAgICAgIGxldCBpLCBqLCBrLCBtYXRjaEFsdEltYWdlLCBsb25nZXJBbHQsIG1hdGNoZWRJbWFnZSwgcGF5bG9hZCwgYWx0UGF5bG9hZCwgaW1hZ2VMZW5ndGgsIGdyb3VwLCB0b2tUeXBlLCBuZXdUb2tlbiwgZXJyTGVuZ3RoLCBkcm9wcGVkQ2hhciwgbXNnLCBtYXRjaDtcbiAgICAgICAgY29uc3Qgb3JnVGV4dCA9IHRleHQ7XG4gICAgICAgIGNvbnN0IG9yZ0xlbmd0aCA9IG9yZ1RleHQubGVuZ3RoO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgbGV0IG1hdGNoZWRUb2tlbnNJbmRleCA9IDA7XG4gICAgICAgIC8vIGluaXRpYWxpemluZyB0aGUgdG9rZW5zQXJyYXkgdG8gdGhlIFwiZ3Vlc3NlZFwiIHNpemUuXG4gICAgICAgIC8vIGd1ZXNzaW5nIHRvbyBsaXR0bGUgd2lsbCBzdGlsbCByZWR1Y2UgdGhlIG51bWJlciBvZiBhcnJheSByZS1zaXplcyBvbiBwdXNoZXMuXG4gICAgICAgIC8vIGd1ZXNzaW5nIHRvbyBsYXJnZSAoVGVzdGVkIGJ5IGd1ZXNzaW5nIHg0IHRvbyBsYXJnZSkgbWF5IGNvc3QgYSBiaXQgbW9yZSBvZiBtZW1vcnlcbiAgICAgICAgLy8gYnV0IHdvdWxkIHN0aWxsIGhhdmUgYSBmYXN0ZXIgcnVudGltZSBieSBhdm9pZGluZyAoQWxsIGJ1dCBvbmUpIGFycmF5IHJlc2l6aW5nLlxuICAgICAgICBjb25zdCBndWVzc2VkTnVtYmVyT2ZUb2tlbnMgPSB0aGlzLmhhc0N1c3RvbVxuICAgICAgICAgICAgPyAwIC8vIHdpbGwgYnJlYWsgY3VzdG9tIHRva2VuIHBhdHRlcm4gQVBJcyB0aGUgbWF0Y2hlZFRva2VucyBhcnJheSB3aWxsIGNvbnRhaW4gdW5kZWZpbmVkIGVsZW1lbnRzLlxuICAgICAgICAgICAgOiBNYXRoLmZsb29yKHRleHQubGVuZ3RoIC8gMTApO1xuICAgICAgICBjb25zdCBtYXRjaGVkVG9rZW5zID0gbmV3IEFycmF5KGd1ZXNzZWROdW1iZXJPZlRva2Vucyk7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMudHJhY2tTdGFydExpbmVzID8gMSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGNvbHVtbiA9IHRoaXMudHJhY2tTdGFydExpbmVzID8gMSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0gY2xvbmVFbXB0eUdyb3Vwcyh0aGlzLmVtcHR5R3JvdXBzKTtcbiAgICAgICAgY29uc3QgdHJhY2tMaW5lcyA9IHRoaXMudHJhY2tTdGFydExpbmVzO1xuICAgICAgICBjb25zdCBsaW5lVGVybWluYXRvclBhdHRlcm4gPSB0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvcnNQYXR0ZXJuO1xuICAgICAgICBsZXQgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aCA9IDA7XG4gICAgICAgIGxldCBwYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICAgICAgbGV0IGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gW107XG4gICAgICAgIGNvbnN0IG1vZGVTdGFjayA9IFtdO1xuICAgICAgICBjb25zdCBlbXB0eUFycmF5ID0gW107XG4gICAgICAgIE9iamVjdC5mcmVlemUoZW1wdHlBcnJheSk7XG4gICAgICAgIGxldCBnZXRQb3NzaWJsZVBhdHRlcm5zO1xuICAgICAgICBmdW5jdGlvbiBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdygpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVBhdHRlcm5zID0gY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbb3B0aW1pemVkQ2hhcklkeF07XG4gICAgICAgICAgICBpZiAocG9zc2libGVQYXR0ZXJucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQYXR0ZXJucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3BfbW9kZSA9IChwb3BUb2tlbikgPT4ge1xuICAgICAgICAgICAgLy8gVE9ETzogcGVyaGFwcyBhdm9pZCB0aGlzIGVycm9yIGluIHRoZSBlZGdlIGNhc2UgdGhlcmUgaXMgbm8gbW9yZSBpbnB1dD9cbiAgICAgICAgICAgIGlmIChtb2RlU3RhY2subGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBib3RoIGEgUE9QX01PREUgYW5kIGEgUFVTSF9NT0RFIHRoaXMgaXMgaW4tZmFjdCBhIFwidHJhbnNpdGlvblwiXG4gICAgICAgICAgICAgICAgLy8gU28gbm8gZXJyb3Igc2hvdWxkIG9jY3VyLlxuICAgICAgICAgICAgICAgIHBvcFRva2VuLnRva2VuVHlwZS5QVVNIX01PREUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIHRyeSB0byBwb3AgdGhlIGxhc3QgbW9kZSB0aGVyZSBsZXhlciB3aWxsIG5vIGxvbmdlciBoYXZlIEFOWSBtb2RlLlxuICAgICAgICAgICAgICAgIC8vIHRodXMgdGhlIHBvcCBpcyBpZ25vcmVkLCBhbiBlcnJvciB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSBsZXhlciB3aWxsIGNvbnRpbnVlIHBhcnNpbmcgaW4gdGhlIHByZXZpb3VzIG1vZGUuXG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdGhpcy5jb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UocG9wVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBwb3BUb2tlbi5zdGFydE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogcG9wVG9rZW4uc3RhcnRMaW5lLFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHBvcFRva2VuLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHBvcFRva2VuLmltYWdlLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld01vZGUgPSBsYXN0KG1vZGVTdGFjayk7XG4gICAgICAgICAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICAgICAgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICAgICAgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aCA9IHBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kZUNhbkJlT3B0aW1pemVkID0gdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbbmV3TW9kZV0gJiYgdGhpcy5jb25maWcuc2FmZU1vZGUgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyAmJiBtb2RlQ2FuQmVPcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3c7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBwdXNoX21vZGUobmV3TW9kZSkge1xuICAgICAgICAgICAgbW9kZVN0YWNrLnB1c2gobmV3TW9kZSk7XG4gICAgICAgICAgICBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnW25ld01vZGVdO1xuICAgICAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gdGhpcy5wYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbW9kZUNhbkJlT3B0aW1pemVkID0gdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWRbbmV3TW9kZV0gJiYgdGhpcy5jb25maWcuc2FmZU1vZGUgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnICYmIG1vZGVDYW5CZU9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zT3B0aW1pemVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNTbG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgcGF0dGVybiBzZWVtcyB0byBhdm9pZCBhIFY4IGRlLW9wdGltaXphdGlvbiwgYWx0aG91Z2ggdGhhdCBkZS1vcHRpbWl6YXRpb24gZG9lcyBub3RcbiAgICAgICAgLy8gc2VlbSB0byBtYXR0ZXIgcGVyZm9ybWFuY2Ugd2lzZS5cbiAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgaW5pdGlhbE1vZGUpO1xuICAgICAgICBsZXQgY3VyckNvbmZpZztcbiAgICAgICAgY29uc3QgcmVjb3ZlcnlFbmFibGVkID0gdGhpcy5jb25maWcucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICB3aGlsZSAob2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYXJDb2RlID0gb3JnVGV4dC5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgICAgICBjb25zdCBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWcgPSBnZXRQb3NzaWJsZVBhdHRlcm5zKG5leHRDaGFyQ29kZSk7XG4gICAgICAgICAgICBjb25zdCBjaG9zZW5QYXR0ZXJuc0xlbmd0aCA9IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2hvc2VuUGF0dGVybnNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGN1cnJDb25maWcgPSBjaG9zZW5QYXR0ZXJuSWR4VG9Db25maWdbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdHRlcm4gPSBjdXJyQ29uZmlnLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZUNoYXJDb2RlID0gY3VyckNvbmZpZy5zaG9ydDtcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlQ2hhckNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hhckNvZGUgPT09IHNpbmdsZUNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgY2hhcmFjdGVyIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gY3VyclBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckNvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGN1cnJQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSBtYXRjaC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXgoY3VyclBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IHRoaXMubWF0Y2goY3VyclBhdHRlcm4sIHRleHQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkSW1hZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiB0aG91Z2ggdGhpcyBwYXR0ZXJuIG1hdGNoZWQgd2UgbXVzdCB0cnkgYSBhbm90aGVyIGxvbmdlciBhbHRlcm5hdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjYW4gYmUgdXNlZCB0byBwcmlvcml0aXplIGtleXdvcmRzIG92ZXIgaWRlbnRpZmllcnNcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VyQWx0ID0gY3VyckNvbmZpZy5sb25nZXJBbHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb25nZXJBbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogbWljcm8gb3B0aW1pemUsIGF2b2lkIGV4dHJhIHByb3AgYWNjZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBieSBzYXZpbmcvbGlua2luZyBsb25nZXJBbHQgb24gdGhlIG9yaWdpbmFsIGNvbmZpZz9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdExlbmd0aCA9IGxvbmdlckFsdC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbG9uZ2VyQWx0TGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb25nZXJBbHRDb25maWcgPSBwYXR0ZXJuSWR4VG9Db25maWdbbG9uZ2VyQWx0W2tdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb25nZXJBbHRQYXR0ZXJuID0gbG9uZ2VyQWx0Q29uZmlnLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0UGF5bG9hZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIENoYXIgY2FuIG5ldmVyIGJlIGEgbG9uZ2VyIGFsdCBzbyBubyBuZWVkIHRvIHRlc3QgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb25nZXJBbHRDb25maWcuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBsb25nZXJBbHRQYXR0ZXJuLmV4ZWMob3JnVGV4dCwgb2Zmc2V0LCBtYXRjaGVkVG9rZW5zLCBncm91cHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5wYXlsb2FkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRQYXlsb2FkID0gbWF0Y2gucGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChsb25nZXJBbHRQYXR0ZXJuLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEFsdEltYWdlID0gdGhpcy5tYXRjaChsb25nZXJBbHRQYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hBbHRJbWFnZSAmJiBtYXRjaEFsdEltYWdlLmxlbmd0aCA+IG1hdGNoZWRJbWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbWF0Y2hBbHRJbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IGFsdFBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJDb25maWcgPSBsb25nZXJBbHRDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4aXQgdGhlIGxvb3AgZWFybHkgYWZ0ZXIgbWF0Y2hpbmcgb25lIG9mIHRoZSBsb25nZXIgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBtYXRjaGVkIGFsdGVybmF0aXZlIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgbWF0Y2hcbiAgICAgICAgICAgIGlmIChtYXRjaGVkSW1hZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbWFnZUxlbmd0aCA9IG1hdGNoZWRJbWFnZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZ3JvdXAgPSBjdXJyQ29uZmlnLmdyb3VwO1xuICAgICAgICAgICAgICAgIGlmIChncm91cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva1R5cGUgPSBjdXJyQ29uZmlnLnRva2VuVHlwZUlkeDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogXCJvZmZzZXQgKyBpbWFnZUxlbmd0aFwiIGFuZCB0aGUgbmV3IGNvbHVtbiBtYXkgYmUgY29tcHV0ZWQgdHdpY2UgaW4gY2FzZSBvZiBcImZ1bGxcIiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpbnNpZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlRnVsbFRva2VuIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBuZXdUb2tlbiA9IHRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZShtYXRjaGVkSW1hZ2UsIG9mZnNldCwgdG9rVHlwZSwgY3VyckNvbmZpZy50b2tlblR5cGUsIGxpbmUsIGNvbHVtbiwgaW1hZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBheWxvYWQobmV3VG9rZW4sIHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBvcHRpbWl6ZSBOT09QIGluIGNhc2UgdGhlcmUgYXJlIG5vIHNwZWNpYWwgZ3JvdXBzP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXAgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkVG9rZW5zSW5kZXggPSB0aGlzLmFkZFRva2VuKG1hdGNoZWRUb2tlbnMsIG1hdGNoZWRUb2tlbnNJbmRleCwgbmV3VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKG5ld1Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jaG9wSW5wdXQodGV4dCwgaW1hZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIGltYWdlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdpdGggbmV3bGluZXMgdGhlIGNvbHVtbiBtYXkgYmUgYXNzaWduZWQgdHdpY2VcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbXB1dGVOZXdDb2x1bW4oY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrTGluZXMgPT09IHRydWUgJiYgY3VyckNvbmZpZy5jYW5MaW5lVGVybWluYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbnVtT2ZMVHNJbk1hdGNoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kVGVybWluYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RMVEVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgbGluZVRlcm1pbmF0b3JQYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kVGVybWluYXRvciA9IGxpbmVUZXJtaW5hdG9yUGF0dGVybi50ZXN0KG1hdGNoZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmRUZXJtaW5hdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdExURW5kT2Zmc2V0ID0gbGluZVRlcm1pbmF0b3JQYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtT2ZMVHNJbk1hdGNoKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKGZvdW5kVGVybWluYXRvciA9PT0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1PZkxUc0luTWF0Y2ggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lICsgbnVtT2ZMVHNJbk1hdGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gaW1hZ2VMZW5ndGggLSBsYXN0TFRFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uKG5ld1Rva2VuLCBncm91cCwgbGFzdExURW5kT2Zmc2V0LCBudW1PZkxUc0luTWF0Y2gsIGxpbmUsIGNvbHVtbiwgaW1hZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgTk9PUCBpZiBubyBtb2RlcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNb2RlcyhjdXJyQ29uZmlnLCBwb3BfbW9kZSwgcHVzaF9tb2RlLCBuZXdUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciByZWNvdmVyeSwgZHJvcCBjaGFyYWN0ZXJzIHVudGlsIHdlIGlkZW50aWZ5IGEgdmFsaWQgdG9rZW4ncyBzdGFydCBwb2ludFxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JMaW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckNvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmRSZXN5bmNQb2ludCA9IHJlY292ZXJ5RW5hYmxlZCA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGZvdW5kUmVzeW5jUG9pbnQgPT09IGZhbHNlICYmIG9mZnNldCA8IG9yZ0xlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZGVudGl0eSBGdW5jICh3aGVuIHN0aWNreSBmbGFnIGlzIGVuYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmNob3BJbnB1dCh0ZXh0LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJDb25maWcgPSBwYXR0ZXJuSWR4VG9Db25maWdbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyUGF0dGVybiA9IGN1cnJDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hbnVhbGx5IGluLWxpbmVkIGJlY2F1c2UgPiA2MDAgY2hhcnMgd29uJ3QgYmUgaW4tbGluZWQgaW4gVjhcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpbmdsZUNoYXJDb2RlID0gY3VyckNvbmZpZy5zaG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVDaGFyQ29kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JnVGV4dC5jaGFyQ29kZUF0KG9mZnNldCkgPT09IHNpbmdsZUNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kUmVzeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJDb25maWcuaXNDdXN0b20gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3VwcykgIT09IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChjdXJyUGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZFJlc3luY1BvaW50ID0gY3VyclBhdHRlcm4uZXhlYyh0ZXh0KSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFJlc3luY1BvaW50ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXJyTGVuZ3RoID0gb2Zmc2V0IC0gZXJyb3JTdGFydE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSB0aGlzLmNvbXB1dGVOZXdDb2x1bW4oY29sdW1uLCBlcnJMZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgZWl0aGVyIHJlLXN5bmNlZCBvciByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGlucHV0IHRleHRcbiAgICAgICAgICAgICAgICBtc2cgPSB0aGlzLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZShvcmdUZXh0LCBlcnJvclN0YXJ0T2Zmc2V0LCBlcnJMZW5ndGgsIGVycm9yTGluZSwgZXJyb3JDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBlcnJvclN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBlcnJvckxpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogZXJyb3JDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogZXJyTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY292ZXJ5RW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGRvIGhhdmUgY3VzdG9tIHBhdHRlcm5zIHdoaWNoIHB1c2ggZGlyZWN0bHkgaW50byB0aGVcbiAgICAgICAgLy8gVE9ETzogY3VzdG9tIHRva2VucyBzaG91bGQgbm90IHB1c2ggZGlyZWN0bHk/P1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ3VzdG9tKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBndWVzc2VkIGEgdG9vIGxhcmdlIHNpemUgZm9yIHRoZSB0b2tlbnMgYXJyYXkgdGhpcyB3aWxsIHNocmluayBpdCB0byB0aGUgcmlnaHQgc2l6ZS5cbiAgICAgICAgICAgIG1hdGNoZWRUb2tlbnMubGVuZ3RoID0gbWF0Y2hlZFRva2Vuc0luZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IG1hdGNoZWRUb2tlbnMsXG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBoYW5kbGVNb2Rlcyhjb25maWcsIHBvcF9tb2RlLCBwdXNoX21vZGUsIG5ld1Rva2VuKSB7XG4gICAgICAgIGlmIChjb25maWcucG9wID09PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBuZWVkIHRvIHNhdmUgdGhlIFBVU0hfTU9ERSBwcm9wZXJ0eSBhcyBpZiB0aGUgbW9kZSBpcyBwb3BwZWRcbiAgICAgICAgICAgIC8vIHBhdHRlcm5JZHhUb1BvcE1vZGUgaXMgdXBkYXRlZCB0byByZWZsZWN0IHRoZSBuZXcgbW9kZSBhZnRlciBwb3BwaW5nIHRoZSBzdGFja1xuICAgICAgICAgICAgY29uc3QgcHVzaE1vZGUgPSBjb25maWcucHVzaDtcbiAgICAgICAgICAgIHBvcF9tb2RlKG5ld1Rva2VuKTtcbiAgICAgICAgICAgIGlmIChwdXNoTW9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgcHVzaE1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5wdXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1c2hfbW9kZS5jYWxsKHRoaXMsIGNvbmZpZy5wdXNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaG9wSW5wdXQodGV4dCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0ZXh0LnN1YnN0cmluZyhsZW5ndGgpO1xuICAgIH1cbiAgICB1cGRhdGVMYXN0SW5kZXgocmVnRXhwLCBuZXdMYXN0SW5kZXgpIHtcbiAgICAgICAgcmVnRXhwLmxhc3RJbmRleCA9IG5ld0xhc3RJbmRleDtcbiAgICB9XG4gICAgLy8gVE9ETzogZGVjcmVhc2UgdGhpcyB1bmRlciA2MDAgY2hhcmFjdGVycz8gaW5zcGVjdCBzdHJpcHBpbmcgY29tbWVudHMgb3B0aW9uIGluIFRTQyBjb21waWxlclxuICAgIHVwZGF0ZVRva2VuRW5kTGluZUNvbHVtbkxvY2F0aW9uKG5ld1Rva2VuLCBncm91cCwgbGFzdExUSWR4LCBudW1PZkxUc0luTWF0Y2gsIGxpbmUsIGNvbHVtbiwgaW1hZ2VMZW5ndGgpIHtcbiAgICAgICAgbGV0IGxhc3RDaGFySXNMVCwgZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgaWYgKGdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGEgbm9uZSBza2lwcGVkIG11bHRpIGxpbmUgVG9rZW4sIG5lZWQgdG8gdXBkYXRlIGVuZExpbmUvZW5kQ29sdW1uXG4gICAgICAgICAgICBsYXN0Q2hhcklzTFQgPSBsYXN0TFRJZHggPT09IGltYWdlTGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZpeEZvckVuZGluZ0luTFQgPSBsYXN0Q2hhcklzTFQgPyAtMSA6IDA7XG4gICAgICAgICAgICBpZiAoIShudW1PZkxUc0luTWF0Y2ggPT09IDEgJiYgbGFzdENoYXJJc0xUID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGEgdG9rZW4gZW5kcyBpbiBhIExUIHRoYXQgbGFzdCBMVCBvbmx5IGFmZmVjdHMgdGhlIGxpbmUgbnVtYmVyaW5nIG9mIGZvbGxvd2luZyBUb2tlbnNcbiAgICAgICAgICAgICAgICBuZXdUb2tlbi5lbmRMaW5lID0gbGluZSArIGZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgTFQgaW4gYSB0b2tlbiBkb2VzIG5vdCBhZmZlY3QgdGhlIGVuZENvbHVtbiBlaXRoZXIgYXMgdGhlIFtjb2x1bW5TdGFydCAuLi4gY29sdW1uRW5kKVxuICAgICAgICAgICAgICAgIC8vIGluY2x1c2l2ZSB0byBleGNsdXNpdmUgcmFuZ2UuXG4gICAgICAgICAgICAgICAgbmV3VG9rZW4uZW5kQ29sdW1uID0gY29sdW1uIC0gMSArIC1maXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBzaW5nbGUgTFQgaW4gdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEgdG9rZW4sIG5vIG5lZWQgdG8gbW9kaWZ5IHRoZSBlbmRMaW5lL0VuZENvbHVtblxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVOZXdDb2x1bW4ob2xkQ29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gb2xkQ29sdW1uICsgaW1hZ2VMZW5ndGg7XG4gICAgfVxuICAgIGNyZWF0ZU9mZnNldE9ubHlUb2tlbihpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgdG9rZW5UeXBlSWR4LFxuICAgICAgICAgICAgdG9rZW5UeXBlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVTdGFydE9ubHlUb2tlbihpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgc3RhcnRMaW5lLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZUZ1bGxUb2tlbihpbWFnZSwgc3RhcnRPZmZzZXQsIHRva2VuVHlwZUlkeCwgdG9rZW5UeXBlLCBzdGFydExpbmUsIHN0YXJ0Q29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICBzdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVuZE9mZnNldDogc3RhcnRPZmZzZXQgKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzdGFydExpbmUsXG4gICAgICAgICAgICBlbmRMaW5lOiBzdGFydExpbmUsXG4gICAgICAgICAgICBzdGFydENvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogc3RhcnRDb2x1bW4gKyBpbWFnZUxlbmd0aCAtIDEsXG4gICAgICAgICAgICB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZFRva2VuVXNpbmdQdXNoKHRva2VuVmVjdG9yLCBpbmRleCwgdG9rZW5Ub0FkZCkge1xuICAgICAgICB0b2tlblZlY3Rvci5wdXNoKHRva2VuVG9BZGQpO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZFRva2VuVXNpbmdNZW1iZXJBY2Nlc3ModG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yW2luZGV4XSA9IHRva2VuVG9BZGQ7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgaGFuZGxlUGF5bG9hZE5vQ3VzdG9tKHRva2VuLCBwYXlsb2FkKSB7IH1cbiAgICBoYW5kbGVQYXlsb2FkV2l0aEN1c3RvbSh0b2tlbiwgcGF5bG9hZCkge1xuICAgICAgICBpZiAocGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9rZW4ucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2hXaXRoVGVzdChwYXR0ZXJuLCB0ZXh0LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgZm91bmQgPSBwYXR0ZXJuLnRlc3QodGV4dCk7XG4gICAgICAgIGlmIChmb3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKG9mZnNldCwgcGF0dGVybi5sYXN0SW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBtYXRjaFdpdGhFeGVjKHBhdHRlcm4sIHRleHQpIHtcbiAgICAgICAgY29uc3QgcmVnRXhwQXJyYXkgPSBwYXR0ZXJuLmV4ZWModGV4dCk7XG4gICAgICAgIHJldHVybiByZWdFeHBBcnJheSAhPT0gbnVsbCA/IHJlZ0V4cEFycmF5WzBdIDogbnVsbDtcbiAgICB9XG59XG5MZXhlci5TS0lQUEVEID0gXCJUaGlzIG1hcmtzIGEgc2tpcHBlZCBUb2tlbiBwYXR0ZXJuLCB0aGlzIG1lYW5zIGVhY2ggdG9rZW4gaWRlbnRpZmllZCBieSBpdCB3aWxsXCIgK1xuICAgIFwiYmUgY29uc3VtZWQgYW5kIHRoZW4gdGhyb3duIGludG8gb2JsaXZpb24sIHRoaXMgY2FuIGJlIHVzZWQgdG8gZm9yIGV4YW1wbGUgdG8gY29tcGxldGVseSBpZ25vcmUgd2hpdGVzcGFjZS5cIjtcbkxleGVyLk5BID0gL05PVF9BUFBMSUNBQkxFLztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBoYXMsIGlzU3RyaW5nLCBpc1VuZGVmaW5lZCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4vbGV4ZXJfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciB9IGZyb20gXCIuL3Rva2Vucy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuTGFiZWwodG9rVHlwZSkge1xuICAgIGlmIChoYXNUb2tlbkxhYmVsKHRva1R5cGUpKSB7XG4gICAgICAgIHJldHVybiB0b2tUeXBlLkxBQkVMO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUubmFtZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5OYW1lKHRva1R5cGUpIHtcbiAgICByZXR1cm4gdG9rVHlwZS5uYW1lO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Rva2VuTGFiZWwob2JqKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKG9iai5MQUJFTCkgJiYgb2JqLkxBQkVMICE9PSBcIlwiO1xufVxuY29uc3QgUEFSRU5UID0gXCJwYXJlbnRcIjtcbmNvbnN0IENBVEVHT1JJRVMgPSBcImNhdGVnb3JpZXNcIjtcbmNvbnN0IExBQkVMID0gXCJsYWJlbFwiO1xuY29uc3QgR1JPVVAgPSBcImdyb3VwXCI7XG5jb25zdCBQVVNIX01PREUgPSBcInB1c2hfbW9kZVwiO1xuY29uc3QgUE9QX01PREUgPSBcInBvcF9tb2RlXCI7XG5jb25zdCBMT05HRVJfQUxUID0gXCJsb25nZXJfYWx0XCI7XG5jb25zdCBMSU5FX0JSRUFLUyA9IFwibGluZV9icmVha3NcIjtcbmNvbnN0IFNUQVJUX0NIQVJTX0hJTlQgPSBcInN0YXJ0X2NoYXJzX2hpbnRcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUb2tlbihjb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlVG9rZW5JbnRlcm5hbChjb25maWcpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9rZW5JbnRlcm5hbChjb25maWcpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gY29uZmlnLnBhdHRlcm47XG4gICAgY29uc3QgdG9rZW5UeXBlID0ge307XG4gICAgdG9rZW5UeXBlLm5hbWUgPSBjb25maWcubmFtZTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHBhdHRlcm4pKSB7XG4gICAgICAgIHRva2VuVHlwZS5QQVRURVJOID0gcGF0dGVybjtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFBBUkVOVCkpIHtcbiAgICAgICAgdGhyb3cgKFwiVGhlIHBhcmVudCBwcm9wZXJ0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLlxcblwiICtcbiAgICAgICAgICAgIFwiU2VlOiBodHRwczovL2dpdGh1Yi5jb20vY2hldnJvdGFpbi9jaGV2cm90YWluL2lzc3Vlcy81NjQjaXNzdWVjb21tZW50LTM0OTA2MjM0NiBmb3IgZGV0YWlscy5cIik7XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBDQVRFR09SSUVTKSkge1xuICAgICAgICAvLyBjYXN0aW5nIHRvIEFOWSBhcyB0aGlzIHdpbGwgYmUgZml4ZWQgaW5zaWRlIGBhdWdtZW50VG9rZW5UeXBlc2BgXG4gICAgICAgIHRva2VuVHlwZS5DQVRFR09SSUVTID0gY29uZmlnW0NBVEVHT1JJRVNdO1xuICAgIH1cbiAgICBhdWdtZW50VG9rZW5UeXBlcyhbdG9rZW5UeXBlXSk7XG4gICAgaWYgKGhhcyhjb25maWcsIExBQkVMKSkge1xuICAgICAgICB0b2tlblR5cGUuTEFCRUwgPSBjb25maWdbTEFCRUxdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgR1JPVVApKSB7XG4gICAgICAgIHRva2VuVHlwZS5HUk9VUCA9IGNvbmZpZ1tHUk9VUF07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBQT1BfTU9ERSkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlBPUF9NT0RFID0gY29uZmlnW1BPUF9NT0RFXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFBVU0hfTU9ERSkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlBVU0hfTU9ERSA9IGNvbmZpZ1tQVVNIX01PREVdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgTE9OR0VSX0FMVCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxPTkdFUl9BTFQgPSBjb25maWdbTE9OR0VSX0FMVF07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBMSU5FX0JSRUFLUykpIHtcbiAgICAgICAgdG9rZW5UeXBlLkxJTkVfQlJFQUtTID0gY29uZmlnW0xJTkVfQlJFQUtTXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFNUQVJUX0NIQVJTX0hJTlQpKSB7XG4gICAgICAgIHRva2VuVHlwZS5TVEFSVF9DSEFSU19ISU5UID0gY29uZmlnW1NUQVJUX0NIQVJTX0hJTlRdO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5UeXBlO1xufVxuZXhwb3J0IGNvbnN0IEVPRiA9IGNyZWF0ZVRva2VuKHsgbmFtZTogXCJFT0ZcIiwgcGF0dGVybjogTGV4ZXIuTkEgfSk7XG5hdWdtZW50VG9rZW5UeXBlcyhbRU9GXSk7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVG9rZW5JbnN0YW5jZSh0b2tUeXBlLCBpbWFnZSwgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW1hZ2UsXG4gICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICBlbmRPZmZzZXQsXG4gICAgICAgIHN0YXJ0TGluZSxcbiAgICAgICAgZW5kTGluZSxcbiAgICAgICAgc3RhcnRDb2x1bW4sXG4gICAgICAgIGVuZENvbHVtbixcbiAgICAgICAgdG9rZW5UeXBlSWR4OiB0b2tUeXBlLnRva2VuVHlwZUlkeCxcbiAgICAgICAgdG9rZW5UeXBlOiB0b2tUeXBlLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5NYXRjaGVyKHRva2VuLCB0b2tUeXBlKSB7XG4gICAgcmV0dXJuIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rZW4sIHRva1R5cGUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW5zX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBoYXNUb2tlbkxhYmVsLCB0b2tlbkxhYmVsIH0gZnJvbSBcIi4uL3NjYW4vdG9rZW5zX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgZmlyc3QsIG1hcCwgcmVkdWNlIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgZ2V0UHJvZHVjdGlvbkRzbE5hbWUsIE5vblRlcm1pbmFsLCBSdWxlLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2UoeyBleHBlY3RlZCwgYWN0dWFsLCBwcmV2aW91cywgcnVsZU5hbWUgfSkge1xuICAgICAgICBjb25zdCBoYXNMYWJlbCA9IGhhc1Rva2VuTGFiZWwoZXhwZWN0ZWQpO1xuICAgICAgICBjb25zdCBleHBlY3RlZE1zZyA9IGhhc0xhYmVsXG4gICAgICAgICAgICA/IGAtLT4gJHt0b2tlbkxhYmVsKGV4cGVjdGVkKX0gPC0tYFxuICAgICAgICAgICAgOiBgdG9rZW4gb2YgdHlwZSAtLT4gJHtleHBlY3RlZC5uYW1lfSA8LS1gO1xuICAgICAgICBjb25zdCBtc2cgPSBgRXhwZWN0aW5nICR7ZXhwZWN0ZWRNc2d9IGJ1dCBmb3VuZCAtLT4gJyR7YWN0dWFsLmltYWdlfScgPC0tYDtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9LFxuICAgIGJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlKHsgZmlyc3RSZWR1bmRhbnQsIHJ1bGVOYW1lIH0pIHtcbiAgICAgICAgcmV0dXJuIFwiUmVkdW5kYW50IGlucHV0LCBleHBlY3RpbmcgRU9GIGJ1dCBmb3VuZDogXCIgKyBmaXJzdFJlZHVuZGFudC5pbWFnZTtcbiAgICB9LFxuICAgIGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKHsgZXhwZWN0ZWRQYXRoc1BlckFsdCwgYWN0dWFsLCBwcmV2aW91cywgY3VzdG9tVXNlckRlc2NyaXB0aW9uLCBydWxlTmFtZSwgfSkge1xuICAgICAgICBjb25zdCBlcnJQcmVmaXggPSBcIkV4cGVjdGluZzogXCI7XG4gICAgICAgIC8vIFRPRE86IGlzc3VlOiBObyBWaWFibGUgQWx0ZXJuYXRpdmUgRXJyb3IgbWF5IGhhdmUgaW5jb21wbGV0ZSBkZXRhaWxzLiAjNTAyXG4gICAgICAgIGNvbnN0IGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICBjb25zdCBlcnJTdWZmaXggPSBcIlxcbmJ1dCBmb3VuZDogJ1wiICsgYWN0dWFsVGV4dCArIFwiJ1wiO1xuICAgICAgICBpZiAoY3VzdG9tVXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY3VzdG9tVXNlckRlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYWxsTG9va0FoZWFkUGF0aHMgPSByZWR1Y2UoZXhwZWN0ZWRQYXRoc1BlckFsdCwgKHJlc3VsdCwgY3VyckFsdFBhdGhzKSA9PiByZXN1bHQuY29uY2F0KGN1cnJBbHRQYXRocyksIFtdKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gbWFwKGFsbExvb2tBaGVhZFBhdGhzLCAoY3VyclBhdGgpID0+IGBbJHttYXAoY3VyclBhdGgsIChjdXJyVG9rZW5UeXBlKSA9PiB0b2tlbkxhYmVsKGN1cnJUb2tlblR5cGUpKS5qb2luKFwiLCBcIil9XWApO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbGlkU2VxdWVuY2VJdGVtcyA9IG1hcChuZXh0VmFsaWRUb2tlblNlcXVlbmNlcywgKGl0ZW1Nc2csIGlkeCkgPT4gYCAgJHtpZHggKyAxfS4gJHtpdGVtTXNnfWApO1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZERlc2NyaXB0aW9uID0gYG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6XFxuJHtuZXh0VmFsaWRTZXF1ZW5jZUl0ZW1zLmpvaW4oXCJcXG5cIil9YDtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjYWxjdWxhdGVkRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJ1aWxkRWFybHlFeGl0TWVzc2FnZSh7IGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIGFjdHVhbCwgY3VzdG9tVXNlckRlc2NyaXB0aW9uLCBydWxlTmFtZSwgfSkge1xuICAgICAgICBjb25zdCBlcnJQcmVmaXggPSBcIkV4cGVjdGluZzogXCI7XG4gICAgICAgIC8vIFRPRE86IGlzc3VlOiBObyBWaWFibGUgQWx0ZXJuYXRpdmUgRXJyb3IgbWF5IGhhdmUgaW5jb21wbGV0ZSBkZXRhaWxzLiAjNTAyXG4gICAgICAgIGNvbnN0IGFjdHVhbFRleHQgPSBmaXJzdChhY3R1YWwpLmltYWdlO1xuICAgICAgICBjb25zdCBlcnJTdWZmaXggPSBcIlxcbmJ1dCBmb3VuZDogJ1wiICsgYWN0dWFsVGV4dCArIFwiJ1wiO1xuICAgICAgICBpZiAoY3VzdG9tVXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY3VzdG9tVXNlckRlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbGlkVG9rZW5TZXF1ZW5jZXMgPSBtYXAoZXhwZWN0ZWRJdGVyYXRpb25QYXRocywgKGN1cnJQYXRoKSA9PiBgWyR7bWFwKGN1cnJQYXRoLCAoY3VyclRva2VuVHlwZSkgPT4gdG9rZW5MYWJlbChjdXJyVG9rZW5UeXBlKSkuam9pbihcIixcIil9XWApO1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZERlc2NyaXB0aW9uID0gYGV4cGVjdGluZyBhdCBsZWFzdCBvbmUgaXRlcmF0aW9uIHdoaWNoIHN0YXJ0cyB3aXRoIG9uZSBvZiB0aGVzZSBwb3NzaWJsZSBUb2tlbiBzZXF1ZW5jZXM6OlxcbiAgYCArXG4gICAgICAgICAgICAgICAgYDwke25leHRWYWxpZFRva2VuU2VxdWVuY2VzLmpvaW4oXCIgLFwiKX0+YDtcbiAgICAgICAgICAgIHJldHVybiBlcnJQcmVmaXggKyBjYWxjdWxhdGVkRGVzY3JpcHRpb24gKyBlcnJTdWZmaXg7XG4gICAgICAgIH1cbiAgICB9LFxufTtcbk9iamVjdC5mcmVlemUoZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIpO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkUnVsZU5vdEZvdW5kRXJyb3IodG9wTGV2ZWxSdWxlLCB1bmRlZmluZWRSdWxlKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IFwiSW52YWxpZCBncmFtbWFyLCByZWZlcmVuY2UgdG8gYSBydWxlIHdoaWNoIGlzIG5vdCBkZWZpbmVkOiAtPlwiICtcbiAgICAgICAgICAgIHVuZGVmaW5lZFJ1bGUubm9uVGVybWluYWxOYW1lICtcbiAgICAgICAgICAgIFwiPC1cXG5cIiArXG4gICAgICAgICAgICBcImluc2lkZSB0b3AgbGV2ZWwgcnVsZTogLT5cIiArXG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGUubmFtZSArXG4gICAgICAgICAgICBcIjwtXCI7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyID0ge1xuICAgIGJ1aWxkRHVwbGljYXRlRm91bmRFcnJvcih0b3BMZXZlbFJ1bGUsIGR1cGxpY2F0ZVByb2RzKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpIHtcbiAgICAgICAgICAgIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kLm5vblRlcm1pbmFsTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvcExldmVsTmFtZSA9IHRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICBjb25zdCBkdXBsaWNhdGVQcm9kID0gZmlyc3QoZHVwbGljYXRlUHJvZHMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IGR1cGxpY2F0ZVByb2QuaWR4O1xuICAgICAgICBjb25zdCBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIGNvbnN0IGV4dHJhQXJndW1lbnQgPSBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChkdXBsaWNhdGVQcm9kKTtcbiAgICAgICAgY29uc3QgaGFzRXhwbGljaXRJbmRleCA9IGluZGV4ID4gMDtcbiAgICAgICAgbGV0IG1zZyA9IGAtPiR7ZHNsTmFtZX0ke2hhc0V4cGxpY2l0SW5kZXggPyBpbmRleCA6IFwiXCJ9PC0gJHtleHRyYUFyZ3VtZW50ID8gYHdpdGggYXJndW1lbnQ6IC0+JHtleHRyYUFyZ3VtZW50fTwtYCA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgICBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlICgke2R1cGxpY2F0ZVByb2RzLmxlbmd0aH0gdGltZXMpIGluIHRoZSB0b3AgbGV2ZWwgcnVsZTogLT4ke3RvcExldmVsTmFtZX08LS4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIEZvciBmdXJ0aGVyIGRldGFpbHMgc2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9GQVEuaHRtbCNOVU1FUklDQUxfU1VGRklYRVMgXG4gICAgICAgICAgICAgICAgICBgO1xuICAgICAgICAvLyB3aGl0ZSBzcGFjZSB0cmltbWluZyB0aW1lISBiZXR0ZXIgdG8gdHJpbSBhZnRlcndhcmRzIGFzIGl0IGFsbG93cyB0byB1c2UgV0VMTCBmb3JtYXR0ZWQgbXVsdGkgbGluZSB0ZW1wbGF0ZSBzdHJpbmdzLi4uXG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9bIFxcdF0rL2csIFwiIFwiKTtcbiAgICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1xcc1xccysvZywgXCJcXG5cIik7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZE5hbWVzcGFjZUNvbmZsaWN0RXJyb3IocnVsZSkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgTmFtZXNwYWNlIGNvbmZsaWN0IGZvdW5kIGluIGdyYW1tYXIuXFxuYCArXG4gICAgICAgICAgICBgVGhlIGdyYW1tYXIgaGFzIGJvdGggYSBUZXJtaW5hbChUb2tlbikgYW5kIGEgTm9uLVRlcm1pbmFsKFJ1bGUpIG5hbWVkOiA8JHtydWxlLm5hbWV9Pi5cXG5gICtcbiAgICAgICAgICAgIGBUbyByZXNvbHZlIHRoaXMgbWFrZSBzdXJlIGVhY2ggVGVybWluYWwgYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBhcmUgdW5pcXVlXFxuYCArXG4gICAgICAgICAgICBgVGhpcyBpcyBlYXN5IHRvIGFjY29tcGxpc2ggYnkgdXNpbmcgdGhlIGNvbnZlbnRpb24gdGhhdCBUZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGFuIHVwcGVyY2FzZSBsZXR0ZXJcXG5gICtcbiAgICAgICAgICAgIGBhbmQgTm9uLVRlcm1pbmFsIG5hbWVzIHN0YXJ0IHdpdGggYSBsb3dlciBjYXNlIGxldHRlci5gO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0aE1zZyA9IG1hcChvcHRpb25zLnByZWZpeFBhdGgsIChjdXJyVG9rKSA9PiB0b2tlbkxhYmVsKGN1cnJUb2spKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGNvbnN0IG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gYEFtYmlndW91cyBhbHRlcm5hdGl2ZXM6IDwke29wdGlvbnMuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIil9PiBkdWUgdG8gY29tbW9uIGxvb2thaGVhZCBwcmVmaXhcXG5gICtcbiAgICAgICAgICAgIGBpbiA8T1Ike29jY3VycmVuY2V9PiBpbnNpZGUgPCR7b3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZX0+IFJ1bGUsXFxuYCArXG4gICAgICAgICAgICBgPCR7cGF0aE1zZ30+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5gICtcbiAgICAgICAgICAgIGBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0NPTU1PTl9QUkVGSVhcXG5gICtcbiAgICAgICAgICAgIGBGb3IgRnVydGhlciBkZXRhaWxzLmA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCBwYXRoTXNnID0gbWFwKG9wdGlvbnMucHJlZml4UGF0aCwgKGN1cnJ0b2spID0+IHRva2VuTGFiZWwoY3VycnRvaykpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgY29uc3Qgb2NjdXJyZW5jZSA9IG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4ID09PSAwID8gXCJcIiA6IG9wdGlvbnMuYWx0ZXJuYXRpb24uaWR4O1xuICAgICAgICBsZXQgY3Vyck1lc3NhZ2UgPSBgQW1iaWd1b3VzIEFsdGVybmF0aXZlcyBEZXRlY3RlZDogPCR7b3B0aW9ucy5hbWJpZ3VpdHlJbmRpY2VzLmpvaW4oXCIgLFwiKX0+IGluIDxPUiR7b2NjdXJyZW5jZX0+YCArXG4gICAgICAgICAgICBgIGluc2lkZSA8JHtvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lfT4gUnVsZSxcXG5gICtcbiAgICAgICAgICAgIGA8JHtwYXRoTXNnfT4gbWF5IGFwcGVhcnMgYXMgYSBwcmVmaXggcGF0aCBpbiBhbGwgdGhlc2UgYWx0ZXJuYXRpdmVzLlxcbmA7XG4gICAgICAgIGN1cnJNZXNzYWdlID1cbiAgICAgICAgICAgIGN1cnJNZXNzYWdlICtcbiAgICAgICAgICAgICAgICBgU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNBTUJJR1VPVVNfQUxURVJOQVRJVkVTXFxuYCArXG4gICAgICAgICAgICAgICAgYEZvciBGdXJ0aGVyIGRldGFpbHMuYDtcbiAgICAgICAgcmV0dXJuIGN1cnJNZXNzYWdlO1xuICAgIH0sXG4gICAgYnVpbGRFbXB0eVJlcGV0aXRpb25FcnJvcihvcHRpb25zKSB7XG4gICAgICAgIGxldCBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUob3B0aW9ucy5yZXBldGl0aW9uKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVwZXRpdGlvbi5pZHggIT09IDApIHtcbiAgICAgICAgICAgIGRzbE5hbWUgKz0gb3B0aW9ucy5yZXBldGl0aW9uLmlkeDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlcnJNc2cgPSBgVGhlIHJlcGV0aXRpb24gPCR7ZHNsTmFtZX0+IHdpdGhpbiBSdWxlIDwke29wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWV9PiBjYW4gbmV2ZXIgY29uc3VtZSBhbnkgdG9rZW5zLlxcbmAgK1xuICAgICAgICAgICAgYFRoaXMgY291bGQgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLmA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICAvLyBUT0RPOiByZW1vdmUgLSBgZXJyb3JzX3B1YmxpY2AgZnJvbSBueWMuY29uZmlnLmpzIGV4Y2x1ZGVcbiAgICAvLyAgICAgICBvbmNlIHRoaXMgbWV0aG9kIGlzIGZ1bGx5IHJlbW92ZWQgZnJvbSB0aGlzIGZpbGVcbiAgICBidWlsZFRva2VuTmFtZUVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIFwiZGVwcmVjYXRlZFwiO1xuICAgIH0sXG4gICAgYnVpbGRFbXB0eUFsdGVybmF0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgQW1iaWd1b3VzIGVtcHR5IGFsdGVybmF0aXZlOiA8JHtvcHRpb25zLmVtcHR5Q2hvaWNlSWR4ICsgMX0+YCArXG4gICAgICAgICAgICBgIGluIDxPUiR7b3B0aW9ucy5hbHRlcm5hdGlvbi5pZHh9PiBpbnNpZGUgPCR7b3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZX0+IFJ1bGUuXFxuYCArXG4gICAgICAgICAgICBgT25seSB0aGUgbGFzdCBhbHRlcm5hdGl2ZSBtYXkgYmUgYW4gZW1wdHkgYWx0ZXJuYXRpdmUuYDtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkVG9vTWFueUFsdGVybmF0aXZlc0Vycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gYEFuIEFsdGVybmF0aW9uIGNhbm5vdCBoYXZlIG1vcmUgdGhhbiAyNTYgYWx0ZXJuYXRpdmVzOlxcbmAgK1xuICAgICAgICAgICAgYDxPUiR7b3B0aW9ucy5hbHRlcm5hdGlvbi5pZHh9PiBpbnNpZGUgPCR7b3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZX0+IFJ1bGUuXFxuIGhhcyAke29wdGlvbnMuYWx0ZXJuYXRpb24uZGVmaW5pdGlvbi5sZW5ndGggKyAxfSBhbHRlcm5hdGl2ZXMuYDtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkTGVmdFJlY3Vyc2lvbkVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lO1xuICAgICAgICBjb25zdCBwYXRoTmFtZXMgPSBtYXAob3B0aW9ucy5sZWZ0UmVjdXJzaW9uUGF0aCwgKGN1cnJSdWxlKSA9PiBjdXJyUnVsZS5uYW1lKTtcbiAgICAgICAgY29uc3QgbGVmdFJlY3Vyc2l2ZVBhdGggPSBgJHtydWxlTmFtZX0gLS0+ICR7cGF0aE5hbWVzXG4gICAgICAgICAgICAuY29uY2F0KFtydWxlTmFtZV0pXG4gICAgICAgICAgICAuam9pbihcIiAtLT4gXCIpfWA7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBMZWZ0IFJlY3Vyc2lvbiBmb3VuZCBpbiBncmFtbWFyLlxcbmAgK1xuICAgICAgICAgICAgYHJ1bGU6IDwke3J1bGVOYW1lfT4gY2FuIGJlIGludm9rZWQgZnJvbSBpdHNlbGYgKGRpcmVjdGx5IG9yIGluZGlyZWN0bHkpXFxuYCArXG4gICAgICAgICAgICBgd2l0aG91dCBjb25zdW1pbmcgYW55IFRva2Vucy4gVGhlIGdyYW1tYXIgcGF0aCB0aGF0IGNhdXNlcyB0aGlzIGlzOiBcXG4gJHtsZWZ0UmVjdXJzaXZlUGF0aH1cXG5gICtcbiAgICAgICAgICAgIGAgVG8gZml4IHRoaXMgcmVmYWN0b3IgeW91ciBncmFtbWFyIHRvIHJlbW92ZSB0aGUgbGVmdCByZWN1cnNpb24uXFxuYCArXG4gICAgICAgICAgICBgc2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MTF9wYXJzZXIjTGVmdF9mYWN0b3JpbmcuYDtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIC8vIFRPRE86IHJlbW92ZSAtIGBlcnJvcnNfcHVibGljYCBmcm9tIG55Yy5jb25maWcuanMgZXhjbHVkZVxuICAgIC8vICAgICAgIG9uY2UgdGhpcyBtZXRob2QgaXMgZnVsbHkgcmVtb3ZlZCBmcm9tIHRoaXMgZmlsZVxuICAgIGJ1aWxkSW52YWxpZFJ1bGVOYW1lRXJyb3Iob3B0aW9ucykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gXCJkZXByZWNhdGVkXCI7XG4gICAgfSxcbiAgICBidWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Iob3B0aW9ucykge1xuICAgICAgICBsZXQgcnVsZU5hbWU7XG4gICAgICAgIGlmIChvcHRpb25zLnRvcExldmVsUnVsZSBpbnN0YW5jZW9mIFJ1bGUpIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyTXNnID0gYER1cGxpY2F0ZSBkZWZpbml0aW9uLCBydWxlOiAtPiR7cnVsZU5hbWV9PC0gaXMgYWxyZWFkeSBkZWZpbmVkIGluIHRoZSBncmFtbWFyOiAtPiR7b3B0aW9ucy5ncmFtbWFyTmFtZX08LWA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnNfcHVibGljLmpzLm1hcCIsImltcG9ydCB7IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXIuanNcIjtcbmltcG9ydCB7IGZvckVhY2gsIHZhbHVlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlR3JhbW1hcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgcmVmUmVzb2x2ZXIgPSBuZXcgR2FzdFJlZlJlc29sdmVyVmlzaXRvcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICByZWZSZXNvbHZlci5yZXNvbHZlUmVmcygpO1xuICAgIHJldHVybiByZWZSZXNvbHZlci5lcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgR2FzdFJlZlJlc29sdmVyVmlzaXRvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lVG9Ub3BSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWVUb1RvcFJ1bGUgPSBuYW1lVG9Ub3BSdWxlO1xuICAgICAgICB0aGlzLmVyck1zZ1Byb3ZpZGVyID0gZXJyTXNnUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJlc29sdmVSZWZzKCkge1xuICAgICAgICBmb3JFYWNoKHZhbHVlcyh0aGlzLm5hbWVUb1RvcFJ1bGUpLCAocHJvZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyVG9wTGV2ZWwgPSBwcm9kO1xuICAgICAgICAgICAgcHJvZC5hY2NlcHQodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdE5vblRlcm1pbmFsKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5uYW1lVG9Ub3BSdWxlW25vZGUubm9uVGVybWluYWxOYW1lXTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZXJyTXNnUHJvdmlkZXIuYnVpbGRSdWxlTm90Rm91bmRFcnJvcih0aGlzLmN1cnJUb3BMZXZlbCwgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFU09MVkVEX1NVQlJVTEVfUkVGLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmN1cnJUb3BMZXZlbC5uYW1lLFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRSZWZOYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2VkUnVsZSA9IHJlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCIsImltcG9ydCBiYXNlRmxhdHRlbiBmcm9tICcuL19iYXNlRmxhdHRlbi5qcyc7XG5pbXBvcnQgbWFwIGZyb20gJy4vbWFwLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZmxhdHRlbmVkIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmBcbiAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAqICAgcmV0dXJuIFtuLCBuXTtcbiAqIH1cbiAqXG4gKiBfLmZsYXRNYXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICogLy8gPT4gWzEsIDEsIDIsIDJdXG4gKi9cbmZ1bmN0aW9uIGZsYXRNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSksIDEpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmbGF0TWFwO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICovXG5mdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUFnZ3JlZ2F0b3I7XG4iLCJpbXBvcnQgYmFzZUVhY2ggZnJvbSAnLi9fYmFzZUVhY2guanMnO1xuXG4vKipcbiAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICovXG5mdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUFnZ3JlZ2F0b3I7XG4iLCJpbXBvcnQgYXJyYXlBZ2dyZWdhdG9yIGZyb20gJy4vX2FycmF5QWdncmVnYXRvci5qcyc7XG5pbXBvcnQgYmFzZUFnZ3JlZ2F0b3IgZnJvbSAnLi9fYmFzZUFnZ3JlZ2F0b3IuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFnZ3JlZ2F0b3I7XG4iLCJpbXBvcnQgYmFzZUFzc2lnblZhbHVlIGZyb20gJy4vX2Jhc2VBc3NpZ25WYWx1ZS5qcyc7XG5pbXBvcnQgY3JlYXRlQWdncmVnYXRvciBmcm9tICcuL19jcmVhdGVBZ2dyZWdhdG9yLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgb3JkZXIgb2YgZ3JvdXBlZCB2YWx1ZXNcbiAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICogdmFsdWUgb2YgZWFjaCBrZXkgaXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlXG4gKiBrZXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ncm91cEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi4zXSB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmdyb3VwQnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICovXG52YXIgZ3JvdXBCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgIHJlc3VsdFtrZXldLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBncm91cEJ5O1xuIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBgbmAgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBkcm9wLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdKTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gKiAvLyA9PiBbMV1cbiAqXG4gKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDUpO1xuICogLy8gPT4gW11cbiAqXG4gKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDApO1xuICogLy8gPT4gWzEsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIGRyb3BSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICBuID0gbGVuZ3RoIC0gbjtcbiAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3BSaWdodDtcbiIsImltcG9ydCB7IGNsb25lLCBkcm9wLCBkcm9wUmlnaHQsIGZpcnN0IGFzIF9maXJzdCwgZm9yRWFjaCwgaXNFbXB0eSwgbGFzdCwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gXCIuL2ZpcnN0LmpzXCI7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdC5qc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJ1bGUsIFRlcm1pbmFsLCB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG5leHBvcnQgY2xhc3MgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIgZXh0ZW5kcyBSZXN0V2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3BQcm9kLCBwYXRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG9wUHJvZCA9IHRvcFByb2Q7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMucG9zc2libGVUb2tUeXBlcyA9IFtdO1xuICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gMDtcbiAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQXRFbmRPZlBhdGggPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRXYWxraW5nKCkge1xuICAgICAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnBhdGgucnVsZVN0YWNrWzBdICE9PSB0aGlzLnRvcFByb2QubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgcGF0aCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSB3YWxrZXIncyB0b3AgUnVsZSFcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tdXRhYmxlIGZvciB0aGUgd2luXG4gICAgICAgIHRoaXMucnVsZVN0YWNrID0gY2xvbmUodGhpcy5wYXRoLnJ1bGVTdGFjaykucmV2ZXJzZSgpOyAvLyBpbnRlbGlqIGJ1ZyByZXF1aXJlcyBhc3NlcnRpb25cbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sgPSBjbG9uZSh0aGlzLnBhdGgub2NjdXJyZW5jZVN0YWNrKS5yZXZlcnNlKCk7IC8vIGludGVsaWogYnVnIHJlcXVpcmVzIGFzc2VydGlvblxuICAgICAgICAvLyBhbHJlYWR5IHZlcmlmaWVkIHRoYXQgdGhlIGZpcnN0IHByb2R1Y3Rpb24gaXMgdmFsaWQsIHdlIG5vdyBzZWVrIHRoZSAybmQgcHJvZHVjdGlvblxuICAgICAgICB0aGlzLnJ1bGVTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFByb2QpO1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZVRva1R5cGVzO1xuICAgIH1cbiAgICB3YWxrKHByb2QsIHByZXZSZXN0ID0gW10pIHtcbiAgICAgICAgLy8gc3RvcCBzY2FubmluZyBvbmNlIHdlIGZvdW5kIHRoZSBwYXRoXG4gICAgICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgICAgICAgc3VwZXIud2Fsayhwcm9kLCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fsa1Byb2RSZWYocmVmUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIGZvdW5kIHRoZSBuZXh0IHByb2R1Y3Rpb24sIG5lZWQgdG8ga2VlcCB3YWxraW5nIGluIGl0XG4gICAgICAgIGlmIChyZWZQcm9kLnJlZmVyZW5jZWRSdWxlLm5hbWUgPT09IHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lICYmXG4gICAgICAgICAgICByZWZQcm9kLmlkeCA9PT0gdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRXhwZWN0ZWROZXh0KCk7XG4gICAgICAgICAgICB0aGlzLndhbGsocmVmUHJvZC5yZWZlcmVuY2VkUnVsZSwgZnVsbFJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUV4cGVjdGVkTmV4dCgpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjb25zdW1lIHRoZSBUZXJtaW5hbFxuICAgICAgICBpZiAoaXNFbXB0eSh0aGlzLnJ1bGVTdGFjaykpIHtcbiAgICAgICAgICAgIC8vIG11c3QgcmVzZXQgbmV4dFByb2R1Y3Rpb25YWFggdG8gYXZvaWQgd2Fsa2luZyBkb3duIGFub3RoZXIgVG9wIExldmVsIHByb2R1Y3Rpb24gd2hpbGUgd2hhdCB3ZSBhcmVcbiAgICAgICAgICAgIC8vIHJlYWxseSBzZWVraW5nIGlzIHRoZSBsYXN0IFRlcm1pbmFsLi4uXG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgICAgICB0aGlzLmlzQXRFbmRPZlBhdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgPSB0aGlzLnJ1bGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlID0gdGhpcy5vY2N1cnJlbmNlU3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTmV4dEFmdGVyVG9rZW5XYWxrZXIgZXh0ZW5kcyBBYnN0cmFjdE5leHRQb3NzaWJsZVRva2Vuc1dhbGtlciB7XG4gICAgY29uc3RydWN0b3IodG9wUHJvZCwgcGF0aCkge1xuICAgICAgICBzdXBlcih0b3BQcm9kLCBwYXRoKTtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5uZXh0VGVybWluYWxOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gMDtcbiAgICAgICAgdGhpcy5uZXh0VGVybWluYWxOYW1lID0gdGhpcy5wYXRoLmxhc3RUb2submFtZTtcbiAgICAgICAgdGhpcy5uZXh0VGVybWluYWxPY2N1cnJlbmNlID0gdGhpcy5wYXRoLmxhc3RUb2tPY2N1cnJlbmNlO1xuICAgIH1cbiAgICB3YWxrVGVybWluYWwodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAodGhpcy5pc0F0RW5kT2ZQYXRoICYmXG4gICAgICAgICAgICB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZSA9PT0gdGhpcy5uZXh0VGVybWluYWxOYW1lICYmXG4gICAgICAgICAgICB0ZXJtaW5hbC5pZHggPT09IHRoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSAmJlxuICAgICAgICAgICAgIXRoaXMuZm91bmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RQcm9kID0gbmV3IEFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogZnVsbFJlc3QgfSk7XG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlVG9rVHlwZXMgPSBmaXJzdChyZXN0UHJvZCk7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhpcyB3YWxrZXIgb25seSBcIndhbGtzXCIgYSBzaW5nbGUgXCJUT1BcIiBsZXZlbCBpbiB0aGUgR3JhbW1hciBBc3QsIHRoaXMgbWVhbnNcbiAqIGl0IG5ldmVyIFwiZm9sbG93c1wiIHByb2R1Y3Rpb24gcmVmc1xuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIgZXh0ZW5kcyBSZXN0V2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3BSdWxlLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudG9wUnVsZSA9IHRvcFJ1bGU7XG4gICAgICAgIHRoaXMub2NjdXJyZW5jZSA9IG9jY3VycmVuY2U7XG4gICAgICAgIHRoaXMucmVzdWx0ID0ge1xuICAgICAgICAgICAgdG9rZW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRW5kT2ZSdWxlOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0V2Fsa2luZygpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUnVsZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55V2Fsa2VyIGV4dGVuZHMgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIge1xuICAgIHdhbGtNYW55KG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKG1hbnlQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEFmdGVyTWFueSA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlck1hbnkgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyTWFueSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyTWFueS50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJNYW55LmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtNYW55KG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlciBleHRlbmRzIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyIHtcbiAgICB3YWxrTWFueVNlcChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChtYW55U2VwUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RBZnRlck1hbnlTZXAgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJNYW55U2VwID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlck1hbnlTZXAgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlck1hbnlTZXAudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyTWFueVNlcC5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci53YWxrTWFueVNlcChtYW55U2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVXYWxrZXIgZXh0ZW5kcyBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciB7XG4gICAgd2Fsa0F0TGVhc3RPbmUoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoYXRMZWFzdE9uZVByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWZ0ZXJBdExlYXN0T25lID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJBdExlYXN0T25lIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlckF0TGVhc3RPbmUuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIud2Fsa0F0TGVhc3RPbmUoYXRMZWFzdE9uZVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUT0RPOiByZWR1Y2UgY29kZSBkdXBsaWNhdGlvbiBpbiB0aGUgQWZ0ZXJXYWxrZXJzXG5leHBvcnQgY2xhc3MgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyIGV4dGVuZHMgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIge1xuICAgIHdhbGtBdExlYXN0T25lU2VwKGF0bGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKGF0bGVhc3RPbmVTZXBQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJmaXJzdEFmdGVyQXRMZWFzdE9uZVNlcCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIud2Fsa0F0TGVhc3RPbmVTZXAoYXRsZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcG9zc2libGVQYXRoc0Zyb20odGFyZ2V0RGVmLCBtYXhMZW5ndGgsIGN1cnJQYXRoID0gW10pIHtcbiAgICAvLyBhdm9pZCBzaWRlIGVmZmVjdHNcbiAgICBjdXJyUGF0aCA9IGNsb25lKGN1cnJQYXRoKTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gcmVtYWluaW5nUGF0aFdpdGgobmV4dERlZikge1xuICAgICAgICByZXR1cm4gbmV4dERlZi5jb25jYXQoZHJvcCh0YXJnZXREZWYsIGkgKyAxKSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGF2b2lkIGlubmVyIGZ1bmNzXG4gICAgZnVuY3Rpb24gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IHBvc3NpYmxlUGF0aHNGcm9tKHJlbWFpbmluZ1BhdGhXaXRoKGRlZmluaXRpb24pLCBtYXhMZW5ndGgsIGN1cnJQYXRoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoYWx0ZXJuYXRpdmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFuZGF0b3J5IHByb2R1Y3Rpb25zIHdpbGwgaGFsdCB0aGUgbG9vcCBhcyB0aGUgcGF0aHMgY29tcHV0ZWQgZnJvbSB0aGVpciByZWN1cnNpdmUgY2FsbHMgd2lsbCBhbHJlYWR5IGNvbnRhaW4gdGhlXG4gICAgICogZm9sbG93aW5nIChyZXN0KSBvZiB0aGUgdGFyZ2V0RGVmLlxuICAgICAqXG4gICAgICogRm9yIG9wdGlvbmFsIHByb2R1Y3Rpb25zIChPcHRpb24vUmVwZXRpdGlvbi8uLi4pIHRoZSBsb29wIHdpbGwgY29udGludWUgdG8gcmVwcmVzZW50IHRoZSBwYXRocyB0aGF0IGRvIG5vdCBpbmNsdWRlIHRoZVxuICAgICAqIHRoZSBvcHRpb25hbCBwcm9kdWN0aW9uLlxuICAgICAqL1xuICAgIHdoaWxlIChjdXJyUGF0aC5sZW5ndGggPCBtYXhMZW5ndGggJiYgaSA8IHRhcmdldERlZi5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcHJvZCA9IHRhcmdldERlZltpXTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQWx0ZXJuYXRpdmUoeyBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24gfSksXG4gICAgICAgICAgICAgICAgbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvciB9KV0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsdGVybmF0aXZlc0ZvclByb2QobmV3RGVmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW25ldyBUZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3IgfSldLmNvbmNhdChwcm9kLmRlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW1xuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICBmb3JFYWNoKHByb2QuZGVmaW5pdGlvbiwgKGN1cnJBbHQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIGEgbGltaXRlZCBjaGVjayBmb3IgZW1wdHkgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgICAgLy8gICBJdCB3b3VsZCBwcmV2ZW50IGEgY29tbW9uIGNhc2Ugb2YgaW5maW5pdGUgbG9vcHMgZHVyaW5nIHBhcnNlciBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICAgICAgICAvLyAgIEhvd2V2ZXIgKippbi1kaXJlY3RseSoqIGVtcHR5IGFsdGVybmF0aXZlcyBtYXkgc3RpbGwgY2F1c2UgaXNzdWVzLlxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KGN1cnJBbHQuZGVmaW5pdGlvbikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QoY3VyckFsdC5kZWZpbml0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICBjdXJyUGF0aC5wdXNoKHByb2QudGVybWluYWxUeXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHBhcnRpYWxQYXRoOiBjdXJyUGF0aCxcbiAgICAgICAgc3VmZml4RGVmOiBkcm9wKHRhcmdldERlZiwgaSksXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXh0UG9zc2libGVUb2tlbnNBZnRlcihpbml0aWFsRGVmLCB0b2tlblZlY3RvciwgdG9rTWF0Y2hlciwgbWF4TG9va0FoZWFkKSB7XG4gICAgY29uc3QgRVhJVF9OT05fVEVSTUlOQUwgPSBcIkVYSVRfTk9ORV9URVJNSU5BTFwiO1xuICAgIC8vIHRvIGF2b2lkIGNyZWF0aW5nIGEgbmV3IEFycmF5IGVhY2ggdGltZS5cbiAgICBjb25zdCBFWElUX05PTl9URVJNSU5BTF9BUlIgPSBbRVhJVF9OT05fVEVSTUlOQUxdO1xuICAgIGNvbnN0IEVYSVRfQUxURVJOQVRJVkUgPSBcIkVYSVRfQUxURVJOQVRJVkVcIjtcbiAgICBsZXQgZm91bmRDb21wbGV0ZVBhdGggPSBmYWxzZTtcbiAgICBjb25zdCB0b2tlblZlY3Rvckxlbmd0aCA9IHRva2VuVmVjdG9yLmxlbmd0aDtcbiAgICBjb25zdCBtaW5pbWFsQWx0ZXJuYXRpdmVzSW5kZXggPSB0b2tlblZlY3Rvckxlbmd0aCAtIG1heExvb2tBaGVhZCAtIDE7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgcG9zc2libGVQYXRocyA9IFtdO1xuICAgIHBvc3NpYmxlUGF0aHMucHVzaCh7XG4gICAgICAgIGlkeDogLTEsXG4gICAgICAgIGRlZjogaW5pdGlhbERlZixcbiAgICAgICAgcnVsZVN0YWNrOiBbXSxcbiAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBbXSxcbiAgICB9KTtcbiAgICB3aGlsZSAoIWlzRW1wdHkocG9zc2libGVQYXRocykpIHtcbiAgICAgICAgY29uc3QgY3VyclBhdGggPSBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAvLyBza2lwIGFsdGVybmF0aXZlcyBpZiBubyBtb3JlIHJlc3VsdHMgY2FuIGJlIGZvdW5kIChhc3N1bWluZyBkZXRlcm1pbmlzdGljIGdyYW1tYXIgd2l0aCBmaXhlZCBsb29rYWhlYWQpXG4gICAgICAgIGlmIChjdXJyUGF0aCA9PT0gRVhJVF9BTFRFUk5BVElWRSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kQ29tcGxldGVQYXRoICYmXG4gICAgICAgICAgICAgICAgbGFzdChwb3NzaWJsZVBhdGhzKS5pZHggPD0gbWluaW1hbEFsdGVybmF0aXZlc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGlycmVsZXZhbnQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VyckRlZiA9IGN1cnJQYXRoLmRlZjtcbiAgICAgICAgY29uc3QgY3VycklkeCA9IGN1cnJQYXRoLmlkeDtcbiAgICAgICAgY29uc3QgY3VyclJ1bGVTdGFjayA9IGN1cnJQYXRoLnJ1bGVTdGFjaztcbiAgICAgICAgY29uc3QgY3Vyck9jY3VycmVuY2VTdGFjayA9IGN1cnJQYXRoLm9jY3VycmVuY2VTdGFjaztcbiAgICAgICAgLy8gRm9yIEV4YW1wbGU6IGFuIGVtcHR5IHBhdGggY291bGQgZXhpc3QgaW4gYSB2YWxpZCBncmFtbWFyIGluIHRoZSBjYXNlIG9mIGFuIEVNUFRZX0FMVFxuICAgICAgICBpZiAoaXNFbXB0eShjdXJyRGVmKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvZCA9IGN1cnJEZWZbMF07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9kID09PSBFWElUX05PTl9URVJNSU5BTCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGRyb3BSaWdodChjdXJyUnVsZVN0YWNrKSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGRyb3BSaWdodChjdXJyT2NjdXJyZW5jZVN0YWNrKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChjdXJySWR4IDwgdG9rZW5WZWN0b3JMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dElkeCA9IGN1cnJJZHggKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbFRva2VuID0gdG9rZW5WZWN0b3JbbmV4dElkeF07XG4gICAgICAgICAgICAgICAgaWYgKHRva01hdGNoZXIoYWN0dWFsVG9rZW4sIHByb2QudGVybWluYWxUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeDogbmV4dElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJySWR4ID09PSB0b2tlblZlY3Rvckxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAvLyBJR05PUkUgQUJPVkUgRUxTRVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRva2VuVHlwZTogcHJvZC50ZXJtaW5hbFR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlbk9jY3VycmVuY2U6IHByb2QuaWR4LFxuICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3VuZENvbXBsZXRlUGF0aCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UnVsZVN0YWNrID0gY2xvbmUoY3VyclJ1bGVTdGFjayk7XG4gICAgICAgICAgICBuZXdSdWxlU3RhY2sucHVzaChwcm9kLm5vblRlcm1pbmFsTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBuZXdPY2N1cnJlbmNlU3RhY2sgPSBjbG9uZShjdXJyT2NjdXJyZW5jZVN0YWNrKTtcbiAgICAgICAgICAgIG5ld09jY3VycmVuY2VTdGFjay5wdXNoKHByb2QuaWR4KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoRVhJVF9OT05fVEVSTUlOQUxfQVJSLCBkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IG5ld1J1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IG5ld09jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogcHJvZC5kZWZpbml0aW9uLmNvbmNhdChkcm9wKGN1cnJEZWYpKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOihUSEUgTkVXIG9wZXJhdG9ycyBoZXJlIHRha2UgYSB3aGlsZS4uLikgKGNvbnZlcnQgb25jZT8pXG4gICAgICAgICAgICBjb25zdCBzZWNvbmRJdGVyYXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtzZWNvbmRJdGVyYXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgLy8gVE9ETzooVEhFIE5FVyBvcGVyYXRvcnMgaGVyZSB0YWtlIGEgd2hpbGUuLi4pIChjb252ZXJ0IG9uY2U/KVxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yR2FzdCA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgICAgICAgICAgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kSXRlcmF0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtzZXBhcmF0b3JHYXN0XS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbc2Vjb25kSXRlcmF0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JHYXN0ID0gbmV3IFRlcm1pbmFsKHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBudGhSZXBldGl0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtzZXBhcmF0b3JHYXN0XS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbbnRoUmVwZXRpdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IG5leHREZWYsXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgY29uc3QgbmV4dFBhdGhXaXRob3V0ID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRob3V0KTtcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIG1hcmtlciB0byBhdm9pZCBiYWNrdHJhY2tpbmcgcGF0aHMgd2hvc2UgaGlnaGVyIHByaW9yaXR5IGFsdGVybmF0aXZlcyBhbHJlYWR5IG1hdGNoZWRcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChFWElUX0FMVEVSTkFUSVZFKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGFuIGVtcHR5IHJlcGV0aXRpb24gd2lsbCBjYXVzZSBpbmZpbml0ZSBsb29wcyBoZXJlLCB3aWxsIHRoZSBwYXJzZXIgZGV0ZWN0IHRoaXMgaW4gc2VsZkFuYWx5c2lzP1xuICAgICAgICAgICAgY29uc3QgbnRoUmVwZXRpdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW250aFJlcGV0aXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoV2l0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gcHJvZC5kZWZpbml0aW9uLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdCA9IHByb2QuZGVmaW5pdGlvbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyQWx0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgICAgICBkZWY6IGN1cnJBbHQuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKGN1cnJBbHRQYXRoKTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aXZlKSB7XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSdWxlKSB7XG4gICAgICAgICAgICAvLyBsYXN0IGJlY2F1c2Ugd2Ugc2hvdWxkIG9ubHkgZW5jb3VudGVyIGF0IG1vc3QgYSBzaW5nbGUgb25lIG9mIHRoZXNlIHBlciBpbnZvY2F0aW9uLlxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKGV4cGFuZFRvcExldmVsUnVsZShwcm9kLCBjdXJySWR4LCBjdXJyUnVsZVN0YWNrLCBjdXJyT2NjdXJyZW5jZVN0YWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBleHBhbmRUb3BMZXZlbFJ1bGUodG9wUnVsZSwgY3VycklkeCwgY3VyclJ1bGVTdGFjaywgY3Vyck9jY3VycmVuY2VTdGFjaykge1xuICAgIGNvbnN0IG5ld1J1bGVTdGFjayA9IGNsb25lKGN1cnJSdWxlU3RhY2spO1xuICAgIG5ld1J1bGVTdGFjay5wdXNoKHRvcFJ1bGUubmFtZSk7XG4gICAgY29uc3QgbmV3Q3Vyck9jY3VycmVuY2VTdGFjayA9IGNsb25lKGN1cnJPY2N1cnJlbmNlU3RhY2spO1xuICAgIC8vIHRvcCBydWxlIGlzIGFsd2F5cyBhc3N1bWVkIHRvIGhhdmUgYmVlbiBjYWxsZWQgd2l0aCBvY2N1cnJlbmNlIGluZGV4IDFcbiAgICBuZXdDdXJyT2NjdXJyZW5jZVN0YWNrLnB1c2goMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICBkZWY6IHRvcFJ1bGUuZGVmaW5pdGlvbixcbiAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogbmV3Q3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW50ZXJwcmV0ZXIuanMubWFwIiwiaW1wb3J0IHsgZXZlcnksIGZsYXR0ZW4sIGZvckVhY2gsIGhhcywgaXNFbXB0eSwgbWFwLCByZWR1Y2UgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBwb3NzaWJsZVBhdGhzRnJvbSB9IGZyb20gXCIuL2ludGVycHJldGVyLmpzXCI7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdC5qc1wiO1xuaW1wb3J0IHsgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcywgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSBhcyBBbHRlcm5hdGl2ZUdBU1QsIEdBc3RWaXNpdG9yLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuZXhwb3J0IHZhciBQUk9EX1RZUEU7XG4oZnVuY3Rpb24gKFBST0RfVFlQRSkge1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJPUFRJT05cIl0gPSAwXSA9IFwiT1BUSU9OXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05cIl0gPSAxXSA9IFwiUkVQRVRJVElPTlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX01BTkRBVE9SWVwiXSA9IDJdID0gXCJSRVBFVElUSU9OX01BTkRBVE9SWVwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUlwiXSA9IDNdID0gXCJSRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SXCJdID0gNF0gPSBcIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiQUxURVJOQVRJT05cIl0gPSA1XSA9IFwiQUxURVJOQVRJT05cIjtcbn0pKFBST0RfVFlQRSB8fCAoUFJPRF9UWVBFID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9kVHlwZShwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fCBwcm9kID09PSBcIk9wdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuT1BUSU9OO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fCBwcm9kID09PSBcIlJlcGV0aXRpb25cIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBwcm9kID09PSBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbiB8fCBwcm9kID09PSBcIkFsdGVybmF0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5BTFRFUk5BVElPTjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG9jY3VycmVuY2UsIHJ1bGUsIHByb2RUeXBlLCBtYXhMb29rYWhlYWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHlwZSA9IGdldFByb2RUeXBlKHByb2RUeXBlKTtcbiAgICBpZiAodHlwZSA9PT0gUFJPRF9UWVBFLkFMVEVSTkFUSU9OKSB7XG4gICAgICAgIHJldHVybiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGUsIG1heExvb2thaGVhZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZSwgdHlwZSwgbWF4TG9va2FoZWFkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCwgaGFzUHJlZGljYXRlcywgZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGxhRnVuY0J1aWxkZXIpIHtcbiAgICBjb25zdCBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCk7XG4gICAgY29uc3QgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbGFGdW5jQnVpbGRlcihsb29rQWhlYWRQYXRocywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG4vKipcbiAqICBXaGVuIGRlYWxpbmcgd2l0aCBhbiBPcHRpb25hbCBwcm9kdWN0aW9uIChPUFRJT04vTUFOWS8ybmQgaXRlcmF0aW9uIG9mIEFUX0xFQVNUX09ORS8uLi4pIHdlIG5lZWQgdG8gY29tcGFyZVxuICogIHRoZSBsb29rYWhlYWQgXCJpbnNpZGVcIiB0aGUgcHJvZHVjdGlvbiBhbmQgdGhlIGxvb2thaGVhZCBpbW1lZGlhdGVseSBcImFmdGVyXCIgaXQgaW4gdGhlIHNhbWUgdG9wIGxldmVsIHJ1bGUgKGNvbnRleHQgZnJlZSkuXG4gKlxuICogIEV4YW1wbGU6IGdpdmVuIGEgcHJvZHVjdGlvbjpcbiAqICBBQkMoREUpP0RGXG4gKlxuICogIFRoZSBvcHRpb25hbCAnKERFKT8nIHNob3VsZCBvbmx5IGJlIGVudGVyZWQgaWYgd2Ugc2VlICdERScuIGEgc2luZ2xlIFRva2VuICdEJyBpcyBub3Qgc3VmZmljaWVudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d29cbiAqICBhbHRlcm5hdGl2ZXMuXG4gKlxuICogIEByZXR1cm5zIEEgTG9va2FoZWFkIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgSUZGIHRoZSBwYXJzZXIgc2hvdWxkIHBhcnNlIHRoZSBPcHRpb25hbCBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIGxvb2thaGVhZEJ1aWxkZXIpIHtcbiAgICBjb25zdCBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgayk7XG4gICAgY29uc3QgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbG9va2FoZWFkQnVpbGRlcihsb29rQWhlYWRQYXRoc1swXSwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jKGFsdHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICBjb25zdCBudW1PZkFsdHMgPSBhbHRzLmxlbmd0aDtcbiAgICBjb25zdCBhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCA9IGV2ZXJ5KGFsdHMsIChjdXJyQWx0KSA9PiB7XG4gICAgICAgIHJldHVybiBldmVyeShjdXJyQWx0LCAoY3VyclBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyUGF0aC5sZW5ndGggPT09IDE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgdmVyc2lvbiB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHByZWRpY2F0ZXMgYXMgd2VsbC5cbiAgICBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2hvc2VuIGFsdGVybmF0aXZlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9yQWx0cykge1xuICAgICAgICAgICAgLy8gdW5mb3J0dW5hdGVseSB0aGUgcHJlZGljYXRlcyBtdXN0IGJlIGV4dHJhY3RlZCBldmVyeSBzaW5nbGUgdGltZVxuICAgICAgICAgICAgLy8gYXMgdGhleSBjYW5ub3QgYmUgY2FjaGVkIGR1ZSB0byByZWZlcmVuY2VzIHRvIHBhcmFtZXRlcnModmFycykgd2hpY2ggYXJlIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBpbiB0aGUgY29tbW9uIGNhc2Ugb2Ygbm8gcHJlZGljYXRlcywgbm8gY3B1IHRpbWUgd2lsbCBiZSB3YXN0ZWQgb24gdGhpcyAoc2VlIGVsc2UgYmxvY2spXG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGVzID0gbWFwKG9yQWx0cywgKGN1cnJBbHQpID0+IGN1cnJBbHQuR0FURSk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyUHJlZGljYXRlID0gcHJlZGljYXRlc1t0XTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJQcmVkaWNhdGUuY2FsbCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZWRpY2F0ZSBkb2VzIG5vdCBtYXRjaCB0aGVyZSBpcyBubyBwb2ludCBpbiBjaGVja2luZyB0aGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJOdW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGggPSBjdXJyQWx0W2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyUGF0aExlbmd0aCA9IGN1cnJQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gd29yayBmb3IgYW4gZW1wdHkgQUxUIGFzIHRoZSBsb29wIHdpbGwgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgZm9yIHRoZSBjdXJyZW50IGFsdGVybmF0aXZlIG1hdGNoZWRcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIGFsdGVybmF0aXZlcyBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIChjb21tb24pIGNhc2Ugb2YgYWxsIHRoZSBsb29rYWhlYWRzIHBhdGhzIHJlcXVpcmluZyBvbmx5XG4gICAgICAgIC8vIGEgc2luZ2xlIHRva2VuIGxvb2thaGVhZC4gVGhlc2UgT3B0aW1pemF0aW9ucyBjYW5ub3Qgd29yayBpZiBkeW5hbWljYWxseSBkZWZpbmVkIFRva2VucyBhcmUgdXNlZC5cbiAgICAgICAgY29uc3Qgc2luZ2xlVG9rZW5BbHRzID0gbWFwKGFsdHMsIChjdXJyQWx0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihjdXJyQWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHNpbmdsZVRva2VuQWx0cywgKHJlc3VsdCwgY3VyckFsdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaGFzKHJlc3VsdCwgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIChjdXJyRXh0ZW5kaW5nVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhcyhyZXN1bHQsIGN1cnJFeHRlbmRpbmdUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZVRvQWx0W25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxvb2thaGVhZCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgdGhlIHByZWRpY2F0ZXMgYXQgYWxsLlxuICAgICAgICAvLyB0aGlzIGNhdXNlcyBjb2RlIGR1cGxpY2F0aW9uIHdoaWNoIGlzIGludGVudGlvbmFsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aDogZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyTnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJQYXRoID0gY3VyckFsdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIHdvcmsgZm9yIGFuIGVtcHR5IEFMVCBhcyB0aGUgbG9vcCB3aWxsIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIGZvciB0aGUgY3VycmVudCBhbHRlcm5hdGl2ZSBtYXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IGFsdGVybmF0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgIGNvbnN0IGFyZUFsbE9uZVRva2VuTG9va2FoZWFkID0gZXZlcnkoYWx0LCAoY3VyclBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICBjb25zdCBudW1PZlBhdGhzID0gYWx0Lmxlbmd0aDtcbiAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAvLyBhIHNpbmdsZSB0b2tlbiBsb29rYWhlYWQuXG4gICAgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzaW5nbGVUb2tlbnNUeXBlcyA9IGZsYXR0ZW4oYWx0KTtcbiAgICAgICAgaWYgKHNpbmdsZVRva2Vuc1R5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgaXNFbXB0eShzaW5nbGVUb2tlbnNUeXBlc1swXS5jYXRlZ29yeU1hdGNoZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFRva2VuVHlwZSA9IHNpbmdsZVRva2Vuc1R5cGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb2tlblVuaXF1ZUtleSA9IGV4cGVjdGVkVG9rZW5UeXBlLnRva2VuVHlwZUlkeDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4ID09PSBleHBlY3RlZFRva2VuVW5pcXVlS2V5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHNpbmdsZVRva2Vuc1R5cGVzLCAocmVzdWx0LCBjdXJyVG9rVHlwZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJUb2tUeXBlLnRva2VuVHlwZUlkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvckVhY2goY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLCAoY3VyckV4dGVuZGluZ1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRbbmV4dFRva2VuLnRva2VuVHlwZUlkeF0gPT09IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbmV4dFBhdGg6IGZvciAobGV0IGogPSAwOyBqIDwgbnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGggPSBhbHRbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBwYXRocyBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIgZXh0ZW5kcyBSZXN0V2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3BQcm9kLCB0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICB0aGlzLnRhcmdldE9jY3VycmVuY2UgPSB0YXJnZXRPY2N1cnJlbmNlO1xuICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID0gdGFyZ2V0UHJvZFR5cGU7XG4gICAgfVxuICAgIHN0YXJ0V2Fsa2luZygpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3REZWY7XG4gICAgfVxuICAgIGNoZWNrSXNUYXJnZXQobm9kZSwgZXhwZWN0ZWRQcm9kVHlwZSwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChub2RlLmlkeCA9PT0gdGhpcy50YXJnZXRPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID09PSBleHBlY3RlZFByb2RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3REZWYgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBkbyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgR3JhbW1hciBhc3QgYWZ0ZXIgd2UgaGF2ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2Fsa09wdGlvbihvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQob3B0aW9uUHJvZCwgUFJPRF9UWVBFLk9QVElPTiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgc3VwZXIud2Fsa09wdGlvbihvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhbGtBdExlYXN0T25lKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQoYXRMZWFzdE9uZVByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgc3VwZXIud2Fsa09wdGlvbihhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YWxrQXRMZWFzdE9uZVNlcChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KGF0TGVhc3RPbmVTZXBQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24oYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fsa01hbnkobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55UHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24obWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fsa01hbnlTZXAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55U2VwUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24obWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmluaXRpb24gb2YgYSB0YXJnZXQgcHJvZHVjdGlvbiBpbiBhIHRvcCBsZXZlbCBsZXZlbCBydWxlLlxuICovXG5jbGFzcyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSwgdGFyZ2V0UmVmKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0T2NjdXJyZW5jZSA9IHRhcmdldE9jY3VycmVuY2U7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgdGhpcy50YXJnZXRSZWYgPSB0YXJnZXRSZWY7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgfVxuICAgIGNoZWNrSXNUYXJnZXQobm9kZSwgZXhwZWN0ZWRQcm9kTmFtZSkge1xuICAgICAgICBpZiAobm9kZS5pZHggPT09IHRoaXMudGFyZ2V0T2NjdXJyZW5jZSAmJlxuICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9kVHlwZSA9PT0gZXhwZWN0ZWRQcm9kTmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMudGFyZ2V0UmVmID09PSB1bmRlZmluZWQgfHwgbm9kZSA9PT0gdGhpcy50YXJnZXRSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG5vZGUuZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdE9wdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuT1BUSU9OKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUik7XG4gICAgfVxuICAgIHZpc2l0QWx0ZXJuYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLkFMVEVSTkFUSU9OKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQXJyYXlPZkFycmF5cyhzaXplKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBIHNvcnQgb2YgaGFzaCBmdW5jdGlvbiBiZXR3ZWVuIGEgUGF0aCBpbiB0aGUgZ3JhbW1hciBhbmQgYSBzdHJpbmcuXG4gKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIG11bHRpcGxlIFwiaGFzaGVzXCIgdG8gc3VwcG9ydCB0aGUgc2NlbmFyaW8gb2YgdG9rZW4gY2F0ZWdvcmllcy5cbiAqIC0gIEEgc2luZ2xlIHBhdGggd2l0aCBjYXRlZ29yaWVzIG1heSBtYXRjaCBtdWx0aXBsZSAqKmFjdHVhbCoqIHBhdGhzLlxuICovXG5mdW5jdGlvbiBwYXRoVG9IYXNoS2V5cyhwYXRoKSB7XG4gICAgbGV0IGtleXMgPSBbXCJcIl07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRva1R5cGUgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCBsb25nZXJLZXlzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY3VyclNob3J0ZXJLZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgXCJfXCIgKyB0b2tUeXBlLnRva2VuVHlwZUlkeCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllc0tleVN1ZmZpeCA9IFwiX1wiICsgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNbdF07XG4gICAgICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgY2F0ZWdvcmllc0tleVN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGxvbmdlcktleXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBJbXBlcmF0aXZlIHN0eWxlIGR1ZSB0byBiZWluZyBjYWxsZWQgZnJvbSBhIGhvdCBzcG90XG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlUHJlZml4SGFzaChhbHRLbm93blBhdGhzS2V5cywgc2VhcmNoUGF0aEtleXMsIGlkeCkge1xuICAgIGZvciAobGV0IGN1cnJBbHRJZHggPSAwOyBjdXJyQWx0SWR4IDwgYWx0S25vd25QYXRoc0tleXMubGVuZ3RoOyBjdXJyQWx0SWR4KyspIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRlc3QgdnMgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgICAgICBpZiAoY3VyckFsdElkeCA9PT0gaWR4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlckFsdEtub3duUGF0aHNLZXlzID0gYWx0S25vd25QYXRoc0tleXNbY3VyckFsdElkeF07XG4gICAgICAgIGZvciAobGV0IHNlYXJjaElkeCA9IDA7IHNlYXJjaElkeCA8IHNlYXJjaFBhdGhLZXlzLmxlbmd0aDsgc2VhcmNoSWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaEtleSA9IHNlYXJjaFBhdGhLZXlzW3NlYXJjaElkeF07XG4gICAgICAgICAgICBpZiAob3RoZXJBbHRLbm93blBhdGhzS2V5c1tzZWFyY2hLZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vbmUgb2YgdGhlIFNlYXJjaFBhdGhLZXlzIHdlcmUgZm91bmQgaW4gYW55IG9mIHRoZSBvdGhlciBhbHRlcm5hdGl2ZXNcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXMoYWx0c0RlZnMsIGspIHtcbiAgICBjb25zdCBwYXJ0aWFsQWx0cyA9IG1hcChhbHRzRGVmcywgKGN1cnJBbHQpID0+IHBvc3NpYmxlUGF0aHNGcm9tKFtjdXJyQWx0XSwgMSkpO1xuICAgIGNvbnN0IGZpbmFsUmVzdWx0ID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMocGFydGlhbEFsdHMubGVuZ3RoKTtcbiAgICBjb25zdCBhbHRzSGFzaGVzID0gbWFwKHBhcnRpYWxBbHRzLCAoY3VyckFsdFBhdGhzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpY3QgPSB7fTtcbiAgICAgICAgZm9yRWFjaChjdXJyQWx0UGF0aHMsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gcGF0aFRvSGFzaEtleXMoaXRlbS5wYXJ0aWFsUGF0aCk7XG4gICAgICAgICAgICBmb3JFYWNoKGtleXMsIChjdXJyS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGljdFtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH0pO1xuICAgIGxldCBuZXdEYXRhID0gcGFydGlhbEFsdHM7XG4gICAgLy8gbWF4TG9va2FoZWFkIGxvb3BcbiAgICBmb3IgKGxldCBwYXRoTGVuZ3RoID0gMTsgcGF0aExlbmd0aCA8PSBrOyBwYXRoTGVuZ3RoKyspIHtcbiAgICAgICAgY29uc3QgY3VyckRhdGFzZXQgPSBuZXdEYXRhO1xuICAgICAgICBuZXdEYXRhID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMoY3VyckRhdGFzZXQubGVuZ3RoKTtcbiAgICAgICAgLy8gYWx0ZXJuYXRpdmVzIGxvb3BcbiAgICAgICAgZm9yIChsZXQgYWx0SWR4ID0gMDsgYWx0SWR4IDwgY3VyckRhdGFzZXQubGVuZ3RoOyBhbHRJZHgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyckFsdFBhdGhzQW5kU3VmZml4ZXMgPSBjdXJyRGF0YXNldFthbHRJZHhdO1xuICAgICAgICAgICAgLy8gcGF0aHMgaW4gY3VycmVudCBhbHRlcm5hdGl2ZSBsb29wXG4gICAgICAgICAgICBmb3IgKGxldCBjdXJyUGF0aElkeCA9IDA7IGN1cnJQYXRoSWR4IDwgY3VyckFsdFBhdGhzQW5kU3VmZml4ZXMubGVuZ3RoOyBjdXJyUGF0aElkeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhQcmVmaXggPSBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlc1tjdXJyUGF0aElkeF0ucGFydGlhbFBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4RGVmID0gY3VyckFsdFBhdGhzQW5kU3VmZml4ZXNbY3VyclBhdGhJZHhdLnN1ZmZpeERlZjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhLZXlzID0gcGF0aFRvSGFzaEtleXMoY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVW5pcXVlID0gaXNVbmlxdWVQcmVmaXhIYXNoKGFsdHNIYXNoZXMsIHByZWZpeEtleXMsIGFsdElkeCk7XG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIHRoZSBsaW5lIGZvciB0aGlzIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5pcXVlIHx8IGlzRW1wdHkoc3VmZml4RGVmKSB8fCBjdXJyUGF0aFByZWZpeC5sZW5ndGggPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdFJlc3VsdCA9IGZpbmFsUmVzdWx0W2FsdElkeF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENhbiB3ZSBpbXBsZW1lbnQgYSBjb250YWluc1BhdGggdXNpbmcgTWFwcy9EaWN0aW9uYXJpZXM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BhdGgoY3VyckFsdFJlc3VsdCwgY3VyclBhdGhQcmVmaXgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFsdFJlc3VsdC5wdXNoKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgbmV3ICBrZXlzIGZvciB0aGUgY3VycmVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmVmaXhLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycktleSA9IHByZWZpeEtleXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0c0hhc2hlc1thbHRJZHhdW2N1cnJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbG9uZ2VyIHBhdGhzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzID0gcG9zc2libGVQYXRoc0Zyb20oc3VmZml4RGVmLCBwYXRoTGVuZ3RoICsgMSwgY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2FsdElkeF0gPSBuZXdEYXRhW2FsdElkeF0uY29uY2F0KG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGtleXMgZm9yIG5ldyBrbm93biBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4S2V5cyA9IHBhdGhUb0hhc2hLZXlzKGl0ZW0ucGFydGlhbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChwcmVmaXhLZXlzLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0c0hhc2hlc1thbHRJZHhdW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgaywgb3JQcm9kKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcihvY2N1cnJlbmNlLCBQUk9EX1RZUEUuQUxURVJOQVRJT04sIG9yUHJvZCk7XG4gICAgcnVsZUdyYW1tYXIuYWNjZXB0KHZpc2l0b3IpO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXModmlzaXRvci5yZXN1bHQsIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgaykge1xuICAgIGNvbnN0IGluc2lkZURlZlZpc2l0b3IgPSBuZXcgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3Iob2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIHJ1bGVHcmFtbWFyLmFjY2VwdChpbnNpZGVEZWZWaXNpdG9yKTtcbiAgICBjb25zdCBpbnNpZGVEZWYgPSBpbnNpZGVEZWZWaXNpdG9yLnJlc3VsdDtcbiAgICBjb25zdCBhZnRlckRlZldhbGtlciA9IG5ldyBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlcihydWxlR3JhbW1hciwgb2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIGNvbnN0IGFmdGVyRGVmID0gYWZ0ZXJEZWZXYWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgY29uc3QgaW5zaWRlRmxhdCA9IG5ldyBBbHRlcm5hdGl2ZUdBU1QoeyBkZWZpbml0aW9uOiBpbnNpZGVEZWYgfSk7XG4gICAgY29uc3QgYWZ0ZXJGbGF0ID0gbmV3IEFsdGVybmF0aXZlR0FTVCh7IGRlZmluaXRpb246IGFmdGVyRGVmIH0pO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXMoW2luc2lkZUZsYXQsIGFmdGVyRmxhdF0sIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUGF0aChhbHRlcm5hdGl2ZSwgc2VhcmNoUGF0aCkge1xuICAgIGNvbXBhcmVPdGhlclBhdGg6IGZvciAobGV0IGkgPSAwOyBpIDwgYWx0ZXJuYXRpdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJQYXRoID0gYWx0ZXJuYXRpdmVbaV07XG4gICAgICAgIGlmIChvdGhlclBhdGgubGVuZ3RoICE9PSBzZWFyY2hQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlclBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFRvayA9IHNlYXJjaFBhdGhbal07XG4gICAgICAgICAgICBjb25zdCBvdGhlclRvayA9IG90aGVyUGF0aFtqXTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVG9rZW5zID0gc2VhcmNoVG9rID09PSBvdGhlclRvayB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9rLmNhdGVnb3J5TWF0Y2hlc01hcFtzZWFyY2hUb2sudG9rZW5UeXBlSWR4XSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVG9rZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIGNvbXBhcmVPdGhlclBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmljdFByZWZpeE9mUGF0aChwcmVmaXgsIG90aGVyKSB7XG4gICAgcmV0dXJuIChwcmVmaXgubGVuZ3RoIDwgb3RoZXIubGVuZ3RoICYmXG4gICAgICAgIGV2ZXJ5KHByZWZpeCwgKHRva1R5cGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJUb2tUeXBlID0gb3RoZXJbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiAodG9rVHlwZSA9PT0gb3RoZXJUb2tUeXBlIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcFt0b2tUeXBlLnRva2VuVHlwZUlkeF0pO1xuICAgICAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocykge1xuICAgIHJldHVybiBldmVyeShsb29rQWhlYWRQYXRocywgKHNpbmdsZUFsdFBhdGhzKSA9PiBldmVyeShzaW5nbGVBbHRQYXRocywgKHNpbmdsZVBhdGgpID0+IGV2ZXJ5KHNpbmdsZVBhdGgsICh0b2tlbikgPT4gaXNFbXB0eSh0b2tlbi5jYXRlZ29yeU1hdGNoZXMpKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9va2FoZWFkLmpzLm1hcCIsImltcG9ydCB7IGNsb25lLCBjb21wYWN0LCBkaWZmZXJlbmNlLCBkcm9wLCBkcm9wUmlnaHQsIGZpbHRlciwgZmlyc3QsIGZsYXRNYXAsIGZsYXR0ZW4sIGZvckVhY2gsIGdyb3VwQnksIGluY2x1ZGVzLCBpc0VtcHR5LCBtYXAsIHBpY2tCeSwgcmVkdWNlLCByZWplY3QsIHZhbHVlcywgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLCB9IGZyb20gXCIuLi9wYXJzZXIvcGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUgYXMgQWx0ZXJuYXRpdmVHQVNULCBHQXN0VmlzaXRvciwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUsIGlzT3B0aW9uYWxQcm9kLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFRlcm1pbmFsLCB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG5pbXBvcnQgeyBjb250YWluc1BhdGgsIGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9yLCBnZXRQcm9kVHlwZSwgaXNTdHJpY3RQcmVmaXhPZlBhdGgsIH0gZnJvbSBcIi4vbG9va2FoZWFkLmpzXCI7XG5pbXBvcnQgeyBuZXh0UG9zc2libGVUb2tlbnNBZnRlciB9IGZyb20gXCIuL2ludGVycHJldGVyLmpzXCI7XG5pbXBvcnQgeyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyIH0gZnJvbSBcIi4uLy4uL3NjYW4vdG9rZW5zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVMb29rYWhlYWQob3B0aW9ucykge1xuICAgIGNvbnN0IGxvb2thaGVhZFZhbGlkYXRpb25FcnJvck1lc3NhZ2VzID0gb3B0aW9ucy5sb29rYWhlYWRTdHJhdGVneS52YWxpZGF0ZSh7XG4gICAgICAgIHJ1bGVzOiBvcHRpb25zLnJ1bGVzLFxuICAgICAgICB0b2tlblR5cGVzOiBvcHRpb25zLnRva2VuVHlwZXMsXG4gICAgICAgIGdyYW1tYXJOYW1lOiBvcHRpb25zLmdyYW1tYXJOYW1lLFxuICAgIH0pO1xuICAgIHJldHVybiBtYXAobG9va2FoZWFkVmFsaWRhdGlvbkVycm9yTWVzc2FnZXMsIChlcnJvck1lc3NhZ2UpID0+IChPYmplY3QuYXNzaWduKHsgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DVVNUT01fTE9PS0FIRUFEX1ZBTElEQVRJT04gfSwgZXJyb3JNZXNzYWdlKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlR3JhbW1hcih0b3BMZXZlbHMsIHRva2VuVHlwZXMsIGVyck1zZ1Byb3ZpZGVyLCBncmFtbWFyTmFtZSkge1xuICAgIGNvbnN0IGR1cGxpY2F0ZUVycm9ycyA9IGZsYXRNYXAodG9wTGV2ZWxzLCAoY3VyclRvcExldmVsKSA9PiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKGN1cnJUb3BMZXZlbCwgZXJyTXNnUHJvdmlkZXIpKTtcbiAgICBjb25zdCB0ZXJtc05hbWVzcGFjZUNvbmZsaWN0RXJyb3JzID0gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcik7XG4gICAgY29uc3QgdG9vTWFueUFsdHNFcnJvcnMgPSBmbGF0TWFwKHRvcExldmVscywgKGN1clJ1bGUpID0+IHZhbGlkYXRlVG9vTWFueUFsdHMoY3VyUnVsZSwgZXJyTXNnUHJvdmlkZXIpKTtcbiAgICBjb25zdCBkdXBsaWNhdGVSdWxlc0Vycm9yID0gZmxhdE1hcCh0b3BMZXZlbHMsIChjdXJSdWxlKSA9PiB2YWxpZGF0ZVJ1bGVEb2VzTm90QWxyZWFkeUV4aXN0KGN1clJ1bGUsIHRvcExldmVscywgZ3JhbW1hck5hbWUsIGVyck1zZ1Byb3ZpZGVyKSk7XG4gICAgcmV0dXJuIGR1cGxpY2F0ZUVycm9ycy5jb25jYXQodGVybXNOYW1lc3BhY2VDb25mbGljdEVycm9ycywgdG9vTWFueUFsdHNFcnJvcnMsIGR1cGxpY2F0ZVJ1bGVzRXJyb3IpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVEdXBsaWNhdGVQcm9kdWN0aW9ucyh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQoY29sbGVjdG9yVmlzaXRvcik7XG4gICAgY29uc3QgYWxsUnVsZVByb2R1Y3Rpb25zID0gY29sbGVjdG9yVmlzaXRvci5hbGxQcm9kdWN0aW9ucztcbiAgICBjb25zdCBwcm9kdWN0aW9uR3JvdXBzID0gZ3JvdXBCeShhbGxSdWxlUHJvZHVjdGlvbnMsIGlkZW50aWZ5UHJvZHVjdGlvbkZvckR1cGxpY2F0ZXMpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZXMgPSBwaWNrQnkocHJvZHVjdGlvbkdyb3VwcywgKGN1cnJHcm91cCkgPT4ge1xuICAgICAgICByZXR1cm4gY3Vyckdyb3VwLmxlbmd0aCA+IDE7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JzID0gbWFwKHZhbHVlcyhkdXBsaWNhdGVzKSwgKGN1cnJEdXBsaWNhdGVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpcnN0UHJvZCA9IGZpcnN0KGN1cnJEdXBsaWNhdGVzKTtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGREdXBsaWNhdGVGb3VuZEVycm9yKHRvcExldmVsUnVsZSwgY3VyckR1cGxpY2F0ZXMpO1xuICAgICAgICBjb25zdCBkc2xOYW1lID0gZ2V0UHJvZHVjdGlvbkRzbE5hbWUoZmlyc3RQcm9kKTtcbiAgICAgICAgY29uc3QgZGVmRXJyb3IgPSB7XG4gICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkRVUExJQ0FURV9QUk9EVUNUSU9OUyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgIGRzbE5hbWU6IGRzbE5hbWUsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBmaXJzdFByb2QuaWR4LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXJhbSA9IGdldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KGZpcnN0UHJvZCk7XG4gICAgICAgIGlmIChwYXJhbSkge1xuICAgICAgICAgICAgZGVmRXJyb3IucGFyYW1ldGVyID0gcGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZkVycm9yO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyhwcm9kKSB7XG4gICAgcmV0dXJuIGAke2dldFByb2R1Y3Rpb25Ec2xOYW1lKHByb2QpfV8jXyR7cHJvZC5pZHh9XyNfJHtnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKX1gO1xufVxuZnVuY3Rpb24gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQocHJvZCkge1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gcHJvZC5ub25UZXJtaW5hbE5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT2NjdXJyZW5jZVZhbGlkYXRpb25Db2xsZWN0b3IgZXh0ZW5kcyBHQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmlzaXROb25UZXJtaW5hbChzdWJydWxlKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChzdWJydWxlKTtcbiAgICB9XG4gICAgdmlzaXRPcHRpb24ob3B0aW9uKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChvcHRpb24pO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG1hbnlTZXApIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnlTZXApO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkoYXRMZWFzdE9uZSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZSk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IoYXRMZWFzdE9uZVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbihtYW55KSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChtYW55KTtcbiAgICB9XG4gICAgdmlzaXRBbHRlcm5hdGlvbihvcikge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gob3IpO1xuICAgIH1cbiAgICB2aXNpdFRlcm1pbmFsKHRlcm1pbmFsKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaCh0ZXJtaW5hbCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QocnVsZSwgYWxsUnVsZXMsIGNsYXNzTmFtZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBvY2N1cnJlbmNlcyA9IHJlZHVjZShhbGxSdWxlcywgKHJlc3VsdCwgY3VyUnVsZSkgPT4ge1xuICAgICAgICBpZiAoY3VyUnVsZS5uYW1lID09PSBydWxlLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgMCk7XG4gICAgaWYgKG9jY3VycmVuY2VzID4gMSkge1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZVJ1bGVOYW1lRXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlLm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8gVE9ETzogaXMgdGhlcmUgYW55d2F5IHRvIGdldCBvbmx5IHRoZSBydWxlIG5hbWVzIG9mIHJ1bGVzIGluaGVyaXRlZCBmcm9tIHRoZSBzdXBlciBncmFtbWFycz9cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIElHcmFtbWFyRXJyb3JQcm92aWRlciBiZWNhdXNlIHRoZSB2YWxpZGF0aW9uIGNhbm5vdCBiZSBwZXJmb3JtZWQgb25cbi8vIFRoZSBncmFtbWFyIHN0cnVjdHVyZSwgb25seSBhdCBydW50aW1lLlxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbihydWxlTmFtZSwgZGVmaW5lZFJ1bGVzTmFtZXMsIGNsYXNzTmFtZSkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGxldCBlcnJNc2c7XG4gICAgaWYgKCFpbmNsdWRlcyhkZWZpbmVkUnVsZXNOYW1lcywgcnVsZU5hbWUpKSB7XG4gICAgICAgIGVyck1zZyA9XG4gICAgICAgICAgICBgSW52YWxpZCBydWxlIG92ZXJyaWRlLCBydWxlOiAtPiR7cnVsZU5hbWV9PC0gY2Fubm90IGJlIG92ZXJyaWRkZW4gaW4gdGhlIGdyYW1tYXI6IC0+JHtjbGFzc05hbWV9PC1gICtcbiAgICAgICAgICAgICAgICBgYXMgaXQgaXMgbm90IGRlZmluZWQgaW4gYW55IG9mIHRoZSBzdXBlciBncmFtbWFycyBgO1xuICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUlVMRV9PVkVSUklERSxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24odG9wUnVsZSwgY3VyclJ1bGUsIGVyck1zZ1Byb3ZpZGVyLCBwYXRoID0gW10pIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBuZXh0Tm9uVGVybWluYWxzID0gZ2V0Rmlyc3ROb25lVGVybWluYWwoY3VyclJ1bGUuZGVmaW5pdGlvbik7XG4gICAgaWYgKGlzRW1wdHkobmV4dE5vblRlcm1pbmFscykpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSB0b3BSdWxlLm5hbWU7XG4gICAgICAgIGNvbnN0IGZvdW5kTGVmdFJlY3Vyc2lvbiA9IGluY2x1ZGVzKG5leHROb25UZXJtaW5hbHMsIHRvcFJ1bGUpO1xuICAgICAgICBpZiAoZm91bmRMZWZ0UmVjdXJzaW9uKSB7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRMZWZ0UmVjdXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHRvcFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgIGxlZnRSZWN1cnNpb25QYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTEVGVF9SRUNVUlNJT04sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgYXJlIG9ubHkgbG9va2luZyBmb3IgY3ljbGljIHBhdGhzIGxlYWRpbmcgYmFjayB0byB0aGUgc3BlY2lmaWMgdG9wUnVsZVxuICAgICAgICAvLyBvdGhlciBjeWNsaWMgcGF0aHMgYXJlIGlnbm9yZWQsIHdlIHN0aWxsIG5lZWQgdGhpcyBkaWZmZXJlbmNlIHRvIGF2b2lkIGluZmluaXRlIGxvb3BzLi4uXG4gICAgICAgIGNvbnN0IHZhbGlkTmV4dFN0ZXBzID0gZGlmZmVyZW5jZShuZXh0Tm9uVGVybWluYWxzLCBwYXRoLmNvbmNhdChbdG9wUnVsZV0pKTtcbiAgICAgICAgY29uc3QgZXJyb3JzRnJvbU5leHRTdGVwcyA9IGZsYXRNYXAodmFsaWROZXh0U3RlcHMsIChjdXJyUmVmUnVsZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGNsb25lKHBhdGgpO1xuICAgICAgICAgICAgbmV3UGF0aC5wdXNoKGN1cnJSZWZSdWxlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbih0b3BSdWxlLCBjdXJyUmVmUnVsZSwgZXJyTXNnUHJvdmlkZXIsIG5ld1BhdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5jb25jYXQoZXJyb3JzRnJvbU5leHRTdGVwcyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEZpcnN0Tm9uZVRlcm1pbmFsKGRlZmluaXRpb24pIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgaWYgKGlzRW1wdHkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQcm9kID0gZmlyc3QoZGVmaW5pdGlvbik7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZmlyc3RQcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmVHQVNUIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBmaXJzdFByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChnZXRGaXJzdE5vbmVUZXJtaW5hbChmaXJzdFByb2QuZGVmaW5pdGlvbikpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBlYWNoIHN1YiBkZWZpbml0aW9uIGluIGFsdGVybmF0aW9uIGlzIGEgRkxBVFxuICAgICAgICByZXN1bHQgPSBmbGF0dGVuKG1hcChmaXJzdFByb2QuZGVmaW5pdGlvbiwgKGN1cnJTdWJEZWYpID0+IGdldEZpcnN0Tm9uZVRlcm1pbmFsKGN1cnJTdWJEZWYuZGVmaW5pdGlvbikpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RQcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgLy8gbm90aGluZyB0byBzZWUsIG1vdmUgYWxvbmdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxuICAgIGNvbnN0IGlzRmlyc3RPcHRpb25hbCA9IGlzT3B0aW9uYWxQcm9kKGZpcnN0UHJvZCk7XG4gICAgY29uc3QgaGFzTW9yZSA9IGRlZmluaXRpb24ubGVuZ3RoID4gMTtcbiAgICBpZiAoaXNGaXJzdE9wdGlvbmFsICYmIGhhc01vcmUpIHtcbiAgICAgICAgY29uc3QgcmVzdCA9IGRyb3AoZGVmaW5pdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGdldEZpcnN0Tm9uZVRlcm1pbmFsKHJlc3QpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuY2xhc3MgT3JDb2xsZWN0b3IgZXh0ZW5kcyBHQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpb25zID0gW107XG4gICAgfVxuICAgIHZpc2l0QWx0ZXJuYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLmFsdGVybmF0aW9ucy5wdXNoKG5vZGUpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUVtcHR5T3JBbHRlcm5hdGl2ZSh0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3Qgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICBjb25zdCBvcnMgPSBvckNvbGxlY3Rvci5hbHRlcm5hdGlvbnM7XG4gICAgY29uc3QgZXJyb3JzID0gZmxhdE1hcChvcnMsIChjdXJyT3IpID0+IHtcbiAgICAgICAgY29uc3QgZXhjZXB0TGFzdCA9IGRyb3BSaWdodChjdXJyT3IuZGVmaW5pdGlvbik7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKGV4Y2VwdExhc3QsIChjdXJyQWx0ZXJuYXRpdmUsIGN1cnJBbHRJZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlRmlyc3RJbkFsdCA9IG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyKFtjdXJyQWx0ZXJuYXRpdmVdLCBbXSwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciwgMSk7XG4gICAgICAgICAgICBpZiAoaXNFbXB0eShwb3NzaWJsZUZpcnN0SW5BbHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRFbXB0eUFsdGVybmF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wTGV2ZWxSdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBjdXJyT3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHlDaG9pY2VJZHg6IGN1cnJBbHRJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9ORV9MQVNUX0VNUFRZX0FMVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZTogY3VyckFsdElkeCArIDEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFtYmlndW91c0FsdGVybmF0aW9uQWx0ZXJuYXRpdmVzKHRvcExldmVsUnVsZSwgZ2xvYmFsTWF4TG9va2FoZWFkLCBlcnJNc2dQcm92aWRlcikge1xuICAgIGNvbnN0IG9yQ29sbGVjdG9yID0gbmV3IE9yQ29sbGVjdG9yKCk7XG4gICAgdG9wTGV2ZWxSdWxlLmFjY2VwdChvckNvbGxlY3Rvcik7XG4gICAgbGV0IG9ycyA9IG9yQ29sbGVjdG9yLmFsdGVybmF0aW9ucztcbiAgICAvLyBOZXcgSGFuZGxpbmcgb2YgaWdub3JpbmcgYW1iaWd1aXRpZXNcbiAgICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGV2cm90YWluL2NoZXZyb3RhaW4vaXNzdWVzLzg2OVxuICAgIG9ycyA9IHJlamVjdChvcnMsIChjdXJyT3IpID0+IGN1cnJPci5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSk7XG4gICAgY29uc3QgZXJyb3JzID0gZmxhdE1hcChvcnMsIChjdXJyT3IpID0+IHtcbiAgICAgICAgY29uc3QgY3Vyck9jY3VycmVuY2UgPSBjdXJyT3IuaWR4O1xuICAgICAgICBjb25zdCBhY3R1YWxNYXhMb29rYWhlYWQgPSBjdXJyT3IubWF4TG9va2FoZWFkIHx8IGdsb2JhbE1heExvb2thaGVhZDtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihjdXJyT2NjdXJyZW5jZSwgdG9wTGV2ZWxSdWxlLCBhY3R1YWxNYXhMb29rYWhlYWQsIGN1cnJPcik7XG4gICAgICAgIGNvbnN0IGFsdHNBbWJpZ3VpdHlFcnJvcnMgPSBjaGVja0FsdGVybmF0aXZlc0FtYmlndWl0aWVzKGFsdGVybmF0aXZlcywgY3Vyck9yLCB0b3BMZXZlbFJ1bGUsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgYWx0c1ByZWZpeEFtYmlndWl0eUVycm9ycyA9IGNoZWNrUHJlZml4QWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICByZXR1cm4gYWx0c0FtYmlndWl0eUVycm9ycy5jb25jYXQoYWx0c1ByZWZpeEFtYmlndWl0eUVycm9ycyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBjbGFzcyBSZXBldGl0aW9uQ29sbGVjdG9yIGV4dGVuZHMgR0FzdFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zID0gW107XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeShhdExlYXN0T25lKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lU2VwKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVRvb01hbnlBbHRzKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIGNvbnN0IG9ycyA9IG9yQ29sbGVjdG9yLmFsdGVybmF0aW9ucztcbiAgICBjb25zdCBlcnJvcnMgPSBmbGF0TWFwKG9ycywgKGN1cnJPcikgPT4ge1xuICAgICAgICBpZiAoY3Vyck9yLmRlZmluaXRpb24ubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnUHJvdmlkZXIuYnVpbGRUb29NYW55QWx0ZXJuYXRpdmVzRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BMZXZlbFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbjogY3Vyck9yLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5UT09fTUFOWV9BTFRTLFxuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogdG9wTGV2ZWxSdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IGN1cnJPci5pZHgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aCh0b3BMZXZlbFJ1bGVzLCBtYXhMb29rYWhlYWQsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgZm9yRWFjaCh0b3BMZXZlbFJ1bGVzLCAoY3VyclRvcFJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yVmlzaXRvciA9IG5ldyBSZXBldGl0aW9uQ29sbGVjdG9yKCk7XG4gICAgICAgIGN1cnJUb3BSdWxlLmFjY2VwdChjb2xsZWN0b3JWaXNpdG9yKTtcbiAgICAgICAgY29uc3QgYWxsUnVsZVByb2R1Y3Rpb25zID0gY29sbGVjdG9yVmlzaXRvci5hbGxQcm9kdWN0aW9ucztcbiAgICAgICAgZm9yRWFjaChhbGxSdWxlUHJvZHVjdGlvbnMsIChjdXJyUHJvZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvZFR5cGUgPSBnZXRQcm9kVHlwZShjdXJyUHJvZCk7XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxNYXhMb29rYWhlYWQgPSBjdXJyUHJvZC5tYXhMb29rYWhlYWQgfHwgbWF4TG9va2FoZWFkO1xuICAgICAgICAgICAgY29uc3QgY3Vyck9jY3VycmVuY2UgPSBjdXJyUHJvZC5pZHg7XG4gICAgICAgICAgICBjb25zdCBwYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKGN1cnJPY2N1cnJlbmNlLCBjdXJyVG9wUnVsZSwgcHJvZFR5cGUsIGFjdHVhbE1heExvb2thaGVhZCk7XG4gICAgICAgICAgICBjb25zdCBwYXRoc0luc2lkZVByb2R1Y3Rpb24gPSBwYXRoc1swXTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGZsYXR0ZW4ocGF0aHNJbnNpZGVQcm9kdWN0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZEVtcHR5UmVwZXRpdGlvbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBjdXJyVG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgcmVwZXRpdGlvbjogY3VyclByb2QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuTk9fTk9OX0VNUFRZX0xPT0tBSEVBRCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWU6IGN1cnJUb3BSdWxlLm5hbWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBjaGVja0FsdGVybmF0aXZlc0FtYmlndWl0aWVzKGFsdGVybmF0aXZlcywgYWx0ZXJuYXRpb24sIHJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgZm91bmRBbWJpZ3VvdXNQYXRocyA9IFtdO1xuICAgIGNvbnN0IGlkZW50aWNhbEFtYmlndWl0aWVzID0gcmVkdWNlKGFsdGVybmF0aXZlcywgKHJlc3VsdCwgY3VyckFsdCwgY3VyckFsdElkeCkgPT4ge1xuICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAoYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyQWx0SWR4XS5pZ25vcmVBbWJpZ3VpdGllcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIChjdXJyUGF0aCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWx0c0N1cnJQYXRoQXBwZWFyc0luID0gW2N1cnJBbHRJZHhdO1xuICAgICAgICAgICAgZm9yRWFjaChhbHRlcm5hdGl2ZXMsIChjdXJyT3RoZXJBbHQsIGN1cnJPdGhlckFsdElkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyQWx0SWR4ICE9PSBjdXJyT3RoZXJBbHRJZHggJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnNQYXRoKGN1cnJPdGhlckFsdCwgY3VyclBhdGgpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIFwib3RoZXJcIiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJPdGhlckFsdElkeF0uaWdub3JlQW1iaWd1aXRpZXMgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0c0N1cnJQYXRoQXBwZWFyc0luLnB1c2goY3Vyck90aGVyQWx0SWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhbHRzQ3VyclBhdGhBcHBlYXJzSW4ubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICFjb250YWluc1BhdGgoZm91bmRBbWJpZ3VvdXNQYXRocywgY3VyclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZm91bmRBbWJpZ3VvdXNQYXRocy5wdXNoKGN1cnJQYXRoKTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGFsdHM6IGFsdHNDdXJyUGF0aEFwcGVhcnNJbixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3VyclBhdGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjdXJyRXJyb3JzID0gbWFwKGlkZW50aWNhbEFtYmlndWl0aWVzLCAoY3VyckFtYkRlc2NyaXB0b3IpID0+IHtcbiAgICAgICAgY29uc3QgYW1iZ0luZGljZXMgPSBtYXAoY3VyckFtYkRlc2NyaXB0b3IuYWx0cywgKGN1cnJBbHRJZHgpID0+IGN1cnJBbHRJZHggKyAxKTtcbiAgICAgICAgY29uc3QgY3Vyck1lc3NhZ2UgPSBlcnJNc2dQcm92aWRlci5idWlsZEFsdGVybmF0aW9uQW1iaWd1aXR5RXJyb3Ioe1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgYW1iaWd1aXR5SW5kaWNlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICBwcmVmaXhQYXRoOiBjdXJyQW1iRGVzY3JpcHRvci5wYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGN1cnJNZXNzYWdlLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfQUxUUyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlLm5hbWUsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBhbHRlcm5hdGlvbi5pZHgsXG4gICAgICAgICAgICBhbHRlcm5hdGl2ZXM6IGN1cnJBbWJEZXNjcmlwdG9yLmFsdHMsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGFsdGVybmF0aW9uLCBydWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIC8vIGZsYXR0ZW5cbiAgICBjb25zdCBwYXRoc0FuZEluZGljZXMgPSByZWR1Y2UoYWx0ZXJuYXRpdmVzLCAocmVzdWx0LCBjdXJyQWx0LCBpZHgpID0+IHtcbiAgICAgICAgY29uc3QgY3VyclBhdGhzQW5kSWR4ID0gbWFwKGN1cnJBbHQsIChjdXJyUGF0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWR4OiBpZHgsIHBhdGg6IGN1cnJQYXRoIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChjdXJyUGF0aHNBbmRJZHgpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBlcnJvcnMgPSBjb21wYWN0KGZsYXRNYXAocGF0aHNBbmRJbmRpY2VzLCAoY3VyclBhdGhBbmRJZHgpID0+IHtcbiAgICAgICAgY29uc3QgYWx0ZXJuYXRpdmVHYXN0ID0gYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltjdXJyUGF0aEFuZElkeC5pZHhdO1xuICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICBpZiAoYWx0ZXJuYXRpdmVHYXN0Lmlnbm9yZUFtYmlndWl0aWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0SWR4ID0gY3VyclBhdGhBbmRJZHguaWR4O1xuICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gY3VyclBhdGhBbmRJZHgucGF0aDtcbiAgICAgICAgY29uc3QgcHJlZml4QW1iaWd1aXRpZXNQYXRoc0FuZEluZGljZXMgPSBmaWx0ZXIocGF0aHNBbmRJbmRpY2VzLCAoc2VhcmNoUGF0aEFuZElkeCkgPT4ge1xuICAgICAgICAgICAgLy8gcHJlZml4IGFtYmlndWl0eSBjYW4gb25seSBiZSBjcmVhdGVkIGZyb20gbG93ZXIgaWR4IChoaWdoZXIgcHJpb3JpdHkpIHBhdGhcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvLyBpZ25vcmUgKHNraXApIGFtYmlndWl0aWVzIHdpdGggdGhpcyBcIm90aGVyXCIgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIGFsdGVybmF0aW9uLmRlZmluaXRpb25bc2VhcmNoUGF0aEFuZElkeC5pZHhdLmlnbm9yZUFtYmlndWl0aWVzICE9PVxuICAgICAgICAgICAgICAgIHRydWUgJiZcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRoQW5kSWR4LmlkeCA8IHRhcmdldElkeCAmJlxuICAgICAgICAgICAgICAgIC8vIGNoZWNraW5nIGZvciBzdHJpY3QgcHJlZml4IGJlY2F1c2UgaWRlbnRpY2FsIGxvb2thaGVhZHNcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGJlIGJlIGRldGVjdGVkIHVzaW5nIGEgZGlmZmVyZW50IHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgaXNTdHJpY3RQcmVmaXhPZlBhdGgoc2VhcmNoUGF0aEFuZElkeC5wYXRoLCB0YXJnZXRQYXRoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjdXJyUGF0aFByZWZpeEVycm9ycyA9IG1hcChwcmVmaXhBbWJpZ3VpdGllc1BhdGhzQW5kSW5kaWNlcywgKGN1cnJBbWJQYXRoQW5kSWR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbWJnSW5kaWNlcyA9IFtjdXJyQW1iUGF0aEFuZElkeC5pZHggKyAxLCB0YXJnZXRJZHggKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IG9jY3VycmVuY2UgPSBhbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogYWx0ZXJuYXRpb24uaWR4O1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBydWxlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBhbHRlcm5hdGlvbixcbiAgICAgICAgICAgICAgICBhbWJpZ3VpdHlJbmRpY2VzOiBhbWJnSW5kaWNlcyxcbiAgICAgICAgICAgICAgICBwcmVmaXhQYXRoOiBjdXJyQW1iUGF0aEFuZElkeC5wYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5BTUJJR1VPVVNfUFJFRklYX0FMVFMsXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlOiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlczogYW1iZ0luZGljZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoUHJlZml4RXJyb3JzO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZnVuY3Rpb24gY2hlY2tUZXJtaW5hbEFuZE5vbmVUZXJtaW5hbHNOYW1lU3BhY2UodG9wTGV2ZWxzLCB0b2tlblR5cGVzLCBlcnJNc2dQcm92aWRlcikge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHRva2VuTmFtZXMgPSBtYXAodG9rZW5UeXBlcywgKGN1cnJUb2tlbikgPT4gY3VyclRva2VuLm5hbWUpO1xuICAgIGZvckVhY2godG9wTGV2ZWxzLCAoY3VyclJ1bGUpID0+IHtcbiAgICAgICAgY29uc3QgY3VyclJ1bGVOYW1lID0gY3VyclJ1bGUubmFtZTtcbiAgICAgICAgaWYgKGluY2x1ZGVzKHRva2VuTmFtZXMsIGN1cnJSdWxlTmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkTmFtZXNwYWNlQ29uZmxpY3RFcnJvcihjdXJyUnVsZSk7XG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogY3VyclJ1bGVOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2tzLmpzLm1hcCIsImltcG9ydCB7IGRlZmF1bHRzLCBmb3JFYWNoIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgcmVzb2x2ZUdyYW1tYXIgYXMgb3JnUmVzb2x2ZUdyYW1tYXIgfSBmcm9tIFwiLi4vcmVzb2x2ZXIuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlR3JhbW1hciBhcyBvcmdWYWxpZGF0ZUdyYW1tYXIgfSBmcm9tIFwiLi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlciwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLCB9IGZyb20gXCIuLi8uLi9lcnJvcnNfcHVibGljLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdHVhbE9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlcixcbiAgICB9KTtcbiAgICBjb25zdCB0b3BSdWxlc1RhYmxlID0ge307XG4gICAgZm9yRWFjaChvcHRpb25zLnJ1bGVzLCAocnVsZSkgPT4ge1xuICAgICAgICB0b3BSdWxlc1RhYmxlW3J1bGUubmFtZV0gPSBydWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBvcmdSZXNvbHZlR3JhbW1hcih0b3BSdWxlc1RhYmxlLCBhY3R1YWxPcHRpb25zLmVyck1zZ1Byb3ZpZGVyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdyYW1tYXIob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsXG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ1ZhbGlkYXRlR3JhbW1hcihvcHRpb25zLnJ1bGVzLCBvcHRpb25zLnRva2VuVHlwZXMsIG9wdGlvbnMuZXJyTXNnUHJvdmlkZXIsIG9wdGlvbnMuZ3JhbW1hck5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzdF9yZXNvbHZlcl9wdWJsaWMuanMubWFwIiwiaW1wb3J0IHsgaW5jbHVkZXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5jb25zdCBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTiA9IFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCI7XG5jb25zdCBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTiA9IFwiTm9WaWFibGVBbHRFeGNlcHRpb25cIjtcbmNvbnN0IEVBUkxZX0VYSVRfRVhDRVBUSU9OID0gXCJFYXJseUV4aXRFeGNlcHRpb25cIjtcbmNvbnN0IE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTiA9IFwiTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb25cIjtcbmNvbnN0IFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUyA9IFtcbiAgICBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTixcbiAgICBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTixcbiAgICBFQVJMWV9FWElUX0VYQ0VQVElPTixcbiAgICBOT1RfQUxMX0lOUFVUX1BBUlNFRF9FWENFUFRJT04sXG5dO1xuT2JqZWN0LmZyZWV6ZShSRUNPR05JVElPTl9FWENFUFRJT05fTkFNRVMpO1xuLy8gaGFja3MgdG8gYnlwYXNzIG5vIHN1cHBvcnQgZm9yIGN1c3RvbSBFcnJvcnMgaW4gamF2YXNjcmlwdC90eXBlc2NyaXB0XG5leHBvcnQgZnVuY3Rpb24gaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikge1xuICAgIC8vIGNhbid0IGRvIGluc3RhbmNlb2Ygb24gaGFja2VkIGN1c3RvbSBqcyBleGNlcHRpb25zXG4gICAgcmV0dXJuIGluY2x1ZGVzKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUywgZXJyb3IubmFtZSk7XG59XG5jbGFzcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLnJlc3luY2VkVG9rZW5zID0gW107XG4gICAgICAgIC8vIGZpeCBwcm90b3R5cGUgY2hhaW4gd2hlbiB0eXBlc2NyaXB0IHRhcmdldCBpcyBFUzVcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIG5ldy50YXJnZXQucHJvdG90eXBlKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBWOCB3b3JrYXJvdW5kIHRvIHJlbW92ZSBjb25zdHJ1Y3RvciBmcm9tIHN0YWNrdHJhY2Ugd2hlbiB0eXBlc2NyaXB0IHRhcmdldCBpcyBFUzUgKi9cbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgdG9rZW4pO1xuICAgICAgICB0aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSBNSVNNQVRDSEVEX1RPS0VOX0VYQ0VQVElPTjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm9WaWFibGVBbHRFeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgdG9rZW4sIHByZXZpb3VzVG9rZW4pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgdG9rZW4pO1xuICAgICAgICB0aGlzLnByZXZpb3VzVG9rZW4gPSBwcmV2aW91c1Rva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSBOT19WSUFCTEVfQUxUX0VYQ0VQVElPTjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24gZXh0ZW5kcyBSZWNvZ25pdGlvbkV4Y2VwdGlvbiB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgdG9rZW4pIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgdG9rZW4pO1xuICAgICAgICB0aGlzLm5hbWUgPSBOT1RfQUxMX0lOUFVUX1BBUlNFRF9FWENFUFRJT047XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEVhcmx5RXhpdEV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbiwgcHJldmlvdXNUb2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0b2tlbik7XG4gICAgICAgIHRoaXMucHJldmlvdXNUb2tlbiA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9IEVBUkxZX0VYSVRfRVhDRVBUSU9OO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2VwdGlvbnNfcHVibGljLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZVRva2VuSW5zdGFuY2UsIEVPRiwgdG9rZW5NYXRjaGVyLCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGNsb25lLCBkcm9wUmlnaHQsIGZpbmQsIGZsYXR0ZW4sIGhhcywgaW5jbHVkZXMsIGlzRW1wdHksIG1hcCwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IElOIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuZXhwb3J0IGNvbnN0IEVPRl9GT0xMT1dfS0VZID0ge307XG5leHBvcnQgY29uc3QgSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04gPSBcIkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uXCI7XG5leHBvcnQgY2xhc3MgSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT047XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZXJyb3IgcmVjb3ZlcnkgYW5kIGZhdWx0IHRvbGVyYW50IGxvZ2ljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvdmVyYWJsZSB7XG4gICAgaW5pdFJlY292ZXJhYmxlKGNvbmZpZykge1xuICAgICAgICB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZXN5bmNGb2xsb3dzID0ge307XG4gICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkID0gaGFzKGNvbmZpZywgXCJyZWNvdmVyeUVuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5RW5hYmxlZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgTk9PUCB3aWxsIGJlIGlubGluZWQgd2hpY2hcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgbWVhbnMgdGhhdCB0aGlzIG9wdGlvbmFsIGZlYXR1cmUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgLy8gd2hlbiBub3QgdXNlZC5cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUb2tlblRvSW5zZXJ0KHRva1R5cGUpIHtcbiAgICAgICAgY29uc3QgdG9rVG9JbnNlcnQgPSBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICAgICAgICB0b2tUb0luc2VydC5pc0luc2VydGVkSW5SZWNvdmVyeSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICB9XG4gICAgY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkodG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FuVG9rZW5UeXBlQmVEZWxldGVkSW5SZWNvdmVyeSh0b2tUeXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnlJblJlcGV0aXRpb25SZWNvdmVyeShncmFtbWFyUnVsZSwgZ3JhbW1hclJ1bGVBcmdzLCBsb29rQWhlYWRGdW5jLCBleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoZSByZXN5bmNUb2tlblR5cGUgYmUgY2FjaGVkP1xuICAgICAgICBjb25zdCByZVN5bmNUb2tUeXBlID0gdGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7XG4gICAgICAgIGNvbnN0IHNhdmVkTGV4ZXJTdGF0ZSA9IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICBjb25zdCByZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICBsZXQgcGFzc2VkUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuV2l0aG91dFJlc3luYyA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGxldCBjdXJyVG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZUVycm9yTWVzc2FnZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICAgICAgLy8gd2UgYXJlIHByZWVtcHRpdmVseSByZS1zeW5jaW5nIGJlZm9yZSBhbiBlcnJvciBoYXMgYmVlbiBkZXRlY3RlZCwgdGhlcmVmb3Igd2UgbXVzdCByZXByb2R1Y2VcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvciB0aGF0IHdvdWxkIGhhdmUgYmVlbiB0aHJvd25cbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkVG9rVHlwZSxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5leHRUb2tlbldpdGhvdXRSZXN5bmMsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obXNnLCBuZXh0VG9rZW5XaXRob3V0UmVzeW5jLCB0aGlzLkxBKDApKTtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0b2tlbiBoZXJlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIGNhdXNlIG9mIHRoZSBlcnJvciwgdGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcmVzeW5jZWRUb2tlbnMgcHJvcGVydHkuXG4gICAgICAgICAgICBlcnJvci5yZXN5bmNlZFRva2VucyA9IGRyb3BSaWdodChyZXN5bmNlZFRva2Vucyk7XG4gICAgICAgICAgICB0aGlzLlNBVkVfRVJST1IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoIXBhc3NlZFJlc3luY1BvaW50KSB7XG4gICAgICAgICAgICAvLyByZS1zeW5jZWQgdG8gYSBwb2ludCB3aGVyZSB3ZSBjYW4gc2FmZWx5IGV4aXQgdGhlIHJlcGV0aXRpb24vXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIoY3VyclRva2VuLCBleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG11c3QgcmV0dXJuIGhlcmUgdG8gYXZvaWQgcmV2ZXJ0aW5nIHRoZSBpbnB1dElkeFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2tpcHBlZCBlbm91Z2ggdG9rZW5zIHNvIHdlIGNhbiByZXN5bmMgcmlnaHQgYmFjayBpbnRvIGFub3RoZXIgaXRlcmF0aW9uIG9mIHRoZSByZXBldGl0aW9uIGdyYW1tYXIgcnVsZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGludm9jYXRpb24gaW4gb3RoZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSByZS1zeW5jcyBpbiB0aGUgc2FtZSB0b3AgbGV2ZWwgcmVwZXRpdGlvbiBncmFtbWFyIHJ1bGVcbiAgICAgICAgICAgICAgICBncmFtbWFyUnVsZS5hcHBseSh0aGlzLCBncmFtbWFyUnVsZUFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbXVzdCByZXR1cm4gaGVyZSB0byBhdm9pZCByZXZlcnRpbmcgdGhlIGlucHV0SWR4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRva2VuTWF0Y2hlcihjdXJyVG9rZW4sIHJlU3luY1Rva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkUmVzeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyclRva2VuID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhjdXJyVG9rZW4sIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgQ0xPU0VSIHBvaW50IHRvIHJlc3luYyBpbnNpZGUgdGhlIFJlcGV0aXRpb24sIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGhlIHBhcnNpbmcgZXhjZXB0aW9uIHdlIHdlcmUgdHJ5aW5nIHRvIHByZXZlbnQgd2lsbCBoYXBwZW4gaW4gdGhlIE5FWFQgcGFyc2luZyBzdGVwLiBpdCBtYXkgYmUgaGFuZGxlZCBieVxuICAgICAgICAvLyBcImJldHdlZW4gcnVsZXNcIiByZXN5bmMgcmVjb3ZlcnkgbGF0ZXIgaW4gdGhlIGZsb3cuXG4gICAgICAgIHRoaXMuaW1wb3J0TGV4ZXJTdGF0ZShzYXZlZExleGVyU3RhdGUpO1xuICAgIH1cbiAgICBzaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgsIG5vdFN0dWNrKSB7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSBvZiBhcnJpdmluZyBmcm9tIGEgTUFOWSByZXBldGl0aW9uIHdoaWNoIGlzIHN0dWNrXG4gICAgICAgIC8vIEF0dGVtcHRpbmcgcmVjb3ZlcnkgaW4gdGhpcyBjYXNlIGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgaWYgKG5vdFN0dWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcmVjb3ZlciwgbmV4dCB0b2tlbiBpcyB3aGF0IHdlIGV4cGVjdC4uLlxuICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnkgaXMgZGlzYWJsZWQgZHVyaW5nIGJhY2t0cmFja2luZyBhcyBpdCBjYW4gbWFrZSB0aGUgcGFyc2VyIGlnbm9yZSBhIHZhbGlkIGdyYW1tYXIgcGF0aFxuICAgICAgICAvLyBhbmQgcHJlZmVyIHNvbWUgYmFja3RyYWNraW5nIHBhdGggdGhhdCBpbmNsdWRlcyByZWNvdmVyZWQgZXJyb3JzLlxuICAgICAgICBpZiAodGhpcy5pc0JhY2tUcmFja2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuIHBlcmZvcm0gaW5SdWxlIHJlY292ZXJ5IChzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uKSB3ZSBhbHdheXMgcHJlZmVyIHRoYXQgcmVjb3ZlcnkgYWxnb3JpdGhtXG4gICAgICAgIC8vIGJlY2F1c2UgaWYgaXQgd29ya3MsIGl0IG1ha2VzIHRoZSBsZWFzdCBhbW91bnQgb2YgY2hhbmdlcyB0byB0aGUgaW5wdXQgc3RyZWFtIChncmVlZHkgYWxnb3JpdGhtKVxuICAgICAgICAvL25vaW5zcGVjdGlvbiBSZWR1bmRhbnRJZlN0YXRlbWVudEpTXG4gICAgICAgIGlmICh0aGlzLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeShleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBFcnJvciBSZWNvdmVyeSBmdW5jdGlvbmFsaXR5XG4gICAgZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHRva1R5cGUsIHRva0lkeEluUnVsZSkge1xuICAgICAgICBjb25zdCBncmFtbWFyUGF0aCA9IHRoaXMuZ2V0Q3VycmVudEdyYW1tYXJQYXRoKHRva1R5cGUsIHRva0lkeEluUnVsZSk7XG4gICAgICAgIGNvbnN0IGZvbGxvd3MgPSB0aGlzLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMoZ3JhbW1hclBhdGgpO1xuICAgICAgICByZXR1cm4gZm9sbG93cztcbiAgICB9XG4gICAgdHJ5SW5SdWxlUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rVG9JbnNlcnQgPSB0aGlzLmdldFRva2VuVG9JbnNlcnQoZXhwZWN0ZWRUb2tUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24oZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRvayA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VG9rO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbihcInNhZCBzYWQgcGFuZGFcIik7XG4gICAgfVxuICAgIGNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeShleHBlY3RlZFRva2VuLCBmb2xsb3dzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKGV4cGVjdGVkVG9rZW4sIGZvbGxvd3MpIHx8XG4gICAgICAgICAgICB0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva2VuKSk7XG4gICAgfVxuICAgIGNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeShleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbXVzdCBrbm93IHRoZSBwb3NzaWJsZSBmb2xsb3dpbmcgdG9rZW5zIHRvIHBlcmZvcm0gc2luZ2xlIHRva2VuIGluc2VydGlvblxuICAgICAgICBpZiAoaXNFbXB0eShmb2xsb3dzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc21hdGNoZWRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICBjb25zdCBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3MgPSBmaW5kKGZvbGxvd3MsIChwb3NzaWJsZUZvbGxvd3NUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIobWlzbWF0Y2hlZFRvaywgcG9zc2libGVGb2xsb3dzVG9rVHlwZSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3M7XG4gICAgfVxuICAgIGNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblRva2VuVHlwZUJlRGVsZXRlZEluUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTmV4dFRva2VuV2hhdElzRXhwZWN0ZWQgPSB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLCBleHBlY3RlZFRva1R5cGUpO1xuICAgICAgICByZXR1cm4gaXNOZXh0VG9rZW5XaGF0SXNFeHBlY3RlZDtcbiAgICB9XG4gICAgaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0KHRva2VuVHlwZUlkeCkge1xuICAgICAgICBjb25zdCBmb2xsb3dLZXkgPSB0aGlzLmdldEN1cnJGb2xsb3dLZXkoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFJ1bGVSZVN5bmNTZXQgPSB0aGlzLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoZm9sbG93S2V5KTtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVzKGN1cnJlbnRSdWxlUmVTeW5jU2V0LCB0b2tlblR5cGVJZHgpO1xuICAgIH1cbiAgICBmaW5kUmVTeW5jVG9rZW5UeXBlKCkge1xuICAgICAgICBjb25zdCBhbGxQb3NzaWJsZVJlU3luY1Rva1R5cGVzID0gdGhpcy5mbGF0dGVuRm9sbG93U2V0KCk7XG4gICAgICAgIC8vIHRoaXMgbG9vcCB3aWxsIGFsd2F5cyB0ZXJtaW5hdGUgYXMgRU9GIGlzIGFsd2F5cyBpbiB0aGUgZm9sbG93IHN0YWNrIGFuZCBhbHNvIGFsd2F5cyAodmlydHVhbGx5KSBpbiB0aGUgaW5wdXRcbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGxldCBrID0gMjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kTWF0Y2ggPSBmaW5kKGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMsIChyZXN5bmNUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuTWF0Y2ggPSB0b2tlbk1hdGNoZXIobmV4dFRva2VuLCByZXN5bmNUb2tUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuTWF0Y2g7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmb3VuZE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRUb2tlbiA9IHRoaXMuTEEoayk7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q3VyckZvbGxvd0tleSgpIHtcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBpcyBhdCBsZWFzdCBvbmUgYXMgd2UgYWx3YXlzIGFkZCB0aGUgcnVsZU5hbWUgdG8gdGhlIHN0YWNrIGJlZm9yZSBpbnZva2luZyB0aGUgcnVsZS5cbiAgICAgICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyUnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICBjb25zdCBjdXJyUnVsZUlkeCA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCgpO1xuICAgICAgICBjb25zdCBwcmV2UnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGN1cnJSdWxlU2hvcnROYW1lKSxcbiAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGN1cnJSdWxlSWR4LFxuICAgICAgICAgICAgaW5SdWxlOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHByZXZSdWxlU2hvcnROYW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSB7XG4gICAgICAgIGNvbnN0IGV4cGxpY2l0UnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICBjb25zdCBleHBsaWNpdE9jY3VycmVuY2VTdGFjayA9IHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO1xuICAgICAgICByZXR1cm4gbWFwKGV4cGxpY2l0UnVsZVN0YWNrLCAocnVsZU5hbWUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrW2lkeF0sXG4gICAgICAgICAgICAgICAgaW5SdWxlOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGV4cGxpY2l0UnVsZVN0YWNrW2lkeCAtIDFdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmbGF0dGVuRm9sbG93U2V0KCkge1xuICAgICAgICBjb25zdCBmb2xsb3dTdGFjayA9IG1hcCh0aGlzLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrKCksIChjdXJyS2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGN1cnJLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oZm9sbG93U3RhY2spO1xuICAgIH1cbiAgICBnZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGZvbGxvd0tleSkge1xuICAgICAgICBpZiAoZm9sbG93S2V5ID09PSBFT0ZfRk9MTE9XX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIFtFT0ZdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbGxvd05hbWUgPSBmb2xsb3dLZXkucnVsZU5hbWUgKyBmb2xsb3dLZXkuaWR4SW5DYWxsaW5nUnVsZSArIElOICsgZm9sbG93S2V5LmluUnVsZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzeW5jRm9sbG93c1tmb2xsb3dOYW1lXTtcbiAgICB9XG4gICAgLy8gSXQgZG9lcyBub3QgbWFrZSBhbnkgc2Vuc2UgdG8gaW5jbHVkZSBhIHZpcnR1YWwgRU9GIHRva2VuIGluIHRoZSBsaXN0IG9mIHJlc3luY2VkIHRva2Vuc1xuICAgIC8vIGFzIEVPRiBkb2VzIG5vdCByZWFsbHkgZXhpc3QgYW5kIHRodXMgZG9lcyBub3QgY29udGFpbiBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIChsaW5lL2NvbHVtbiBudW1iZXJzKVxuICAgIGFkZFRvUmVzeW5jVG9rZW5zKHRva2VuLCByZXN5bmNUb2tlbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuTWF0Y2hlcih0b2tlbiwgRU9GKSkge1xuICAgICAgICAgICAgcmVzeW5jVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN5bmNUb2tlbnM7XG4gICAgfVxuICAgIHJlU3luY1RvKHRva1R5cGUpIHtcbiAgICAgICAgY29uc3QgcmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIobmV4dFRvaywgdG9rVHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuZXh0VG9rID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKG5leHRUb2ssIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgbGFzdCB0b2tlbiBpcyBub3QgcGFydCBvZiB0aGUgZXJyb3IuXG4gICAgICAgIHJldHVybiBkcm9wUmlnaHQocmVzeW5jZWRUb2tlbnMpO1xuICAgIH1cbiAgICBhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UsIG5leHRUb2tzV2Fsa2VyLCBub3RTdHVjaykge1xuICAgICAgICAvLyBieSBkZWZhdWx0IHRoaXMgaXMgYSBOTy1PUFxuICAgICAgICAvLyBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIHdpdGggdGhlIGZ1bmN0aW9uKG5vdCBtZXRob2QpIGJlbG93XG4gICAgfVxuICAgIGdldEN1cnJlbnRHcmFtbWFyUGF0aCh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpIHtcbiAgICAgICAgY29uc3QgcGF0aFJ1bGVTdGFjayA9IHRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpO1xuICAgICAgICBjb25zdCBwYXRoT2NjdXJyZW5jZVN0YWNrID0gY2xvbmUodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spO1xuICAgICAgICBjb25zdCBncmFtbWFyUGF0aCA9IHtcbiAgICAgICAgICAgIHJ1bGVTdGFjazogcGF0aFJ1bGVTdGFjayxcbiAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogcGF0aE9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIGxhc3RUb2s6IHRva1R5cGUsXG4gICAgICAgICAgICBsYXN0VG9rT2NjdXJyZW5jZTogdG9rSWR4SW5SdWxlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhbW1hclBhdGg7XG4gICAgfVxuICAgIGdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSB7XG4gICAgICAgIHJldHVybiBtYXAodGhpcy5SVUxFX1NUQUNLLCAoY3VyclNob3J0TmFtZSkgPT4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShjdXJyU2hvcnROYW1lKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSwgbmV4dFRva3NXYWxrZXIsIG5vdFN0dWNrKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgbGV0IGZpcnN0QWZ0ZXJSZXBJbmZvID0gdGhpcy5maXJzdEFmdGVyUmVwTWFwW2tleV07XG4gICAgaWYgKGZpcnN0QWZ0ZXJSZXBJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY3VyclJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIGNvbnN0IHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtjdXJyUnVsZU5hbWVdO1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgbmV4dFRva3NXYWxrZXIocnVsZUdyYW1tYXIsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgZmlyc3RBZnRlclJlcEluZm8gPSB3YWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgICAgIHRoaXMuZmlyc3RBZnRlclJlcE1hcFtrZXldID0gZmlyc3RBZnRlclJlcEluZm87XG4gICAgfVxuICAgIGxldCBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IGZpcnN0QWZ0ZXJSZXBJbmZvLnRva2VuO1xuICAgIGxldCBuZXh0VG9rSWR4ID0gZmlyc3RBZnRlclJlcEluZm8ub2NjdXJyZW5jZTtcbiAgICBjb25zdCBpc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJSZXBJbmZvLmlzRW5kT2ZSdWxlO1xuICAgIC8vIHNwZWNpYWwgZWRnZSBjYXNlIG9mIGEgVE9QIG1vc3QgcmVwZXRpdGlvbiBhZnRlciB3aGljaCB0aGUgaW5wdXQgc2hvdWxkIEVORC5cbiAgICAvLyB0aGlzIHdpbGwgZm9yY2UgYW4gYXR0ZW1wdCBmb3IgaW5SdWxlIHJlY292ZXJ5IGluIHRoYXQgc2NlbmFyaW8uXG4gICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFbmRPZlJ1bGUgJiZcbiAgICAgICAgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IEVPRjtcbiAgICAgICAgbmV4dFRva0lkeCA9IDE7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gcmUtc3luYyB0by4uLlxuICAgIC8vIHRoaXMgY29uZGl0aW9uIHdhcyBleHRyYWN0ZWQgZnJvbSBgc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkYCB0byBhY3QgYXMgYSB0eXBlLWd1YXJkXG4gICAgaWYgKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID09PSB1bmRlZmluZWQgfHwgbmV4dFRva0lkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4LCBub3RTdHVjaykpIHtcbiAgICAgICAgLy8gVE9ETzogcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBpbnN0ZWFkIG9mIHBhc3NpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgaGVyZSwgd2UgbW9kaWZ5XG4gICAgICAgIC8vIHRoZSBhcmdzIHBhcmFtIChvciBjcmVhdGUgYSBuZXcgb25lKSBhbmQgbWFrZSBzdXJlIHRoZSBsb29rYWhlYWQgZnVuYyBpcyBleHBsaWNpdGx5IHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIGF2b2lkIHNlYXJjaGluZyB0aGUgY2FjaGUgZm9yIGl0IG9uY2UgbW9yZS5cbiAgICAgICAgdGhpcy50cnlJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY292ZXJhYmxlLmpzLm1hcCIsIi8vIExvb2thaGVhZCBrZXlzIGFyZSAzMkJpdCBpbnRlZ2VycyBpbiB0aGUgZm9ybVxuLy8gVFRUVFRUVFQtWlpaWlpaWlpaWlpaLVlZWVktWFhYWFhYWFhcbi8vIFhYWFggLT4gT2NjdXJyZW5jZSBJbmRleCBiaXRtYXAuXG4vLyBZWVlZIC0+IERTTCBNZXRob2QgVHlwZSBiaXRtYXAuXG4vLyBaWlpaWlpaWlpaWlpaWlogLT4gUnVsZSBzaG9ydCBJbmRleCBiaXRtYXAuXG4vLyBUVFRUVFRUVFQgLT4gYWx0ZXJuYXRpb24gYWx0ZXJuYXRpdmUgaW5kZXggYml0bWFwXG5leHBvcnQgY29uc3QgQklUU19GT1JfTUVUSE9EX1RZUEUgPSA0O1xuZXhwb3J0IGNvbnN0IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYID0gODtcbmV4cG9ydCBjb25zdCBCSVRTX0ZPUl9SVUxFX0lEWCA9IDEyO1xuLy8gVE9ETzogdmFsaWRhdGlvbiwgdGhpcyBtZWFucyB0aGF0IHRoZXJlIG1heSBhdCBtb3N0IDJeOCAtLT4gMjU2IGFsdGVybmF0aXZlcyBmb3IgYW4gYWx0ZXJuYXRpb24uXG5leHBvcnQgY29uc3QgQklUU19GT1JfQUxUX0lEWCA9IDg7XG4vLyBzaG9ydCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIG1hcHBpbmcga2V5cy5cbi8vIGJlaW5nIHNob3J0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSB3aGVuIGNvbXBvc2luZyBLRVlTIGZvciBtYXBzIG91dCBvZiB0aGVzZVxuLy8gVGhlIDUgLSA4IGJpdHMgKDE2IHBvc3NpYmxlIHZhbHVlcywgYXJlIHJlc2VydmVkIGZvciB0aGUgRFNMIG1ldGhvZCBpbmRpY2VzKVxuZXhwb3J0IGNvbnN0IE9SX0lEWCA9IDEgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgT1BUSU9OX0lEWCA9IDIgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgTUFOWV9JRFggPSAzIDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IGNvbnN0IEFUX0xFQVNUX09ORV9JRFggPSA0IDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IGNvbnN0IE1BTllfU0VQX0lEWCA9IDUgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgQVRfTEVBU1RfT05FX1NFUF9JRFggPSA2IDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuLy8gdGhpcyBhY3R1YWxseSByZXR1cm5zIGEgbnVtYmVyLCBidXQgaXQgaXMgYWx3YXlzIHVzZWQgYXMgYSBzdHJpbmcgKG9iamVjdCBwcm9wIGtleSlcbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQocnVsZUlkeCwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKSB7XG4gICAgcmV0dXJuIG9jY3VycmVuY2UgfCBkc2xNZXRob2RJZHggfCBydWxlSWR4O1xufVxuY29uc3QgQklUU19TVEFSVF9GT1JfQUxUX0lEWCA9IDMyIC0gQklUU19GT1JfQUxUX0lEWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIiwiaW1wb3J0IHsgZmxhdE1hcCwgaXNFbXB0eSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi9lcnJvcnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcywgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUsIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uLCB2YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgsIH0gZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgeyBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMsIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZCwgYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IsIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbiwgZ2V0UHJvZFR5cGUsIH0gZnJvbSBcIi4vbG9va2FoZWFkLmpzXCI7XG5leHBvcnQgY2xhc3MgTExrTG9va2FoZWFkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm1heExvb2thaGVhZCA9XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4TG9va2FoZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcubWF4TG9va2FoZWFkO1xuICAgIH1cbiAgICB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpb25FcnJvcnMgPSB0aGlzLnZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKG9wdGlvbnMucnVsZXMpO1xuICAgICAgICBpZiAoaXNFbXB0eShsZWZ0UmVjdXJzaW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlBbHRFcnJvcnMgPSB0aGlzLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlcyhvcHRpb25zLnJ1bGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGFtYmlndW91c0FsdHNFcnJvcnMgPSB0aGlzLnZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMob3B0aW9ucy5ydWxlcywgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgY29uc3QgZW1wdHlSZXBldGl0aW9uRXJyb3JzID0gdGhpcy52YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgob3B0aW9ucy5ydWxlcywgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgY29uc3QgYWxsRXJyb3JzID0gW1xuICAgICAgICAgICAgICAgIC4uLmxlZnRSZWN1cnNpb25FcnJvcnMsXG4gICAgICAgICAgICAgICAgLi4uZW1wdHlBbHRFcnJvcnMsXG4gICAgICAgICAgICAgICAgLi4uYW1iaWd1b3VzQWx0c0Vycm9ycyxcbiAgICAgICAgICAgICAgICAuLi5lbXB0eVJlcGV0aXRpb25FcnJvcnMsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGFsbEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdFJlY3Vyc2lvbkVycm9ycztcbiAgICB9XG4gICAgdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24ocnVsZXMpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAocnVsZXMsIChjdXJyVG9wUnVsZSkgPT4gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24oY3VyclRvcFJ1bGUsIGN1cnJUb3BSdWxlLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmVzKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKHJ1bGVzLCAoY3VyclRvcFJ1bGUpID0+IHZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKGN1cnJUb3BSdWxlLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyhydWxlcywgbWF4TG9va2FoZWFkKSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKHJ1bGVzLCAoY3VyclRvcFJ1bGUpID0+IHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoY3VyclRvcFJ1bGUsIG1heExvb2thaGVhZCwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyKSk7XG4gICAgfVxuICAgIHZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aChydWxlcywgbWF4TG9va2FoZWFkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgocnVsZXMsIG1heExvb2thaGVhZCwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyKTtcbiAgICB9XG4gICAgYnVpbGRMb29rYWhlYWRGb3JBbHRlcm5hdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBidWlsZExvb2thaGVhZEZ1bmNGb3JPcihvcHRpb25zLnByb2RPY2N1cnJlbmNlLCBvcHRpb25zLnJ1bGUsIG9wdGlvbnMubWF4TG9va2FoZWFkLCBvcHRpb25zLmhhc1ByZWRpY2F0ZXMsIG9wdGlvbnMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyk7XG4gICAgfVxuICAgIGJ1aWxkTG9va2FoZWFkRm9yT3B0aW9uYWwob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9wdGlvbnMucHJvZE9jY3VycmVuY2UsIG9wdGlvbnMucnVsZSwgb3B0aW9ucy5tYXhMb29rYWhlYWQsIG9wdGlvbnMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGdldFByb2RUeXBlKG9wdGlvbnMucHJvZFR5cGUpLCBidWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxsa19sb29rYWhlYWQuanMubWFwIiwiaW1wb3J0IHsgZm9yRWFjaCwgaGFzIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgQVRfTEVBU1RfT05FX0lEWCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCwgTUFOWV9JRFgsIE1BTllfU0VQX0lEWCwgT1BUSU9OX0lEWCwgT1JfSURYLCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2tleXMuanNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yLCBnZXRQcm9kdWN0aW9uRHNsTmFtZSwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuaW1wb3J0IHsgTExrTG9va2FoZWFkU3RyYXRlZ3kgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sbGtfbG9va2FoZWFkLmpzXCI7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGZvciB0aGUgbG9va2FoZWFkIHJlbGF0ZWQgdXRpbGl0aWVzIGFuZCBvcHRpbWl6YXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgTG9va3NBaGVhZCB7XG4gICAgaW5pdExvb2tzQWhlYWQoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1Rva2Vuc0VuYWJsZWQgPSBoYXMoY29uZmlnLCBcImR5bmFtaWNUb2tlbnNFbmFibGVkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5keW5hbWljVG9rZW5zRW5hYmxlZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5keW5hbWljVG9rZW5zRW5hYmxlZDtcbiAgICAgICAgdGhpcy5tYXhMb29rYWhlYWQgPSBoYXMoY29uZmlnLCBcIm1heExvb2thaGVhZFwiKVxuICAgICAgICAgICAgPyBjb25maWcubWF4TG9va2FoZWFkIC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLm1heExvb2thaGVhZDtcbiAgICAgICAgdGhpcy5sb29rYWhlYWRTdHJhdGVneSA9IGhhcyhjb25maWcsIFwibG9va2FoZWFkU3RyYXRlZ3lcIilcbiAgICAgICAgICAgID8gY29uZmlnLmxvb2thaGVhZFN0cmF0ZWd5IC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogbmV3IExMa0xvb2thaGVhZFN0cmF0ZWd5KHsgbWF4TG9va2FoZWFkOiB0aGlzLm1heExvb2thaGVhZCB9KTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWRGdW5jc0NhY2hlID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBwcmVDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zKHJ1bGVzKSB7XG4gICAgICAgIGZvckVhY2gocnVsZXMsIChjdXJyUnVsZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKGAke2N1cnJSdWxlLm5hbWV9IFJ1bGUgTG9va2FoZWFkYCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWx0ZXJuYXRpb24sIHJlcGV0aXRpb24sIG9wdGlvbiwgcmVwZXRpdGlvbk1hbmRhdG9yeSwgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCB9ID0gY29sbGVjdE1ldGhvZHMoY3VyclJ1bGUpO1xuICAgICAgICAgICAgICAgIGZvckVhY2goYWx0ZXJuYXRpb24sIChjdXJyUHJvZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9kSWR4ID0gY3VyclByb2QuaWR4ID09PSAwID8gXCJcIiA6IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKGAke2dldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKX0ke3Byb2RJZHh9YCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFGdW5jID0gdGhpcy5sb29rYWhlYWRTdHJhdGVneS5idWlsZExvb2thaGVhZEZvckFsdGVybmF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZTogY3VyclByb2QuaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IGN1cnJSdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heExvb2thaGVhZDogY3VyclByb2QubWF4TG9va2FoZWFkIHx8IHRoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1ByZWRpY2F0ZXM6IGN1cnJQcm9kLmhhc1ByZWRpY2F0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY1Rva2Vuc0VuYWJsZWQ6IHRoaXMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZCh0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnRbY3VyclJ1bGUubmFtZV0sIE9SX0lEWCwgY3VyclByb2QuaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUoa2V5LCBsYUZ1bmMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb24sIChjdXJyUHJvZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVMb29rYWhlYWRGdW5jKGN1cnJSdWxlLCBjdXJyUHJvZC5pZHgsIE1BTllfSURYLCBcIlJlcGV0aXRpb25cIiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvckVhY2gob3B0aW9uLCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBPUFRJT05fSURYLCBcIk9wdGlvblwiLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uTWFuZGF0b3J5LCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBBVF9MRUFTVF9PTkVfSURYLCBcIlJlcGV0aXRpb25NYW5kYXRvcnlcIiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvckVhY2gocmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIChjdXJyUHJvZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVMb29rYWhlYWRGdW5jKGN1cnJSdWxlLCBjdXJyUHJvZC5pZHgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX1NFUF9JRFgsIFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wdXRlTG9va2FoZWFkRnVuYyhydWxlLCBwcm9kT2NjdXJyZW5jZSwgcHJvZEtleSwgcHJvZFR5cGUsIHByb2RNYXhMb29rYWhlYWQsIGRzbE1ldGhvZE5hbWUpIHtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKGAke2RzbE1ldGhvZE5hbWV9JHtwcm9kT2NjdXJyZW5jZSA9PT0gMCA/IFwiXCIgOiBwcm9kT2NjdXJyZW5jZX1gLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsYUZ1bmMgPSB0aGlzLmxvb2thaGVhZFN0cmF0ZWd5LmJ1aWxkTG9va2FoZWFkRm9yT3B0aW9uYWwoe1xuICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICAgICAgbWF4TG9va2FoZWFkOiBwcm9kTWF4TG9va2FoZWFkIHx8IHRoaXMubWF4TG9va2FoZWFkLFxuICAgICAgICAgICAgICAgIGR5bmFtaWNUb2tlbnNFbmFibGVkOiB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLFxuICAgICAgICAgICAgICAgIHByb2RUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQodGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W3J1bGUubmFtZV0sIHByb2RLZXksIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgICAgIHRoaXMuc2V0TGFGdW5jQ2FjaGUoa2V5LCBsYUZ1bmMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gdGhpcyBhY3R1YWxseSByZXR1cm5zIGEgbnVtYmVyLCBidXQgaXQgaXMgYWx3YXlzIHVzZWQgYXMgYSBzdHJpbmcgKG9iamVjdCBwcm9wIGtleSlcbiAgICBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJSdWxlU2hvcnROYW1lID0gdGhpcy5nZXRMYXN0RXhwbGljaXRSdWxlU2hvcnROYW1lKCk7XG4gICAgICAgIHJldHVybiBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoY3VyclJ1bGVTaG9ydE5hbWUsIGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSk7XG4gICAgfVxuICAgIGdldExhRnVuY0Zyb21DYWNoZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBzZXRMYUZ1bmNDYWNoZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuY2xhc3MgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IgZXh0ZW5kcyBHQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogW10sXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnk6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzID0ge1xuICAgICAgICAgICAgb3B0aW9uOiBbXSxcbiAgICAgICAgICAgIGFsdGVybmF0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbldpdGhTZXBhcmF0b3I6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeTogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZpc2l0T3B0aW9uKG9wdGlvbikge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMub3B0aW9uLnB1c2gob3B0aW9uKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihtYW55U2VwKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uV2l0aFNlcGFyYXRvci5wdXNoKG1hbnlTZXApO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkoYXRMZWFzdE9uZSkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbk1hbmRhdG9yeS5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLnB1c2goYXRMZWFzdE9uZVNlcCk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbihtYW55KSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uLnB1c2gobWFueSk7XG4gICAgfVxuICAgIHZpc2l0QWx0ZXJuYXRpb24ob3IpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLmFsdGVybmF0aW9uLnB1c2gob3IpO1xuICAgIH1cbn1cbmNvbnN0IGNvbGxlY3RvclZpc2l0b3IgPSBuZXcgRHNsTWV0aG9kc0NvbGxlY3RvclZpc2l0b3IoKTtcbmV4cG9ydCBmdW5jdGlvbiBjb2xsZWN0TWV0aG9kcyhydWxlKSB7XG4gICAgY29sbGVjdG9yVmlzaXRvci5yZXNldCgpO1xuICAgIHJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgIGNvbnN0IGRzbE1ldGhvZHMgPSBjb2xsZWN0b3JWaXNpdG9yLmRzbE1ldGhvZHM7XG4gICAgLy8gYXZvaWQgdW5jbGVhbmVkIHJlZmVyZW5jZXNcbiAgICBjb2xsZWN0b3JWaXNpdG9yLnJlc2V0KCk7XG4gICAgcmV0dXJuIGRzbE1ldGhvZHM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb29rc2FoZWFkLmpzLm1hcCIsIi8qKlxuICogVGhpcyBub2RlTG9jYXRpb24gdHJhY2tpbmcgaXMgbm90IGVmZmljaWVudCBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZFxuICogd2hlbiBlcnJvciByZWNvdmVyeSBpcyBlbmFibGVkIG9yIHRoZSBUb2tlbiBWZWN0b3IgY29udGFpbnMgdmlydHVhbCBUb2tlbnNcbiAqIChlLmcsIFB5dGhvbiBJbmRlbnQvT3V0ZGVudClcbiAqIEFzIGl0IGV4ZWN1dGVzIHRoZSBjYWxjdWxhdGlvbiBmb3IgZXZlcnkgc2luZ2xlIHRlcm1pbmFsL25vblRlcm1pbmFsXG4gKiBhbmQgZG9lcyBub3QgcmVseSBvbiB0aGUgZmFjdCB0aGUgdG9rZW4gdmVjdG9yIGlzICoqc29ydGVkKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldE5vZGVMb2NhdGlvbk9ubHlPZmZzZXQoY3Vyck5vZGVMb2NhdGlvbiwgbmV3TG9jYXRpb25JbmZvKSB7XG4gICAgLy8gRmlyc3QgKHZhbGlkKSB1cGRhdGUgZm9yIHRoaXMgY3N0IG5vZGVcbiAgICBpZiAoaXNOYU4oY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCkgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXNzdW1wdGlvbjE6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGVpdGhlciBOYU4gb3IgYSB2YWxpZCBudW1iZXJcbiAgICAgICAgLy8gYXNzdW1wdGlvbjI6IFRva2VuIGxvY2F0aW9uIGluZm9ybWF0aW9uIGlzIGZ1bGx5IHZhbGlkIGlmIGl0IGV4aXN0XG4gICAgICAgIC8vIChib3RoIHN0YXJ0L2VuZCBvZmZzZXRzIGV4aXN0IGFuZCBhcmUgbnVtYmVycykuXG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICB9XG4gICAgLy8gT25jZSB0aGUgc3RhcnRPZmZzZXQgaGFzIGJlZW4gdXBkYXRlZCB3aXRoIGEgdmFsaWQgbnVtYmVyIGl0IHNob3VsZCBuZXZlciByZWNlaXZlXG4gICAgLy8gYW55IGZhcnRoZXIgdXBkYXRlcyBhcyB0aGUgVG9rZW4gdmVjdG9yIGlzIHNvcnRlZC5cbiAgICAvLyBXZSBzdGlsbCBoYXZlIHRvIGNoZWNrIHRoaXMgdGhpcyBjb25kaXRpb24gZm9yIGV2ZXJ5IG5ldyBwb3NzaWJsZSBsb2NhdGlvbiBpbmZvXG4gICAgLy8gYmVjYXVzZSB3aXRoIGVycm9yIHJlY292ZXJ5IGVuYWJsZWQgd2UgbWF5IGVuY291bnRlciBpbnZhbGlkIHRva2VucyAoTmFOIGxvY2F0aW9uIHByb3BzKVxuICAgIGVsc2UgaWYgKGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0IDwgbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIG5vZGVMb2NhdGlvbiB0cmFja2luZyBpcyBub3QgZWZmaWNpZW50IGFuZCBzaG91bGQgb25seSBiZSB1c2VkXG4gKiB3aGVuIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQgb3IgdGhlIFRva2VuIFZlY3RvciBjb250YWlucyB2aXJ0dWFsIFRva2Vuc1xuICogKGUuZywgUHl0aG9uIEluZGVudC9PdXRkZW50KVxuICogQXMgaXQgZXhlY3V0ZXMgdGhlIGNhbGN1bGF0aW9uIGZvciBldmVyeSBzaW5nbGUgdGVybWluYWwvbm9uVGVybWluYWxcbiAqIGFuZCBkb2VzIG5vdCByZWx5IG9uIHRoZSBmYWN0IHRoZSB0b2tlbiB2ZWN0b3IgaXMgKipzb3J0ZWQqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Tm9kZUxvY2F0aW9uRnVsbChjdXJyTm9kZUxvY2F0aW9uLCBuZXdMb2NhdGlvbkluZm8pIHtcbiAgICAvLyBGaXJzdCAodmFsaWQpIHVwZGF0ZSBmb3IgdGhpcyBjc3Qgbm9kZVxuICAgIGlmIChpc05hTihjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhc3N1bXB0aW9uMTogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZWl0aGVyIE5hTiBvciBhIHZhbGlkIG51bWJlclxuICAgICAgICAvLyBhc3N1bXB0aW9uMjogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZnVsbHkgdmFsaWQgaWYgaXQgZXhpc3RcbiAgICAgICAgLy8gKGFsbCBzdGFydC9lbmQgcHJvcHMgZXhpc3QgYW5kIGFyZSBudW1iZXJzKS5cbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydENvbHVtbiA9IG5ld0xvY2F0aW9uSW5mby5zdGFydENvbHVtbjtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydExpbmUgPSBuZXdMb2NhdGlvbkluZm8uc3RhcnRMaW5lO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kQ29sdW1uID0gbmV3TG9jYXRpb25JbmZvLmVuZENvbHVtbjtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRMaW5lID0gbmV3TG9jYXRpb25JbmZvLmVuZExpbmU7XG4gICAgfVxuICAgIC8vIE9uY2UgdGhlIHN0YXJ0IHByb3BzIGhhcyBiZWVuIHVwZGF0ZWQgd2l0aCBhIHZhbGlkIG51bWJlciBpdCBzaG91bGQgbmV2ZXIgcmVjZWl2ZVxuICAgIC8vIGFueSBmYXJ0aGVyIHVwZGF0ZXMgYXMgdGhlIFRva2VuIHZlY3RvciBpcyBzb3J0ZWQuXG4gICAgLy8gV2Ugc3RpbGwgaGF2ZSB0byBjaGVjayB0aGlzIHRoaXMgY29uZGl0aW9uIGZvciBldmVyeSBuZXcgcG9zc2libGUgbG9jYXRpb24gaW5mb1xuICAgIC8vIGJlY2F1c2Ugd2l0aCBlcnJvciByZWNvdmVyeSBlbmFibGVkIHdlIG1heSBlbmNvdW50ZXIgaW52YWxpZCB0b2tlbnMgKE5hTiBsb2NhdGlvbiBwcm9wcylcbiAgICBlbHNlIGlmIChjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA8IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZENvbHVtbiA9IG5ld0xvY2F0aW9uSW5mby5lbmRDb2x1bW47XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kTGluZSA9IG5ld0xvY2F0aW9uSW5mby5lbmRMaW5lO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRUZXJtaW5hbFRvQ3N0KG5vZGUsIHRva2VuLCB0b2tlblR5cGVOYW1lKSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW5bdG9rZW5UeXBlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3Rva2VuVHlwZU5hbWVdID0gW3Rva2VuXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bdG9rZW5UeXBlTmFtZV0ucHVzaCh0b2tlbik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZE5vbmVUZXJtaW5hbFRvQ3N0KG5vZGUsIHJ1bGVOYW1lLCBydWxlUmVzdWx0KSB7XG4gICAgaWYgKG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbltydWxlTmFtZV0gPSBbcnVsZVJlc3VsdF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3J1bGVOYW1lXS5wdXNoKHJ1bGVSZXN1bHQpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdC5qcy5tYXAiLCJjb25zdCBOQU1FID0gXCJuYW1lXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lTmFtZVByb3Aob2JqLCBuYW1lVmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBOQU1FLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG5hbWVWYWx1ZSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdfZXh0ZW5zaW9ucy5qcy5tYXAiLCJpbXBvcnQgeyBjb21wYWN0LCBmaWx0ZXIsIGZvckVhY2gsIGlzQXJyYXksIGlzRW1wdHksIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBrZXlzLCBtYXAsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgZGVmaW5lTmFtZVByb3AgfSBmcm9tIFwiLi4vLi4vbGFuZy9sYW5nX2V4dGVuc2lvbnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0VmlzaXQoY3R4LCBwYXJhbSkge1xuICAgIGNvbnN0IGNoaWxkcmVuTmFtZXMgPSBrZXlzKGN0eCk7XG4gICAgY29uc3QgY2hpbGRyZW5OYW1lc0xlbmd0aCA9IGNoaWxkcmVuTmFtZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5OYW1lc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJDaGlsZE5hbWUgPSBjaGlsZHJlbk5hbWVzW2ldO1xuICAgICAgICBjb25zdCBjdXJyQ2hpbGRBcnJheSA9IGN0eFtjdXJyQ2hpbGROYW1lXTtcbiAgICAgICAgY29uc3QgY3VyckNoaWxkQXJyYXlMZW5ndGggPSBjdXJyQ2hpbGRBcnJheS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyckNoaWxkQXJyYXlMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY3VyckNoaWxkID0gY3VyckNoaWxkQXJyYXlbal07XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIFRva2VucyBDaGlsZHJlbiBhbmQgQ3N0Tm9kZSBjaGlsZHJlblxuICAgICAgICAgICAgaWYgKGN1cnJDaGlsZC50b2tlblR5cGVJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXNbY3VyckNoaWxkLm5hbWVdKGN1cnJDaGlsZC5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRlZmF1bHRWaXNpdCBkb2VzIG5vdCBzdXBwb3J0IGdlbmVyaWMgb3V0IHBhcmFtXG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yKGdyYW1tYXJOYW1lLCBydWxlTmFtZXMpIHtcbiAgICBjb25zdCBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICBkZWZpbmVOYW1lUHJvcChkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzXCIpO1xuICAgIGNvbnN0IHNlbWFudGljUHJvdG8gPSB7XG4gICAgICAgIHZpc2l0OiBmdW5jdGlvbiAoY3N0Tm9kZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIC8vIGVuYWJsZXMgd3JpdGluZyBtb3JlIGNvbmNpc2UgdmlzaXRvciBtZXRob2RzIHdoZW4gQ3N0Tm9kZSBoYXMgb25seSBhIHNpbmdsZSBjaGlsZFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkoY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBIENTVCBOb2RlJ3MgY2hpbGRyZW4gZGljdGlvbmFyeSBjYW4gbmV2ZXIgaGF2ZSBlbXB0eSBhcnJheXMgYXMgdmFsdWVzXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBrZXkgaXMgZGVmaW5lZCB0aGVyZSB3aWxsIGJlIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGFycmF5LlxuICAgICAgICAgICAgICAgIGNzdE5vZGUgPSBjc3ROb2RlWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZW5hYmxlcyBwYXNzaW5nIG9wdGlvbmFsIENzdE5vZGVzIGNvbmNpc2VseS5cbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjc3ROb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tjc3ROb2RlLm5hbWVdKGNzdE5vZGUuY2hpbGRyZW4sIHBhcmFtKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdGVWaXNpdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMgPSB2YWxpZGF0ZVZpc2l0b3IodGhpcywgcnVsZU5hbWVzKTtcbiAgICAgICAgICAgIGlmICghaXNFbXB0eShzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlcyA9IG1hcChzZW1hbnRpY0RlZmluaXRpb25FcnJvcnMsIChjdXJyRGVmRXJyb3IpID0+IGN1cnJEZWZFcnJvci5tc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvcnMgRGV0ZWN0ZWQgaW4gQ1NUIFZpc2l0b3IgPCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfT46XFxuXFx0YCArXG4gICAgICAgICAgICAgICAgICAgIGAke2Vycm9yTWVzc2FnZXMuam9pbihcIlxcblxcblwiKS5yZXBsYWNlKC9cXG4vZywgXCJcXG5cXHRcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gc2VtYW50aWNQcm90bztcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZGVyaXZlZENvbnN0cnVjdG9yO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5fUlVMRV9OQU1FUyA9IHJ1bGVOYW1lcztcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcywgYmFzZUNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgZGVyaXZlZENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIC8vIGNhbiBiZSBvdmVyd3JpdHRlbiBhY2NvcmRpbmcgdG86XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vXG4gICAgLy8gbmFtZT9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRlJlZmVyZW5jZSUyRkdsb2JhbF9PYmplY3RzJTJGRnVuY3Rpb24lMkZuYW1lXG4gICAgZGVmaW5lTmFtZVByb3AoZGVyaXZlZENvbnN0cnVjdG9yLCBncmFtbWFyTmFtZSArIFwiQmFzZVNlbWFudGljc1dpdGhEZWZhdWx0c1wiKTtcbiAgICBjb25zdCB3aXRoRGVmYXVsdHNQcm90byA9IE9iamVjdC5jcmVhdGUoYmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgZm9yRWFjaChydWxlTmFtZXMsIChydWxlTmFtZSkgPT4ge1xuICAgICAgICB3aXRoRGVmYXVsdHNQcm90b1tydWxlTmFtZV0gPSBkZWZhdWx0VmlzaXQ7XG4gICAgfSk7XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IHdpdGhEZWZhdWx0c1Byb3RvO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkZXJpdmVkQ29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGRlcml2ZWRDb25zdHJ1Y3Rvcjtcbn1cbmV4cG9ydCB2YXIgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcjtcbihmdW5jdGlvbiAoQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcikge1xuICAgIENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3JbQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltcIlJFRFVOREFOVF9NRVRIT0RcIl0gPSAwXSA9IFwiUkVEVU5EQU5UX01FVEhPRFwiO1xuICAgIENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3JbQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltcIk1JU1NJTkdfTUVUSE9EXCJdID0gMV0gPSBcIk1JU1NJTkdfTUVUSE9EXCI7XG59KShDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yIHx8IChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVZpc2l0b3IodmlzaXRvckluc3RhbmNlLCBydWxlTmFtZXMpIHtcbiAgICBjb25zdCBtaXNzaW5nRXJyb3JzID0gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcyk7XG4gICAgcmV0dXJuIG1pc3NpbmdFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVNaXNzaW5nQ3N0TWV0aG9kcyh2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG1pc3NpbmdSdWxlTmFtZXMgPSBmaWx0ZXIocnVsZU5hbWVzLCAoY3VyclJ1bGVOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHZpc2l0b3JJbnN0YW5jZVtjdXJyUnVsZU5hbWVdKSA9PT0gZmFsc2U7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JzID0gbWFwKG1pc3NpbmdSdWxlTmFtZXMsIChjdXJyUnVsZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1zZzogYE1pc3NpbmcgdmlzaXRvciBtZXRob2Q6IDwke2N1cnJSdWxlTmFtZX0+IG9uICR7KHZpc2l0b3JJbnN0YW5jZS5jb25zdHJ1Y3Rvci5uYW1lKX0gQ1NUIFZpc2l0b3IuYCxcbiAgICAgICAgICAgIHR5cGU6IENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IuTUlTU0lOR19NRVRIT0QsXG4gICAgICAgICAgICBtZXRob2ROYW1lOiBjdXJyUnVsZU5hbWUsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBhY3QoZXJyb3JzKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdF92aXNpdG9yLmpzLm1hcCIsImltcG9ydCB7IGFkZE5vbmVUZXJtaW5hbFRvQ3N0LCBhZGRUZXJtaW5hbFRvQ3N0LCBzZXROb2RlTG9jYXRpb25GdWxsLCBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0LCB9IGZyb20gXCIuLi8uLi9jc3QvY3N0LmpzXCI7XG5pbXBvcnQgeyBoYXMsIGlzVW5kZWZpbmVkLCBrZXlzLCBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yLCBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzLCB9IGZyb20gXCIuLi8uLi9jc3QvY3N0X3Zpc2l0b3IuanNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIENTVCBidWlsZGluZyBsb2dpYy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyZWVCdWlsZGVyIHtcbiAgICBpbml0VHJlZUJ1aWxkZXIoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLID0gW107XG4gICAgICAgIC8vIG91dHB1dENzdCBpcyBubyBsb25nZXIgZXhwb3NlZC9kZWZpbmVkIGluIHRoZSBwdWJpYyBBUElcbiAgICAgICAgdGhpcy5vdXRwdXRDc3QgPSBjb25maWcub3V0cHV0Q3N0O1xuICAgICAgICB0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nID0gaGFzKGNvbmZpZywgXCJub2RlTG9jYXRpb25UcmFja2luZ1wiKVxuICAgICAgICAgICAgPyBjb25maWcubm9kZUxvY2F0aW9uVHJhY2tpbmcgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcubm9kZUxvY2F0aW9uVHJhY2tpbmc7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFRlcm1pbmFsID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKC9mdWxsL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IHNldE5vZGVMb2NhdGlvbkZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBzZXROb2RlTG9jYXRpb25GdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IHRoaXMuY3N0UG9zdFJ1bGVGdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvb25seU9mZnNldC9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gdGhpcy5jc3RQb3N0UnVsZU9ubHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvbm9uZS9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIDxub2RlTG9jYXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXCIke2NvbmZpZy5ub2RlTG9jYXRpb25UcmFja2luZ31cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3ZlcnkoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBlcnJvciByZWNvdmVyeSB0aGUgc3RhcnRpbmcgTG9jYXRpb24gb2YgYSBuZXcgQ3N0Tm9kZSBpcyBndWFyYW50ZWVkXG4gICAgICAgICAgICAvLyBUbyBiZSB0aGUgbmV4dCBUb2tlbidzIHN0YXJ0T2Zmc2V0IChmb3IgdmFsaWQgaW5wdXRzKS5cbiAgICAgICAgICAgIC8vIEZvciBpbnZhbGlkIGlucHV0cyB0aGVyZSB3b24ndCBiZSBhbnkgQ1NUT3V0cHV0IHNvIHRoaXMgcG90ZW50aWFsXG4gICAgICAgICAgICAvLyBpbmFjY3VyYWN5IGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRoaXMuTEEoMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWNvdmVyeShjc3ROb2RlKSB7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogTmFOLFxuICAgICAgICAgICAgc3RhcnRMaW5lOiBOYU4sXG4gICAgICAgICAgICBzdGFydENvbHVtbjogTmFOLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBlbmRMaW5lOiBOYU4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgKiAgQHNlZSBzZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIgZm9yIGV4cGxhbmF0aW9uIHdoeSB0aGlzIHdvcmtcbiAgXG4gICAgICAgKiBAcGFyYW0gY3N0Tm9kZVxuICAgICAgICovXG4gICAgc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyKGNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBuZXh0VG9rZW4uc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmU6IG5leHRUb2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICBzdGFydENvbHVtbjogbmV4dFRva2VuLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBlbmRMaW5lOiBOYU4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlKGZ1bGxSdWxlTmFtZSkge1xuICAgICAgICBjb25zdCBjc3ROb2RlID0ge1xuICAgICAgICAgICAgbmFtZTogZnVsbFJ1bGVOYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbihjc3ROb2RlKTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucHVzaChjc3ROb2RlKTtcbiAgICB9XG4gICAgY3N0RmluYWxseVN0YXRlVXBkYXRlKCkge1xuICAgICAgICB0aGlzLkNTVF9TVEFDSy5wb3AoKTtcbiAgICB9XG4gICAgY3N0UG9zdFJ1bGVGdWxsKHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIC8vIGNhc3RzIHRvIGByZXF1aXJlZDxDc3ROb2RlTG9jYXRpb24+YCBhcmUgc2FmZSBiZWNhdXNlIGBjc3RQb3N0UnVsZUZ1bGxgIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBmdWxsIGxvY2F0aW9uIGlzIGVuYWJsZWRcbiAgICAgICAgY29uc3QgcHJldlRva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgY29uc3QgbG9jID0gcnVsZUNzdE5vZGUubG9jYXRpb247XG4gICAgICAgIC8vIElmIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgaXQgbWVhbnMgd2UgY29uc3VtZWQgYXQgbGVhc3Qgb25lIFRva2VuXG4gICAgICAgIC8vIEluIHRoaXMgQ3N0Tm9kZS5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICAgICAgbG9jLmVuZExpbmUgPSBwcmV2VG9rZW4uZW5kTGluZTtcbiAgICAgICAgICAgIGxvYy5lbmRDb2x1bW4gPSBwcmV2VG9rZW4uZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgICAgIGxvYy5zdGFydExpbmUgPSBOYU47XG4gICAgICAgICAgICBsb2Muc3RhcnRDb2x1bW4gPSBOYU47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0KHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIC8vIGBsb2NhdGlvbicgaXMgbm90IG51bGwgYmVjYXVzZSBgY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0YCB3aWxsIG9ubHkgYmUgaW52b2tlZCB3aGVuIGxvY2F0aW9uIHRyYWNraW5nIGlzIGVuYWJsZWQuXG4gICAgICAgIGNvbnN0IGxvYyA9IHJ1bGVDc3ROb2RlLmxvY2F0aW9uO1xuICAgICAgICAvLyBJZiB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlIGl0IG1lYW5zIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBUb2tlblxuICAgICAgICAvLyBJbiB0aGlzIENzdE5vZGUuXG4gICAgICAgIGlmIChsb2Muc3RhcnRPZmZzZXQgPD0gcHJldlRva2VuLnN0YXJ0T2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2MuZW5kT2Zmc2V0ID0gcHJldlRva2VuLmVuZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBcImVtcHR5XCIgQ3N0Tm9kZSBlZGdlIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2Muc3RhcnRPZmZzZXQgPSBOYU47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3N0UG9zdFRlcm1pbmFsKGtleSwgY29uc3VtZWRUb2tlbikge1xuICAgICAgICBjb25zdCByb290Q3N0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZFRlcm1pbmFsVG9Dc3Qocm9vdENzdCwgY29uc3VtZWRUb2tlbiwga2V5KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4ocm9vdENzdC5sb2NhdGlvbiwgY29uc3VtZWRUb2tlbik7XG4gICAgfVxuICAgIGNzdFBvc3ROb25UZXJtaW5hbChydWxlQ3N0UmVzdWx0LCBydWxlTmFtZSkge1xuICAgICAgICBjb25zdCBwcmVDc3ROb2RlID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZE5vbmVUZXJtaW5hbFRvQ3N0KHByZUNzdE5vZGUsIHJ1bGVOYW1lLCBydWxlQ3N0UmVzdWx0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZShwcmVDc3ROb2RlLmxvY2F0aW9uLCBydWxlQ3N0UmVzdWx0LmxvY2F0aW9uKTtcbiAgICB9XG4gICAgZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IodGhpcy5jbGFzc05hbWUsIGtleXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgICAgICAgICAgdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXdCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMoKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25zdHJ1Y3RvciA9IGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHModGhpcy5jbGFzc05hbWUsIGtleXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksIHRoaXMuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3RvciA9IG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIHJ1bGVTdGFja1tydWxlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lKCkge1xuICAgICAgICBjb25zdCBydWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHJldHVybiBydWxlU3RhY2tbcnVsZVN0YWNrLmxlbmd0aCAtIDJdO1xuICAgIH1cbiAgICBnZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4KCkge1xuICAgICAgICBjb25zdCBvY2N1cnJlbmNlU3RhY2sgPSB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIG9jY3VycmVuY2VTdGFja1tvY2N1cnJlbmNlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJlZV9idWlsZGVyLmpzLm1hcCIsImltcG9ydCB7IEVORF9PRl9GSUxFIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuLyoqXG4gKiBUcmFpdCByZXNwb25zaWJsZSBhYnN0cmFjdGluZyBvdmVyIHRoZSBpbnRlcmFjdGlvbiB3aXRoIExleGVyIG91dHB1dCAoVG9rZW4gdmVjdG9yKS5cbiAqXG4gKiBUaGlzIGNvdWxkIGJlIGdlbmVyYWxpemVkIHRvIHN1cHBvcnQgb3RoZXIga2luZHMgb2YgbGV4ZXJzLCBlLmcuXG4gKiAtIEp1c3QgaW4gVGltZSBMZXhpbmcgLyBMZXhlci1MZXNzIHBhcnNpbmcuXG4gKiAtIFN0cmVhbWluZyBMZXhlci5cbiAqL1xuZXhwb3J0IGNsYXNzIExleGVyQWRhcHRlciB7XG4gICAgaW5pdExleGVyQWRhcHRlcigpIHtcbiAgICAgICAgdGhpcy50b2tWZWN0b3IgPSBbXTtcbiAgICAgICAgdGhpcy50b2tWZWN0b3JMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmN1cnJJZHggPSAtMTtcbiAgICB9XG4gICAgc2V0IGlucHV0KG5ld0lucHV0KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgLSBgdGhpcyBwYXJhbWV0ZXJgIG5vdCBzdXBwb3J0ZWQgaW4gc2V0dGVycy9nZXR0ZXJzXG4gICAgICAgIC8vICAgLSBodHRwczovL3d3dy50eXBlc2NyaXB0bGFuZy5vcmcvZG9jcy9oYW5kYm9vay9mdW5jdGlvbnMuaHRtbCN0aGlzLXBhcmFtZXRlcnNcbiAgICAgICAgaWYgKHRoaXMuc2VsZkFuYWx5c2lzRG9uZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE1pc3NpbmcgPHBlcmZvcm1TZWxmQW5hbHlzaXM+IGludm9jYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgUGFyc2VyJ3MgY29uc3RydWN0b3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGB0aGlzIHBhcmFtZXRlcmAgbm90IHN1cHBvcnRlZCBpbiBzZXR0ZXJzL2dldHRlcnNcbiAgICAgICAgLy8gICAtIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2Z1bmN0aW9ucy5odG1sI3RoaXMtcGFyYW1ldGVyc1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMudG9rVmVjdG9yID0gbmV3SW5wdXQ7XG4gICAgICAgIHRoaXMudG9rVmVjdG9yTGVuZ3RoID0gbmV3SW5wdXQubGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva1ZlY3RvcjtcbiAgICB9XG4gICAgLy8gc2tpcHMgYSB0b2tlbiBhbmQgcmV0dXJucyB0aGUgbmV4dCB0b2tlblxuICAgIFNLSVBfVE9LRU4oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJJZHggPD0gdGhpcy50b2tWZWN0b3IubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIExleGVyIChhY2Nlc3NpbmcgVG9rZW4gdmVjdG9yKSByZWxhdGVkIG1ldGhvZHMgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4gdG8gaW1wbGVtZW50IGxhenkgbGV4ZXJzXG4gICAgLy8gb3IgbGV4ZXJzIGRlcGVuZGVudCBvbiBwYXJzZXIgY29udGV4dC5cbiAgICBMQShob3dNdWNoKSB7XG4gICAgICAgIGNvbnN0IHNvdWdodElkeCA9IHRoaXMuY3VycklkeCArIGhvd011Y2g7XG4gICAgICAgIGlmIChzb3VnaHRJZHggPCAwIHx8IHRoaXMudG9rVmVjdG9yTGVuZ3RoIDw9IHNvdWdodElkeCkge1xuICAgICAgICAgICAgcmV0dXJuIEVORF9PRl9GSUxFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rVmVjdG9yW3NvdWdodElkeF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3VtZVRva2VuKCkge1xuICAgICAgICB0aGlzLmN1cnJJZHgrKztcbiAgICB9XG4gICAgZXhwb3J0TGV4ZXJTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycklkeDtcbiAgICB9XG4gICAgaW1wb3J0TGV4ZXJTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLmN1cnJJZHggPSBuZXdTdGF0ZTtcbiAgICB9XG4gICAgcmVzZXRMZXhlclN0YXRlKCkge1xuICAgICAgICB0aGlzLmN1cnJJZHggPSAtMTtcbiAgICB9XG4gICAgbW92ZVRvVGVybWluYXRlZFN0YXRlKCkge1xuICAgICAgICB0aGlzLmN1cnJJZHggPSB0aGlzLnRva1ZlY3Rvci5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBnZXRMZXhlclBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvcnRMZXhlclN0YXRlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfYWRhcHRlci5qcy5tYXAiLCJpbXBvcnQgeyBpbmNsdWRlcywgdmFsdWVzIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9SVUxFX0NPTkZJRywgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZSB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi8uLi9lcnJvcnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4gfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9jaGVja3MuanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciBpbXBsZW1lbnRpbmcgdGhlIHB1YmxpYyBBUElcbiAqIGZvciBkZWZpbmluZyBDaGV2cm90YWluIHBhcnNlcnMsIGkuZTpcbiAqIC0gQ09OU1VNRVxuICogLSBSVUxFXG4gKiAtIE9QVElPTlxuICogLSAuLi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlY29nbml6ZXJBcGkge1xuICAgIEFDVElPTihpbXBsKSB7XG4gICAgICAgIHJldHVybiBpbXBsLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGNvbnN1bWUoaWR4LCB0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCBpZHgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBzdWJydWxlKGlkeCwgcnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgaWR4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgb3B0aW9uKGlkeCwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIGlkeCk7XG4gICAgfVxuICAgIG9yKGlkeCwgYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIGlkeCk7XG4gICAgfVxuICAgIG1hbnkoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWwoaWR4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIGF0TGVhc3RPbmUoaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoaWR4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIENPTlNVTUUodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUUxKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FMih0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTModG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMywgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUU0KHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FNSh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA1LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTYodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUU3KHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FOCh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTkodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgOSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEUocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEUxKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFMihydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTMocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMywgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEU0KHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFNShydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA1LCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTYocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEU3KHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFOChydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTkocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgOSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIE9QVElPTihhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMCk7XG4gICAgfVxuICAgIE9QVElPTjEoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDEpO1xuICAgIH1cbiAgICBPUFRJT04yKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAyKTtcbiAgICB9XG4gICAgT1BUSU9OMyhhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMyk7XG4gICAgfVxuICAgIE9QVElPTjQoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDQpO1xuICAgIH1cbiAgICBPUFRJT041KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA1KTtcbiAgICB9XG4gICAgT1BUSU9ONihhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNik7XG4gICAgfVxuICAgIE9QVElPTjcoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDcpO1xuICAgIH1cbiAgICBPUFRJT044KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA4KTtcbiAgICB9XG4gICAgT1BUSU9OOShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgOSk7XG4gICAgfVxuICAgIE9SKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAwKTtcbiAgICB9XG4gICAgT1IxKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAxKTtcbiAgICB9XG4gICAgT1IyKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAyKTtcbiAgICB9XG4gICAgT1IzKGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCAzKTtcbiAgICB9XG4gICAgT1I0KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA0KTtcbiAgICB9XG4gICAgT1I1KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA1KTtcbiAgICB9XG4gICAgT1I2KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA2KTtcbiAgICB9XG4gICAgT1I3KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA3KTtcbiAgICB9XG4gICAgT1I4KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA4KTtcbiAgICB9XG4gICAgT1I5KGFsdHNPck9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbChhbHRzT3JPcHRzLCA5KTtcbiAgICB9XG4gICAgTUFOWShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgwLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlkxKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDEsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTIoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZMyhhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgzLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlk0KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDQsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTUoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZNihhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg2LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlk3KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDcsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTgoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoOCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZOShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg5LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTllfU0VQKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVAxKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgxLCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVAyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVAzKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCgzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA1KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg1LCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA2KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg2LCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA3KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg3LCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA4KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgTUFOWV9TRVA5KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbCg5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDAsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FMShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkUyKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDIsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FMyhhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgzLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORTQoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkU1KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDUsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FNihhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg2LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORTcoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkU4KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FOShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg5LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQMShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVAyKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDMob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQNChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVA1KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg1LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDYob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDYsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQNyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNywgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVA4KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg4LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDkob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBSVUxFKG5hbWUsIGltcGxlbWVudGF0aW9uLCBjb25maWcgPSBERUZBVUxUX1JVTEVfQ09ORklHKSB7XG4gICAgICAgIGlmIChpbmNsdWRlcyh0aGlzLmRlZmluZWRSdWxlc05hbWVzLCBuYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiBuYW1lLFxuICAgICAgICAgICAgICAgIGdyYW1tYXJOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1JVTEVfTkFNRSxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICBjb25zdCBydWxlSW1wbGVtZW50YXRpb24gPSB0aGlzLmRlZmluZVJ1bGUobmFtZSwgaW1wbGVtZW50YXRpb24sIGNvbmZpZyk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBydWxlSW1wbGVtZW50YXRpb247XG4gICAgICAgIHJldHVybiBydWxlSW1wbGVtZW50YXRpb247XG4gICAgfVxuICAgIE9WRVJSSURFX1JVTEUobmFtZSwgaW1wbCwgY29uZmlnID0gREVGQVVMVF9SVUxFX0NPTkZJRykge1xuICAgICAgICBjb25zdCBydWxlRXJyb3JzID0gdmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuKG5hbWUsIHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIHRoaXMuY2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gdGhpcy5kZWZpbml0aW9uRXJyb3JzLmNvbmNhdChydWxlRXJyb3JzKTtcbiAgICAgICAgY29uc3QgcnVsZUltcGxlbWVudGF0aW9uID0gdGhpcy5kZWZpbmVSdWxlKG5hbWUsIGltcGwsIGNvbmZpZyk7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBydWxlSW1wbGVtZW50YXRpb247XG4gICAgICAgIHJldHVybiBydWxlSW1wbGVtZW50YXRpb247XG4gICAgfVxuICAgIEJBQ0tUUkFDSyhncmFtbWFyUnVsZSwgYXJncykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBvcmcgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5wdXNoKDEpO1xuICAgICAgICAgICAgY29uc3Qgb3JnU3RhdGUgPSB0aGlzLnNhdmVSZWNvZ1N0YXRlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdyYW1tYXJSdWxlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGV4Y2VwdGlvbiB3YXMgdGhyb3duIHdlIGhhdmUgc3VjY2VlZCBwYXJzaW5nIHRoZSBydWxlLlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsb2FkUmVjb2dTdGF0ZShvcmdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBHQVNUIGV4cG9ydCBBUElzXG4gICAgZ2V0R0FzdFByb2R1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZTtcbiAgICB9XG4gICAgZ2V0U2VyaWFsaXplZEdhc3RQcm9kdWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUdyYW1tYXIodmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvZ25pemVyX2FwaS5qcy5tYXAiLCJpbXBvcnQgeyBjbG9uZSwgZXZlcnksIGZsYXR0ZW4sIGhhcywgaXNBcnJheSwgaXNFbXB0eSwgaXNPYmplY3QsIHJlZHVjZSwgdW5pcSwgdmFsdWVzLCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IEFUX0xFQVNUX09ORV9JRFgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBCSVRTX0ZPUl9NRVRIT0RfVFlQRSwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFgsIE1BTllfSURYLCBNQU5ZX1NFUF9JRFgsIE9QVElPTl9JRFgsIE9SX0lEWCwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzLmpzXCI7XG5pbXBvcnQgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24sIE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uLCB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgUFJPRF9UWVBFIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvbG9va2FoZWFkLmpzXCI7XG5pbXBvcnQgeyBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIsIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlciwgTmV4dFRlcm1pbmFsQWZ0ZXJNYW55U2VwV2Fsa2VyLCBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanNcIjtcbmltcG9ydCB7IERFRkFVTFRfUlVMRV9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyLmpzXCI7XG5pbXBvcnQgeyBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTiB9IGZyb20gXCIuL3JlY292ZXJhYmxlLmpzXCI7XG5pbXBvcnQgeyBFT0YgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgaXNUb2tlblR5cGUsIHRva2VuU3RydWN0dXJlZE1hdGNoZXIsIHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXMsIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vdG9rZW5zLmpzXCI7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIHRoZSBydW50aW1lIHBhcnNpbmcgZW5naW5lXG4gKiBVc2VkIGJ5IHRoZSBvZmZpY2lhbCBBUEkgKHJlY29nbml6ZXJfYXBpLnRzKVxuICovXG5leHBvcnQgY2xhc3MgUmVjb2duaXplckVuZ2luZSB7XG4gICAgaW5pdFJlY29nbml6ZXJFbmdpbmUodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIC8vIFRPRE86IHdvdWxkIHVzaW5nIGFuIEVTNiBNYXAgb3IgcGxhaW4gb2JqZWN0IGJlIGZhc3RlciAoQ1NUIGJ1aWxkaW5nIHNjZW5hcmlvKVxuICAgICAgICB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGwgPSB7fTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0ID0ge307XG4gICAgICAgIHRoaXMucnVsZVNob3J0TmFtZUlkeCA9IDI1NjtcbiAgICAgICAgdGhpcy50b2tlbk1hdGNoZXIgPSB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzO1xuICAgICAgICB0aGlzLnN1YnJ1bGVJZHggPSAwO1xuICAgICAgICB0aGlzLmRlZmluZWRSdWxlc05hbWVzID0gW107XG4gICAgICAgIHRoaXMudG9rZW5zTWFwID0ge307XG4gICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSA9IHt9O1xuICAgICAgICBpZiAoaGFzKGNvbmZpZywgXCJzZXJpYWxpemVkR3JhbW1hclwiKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyJ3MgY29uZmlndXJhdGlvbiBjYW4gbm8gbG9uZ2VyIGNvbnRhaW4gYSA8c2VyaWFsaXplZEdyYW1tYXI+IHByb3BlcnR5LlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzYtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgLy8gVGhpcyBvbmx5IGNoZWNrcyBmb3IgVG9rZW4gdm9jYWJ1bGFyaWVzIHByb3ZpZGVkIGFzIGFycmF5cy5cbiAgICAgICAgICAgIC8vIFRoYXQgaXMgZ29vZCBlbm91Z2ggYmVjYXVzZSB0aGUgbWFpbiBvYmplY3RpdmUgaXMgdG8gZGV0ZWN0IHVzZXJzIG9mIHByZS1WNC4wIEFQSXNcbiAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIGFsbCBlZGdlIGNhc2VzIG9mIGVtcHR5IFRva2VuIHZvY2FidWxhcmllcy5cbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkEgVG9rZW4gVm9jYWJ1bGFyeSBjYW5ub3QgYmUgZW1wdHkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdE5vdGUgdGhhdCB0aGUgZmlyc3QgYXJndW1lbnQgZm9yIHRoZSBwYXJzZXIgY29uc3RydWN0b3JcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0aXMgbm8gbG9uZ2VyIGEgVG9rZW4gdmVjdG9yIChzaW5jZSB2NC4wKS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuVm9jYWJ1bGFyeVswXS5zdGFydE9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIFBhcnNlciBjb25zdHJ1Y3RvciBubyBsb25nZXIgYWNjZXB0cyBhIHRva2VuIHZlY3RvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzQtMC0wXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBGdXJ0aGVyIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zTWFwID0gcmVkdWNlKHRva2VuVm9jYWJ1bGFyeSwgKGFjYywgdG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1t0b2tUeXBlLm5hbWVdID0gdG9rVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhcyh0b2tlblZvY2FidWxhcnksIFwibW9kZXNcIikgJiZcbiAgICAgICAgICAgIGV2ZXJ5KGZsYXR0ZW4odmFsdWVzKHRva2VuVm9jYWJ1bGFyeS5tb2RlcykpLCBpc1Rva2VuVHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFRva2VuVHlwZXMgPSBmbGF0dGVuKHZhbHVlcyh0b2tlblZvY2FidWxhcnkubW9kZXMpKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVRva2VucyA9IHVuaXEoYWxsVG9rZW5UeXBlcyk7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9IHJlZHVjZSh1bmlxdWVUb2tlbnMsIChhY2MsIHRva1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBhY2NbdG9rVHlwZS5uYW1lXSA9IHRva1R5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdCh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vuc01hcCA9IGNsb25lKHRva2VuVm9jYWJ1bGFyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8dG9rZW5zRGljdGlvbmFyeT4gYXJndW1lbnQgbXVzdCBiZSBBbiBBcnJheSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMsXCIgK1xuICAgICAgICAgICAgICAgIFwiIEEgZGljdGlvbmFyeSBvZiBUb2tlbiBjb25zdHJ1Y3RvcnMgb3IgYW4gSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHdheXMgYWRkIEVPRiB0byB0aGUgdG9rZW5OYW1lcyAtPiBjb25zdHJ1Y3RvcnMgbWFwLiBpdCBpcyB1c2VmdWwgdG8gYXNzdXJlIGFsbCB0aGUgaW5wdXQgaGFzIGJlZW5cbiAgICAgICAgLy8gcGFyc2VkIHdpdGggYSBjbGVhciBlcnJvciBtZXNzYWdlIChcImV4cGVjdGluZyBFT0YgYnV0IGZvdW5kIC4uLlwiKVxuICAgICAgICB0aGlzLnRva2Vuc01hcFtcIkVPRlwiXSA9IEVPRjtcbiAgICAgICAgY29uc3QgYWxsVG9rZW5UeXBlcyA9IGhhcyh0b2tlblZvY2FidWxhcnksIFwibW9kZXNcIilcbiAgICAgICAgICAgID8gZmxhdHRlbih2YWx1ZXModG9rZW5Wb2NhYnVsYXJ5Lm1vZGVzKSlcbiAgICAgICAgICAgIDogdmFsdWVzKHRva2VuVm9jYWJ1bGFyeSk7XG4gICAgICAgIGNvbnN0IG5vVG9rZW5DYXRlZ29yaWVzVXNlZCA9IGV2ZXJ5KGFsbFRva2VuVHlwZXMsICh0b2tlbkNvbnN0cnVjdG9yKSA9PiBpc0VtcHR5KHRva2VuQ29uc3RydWN0b3IuY2F0ZWdvcnlNYXRjaGVzKSk7XG4gICAgICAgIHRoaXMudG9rZW5NYXRjaGVyID0gbm9Ub2tlbkNhdGVnb3JpZXNVc2VkXG4gICAgICAgICAgICA/IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXNcbiAgICAgICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICAgICAgLy8gQmVjYXVzZSBFUzIwMTUrIHN5bnRheCBzaG91bGQgYmUgc3VwcG9ydGVkIGZvciBjcmVhdGluZyBUb2tlbiBjbGFzc2VzXG4gICAgICAgIC8vIFdlIGNhbm5vdCBhc3N1bWUgdGhhdCB0aGUgVG9rZW4gY2xhc3NlcyB3ZXJlIGNyZWF0ZWQgdXNpbmcgdGhlIFwiZXh0ZW5kVG9rZW5cIiB1dGlsaXRpZXNcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIG11c3QgYXVnbWVudCB0aGUgVG9rZW4gY2xhc3NlcyBib3RoIG9uIExleGVyIGluaXRpYWxpemF0aW9uIGFuZCBvbiBQYXJzZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgYXVnbWVudFRva2VuVHlwZXModmFsdWVzKHRoaXMudG9rZW5zTWFwKSk7XG4gICAgfVxuICAgIGRlZmluZVJ1bGUocnVsZU5hbWUsIGltcGwsIGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5zZWxmQW5hbHlzaXNEb25lKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgR3JhbW1hciBydWxlIDwke3J1bGVOYW1lfT4gbWF5IG5vdCBiZSBkZWZpbmVkIGFmdGVyIHRoZSAncGVyZm9ybVNlbGZBbmFseXNpcycgbWV0aG9kIGhhcyBiZWVuIGNhbGxlZCdcXG5gICtcbiAgICAgICAgICAgICAgICBgTWFrZSBzdXJlIHRoYXQgYWxsIGdyYW1tYXIgcnVsZSBkZWZpbml0aW9ucyBhcmUgZG9uZSBiZWZvcmUgJ3BlcmZvcm1TZWxmQW5hbHlzaXMnIGlzIGNhbGxlZC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN5bmNFbmFibGVkID0gaGFzKGNvbmZpZywgXCJyZXN5bmNFbmFibGVkXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5yZXN5bmNFbmFibGVkIC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogREVGQVVMVF9SVUxFX0NPTkZJRy5yZXN5bmNFbmFibGVkO1xuICAgICAgICBjb25zdCByZWNvdmVyeVZhbHVlRnVuYyA9IGhhcyhjb25maWcsIFwicmVjb3ZlcnlWYWx1ZUZ1bmNcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5VmFsdWVGdW5jIC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgICAgIDogREVGQVVMVF9SVUxFX0NPTkZJRy5yZWNvdmVyeVZhbHVlRnVuYztcbiAgICAgICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBVc2Ugc21hbGwgaW50ZWdlcnMgYXMga2V5cyBmb3IgdGhlIGxvbmdlciBodW1hbiByZWFkYWJsZSBcImZ1bGxcIiBydWxlIG5hbWVzLlxuICAgICAgICAvLyB0aGlzIGdyZWF0bHkgaW1wcm92ZXMgTWFwIGFjY2VzcyB0aW1lIChhcyBtdWNoIGFzIDglIGZvciBzb21lIHBlcmZvcm1hbmNlIGJlbmNobWFya3MpLlxuICAgICAgICBjb25zdCBzaG9ydE5hbWUgPSB0aGlzLnJ1bGVTaG9ydE5hbWVJZHggPDwgKEJJVFNfRk9SX01FVEhPRF9UWVBFICsgQklUU19GT1JfT0NDVVJSRU5DRV9JRFgpO1xuICAgICAgICB0aGlzLnJ1bGVTaG9ydE5hbWVJZHgrKztcbiAgICAgICAgdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV0gPSBydWxlTmFtZTtcbiAgICAgICAgdGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W3J1bGVOYW1lXSA9IHNob3J0TmFtZTtcbiAgICAgICAgbGV0IGludm9rZVJ1bGVXaXRoVHJ5O1xuICAgICAgICAvLyBNaWNybyBvcHRpbWl6YXRpb24sIG9ubHkgY2hlY2sgdGhlIGNvbmRpdGlvbiAqKm9uY2UqKiBvbiBydWxlIGRlZmluaXRpb25cbiAgICAgICAgLy8gaW5zdGVhZCBvZiAqKmV2ZXJ5IHNpbmdsZSoqIHJ1bGUgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBpbnZva2VSdWxlV2l0aFRyeSA9IGZ1bmN0aW9uIGludm9rZVJ1bGVXaXRoVHJ5KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUoc2hvcnROYW1lLCBydWxlTmFtZSwgdGhpcy5zdWJydWxlSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3N0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUoY3N0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlUnVsZUNhdGNoKGUsIHJlc3luY0VuYWJsZWQsIHJlY292ZXJ5VmFsdWVGdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnZva2VSdWxlV2l0aFRyeSA9IGZ1bmN0aW9uIGludm9rZVJ1bGVXaXRoVHJ5Q3N0KC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUoc2hvcnROYW1lLCBydWxlTmFtZSwgdGhpcy5zdWJydWxlSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltcGwuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludm9rZVJ1bGVDYXRjaChlLCByZXN5bmNFbmFibGVkLCByZWNvdmVyeVZhbHVlRnVuYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdyYXBwZWRHcmFtbWFyUnVsZSA9IE9iamVjdC5hc3NpZ24oaW52b2tlUnVsZVdpdGhUcnksIHsgcnVsZU5hbWUsIG9yaWdpbmFsR3JhbW1hckFjdGlvbjogaW1wbCB9KTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRHcmFtbWFyUnVsZTtcbiAgICB9XG4gICAgaW52b2tlUnVsZUNhdGNoKGUsIHJlc3luY0VuYWJsZWRDb25maWcsIHJlY292ZXJ5VmFsdWVGdW5jKSB7XG4gICAgICAgIGNvbnN0IGlzRmlyc3RJbnZva2VkUnVsZSA9IHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDE7XG4gICAgICAgIC8vIG5vdGUgdGhlIHJlU3luYyBpcyBhbHdheXMgZW5hYmxlZCBmb3IgdGhlIGZpcnN0IHJ1bGUgaW52b2NhdGlvbiwgYmVjYXVzZSB3ZSBtdXN0IGFsd2F5cyBiZSBhYmxlIHRvXG4gICAgICAgIC8vIHJlU3luYyB3aXRoIEVPRiBhbmQganVzdCBvdXRwdXQgc29tZSBJTlZBTElEIFBhcnNlVHJlZVxuICAgICAgICAvLyBkdXJpbmcgYmFja3RyYWNraW5nIHJlU3luYyByZWNvdmVyeSBpcyBkaXNhYmxlZCwgb3RoZXJ3aXNlIHdlIGNhbid0IGJlIGNlcnRhaW4gdGhlIGJhY2t0cmFja2luZ1xuICAgICAgICAvLyBwYXRoIGlzIHJlYWxseSB0aGUgbW9zdCB2YWxpZCBvbmVcbiAgICAgICAgY29uc3QgcmVTeW5jRW5hYmxlZCA9IHJlc3luY0VuYWJsZWRDb25maWcgJiYgIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSAmJiB0aGlzLnJlY292ZXJ5RW5hYmxlZDtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY29nRXJyb3IgPSBlO1xuICAgICAgICAgICAgaWYgKHJlU3luY0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZVN5bmNUb2tUeXBlID0gdGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0KHJlU3luY1Rva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29nRXJyb3IucmVzeW5jZWRUb2tlbnMgPSB0aGlzLnJlU3luY1RvKHJlU3luY1Rva1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxDc3RSZXN1bHQgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxDc3RSZXN1bHQucmVjb3ZlcmVkTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNvdmVyeVZhbHVlRnVuYyhlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0Q3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsQ3N0UmVzdWx0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQ3N0UmVzdWx0LnJlY292ZXJlZE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb2dFcnJvci5wYXJ0aWFsQ3N0UmVzdWx0ID0gcGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB0byBiZSBoYW5kbGVkIEZ1cnRoZXIgdXAgdGhlIGNhbGwgc3RhY2tcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVjb2dFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZpcnN0SW52b2tlZFJ1bGUpIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgYSBSZWR1bmRhbnQgaW5wdXQgZXJyb3Igd2lsbCBiZSBjcmVhdGVkIGFzIHdlbGwgYW5kIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGlzIGlzIGluZGVlZCB0aGUgY2FzZVxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVGVybWluYXRlZFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gdGhlIHBhcnNlciBzaG91bGQgbmV2ZXIgdGhyb3cgb25lIG9mIGl0cyBvd24gZXJyb3JzIG91dHNpZGUgaXRzIGZsb3cuXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiBlcnJvciByZWNvdmVyeSBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgIHJldHVybiByZWNvdmVyeVZhbHVlRnVuYyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRvIGJlIHJlY292ZXJlZCBGdXJ0aGVyIHVwIHRoZSBjYWxsIHN0YWNrXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVjb2dFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNvbWUgb3RoZXIgRXJyb3IgdHlwZSB3aGljaCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGUgKGZvciBleGFtcGxlIGEgYnVpbHQgaW4gSmF2YVNjcmlwdCBFcnJvcilcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgcGFyc2luZyBEU0xcbiAgICBvcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChPUFRJT05fSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWxMb2dpYyhhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSwga2V5KTtcbiAgICB9XG4gICAgb3B0aW9uSW50ZXJuYWxMb2dpYyhhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSwga2V5KSB7XG4gICAgICAgIGxldCBsb29rQWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25PUk1ldGhvZERlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvb2thaGVhZEZ1bmN0aW9uID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVJbnRlcm5hbChwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgY29uc3QgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwgbGFLZXkpO1xuICAgIH1cbiAgICBhdExlYXN0T25lSW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYsIGtleSkge1xuICAgICAgICBsZXQgbG9va0FoZWFkRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIGxldCBhY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uT1JNZXRob2REZWYgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWYuREVGO1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYWN0aW9uT1JNZXRob2REZWYuR0FURTtcbiAgICAgICAgICAgIC8vIHByZWRpY2F0ZSBwcmVzZW50XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdMb29rYWhlYWRGdW5jdGlvbiA9IGxvb2tBaGVhZEZ1bmM7XG4gICAgICAgICAgICAgICAgbG9va0FoZWFkRnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKHRoaXMpICYmIG9yZ0xvb2thaGVhZEZ1bmN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxldCBub3RTdHVjayA9IHRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICB3aGlsZSAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgbm90U3R1Y2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9IHRoaXMuZG9TaW5nbGVSZXBldGl0aW9uKGFjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKHByb2RPY2N1cnJlbmNlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlksIGFjdGlvbk9STWV0aG9kRGVmLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vdGUgdGhhdCB3aGlsZSBpdCBtYXkgc2VlbSB0aGF0IHRoaXMgY2FuIGNhdXNlIGFuIGVycm9yIGJlY2F1c2UgYnkgdXNpbmcgYSByZWN1cnNpdmUgY2FsbCB0b1xuICAgICAgICAvLyBBVF9MRUFTVF9PTkUgd2UgY2hhbmdlIHRoZSBncmFtbWFyIHRvIEFUX0xFQVNUX1RXTywgQVRfTEVBU1RfVEhSRUUgLi4uICwgdGhlIHBvc3NpYmxlIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIC8vIGZyb20gdGhlIHRyeUluUmVwZXRpdGlvblJlY292ZXJ5KC4uLikgd2lsbCBvbmx5IGhhcHBlbiBJRkYgdGhlcmUgcmVhbGx5IGFyZSBUV08vVEhSRUUvLi4uLiBpdGVtcy5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMuYXRMZWFzdE9uZUludGVybmFsLCBbcHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmXSwgbG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVdhbGtlcik7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMsIGtleSkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlcmF0aW9uTG9va2FoZWFkRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIC8vIDFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKGZpcnN0SXRlcmF0aW9uTG9va2FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIC8vICBUT0RPOiBPcHRpbWl6YXRpb24gY2FuIG1vdmUgdGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3Rpb24gaW50byBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiXG4gICAgICAgICAgICAvLyAgYmVjYXVzZSBpdCBpcyBvbmx5IG5lZWRlZCBpbiBlcnJvciByZWNvdmVyeSBzY2VuYXJpb3MuXG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLCBzZXBhcmF0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIDJuZC4ubnRoIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLCBzZXBhcmF0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoaXMgQ09OU1VNRSB3aWxsIG5ldmVyIGVudGVyIHJlY292ZXJ5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQ09OU1VNRShzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgZm9yIGNoZWNraW5nIGluZmluaXRlIGxvb3AgaGVyZSBkdWUgdG8gY29uc3VtaW5nIHRoZSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlcixcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUiwgb3B0aW9ucy5FUlJfTVNHKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYW55SW50ZXJuYWwocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIGNvbnN0IGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoTUFOWV9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFueUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgfVxuICAgIG1hbnlJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KSB7XG4gICAgICAgIGxldCBsb29rYWhlYWRGdW5jdGlvbiA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIGxldCBhY3Rpb247XG4gICAgICAgIGlmICh0eXBlb2YgYWN0aW9uT1JNZXRob2REZWYgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWYuREVGO1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYWN0aW9uT1JNZXRob2REZWYuR0FURTtcbiAgICAgICAgICAgIC8vIHByZWRpY2F0ZSBwcmVzZW50XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmdMb29rYWhlYWRGdW5jdGlvbiA9IGxvb2thaGVhZEZ1bmN0aW9uO1xuICAgICAgICAgICAgICAgIGxvb2thaGVhZEZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vdFN0dWNrID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKGxvb2thaGVhZEZ1bmN0aW9uLmNhbGwodGhpcykgPT09IHRydWUgJiYgbm90U3R1Y2sgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5tYW55SW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rYWhlYWRGdW5jdGlvbiwgTUFOWV9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlck1hbnlXYWxrZXIsIFxuICAgICAgICAvLyBUaGUgbm90U3R1Y2sgcGFyYW1ldGVyIGlzIG9ubHkgcmVsZXZhbnQgd2hlbiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiXG4gICAgICAgIC8vIGlzIGludm9rZWQgZnJvbSBtYW55SW50ZXJuYWwsIGluIHRoZSBNQU5ZX1NFUCBjYXNlIGFuZCBBVF9MRUFTVF9PTkVbX1NFUF1cbiAgICAgICAgLy8gQW4gaW5maW5pdGUgbG9vcCBjYW5ub3Qgb2NjdXIgYXM6XG4gICAgICAgIC8vIC0gRWl0aGVyIHRoZSBsb29rYWhlYWQgaXMgZ3VhcmFudGVlZCB0byBjb25zdW1lIHNvbWV0aGluZyAoU2luZ2xlIFRva2VuIFNlcGFyYXRvcilcbiAgICAgICAgLy8gLSBBVF9MRUFTVF9PTkUgYnkgZGVmaW5pdGlvbiBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChvciBlcnJvciBvdXQpLlxuICAgICAgICBub3RTdHVjayk7XG4gICAgfVxuICAgIG1hbnlTZXBGaXJzdEludGVybmFsKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoTUFOWV9TRVBfSURYLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIHRoaXMubWFueVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywgbGFLZXkpO1xuICAgIH1cbiAgICBtYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBrZXkpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gb3B0aW9ucy5ERUY7XG4gICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IG9wdGlvbnMuU0VQO1xuICAgICAgICBjb25zdCBmaXJzdEl0ZXJhdGlvbkxhRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGtleSk7XG4gICAgICAgIC8vIDFzdCBpdGVyYXRpb25cbiAgICAgICAgaWYgKGZpcnN0SXRlcmF0aW9uTGFGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyAybmQuLm50aCBpdGVyYXRpb25zXG4gICAgICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgc2VwYXJhdG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgY2hlY2tzIHRoYXQgdGhlIHNlcGFyYXRvciByZWFsbHkgZG9lcyBleGlzdC5cbiAgICAgICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIGZvciBjaGVja2luZyBpbmZpbml0ZSBsb29wIGhlcmUgZHVlIHRvIGNvbnN1bWluZyB0aGUgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLnJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbCwgW1xuICAgICAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLFxuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIsXG4gICAgICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBNQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGV0aXRpb25TZXBTZWNvbmRJbnRlcm5hbChwcm9kT2NjdXJyZW5jZSwgc2VwYXJhdG9yLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBhY3Rpb24sIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKSB7XG4gICAgICAgIHdoaWxlIChzZXBhcmF0b3JMb29rQWhlYWRGdW5jKCkpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGlzIENPTlNVTUUgd2lsbCBuZXZlciBlbnRlciByZWNvdmVyeSBiZWNhdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBjYW4gb25seSBhcnJpdmUgdG8gdGhpcyBmdW5jdGlvbiBhZnRlciBhbiBlcnJvclxuICAgICAgICAvLyBoYXMgb2NjdXJyZWQgKGhlbmNlIHRoZSBuYW1lICdzZWNvbmQnKSBzbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIElGIHdpbGwgYWx3YXlzIGJlIGVudGVyZWQsIGl0cyBwb3NzaWJsZSB0byByZW1vdmUgaXQuLi5cbiAgICAgICAgLy8gaG93ZXZlciBpdCBpcyBrZXB0IHRvIGF2b2lkIGNvbmZ1c2lvbiBhbmQgYmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gUGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBcImF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeVwiIHdpbGwgYmUgZGVmaW5lZCBhcyBOT09QIHVubGVzcyByZWNvdmVyeSBpcyBlbmFibGVkXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHNlcGFyYXRvcixcbiAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICBuZXh0VGVybWluYWxBZnRlcldhbGtlcixcbiAgICAgICAgXSwgc2VwYXJhdG9yTG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBuZXh0VGVybWluYWxBZnRlcldhbGtlcik7XG4gICAgfVxuICAgIGRvU2luZ2xlUmVwZXRpdGlvbihhY3Rpb24pIHtcbiAgICAgICAgY29uc3QgYmVmb3JlSXRlcmF0aW9uID0gdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7XG4gICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICBjb25zdCBhZnRlckl0ZXJhdGlvbiA9IHRoaXMuZ2V0TGV4ZXJQb3NpdGlvbigpO1xuICAgICAgICAvLyBUaGlzIGJvb2xlYW4gd2lsbCBpbmRpY2F0ZSBpZiB0aGlzIHJlcGV0aXRpb24gcHJvZ3Jlc3NlZFxuICAgICAgICAvLyBvciBpZiB3ZSBhcmUgXCJzdHVja1wiIChwb3RlbnRpYWwgaW5maW5pdGUgbG9vcCBpbiB0aGUgcmVwZXRpdGlvbikuXG4gICAgICAgIHJldHVybiBhZnRlckl0ZXJhdGlvbiA+IGJlZm9yZUl0ZXJhdGlvbjtcbiAgICB9XG4gICAgb3JJbnRlcm5hbChhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIGNvbnN0IGxhS2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoT1JfSURYLCBvY2N1cnJlbmNlKTtcbiAgICAgICAgY29uc3QgYWx0cyA9IGlzQXJyYXkoYWx0c09yT3B0cykgPyBhbHRzT3JPcHRzIDogYWx0c09yT3B0cy5ERUY7XG4gICAgICAgIGNvbnN0IGxhRnVuYyA9IHRoaXMuZ2V0TGFGdW5jRnJvbUNhY2hlKGxhS2V5KTtcbiAgICAgICAgY29uc3QgYWx0SWR4VG9UYWtlID0gbGFGdW5jLmNhbGwodGhpcywgYWx0cyk7XG4gICAgICAgIGlmIChhbHRJZHhUb1Rha2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hvc2VuQWx0ZXJuYXRpdmUgPSBhbHRzW2FsdElkeFRvVGFrZV07XG4gICAgICAgICAgICByZXR1cm4gY2hvc2VuQWx0ZXJuYXRpdmUuQUxULmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yYWlzZU5vQWx0RXhjZXB0aW9uKG9jY3VycmVuY2UsIGFsdHNPck9wdHMuRVJSX01TRyk7XG4gICAgfVxuICAgIHJ1bGVGaW5hbGx5U3RhdGVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sucG9wKCk7XG4gICAgICAgIC8vIE5PT1Agd2hlbiBjc3QgaXMgZGlzYWJsZWRcbiAgICAgICAgdGhpcy5jc3RGaW5hbGx5U3RhdGVVcGRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0F0RW5kT2ZJbnB1dCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWR1bmRhbnRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZmlyc3RSZWR1bmRhbnQ6IGZpcnN0UmVkdW5kYW50VG9rLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5TQVZFX0VSUk9SKG5ldyBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbihlcnJNc2csIGZpcnN0UmVkdW5kYW50VG9rKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIGlkeCwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcnVsZVJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLkFSR1MgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN1YnJ1bGVJZHggPSBpZHg7XG4gICAgICAgICAgICBydWxlUmVzdWx0ID0gcnVsZVRvQ2FsbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKHJ1bGVSZXN1bHQsIG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkxBQkVMICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuTEFCRUxcbiAgICAgICAgICAgICAgICA6IHJ1bGVUb0NhbGwucnVsZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuc3VicnVsZUludGVybmFsRXJyb3IoZSwgb3B0aW9ucywgcnVsZVRvQ2FsbC5ydWxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3VicnVsZUludGVybmFsRXJyb3IoZSwgb3B0aW9ucywgcnVsZU5hbWUpIHtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZSkgJiYgZS5wYXJ0aWFsQ3N0UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsKGUucGFydGlhbENzdFJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZU5hbWUpO1xuICAgICAgICAgICAgZGVsZXRlIGUucGFydGlhbENzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBjb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgaWR4LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBjb25zdW1lZFRva2VuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTWF0Y2hlcihuZXh0VG9rZW4sIHRva1R5cGUpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgICAgICBjb25zdW1lZFRva2VuID0gbmV4dFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lSW50ZXJuYWxFcnJvcih0b2tUeXBlLCBuZXh0VG9rZW4sIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlRnJvbUNvbnN1bXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdW1lZFRva2VuID0gdGhpcy5jb25zdW1lSW50ZXJuYWxSZWNvdmVyeSh0b2tUeXBlLCBpZHgsIGVGcm9tQ29uc3VtcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3N0UG9zdFRlcm1pbmFsKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLkxBQkVMICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgOiB0b2tUeXBlLm5hbWUsIGNvbnN1bWVkVG9rZW4pO1xuICAgICAgICByZXR1cm4gY29uc3VtZWRUb2tlbjtcbiAgICB9XG4gICAgY29uc3VtZUludGVybmFsRXJyb3IodG9rVHlwZSwgbmV4dFRva2VuLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBtc2c7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuRVJSX01TRykge1xuICAgICAgICAgICAgbXNnID0gb3B0aW9ucy5FUlJfTVNHO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXNnID0gdGhpcy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdG9rVHlwZSxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5leHRUb2tlbixcbiAgICAgICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNUb2tlbixcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLlNBVkVfRVJST1IobmV3IE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbihtc2csIG5leHRUb2tlbiwgcHJldmlvdXNUb2tlbikpO1xuICAgIH1cbiAgICBjb25zdW1lSW50ZXJuYWxSZWNvdmVyeSh0b2tUeXBlLCBpZHgsIGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgLy8gbm8gcmVjb3ZlcnkgYWxsb3dlZCBkdXJpbmcgYmFja3RyYWNraW5nLCBvdGhlcndpc2UgYmFja3RyYWNraW5nIG1heSByZWNvdmVyIGludmFsaWQgc3ludGF4IGFuZCBhY2NlcHQgaXRcbiAgICAgICAgLy8gYnV0IHRoZSBvcmlnaW5hbCBzeW50YXggY291bGQgaGF2ZSBiZWVuIHBhcnNlZCBzdWNjZXNzZnVsbHkgd2l0aG91dCBhbnkgYmFja3RyYWNraW5nICsgcmVjb3ZlcnlcbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkICYmXG4gICAgICAgICAgICAvLyBUT0RPOiBtb3JlIHJvYnVzdCBjaGVja2luZyBvZiB0aGUgZXhjZXB0aW9uIHR5cGUuIFBlcmhhcHMgVHlwZXNjcmlwdCBleHRlbmRpbmcgZXhwcmVzc2lvbnM/XG4gICAgICAgICAgICBlRnJvbUNvbnN1bXB0aW9uLm5hbWUgPT09IFwiTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uXCIgJiZcbiAgICAgICAgICAgICF0aGlzLmlzQmFja1RyYWNraW5nKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd3MgPSB0aGlzLmdldEZvbGxvd3NGb3JJblJ1bGVSZWNvdmVyeSh0b2tUeXBlLCBpZHgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cnlJblJ1bGVSZWNvdmVyeSh0b2tUeXBlLCBmb2xsb3dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlRnJvbUluUnVsZVJlY292ZXJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVGcm9tSW5SdWxlUmVjb3ZlcnkubmFtZSA9PT0gSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGluIFJ1bGVSZWNvdmVyeS5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsIGVycm9yIGluIG9yZGVyIHRvIHRyaWdnZXIgcmVTeW5jIGVycm9yIHJlY292ZXJ5XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlRnJvbUluUnVsZVJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVGcm9tQ29uc3VtcHRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2F2ZVJlY29nU3RhdGUoKSB7XG4gICAgICAgIC8vIGVycm9ycyBpcyBhIGdldHRlciB3aGljaCB3aWxsIGNsb25lIHRoZSBlcnJvcnMgYXJyYXlcbiAgICAgICAgY29uc3Qgc2F2ZWRFcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgY29uc3Qgc2F2ZWRSdWxlU3RhY2sgPSBjbG9uZSh0aGlzLlJVTEVfU1RBQ0spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3JzOiBzYXZlZEVycm9ycyxcbiAgICAgICAgICAgIGxleGVyU3RhdGU6IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpLFxuICAgICAgICAgICAgUlVMRV9TVEFDSzogc2F2ZWRSdWxlU3RhY2ssXG4gICAgICAgICAgICBDU1RfU1RBQ0s6IHRoaXMuQ1NUX1NUQUNLLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWxvYWRSZWNvZ1N0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbmV3U3RhdGUuZXJyb3JzO1xuICAgICAgICB0aGlzLmltcG9ydExleGVyU3RhdGUobmV3U3RhdGUubGV4ZXJTdGF0ZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IG5ld1N0YXRlLlJVTEVfU1RBQ0s7XG4gICAgfVxuICAgIHJ1bGVJbnZvY2F0aW9uU3RhdGVVcGRhdGUoc2hvcnROYW1lLCBmdWxsTmFtZSwgaWR4SW5DYWxsaW5nUnVsZSkge1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wdXNoKGlkeEluQ2FsbGluZ1J1bGUpO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sucHVzaChzaG9ydE5hbWUpO1xuICAgICAgICAvLyBOT09QIHdoZW4gY3N0IGlzIGRpc2FibGVkXG4gICAgICAgIHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlKGZ1bGxOYW1lKTtcbiAgICB9XG4gICAgaXNCYWNrVHJhY2tpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2subGVuZ3RoICE9PSAwO1xuICAgIH1cbiAgICBnZXRDdXJyUnVsZUZ1bGxOYW1lKCkge1xuICAgICAgICBjb25zdCBzaG9ydE5hbWUgPSB0aGlzLmdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdO1xuICAgIH1cbiAgICBzaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShzaG9ydE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbFtzaG9ydE5hbWVdO1xuICAgIH1cbiAgICBpc0F0RW5kT2ZJbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIEVPRik7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnJlc2V0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLnN1YnJ1bGVJZHggPSAwO1xuICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gW107XG4gICAgICAgIC8vIFRPRE86IGV4dHJhY3QgYSBzcGVjaWZpYyByZXNldCBmb3IgVHJlZUJ1aWxkZXIgdHJhaXRcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sgPSBbXTtcbiAgICAgICAgdGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0sgPSBbXTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWNvZ25pemVyX2VuZ2luZS5qcy5tYXAiLCJpbXBvcnQgeyBFYXJseUV4aXRFeGNlcHRpb24sIGlzUmVjb2duaXRpb25FeGNlcHRpb24sIE5vVmlhYmxlQWx0RXhjZXB0aW9uLCB9IGZyb20gXCIuLi8uLi9leGNlcHRpb25zX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgY2xvbmUsIGhhcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kLCBnZXRMb29rYWhlYWRQYXRoc0Zvck9yLCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2xvb2thaGVhZC5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuLyoqXG4gKiBUcmFpdCByZXNwb25zaWJsZSBmb3IgcnVudGltZSBwYXJzaW5nIGVycm9ycy5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9ySGFuZGxlciB7XG4gICAgaW5pdEVycm9ySGFuZGxlcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIgPSBoYXMoY29uZmlnLCBcImVycm9yTWVzc2FnZVByb3ZpZGVyXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlciAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5lcnJvck1lc3NhZ2VQcm92aWRlcjtcbiAgICB9XG4gICAgU0FWRV9FUlJPUihlcnJvcikge1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlcnJvcikpIHtcbiAgICAgICAgICAgIGVycm9yLmNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiB0aGlzLmdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSxcbiAgICAgICAgICAgICAgICBydWxlT2NjdXJyZW5jZVN0YWNrOiBjbG9uZSh0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUcnlpbmcgdG8gc2F2ZSBhbiBFcnJvciB3aGljaCBpcyBub3QgYSBSZWNvZ25pdGlvbkV4Y2VwdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gY2xvbmUodGhpcy5fZXJyb3JzKTtcbiAgICB9XG4gICAgc2V0IGVycm9ycyhuZXdFcnJvcnMpIHtcbiAgICAgICAgdGhpcy5fZXJyb3JzID0gbmV3RXJyb3JzO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjb25zaWRlciBjYWNoaW5nIHRoZSBlcnJvciBtZXNzYWdlIGNvbXB1dGVkIGluZm9ybWF0aW9uXG4gICAgcmFpc2VFYXJseUV4aXRFeGNlcHRpb24ob2NjdXJyZW5jZSwgcHJvZFR5cGUsIHVzZXJEZWZpbmVkRXJyTXNnKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIGNvbnN0IHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtydWxlTmFtZV07XG4gICAgICAgIGNvbnN0IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZChvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgcHJvZFR5cGUsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgY29uc3QgaW5zaWRlUHJvZFBhdGhzID0gbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZVswXTtcbiAgICAgICAgY29uc3QgYWN0dWFsVG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMubWF4TG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgICAgIGFjdHVhbFRva2Vucy5wdXNoKHRoaXMuTEEoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKHtcbiAgICAgICAgICAgIGV4cGVjdGVkSXRlcmF0aW9uUGF0aHM6IGluc2lkZVByb2RQYXRocyxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHRoaXMuTEEoMCksXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IHVzZXJEZWZpbmVkRXJyTXNnLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyBFYXJseUV4aXRFeGNlcHRpb24obXNnLCB0aGlzLkxBKDEpLCB0aGlzLkxBKDApKSk7XG4gICAgfVxuICAgIC8vIFRPRE86IGNvbnNpZGVyIGNhY2hpbmcgdGhlIGVycm9yIG1lc3NhZ2UgY29tcHV0ZWQgaW5mb3JtYXRpb25cbiAgICByYWlzZU5vQWx0RXhjZXB0aW9uKG9jY3VycmVuY2UsIGVyck1zZ1R5cGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIGNvbnN0IHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtydWxlTmFtZV07XG4gICAgICAgIC8vIFRPRE86IGdldExvb2thaGVhZFBhdGhzRm9yT3IgY2FuIGJlIHNsb3cgZm9yIGxhcmdlIGVub3VnaCBtYXhMb29rYWhlYWQgYW5kIGNlcnRhaW4gZ3JhbW1hcnMsIGNvbnNpZGVyIGNhY2hpbmcgP1xuICAgICAgICBjb25zdCBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICBjb25zdCBhY3R1YWxUb2tlbnMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5tYXhMb29rYWhlYWQ7IGkrKykge1xuICAgICAgICAgICAgYWN0dWFsVG9rZW5zLnB1c2godGhpcy5MQShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgZXhwZWN0ZWRQYXRoc1BlckFsdDogbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZSxcbiAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsVG9rZW5zLFxuICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICBjdXN0b21Vc2VyRGVzY3JpcHRpb246IGVyck1zZ1R5cGVzLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhyb3cgdGhpcy5TQVZFX0VSUk9SKG5ldyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbihlcnJNc2csIHRoaXMuTEEoMSksIHByZXZpb3VzVG9rZW4pKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcl9oYW5kbGVyLmpzLm1hcCIsImltcG9ydCB7IE5leHRBZnRlclRva2VuV2Fsa2VyLCBuZXh0UG9zc2libGVUb2tlbnNBZnRlciwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9pbnRlcnByZXRlci5qc1wiO1xuaW1wb3J0IHsgZmlyc3QsIGlzVW5kZWZpbmVkIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuZXhwb3J0IGNsYXNzIENvbnRlbnRBc3Npc3Qge1xuICAgIGluaXRDb250ZW50QXNzaXN0KCkgeyB9XG4gICAgY29tcHV0ZUNvbnRlbnRBc3Npc3Qoc3RhcnRSdWxlTmFtZSwgcHJlY2VkaW5nSW5wdXQpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRSdWxlR2FzdCA9IHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGVbc3RhcnRSdWxlTmFtZV07XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChzdGFydFJ1bGVHYXN0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFJ1bGUgLT4ke3N0YXJ0UnVsZU5hbWV9PC0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBncmFtbWFyLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0UG9zc2libGVUb2tlbnNBZnRlcihbc3RhcnRSdWxlR2FzdF0sIHByZWNlZGluZ0lucHV0LCB0aGlzLnRva2VuTWF0Y2hlciwgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBhIG1lbWJlciBtZXRob2Qgb3IgYSB1dGlsaXR5PyBpdCBkb2VzIG5vdCBoYXZlIGFueSBzdGF0ZSBvciB1c2FnZSBvZiAndGhpcycuLi5cbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBiZSBtb3JlIGV4cGxpY2l0bHkgcGFydCBvZiB0aGUgcHVibGljIEFQST9cbiAgICBnZXROZXh0UG9zc2libGVUb2tlblR5cGVzKGdyYW1tYXJQYXRoKSB7XG4gICAgICAgIGNvbnN0IHRvcFJ1bGVOYW1lID0gZmlyc3QoZ3JhbW1hclBhdGgucnVsZVN0YWNrKTtcbiAgICAgICAgY29uc3QgZ2FzdFByb2R1Y3Rpb25zID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKTtcbiAgICAgICAgY29uc3QgdG9wUHJvZHVjdGlvbiA9IGdhc3RQcm9kdWN0aW9uc1t0b3BSdWxlTmFtZV07XG4gICAgICAgIGNvbnN0IG5leHRQb3NzaWJsZVRva2VuVHlwZXMgPSBuZXcgTmV4dEFmdGVyVG9rZW5XYWxrZXIodG9wUHJvZHVjdGlvbiwgZ3JhbW1hclBhdGgpLnN0YXJ0V2Fsa2luZygpO1xuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5UeXBlcztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250ZXh0X2Fzc2lzdC5qcy5tYXAiLCJpbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGxhc3QgYXMgcGVlaywgc29tZSwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vbGV4ZXJfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgaGFzU2hvcnRLZXlQcm9wZXJ0eSwgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlLCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IEVORF9PRl9GSUxFIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgQklUU19GT1JfT0NDVVJSRU5DRV9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzLmpzXCI7XG5jb25zdCBSRUNPUkRJTkdfTlVMTF9PQkpFQ1QgPSB7XG4gICAgZGVzY3JpcHRpb246IFwiVGhpcyBPYmplY3QgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgZHVyaW5nIFJlY29yZGluZyBQaGFzZVwiLFxufTtcbk9iamVjdC5mcmVlemUoUkVDT1JESU5HX05VTExfT0JKRUNUKTtcbmNvbnN0IEhBTkRMRV9TRVBBUkFUT1IgPSB0cnVlO1xuY29uc3QgTUFYX01FVEhPRF9JRFggPSBNYXRoLnBvdygyLCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCkgLSAxO1xuY29uc3QgUkZUID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlJFQ09SRElOR19QSEFTRV9UT0tFTlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtSRlRdKTtcbmNvbnN0IFJFQ09SRElOR19QSEFTRV9UT0tFTiA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoUkZULCBcIlRoaXMgSVRva2VuIGluZGljYXRlcyB0aGUgUGFyc2VyIGlzIGluIFJlY29yZGluZyBQaGFzZVxcblxcdFwiICtcbiAgICBcIlwiICtcbiAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIiwgXG4vLyBVc2luZyBcIi0xXCIgaW5zdGVhZCBvZiBOYU4gKGFzIGluIEVPRikgYmVjYXVzZSBhbiBhY3R1YWwgbnVtYmVyIGlzIGxlc3MgbGlrZWx5IHRvXG4vLyBjYXVzZSBlcnJvcnMgaWYgdGhlIG91dHB1dCBvZiBMQSBvciBDT05TVU1FIHdvdWxkIGJlIChpbmNvcnJlY3RseSkgdXNlZCBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbi0xLCAtMSwgLTEsIC0xLCAtMSwgLTEpO1xuT2JqZWN0LmZyZWV6ZShSRUNPUkRJTkdfUEhBU0VfVE9LRU4pO1xuY29uc3QgUkVDT1JESU5HX1BIQVNFX0NTVE5PREUgPSB7XG4gICAgbmFtZTogXCJUaGlzIENTVE5vZGUgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIixcbiAgICBjaGlsZHJlbjoge30sXG59O1xuLyoqXG4gKiBUaGlzIHRyYWl0IGhhbmRsZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBHQVNUIHN0cnVjdHVyZSBmb3IgQ2hldnJvdGFpbiBHcmFtbWFyc1xuICovXG5leHBvcnQgY2xhc3MgR2FzdFJlY29yZGVyIHtcbiAgICBpbml0R2FzdFJlY29yZGVyKGNvbmZpZykge1xuICAgICAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbmFibGVSZWNvcmRpbmcoKSB7XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiRW5hYmxlIFJlY29yZGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhcm5pbmcgRGFyayBWb29kb28gTWFnaWMgdXBjb21pbmchXG4gICAgICAgICAgICAgKiBXZSBhcmUgXCJyZXBsYWNpbmdcIiB0aGUgcHVibGljIHBhcnNpbmcgRFNMIG1ldGhvZHMgQVBJXG4gICAgICAgICAgICAgKiBXaXRoICoqbmV3KiogYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zIG9uIHRoZSBQYXJzZXIgKippbnN0YW5jZSoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU28gZmFyIHRoaXMgaXMgdGhlIG9ubHkgd2F5IEkndmUgZm91bmQgdG8gYXZvaWQgcGVyZm9ybWFuY2UgcmVncmVzc2lvbnMgZHVyaW5nIHBhcnNpbmcgdGltZS5cbiAgICAgICAgICAgICAqIC0gQXBwcm94IDMwJSBwZXJmb3JtYW5jZSByZWdyZXNzaW9uIHdhcyBtZWFzdXJlZCBvbiBDaHJvbWUgNzUgQ2FuYXJ5IHdoZW4gYXR0ZW1wdGluZyB0byByZXBsYWNlIHRoZSBcImludGVybmFsXCJcbiAgICAgICAgICAgICAqICAgaW1wbGVtZW50YXRpb25zIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGkgPiAwID8gaSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpc1tgQ09OU1VNRSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgU1VCUlVMRSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgT1BUSU9OJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNbYE9SJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsUmVjb3JkKGFyZzEsIGkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgTUFOWSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzW2BNQU5ZX1NFUCR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNbYEFUX0xFQVNUX09ORSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzW2BBVF9MRUFTVF9PTkVfU0VQJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEU0wgbWV0aG9kcyB3aXRoIHRoZSBpZHgoc3VmZml4KSBhcyBhbiBhcmd1bWVudFxuICAgICAgICAgICAgdGhpc1tgY29uc3VtZWBdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgsIGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYHN1YnJ1bGVgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4LCBhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW2BvcHRpb25gXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYG9yYF0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYG1hbnlgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYGF0TGVhc3RPbmVgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuQUNUSU9OID0gdGhpcy5BQ1RJT05fUkVDT1JEO1xuICAgICAgICAgICAgdGhpcy5CQUNLVFJBQ0sgPSB0aGlzLkJBQ0tUUkFDS19SRUNPUkQ7XG4gICAgICAgICAgICB0aGlzLkxBID0gdGhpcy5MQV9SRUNPUkQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNhYmxlUmVjb3JkaW5nKCkge1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgICAgICAvLyBCeSBkZWxldGluZyB0aGVzZSAqKmluc3RhbmNlKiogcHJvcGVydGllcywgYW55IGZ1dHVyZSBpbnZvY2F0aW9uXG4gICAgICAgIC8vIHdpbGwgYmUgZGVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZHMgb24gdGhlICoqcHJvdG90eXBlKiogb2JqZWN0XG4gICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gZ2V0IHJpZCBvZiBhbnkgaW5jb3JyZWN0IG9wdGltaXphdGlvbnMgdGhhdCBWOCBtYXlcbiAgICAgICAgLy8gZG8gZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkRlbGV0aW5nIFJlY29yZGluZyBtZXRob2RzXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdFtgQ09OU1VNRSR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BTVUJSVUxFJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYE9QVElPTiR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BPUiR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BNQU5ZJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYE1BTllfU0VQJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYEFUX0xFQVNUX09ORSR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BBVF9MRUFTVF9PTkVfU0VQJHtpZHh9YF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhhdFtgY29uc3VtZWBdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbYHN1YnJ1bGVgXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BvcHRpb25gXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BvcmBdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbYG1hbnlgXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BhdExlYXN0T25lYF07XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5BQ1RJT047XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5CQUNLVFJBQ0s7XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5MQTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vICAgUGFyc2VyIG1ldGhvZHMgYXJlIGNhbGxlZCBpbnNpZGUgYW4gQUNUSU9OP1xuICAgIC8vICAgTWF5YmUgdHJ5L2NhdGNoL2ZpbmFsbHkgb24gQUNUSU9OUyB3aGlsZSBkaXNhYmxpbmcgdGhlIHJlY29yZGVycyBzdGF0ZSBjaGFuZ2VzP1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gbm9vcCBwbGFjZSBob2xkZXJcbiAgICBBQ1RJT05fUkVDT1JEKGltcGwpIHtcbiAgICAgICAgLy8gTk8tT1AgZHVyaW5nIHJlY29yZGluZ1xuICAgIH1cbiAgICAvLyBFeGVjdXRpbmcgYmFja3RyYWNraW5nIGxvZ2ljIHdpbGwgYnJlYWsgb3VyIHJlY29yZGluZyBsb2dpYyBhc3N1bXB0aW9uc1xuICAgIEJBQ0tUUkFDS19SRUNPUkQoZ3JhbW1hclJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRydWU7XG4gICAgfVxuICAgIC8vIExBIGlzIHBhcnQgb2YgdGhlIG9mZmljaWFsIEFQSSBhbmQgbWF5IGJlIHVzZWQgZm9yIGN1c3RvbSBsb29rYWhlYWQgbG9naWNcbiAgICAvLyBieSBlbmQgdXNlcnMgd2hvIG1heSBmb3JnZXQgdG8gd3JhcCBpdCBpbiBBQ1RJT04gb3IgaW5zaWRlIGEgR0FURVxuICAgIExBX1JFQ09SRChob3dNdWNoKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgdGhlIFJFQ09SRF9QSEFTRV9UT0tFTiBoZXJlIGJlY2F1c2Ugc29tZW9uZSBtYXkgZGVwZW5kXG4gICAgICAgIC8vIE9uIExBIHJldHVybiBFT0YgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgc28gYW4gaW5maW5pdGUgbG9vcCBtYXkgb2NjdXIuXG4gICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICB9XG4gICAgdG9wTGV2ZWxSdWxlUmVjb3JkKG5hbWUsIGRlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3VG9wTGV2ZWxSdWxlID0gbmV3IFJ1bGUoeyBkZWZpbml0aW9uOiBbXSwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIG5ld1RvcExldmVsUnVsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3VG9wTGV2ZWxSdWxlKTtcbiAgICAgICAgICAgIGRlZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9wTGV2ZWxSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG5cXHQgVGhpcyBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgXCJncmFtbWFyIHJlY29yZGluZyBwaGFzZVwiIEZvciBtb3JlIGluZm8gc2VlOlxcblxcdCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG11dGFiaWxpdHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBlcnJvciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHBhcnNpbmcgRFNMXG4gICAgb3B0aW9uSW50ZXJuYWxSZWNvcmQoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZFByb2QuY2FsbCh0aGlzLCBPcHRpb24sIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9XG4gICAgYXRMZWFzdE9uZUludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgbWFueUludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uLCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfVxuICAgIG1hbnlTZXBGaXJzdEludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgb3JJbnRlcm5hbFJlY29yZChhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRPclByb2QuY2FsbCh0aGlzLCBhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKTtcbiAgICB9XG4gICAgc3VicnVsZUludGVybmFsUmVjb3JkKHJ1bGVUb0NhbGwsIG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICAgICAgaWYgKCFydWxlVG9DYWxsIHx8IGhhcyhydWxlVG9DYWxsLCBcInJ1bGVOYW1lXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYDxTVUJSVUxFJHtnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSl9PiBhcmd1bWVudCBpcyBpbnZhbGlkYCArXG4gICAgICAgICAgICAgICAgYCBleHBlY3RpbmcgYSBQYXJzZXIgbWV0aG9kIHJlZmVyZW5jZSBidXQgZ290OiA8JHtKU09OLnN0cmluZ2lmeShydWxlVG9DYWxsKX0+YCArXG4gICAgICAgICAgICAgICAgYFxcbiBpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IDwke3RoaXMucmVjb3JkaW5nUHJvZFN0YWNrWzBdLm5hbWV9PmApO1xuICAgICAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlVG9DYWxsLnJ1bGVOYW1lO1xuICAgICAgICBjb25zdCBuZXdOb25lVGVybWluYWwgPSBuZXcgTm9uVGVybWluYWwoe1xuICAgICAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxOYW1lOiBydWxlTmFtZSxcbiAgICAgICAgICAgIGxhYmVsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuTEFCRUwsXG4gICAgICAgICAgICAvLyBUaGUgcmVzb2x2aW5nIG9mIHRoZSBgcmVmZXJlbmNlZFJ1bGVgIHByb3BlcnR5IHdpbGwgYmUgZG9uZSBvbmNlIGFsbCB0aGUgUnVsZSdzIEdBU1RzIGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICByZWZlcmVuY2VkUnVsZTogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dENzdFxuICAgICAgICAgICAgPyBSRUNPUkRJTkdfUEhBU0VfQ1NUTk9ERVxuICAgICAgICAgICAgOiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG4gICAgfVxuICAgIGNvbnN1bWVJbnRlcm5hbFJlY29yZCh0b2tUeXBlLCBvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgICAgIGlmICghaGFzU2hvcnRLZXlQcm9wZXJ0eSh0b2tUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYDxDT05TVU1FJHtnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSl9PiBhcmd1bWVudCBpcyBpbnZhbGlkYCArXG4gICAgICAgICAgICAgICAgYCBleHBlY3RpbmcgYSBUb2tlblR5cGUgcmVmZXJlbmNlIGJ1dCBnb3Q6IDwke0pTT04uc3RyaW5naWZ5KHRva1R5cGUpfT5gICtcbiAgICAgICAgICAgICAgICBgXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPCR7dGhpcy5yZWNvcmRpbmdQcm9kU3RhY2tbMF0ubmFtZX0+YCk7XG4gICAgICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgICAgICBjb25zdCBuZXdOb25lVGVybWluYWwgPSBuZXcgVGVybWluYWwoe1xuICAgICAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgdGVybWluYWxUeXBlOiB0b2tUeXBlLFxuICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5MQUJFTCxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdOb25lVGVybWluYWwpO1xuICAgICAgICByZXR1cm4gUkVDT1JESU5HX1BIQVNFX1RPS0VOO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFByb2QocHJvZENvbnN0cnVjdG9yLCBtYWluUHJvZEFyZywgb2NjdXJyZW5jZSwgaGFuZGxlU2VwID0gZmFsc2UpIHtcbiAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgIGNvbnN0IHByZXZQcm9kID0gcGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgY29uc3QgZ3JhbW1hckFjdGlvbiA9IGlzRnVuY3Rpb24obWFpblByb2RBcmcpID8gbWFpblByb2RBcmcgOiBtYWluUHJvZEFyZy5ERUY7XG4gICAgY29uc3QgbmV3UHJvZCA9IG5ldyBwcm9kQ29uc3RydWN0b3IoeyBkZWZpbml0aW9uOiBbXSwgaWR4OiBvY2N1cnJlbmNlIH0pO1xuICAgIGlmIChoYW5kbGVTZXApIHtcbiAgICAgICAgbmV3UHJvZC5zZXBhcmF0b3IgPSBtYWluUHJvZEFyZy5TRVA7XG4gICAgfVxuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTUFYX0xPT0tBSEVBRFwiKSkge1xuICAgICAgICBuZXdQcm9kLm1heExvb2thaGVhZCA9IG1haW5Qcm9kQXJnLk1BWF9MT09LQUhFQUQ7XG4gICAgfVxuICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3UHJvZCk7XG4gICAgZ3JhbW1hckFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdQcm9kKTtcbiAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gUkVDT1JESU5HX05VTExfT0JKRUNUO1xufVxuZnVuY3Rpb24gcmVjb3JkT3JQcm9kKG1haW5Qcm9kQXJnLCBvY2N1cnJlbmNlKSB7XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICBjb25zdCBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgIC8vIE9ubHkgYW4gYXJyYXkgb2YgYWx0ZXJuYXRpdmVzXG4gICAgY29uc3QgaGFzT3B0aW9ucyA9IGlzQXJyYXkobWFpblByb2RBcmcpID09PSBmYWxzZTtcbiAgICBjb25zdCBhbHRzID0gaGFzT3B0aW9ucyA9PT0gZmFsc2UgPyBtYWluUHJvZEFyZyA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICBjb25zdCBuZXdPclByb2QgPSBuZXcgQWx0ZXJuYXRpb24oe1xuICAgICAgICBkZWZpbml0aW9uOiBbXSxcbiAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICBpZ25vcmVBbWJpZ3VpdGllczogaGFzT3B0aW9ucyAmJiBtYWluUHJvZEFyZy5JR05PUkVfQU1CSUdVSVRJRVMgPT09IHRydWUsXG4gICAgfSk7XG4gICAgaWYgKGhhcyhtYWluUHJvZEFyZywgXCJNQVhfTE9PS0FIRUFEXCIpKSB7XG4gICAgICAgIG5ld09yUHJvZC5tYXhMb29rYWhlYWQgPSBtYWluUHJvZEFyZy5NQVhfTE9PS0FIRUFEO1xuICAgIH1cbiAgICBjb25zdCBoYXNQcmVkaWNhdGVzID0gc29tZShhbHRzLCAoY3VyckFsdCkgPT4gaXNGdW5jdGlvbihjdXJyQWx0LkdBVEUpKTtcbiAgICBuZXdPclByb2QuaGFzUHJlZGljYXRlcyA9IGhhc1ByZWRpY2F0ZXM7XG4gICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld09yUHJvZCk7XG4gICAgZm9yRWFjaChhbHRzLCAoY3VyckFsdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyQWx0RmxhdCA9IG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IFtdIH0pO1xuICAgICAgICBuZXdPclByb2QuZGVmaW5pdGlvbi5wdXNoKGN1cnJBbHRGbGF0KTtcbiAgICAgICAgaWYgKGhhcyhjdXJyQWx0LCBcIklHTk9SRV9BTUJJR1VJVElFU1wiKSkge1xuICAgICAgICAgICAgY3VyckFsdEZsYXQuaWdub3JlQW1iaWd1aXRpZXMgPSBjdXJyQWx0LklHTk9SRV9BTUJJR1VJVElFUzsgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICB9XG4gICAgICAgIC8vICoqaW1wbGljaXQqKiBpZ25vcmVBbWJpZ3VpdGllcyBkdWUgdG8gdXNhZ2Ugb2YgZ2F0ZVxuICAgICAgICBlbHNlIGlmIChoYXMoY3VyckFsdCwgXCJHQVRFXCIpKSB7XG4gICAgICAgICAgICBjdXJyQWx0RmxhdC5pZ25vcmVBbWJpZ3VpdGllcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGN1cnJBbHQuQUxULmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG59XG5mdW5jdGlvbiBnZXRJZHhTdWZmaXgoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA9PT0gMCA/IFwiXCIgOiBgJHtpZHh9YDtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGhvZElkeElzVmFsaWQoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDAgfHwgaWR4ID4gTUFYX01FVEhPRF9JRFgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRoZSBzdGFjayB0cmFjZSB3aWxsIGNvbnRhaW4gYWxsIHRoZSBuZWVkZWQgZGV0YWlsc1xuICAgICAgICBgSW52YWxpZCBEU0wgTWV0aG9kIGlkeCB2YWx1ZTogPCR7aWR4fT5cXG5cXHRgICtcbiAgICAgICAgICAgIGBJZHggdmFsdWUgbXVzdCBiZSBhIG5vbmUgbmVnYXRpdmUgdmFsdWUgc21hbGxlciB0aGFuICR7TUFYX01FVEhPRF9JRFggKyAxfWApO1xuICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfcmVjb3JkZXIuanMubWFwIiwiaW1wb3J0IHsgaGFzIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgdGltZXIgfSBmcm9tIFwiQGNoZXZyb3RhaW4vdXRpbHNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQZXJmb3JtYW5jZVRyYWNlciB7XG4gICAgaW5pdFBlcmZvcm1hbmNlVHJhY2VyKGNvbmZpZykge1xuICAgICAgICBpZiAoaGFzKGNvbmZpZywgXCJ0cmFjZUluaXRQZXJmXCIpKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyVHJhY2VJbml0UGVyZiA9IGNvbmZpZy50cmFjZUluaXRQZXJmO1xuICAgICAgICAgICAgY29uc3QgdHJhY2VJc051bWJlciA9IHR5cGVvZiB1c2VyVHJhY2VJbml0UGVyZiA9PT0gXCJudW1iZXJcIjtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZlxuICAgICAgICAgICAgICAgIDogSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cmFjZUlzTnVtYmVyXG4gICAgICAgICAgICAgICAgPyB1c2VyVHJhY2VJbml0UGVyZiA+IDBcbiAgICAgICAgICAgICAgICA6IHVzZXJUcmFjZUluaXRQZXJmOyAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0UGVyZiA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRy50cmFjZUluaXRQZXJmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50ID0gLTE7XG4gICAgfVxuICAgIFRSQUNFX0lOSVQocGhhc2VEZXNjLCBwaGFzZUltcGwpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBvcHRpbWl6ZSB0aGlzIHVzaW5nIE5PT1AgcGF0dGVybiBiZWNhdXNlXG4gICAgICAgIC8vIEl0IGlzIG5vdCBjYWxsZWQgaW4gYSBob3Qgc3BvdC4uLlxuICAgICAgICBpZiAodGhpcy50cmFjZUluaXRQZXJmID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCsrO1xuICAgICAgICAgICAgY29uc3QgaW5kZW50ID0gbmV3IEFycmF5KHRoaXMudHJhY2VJbml0SW5kZW50ICsgMSkuam9pbihcIlxcdFwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9LS0+IDwke3BoYXNlRGVzY30+YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRpbWUsIHZhbHVlIH0gPSB0aW1lcihwaGFzZUltcGwpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBEaWZmaWN1bHQgdG8gcmVwcm9kdWNlIHNwZWNpZmljIHBlcmZvcm1hbmNlIGJlaGF2aW9yICg+MTBtcykgaW4gdGVzdHMgKi9cbiAgICAgICAgICAgIGNvbnN0IHRyYWNlTWV0aG9kID0gdGltZSA+IDEwID8gY29uc29sZS53YXJuIDogY29uc29sZS5sb2c7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFjZUluaXRJbmRlbnQgPCB0aGlzLnRyYWNlSW5pdE1heElkZW50KSB7XG4gICAgICAgICAgICAgICAgdHJhY2VNZXRob2QoYCR7aW5kZW50fTwtLSA8JHtwaGFzZURlc2N9PiB0aW1lOiAke3RpbWV9bXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50LS07XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGhhc2VJbXBsKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJmX3RyYWNlci5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gYXBwbHlNaXhpbnMoZGVyaXZlZEN0b3IsIGJhc2VDdG9ycykge1xuICAgIGJhc2VDdG9ycy5mb3JFYWNoKChiYXNlQ3RvcikgPT4ge1xuICAgICAgICBjb25zdCBiYXNlUHJvdG8gPSBiYXNlQ3Rvci5wcm90b3R5cGU7XG4gICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2VQcm90bykuZm9yRWFjaCgocHJvcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wTmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmFzZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlUHJvdG8sIHByb3BOYW1lKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBBY2Nlc3NvcnNcbiAgICAgICAgICAgIGlmIChiYXNlUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgICAgICAgICAgICAoYmFzZVByb3BEZXNjcmlwdG9yLmdldCB8fCBiYXNlUHJvcERlc2NyaXB0b3Iuc2V0KSkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkQ3Rvci5wcm90b3R5cGUsIHByb3BOYW1lLCBiYXNlUHJvcERlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlW3Byb3BOYW1lXSA9IGJhc2VDdG9yLnByb3RvdHlwZVtwcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwbHlfbWl4aW5zLmpzLm1hcCIsImltcG9ydCB7IGNsb25lLCBmb3JFYWNoLCBoYXMsIGlzRW1wdHksIG1hcCwgdmFsdWVzIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgdG9GYXN0UHJvcGVydGllcyB9IGZyb20gXCJAY2hldnJvdGFpbi91dGlsc1wiO1xuaW1wb3J0IHsgY29tcHV0ZUFsbFByb2RzRm9sbG93cyB9IGZyb20gXCIuLi9ncmFtbWFyL2ZvbGxvdy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlVG9rZW5JbnN0YW5jZSwgRU9GIH0gZnJvbSBcIi4uLy4uL3NjYW4vdG9rZW5zX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLCBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciwgfSBmcm9tIFwiLi4vZXJyb3JzX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgcmVzb2x2ZUdyYW1tYXIsIHZhbGlkYXRlR3JhbW1hciwgfSBmcm9tIFwiLi4vZ3JhbW1hci9nYXN0L2dhc3RfcmVzb2x2ZXJfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBSZWNvdmVyYWJsZSB9IGZyb20gXCIuL3RyYWl0cy9yZWNvdmVyYWJsZS5qc1wiO1xuaW1wb3J0IHsgTG9va3NBaGVhZCB9IGZyb20gXCIuL3RyYWl0cy9sb29rc2FoZWFkLmpzXCI7XG5pbXBvcnQgeyBUcmVlQnVpbGRlciB9IGZyb20gXCIuL3RyYWl0cy90cmVlX2J1aWxkZXIuanNcIjtcbmltcG9ydCB7IExleGVyQWRhcHRlciB9IGZyb20gXCIuL3RyYWl0cy9sZXhlcl9hZGFwdGVyLmpzXCI7XG5pbXBvcnQgeyBSZWNvZ25pemVyQXBpIH0gZnJvbSBcIi4vdHJhaXRzL3JlY29nbml6ZXJfYXBpLmpzXCI7XG5pbXBvcnQgeyBSZWNvZ25pemVyRW5naW5lIH0gZnJvbSBcIi4vdHJhaXRzL3JlY29nbml6ZXJfZW5naW5lLmpzXCI7XG5pbXBvcnQgeyBFcnJvckhhbmRsZXIgfSBmcm9tIFwiLi90cmFpdHMvZXJyb3JfaGFuZGxlci5qc1wiO1xuaW1wb3J0IHsgQ29udGVudEFzc2lzdCB9IGZyb20gXCIuL3RyYWl0cy9jb250ZXh0X2Fzc2lzdC5qc1wiO1xuaW1wb3J0IHsgR2FzdFJlY29yZGVyIH0gZnJvbSBcIi4vdHJhaXRzL2dhc3RfcmVjb3JkZXIuanNcIjtcbmltcG9ydCB7IFBlcmZvcm1hbmNlVHJhY2VyIH0gZnJvbSBcIi4vdHJhaXRzL3BlcmZfdHJhY2VyLmpzXCI7XG5pbXBvcnQgeyBhcHBseU1peGlucyB9IGZyb20gXCIuL3V0aWxzL2FwcGx5X21peGlucy5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVMb29rYWhlYWQgfSBmcm9tIFwiLi4vZ3JhbW1hci9jaGVja3MuanNcIjtcbmV4cG9ydCBjb25zdCBFTkRfT0ZfRklMRSA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoRU9GLCBcIlwiLCBOYU4sIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbk9iamVjdC5mcmVlemUoRU5EX09GX0ZJTEUpO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUEFSU0VSX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlY292ZXJ5RW5hYmxlZDogZmFsc2UsXG4gICAgbWF4TG9va2FoZWFkOiAzLFxuICAgIGR5bmFtaWNUb2tlbnNFbmFibGVkOiBmYWxzZSxcbiAgICBvdXRwdXRDc3Q6IHRydWUsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLFxuICAgIG5vZGVMb2NhdGlvblRyYWNraW5nOiBcIm5vbmVcIixcbiAgICB0cmFjZUluaXRQZXJmOiBmYWxzZSxcbiAgICBza2lwVmFsaWRhdGlvbnM6IGZhbHNlLFxufSk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SVUxFX0NPTkZJRyA9IE9iamVjdC5mcmVlemUoe1xuICAgIHJlY292ZXJ5VmFsdWVGdW5jOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgcmVzeW5jRW5hYmxlZDogdHJ1ZSxcbn0pO1xuZXhwb3J0IHZhciBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlO1xuKGZ1bmN0aW9uIChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9SVUxFX05BTUVcIl0gPSAwXSA9IFwiSU5WQUxJRF9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUlVMRV9OQU1FXCJdID0gMV0gPSBcIkRVUExJQ0FURV9SVUxFX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIl0gPSAyXSA9IFwiSU5WQUxJRF9SVUxFX09WRVJSSURFXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BST0RVQ1RJT05TXCJdID0gM10gPSBcIkRVUExJQ0FURV9QUk9EVUNUSU9OU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlVOUkVTT0xWRURfU1VCUlVMRV9SRUZcIl0gPSA0XSA9IFwiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkxFRlRfUkVDVVJTSU9OXCJdID0gNV0gPSBcIkxFRlRfUkVDVVJTSU9OXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9ORV9MQVNUX0VNUFRZX0FMVFwiXSA9IDZdID0gXCJOT05FX0xBU1RfRU1QVFlfQUxUXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX0FMVFNcIl0gPSA3XSA9IFwiQU1CSUdVT1VTX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJDT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFXCJdID0gOF0gPSBcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1RPS0VOX05BTUVcIl0gPSA5XSA9IFwiSU5WQUxJRF9UT0tFTl9OQU1FXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTk9fTk9OX0VNUFRZX0xPT0tBSEVBRFwiXSA9IDEwXSA9IFwiTk9fTk9OX0VNUFRZX0xPT0tBSEVBRFwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkFNQklHVU9VU19QUkVGSVhfQUxUU1wiXSA9IDExXSA9IFwiQU1CSUdVT1VTX1BSRUZJWF9BTFRTXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVE9PX01BTllfQUxUU1wiXSA9IDEyXSA9IFwiVE9PX01BTllfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNVU1RPTV9MT09LQUhFQURfVkFMSURBVElPTlwiXSA9IDEzXSA9IFwiQ1VTVE9NX0xPT0tBSEVBRF9WQUxJREFUSU9OXCI7XG59KShQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIHx8IChQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBFTVBUWV9BTFQodmFsdWUgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgICAqICBAZGVwcmVjYXRlZCB1c2UgdGhlICoqaW5zdGFuY2UqKiBtZXRob2Qgd2l0aCB0aGUgc2FtZSBuYW1lIGluc3RlYWRcbiAgICAgKi9cbiAgICBzdGF0aWMgcGVyZm9ybVNlbGZBbmFseXNpcyhwYXJzZXJJbnN0YW5jZSkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSAqKnN0YXRpYyoqIGBwZXJmb3JtU2VsZkFuYWx5c2lzYCBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZC5cIiArXG4gICAgICAgICAgICBcIlxcdFxcblVzZSB0aGUgKippbnN0YW5jZSoqIG1ldGhvZCB3aXRoIHRoZSBzYW1lIG5hbWUgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIHBlcmZvcm1TZWxmQW5hbHlzaXMoKSB7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcInBlcmZvcm1TZWxmQW5hbHlzaXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRlZkVycm9yc01zZ3M7XG4gICAgICAgICAgICB0aGlzLnNlbGZBbmFseXNpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJ0b0Zhc3RQcm9wc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCB0aGlzIHZvb2RvbyBtYWdpYyB0aGUgcGFyc2VyIHdvdWxkIGJlIHgzLXg0IHNsb3dlclxuICAgICAgICAgICAgICAgIC8vIEl0IHNlZW1zIGl0IGlzIGJldHRlciB0byBpbnZva2UgYHRvRmFzdFByb3BlcnRpZXNgICoqYmVmb3JlKipcbiAgICAgICAgICAgICAgICAvLyBBbnkgbWFuaXB1bGF0aW9ucyBvZiB0aGUgYHRoaXNgIG9iamVjdCBkb25lIGR1cmluZyB0aGUgcmVjb3JkaW5nIHBoYXNlLlxuICAgICAgICAgICAgICAgIHRvRmFzdFByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkdyYW1tYXIgUmVjb3JkaW5nXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCdWlsZGluZyB0aGUgR0FTVFxuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIChjdXJyUnVsZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRSdWxlID0gdGhpc1tjdXJyUnVsZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxHcmFtbWFyQWN0aW9uID0gd3JhcHBlZFJ1bGVbXCJvcmlnaW5hbEdyYW1tYXJBY3Rpb25cIl07XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVjb3JkZWRSdWxlR2FzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgJHtjdXJyUnVsZU5hbWV9IFJ1bGVgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWRSdWxlR2FzdCA9IHRoaXMudG9wTGV2ZWxSdWxlUmVjb3JkKGN1cnJSdWxlTmFtZSwgb3JpZ2luYWxHcmFtbWFyQWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZVtjdXJyUnVsZU5hbWVdID0gcmVjb3JkZWRSdWxlR2FzdDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2FibGVSZWNvcmRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlckVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBSZXNvbHZpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVyRXJyb3JzID0gcmVzb2x2ZUdyYW1tYXIoe1xuICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycyA9IHRoaXMuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQocmVzb2x2ZXJFcnJvcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFZhbGlkYXRpb25zXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWRkaXRpb25hbCBncmFtbWFyIHZhbGlkYXRpb25zIElGRiBubyByZXNvbHZpbmcgZXJyb3JzIGhhdmUgb2NjdXJyZWQuXG4gICAgICAgICAgICAgICAgLy8gYXMgdW5yZXNvbHZlZCBncmFtbWFyIG1heSBsZWFkIHRvIHVuaGFuZGxlZCBydW50aW1lIGV4Y2VwdGlvbnMgaW4gdGhlIGZvbGxvdyB1cCB2YWxpZGF0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShyZXNvbHZlckVycm9ycykgJiYgdGhpcy5za2lwVmFsaWRhdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0ZUdyYW1tYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHZhbHVlcyh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IHZhbHVlcyh0aGlzLnRva2Vuc01hcCksXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJNc2dQcm92aWRlcjogZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvb2thaGVhZFZhbGlkYXRpb25FcnJvcnMgPSB2YWxpZGF0ZUxvb2thaGVhZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWRTdHJhdGVneTogdGhpcy5sb29rYWhlYWRTdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzOiB2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGVzOiB2YWx1ZXModGhpcy50b2tlbnNNYXApLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IGNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycyA9IHRoaXMuZGVmaW5pdGlvbkVycm9ycy5jb25jYXQodmFsaWRhdGlvbkVycm9ycywgbG9va2FoZWFkVmFsaWRhdGlvbkVycm9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyB0aGlzIGFuYWx5c2lzIG1heSBmYWlsIGlmIHRoZSBncmFtbWFyIGlzIG5vdCBwZXJmZWN0bHkgdmFsaWRcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHRoaXMuZGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0cyBvZiB0aGVzZSBjb21wdXRhdGlvbnMgYXJlIG5vdCBuZWVkZWQgdW5sZXNzIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcImNvbXB1dGVBbGxQcm9kc0ZvbGxvd3NcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRm9sbG93cyA9IGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzeW5jRm9sbG93cyA9IGFsbEZvbGxvd3M7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJDb21wdXRlTG9va2FoZWFkRnVuY3Rpb25zXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5sb29rYWhlYWRTdHJhdGVneSkuaW5pdGlhbGl6ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzOiB2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZUNvbXB1dGVMb29rYWhlYWRGdW5jdGlvbnModmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghUGFyc2VyLkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HICYmXG4gICAgICAgICAgICAgICAgIWlzRW1wdHkodGhpcy5kZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIGRlZkVycm9yc01zZ3MgPSBtYXAodGhpcy5kZWZpbml0aW9uRXJyb3JzLCAoZGVmRXJyb3IpID0+IGRlZkVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyc2VyIERlZmluaXRpb24gRXJyb3JzIGRldGVjdGVkOlxcbiAke2RlZkVycm9yc01zZ3Muam9pbihcIlxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5zZWxmQW5hbHlzaXNEb25lID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGF0LmluaXRFcnJvckhhbmRsZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0TGV4ZXJBZGFwdGVyKCk7XG4gICAgICAgIHRoYXQuaW5pdExvb2tzQWhlYWQoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UmVjb2duaXplckVuZ2luZSh0b2tlblZvY2FidWxhcnksIGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdFJlY292ZXJhYmxlKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdFRyZWVCdWlsZGVyKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdENvbnRlbnRBc3Npc3QoKTtcbiAgICAgICAgdGhhdC5pbml0R2FzdFJlY29yZGVyKGNvbmZpZyk7XG4gICAgICAgIHRoYXQuaW5pdFBlcmZvcm1hbmNlVHJhY2VyKGNvbmZpZyk7XG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcImlnbm9yZWRJc3N1ZXNcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSA8aWdub3JlZElzc3Vlcz4gSVBhcnNlckNvbmZpZyBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLlxcblxcdFwiICtcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSB1c2UgdGhlIDxJR05PUkVfQU1CSUdVSVRJRVM+IGZsYWcgb24gdGhlIHJlbGV2YW50IERTTCBtZXRob2QgaW5zdGVhZC5cXG5cXHRcIiArXG4gICAgICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0lHTk9SSU5HX0FNQklHVUlUSUVTXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiRm9yIGZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5za2lwVmFsaWRhdGlvbnMgPSBoYXMoY29uZmlnLCBcInNraXBWYWxpZGF0aW9uc1wiKVxuICAgICAgICAgICAgPyBjb25maWcuc2tpcFZhbGlkYXRpb25zIC8vIGNhc3RpbmcgYXNzdW1lcyB0aGUgZW5kIHVzZXIgcGFzc2luZyB0aGUgY29ycmVjdCB0eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5za2lwVmFsaWRhdGlvbnM7XG4gICAgfVxufVxuLy8gU2V0IHRoaXMgZmxhZyB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IHRoZSBQYXJzZXIgdG8gdGhyb3cgZXJyb3Igd2hlbiBwcm9ibGVtcyBpbiBpdCdzIGRlZmluaXRpb24gYXJlIGRldGVjdGVkLlxuLy8gKG5vcm1hbGx5IGR1cmluZyB0aGUgcGFyc2VyJ3MgY29uc3RydWN0b3IpLlxuLy8gVGhpcyBpcyBhIGRlc2lnbiB0aW1lIGZsYWcsIGl0IHdpbGwgbm90IGFmZmVjdCB0aGUgcnVudGltZSBlcnJvciBoYW5kbGluZyBvZiB0aGUgcGFyc2VyLCBqdXN0IGRlc2lnbiB0aW1lIGVycm9ycyxcbi8vIGZvciBleGFtcGxlOiBkdXBsaWNhdGUgcnVsZSBuYW1lcywgcmVmZXJlbmNpbmcgYW4gdW5yZXNvbHZlZCBzdWJydWxlLCBlY3QuLi5cbi8vIFRoaXMgZmxhZyBzaG91bGQgbm90IGJlIGVuYWJsZWQgZHVyaW5nIG5vcm1hbCB1c2FnZSwgaXQgaXMgdXNlZCBpbiBzcGVjaWFsIHNpdHVhdGlvbnMsIGZvciBleGFtcGxlIHdoZW5cbi8vIG5lZWRpbmcgdG8gZGlzcGxheSB0aGUgcGFyc2VyIGRlZmluaXRpb24gZXJyb3JzIGluIHNvbWUgR1VJKG9ubGluZSBwbGF5Z3JvdW5kKS5cblBhcnNlci5ERUZFUl9ERUZJTklUSU9OX0VSUk9SU19IQU5ETElORyA9IGZhbHNlO1xuYXBwbHlNaXhpbnMoUGFyc2VyLCBbXG4gICAgUmVjb3ZlcmFibGUsXG4gICAgTG9va3NBaGVhZCxcbiAgICBUcmVlQnVpbGRlcixcbiAgICBMZXhlckFkYXB0ZXIsXG4gICAgUmVjb2duaXplckVuZ2luZSxcbiAgICBSZWNvZ25pemVyQXBpLFxuICAgIEVycm9ySGFuZGxlcixcbiAgICBDb250ZW50QXNzaXN0LFxuICAgIEdhc3RSZWNvcmRlcixcbiAgICBQZXJmb3JtYW5jZVRyYWNlcixcbl0pO1xuZXhwb3J0IGNsYXNzIENzdFBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5Wb2NhYnVsYXJ5LCBjb25maWcgPSBERUZBVUxUX1BBUlNFUl9DT05GSUcpIHtcbiAgICAgICAgY29uc3QgY29uZmlnQ2xvbmUgPSBjbG9uZShjb25maWcpO1xuICAgICAgICBjb25maWdDbG9uZS5vdXRwdXRDc3QgPSB0cnVlO1xuICAgICAgICBzdXBlcih0b2tlblZvY2FidWxhcnksIGNvbmZpZ0Nsb25lKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRW1iZWRkZWRBY3Rpb25zUGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlblZvY2FidWxhcnksIGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRykge1xuICAgICAgICBjb25zdCBjb25maWdDbG9uZSA9IGNsb25lKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0Nsb25lLm91dHB1dENzdCA9IGZhbHNlO1xuICAgICAgICBzdXBlcih0b2tlblZvY2FidWxhcnksIGNvbmZpZ0Nsb25lKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZXIuanMubWFwIiwiaW1wb3J0IHsgR0FzdFZpc2l0b3IsIE5vblRlcm1pbmFsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmltcG9ydCB7IGFzc2lnbiwgZmxhdHRlbiwgZ3JvdXBCeSwgbWFwLCBzb21lLCB2YWx1ZXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRNb2RlbChwcm9kdWN0aW9ucykge1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IG5ldyBDc3ROb2RlRGVmaW5pdGlvbkdlbmVyYXRvcigpO1xuICAgIGNvbnN0IGFsbFJ1bGVzID0gdmFsdWVzKHByb2R1Y3Rpb25zKTtcbiAgICByZXR1cm4gbWFwKGFsbFJ1bGVzLCAocnVsZSkgPT4gZ2VuZXJhdG9yLnZpc2l0UnVsZShydWxlKSk7XG59XG5jbGFzcyBDc3ROb2RlRGVmaW5pdGlvbkdlbmVyYXRvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICB2aXNpdFJ1bGUobm9kZSkge1xuICAgICAgICBjb25zdCByYXdFbGVtZW50cyA9IHRoaXMudmlzaXRFYWNoKG5vZGUuZGVmaW5pdGlvbik7XG4gICAgICAgIGNvbnN0IGdyb3VwZWQgPSBncm91cEJ5KHJhd0VsZW1lbnRzLCAoZWwpID0+IGVsLnByb3BlcnR5TmFtZSk7XG4gICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBtYXAoZ3JvdXBlZCwgKGdyb3VwLCBwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE51bGxhYmxlID0gIXNvbWUoZ3JvdXAsIChlbCkgPT4gIWVsLmNhbkJlTnVsbCk7XG4gICAgICAgICAgICAvLyBJbiBhbiBhbHRlcm5hdGlvbiB3aXRoIGEgbGFiZWwgYSBwcm9wZXJ0eSBuYW1lIGNhbiBoYXZlXG4gICAgICAgICAgICAvLyBtdWx0aXBsZSB0eXBlcy5cbiAgICAgICAgICAgIGxldCBwcm9wZXJ0eVR5cGUgPSBncm91cFswXS50eXBlO1xuICAgICAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eVR5cGUgPSBtYXAoZ3JvdXAsIChnKSA9PiBnLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcGVydHlUeXBlLFxuICAgICAgICAgICAgICAgIG9wdGlvbmFsOiBhbGxOdWxsYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbm9kZS5uYW1lLFxuICAgICAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmlzaXRBbHRlcm5hdGl2ZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaEFuZE92ZXJyaWRlV2l0aChub2RlLmRlZmluaXRpb24sIHsgY2FuQmVOdWxsOiB0cnVlIH0pO1xuICAgIH1cbiAgICB2aXNpdE9wdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaEFuZE92ZXJyaWRlV2l0aChub2RlLmRlZmluaXRpb24sIHsgY2FuQmVOdWxsOiB0cnVlIH0pO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEVhY2hBbmRPdmVycmlkZVdpdGgobm9kZS5kZWZpbml0aW9uLCB7IGNhbkJlTnVsbDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFYWNoKG5vZGUuZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEVhY2gobm9kZS5kZWZpbml0aW9uKS5jb25jYXQoe1xuICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBub2RlLnNlcGFyYXRvci5uYW1lLFxuICAgICAgICAgICAgY2FuQmVOdWxsOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogZ2V0VHlwZShub2RlLnNlcGFyYXRvciksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFYWNoQW5kT3ZlcnJpZGVXaXRoKG5vZGUuZGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgY2FuQmVOdWxsOiB0cnVlLFxuICAgICAgICB9KS5jb25jYXQoe1xuICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBub2RlLnNlcGFyYXRvci5uYW1lLFxuICAgICAgICAgICAgY2FuQmVOdWxsOiB0cnVlLFxuICAgICAgICAgICAgdHlwZTogZ2V0VHlwZShub2RlLnNlcGFyYXRvciksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdEFsdGVybmF0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFYWNoQW5kT3ZlcnJpZGVXaXRoKG5vZGUuZGVmaW5pdGlvbiwgeyBjYW5CZU51bGw6IHRydWUgfSk7XG4gICAgfVxuICAgIHZpc2l0VGVybWluYWwobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogbm9kZS5sYWJlbCB8fCBub2RlLnRlcm1pbmFsVHlwZS5uYW1lLFxuICAgICAgICAgICAgICAgIGNhbkJlTnVsbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0VHlwZShub2RlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZpc2l0Tm9uVGVybWluYWwobm9kZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogbm9kZS5sYWJlbCB8fCBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgICAgICBjYW5CZU51bGw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFR5cGUobm9kZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cbiAgICB2aXNpdEVhY2hBbmRPdmVycmlkZVdpdGgoZGVmaW5pdGlvbiwgb3ZlcnJpZGUpIHtcbiAgICAgICAgcmV0dXJuIG1hcCh0aGlzLnZpc2l0RWFjaChkZWZpbml0aW9uKSwgKGRlZmluaXRpb24pID0+IGFzc2lnbih7fSwgZGVmaW5pdGlvbiwgb3ZlcnJpZGUpKTtcbiAgICB9XG4gICAgdmlzaXRFYWNoKGRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4obWFwKGRlZmluaXRpb24sIChkZWZpbml0aW9uKSA9PiB0aGlzLnZpc2l0KGRlZmluaXRpb24pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VHlwZShwcm9kdWN0aW9uKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2luZDogXCJydWxlXCIsXG4gICAgICAgICAgICBuYW1lOiBwcm9kdWN0aW9uLnJlZmVyZW5jZWRSdWxlLm5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IGtpbmQ6IFwidG9rZW5cIiB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiaW1wb3J0IHsgYnVpbGRNb2RlbCB9IGZyb20gXCIuL21vZGVsLmpzXCI7XG5pbXBvcnQgeyBnZW5EdHMgfSBmcm9tIFwiLi9nZW5lcmF0ZS5qc1wiO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW5jbHVkZVZpc2l0b3JJbnRlcmZhY2U6IHRydWUsXG4gICAgdmlzaXRvckludGVyZmFjZU5hbWU6IFwiSUNzdE5vZGVWaXNpdG9yXCIsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ3N0RHRzKHByb2R1Y3Rpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWZmZWN0aXZlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBjb25zdCBtb2RlbCA9IGJ1aWxkTW9kZWwocHJvZHVjdGlvbnMpO1xuICAgIHJldHVybiBnZW5EdHMobW9kZWwsIGVmZmVjdGl2ZU9wdGlvbnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsIi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlIC0gdHJpY2t5IHRvIGltcG9ydCBzb21lIHRoaW5ncyBmcm9tIHRoaXMgbW9kdWxlIGR1cmluZyB0ZXN0aW5nICovXG4vLyBzZW1hbnRpYyB2ZXJzaW9uXG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuZXhwb3J0IHsgQ3N0UGFyc2VyLCBFbWJlZGRlZEFjdGlvbnNQYXJzZXIsIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIEVNUFRZX0FMVCwgfSBmcm9tIFwiLi9wYXJzZS9wYXJzZXIvcGFyc2VyLmpzXCI7XG5leHBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4vc2Nhbi9sZXhlcl9wdWJsaWMuanNcIjtcbi8vIFRva2VucyB1dGlsaXRpZXNcbmV4cG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YsIHRva2VuTGFiZWwsIHRva2VuTWF0Y2hlciwgdG9rZW5OYW1lLCB9IGZyb20gXCIuL3NjYW4vdG9rZW5zX3B1YmxpYy5qc1wiO1xuLy8gTG9va2FoZWFkXG5leHBvcnQgeyBnZXRMb29rYWhlYWRQYXRocyB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzXCI7XG5leHBvcnQgeyBMTGtMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvbGxrX2xvb2thaGVhZC5qc1wiO1xuLy8gT3RoZXIgVXRpbGl0aWVzXG5leHBvcnQgeyBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuL3BhcnNlL2Vycm9yc19wdWJsaWMuanNcIjtcbmV4cG9ydCB7IEVhcmx5RXhpdEV4Y2VwdGlvbiwgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiwgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uLCBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiwgTm9WaWFibGVBbHRFeGNlcHRpb24sIH0gZnJvbSBcIi4vcGFyc2UvZXhjZXB0aW9uc19wdWJsaWMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWMuanNcIjtcbi8vIGdyYW1tYXIgcmVmbGVjdGlvbiBBUElcbmV4cG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuLy8gR0FTVCBVdGlsaXRpZXNcbmV4cG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIsIHNlcmlhbGl6ZVByb2R1Y3Rpb24sIEdBc3RWaXNpdG9yLCB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG5leHBvcnQgeyBnZW5lcmF0ZUNzdER0cyB9IGZyb20gXCJAY2hldnJvdGFpbi9jc3QtZHRzLWdlblwiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBjbGVhckNhY2hlIGZ1bmN0aW9uIHdhcyAnc29mdCcgcmVtb3ZlZCBmcm9tIHRoZSBDaGV2cm90YWluIEFQSS5cIiArXG4gICAgICAgIFwiXFxuXFx0IEl0IHBlcmZvcm1zIG5vIGFjdGlvbiBvdGhlciB0aGFuIHByaW50aW5nIHRoaXMgbWVzc2FnZS5cIiArXG4gICAgICAgIFwiXFxuXFx0IFBsZWFzZSBhdm9pZCB1c2luZyBpdCBhcyBpdCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXCIpO1xufVxuZXhwb3J0IHsgY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlIH0gZnJvbSBcIi4vZGlhZ3JhbXMvcmVuZGVyX3B1YmxpYy5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBQYXJzZXIgY2xhc3MgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIENzdFBhcnNlciBvciBFbWJlZGRlZEFjdGlvbnNQYXJzZXIgaW5zdGVhZC5cXHRcXG5cIiArXG4gICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzctMC0wXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwLmpzXCI7XG5pbXBvcnQgZmlsdGVyIGZyb20gXCJsb2Rhc2gtZXMvZmlsdGVyLmpzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbiwgVGVybWluYWwsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB9IGZyb20gXCJjaGV2cm90YWluXCI7XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBVE5LZXkocnVsZSwgdHlwZSwgb2NjdXJyZW5jZSkge1xuICAgIHJldHVybiBgJHtydWxlLm5hbWV9XyR7dHlwZX1fJHtvY2N1cnJlbmNlfWA7XG59XG5leHBvcnQgY29uc3QgQVROX0lOVkFMSURfVFlQRSA9IDA7XG5leHBvcnQgY29uc3QgQVROX0JBU0lDID0gMTtcbmV4cG9ydCBjb25zdCBBVE5fUlVMRV9TVEFSVCA9IDI7XG5leHBvcnQgY29uc3QgQVROX1BMVVNfQkxPQ0tfU1RBUlQgPSA0O1xuZXhwb3J0IGNvbnN0IEFUTl9TVEFSX0JMT0NLX1NUQVJUID0gNTtcbi8vIEN1cnJlbnRseSB1bnVzZWQgYXMgdGhlIEFUTiBpcyBub3QgdXNlZCBmb3IgbGV4aW5nXG5leHBvcnQgY29uc3QgQVROX1RPS0VOX1NUQVJUID0gNjtcbmV4cG9ydCBjb25zdCBBVE5fUlVMRV9TVE9QID0gNztcbmV4cG9ydCBjb25zdCBBVE5fQkxPQ0tfRU5EID0gODtcbmV4cG9ydCBjb25zdCBBVE5fU1RBUl9MT09QX0JBQ0sgPSA5O1xuZXhwb3J0IGNvbnN0IEFUTl9TVEFSX0xPT1BfRU5UUlkgPSAxMDtcbmV4cG9ydCBjb25zdCBBVE5fUExVU19MT09QX0JBQ0sgPSAxMTtcbmV4cG9ydCBjb25zdCBBVE5fTE9PUF9FTkQgPSAxMjtcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB9XG4gICAgaXNFcHNpbG9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF0b21UcmFuc2l0aW9uIGV4dGVuZHMgQWJzdHJhY3RUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHRva2VuVHlwZSkge1xuICAgICAgICBzdXBlcih0YXJnZXQpO1xuICAgICAgICB0aGlzLnRva2VuVHlwZSA9IHRva2VuVHlwZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXBzaWxvblRyYW5zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICBzdXBlcih0YXJnZXQpO1xuICAgIH1cbiAgICBpc0Vwc2lsb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSdWxlVHJhbnNpdGlvbiBleHRlbmRzIEFic3RyYWN0VHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IocnVsZVN0YXJ0LCBydWxlLCBmb2xsb3dTdGF0ZSkge1xuICAgICAgICBzdXBlcihydWxlU3RhcnQpO1xuICAgICAgICB0aGlzLnJ1bGUgPSBydWxlO1xuICAgICAgICB0aGlzLmZvbGxvd1N0YXRlID0gZm9sbG93U3RhdGU7XG4gICAgfVxuICAgIGlzRXBzaWxvbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFUTihydWxlcykge1xuICAgIGNvbnN0IGF0biA9IHtcbiAgICAgICAgZGVjaXNpb25NYXA6IHt9LFxuICAgICAgICBkZWNpc2lvblN0YXRlczogW10sXG4gICAgICAgIHJ1bGVUb1N0YXJ0U3RhdGU6IG5ldyBNYXAoKSxcbiAgICAgICAgcnVsZVRvU3RvcFN0YXRlOiBuZXcgTWFwKCksXG4gICAgICAgIHN0YXRlczogW11cbiAgICB9O1xuICAgIGNyZWF0ZVJ1bGVTdGFydEFuZFN0b3BBVE5TdGF0ZXMoYXRuLCBydWxlcyk7XG4gICAgY29uc3QgcnVsZUxlbmd0aCA9IHJ1bGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJ1bGVMZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNbaV07XG4gICAgICAgIGNvbnN0IHJ1bGVCbG9jayA9IGJsb2NrKGF0biwgcnVsZSwgcnVsZSk7XG4gICAgICAgIGlmIChydWxlQmxvY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRSdWxlSGFuZGxlKGF0biwgcnVsZSwgcnVsZUJsb2NrKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0bjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGVTdGFydEFuZFN0b3BBVE5TdGF0ZXMoYXRuLCBydWxlcykge1xuICAgIGNvbnN0IHJ1bGVMZW5ndGggPSBydWxlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICB0eXBlOiBBVE5fUlVMRV9TVEFSVFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RvcCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICB0eXBlOiBBVE5fUlVMRV9TVE9QXG4gICAgICAgIH0pO1xuICAgICAgICBzdGFydC5zdG9wID0gc3RvcDtcbiAgICAgICAgYXRuLnJ1bGVUb1N0YXJ0U3RhdGUuc2V0KHJ1bGUsIHN0YXJ0KTtcbiAgICAgICAgYXRuLnJ1bGVUb1N0b3BTdGF0ZS5zZXQocnVsZSwgc3RvcCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXRvbShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pIHtcbiAgICBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiB0b2tlblJlZihhdG4sIHJ1bGUsIHByb2R1Y3Rpb24udGVybWluYWxUeXBlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBydWxlUmVmKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gYWx0ZXJuYXRpb24oYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gb3B0aW9uKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiByZXBldGl0aW9uKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gcmVwZXRpdGlvblNlcChhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4gcmVwZXRpdGlvbk1hbmRhdG9yeShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJlcGV0aXRpb25NYW5kYXRvcnlTZXAoYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBibG9jayhhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlcGV0aXRpb24oYXRuLCBydWxlLCByZXBldGl0aW9uKSB7XG4gICAgY29uc3Qgc3RhclN0YXRlID0gbmV3U3RhdGUoYXRuLCBydWxlLCByZXBldGl0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9TVEFSX0JMT0NLX1NUQVJUXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHN0YXJTdGF0ZSk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBzdGFyU3RhdGUsIHJlcGV0aXRpb24sIGJsb2NrKGF0biwgcnVsZSwgcmVwZXRpdGlvbikpO1xuICAgIHJldHVybiBzdGFyKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwgaGFuZGxlKTtcbn1cbmZ1bmN0aW9uIHJlcGV0aXRpb25TZXAoYXRuLCBydWxlLCByZXBldGl0aW9uKSB7XG4gICAgY29uc3Qgc3RhclN0YXRlID0gbmV3U3RhdGUoYXRuLCBydWxlLCByZXBldGl0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9TVEFSX0JMT0NLX1NUQVJUXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHN0YXJTdGF0ZSk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBzdGFyU3RhdGUsIHJlcGV0aXRpb24sIGJsb2NrKGF0biwgcnVsZSwgcmVwZXRpdGlvbikpO1xuICAgIGNvbnN0IHNlcCA9IHRva2VuUmVmKGF0biwgcnVsZSwgcmVwZXRpdGlvbi5zZXBhcmF0b3IsIHJlcGV0aXRpb24pO1xuICAgIHJldHVybiBzdGFyKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwgaGFuZGxlLCBzZXApO1xufVxuZnVuY3Rpb24gcmVwZXRpdGlvbk1hbmRhdG9yeShhdG4sIHJ1bGUsIHJlcGV0aXRpb24pIHtcbiAgICBjb25zdCBwbHVzU3RhdGUgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX1BMVVNfQkxPQ0tfU1RBUlRcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgcGx1c1N0YXRlKTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHBsdXNTdGF0ZSwgcmVwZXRpdGlvbiwgYmxvY2soYXRuLCBydWxlLCByZXBldGl0aW9uKSk7XG4gICAgcmV0dXJuIHBsdXMoYXRuLCBydWxlLCByZXBldGl0aW9uLCBoYW5kbGUpO1xufVxuZnVuY3Rpb24gcmVwZXRpdGlvbk1hbmRhdG9yeVNlcChhdG4sIHJ1bGUsIHJlcGV0aXRpb24pIHtcbiAgICBjb25zdCBwbHVzU3RhdGUgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX1BMVVNfQkxPQ0tfU1RBUlRcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgcGx1c1N0YXRlKTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHBsdXNTdGF0ZSwgcmVwZXRpdGlvbiwgYmxvY2soYXRuLCBydWxlLCByZXBldGl0aW9uKSk7XG4gICAgY29uc3Qgc2VwID0gdG9rZW5SZWYoYXRuLCBydWxlLCByZXBldGl0aW9uLnNlcGFyYXRvciwgcmVwZXRpdGlvbik7XG4gICAgcmV0dXJuIHBsdXMoYXRuLCBydWxlLCByZXBldGl0aW9uLCBoYW5kbGUsIHNlcCk7XG59XG5mdW5jdGlvbiBhbHRlcm5hdGlvbihhdG4sIHJ1bGUsIGFsdGVybmF0aW9uKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIGFsdGVybmF0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBzdGFydCk7XG4gICAgY29uc3QgYWx0cyA9IG1hcChhbHRlcm5hdGlvbi5kZWZpbml0aW9uLCAoZSkgPT4gYXRvbShhdG4sIHJ1bGUsIGUpKTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHN0YXJ0LCBhbHRlcm5hdGlvbiwgLi4uYWx0cyk7XG4gICAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIG9wdGlvbihhdG4sIHJ1bGUsIG9wdGlvbikge1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3U3RhdGUoYXRuLCBydWxlLCBvcHRpb24sIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHN0YXJ0KTtcbiAgICBjb25zdCBoYW5kbGUgPSBtYWtlQWx0cyhhdG4sIHJ1bGUsIHN0YXJ0LCBvcHRpb24sIGJsb2NrKGF0biwgcnVsZSwgb3B0aW9uKSk7XG4gICAgcmV0dXJuIG9wdGlvbmFsKGF0biwgcnVsZSwgb3B0aW9uLCBoYW5kbGUpO1xufVxuZnVuY3Rpb24gYmxvY2soYXRuLCBydWxlLCBibG9jaykge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBmaWx0ZXIobWFwKGJsb2NrLmRlZmluaXRpb24sIChlKSA9PiBhdG9tKGF0biwgcnVsZSwgZSkpLCAoZSkgPT4gZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBpZiAoaGFuZGxlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXNbMF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZUJsb2NrKGF0biwgaGFuZGxlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGx1cyhhdG4sIHJ1bGUsIHBsdXMsIGhhbmRsZSwgc2VwKSB7XG4gICAgY29uc3QgYmxrU3RhcnQgPSBoYW5kbGUubGVmdDtcbiAgICBjb25zdCBibGtFbmQgPSBoYW5kbGUucmlnaHQ7XG4gICAgY29uc3QgbG9vcCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcGx1cywge1xuICAgICAgICB0eXBlOiBBVE5fUExVU19MT09QX0JBQ0tcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgbG9vcCk7XG4gICAgY29uc3QgZW5kID0gbmV3U3RhdGUoYXRuLCBydWxlLCBwbHVzLCB7XG4gICAgICAgIHR5cGU6IEFUTl9MT09QX0VORFxuICAgIH0pO1xuICAgIGJsa1N0YXJ0Lmxvb3BiYWNrID0gbG9vcDtcbiAgICBlbmQubG9vcGJhY2sgPSBsb29wO1xuICAgIGF0bi5kZWNpc2lvbk1hcFtidWlsZEFUTktleShydWxlLCBzZXAgPyAnUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3InIDogJ1JlcGV0aXRpb25NYW5kYXRvcnknLCBwbHVzLmlkeCldID0gbG9vcDtcbiAgICBlcHNpbG9uKGJsa0VuZCwgbG9vcCk7IC8vIGJsb2NrIGNhbiBzZWUgbG9vcCBiYWNrXG4gICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UgaGF2ZSBhIHNlcGFyYXRvciB3ZSBwdXQgdGhlIGV4aXQgdHJhbnNpdGlvbiBhdCBpbmRleCAxIG9yIDBcbiAgICAvLyBUaGlzIGluZmx1ZW5jZXMgdGhlIGNob3NlbiBvcHRpb24gaW4gdGhlIGxvb2thaGVhZCBERkFcbiAgICBpZiAoc2VwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXBzaWxvbihsb29wLCBibGtTdGFydCk7IC8vIGxvb3AgYmFjayB0byBzdGFydFxuICAgICAgICBlcHNpbG9uKGxvb3AsIGVuZCk7IC8vIGV4aXRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVwc2lsb24obG9vcCwgZW5kKTsgLy8gZXhpdFxuICAgICAgICAvLyBsb29wIGJhY2sgdG8gc3RhcnQgd2l0aCBzZXBhcmF0b3JcbiAgICAgICAgZXBzaWxvbihsb29wLCBzZXAubGVmdCk7XG4gICAgICAgIGVwc2lsb24oc2VwLnJpZ2h0LCBibGtTdGFydCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGJsa1N0YXJ0LFxuICAgICAgICByaWdodDogZW5kXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0YXIoYXRuLCBydWxlLCBzdGFyLCBoYW5kbGUsIHNlcCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gaGFuZGxlLmxlZnQ7XG4gICAgY29uc3QgZW5kID0gaGFuZGxlLnJpZ2h0O1xuICAgIGNvbnN0IGVudHJ5ID0gbmV3U3RhdGUoYXRuLCBydWxlLCBzdGFyLCB7XG4gICAgICAgIHR5cGU6IEFUTl9TVEFSX0xPT1BfRU5UUllcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgZW50cnkpO1xuICAgIGNvbnN0IGxvb3BFbmQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHN0YXIsIHtcbiAgICAgICAgdHlwZTogQVROX0xPT1BfRU5EXG4gICAgfSk7XG4gICAgY29uc3QgbG9vcCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgc3Rhciwge1xuICAgICAgICB0eXBlOiBBVE5fU1RBUl9MT09QX0JBQ0tcbiAgICB9KTtcbiAgICBlbnRyeS5sb29wYmFjayA9IGxvb3A7XG4gICAgbG9vcEVuZC5sb29wYmFjayA9IGxvb3A7XG4gICAgZXBzaWxvbihlbnRyeSwgc3RhcnQpOyAvLyBsb29wIGVudGVyIGVkZ2UgKGFsdCAyKVxuICAgIGVwc2lsb24oZW50cnksIGxvb3BFbmQpOyAvLyBieXBhc3MgbG9vcCBlZGdlIChhbHQgMSlcbiAgICBlcHNpbG9uKGVuZCwgbG9vcCk7IC8vIGJsb2NrIGVuZCBoaXRzIGxvb3AgYmFja1xuICAgIGlmIChzZXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcHNpbG9uKGxvb3AsIGxvb3BFbmQpOyAvLyBlbmQgbG9vcFxuICAgICAgICAvLyBsb29wIGJhY2sgdG8gc3RhcnQgb2YgaGFuZGxlIHVzaW5nIHNlcGFyYXRvclxuICAgICAgICBlcHNpbG9uKGxvb3AsIHNlcC5sZWZ0KTtcbiAgICAgICAgZXBzaWxvbihzZXAucmlnaHQsIHN0YXJ0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVwc2lsb24obG9vcCwgZW50cnkpOyAvLyBsb29wIGJhY2sgdG8gZW50cnkvZXhpdCBkZWNpc2lvblxuICAgIH1cbiAgICBhdG4uZGVjaXNpb25NYXBbYnVpbGRBVE5LZXkocnVsZSwgc2VwID8gJ1JlcGV0aXRpb25XaXRoU2VwYXJhdG9yJyA6ICdSZXBldGl0aW9uJywgc3Rhci5pZHgpXSA9IGVudHJ5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGVudHJ5LFxuICAgICAgICByaWdodDogbG9vcEVuZFxuICAgIH07XG59XG5mdW5jdGlvbiBvcHRpb25hbChhdG4sIHJ1bGUsIG9wdGlvbmFsLCBoYW5kbGUpIHtcbiAgICBjb25zdCBzdGFydCA9IGhhbmRsZS5sZWZ0O1xuICAgIGNvbnN0IGVuZCA9IGhhbmRsZS5yaWdodDtcbiAgICBlcHNpbG9uKHN0YXJ0LCBlbmQpO1xuICAgIGF0bi5kZWNpc2lvbk1hcFtidWlsZEFUTktleShydWxlLCAnT3B0aW9uJywgb3B0aW9uYWwuaWR4KV0gPSBzdGFydDtcbiAgICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHN0YXRlKSB7XG4gICAgYXRuLmRlY2lzaW9uU3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHN0YXRlLmRlY2lzaW9uID0gYXRuLmRlY2lzaW9uU3RhdGVzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHN0YXRlLmRlY2lzaW9uO1xufVxuZnVuY3Rpb24gbWFrZUFsdHMoYXRuLCBydWxlLCBzdGFydCwgcHJvZHVjdGlvbiwgLi4uYWx0cykge1xuICAgIGNvbnN0IGVuZCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcHJvZHVjdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fQkxPQ0tfRU5ELFxuICAgICAgICBzdGFydFxuICAgIH0pO1xuICAgIHN0YXJ0LmVuZCA9IGVuZDtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRzKSB7XG4gICAgICAgIGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaG9vayBhbHRzIHVwIHRvIGRlY2lzaW9uIGJsb2NrXG4gICAgICAgICAgICBlcHNpbG9uKHN0YXJ0LCBhbHQubGVmdCk7XG4gICAgICAgICAgICBlcHNpbG9uKGFsdC5yaWdodCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVwc2lsb24oc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFuZGxlID0ge1xuICAgICAgICBsZWZ0OiBzdGFydCxcbiAgICAgICAgcmlnaHQ6IGVuZFxuICAgIH07XG4gICAgYXRuLmRlY2lzaW9uTWFwW2J1aWxkQVROS2V5KHJ1bGUsIGdldFByb2RUeXBlKHByb2R1Y3Rpb24pLCBwcm9kdWN0aW9uLmlkeCldID0gc3RhcnQ7XG4gICAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGdldFByb2RUeXBlKHByb2R1Y3Rpb24pIHtcbiAgICBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiAnQWx0ZXJuYXRpb24nO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiAnT3B0aW9uJztcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgcmV0dXJuICdSZXBldGl0aW9uJztcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiAnUmVwZXRpdGlvbldpdGhTZXBhcmF0b3InO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4gJ1JlcGV0aXRpb25NYW5kYXRvcnknO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuICdSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvZHVjdGlvbiB0eXBlIGVuY291bnRlcmVkJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZUJsb2NrKGF0biwgYWx0cykge1xuICAgIGNvbnN0IGFsdHNMZW5ndGggPSBhbHRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsdHNMZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gYWx0c1tpXTtcbiAgICAgICAgbGV0IHRyYW5zaXRpb247XG4gICAgICAgIGlmIChoYW5kbGUubGVmdC50cmFuc2l0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb24gPSBoYW5kbGUubGVmdC50cmFuc2l0aW9uc1swXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1J1bGVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBydWxlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IG5leHQgPSBhbHRzW2kgKyAxXS5sZWZ0O1xuICAgICAgICBpZiAoaGFuZGxlLmxlZnQudHlwZSA9PT0gQVROX0JBU0lDICYmXG4gICAgICAgICAgICBoYW5kbGUucmlnaHQudHlwZSA9PT0gQVROX0JBU0lDICYmXG4gICAgICAgICAgICB0cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICgoaXNSdWxlVHJhbnNpdGlvbiAmJiBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZSA9PT0gaGFuZGxlLnJpZ2h0KSB8fFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24udGFyZ2V0ID09PSBoYW5kbGUucmlnaHQpKSB7XG4gICAgICAgICAgICAvLyB3ZSBjYW4gYXZvaWQgZXBzaWxvbiBlZGdlIHRvIG5leHQgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGlzUnVsZVRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBydWxlVHJhbnNpdGlvbi5mb2xsb3dTdGF0ZSA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnRhcmdldCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVTdGF0ZShhdG4sIGhhbmRsZS5yaWdodCk7IC8vIHdlIHNraXBwZWQgb3ZlciB0aGlzIHN0YXRlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBuZWVkIGVwc2lsb24gaWYgcHJldmlvdXMgYmxvY2sncyByaWdodCBlbmQgbm9kZSBpcyBjb21wbGV4XG4gICAgICAgICAgICBlcHNpbG9uKGhhbmRsZS5yaWdodCwgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSBhbHRzWzBdO1xuICAgIGNvbnN0IGxhc3QgPSBhbHRzW2FsdHNMZW5ndGggLSAxXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBmaXJzdC5sZWZ0LFxuICAgICAgICByaWdodDogbGFzdC5yaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiB0b2tlblJlZihhdG4sIHJ1bGUsIHRva2VuVHlwZSwgcHJvZHVjdGlvbikge1xuICAgIGNvbnN0IGxlZnQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24sIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgY29uc3QgcmlnaHQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24sIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgYWRkVHJhbnNpdGlvbihsZWZ0LCBuZXcgQXRvbVRyYW5zaXRpb24ocmlnaHQsIHRva2VuVHlwZSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bGVSZWYoYXRuLCBjdXJyZW50UnVsZSwgbm9uVGVybWluYWwpIHtcbiAgICBjb25zdCBydWxlID0gbm9uVGVybWluYWwucmVmZXJlbmNlZFJ1bGU7XG4gICAgY29uc3Qgc3RhcnQgPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5nZXQocnVsZSk7XG4gICAgY29uc3QgbGVmdCA9IG5ld1N0YXRlKGF0biwgY3VycmVudFJ1bGUsIG5vblRlcm1pbmFsLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3U3RhdGUoYXRuLCBjdXJyZW50UnVsZSwgbm9uVGVybWluYWwsIHtcbiAgICAgICAgdHlwZTogQVROX0JBU0lDXG4gICAgfSk7XG4gICAgY29uc3QgY2FsbCA9IG5ldyBSdWxlVHJhbnNpdGlvbihzdGFydCwgcnVsZSwgcmlnaHQpO1xuICAgIGFkZFRyYW5zaXRpb24obGVmdCwgY2FsbCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRSdWxlSGFuZGxlKGF0biwgcnVsZSwgYmxvY2spIHtcbiAgICBjb25zdCBzdGFydCA9IGF0bi5ydWxlVG9TdGFydFN0YXRlLmdldChydWxlKTtcbiAgICBlcHNpbG9uKHN0YXJ0LCBibG9jay5sZWZ0KTtcbiAgICBjb25zdCBzdG9wID0gYXRuLnJ1bGVUb1N0b3BTdGF0ZS5nZXQocnVsZSk7XG4gICAgZXBzaWxvbihibG9jay5yaWdodCwgc3RvcCk7XG4gICAgY29uc3QgaGFuZGxlID0ge1xuICAgICAgICBsZWZ0OiBzdGFydCxcbiAgICAgICAgcmlnaHQ6IHN0b3BcbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiBlcHNpbG9uKGEsIGIpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gbmV3IEVwc2lsb25UcmFuc2l0aW9uKGIpO1xuICAgIGFkZFRyYW5zaXRpb24oYSwgdHJhbnNpdGlvbik7XG59XG5mdW5jdGlvbiBuZXdTdGF0ZShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24sIHBhcnRpYWwpIHtcbiAgICBjb25zdCB0ID0gT2JqZWN0LmFzc2lnbih7IGF0bixcbiAgICAgICAgcHJvZHVjdGlvbiwgZXBzaWxvbk9ubHlUcmFuc2l0aW9uczogZmFsc2UsIHJ1bGUsIHRyYW5zaXRpb25zOiBbXSwgbmV4dFRva2VuV2l0aGluUnVsZTogW10sIHN0YXRlTnVtYmVyOiBhdG4uc3RhdGVzLmxlbmd0aCB9LCBwYXJ0aWFsKTtcbiAgICBhdG4uc3RhdGVzLnB1c2godCk7XG4gICAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uKHN0YXRlLCB0cmFuc2l0aW9uKSB7XG4gICAgLy8gQSBzaW5nbGUgQVROIHN0YXRlIGNhbiBvbmx5IGNvbnRhaW4gZXBzaWxvbiB0cmFuc2l0aW9ucyBvciBub24tZXBzaWxvbiB0cmFuc2l0aW9uc1xuICAgIC8vIEJlY2F1c2UgdGhleSBhcmUgbmV2ZXIgbWl4ZWQsIG9ubHkgc2V0dGluZyB0aGUgcHJvcGVydHkgZm9yIHRoZSBmaXJzdCB0cmFuc2l0aW9uIGlzIGZpbmVcbiAgICBpZiAoc3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0YXRlLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uLmlzRXBzaWxvbigpO1xuICAgIH1cbiAgICBzdGF0ZS50cmFuc2l0aW9ucy5wdXNoKHRyYW5zaXRpb24pO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3RhdGUoYXRuLCBzdGF0ZSkge1xuICAgIGF0bi5zdGF0ZXMuc3BsaWNlKGF0bi5zdGF0ZXMuaW5kZXhPZihzdGF0ZSksIDEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXRuLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC1lcy9tYXAuanNcIjtcbmV4cG9ydCBjb25zdCBERkFfRVJST1IgPSB7fTtcbmV4cG9ydCBjbGFzcyBBVE5Db25maWdTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZ3MgPSBbXTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3MubGVuZ3RoO1xuICAgIH1cbiAgICBmaW5hbGl6ZSgpIHtcbiAgICAgICAgLy8gRW1wdGllcyB0aGUgbWFwIHRvIGZyZWUgdXAgbWVtb3J5XG4gICAgICAgIHRoaXMubWFwID0ge307XG4gICAgfVxuICAgIGFkZChjb25maWcpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0QVROQ29uZmlnS2V5KGNvbmZpZyk7XG4gICAgICAgIC8vIE9ubHkgYWRkIGNvbmZpZ3Mgd2hpY2ggZG9uJ3QgZXhpc3QgaW4gb3VyIG1hcCBhbHJlYWR5XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgZG9lcyBub3QgaW5mbHVlbmNlIHRoZSBhY3R1YWwgYWxnb3JpdGhtLCBhZGRpbmcgdGhlbSBhbnl3YXkgd291bGQgbWFzc2l2ZWx5IGluY3JlYXNlIG1lbW9yeSBjb25zdW1wdGlvblxuICAgICAgICBpZiAoIShrZXkgaW4gdGhpcy5tYXApKSB7XG4gICAgICAgICAgICB0aGlzLm1hcFtrZXldID0gdGhpcy5jb25maWdzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY29uZmlncy5wdXNoKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWdzO1xuICAgIH1cbiAgICBnZXQgYWx0cygpIHtcbiAgICAgICAgcmV0dXJuIG1hcCh0aGlzLmNvbmZpZ3MsIChlKSA9PiBlLmFsdCk7XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgdmFsdWUgKz0gayArIFwiOlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QVROQ29uZmlnS2V5KGNvbmZpZywgYWx0ID0gdHJ1ZSkge1xuICAgIHJldHVybiBgJHthbHQgPyBgYSR7Y29uZmlnLmFsdH1gIDogXCJcIn1zJHtjb25maWcuc3RhdGUuc3RhdGVOdW1iZXJ9OiR7Y29uZmlnLnN0YWNrLm1hcCgoZSkgPT4gZS5zdGF0ZU51bWJlci50b1N0cmluZygpKS5qb2luKFwiX1wiKX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGZhLmpzLm1hcCIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlVW5pcSBmcm9tICcuL19iYXNlVW5pcS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gKiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAqIC8vID0+IFsyLjEsIDEuMl1cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICovXG5mdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmlxQnk7XG4iLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyB0b2tlbk1hdGNoZXIsIHRva2VuTGFiZWwsIE5vblRlcm1pbmFsLCBBbHRlcm5hdGlvbiwgT3B0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb24sIFRlcm1pbmFsLCBMTGtMb29rYWhlYWRTdHJhdGVneSwgZ2V0TG9va2FoZWFkUGF0aHMgfSBmcm9tIFwiY2hldnJvdGFpblwiO1xuaW1wb3J0IHsgQVROX1JVTEVfU1RPUCwgQXRvbVRyYW5zaXRpb24sIGJ1aWxkQVROS2V5LCBjcmVhdGVBVE4sIEVwc2lsb25UcmFuc2l0aW9uLCBSdWxlVHJhbnNpdGlvbiB9IGZyb20gXCIuL2F0bi5qc1wiO1xuaW1wb3J0IHsgQVROQ29uZmlnU2V0LCBERkFfRVJST1IsIGdldEFUTkNvbmZpZ0tleSB9IGZyb20gXCIuL2RmYS5qc1wiO1xuaW1wb3J0IG1pbiBmcm9tIFwibG9kYXNoLWVzL21pbi5qc1wiO1xuaW1wb3J0IGZsYXRNYXAgZnJvbSBcImxvZGFzaC1lcy9mbGF0TWFwLmpzXCI7XG5pbXBvcnQgdW5pcUJ5IGZyb20gXCJsb2Rhc2gtZXMvdW5pcUJ5LmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwLmpzXCI7XG5pbXBvcnQgZmxhdHRlbiBmcm9tIFwibG9kYXNoLWVzL2ZsYXR0ZW4uanNcIjtcbmltcG9ydCBmb3JFYWNoIGZyb20gXCJsb2Rhc2gtZXMvZm9yRWFjaC5qc1wiO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSBcImxvZGFzaC1lcy9pc0VtcHR5LmpzXCI7XG5pbXBvcnQgcmVkdWNlIGZyb20gXCJsb2Rhc2gtZXMvcmVkdWNlLmpzXCI7XG5mdW5jdGlvbiBjcmVhdGVERkFDYWNoZShzdGFydFN0YXRlLCBkZWNpc2lvbikge1xuICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgIHJldHVybiAocHJlZGljYXRlU2V0KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IHByZWRpY2F0ZVNldC50b1N0cmluZygpO1xuICAgICAgICBsZXQgZXhpc3RpbmcgPSBtYXBba2V5XTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nID0ge1xuICAgICAgICAgICAgICAgIGF0blN0YXJ0U3RhdGU6IHN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgZGVjaXNpb24sXG4gICAgICAgICAgICAgICAgc3RhdGVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hcFtrZXldID0gZXhpc3Rpbmc7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgUHJlZGljYXRlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVzID0gW107XG4gICAgfVxuICAgIGlzKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpbmRleCA+PSB0aGlzLnByZWRpY2F0ZXMubGVuZ3RoIHx8IHRoaXMucHJlZGljYXRlc1tpbmRleF07XG4gICAgfVxuICAgIHNldChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGVzW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gXCJcIjtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMucHJlZGljYXRlcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSB0aGlzLnByZWRpY2F0ZXNbaV0gPT09IHRydWUgPyBcIjFcIiA6IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5jb25zdCBFTVBUWV9QUkVESUNBVEVTID0gbmV3IFByZWRpY2F0ZVNldCgpO1xuZXhwb3J0IGNsYXNzIExMU3Rhckxvb2thaGVhZFN0cmF0ZWd5IGV4dGVuZHMgTExrTG9va2FoZWFkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxvZ2dpbmcgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubG9nZ2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKChtZXNzYWdlKSA9PiBjb25zb2xlLmxvZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0biA9IGNyZWF0ZUFUTihvcHRpb25zLnJ1bGVzKTtcbiAgICAgICAgdGhpcy5kZmFzID0gaW5pdEFUTlNpbXVsYXRvcih0aGlzLmF0bik7XG4gICAgfVxuICAgIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmVzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGJ1aWxkTG9va2FoZWFkRm9yQWx0ZXJuYXRpb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHByb2RPY2N1cnJlbmNlLCBydWxlLCBoYXNQcmVkaWNhdGVzLCBkeW5hbWljVG9rZW5zRW5hYmxlZCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgZGZhcyA9IHRoaXMuZGZhcztcbiAgICAgICAgY29uc3QgbG9nZ2luZyA9IHRoaXMubG9nZ2luZztcbiAgICAgICAgY29uc3Qga2V5ID0gYnVpbGRBVE5LZXkocnVsZSwgJ0FsdGVybmF0aW9uJywgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBjb25zdCBkZWNpc2lvblN0YXRlID0gdGhpcy5hdG4uZGVjaXNpb25NYXBba2V5XTtcbiAgICAgICAgY29uc3QgZGVjaXNpb25JbmRleCA9IGRlY2lzaW9uU3RhdGUuZGVjaXNpb247XG4gICAgICAgIGNvbnN0IHBhcnRpYWxBbHRzID0gbWFwKGdldExvb2thaGVhZFBhdGhzKHtcbiAgICAgICAgICAgIG1heExvb2thaGVhZDogMSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgcHJvZFR5cGU6IFwiQWx0ZXJuYXRpb25cIixcbiAgICAgICAgICAgIHJ1bGU6IHJ1bGVcbiAgICAgICAgfSksIChjdXJyQWx0KSA9PiBtYXAoY3VyckFsdCwgKHBhdGgpID0+IHBhdGhbMF0pKTtcbiAgICAgICAgaWYgKGlzTEwxU2VxdWVuY2UocGFydGlhbEFsdHMsIGZhbHNlKSAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHBhcnRpYWxBbHRzLCAocmVzdWx0LCBjdXJyQWx0LCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclRva1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gaWR4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIChjdXJyRXh0ZW5kaW5nVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyRXh0ZW5kaW5nVHlwZV0gPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3JBbHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZGljdGlvbiA9IGNob2ljZVRvQWx0W25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3JBbHRzICE9PSB1bmRlZmluZWQgJiYgcHJlZGljdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXRlID0gKF9hID0gb3JBbHRzW3ByZWRpY3Rpb25dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuR0FURTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYXRlICE9PSB1bmRlZmluZWQgJiYgZ2F0ZS5jYWxsKHRoaXMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWRpY3Rpb247XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdFtuZXh0VG9rZW4udG9rZW5UeXBlSWR4XTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhc1ByZWRpY2F0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3JBbHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlcyA9IG5ldyBQcmVkaWNhdGVTZXQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBvckFsdHMgPT09IHVuZGVmaW5lZCA/IDAgOiBvckFsdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2F0ZSA9IG9yQWx0cyA9PT0gbnVsbCB8fCBvckFsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yQWx0c1tpXS5HQVRFO1xuICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGVzLnNldChpLCBnYXRlID09PSB1bmRlZmluZWQgfHwgZ2F0ZS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgcHJlZGljYXRlcywgbG9nZ2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgRU1QVFlfUFJFRElDQVRFUywgbG9nZ2luZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZExvb2thaGVhZEZvck9wdGlvbmFsKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBwcm9kT2NjdXJyZW5jZSwgcnVsZSwgcHJvZFR5cGUsIGR5bmFtaWNUb2tlbnNFbmFibGVkIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBkZmFzID0gdGhpcy5kZmFzO1xuICAgICAgICBjb25zdCBsb2dnaW5nID0gdGhpcy5sb2dnaW5nO1xuICAgICAgICBjb25zdCBrZXkgPSBidWlsZEFUTktleShydWxlLCBwcm9kVHlwZSwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICBjb25zdCBkZWNpc2lvblN0YXRlID0gdGhpcy5hdG4uZGVjaXNpb25NYXBba2V5XTtcbiAgICAgICAgY29uc3QgZGVjaXNpb25JbmRleCA9IGRlY2lzaW9uU3RhdGUuZGVjaXNpb247XG4gICAgICAgIGNvbnN0IGFsdHMgPSBtYXAoZ2V0TG9va2FoZWFkUGF0aHMoe1xuICAgICAgICAgICAgbWF4TG9va2FoZWFkOiAxLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICBwcm9kVHlwZSxcbiAgICAgICAgICAgIHJ1bGVcbiAgICAgICAgfSksIChlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWFwKGUsIChnKSA9PiBnWzBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0xMMVNlcXVlbmNlKGFsdHMpICYmIGFsdHNbMF1bMF0gJiYgIWR5bmFtaWNUb2tlbnNFbmFibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBhbHQgPSBhbHRzWzBdO1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVG9rZW5zVHlwZXMgPSBmbGF0dGVuKGFsdCk7XG4gICAgICAgICAgICBpZiAoc2luZ2xlVG9rZW5zVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShzaW5nbGVUb2tlbnNUeXBlc1swXS5jYXRlZ29yeU1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb2tlblR5cGUgPSBzaW5nbGVUb2tlbnNUeXBlc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFRva2VuVW5pcXVlS2V5ID0gZXhwZWN0ZWRUb2tlblR5cGUudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLkxBKDEpLnRva2VuVHlwZUlkeCA9PT0gZXhwZWN0ZWRUb2tlblVuaXF1ZUtleTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hvaWNlVG9BbHQgPSByZWR1Y2Uoc2luZ2xlVG9rZW5zVHlwZXMsIChyZXN1bHQsIGN1cnJUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVG9rVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgKGN1cnJFeHRlbmRpbmdUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRbbmV4dFRva2VuLnRva2VuVHlwZUlkeF0gPT09IHRydWU7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYWRhcHRpdmVQcmVkaWN0LmNhbGwodGhpcywgZGZhcywgZGVjaXNpb25JbmRleCwgRU1QVFlfUFJFRElDQVRFUywgbG9nZ2luZyk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gXCJvYmplY3RcIiA/IGZhbHNlIDogcmVzdWx0ID09PSAwO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTEwxU2VxdWVuY2Uoc2VxdWVuY2VzLCBhbGxvd0VtcHR5ID0gdHJ1ZSkge1xuICAgIGNvbnN0IGZ1bGxTZXQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBhbHQgb2Ygc2VxdWVuY2VzKSB7XG4gICAgICAgIGNvbnN0IGFsdFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tUeXBlIG9mIGFsdCkge1xuICAgICAgICAgICAgaWYgKHRva1R5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVwc2lsb24gcHJvZHVjdGlvbiBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmRpY2VzID0gW3Rva1R5cGUudG9rZW5UeXBlSWR4XS5jb25jYXQodG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRpY2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxTZXQuaGFzKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsdFNldC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxTZXQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYWx0U2V0LmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaW5pdEFUTlNpbXVsYXRvcihhdG4pIHtcbiAgICBjb25zdCBkZWNpc2lvbkxlbmd0aCA9IGF0bi5kZWNpc2lvblN0YXRlcy5sZW5ndGg7XG4gICAgY29uc3QgZGVjaXNpb25Ub0RGQSA9IEFycmF5KGRlY2lzaW9uTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY2lzaW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjaXNpb25Ub0RGQVtpXSA9IGNyZWF0ZURGQUNhY2hlKGF0bi5kZWNpc2lvblN0YXRlc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNpc2lvblRvREZBO1xufVxuZnVuY3Rpb24gYWRhcHRpdmVQcmVkaWN0KGRmYUNhY2hlcywgZGVjaXNpb24sIHByZWRpY2F0ZVNldCwgbG9nZ2luZykge1xuICAgIGNvbnN0IGRmYSA9IGRmYUNhY2hlc1tkZWNpc2lvbl0ocHJlZGljYXRlU2V0KTtcbiAgICBsZXQgc3RhcnQgPSBkZmEuc3RhcnQ7XG4gICAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY2xvc3VyZSA9IGNvbXB1dGVTdGFydFN0YXRlKGRmYS5hdG5TdGFydFN0YXRlKTtcbiAgICAgICAgc3RhcnQgPSBhZGRERkFTdGF0ZShkZmEsIG5ld0RGQVN0YXRlKGNsb3N1cmUpKTtcbiAgICAgICAgZGZhLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxuICAgIGNvbnN0IGFsdCA9IHBlcmZvcm1Mb29rYWhlYWQuYXBwbHkodGhpcywgW2RmYSwgc3RhcnQsIHByZWRpY2F0ZVNldCwgbG9nZ2luZ10pO1xuICAgIHJldHVybiBhbHQ7XG59XG5mdW5jdGlvbiBwZXJmb3JtTG9va2FoZWFkKGRmYSwgczAsIHByZWRpY2F0ZVNldCwgbG9nZ2luZykge1xuICAgIGxldCBwcmV2aW91c0QgPSBzMDtcbiAgICBsZXQgaSA9IDE7XG4gICAgY29uc3QgcGF0aCA9IFtdO1xuICAgIGxldCB0ID0gdGhpcy5MQShpKyspO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxldCBkID0gZ2V0RXhpc3RpbmdUYXJnZXRTdGF0ZShwcmV2aW91c0QsIHQpO1xuICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkID0gY29tcHV0ZUxvb2thaGVhZFRhcmdldC5hcHBseSh0aGlzLCBbZGZhLCBwcmV2aW91c0QsIHQsIGksIHByZWRpY2F0ZVNldCwgbG9nZ2luZ10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkID09PSBERkFfRVJST1IpIHtcbiAgICAgICAgICAgIHJldHVybiBidWlsZEFkYXB0aXZlUHJlZGljdEVycm9yKHBhdGgsIHByZXZpb3VzRCwgdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuaXNBY2NlcHRTdGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGQucHJlZGljdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0QgPSBkO1xuICAgICAgICBwYXRoLnB1c2godCk7XG4gICAgICAgIHQgPSB0aGlzLkxBKGkrKyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcHV0ZUxvb2thaGVhZFRhcmdldChkZmEsIHByZXZpb3VzRCwgdG9rZW4sIGxvb2thaGVhZCwgcHJlZGljYXRlU2V0LCBsb2dnaW5nKSB7XG4gICAgY29uc3QgcmVhY2ggPSBjb21wdXRlUmVhY2hTZXQocHJldmlvdXNELmNvbmZpZ3MsIHRva2VuLCBwcmVkaWNhdGVTZXQpO1xuICAgIGlmIChyZWFjaC5zaXplID09PSAwKSB7XG4gICAgICAgIGFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHRva2VuLCBERkFfRVJST1IpO1xuICAgICAgICByZXR1cm4gREZBX0VSUk9SO1xuICAgIH1cbiAgICBsZXQgbmV3U3RhdGUgPSBuZXdERkFTdGF0ZShyZWFjaCk7XG4gICAgY29uc3QgcHJlZGljdGVkQWx0ID0gZ2V0VW5pcXVlQWx0KHJlYWNoLCBwcmVkaWNhdGVTZXQpO1xuICAgIGlmIChwcmVkaWN0ZWRBbHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdTdGF0ZS5pc0FjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgbmV3U3RhdGUucHJlZGljdGlvbiA9IHByZWRpY3RlZEFsdDtcbiAgICAgICAgbmV3U3RhdGUuY29uZmlncy51bmlxdWVBbHQgPSBwcmVkaWN0ZWRBbHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhc0NvbmZsaWN0VGVybWluYXRpbmdQcmVkaWN0aW9uKHJlYWNoKSkge1xuICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gbWluKHJlYWNoLmFsdHMpO1xuICAgICAgICBuZXdTdGF0ZS5pc0FjY2VwdFN0YXRlID0gdHJ1ZTtcbiAgICAgICAgbmV3U3RhdGUucHJlZGljdGlvbiA9IHByZWRpY3Rpb247XG4gICAgICAgIG5ld1N0YXRlLmNvbmZpZ3MudW5pcXVlQWx0ID0gcHJlZGljdGlvbjtcbiAgICAgICAgcmVwb3J0TG9va2FoZWFkQW1iaWd1aXR5LmFwcGx5KHRoaXMsIFtkZmEsIGxvb2thaGVhZCwgcmVhY2guYWx0cywgbG9nZ2luZ10pO1xuICAgIH1cbiAgICBuZXdTdGF0ZSA9IGFkZERGQUVkZ2UoZGZhLCBwcmV2aW91c0QsIHRva2VuLCBuZXdTdGF0ZSk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuZnVuY3Rpb24gcmVwb3J0TG9va2FoZWFkQW1iaWd1aXR5KGRmYSwgbG9va2FoZWFkLCBhbWJpZ3VpdHlJbmRpY2VzLCBsb2dnaW5nKSB7XG4gICAgY29uc3QgcHJlZml4UGF0aCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxvb2thaGVhZDsgaSsrKSB7XG4gICAgICAgIHByZWZpeFBhdGgucHVzaCh0aGlzLkxBKGkpLnRva2VuVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGF0blN0YXRlID0gZGZhLmF0blN0YXJ0U3RhdGU7XG4gICAgY29uc3QgdG9wTGV2ZWxSdWxlID0gYXRuU3RhdGUucnVsZTtcbiAgICBjb25zdCBwcm9kdWN0aW9uID0gYXRuU3RhdGUucHJvZHVjdGlvbjtcbiAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgIHRvcExldmVsUnVsZSxcbiAgICAgICAgYW1iaWd1aXR5SW5kaWNlcyxcbiAgICAgICAgcHJvZHVjdGlvbixcbiAgICAgICAgcHJlZml4UGF0aFxuICAgIH0pO1xuICAgIGxvZ2dpbmcobWVzc2FnZSk7XG59XG5mdW5jdGlvbiBidWlsZEFtYmlndWl0eUVycm9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwYXRoTXNnID0gbWFwKG9wdGlvbnMucHJlZml4UGF0aCwgKGN1cnJ0b2spID0+IHRva2VuTGFiZWwoY3VycnRvaykpLmpvaW4oXCIsIFwiKTtcbiAgICBjb25zdCBvY2N1cnJlbmNlID0gb3B0aW9ucy5wcm9kdWN0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLnByb2R1Y3Rpb24uaWR4O1xuICAgIGxldCBjdXJyTWVzc2FnZSA9IGBBbWJpZ3VvdXMgQWx0ZXJuYXRpdmVzIERldGVjdGVkOiA8JHtvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiwgXCIpfT4gaW4gPCR7Z2V0UHJvZHVjdGlvbkRzbE5hbWUob3B0aW9ucy5wcm9kdWN0aW9uKX0ke29jY3VycmVuY2V9PmAgK1xuICAgICAgICBgIGluc2lkZSA8JHtvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lfT4gUnVsZSxcXG5gICtcbiAgICAgICAgYDwke3BhdGhNc2d9PiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuYDtcbiAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgIGN1cnJNZXNzYWdlICtcbiAgICAgICAgICAgIGBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19ncmFtbWFyX2Vycm9ycy5odG1sI0FNQklHVU9VU19BTFRFUk5BVElWRVNcXG5gICtcbiAgICAgICAgICAgIGBGb3IgRnVydGhlciBkZXRhaWxzLmA7XG4gICAgcmV0dXJuIGN1cnJNZXNzYWdlO1xufVxuZnVuY3Rpb24gZ2V0UHJvZHVjdGlvbkRzbE5hbWUocHJvZCkge1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU1VCUlVMRVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9QVElPTlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1JcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJDT05TVU1FXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkQWRhcHRpdmVQcmVkaWN0RXJyb3IocGF0aCwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBuZXh0VHJhbnNpdGlvbnMgPSBmbGF0TWFwKHByZXZpb3VzLmNvbmZpZ3MuZWxlbWVudHMsIChlKSA9PiBlLnN0YXRlLnRyYW5zaXRpb25zKTtcbiAgICBjb25zdCBuZXh0VG9rZW5UeXBlcyA9IHVuaXFCeShuZXh0VHJhbnNpdGlvbnNcbiAgICAgICAgLmZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIEF0b21UcmFuc2l0aW9uKVxuICAgICAgICAubWFwKChlKSA9PiBlLnRva2VuVHlwZSksIChlKSA9PiBlLnRva2VuVHlwZUlkeCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWN0dWFsVG9rZW46IGN1cnJlbnQsXG4gICAgICAgIHBvc3NpYmxlVG9rZW5UeXBlczogbmV4dFRva2VuVHlwZXMsXG4gICAgICAgIHRva2VuUGF0aDogcGF0aFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHN0YXRlLCB0b2tlbikge1xuICAgIHJldHVybiBzdGF0ZS5lZGdlc1t0b2tlbi50b2tlblR5cGVJZHhdO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlYWNoU2V0KGNvbmZpZ3MsIHRva2VuLCBwcmVkaWNhdGVTZXQpIHtcbiAgICBjb25zdCBpbnRlcm1lZGlhdGUgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgY29uc3Qgc2tpcHBlZFN0b3BTdGF0ZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY29uZmlncy5lbGVtZW50cykge1xuICAgICAgICBpZiAocHJlZGljYXRlU2V0LmlzKGMuYWx0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjLnN0YXRlLnR5cGUgPT09IEFUTl9SVUxFX1NUT1ApIHtcbiAgICAgICAgICAgIHNraXBwZWRTdG9wU3RhdGVzLnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2l0aW9uTGVuZ3RoID0gYy5zdGF0ZS50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0gYy5zdGF0ZS50cmFuc2l0aW9uc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFJlYWNoYWJsZVRhcmdldCh0cmFuc2l0aW9uLCB0b2tlbik7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUuYWRkKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBjLmFsdCxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IGMuc3RhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVhY2g7XG4gICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aCA9PT0gMCAmJiBpbnRlcm1lZGlhdGUuc2l6ZSA9PT0gMSkge1xuICAgICAgICByZWFjaCA9IGludGVybWVkaWF0ZTtcbiAgICB9XG4gICAgaWYgKHJlYWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVhY2ggPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBpbnRlcm1lZGlhdGUuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNsb3N1cmUoYywgcmVhY2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChza2lwcGVkU3RvcFN0YXRlcy5sZW5ndGggPiAwICYmICFoYXNDb25maWdJblJ1bGVTdG9wU3RhdGUocmVhY2gpKSB7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBza2lwcGVkU3RvcFN0YXRlcykge1xuICAgICAgICAgICAgcmVhY2guYWRkKGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWFjaDtcbn1cbmZ1bmN0aW9uIGdldFJlYWNoYWJsZVRhcmdldCh0cmFuc2l0aW9uLCB0b2tlbikge1xuICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb24gJiZcbiAgICAgICAgdG9rZW5NYXRjaGVyKHRva2VuLCB0cmFuc2l0aW9uLnRva2VuVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb24udGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0VW5pcXVlQWx0KGNvbmZpZ3MsIHByZWRpY2F0ZVNldCkge1xuICAgIGxldCBhbHQ7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZVNldC5pcyhjLmFsdCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChhbHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFsdCA9IGMuYWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWx0ICE9PSBjLmFsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdDtcbn1cbmZ1bmN0aW9uIG5ld0RGQVN0YXRlKGNsb3N1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWdzOiBjbG9zdXJlLFxuICAgICAgICBlZGdlczoge30sXG4gICAgICAgIGlzQWNjZXB0U3RhdGU6IGZhbHNlLFxuICAgICAgICBwcmVkaWN0aW9uOiAtMVxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRERkFFZGdlKGRmYSwgZnJvbSwgdG9rZW4sIHRvKSB7XG4gICAgdG8gPSBhZGRERkFTdGF0ZShkZmEsIHRvKTtcbiAgICBmcm9tLmVkZ2VzW3Rva2VuLnRva2VuVHlwZUlkeF0gPSB0bztcbiAgICByZXR1cm4gdG87XG59XG5mdW5jdGlvbiBhZGRERkFTdGF0ZShkZmEsIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSBERkFfRVJST1IpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvLyBSZXBldGl0aW9ucyBoYXZlIHRoZSBzYW1lIGNvbmZpZyBzZXRcbiAgICAvLyBUaGVyZWZvcmUsIHN0b3JpbmcgdGhlIGtleSBvZiB0aGUgY29uZmlnIGluIGEgbWFwIGFsbG93cyB1cyB0byBjcmVhdGUgYSBsb29wIGluIG91ciBERkFcbiAgICBjb25zdCBtYXBLZXkgPSBzdGF0ZS5jb25maWdzLmtleTtcbiAgICBjb25zdCBleGlzdGluZyA9IGRmYS5zdGF0ZXNbbWFwS2V5XTtcbiAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIHN0YXRlLmNvbmZpZ3MuZmluYWxpemUoKTtcbiAgICBkZmEuc3RhdGVzW21hcEtleV0gPSBzdGF0ZTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiBjb21wdXRlU3RhcnRTdGF0ZShhdG5TdGF0ZSkge1xuICAgIGNvbnN0IGNvbmZpZ3MgPSBuZXcgQVROQ29uZmlnU2V0KCk7XG4gICAgY29uc3QgbnVtYmVyT2ZUcmFuc2l0aW9ucyA9IGF0blN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mVHJhbnNpdGlvbnM7IGkrKykge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhdG5TdGF0ZS50cmFuc2l0aW9uc1tpXS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHN0YXRlOiB0YXJnZXQsXG4gICAgICAgICAgICBhbHQ6IGksXG4gICAgICAgICAgICBzdGFjazogW11cbiAgICAgICAgfTtcbiAgICAgICAgY2xvc3VyZShjb25maWcsIGNvbmZpZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlncztcbn1cbmZ1bmN0aW9uIGNsb3N1cmUoY29uZmlnLCBjb25maWdzKSB7XG4gICAgY29uc3QgcCA9IGNvbmZpZy5zdGF0ZTtcbiAgICBpZiAocC50eXBlID09PSBBVE5fUlVMRV9TVE9QKSB7XG4gICAgICAgIGlmIChjb25maWcuc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYXRuU3RhY2sgPSBbLi4uY29uZmlnLnN0YWNrXTtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd1N0YXRlID0gYXRuU3RhY2sucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBmb2xsb3dDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IGZvbGxvd1N0YXRlLFxuICAgICAgICAgICAgICAgIGFsdDogY29uZmlnLmFsdCxcbiAgICAgICAgICAgICAgICBzdGFjazogYXRuU3RhY2tcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjbG9zdXJlKGZvbGxvd0NvbmZpZywgY29uZmlncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXBwaW5nIGludG8gb3V0ZXIgY29udGV4dCwgc2ltcGx5IGFkZCB0aGUgY29uZmlnXG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgc3RvcCBjb21wdXRhdGlvbiBvbmNlIGV2ZXJ5IGNvbmZpZyBpcyBhdCB0aGUgcnVsZSBzdG9wIHN0YXRlXG4gICAgICAgICAgICBjb25maWdzLmFkZChjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFwLmVwc2lsb25Pbmx5VHJhbnNpdGlvbnMpIHtcbiAgICAgICAgY29uZmlncy5hZGQoY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdHJhbnNpdGlvbkxlbmd0aCA9IHAudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGlvbkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBwLnRyYW5zaXRpb25zW2ldO1xuICAgICAgICBjb25zdCBjID0gZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHRyYW5zaXRpb24pO1xuICAgICAgICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9zdXJlKGMsIGNvbmZpZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RXBzaWxvblRhcmdldChjb25maWcsIHRyYW5zaXRpb24pIHtcbiAgICBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIEVwc2lsb25UcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdHJhbnNpdGlvbi50YXJnZXQsXG4gICAgICAgICAgICBhbHQ6IGNvbmZpZy5hbHQsXG4gICAgICAgICAgICBzdGFjazogY29uZmlnLnN0YWNrXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbikge1xuICAgICAgICBjb25zdCBzdGFjayA9IFsuLi5jb25maWcuc3RhY2ssIHRyYW5zaXRpb24uZm9sbG93U3RhdGVdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHRyYW5zaXRpb24udGFyZ2V0LFxuICAgICAgICAgICAgYWx0OiBjb25maWcuYWx0LFxuICAgICAgICAgICAgc3RhY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShjb25maWdzKSB7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGMuc3RhdGUudHlwZSA9PT0gQVROX1JVTEVfU1RPUCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykge1xuICAgIGZvciAoY29uc3QgYyBvZiBjb25maWdzLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChjLnN0YXRlLnR5cGUgIT09IEFUTl9SVUxFX1NUT1ApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc0NvbmZsaWN0VGVybWluYXRpbmdQcmVkaWN0aW9uKGNvbmZpZ3MpIHtcbiAgICBpZiAoYWxsQ29uZmlnc0luUnVsZVN0b3BTdGF0ZXMoY29uZmlncykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGFsdFNldHMgPSBnZXRDb25mbGljdGluZ0FsdFNldHMoY29uZmlncy5lbGVtZW50cyk7XG4gICAgY29uc3QgaGV1cmlzdGljID0gaGFzQ29uZmxpY3RpbmdBbHRTZXQoYWx0U2V0cykgJiYgIWhhc1N0YXRlQXNzb2NpYXRlZFdpdGhPbmVBbHQoYWx0U2V0cyk7XG4gICAgcmV0dXJuIGhldXJpc3RpYztcbn1cbmZ1bmN0aW9uIGdldENvbmZsaWN0aW5nQWx0U2V0cyhjb25maWdzKSB7XG4gICAgY29uc3QgY29uZmlnVG9BbHRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgYyBvZiBjb25maWdzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldEFUTkNvbmZpZ0tleShjLCBmYWxzZSk7XG4gICAgICAgIGxldCBhbHRzID0gY29uZmlnVG9BbHRzLmdldChrZXkpO1xuICAgICAgICBpZiAoYWx0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhbHRzID0ge307XG4gICAgICAgICAgICBjb25maWdUb0FsdHMuc2V0KGtleSwgYWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgYWx0c1tjLmFsdF0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnVG9BbHRzO1xufVxuZnVuY3Rpb24gaGFzQ29uZmxpY3RpbmdBbHRTZXQoYWx0U2V0cykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuZnJvbShhbHRTZXRzLnZhbHVlcygpKSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGhhc1N0YXRlQXNzb2NpYXRlZFdpdGhPbmVBbHQoYWx0U2V0cykge1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgQXJyYXkuZnJvbShhbHRTZXRzLnZhbHVlcygpKSkge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWxsLXN0YXItbG9va2FoZWFkLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCB7IExMU3Rhckxvb2thaGVhZFN0cmF0ZWd5IH0gZnJvbSAnLi9hbGwtc3Rhci1sb29rYWhlYWQuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuJ3VzZSBzdHJpY3QnO1xuZXhwb3J0IHZhciBEb2N1bWVudFVyaTtcbihmdW5jdGlvbiAoRG9jdW1lbnRVcmkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgRG9jdW1lbnRVcmkuaXMgPSBpcztcbn0pKERvY3VtZW50VXJpIHx8IChEb2N1bWVudFVyaSA9IHt9KSk7XG5leHBvcnQgdmFyIFVSSTtcbihmdW5jdGlvbiAoVVJJKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG4gICAgfVxuICAgIFVSSS5pcyA9IGlzO1xufSkoVVJJIHx8IChVUkkgPSB7fSkpO1xuZXhwb3J0IHZhciBpbnRlZ2VyO1xuKGZ1bmN0aW9uIChpbnRlZ2VyKSB7XG4gICAgaW50ZWdlci5NSU5fVkFMVUUgPSAtMjE0NzQ4MzY0ODtcbiAgICBpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaW50ZWdlci5NSU5fVkFMVUUgPD0gdmFsdWUgJiYgdmFsdWUgPD0gaW50ZWdlci5NQVhfVkFMVUU7XG4gICAgfVxuICAgIGludGVnZXIuaXMgPSBpcztcbn0pKGludGVnZXIgfHwgKGludGVnZXIgPSB7fSkpO1xuZXhwb3J0IHZhciB1aW50ZWdlcjtcbihmdW5jdGlvbiAodWludGVnZXIpIHtcbiAgICB1aW50ZWdlci5NSU5fVkFMVUUgPSAwO1xuICAgIHVpbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdWludGVnZXIuTUlOX1ZBTFVFIDw9IHZhbHVlICYmIHZhbHVlIDw9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgdWludGVnZXIuaXMgPSBpcztcbn0pKHVpbnRlZ2VyIHx8ICh1aW50ZWdlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQb3NpdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQb3NpdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBQb3NpdGlvbiBsaXRlcmFsIGZyb20gdGhlIGdpdmVuIGxpbmUgYW5kIGNoYXJhY3Rlci5cbiAgICAgKiBAcGFyYW0gbGluZSBUaGUgcG9zaXRpb24ncyBsaW5lLlxuICAgICAqIEBwYXJhbSBjaGFyYWN0ZXIgVGhlIHBvc2l0aW9uJ3MgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsaW5lLCBjaGFyYWN0ZXIpIHtcbiAgICAgICAgaWYgKGxpbmUgPT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICAgICAgICAgIGxpbmUgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyID0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGNoYXJhY3RlciB9O1xuICAgIH1cbiAgICBQb3NpdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBQb3NpdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmNoYXJhY3Rlcik7XG4gICAgfVxuICAgIFBvc2l0aW9uLmlzID0gaXM7XG59KShQb3NpdGlvbiB8fCAoUG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUmFuZ2V9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFJhbmdlO1xuKGZ1bmN0aW9uIChSYW5nZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbmUsIHR3bywgdGhyZWUsIGZvdXIpIHtcbiAgICAgICAgaWYgKElzLnVpbnRlZ2VyKG9uZSkgJiYgSXMudWludGVnZXIodHdvKSAmJiBJcy51aW50ZWdlcih0aHJlZSkgJiYgSXMudWludGVnZXIoZm91cikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBQb3NpdGlvbi5jcmVhdGUob25lLCB0d28pLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSh0aHJlZSwgZm91cikgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChQb3NpdGlvbi5pcyhvbmUpICYmIFBvc2l0aW9uLmlzKHR3bykpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBvbmUsIGVuZDogdHdvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJhbmdlI2NyZWF0ZSBjYWxsZWQgd2l0aCBpbnZhbGlkIGFyZ3VtZW50c1ske29uZX0sICR7dHdvfSwgJHt0aHJlZX0sICR7Zm91cn1dYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnN0YXJ0KSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuZW5kKTtcbiAgICB9XG4gICAgUmFuZ2UuaXMgPSBpcztcbn0pKFJhbmdlIHx8IChSYW5nZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBMb2NhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgTG9jYXRpb247XG4oZnVuY3Rpb24gKExvY2F0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvY2F0aW9uIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgbG9jYXRpb24ncyB1cmkuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSBsb2NhdGlvbidzIHJhbmdlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgcmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTG9jYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUudXJpKSk7XG4gICAgfVxuICAgIExvY2F0aW9uLmlzID0gaXM7XG59KShMb2NhdGlvbiB8fCAoTG9jYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgTG9jYXRpb25MaW5rIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9uTGlua30gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgTG9jYXRpb25MaW5rO1xuKGZ1bmN0aW9uIChMb2NhdGlvbkxpbmspIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb25MaW5rIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHRhcmdldFVyaSBUaGUgZGVmaW5pdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmFuZ2UgVGhlIGZ1bGwgcmFuZ2Ugb2YgdGhlIGRlZmluaXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldFNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgZGVmaW5pdGlvbiBhdCB0aGUgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSBvcmlnaW5TZWxlY3Rpb25SYW5nZSBUaGUgc3BhbiBvZiB0aGUgc3ltYm9sIGJlaW5nIGRlZmluZWQgaW4gdGhlIG9yaWdpbmF0aW5nIHNvdXJjZSBmaWxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0VXJpLCB0YXJnZXRSYW5nZSwgdGFyZ2V0U2VsZWN0aW9uUmFuZ2UsIG9yaWdpblNlbGVjdGlvblJhbmdlIH07XG4gICAgfVxuICAgIExvY2F0aW9uTGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbkxpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldFVyaSlcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS50YXJnZXRTZWxlY3Rpb25SYW5nZSlcbiAgICAgICAgICAgICYmIChSYW5nZS5pcyhjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUub3JpZ2luU2VsZWN0aW9uUmFuZ2UpKTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmlzID0gaXM7XG59KShMb2NhdGlvbkxpbmsgfHwgKExvY2F0aW9uTGluayA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvcn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3I7XG4oZnVuY3Rpb24gKENvbG9yKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvciBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyZWQsIGdyZWVuLCBibHVlLCBhbHBoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVkLFxuICAgICAgICAgICAgZ3JlZW4sXG4gICAgICAgICAgICBibHVlLFxuICAgICAgICAgICAgYWxwaGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9yfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLnJlZCwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ncmVlbiwgMCwgMSlcbiAgICAgICAgICAgICYmIElzLm51bWJlclJhbmdlKGNhbmRpZGF0ZS5ibHVlLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmFscGhhLCAwLCAxKTtcbiAgICB9XG4gICAgQ29sb3IuaXMgPSBpcztcbn0pKENvbG9yIHx8IChDb2xvciA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvckluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvbG9ySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKENvbG9ySW5mb3JtYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9ySW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvckluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIENvbG9yLmlzKGNhbmRpZGF0ZS5jb2xvcik7XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKENvbG9ySW5mb3JtYXRpb24gfHwgKENvbG9ySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29sb3IgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JQcmVzZW50YXRpb259IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvbG9yUHJlc2VudGF0aW9uO1xuKGZ1bmN0aW9uIChDb2xvclByZXNlbnRhdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgdGV4dEVkaXQsIGFkZGl0aW9uYWxUZXh0RWRpdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgdGV4dEVkaXQsXG4gICAgICAgICAgICBhZGRpdGlvbmFsVGV4dEVkaXRzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2xvckluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYWJlbClcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnRleHRFZGl0KSB8fCBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cykgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuYWRkaXRpb25hbFRleHRFZGl0cywgVGV4dEVkaXQuaXMpKTtcbiAgICB9XG4gICAgQ29sb3JQcmVzZW50YXRpb24uaXMgPSBpcztcbn0pKENvbG9yUHJlc2VudGF0aW9uIHx8IChDb2xvclByZXNlbnRhdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgcmFuZ2Uga2luZHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9sZGluZ1JhbmdlS2luZDtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlS2luZCkge1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgY29tbWVudFxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuQ29tbWVudCA9ICdjb21tZW50JztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhbiBpbXBvcnQgb3IgaW5jbHVkZVxuICAgICAqL1xuICAgIEZvbGRpbmdSYW5nZUtpbmQuSW1wb3J0cyA9ICdpbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBGb2xkaW5nIHJhbmdlIGZvciBhIHJlZ2lvbiAoZS5nLiBgI3JlZ2lvbmApXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5SZWdpb24gPSAncmVnaW9uJztcbn0pKEZvbGRpbmdSYW5nZUtpbmQgfHwgKEZvbGRpbmdSYW5nZUtpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZm9sZGluZyByYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb2xkaW5nUmFuZ2V9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIEZvbGRpbmdSYW5nZTtcbihmdW5jdGlvbiAoRm9sZGluZ1JhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb2xkaW5nUmFuZ2UgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoc3RhcnRMaW5lLCBlbmRMaW5lLCBzdGFydENoYXJhY3RlciwgZW5kQ2hhcmFjdGVyLCBraW5kLCBjb2xsYXBzZWRUZXh0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc3RhcnRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhcnRDaGFyYWN0ZXIgPSBzdGFydENoYXJhY3RlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChlbmRDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXN1bHQuZW5kQ2hhcmFjdGVyID0gZW5kQ2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGtpbmQpKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoY29sbGFwc2VkVGV4dCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb2xsYXBzZWRUZXh0ID0gY29sbGFwc2VkVGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRm9sZGluZ1JhbmdlfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLnN0YXJ0TGluZSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnN0YXJ0Q2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSB8fCBJcy51aW50ZWdlcihjYW5kaWRhdGUuZW5kQ2hhcmFjdGVyKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmtpbmQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpO1xuICAgIH1cbiAgICBGb2xkaW5nUmFuZ2UuaXMgPSBpcztcbn0pKEZvbGRpbmdSYW5nZSB8fCAoRm9sZGluZ1JhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsb2NhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH07XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pICYmIElzLnN0cmluZyhjYW5kaWRhdGUubWVzc2FnZSk7XG4gICAgfVxuICAgIERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24uaXMgPSBpcztcbn0pKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gfHwgKERpYWdub3N0aWNSZWxhdGVkSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYydzIHNldmVyaXR5LlxuICovXG5leHBvcnQgdmFyIERpYWdub3N0aWNTZXZlcml0eTtcbihmdW5jdGlvbiAoRGlhZ25vc3RpY1NldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuRXJyb3IgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYSB3YXJuaW5nLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5XYXJuaW5nID0gMjtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGluZm9ybWF0aW9uLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5JbmZvcm1hdGlvbiA9IDM7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIGhpbnQuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkhpbnQgPSA0O1xufSkoRGlhZ25vc3RpY1NldmVyaXR5IHx8IChEaWFnbm9zdGljU2V2ZXJpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlhZ25vc3RpYyB0YWdzLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljVGFnO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljVGFnKSB7XG4gICAgLyoqXG4gICAgICogVW51c2VkIG9yIHVubmVjZXNzYXJ5IGNvZGUuXG4gICAgICpcbiAgICAgKiBDbGllbnRzIGFyZSBhbGxvd2VkIHRvIHJlbmRlciBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIGZhZGVkIG91dCBpbnN0ZWFkIG9mIGhhdmluZ1xuICAgICAqIGFuIGVycm9yIHNxdWlnZ2xlLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuVW5uZWNlc3NhcnkgPSAxO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQgb3Igb2Jzb2xldGUgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyZWQgZGlhZ25vc3RpY3Mgd2l0aCB0aGlzIHRhZyBzdHJpa2UgdGhyb3VnaC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljVGFnLkRlcHJlY2F0ZWQgPSAyO1xufSkoRGlhZ25vc3RpY1RhZyB8fCAoRGlhZ25vc3RpY1RhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2RlRGVzY3JpcHRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggZGVzY3JpcHRpb25zIGZvciBkaWFnbm9zdGljIGNvZGVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBDb2RlRGVzY3JpcHRpb247XG4oZnVuY3Rpb24gKENvZGVEZXNjcmlwdGlvbikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuaHJlZik7XG4gICAgfVxuICAgIENvZGVEZXNjcmlwdGlvbi5pcyA9IGlzO1xufSkoQ29kZURlc2NyaXB0aW9uIHx8IChDb2RlRGVzY3JpcHRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpYyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBtZXNzYWdlLCBzZXZlcml0eSwgY29kZSwgc291cmNlLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UsIG1lc3NhZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoc2V2ZXJpdHkpKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2RlKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvZGUgPSBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQocmVsYXRlZEluZm9ybWF0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LnJlbGF0ZWRJbmZvcm1hdGlvbiA9IHJlbGF0ZWRJbmZvcm1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEaWFnbm9zdGljLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERpYWdub3N0aWN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKVxuICAgICAgICAgICAgJiYgKElzLm51bWJlcihjYW5kaWRhdGUuc2V2ZXJpdHkpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc2V2ZXJpdHkpKVxuICAgICAgICAgICAgJiYgKElzLmludGVnZXIoY2FuZGlkYXRlLmNvZGUpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUuY29kZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb2RlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGVEZXNjcmlwdGlvbikgfHwgKElzLnN0cmluZygoX2EgPSBjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHJlZikpKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuc291cmNlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLnNvdXJjZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5yZWxhdGVkSW5mb3JtYXRpb24pIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbiwgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcykpO1xuICAgIH1cbiAgICBEaWFnbm9zdGljLmlzID0gaXM7XG59KShEaWFnbm9zdGljIHx8IChEaWFnbm9zdGljID0ge30pKTtcbi8qKlxuICogVGhlIENvbW1hbmQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29tbWFuZH0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29tbWFuZDtcbihmdW5jdGlvbiAoQ29tbWFuZCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29tbWFuZCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwgY29tbWFuZCwgLi4uYXJncykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyB0aXRsZSwgY29tbWFuZCB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChhcmdzKSAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5hcmd1bWVudHMgPSBhcmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvbW1hbmQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29tbWFuZH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmNvbW1hbmQpO1xuICAgIH1cbiAgICBDb21tYW5kLmlzID0gaXM7XG59KShDb21tYW5kIHx8IChDb21tYW5kID0ge30pKTtcbi8qKlxuICogVGhlIFRleHRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHJlcGxhY2UsXG4gKiBpbnNlcnQgYW5kIGRlbGV0ZSBlZGl0cyBtb3JlIGVhc2lseS5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RWRpdDtcbihmdW5jdGlvbiAoVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSBuZXcgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKHJhbmdlLCBuZXdUZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0IH07XG4gICAgfVxuICAgIFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zZXJ0IHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkZWxldGUgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpO1xuICAgIH1cbiAgICBUZXh0RWRpdC5pcyA9IGlzO1xufSkoVGV4dEVkaXQgfHwgKFRleHRFZGl0ID0ge30pKTtcbmV4cG9ydCB2YXIgQ2hhbmdlQW5ub3RhdGlvbjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgbmVlZHNDb25maXJtYXRpb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgbGFiZWwgfTtcbiAgICAgICAgaWYgKG5lZWRzQ29uZmlybWF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5uZWVkc0NvbmZpcm1hdGlvbiA9IG5lZWRzQ29uZmlybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSAmJlxuICAgICAgICAgICAgKElzLmJvb2xlYW4oY2FuZGlkYXRlLm5lZWRzQ29uZmlybWF0aW9uKSB8fCBjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24gPT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRlc2NyaXB0aW9uKSB8fCBjYW5kaWRhdGUuZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uaXMgPSBpcztcbn0pKENoYW5nZUFubm90YXRpb24gfHwgKENoYW5nZUFubm90YXRpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcjtcbihmdW5jdGlvbiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLnN0cmluZyhjYW5kaWRhdGUpO1xuICAgIH1cbiAgICBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgfHwgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyID0ge30pKTtcbmV4cG9ydCB2YXIgQW5ub3RhdGVkVGV4dEVkaXQ7XG4oZnVuY3Rpb24gKEFubm90YXRlZFRleHRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgcmVwbGFjZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlID0gcmVwbGFjZTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHRleHQgYXQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIHRleHQgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlOiB7IHN0YXJ0OiBwb3NpdGlvbiwgZW5kOiBwb3NpdGlvbiB9LCBuZXdUZXh0LCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgZGVsZXRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWwocmFuZ2UsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQ6ICcnLCBhbm5vdGF0aW9uSWQ6IGFubm90YXRpb24gfTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuZGVsID0gZGVsO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gVGV4dEVkaXQuaXMoY2FuZGlkYXRlKSAmJiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LmlzID0gaXM7XG59KShBbm5vdGF0ZWRUZXh0RWRpdCB8fCAoQW5ub3RhdGVkVGV4dEVkaXQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50RWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZVxuICogYW4gZWRpdCB0aGF0IG1hbmlwdWxhdGVzIGEgdGV4dCBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRFZGl0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVGV4dERvY3VtZW50RWRpdGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGV4dERvY3VtZW50LCBlZGl0cykge1xuICAgICAgICByZXR1cm4geyB0ZXh0RG9jdW1lbnQsIGVkaXRzIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS50ZXh0RG9jdW1lbnQpXG4gICAgICAgICAgICAmJiBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5lZGl0cyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudEVkaXQuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudEVkaXQgfHwgKFRleHREb2N1bWVudEVkaXQgPSB7fSkpO1xuZXhwb3J0IHZhciBDcmVhdGVGaWxlO1xuKGZ1bmN0aW9uIChDcmVhdGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2NyZWF0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ3JlYXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnY3JlYXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQ3JlYXRlRmlsZS5pcyA9IGlzO1xufSkoQ3JlYXRlRmlsZSB8fCAoQ3JlYXRlRmlsZSA9IHt9KSk7XG5leHBvcnQgdmFyIFJlbmFtZUZpbGU7XG4oZnVuY3Rpb24gKFJlbmFtZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdyZW5hbWUnLFxuICAgICAgICAgICAgb2xkVXJpLFxuICAgICAgICAgICAgbmV3VXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMub3ZlcndyaXRlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZkV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ3JlbmFtZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5vbGRVcmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBSZW5hbWVGaWxlLmlzID0gaXM7XG59KShSZW5hbWVGaWxlIHx8IChSZW5hbWVGaWxlID0ge30pKTtcbmV4cG9ydCB2YXIgRGVsZXRlRmlsZTtcbihmdW5jdGlvbiAoRGVsZXRlRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIG9wdGlvbnMsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIGtpbmQ6ICdkZWxldGUnLFxuICAgICAgICAgICAgdXJpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgKG9wdGlvbnMucmVjdXJzaXZlICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cyAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgcmVzdWx0Lm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbm5vdGF0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5hbm5vdGF0aW9uSWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUua2luZCA9PT0gJ2RlbGV0ZScgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLnJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZk5vdEV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIERlbGV0ZUZpbGUuaXMgPSBpcztcbn0pKERlbGV0ZUZpbGUgfHwgKERlbGV0ZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBXb3Jrc3BhY2VFZGl0O1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VFZGl0KSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoYW5nZXMgIT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMuZXZlcnkoKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChJcy5zdHJpbmcoY2hhbmdlLmtpbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDcmVhdGVGaWxlLmlzKGNoYW5nZSkgfHwgUmVuYW1lRmlsZS5pcyhjaGFuZ2UpIHx8IERlbGV0ZUZpbGUuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBUZXh0RG9jdW1lbnRFZGl0LmlzKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiAgICBXb3Jrc3BhY2VFZGl0LmlzID0gaXM7XG59KShXb3Jrc3BhY2VFZGl0IHx8IChXb3Jrc3BhY2VFZGl0ID0ge30pKTtcbmNsYXNzIFRleHRFZGl0Q2hhbmdlSW1wbCB7XG4gICAgY29uc3RydWN0b3IoZWRpdHMsIGNoYW5nZUFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuZWRpdHMgPSBlZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyA9IGNoYW5nZUFubm90YXRpb25zO1xuICAgIH1cbiAgICBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh0aGlzLmNoYW5nZUFubm90YXRpb25zKTtcbiAgICAgICAgICAgIGlkID0gdGhpcy5jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0LCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGVkaXQ7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZWRpdCA9IFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZShyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuZGVsKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwocmFuZ2UsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKGVkaXQpIHtcbiAgICAgICAgdGhpcy5lZGl0cy5wdXNoKGVkaXQpO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRzO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5lZGl0cy5zcGxpY2UoMCwgdGhpcy5lZGl0cy5sZW5ndGgpO1xuICAgIH1cbiAgICBhc3NlcnRDaGFuZ2VBbm5vdGF0aW9ucyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUZXh0IGVkaXQgY2hhbmdlIGlzIG5vdCBjb25maWd1cmVkIHRvIG1hbmFnZSBjaGFuZ2UgYW5ub3RhdGlvbnMuYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgaGVscGVyIGNsYXNzXG4gKi9cbmNsYXNzIENoYW5nZUFubm90YXRpb25zIHtcbiAgICBjb25zdHJ1Y3Rvcihhbm5vdGF0aW9ucykge1xuICAgICAgICB0aGlzLl9hbm5vdGF0aW9ucyA9IGFubm90YXRpb25zID09PSB1bmRlZmluZWQgPyBPYmplY3QuY3JlYXRlKG51bGwpIDogYW5ub3RhdGlvbnM7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgbWFuYWdlKGlkT3JBbm5vdGF0aW9uLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGlkT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gdGhpcy5uZXh0SWQoKTtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBpZE9yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW5ub3RhdGlvbnNbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSWQgJHtpZH0gaXMgYWxyZWFkeSBpbiB1c2UuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBhbm5vdGF0aW9uIHByb3ZpZGVkIGZvciBpZCAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zW2lkXSA9IGFubm90YXRpb247XG4gICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBuZXh0SWQoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvdW50ZXIudG9TdHJpbmcoKTtcbiAgICB9XG59XG4vKipcbiAqIEEgd29ya3NwYWNlIGNoYW5nZSBoZWxwcyBjb25zdHJ1Y3RpbmcgY2hhbmdlcyB0byBhIHdvcmtzcGFjZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtzcGFjZUNoYW5nZSB7XG4gICAgY29uc3RydWN0b3Iod29ya3NwYWNlRWRpdCkge1xuICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBpZiAod29ya3NwYWNlRWRpdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0gd29ya3NwYWNlRWRpdDtcbiAgICAgICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgICAgICB3b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5mb3JFYWNoKChjaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEVkaXRDaGFuZ2UgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGNoYW5nZS5lZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2NoYW5nZS50ZXh0RG9jdW1lbnQudXJpXSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3b3Jrc3BhY2VFZGl0LmNoYW5nZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwod29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHRleHRFZGl0Q2hhbmdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVuZGVybHlpbmcge0BsaW5rIFdvcmtzcGFjZUVkaXR9IGxpdGVyYWxcbiAgICAgKiB1c2UgdG8gYmUgcmV0dXJuZWQgZnJvbSBhIHdvcmtzcGFjZSBlZGl0IG9wZXJhdGlvbiBsaWtlIHJlbmFtZS5cbiAgICAgKi9cbiAgICBnZXQgZWRpdCgpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZUFubm90YXRpb25zID0gdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMuYWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmtzcGFjZUVkaXQ7XG4gICAgfVxuICAgIGdldFRleHRFZGl0Q2hhbmdlKGtleSkge1xuICAgICAgICBpZiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50ID0geyB1cmk6IGtleS51cmksIHZlcnNpb246IGtleS52ZXJzaW9uIH07XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHREb2N1bWVudEVkaXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZWRpdHNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2godGV4dERvY3VtZW50RWRpdCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cywgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1t0ZXh0RG9jdW1lbnQudXJpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBub3JtYWwgdGV4dCBlZGl0IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxldCBlZGl0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlc1trZXldID0gZWRpdHM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbChlZGl0cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW2tleV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXREb2N1bWVudENoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyA9IG5ldyBDaGFuZ2VBbm5vdGF0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IENyZWF0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5hbWVGaWxlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBSZW5hbWVGaWxlLmNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUodXJpLCBvcHRpb25zT3JBbm5vdGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdERvY3VtZW50Q2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3Jrc3BhY2UgZWRpdCBpcyBub3QgY29uZmlndXJlZCBmb3IgZG9jdW1lbnQgY2hhbmdlcy4nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKENoYW5nZUFubm90YXRpb24uaXMob3B0aW9uc09yQW5ub3RhdGlvbikgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMob3B0aW9uc09yQW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGFubm90YXRpb24gPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wZXJhdGlvbjtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSA/IGFubm90YXRpb24gOiB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5tYW5hZ2UoYW5ub3RhdGlvbik7XG4gICAgICAgICAgICBvcGVyYXRpb24gPSBEZWxldGVGaWxlLmNyZWF0ZSh1cmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRJZGVudGlmaWVyIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudElkZW50aWZpZXIpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgdmVyc2lvbikge1xuICAgICAgICByZXR1cm4geyB1cmksIHZlcnNpb24gfTtcbiAgICB9XG4gICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKTtcbiAgICB9XG4gICAgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciA9IHt9KSk7XG4vKipcbiAqIFRoZSBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXI7XG4oZnVuY3Rpb24gKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLnZlcnNpb24gPT09IG51bGwgfHwgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikpO1xuICAgIH1cbiAgICBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciB8fCAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIFRleHREb2N1bWVudEl0ZW0gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SXRlbTtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SXRlbSBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIHRleHQgVGhlIGRvY3VtZW50J3MgdGV4dC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgdGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFRleHREb2N1bWVudEl0ZW19IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgJiYgSXMuaW50ZWdlcihjYW5kaWRhdGUudmVyc2lvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50SXRlbS5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50SXRlbSB8fCAoVGV4dERvY3VtZW50SXRlbSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgY29udGVudCB0eXBlIHRoYXQgYSBjbGllbnQgc3VwcG9ydHMgaW4gdmFyaW91c1xuICogcmVzdWx0IGxpdGVyYWxzIGxpa2UgYEhvdmVyYCwgYFBhcmFtZXRlckluZm9gIG9yIGBDb21wbGV0aW9uSXRlbWAuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCBgTWFya3VwS2luZHNgIG11c3Qgbm90IHN0YXJ0IHdpdGggYSBgJGAuIFRoaXMga2luZHNcbiAqIGFyZSByZXNlcnZlZCBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gKi9cbmV4cG9ydCB2YXIgTWFya3VwS2luZDtcbihmdW5jdGlvbiAoTWFya3VwS2luZCkge1xuICAgIC8qKlxuICAgICAqIFBsYWluIHRleHQgaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLlBsYWluVGV4dCA9ICdwbGFpbnRleHQnO1xuICAgIC8qKlxuICAgICAqIE1hcmtkb3duIGlzIHN1cHBvcnRlZCBhcyBhIGNvbnRlbnQgZm9ybWF0XG4gICAgICovXG4gICAgTWFya3VwS2luZC5NYXJrZG93biA9ICdtYXJrZG93bic7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsdWUgb2YgdGhlIHtAbGluayBNYXJrdXBLaW5kfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlID09PSBNYXJrdXBLaW5kLlBsYWluVGV4dCB8fCBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuTWFya2Rvd247XG4gICAgfVxuICAgIE1hcmt1cEtpbmQuaXMgPSBpcztcbn0pKE1hcmt1cEtpbmQgfHwgKE1hcmt1cEtpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBNYXJrdXBDb250ZW50O1xuKGZ1bmN0aW9uIChNYXJrdXBDb250ZW50KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya3VwQ29udGVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbCh2YWx1ZSkgJiYgTWFya3VwS2luZC5pcyhjYW5kaWRhdGUua2luZCkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIE1hcmt1cENvbnRlbnQuaXMgPSBpcztcbn0pKE1hcmt1cENvbnRlbnQgfHwgKE1hcmt1cENvbnRlbnQgPSB7fSkpO1xuLyoqXG4gKiBUaGUga2luZCBvZiBhIGNvbXBsZXRpb24gZW50cnkuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1LaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUtpbmQpIHtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCA9IDE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1ldGhvZCA9IDI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uID0gMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RydWN0b3IgPSA0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5GaWVsZCA9IDU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlID0gNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ2xhc3MgPSA3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5JbnRlcmZhY2UgPSA4O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgPSA5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Qcm9wZXJ0eSA9IDEwO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ID0gMTE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlZhbHVlID0gMTI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gPSAxMztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZCA9IDE0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5TbmlwcGV0ID0gMTU7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbG9yID0gMTY7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGUgPSAxNztcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuUmVmZXJlbmNlID0gMTg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZvbGRlciA9IDE5O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FbnVtTWVtYmVyID0gMjA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0YW50ID0gMjE7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCA9IDIyO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCA9IDIzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5PcGVyYXRvciA9IDI0O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyID0gMjU7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG4vKipcbiAqIERlZmluZXMgd2hldGhlciB0aGUgaW5zZXJ0IHRleHQgaW4gYSBjb21wbGV0aW9uIGl0ZW0gc2hvdWxkIGJlIGludGVycHJldGVkIGFzXG4gKiBwbGFpbiB0ZXh0IG9yIGEgc25pcHBldC5cbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRUZXh0Rm9ybWF0O1xuKGZ1bmN0aW9uIChJbnNlcnRUZXh0Rm9ybWF0KSB7XG4gICAgLyoqXG4gICAgICogVGhlIHByaW1hcnkgdGV4dCB0byBiZSBpbnNlcnRlZCBpcyB0cmVhdGVkIGFzIGEgcGxhaW4gc3RyaW5nLlxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuUGxhaW5UZXh0ID0gMTtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBzbmlwcGV0LlxuICAgICAqXG4gICAgICogQSBzbmlwcGV0IGNhbiBkZWZpbmUgdGFiIHN0b3BzIGFuZCBwbGFjZWhvbGRlcnMgd2l0aCBgJDFgLCBgJDJgXG4gICAgICogYW5kIGAkezM6Zm9vfWAuIGAkMGAgZGVmaW5lcyB0aGUgZmluYWwgdGFiIHN0b3AsIGl0IGRlZmF1bHRzIHRvXG4gICAgICogdGhlIGVuZCBvZiB0aGUgc25pcHBldC4gUGxhY2Vob2xkZXJzIHdpdGggZXF1YWwgaWRlbnRpZmllcnMgYXJlIGxpbmtlZCxcbiAgICAgKiB0aGF0IGlzIHR5cGluZyBpbiBvbmUgd2lsbCB1cGRhdGUgb3RoZXJzIHRvby5cbiAgICAgKlxuICAgICAqIFNlZSBhbHNvOiBodHRwczovL21pY3Jvc29mdC5naXRodWIuaW8vbGFuZ3VhZ2Utc2VydmVyLXByb3RvY29sL3NwZWNpZmljYXRpb25zL3NwZWNpZmljYXRpb24tY3VycmVudC8jc25pcHBldF9zeW50YXhcbiAgICAgKi9cbiAgICBJbnNlcnRUZXh0Rm9ybWF0LlNuaXBwZXQgPSAyO1xufSkoSW5zZXJ0VGV4dEZvcm1hdCB8fCAoSW5zZXJ0VGV4dEZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIENvbXBsZXRpb24gaXRlbSB0YWdzIGFyZSBleHRyYSBhbm5vdGF0aW9ucyB0aGF0IHR3ZWFrIHRoZSByZW5kZXJpbmcgb2YgYSBjb21wbGV0aW9uXG4gKiBpdGVtLlxuICpcbiAqIEBzaW5jZSAzLjE1LjBcbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbVRhZztcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1UYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBjb21wbGV0aW9uIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbVRhZy5EZXByZWNhdGVkID0gMTtcbn0pKENvbXBsZXRpb25JdGVtVGFnIHx8IChDb21wbGV0aW9uSXRlbVRhZyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbnNlcnRSZXBsYWNlRWRpdCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBpbnNlcnQgLyByZXBsYWNlIGVkaXRzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBJbnNlcnRSZXBsYWNlRWRpdDtcbihmdW5jdGlvbiAoSW5zZXJ0UmVwbGFjZUVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc2VydCAvIHJlcGxhY2UgZWRpdFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UpIHtcbiAgICAgICAgcmV0dXJuIHsgbmV3VGV4dCwgaW5zZXJ0LCByZXBsYWNlIH07XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEluc2VydFJlcGxhY2VFZGl0fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdUZXh0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUuaW5zZXJ0KSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmVwbGFjZSk7XG4gICAgfVxuICAgIEluc2VydFJlcGxhY2VFZGl0LmlzID0gaXM7XG59KShJbnNlcnRSZXBsYWNlRWRpdCB8fCAoSW5zZXJ0UmVwbGFjZUVkaXQgPSB7fSkpO1xuLyoqXG4gKiBIb3cgd2hpdGVzcGFjZSBhbmQgaW5kZW50YXRpb24gaXMgaGFuZGxlZCBkdXJpbmcgY29tcGxldGlvblxuICogaXRlbSBpbnNlcnRpb24uXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIEluc2VydFRleHRNb2RlO1xuKGZ1bmN0aW9uIChJbnNlcnRUZXh0TW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnNlcnRpb24gb3IgcmVwbGFjZSBzdHJpbmdzIGlzIHRha2VuIGFzIGl0IGlzLiBJZiB0aGVcbiAgICAgKiB2YWx1ZSBpcyBtdWx0aSBsaW5lIHRoZSBsaW5lcyBiZWxvdyB0aGUgY3Vyc29yIHdpbGwgYmVcbiAgICAgKiBpbnNlcnRlZCB1c2luZyB0aGUgaW5kZW50YXRpb24gZGVmaW5lZCBpbiB0aGUgc3RyaW5nIHZhbHVlLlxuICAgICAqIFRoZSBjbGllbnQgd2lsbCBub3QgYXBwbHkgYW55IGtpbmQgb2YgYWRqdXN0bWVudHMgdG8gdGhlXG4gICAgICogc3RyaW5nLlxuICAgICAqL1xuICAgIEluc2VydFRleHRNb2RlLmFzSXMgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBlZGl0b3IgYWRqdXN0cyBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgbmV3IGxpbmVzIHNvIHRoYXRcbiAgICAgKiB0aGV5IG1hdGNoIHRoZSBpbmRlbnRhdGlvbiB1cCB0byB0aGUgY3Vyc29yIG9mIHRoZSBsaW5lIGZvclxuICAgICAqIHdoaWNoIHRoZSBpdGVtIGlzIGFjY2VwdGVkLlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgYSBsaW5lIGxpa2UgdGhpczogPDJ0YWJzPjxjdXJzb3I+PDN0YWJzPmZvby4gQWNjZXB0aW5nIGFcbiAgICAgKiBtdWx0aSBsaW5lIGNvbXBsZXRpb24gaXRlbSBpcyBpbmRlbnRlZCB1c2luZyAyIHRhYnMgYW5kIGFsbFxuICAgICAqIGZvbGxvd2luZyBsaW5lcyBpbnNlcnRlZCB3aWxsIGJlIGluZGVudGVkIHVzaW5nIDIgdGFicyBhcyB3ZWxsLlxuICAgICAqL1xuICAgIEluc2VydFRleHRNb2RlLmFkanVzdEluZGVudGF0aW9uID0gMjtcbn0pKEluc2VydFRleHRNb2RlIHx8IChJbnNlcnRUZXh0TW9kZSA9IHt9KSk7XG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscykge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkgfHwgY2FuZGlkYXRlLmRldGFpbCA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMuaXMgPSBpcztcbn0pKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzIHx8IChDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscyA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb21wbGV0aW9uSXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aFxuICogY29tcGxldGlvbiBpdGVtcy5cbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbTtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW0pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21wbGV0aW9uIGl0ZW0gYW5kIHNlZWQgaXQgd2l0aCBhIGxhYmVsLlxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgY29tcGxldGlvbiBpdGVtJ3MgbGFiZWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIHsgbGFiZWwgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW0uY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkl0ZW0gfHwgKENvbXBsZXRpb25JdGVtID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25MaXN0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGxpc3RzLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uTGlzdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY29tcGxldGlvbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBjb21wbGV0aW9uIGl0ZW1zLlxuICAgICAqIEBwYXJhbSBpc0luY29tcGxldGUgVGhlIGxpc3QgaXMgbm90IGNvbXBsZXRlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcywgaXNJbmNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB7IGl0ZW1zOiBpdGVtcyA/IGl0ZW1zIDogW10sIGlzSW5jb21wbGV0ZTogISFpc0luY29tcGxldGUgfTtcbiAgICB9XG4gICAgQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoQ29tcGxldGlvbkxpc3QgfHwgKENvbXBsZXRpb25MaXN0ID0ge30pKTtcbmV4cG9ydCB2YXIgTWFya2VkU3RyaW5nO1xuKGZ1bmN0aW9uIChNYXJrZWRTdHJpbmcpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbWFya2VkIHN0cmluZyBmcm9tIHBsYWluIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGxhaW5UZXh0IFRoZSBwbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QbGFpblRleHQocGxhaW5UZXh0KSB7XG4gICAgICAgIHJldHVybiBwbGFpblRleHQucmVwbGFjZSgvW1xcXFxgKl97fVtcXF0oKSMrXFwtLiFdL2csICdcXFxcJCYnKTsgLy8gZXNjYXBlIG1hcmtkb3duIHN5bnRheCB0b2tlbnM6IGh0dHA6Ly9kYXJpbmdmaXJlYmFsbC5uZXQvcHJvamVjdHMvbWFya2Rvd24vc3ludGF4I2JhY2tzbGFzaFxuICAgIH1cbiAgICBNYXJrZWRTdHJpbmcuZnJvbVBsYWluVGV4dCA9IGZyb21QbGFpblRleHQ7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgTWFya2VkU3RyaW5nfSB0eXBlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSkgfHwgKElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKSk7XG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5pcyA9IGlzO1xufSkoTWFya2VkU3RyaW5nIHx8IChNYXJrZWRTdHJpbmcgPSB7fSkpO1xuZXhwb3J0IHZhciBIb3ZlcjtcbihmdW5jdGlvbiAoSG92ZXIpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBIb3Zlcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuICEhY2FuZGlkYXRlICYmIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBNYXJrZWRTdHJpbmcuaXMoY2FuZGlkYXRlLmNvbnRlbnRzKSB8fFxuICAgICAgICAgICAgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuY29udGVudHMsIE1hcmtlZFN0cmluZy5pcykpICYmICh2YWx1ZS5yYW5nZSA9PT0gdW5kZWZpbmVkIHx8IFJhbmdlLmlzKHZhbHVlLnJhbmdlKSk7XG4gICAgfVxuICAgIEhvdmVyLmlzID0gaXM7XG59KShIb3ZlciB8fCAoSG92ZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgUGFyYW1ldGVySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgUGFyYW1ldGVySW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFBhcmFtZXRlckluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChQYXJhbWV0ZXJJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcGFyYW1ldGVyIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGFiZWwgQSBsYWJlbCBzdHJpbmcuXG4gICAgICogQHBhcmFtIGRvY3VtZW50YXRpb24gQSBkb2Mgc3RyaW5nLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRhdGlvbiA/IHsgbGFiZWwsIGRvY3VtZW50YXRpb24gfSA6IHsgbGFiZWwgfTtcbiAgICB9XG4gICAgUGFyYW1ldGVySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoUGFyYW1ldGVySW5mb3JtYXRpb24gfHwgKFBhcmFtZXRlckluZm9ybWF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIFNpZ25hdHVyZUluZm9ybWF0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFNpZ25hdHVyZUluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTaWduYXR1cmVJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSW5mb3JtYXRpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUobGFiZWwsIGRvY3VtZW50YXRpb24sIC4uLnBhcmFtZXRlcnMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgbGFiZWwgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZG9jdW1lbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kb2N1bWVudGF0aW9uID0gZG9jdW1lbnRhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhcmFtZXRlcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBTaWduYXR1cmVJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShTaWduYXR1cmVJbmZvcm1hdGlvbiB8fCAoU2lnbmF0dXJlSW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kLlRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuUmVhZCA9IDI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuV3JpdGUgPSAzO1xufSkoRG9jdW1lbnRIaWdobGlnaHRLaW5kIHx8IChEb2N1bWVudEhpZ2hsaWdodEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBEb2N1bWVudEhpZ2hsaWdodCBuYW1lc3BhY2UgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERvY3VtZW50SGlnaGxpZ2h0fSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEb2N1bWVudEhpZ2hsaWdodCBvYmplY3QuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSB0aGUgaGlnaGxpZ2h0IGFwcGxpZXMgdG8uXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGhpZ2hsaWdodCBraW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBraW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5udW1iZXIoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudEhpZ2hsaWdodC5jcmVhdGUgPSBjcmVhdGU7XG59KShEb2N1bWVudEhpZ2hsaWdodCB8fCAoRG9jdW1lbnRIaWdobGlnaHQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG5leHBvcnQgdmFyIFN5bWJvbEtpbmQ7XG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcbiAgICBTeW1ib2xLaW5kLkZpbGUgPSAxO1xuICAgIFN5bWJvbEtpbmQuTW9kdWxlID0gMjtcbiAgICBTeW1ib2xLaW5kLk5hbWVzcGFjZSA9IDM7XG4gICAgU3ltYm9sS2luZC5QYWNrYWdlID0gNDtcbiAgICBTeW1ib2xLaW5kLkNsYXNzID0gNTtcbiAgICBTeW1ib2xLaW5kLk1ldGhvZCA9IDY7XG4gICAgU3ltYm9sS2luZC5Qcm9wZXJ0eSA9IDc7XG4gICAgU3ltYm9sS2luZC5GaWVsZCA9IDg7XG4gICAgU3ltYm9sS2luZC5Db25zdHJ1Y3RvciA9IDk7XG4gICAgU3ltYm9sS2luZC5FbnVtID0gMTA7XG4gICAgU3ltYm9sS2luZC5JbnRlcmZhY2UgPSAxMTtcbiAgICBTeW1ib2xLaW5kLkZ1bmN0aW9uID0gMTI7XG4gICAgU3ltYm9sS2luZC5WYXJpYWJsZSA9IDEzO1xuICAgIFN5bWJvbEtpbmQuQ29uc3RhbnQgPSAxNDtcbiAgICBTeW1ib2xLaW5kLlN0cmluZyA9IDE1O1xuICAgIFN5bWJvbEtpbmQuTnVtYmVyID0gMTY7XG4gICAgU3ltYm9sS2luZC5Cb29sZWFuID0gMTc7XG4gICAgU3ltYm9sS2luZC5BcnJheSA9IDE4O1xuICAgIFN5bWJvbEtpbmQuT2JqZWN0ID0gMTk7XG4gICAgU3ltYm9sS2luZC5LZXkgPSAyMDtcbiAgICBTeW1ib2xLaW5kLk51bGwgPSAyMTtcbiAgICBTeW1ib2xLaW5kLkVudW1NZW1iZXIgPSAyMjtcbiAgICBTeW1ib2xLaW5kLlN0cnVjdCA9IDIzO1xuICAgIFN5bWJvbEtpbmQuRXZlbnQgPSAyNDtcbiAgICBTeW1ib2xLaW5kLk9wZXJhdG9yID0gMjU7XG4gICAgU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyID0gMjY7XG59KShTeW1ib2xLaW5kIHx8IChTeW1ib2xLaW5kID0ge30pKTtcbi8qKlxuICogU3ltYm9sIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIHN5bWJvbC5cbiAqXG4gKiBAc2luY2UgMy4xNlxuICovXG5leHBvcnQgdmFyIFN5bWJvbFRhZztcbihmdW5jdGlvbiAoU3ltYm9sVGFnKSB7XG4gICAgLyoqXG4gICAgICogUmVuZGVyIGEgc3ltYm9sIGFzIG9ic29sZXRlLCB1c3VhbGx5IHVzaW5nIGEgc3RyaWtlLW91dC5cbiAgICAgKi9cbiAgICBTeW1ib2xUYWcuRGVwcmVjYXRlZCA9IDE7XG59KShTeW1ib2xUYWcgfHwgKFN5bWJvbFRhZyA9IHt9KSk7XG5leHBvcnQgdmFyIFN5bWJvbEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTeW1ib2xJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2Ygc3ltYm9sLlxuICAgICAqIEBwYXJhbSBjb250YWluZXJOYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wgY29udGFpbmluZyB0aGUgc3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCByYW5nZSwgdXJpLCBjb250YWluZXJOYW1lKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7IHVyaSwgcmFuZ2UgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udGFpbmVyTmFtZSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbnRhaW5lck5hbWUgPSBjb250YWluZXJOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFN5bWJvbEluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFN5bWJvbEluZm9ybWF0aW9uIHx8IChTeW1ib2xJbmZvcm1hdGlvbiA9IHt9KSk7XG5leHBvcnQgdmFyIFdvcmtzcGFjZVN5bWJvbDtcbihmdW5jdGlvbiAoV29ya3NwYWNlU3ltYm9sKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdvcmtzcGFjZSBzeW1ib2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgcmVzb3VyY2Ugb2YgdGhlIGxvY2F0aW9uIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIEFuIG9wdGlvbnMgcmFuZ2Ugb2YgdGhlIGxvY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgV29ya3NwYWNlU3ltYm9sLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShuYW1lLCBraW5kLCB1cmksIHJhbmdlKSB7XG4gICAgICAgIHJldHVybiByYW5nZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHsgbmFtZSwga2luZCwgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9IH1cbiAgICAgICAgICAgIDogeyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmkgfSB9O1xuICAgIH1cbiAgICBXb3Jrc3BhY2VTeW1ib2wuY3JlYXRlID0gY3JlYXRlO1xufSkoV29ya3NwYWNlU3ltYm9sIHx8IChXb3Jrc3BhY2VTeW1ib2wgPSB7fSkpO1xuZXhwb3J0IHZhciBEb2N1bWVudFN5bWJvbDtcbihmdW5jdGlvbiAoRG9jdW1lbnRTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHN5bWJvbCBpbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gZGV0YWlsIFRoZSBkZXRhaWwgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUga2luZCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gc2VsZWN0aW9uUmFuZ2UgVGhlIHNlbGVjdGlvblJhbmdlIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIENoaWxkcmVuIG9mIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGRldGFpbCwga2luZCwgcmFuZ2UsIHNlbGVjdGlvblJhbmdlLCBjaGlsZHJlbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRldGFpbCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudFN5bWJvbH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJlxuICAgICAgICAgICAgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJiBJcy5udW1iZXIoY2FuZGlkYXRlLmtpbmQpICYmXG4gICAgICAgICAgICBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5zZWxlY3Rpb25SYW5nZSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXRhaWwpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXByZWNhdGVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuZGVwcmVjYXRlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNoaWxkcmVuID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuY2hpbGRyZW4pKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS50YWdzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUudGFncykpO1xuICAgIH1cbiAgICBEb2N1bWVudFN5bWJvbC5pcyA9IGlzO1xufSkoRG9jdW1lbnRTeW1ib2wgfHwgKERvY3VtZW50U3ltYm9sID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCBjb2RlIGFjdGlvbiBraW5kc1xuICovXG5leHBvcnQgdmFyIENvZGVBY3Rpb25LaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uS2luZCkge1xuICAgIC8qKlxuICAgICAqIEVtcHR5IGtpbmQuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuRW1wdHkgPSAnJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHF1aWNrZml4IGFjdGlvbnM6ICdxdWlja2ZpeCdcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5RdWlja0ZpeCA9ICdxdWlja2ZpeCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBhY3Rpb25zOiAncmVmYWN0b3InXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3IgPSAncmVmYWN0b3InO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgZXh0cmFjdGlvbiBhY3Rpb25zOiAncmVmYWN0b3IuZXh0cmFjdCdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgZXh0cmFjdCBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBFeHRyYWN0IG1ldGhvZFxuICAgICAqIC0gRXh0cmFjdCBmdW5jdGlvblxuICAgICAqIC0gRXh0cmFjdCB2YXJpYWJsZVxuICAgICAqIC0gRXh0cmFjdCBpbnRlcmZhY2UgZnJvbSBjbGFzc1xuICAgICAqIC0gLi4uXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuUmVmYWN0b3JFeHRyYWN0ID0gJ3JlZmFjdG9yLmV4dHJhY3QnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgaW5saW5lIGFjdGlvbnM6ICdyZWZhY3Rvci5pbmxpbmUnXG4gICAgICpcbiAgICAgKiBFeGFtcGxlIGlubGluZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBJbmxpbmUgZnVuY3Rpb25cbiAgICAgKiAtIElubGluZSB2YXJpYWJsZVxuICAgICAqIC0gSW5saW5lIGNvbnN0YW50XG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvcklubGluZSA9ICdyZWZhY3Rvci5pbmxpbmUnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcmVmYWN0b3JpbmcgcmV3cml0ZSBhY3Rpb25zOiAncmVmYWN0b3IucmV3cml0ZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgcmV3cml0ZSBhY3Rpb25zOlxuICAgICAqXG4gICAgICogLSBDb252ZXJ0IEphdmFTY3JpcHQgZnVuY3Rpb24gdG8gY2xhc3NcbiAgICAgKiAtIEFkZCBvciByZW1vdmUgcGFyYW1ldGVyXG4gICAgICogLSBFbmNhcHN1bGF0ZSBmaWVsZFxuICAgICAqIC0gTWFrZSBtZXRob2Qgc3RhdGljXG4gICAgICogLSBNb3ZlIG1ldGhvZCB0byBiYXNlIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvclJld3JpdGUgPSAncmVmYWN0b3IucmV3cml0ZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBzb3VyY2UgYWN0aW9uczogYHNvdXJjZWBcbiAgICAgKlxuICAgICAqIFNvdXJjZSBjb2RlIGFjdGlvbnMgYXBwbHkgdG8gdGhlIGVudGlyZSBmaWxlLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZSA9ICdzb3VyY2UnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgYW4gb3JnYW5pemUgaW1wb3J0cyBzb3VyY2UgYWN0aW9uOiBgc291cmNlLm9yZ2FuaXplSW1wb3J0c2BcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5Tb3VyY2VPcmdhbml6ZUltcG9ydHMgPSAnc291cmNlLm9yZ2FuaXplSW1wb3J0cyc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhdXRvLWZpeCBzb3VyY2UgYWN0aW9uczogYHNvdXJjZS5maXhBbGxgLlxuICAgICAqXG4gICAgICogRml4IGFsbCBhY3Rpb25zIGF1dG9tYXRpY2FsbHkgZml4IGVycm9ycyB0aGF0IGhhdmUgYSBjbGVhciBmaXggdGhhdCBkbyBub3QgcmVxdWlyZSB1c2VyIGlucHV0LlxuICAgICAqIFRoZXkgc2hvdWxkIG5vdCBzdXBwcmVzcyBlcnJvcnMgb3IgcGVyZm9ybSB1bnNhZmUgZml4ZXMgc3VjaCBhcyBnZW5lcmF0aW5nIG5ldyB0eXBlcyBvciBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHNpbmNlIDMuMTUuMFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZUZpeEFsbCA9ICdzb3VyY2UuZml4QWxsJztcbn0pKENvZGVBY3Rpb25LaW5kIHx8IChDb2RlQWN0aW9uS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSByZWFzb24gd2h5IGNvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZC5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgQ29kZUFjdGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb2RlIGFjdGlvbnMgd2VyZSBleHBsaWNpdGx5IHJlcXVlc3RlZCBieSB0aGUgdXNlciBvciBieSBhbiBleHRlbnNpb24uXG4gICAgICovXG4gICAgQ29kZUFjdGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAxO1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIHJlcXVlc3RlZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogVGhpcyB0eXBpY2FsbHkgaGFwcGVucyB3aGVuIGN1cnJlbnQgc2VsZWN0aW9uIGluIGEgZmlsZSBjaGFuZ2VzLCBidXQgY2FuXG4gICAgICogYWxzbyBiZSB0cmlnZ2VyZWQgd2hlbiBmaWxlIGNvbnRlbnQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljID0gMjtcbn0pKENvZGVBY3Rpb25UcmlnZ2VyS2luZCB8fCAoQ29kZUFjdGlvblRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVBY3Rpb25Db250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVBY3Rpb25Db250ZXh0fSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlQWN0aW9uQ29udGV4dDtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbkNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVBY3Rpb25Db250ZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGRpYWdub3N0aWNzLCBvbmx5LCB0cmlnZ2VyS2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBkaWFnbm9zdGljcyB9O1xuICAgICAgICBpZiAob25seSAhPT0gdW5kZWZpbmVkICYmIG9ubHkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vbmx5ID0gb25seTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlcktpbmQgIT09IHVuZGVmaW5lZCAmJiB0cmlnZ2VyS2luZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0LnRyaWdnZXJLaW5kID0gdHJpZ2dlcktpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbkNvbnRleHQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLm9ubHkgPT09IHVuZGVmaW5lZCB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5vbmx5LCBJcy5zdHJpbmcpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS50cmlnZ2VyS2luZCA9PT0gQ29kZUFjdGlvblRyaWdnZXJLaW5kLkludm9rZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuQXV0b21hdGljKTtcbiAgICB9XG4gICAgQ29kZUFjdGlvbkNvbnRleHQuaXMgPSBpcztcbn0pKENvZGVBY3Rpb25Db250ZXh0IHx8IChDb2RlQWN0aW9uQ29udGV4dCA9IHt9KSk7XG5leHBvcnQgdmFyIENvZGVBY3Rpb247XG4oZnVuY3Rpb24gKENvZGVBY3Rpb24pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodGl0bGUsIGtpbmRPckNvbW1hbmRPckVkaXQsIGtpbmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgdGl0bGUgfTtcbiAgICAgICAgbGV0IGNoZWNrS2luZCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2Yga2luZE9yQ29tbWFuZE9yRWRpdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNoZWNrS2luZCA9IGZhbHNlO1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENvbW1hbmQuaXMoa2luZE9yQ29tbWFuZE9yRWRpdCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jb21tYW5kID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5lZGl0ID0ga2luZE9yQ29tbWFuZE9yRWRpdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tLaW5kICYmIGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRpdGxlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kaWFnbm9zdGljcyA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmRpYWdub3N0aWNzLCBEaWFnbm9zdGljLmlzKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUua2luZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgIT09IHVuZGVmaW5lZCB8fCBjYW5kaWRhdGUuY29tbWFuZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmlzUHJlZmVycmVkID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUuaXNQcmVmZXJyZWQpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5lZGl0ID09PSB1bmRlZmluZWQgfHwgV29ya3NwYWNlRWRpdC5pcyhjYW5kaWRhdGUuZWRpdCkpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uLmlzID0gaXM7XG59KShDb2RlQWN0aW9uIHx8IChDb2RlQWN0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVMZW5zIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvZGVMZW5zfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2RlTGVucztcbihmdW5jdGlvbiAoQ29kZUxlbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvZGVMZW5zIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHJhbmdlIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGRhdGEpKSB7XG4gICAgICAgICAgICByZXN1bHQuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUxlbnMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29kZUxlbnN9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5jb21tYW5kKSB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIENvZGVMZW5zLmlzID0gaXM7XG59KShDb2RlTGVucyB8fCAoQ29kZUxlbnMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRm9ybWF0dGluZ09wdGlvbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRm9ybWF0dGluZ09wdGlvbnN9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIEZvcm1hdHRpbmdPcHRpb25zO1xuKGZ1bmN0aW9uIChGb3JtYXR0aW5nT3B0aW9ucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRm9ybWF0dGluZ09wdGlvbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodGFiU2l6ZSwgaW5zZXJ0U3BhY2VzKSB7XG4gICAgICAgIHJldHVybiB7IHRhYlNpemUsIGluc2VydFNwYWNlcyB9O1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUudGFiU2l6ZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuaW5zZXJ0U3BhY2VzKTtcbiAgICB9XG4gICAgRm9ybWF0dGluZ09wdGlvbnMuaXMgPSBpcztcbn0pKEZvcm1hdHRpbmdPcHRpb25zIHx8IChGb3JtYXR0aW5nT3B0aW9ucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBEb2N1bWVudExpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRMaW5rfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudExpbms7XG4oZnVuY3Rpb24gKERvY3VtZW50TGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgRG9jdW1lbnRMaW5rIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0YXJnZXQsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRhcmdldCwgZGF0YSB9O1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRG9jdW1lbnRMaW5rfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGFyZ2V0KSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRhcmdldCkpO1xuICAgIH1cbiAgICBEb2N1bWVudExpbmsuaXMgPSBpcztcbn0pKERvY3VtZW50TGluayB8fCAoRG9jdW1lbnRMaW5rID0ge30pKTtcbi8qKlxuICogVGhlIFNlbGVjdGlvblJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gd29yayB3aXRoXG4gKiBTZWxlY3Rpb25SYW5nZSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBTZWxlY3Rpb25SYW5nZTtcbihmdW5jdGlvbiAoU2VsZWN0aW9uUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFNlbGVjdGlvblJhbmdlXG4gICAgICogQHBhcmFtIHJhbmdlIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0gcGFyZW50IGFuIG9wdGlvbmFsIHBhcmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHBhcmVudCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgcGFyZW50IH07XG4gICAgfVxuICAgIFNlbGVjdGlvblJhbmdlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoY2FuZGlkYXRlLnBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IFNlbGVjdGlvblJhbmdlLmlzKGNhbmRpZGF0ZS5wYXJlbnQpKTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuaXMgPSBpcztcbn0pKFNlbGVjdGlvblJhbmdlIHx8IChTZWxlY3Rpb25SYW5nZSA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gdHlwZXMuIFRoaXMgc2V0IGlzIG5vdCBmaXhlZFxuICogYW4gY2xpZW50cyBjYW4gc3BlY2lmeSBhZGRpdGlvbmFsIHRva2VuIHR5cGVzIHZpYSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgY2xpZW50IGNhcGFiaWxpdGllcy5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgU2VtYW50aWNUb2tlblR5cGVzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuVHlwZXMpIHtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJuYW1lc3BhY2VcIl0gPSBcIm5hbWVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBnZW5lcmljIHR5cGUuIEFjdHMgYXMgYSBmYWxsYmFjayBmb3IgdHlwZXMgd2hpY2ggY2FuJ3QgYmUgbWFwcGVkIHRvXG4gICAgICogYSBzcGVjaWZpYyB0eXBlIGxpa2UgY2xhc3Mgb3IgZW51bS5cbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlXCJdID0gXCJ0eXBlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY2xhc3NcIl0gPSBcImNsYXNzXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZW51bVwiXSA9IFwiZW51bVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImludGVyZmFjZVwiXSA9IFwiaW50ZXJmYWNlXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RydWN0XCJdID0gXCJzdHJ1Y3RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ0eXBlUGFyYW1ldGVyXCJdID0gXCJ0eXBlUGFyYW1ldGVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wicGFyYW1ldGVyXCJdID0gXCJwYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJ2YXJpYWJsZVwiXSA9IFwidmFyaWFibGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwcm9wZXJ0eVwiXSA9IFwicHJvcGVydHlcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtTWVtYmVyXCJdID0gXCJlbnVtTWVtYmVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZXZlbnRcIl0gPSBcImV2ZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiZnVuY3Rpb25cIl0gPSBcImZ1bmN0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibWV0aG9kXCJdID0gXCJtZXRob2RcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtYWNyb1wiXSA9IFwibWFjcm9cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJrZXl3b3JkXCJdID0gXCJrZXl3b3JkXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibW9kaWZpZXJcIl0gPSBcIm1vZGlmaWVyXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiY29tbWVudFwiXSA9IFwiY29tbWVudFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInN0cmluZ1wiXSA9IFwic3RyaW5nXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wibnVtYmVyXCJdID0gXCJudW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJyZWdleHBcIl0gPSBcInJlZ2V4cFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm9wZXJhdG9yXCJdID0gXCJvcGVyYXRvclwiO1xuICAgIC8qKlxuICAgICAqIEBzaW5jZSAzLjE3LjBcbiAgICAgKi9cbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJkZWNvcmF0b3JcIl0gPSBcImRlY29yYXRvclwiO1xufSkoU2VtYW50aWNUb2tlblR5cGVzIHx8IChTZW1hbnRpY1Rva2VuVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIHRva2VuIG1vZGlmaWVycy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzO1xuKGZ1bmN0aW9uIChTZW1hbnRpY1Rva2VuTW9kaWZpZXJzKSB7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlY2xhcmF0aW9uXCJdID0gXCJkZWNsYXJhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWZpbml0aW9uXCJdID0gXCJkZWZpbml0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInJlYWRvbmx5XCJdID0gXCJyZWFkb25seVwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJzdGF0aWNcIl0gPSBcInN0YXRpY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZXByZWNhdGVkXCJdID0gXCJkZXByZWNhdGVkXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFic3RyYWN0XCJdID0gXCJhYnN0cmFjdFwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJhc3luY1wiXSA9IFwiYXN5bmNcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wibW9kaWZpY2F0aW9uXCJdID0gXCJtb2RpZmljYXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZG9jdW1lbnRhdGlvblwiXSA9IFwiZG9jdW1lbnRhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkZWZhdWx0TGlicmFyeVwiXSA9IFwiZGVmYXVsdExpYnJhcnlcIjtcbn0pKFNlbWFudGljVG9rZW5Nb2RpZmllcnMgfHwgKFNlbWFudGljVG9rZW5Nb2RpZmllcnMgPSB7fSkpO1xuLyoqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgU2VtYW50aWNUb2tlbnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5zKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgKGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmVzdWx0SWQgPT09ICdzdHJpbmcnKSAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShjYW5kaWRhdGUuZGF0YSkgJiYgKGNhbmRpZGF0ZS5kYXRhLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgY2FuZGlkYXRlLmRhdGFbMF0gPT09ICdudW1iZXInKTtcbiAgICB9XG4gICAgU2VtYW50aWNUb2tlbnMuaXMgPSBpcztcbn0pKFNlbWFudGljVG9rZW5zIHx8IChTZW1hbnRpY1Rva2VucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVUZXh0cy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lVmFsdWVUZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgdGV4dCB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS50ZXh0KTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVUZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVRleHQgfHwgKElubGluZVZhbHVlVGV4dCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlVmFyaWFibGVMb29rdXBzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwO1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZVRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHZhcmlhYmxlTmFtZSwgY2FzZVNlbnNpdGl2ZUxvb2t1cCkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICE9PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlICE9PSBudWxsICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgSXMuYm9vbGVhbihjYW5kaWRhdGUuY2FzZVNlbnNpdGl2ZUxvb2t1cClcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSkgfHwgY2FuZGlkYXRlLnZhcmlhYmxlTmFtZSA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5pcyA9IGlzO1xufSkoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCB8fCAoSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cCA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb247XG4oZnVuY3Rpb24gKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgZXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgZXhwcmVzc2lvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZXhwcmVzc2lvbikgfHwgY2FuZGlkYXRlLmV4cHJlc3Npb24gPT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiB8fCAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgSW5saW5lVmFsdWVDb250ZXh0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIElubGluZVZhbHVlQ29udGV4dH0gbGl0ZXJhbHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG5leHBvcnQgdmFyIElubGluZVZhbHVlQ29udGV4dDtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVDb250ZXh0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJbmxpbmVWYWx1ZUNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uKSB7XG4gICAgICAgIHJldHVybiB7IGZyYW1lSWQsIHN0b3BwZWRMb2NhdGlvbiB9O1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5saW5lVmFsdWVDb250ZXh0fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXModmFsdWUuc3RvcHBlZExvY2F0aW9uKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVDb250ZXh0LmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZUNvbnRleHQgfHwgKElubGluZVZhbHVlQ29udGV4dCA9IHt9KSk7XG4vKipcbiAqIElubGF5IGhpbnQga2luZHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG5leHBvcnQgdmFyIElubGF5SGludEtpbmQ7XG4oZnVuY3Rpb24gKElubGF5SGludEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgZm9yIGEgdHlwZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuVHlwZSA9IDE7XG4gICAgLyoqXG4gICAgICogQW4gaW5sYXkgaGludCB0aGF0IGlzIGZvciBhIHBhcmFtZXRlci5cbiAgICAgKi9cbiAgICBJbmxheUhpbnRLaW5kLlBhcmFtZXRlciA9IDI7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAxIHx8IHZhbHVlID09PSAyO1xuICAgIH1cbiAgICBJbmxheUhpbnRLaW5kLmlzID0gaXM7XG59KShJbmxheUhpbnRLaW5kIHx8IChJbmxheUhpbnRLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgSW5sYXlIaW50TGFiZWxQYXJ0O1xuKGZ1bmN0aW9uIChJbmxheUhpbnRMYWJlbFBhcnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUgfTtcbiAgICB9XG4gICAgSW5sYXlIaW50TGFiZWxQYXJ0LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUubG9jYXRpb24gPT09IHVuZGVmaW5lZCB8fCBMb2NhdGlvbi5pcyhjYW5kaWRhdGUubG9jYXRpb24pKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5jb21tYW5kID09PSB1bmRlZmluZWQgfHwgQ29tbWFuZC5pcyhjYW5kaWRhdGUuY29tbWFuZCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuaXMgPSBpcztcbn0pKElubGF5SGludExhYmVsUGFydCB8fCAoSW5sYXlIaW50TGFiZWxQYXJ0ID0ge30pKTtcbmV4cG9ydCB2YXIgSW5sYXlIaW50O1xuKGZ1bmN0aW9uIChJbmxheUhpbnQpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUocG9zaXRpb24sIGxhYmVsLCBraW5kKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgcG9zaXRpb24sIGxhYmVsIH07XG4gICAgICAgIGlmIChraW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBJbmxheUhpbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5wb3NpdGlvbilcbiAgICAgICAgICAgICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5sYWJlbCwgSW5sYXlIaW50TGFiZWxQYXJ0LmlzKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUua2luZCA9PT0gdW5kZWZpbmVkIHx8IElubGF5SGludEtpbmQuaXMoY2FuZGlkYXRlLmtpbmQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50ZXh0RWRpdHMgPT09IHVuZGVmaW5lZCkgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUudGV4dEVkaXRzLCBUZXh0RWRpdC5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUudG9vbHRpcCA9PT0gdW5kZWZpbmVkIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudG9vbHRpcCkgfHwgTWFya3VwQ29udGVudC5pcyhjYW5kaWRhdGUudG9vbHRpcCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdMZWZ0ID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUucGFkZGluZ0xlZnQpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nUmlnaHQpKTtcbiAgICB9XG4gICAgSW5sYXlIaW50LmlzID0gaXM7XG59KShJbmxheUhpbnQgfHwgKElubGF5SGludCA9IHt9KSk7XG5leHBvcnQgdmFyIFN0cmluZ1ZhbHVlO1xuKGZ1bmN0aW9uIChTdHJpbmdWYWx1ZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVNuaXBwZXQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHsga2luZDogJ3NuaXBwZXQnLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBTdHJpbmdWYWx1ZS5jcmVhdGVTbmlwcGV0ID0gY3JlYXRlU25pcHBldDtcbn0pKFN0cmluZ1ZhbHVlIHx8IChTdHJpbmdWYWx1ZSA9IHt9KSk7XG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uSXRlbSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCkge1xuICAgICAgICByZXR1cm4geyBpbnNlcnRUZXh0LCBmaWx0ZXJUZXh0LCByYW5nZSwgY29tbWFuZCB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uSXRlbSB8fCAoSW5saW5lQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxpbmVDb21wbGV0aW9uTGlzdDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvbkxpc3QpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRlbXMgfTtcbiAgICB9XG4gICAgSW5saW5lQ29tcGxldGlvbkxpc3QuY3JlYXRlID0gY3JlYXRlO1xufSkoSW5saW5lQ29tcGxldGlvbkxpc3QgfHwgKElubGluZUNvbXBsZXRpb25MaXN0ID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIGhvdyBhbiB7QGxpbmsgSW5saW5lQ29tcGxldGlvbkl0ZW1Qcm92aWRlciBpbmxpbmUgY29tcGxldGlvbiBwcm92aWRlcn0gd2FzIHRyaWdnZXJlZC5cbiAqXG4gKiBAc2luY2UgMy4xOC4wXG4gKiBAcHJvcG9zZWRcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGEgdXNlciBnZXN0dXJlLlxuICAgICAqL1xuICAgIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZC5JbnZva2VkID0gMDtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAqL1xuICAgIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAxO1xufSkoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kIHx8IChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBTZWxlY3RlZENvbXBsZXRpb25JbmZvO1xuKGZ1bmN0aW9uIChTZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIFNlbGVjdGVkQ29tcGxldGlvbkluZm8uY3JlYXRlID0gY3JlYXRlO1xufSkoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB8fCAoU2VsZWN0ZWRDb21wbGV0aW9uSW5mbyA9IHt9KSk7XG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0cmlnZ2VyS2luZCwgc2VsZWN0ZWRDb21wbGV0aW9uSW5mbykge1xuICAgICAgICByZXR1cm4geyB0cmlnZ2VyS2luZCwgc2VsZWN0ZWRDb21wbGV0aW9uSW5mbyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uQ29udGV4dCB8fCAoSW5saW5lQ29tcGxldGlvbkNvbnRleHQgPSB7fSkpO1xuZXhwb3J0IHZhciBXb3Jrc3BhY2VGb2xkZXI7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUZvbGRlcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFVSSS5pcyhjYW5kaWRhdGUudXJpKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpO1xuICAgIH1cbiAgICBXb3Jrc3BhY2VGb2xkZXIuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUZvbGRlciB8fCAoV29ya3NwYWNlRm9sZGVyID0ge30pKTtcbmV4cG9ydCBjb25zdCBFT0wgPSBbJ1xcbicsICdcXHJcXG4nLCAnXFxyJ107XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBJVGV4dERvY3VtZW50IGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gdXJpIGFuZCBjb250ZW50LlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIHZlcnNpb24uXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSVRleHREb2N1bWVudH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUubGFuZ3VhZ2VJZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSkgJiYgSXMudWludGVnZXIoY2FuZGlkYXRlLmxpbmVDb3VudClcbiAgICAgICAgICAgICYmIElzLmZ1bmMoY2FuZGlkYXRlLmdldFRleHQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLnBvc2l0aW9uQXQpICYmIElzLmZ1bmMoY2FuZGlkYXRlLm9mZnNldEF0KSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmlzID0gaXM7XG4gICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgbGV0IHRleHQgPSBkb2N1bWVudC5nZXRUZXh0KCk7XG4gICAgICAgIGxldCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cywgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGxldCBkaWZmID0gYS5yYW5nZS5zdGFydC5saW5lIC0gYi5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5yYW5nZS5zdGFydC5jaGFyYWN0ZXIgLSBiLnJhbmdlLnN0YXJ0LmNoYXJhY3RlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGxhc3RNb2RpZmllZE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gc29ydGVkRWRpdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBlID0gc29ydGVkRWRpdHNbaV07XG4gICAgICAgICAgICBsZXQgc3RhcnRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBlbmRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICBpZiAoZW5kT2Zmc2V0IDw9IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBlLm5ld1RleHQgKyB0ZXh0LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3ZlcmxhcHBpbmcgZWRpdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbiAgICBmdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgLy8gc29ydGVkXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBkYXRhLnNsaWNlKHApO1xuICAgICAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgICAgIGxldCBsZWZ0SWR4ID0gMDtcbiAgICAgICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoICYmIHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICAgICAgaWYgKHJldCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVmdElkeCA8IGxlZnQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHJpZ2h0SWR4IDwgcmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgdGV4dCBkb2N1bWVudCBmcm9tIHRoZSBuZXcgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCBwYWNrYWdlLlxuICovXG5jbGFzcyBGdWxsVGV4dERvY3VtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5fdXJpID0gdXJpO1xuICAgICAgICB0aGlzLl9sYW5ndWFnZUlkID0gbGFuZ3VhZ2VJZDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHVyaSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VyaTtcbiAgICB9XG4gICAgZ2V0IGxhbmd1YWdlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYW5ndWFnZUlkO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb247XG4gICAgfVxuICAgIGdldFRleHQocmFuZ2UpIHtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShldmVudCwgdmVyc2lvbikge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZXZlbnQudGV4dDtcbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRMaW5lT2Zmc2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVPZmZzZXRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHRleHQgPSB0aGlzLl9jb250ZW50O1xuICAgICAgICAgICAgbGV0IGlzTGluZVN0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc0xpbmVTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICBpc0xpbmVTdGFydCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2ggPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpc0xpbmVTdGFydCA9IChjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXG4nKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQXQoaSArIDEpID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2godGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgfVxuICAgIHBvc2l0aW9uQXQob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQb3NpdGlvbi5jcmVhdGUoMCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgbGV0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGxldCBsaW5lID0gbG93IC0gMTtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZShsaW5lLCBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSk7XG4gICAgfVxuICAgIG9mZnNldEF0KHBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lT2Zmc2V0ID0gbGluZU9mZnNldHNbcG9zaXRpb24ubGluZV07XG4gICAgICAgIGxldCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGxpbmVPZmZzZXQgKyBwb3NpdGlvbi5jaGFyYWN0ZXIsIG5leHRMaW5lT2Zmc2V0KSwgbGluZU9mZnNldCk7XG4gICAgfVxuICAgIGdldCBsaW5lQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpbmVPZmZzZXRzKCkubGVuZ3RoO1xuICAgIH1cbn1cbnZhciBJcztcbihmdW5jdGlvbiAoSXMpIHtcbiAgICBjb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgZnVuY3Rpb24gZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgSXMuZGVmaW5lZCA9IGRlZmluZWQ7XG4gICAgZnVuY3Rpb24gdW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy51bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgZnVuY3Rpb24gYm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xuICAgIH1cbiAgICBJcy5ib29sZWFuID0gYm9vbGVhbjtcbiAgICBmdW5jdGlvbiBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBTdHJpbmddJztcbiAgICB9XG4gICAgSXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIGZ1bmN0aW9uIG51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nO1xuICAgIH1cbiAgICBJcy5udW1iZXIgPSBudW1iZXI7XG4gICAgZnVuY3Rpb24gbnVtYmVyUmFuZ2UodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heDtcbiAgICB9XG4gICAgSXMubnVtYmVyUmFuZ2UgPSBudW1iZXJSYW5nZTtcbiAgICBmdW5jdGlvbiBpbnRlZ2VyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgLTIxNDc0ODM2NDggPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMuaW50ZWdlciA9IGludGVnZXI7XG4gICAgZnVuY3Rpb24gdWludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAwIDw9IHZhbHVlICYmIHZhbHVlIDw9IDIxNDc0ODM2NDc7XG4gICAgfVxuICAgIElzLnVpbnRlZ2VyID0gdWludGVnZXI7XG4gICAgZnVuY3Rpb24gZnVuYyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuICAgIElzLmZ1bmMgPSBmdW5jO1xuICAgIGZ1bmN0aW9uIG9iamVjdExpdGVyYWwodmFsdWUpIHtcbiAgICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcgY2xhc3MgaW5zdGFuY2VzIHBhc3MgdGhpcyBjaGVjayBhcyB3ZWxsLiBTaW5jZSB0aGUgTFNQXG4gICAgICAgIC8vIGRvZXNuJ3QgdXNlIGNsYXNzZXMgd2UgaWdub3JlIHRoaXMgZm9yIG5vdy4gSWYgd2UgZG8gd2UgbmVlZCB0byBhZGQgc29tZXRoaW5nXG4gICAgICAgIC8vIGxpa2UgdGhpczogYE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCkpID09PSBudWxsYFxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbiAgICB9XG4gICAgSXMub2JqZWN0TGl0ZXJhbCA9IG9iamVjdExpdGVyYWw7XG4gICAgZnVuY3Rpb24gdHlwZWRBcnJheSh2YWx1ZSwgY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGNoZWNrKTtcbiAgICB9XG4gICAgSXMudHlwZWRBcnJheSA9IHR5cGVkQXJyYXk7XG59KShJcyB8fCAoSXMgPSB7fSkpO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICd2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMnO1xuaW1wb3J0IHsgaXNDb21wb3NpdGVDc3ROb2RlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgdG9rZW5Ub1JhbmdlIH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBDc3ROb2RlQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubm9kZVN0YWNrID0gW107XG4gICAgfVxuICAgIGdldCBjdXJyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlU3RhY2tbdGhpcy5ub2RlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGJ1aWxkUm9vdE5vZGUoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5yb290Tm9kZSA9IG5ldyBSb290Q3N0Tm9kZUltcGwoaW5wdXQpO1xuICAgICAgICB0aGlzLnJvb3ROb2RlLnJvb3QgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICB0aGlzLm5vZGVTdGFjayA9IFt0aGlzLnJvb3ROb2RlXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdE5vZGU7XG4gICAgfVxuICAgIGJ1aWxkQ29tcG9zaXRlTm9kZShmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvc2l0ZU5vZGUgPSBuZXcgQ29tcG9zaXRlQ3N0Tm9kZUltcGwoKTtcbiAgICAgICAgY29tcG9zaXRlTm9kZS5ncmFtbWFyU291cmNlID0gZmVhdHVyZTtcbiAgICAgICAgY29tcG9zaXRlTm9kZS5yb290ID0gdGhpcy5yb290Tm9kZTtcbiAgICAgICAgdGhpcy5jdXJyZW50LmNvbnRlbnQucHVzaChjb21wb3NpdGVOb2RlKTtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sucHVzaChjb21wb3NpdGVOb2RlKTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZU5vZGU7XG4gICAgfVxuICAgIGJ1aWxkTGVhZk5vZGUodG9rZW4sIGZlYXR1cmUpIHtcbiAgICAgICAgY29uc3QgbGVhZk5vZGUgPSBuZXcgTGVhZkNzdE5vZGVJbXBsKHRva2VuLnN0YXJ0T2Zmc2V0LCB0b2tlbi5pbWFnZS5sZW5ndGgsIHRva2VuVG9SYW5nZSh0b2tlbiksIHRva2VuLnRva2VuVHlwZSwgZmFsc2UpO1xuICAgICAgICBsZWFmTm9kZS5ncmFtbWFyU291cmNlID0gZmVhdHVyZTtcbiAgICAgICAgbGVhZk5vZGUucm9vdCA9IHRoaXMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMuY3VycmVudC5jb250ZW50LnB1c2gobGVhZk5vZGUpO1xuICAgICAgICByZXR1cm4gbGVhZk5vZGU7XG4gICAgfVxuICAgIHJlbW92ZU5vZGUobm9kZSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuY29udGVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIC8vIFRoZSBzcGVjaWZpZWQgaXRlbSBjb3VsZCBiZSBhIGRhdGF0eXBlICgkdHlwZSBpcyBzeW1ib2wpIG9yIGEgZnJhZ21lbnQgKCR0eXBlIGlzIHVuZGVmaW5lZClcbiAgICAgICAgLy8gT25seSBpZiB0aGUgJHR5cGUgaXMgYSBzdHJpbmcsIHdlIGFjdHVhbGx5IGFzc2lnbiB0aGUgZWxlbWVudFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uJHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXN0Tm9kZSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS4kY3N0Tm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gRW1wdHkgY29tcG9zaXRlIG5vZGVzIGFyZSBub3QgdmFsaWRcbiAgICAgICAgLy8gU2ltcGx5IHJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlXG4gICAgICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNvbnRlbnQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEhpZGRlblRva2VucyhoaWRkZW5Ub2tlbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBoaWRkZW5Ub2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhpZGRlbk5vZGUgPSBuZXcgTGVhZkNzdE5vZGVJbXBsKHRva2VuLnN0YXJ0T2Zmc2V0LCB0b2tlbi5pbWFnZS5sZW5ndGgsIHRva2VuVG9SYW5nZSh0b2tlbiksIHRva2VuLnRva2VuVHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgICBoaWRkZW5Ob2RlLnJvb3QgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICAgICAgdGhpcy5hZGRIaWRkZW5Ub2tlbih0aGlzLnJvb3ROb2RlLCBoaWRkZW5Ob2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIaWRkZW5Ub2tlbihub2RlLCB0b2tlbikge1xuICAgICAgICBjb25zdCB7IG9mZnNldDogdG9rZW5TdGFydCwgZW5kOiB0b2tlbkVuZCB9ID0gdG9rZW47XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY29udGVudFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0OiBjaGlsZFN0YXJ0LCBlbmQ6IGNoaWxkRW5kIH0gPSBjaGlsZDtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUoY2hpbGQpICYmIHRva2VuU3RhcnQgPiBjaGlsZFN0YXJ0ICYmIHRva2VuRW5kIDwgY2hpbGRFbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEhpZGRlblRva2VuKGNoaWxkLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rZW5FbmQgPD0gY2hpbGRTdGFydCkge1xuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudC5zcGxpY2UoaSwgMCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBrbm93IHRoYXQgd2UgaGF2ZW4ndCBmb3VuZCBhIHN1aXRlZCBwb3NpdGlvbiBmb3IgdGhlIHRva2VuXG4gICAgICAgIC8vIFNvIHdlIHNpbXBseSBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgY3VycmVudCBub2RlXG4gICAgICAgIG5vZGUuY29udGVudC5wdXNoKHRva2VuKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RDc3ROb2RlIHtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBjb250YWluZXJgIGluc3RlYWQuICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBncmFtbWFyU291cmNlYCBpbnN0ZWFkLiAqL1xuICAgIGdldCBmZWF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmFtbWFyU291cmNlO1xuICAgIH1cbiAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBhc3ROb2RlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBub2RlID0gdHlwZW9mICgoX2EgPSB0aGlzLl9hc3ROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuJHR5cGUpID09PSAnc3RyaW5nJyA/IHRoaXMuX2FzdE5vZGUgOiAoX2IgPSB0aGlzLmNvbnRhaW5lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFzdE5vZGU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgaGFzIG5vIGFzc29jaWF0ZWQgQVNUIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgc2V0IGFzdE5vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXN0Tm9kZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIGBhc3ROb2RlYCBpbnN0ZWFkLiAqL1xuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3ROb2RlO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5mdWxsVGV4dC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIHRoaXMuZW5kKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGVhZkNzdE5vZGVJbXBsIGV4dGVuZHMgQWJzdHJhY3RDc3ROb2RlIHtcbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ICsgdGhpcy5fbGVuZ3RoO1xuICAgIH1cbiAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlkZGVuO1xuICAgIH1cbiAgICBnZXQgdG9rZW5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5UeXBlO1xuICAgIH1cbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yYW5nZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob2Zmc2V0LCBsZW5ndGgsIHJhbmdlLCB0b2tlblR5cGUsIGhpZGRlbiA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2hpZGRlbiA9IGhpZGRlbjtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLl90b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5fcmFuZ2UgPSByYW5nZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ29tcG9zaXRlQ3N0Tm9kZUltcGwgZXh0ZW5kcyBBYnN0cmFjdENzdE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ3N0Tm9kZUNvbnRhaW5lcih0aGlzKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgY29udGVudGAgaW5zdGVhZC4gKi9cbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmZpcnN0Tm9uSGlkZGVuTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9mZnNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kIC0gdGhpcy5vZmZzZXQ7XG4gICAgfVxuICAgIGdldCBlbmQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmxhc3ROb25IaWRkZW5Ob2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgIH1cbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZmlyc3ROb25IaWRkZW5Ob2RlO1xuICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IHRoaXMubGFzdE5vbkhpZGRlbk5vZGU7XG4gICAgICAgIGlmIChmaXJzdE5vZGUgJiYgbGFzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yYW5nZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJhbmdlOiBmaXJzdFJhbmdlIH0gPSBmaXJzdE5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZTogbGFzdFJhbmdlIH0gPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yYW5nZUNhY2hlID0geyBzdGFydDogZmlyc3RSYW5nZS5zdGFydCwgZW5kOiBsYXN0UmFuZ2UuZW5kLmxpbmUgPCBmaXJzdFJhbmdlLnN0YXJ0LmxpbmUgPyBmaXJzdFJhbmdlLnN0YXJ0IDogbGFzdFJhbmdlLmVuZCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JhbmdlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogUG9zaXRpb24uY3JlYXRlKDAsIDApLCBlbmQ6IFBvc2l0aW9uLmNyZWF0ZSgwLCAwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdE5vbkhpZGRlbk5vZGUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIWNoaWxkLmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdO1xuICAgIH1cbiAgICBnZXQgbGFzdE5vbkhpZGRlbk5vZGUoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV07XG4gICAgfVxufVxuY2xhc3MgQ3N0Tm9kZUNvbnRhaW5lciBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBDc3ROb2RlQ29udGFpbmVyLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIHB1c2goLi4uaXRlbXMpIHtcbiAgICAgICAgdGhpcy5hZGRQYXJlbnRzKGl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnB1c2goLi4uaXRlbXMpO1xuICAgIH1cbiAgICB1bnNoaWZ0KC4uLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuYWRkUGFyZW50cyhpdGVtcyk7XG4gICAgICAgIHJldHVybiBzdXBlci51bnNoaWZ0KC4uLml0ZW1zKTtcbiAgICB9XG4gICAgc3BsaWNlKHN0YXJ0LCBjb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgICAgdGhpcy5hZGRQYXJlbnRzKGl0ZW1zKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNwbGljZShzdGFydCwgY291bnQsIC4uLml0ZW1zKTtcbiAgICB9XG4gICAgYWRkUGFyZW50cyhpdGVtcykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGl0ZW0uY29udGFpbmVyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUm9vdENzdE5vZGVJbXBsIGV4dGVuZHMgQ29tcG9zaXRlQ3N0Tm9kZUltcGwge1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dC5zdWJzdHJpbmcodGhpcy5vZmZzZXQsIHRoaXMuZW5kKTtcbiAgICB9XG4gICAgZ2V0IGZ1bGxUZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fdGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl90ZXh0ID0gaW5wdXQgIT09IG51bGwgJiYgaW5wdXQgIT09IHZvaWQgMCA/IGlucHV0IDogJyc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LW5vZGUtYnVpbGRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciwgRW1iZWRkZWRBY3Rpb25zUGFyc2VyLCBMTGtMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuaW1wb3J0IHsgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3kgfSBmcm9tICdjaGV2cm90YWluLWFsbHN0YXInO1xuaW1wb3J0IHsgaXNBc3NpZ25tZW50LCBpc0Nyb3NzUmVmZXJlbmNlLCBpc0tleXdvcmQgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBnZXRUeXBlTmFtZSwgaXNEYXRhVHlwZVJ1bGUgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGFzc2lnbk1hbmRhdG9yeVByb3BlcnRpZXMsIGdldENvbnRhaW5lck9mVHlwZSwgbGlua0NvbnRlbnRUb0NvbnRhaW5lciB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBDc3ROb2RlQnVpbGRlciB9IGZyb20gJy4vY3N0LW5vZGUtYnVpbGRlci5qcyc7XG5leHBvcnQgY29uc3QgRGF0YXR5cGVTeW1ib2wgPSBTeW1ib2woJ0RhdGF0eXBlJyk7XG5mdW5jdGlvbiBpc0RhdGFUeXBlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuJHR5cGUgPT09IERhdGF0eXBlU3ltYm9sO1xufVxuY29uc3QgcnVsZVN1ZmZpeCA9ICdcXHUyMDBCJztcbmNvbnN0IHdpdGhSdWxlU3VmZml4ID0gKG5hbWUpID0+IG5hbWUuZW5kc1dpdGgocnVsZVN1ZmZpeCkgPyBuYW1lIDogbmFtZSArIHJ1bGVTdWZmaXg7XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RMYW5naXVtUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLl91bm9yZGVyZWRHcm91cHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGV4ZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGV4ZXI7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMubGV4ZXIuZGVmaW5pdGlvbjtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gbmV3IENoZXZyb3RhaW5XcmFwcGVyKHRva2VucywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJ2aWNlcy5wYXJzZXIuUGFyc2VyQ29uZmlnKSwgeyBlcnJvck1lc3NhZ2VQcm92aWRlcjogc2VydmljZXMucGFyc2VyLlBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIH0pKTtcbiAgICB9XG4gICAgYWx0ZXJuYXRpdmVzKGlkeCwgY2hvaWNlcykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE9yKGlkeCwgY2hvaWNlcyk7XG4gICAgfVxuICAgIG9wdGlvbmFsKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLndyYXBPcHRpb24oaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG1hbnkoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE1hbnkoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcEF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlzUmVjb3JkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLklTX1JFQ09SRElORztcbiAgICB9XG4gICAgZ2V0IHVub3JkZXJlZEdyb3VwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Vub3JkZXJlZEdyb3VwcztcbiAgICB9XG4gICAgZ2V0UnVsZVN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLlJVTEVfU1RBQ0s7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcFNlbGZBbmFseXNpcygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RMYW5naXVtUGFyc2VyIHtcbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgc3VwZXIoc2VydmljZXMpO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyID0gbmV3IENzdE5vZGVCdWlsZGVyKCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmtlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IHNlcnZpY2VzLnBhcnNlci5WYWx1ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5hc3RSZWZsZWN0aW9uID0gc2VydmljZXMuc2hhcmVkLkFzdFJlZmxlY3Rpb247XG4gICAgfVxuICAgIHJ1bGUocnVsZSwgaW1wbCkge1xuICAgICAgICBjb25zdCB0eXBlID0gcnVsZS5mcmFnbWVudCA/IHVuZGVmaW5lZCA6IGlzRGF0YVR5cGVSdWxlKHJ1bGUpID8gRGF0YXR5cGVTeW1ib2wgOiBnZXRUeXBlTmFtZShydWxlKTtcbiAgICAgICAgY29uc3QgcnVsZU1ldGhvZCA9IHRoaXMud3JhcHBlci5ERUZJTkVfUlVMRSh3aXRoUnVsZVN1ZmZpeChydWxlLm5hbWUpLCB0aGlzLnN0YXJ0SW1wbGVtZW50YXRpb24odHlwZSwgaW1wbCkuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChydWxlLmVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLm1haW5SdWxlID0gcnVsZU1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZU1ldGhvZDtcbiAgICB9XG4gICAgcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5idWlsZFJvb3ROb2RlKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGV4ZXJSZXN1bHQgPSB0aGlzLmxleGVyLnRva2VuaXplKGlucHV0KTtcbiAgICAgICAgdGhpcy53cmFwcGVyLmlucHV0ID0gbGV4ZXJSZXN1bHQudG9rZW5zO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLm1haW5SdWxlLmNhbGwodGhpcy53cmFwcGVyLCB7fSk7XG4gICAgICAgIHRoaXMubm9kZUJ1aWxkZXIuYWRkSGlkZGVuVG9rZW5zKGxleGVyUmVzdWx0LmhpZGRlbik7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkR3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgbGV4ZXJFcnJvcnM6IGxleGVyUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIHBhcnNlckVycm9yczogdGhpcy53cmFwcGVyLmVycm9yc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydEltcGxlbWVudGF0aW9uKCR0eXBlLCBpbXBsZW1lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgJHR5cGUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlID09PSBEYXRhdHlwZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW1wbGVtZW50YXRpb24oYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN0cnVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3VtZShpZHgsIHRva2VuVHlwZSwgZmVhdHVyZSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMud3JhcHBlci53cmFwQ29uc3VtZShpZHgsIHRva2VuVHlwZSk7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpICYmIHRoaXMuaXNWYWxpZFRva2VuKHRva2VuKSkge1xuICAgICAgICAgICAgY29uc3QgbGVhZk5vZGUgPSB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkTGVhZk5vZGUodG9rZW4sIGZlYXR1cmUpO1xuICAgICAgICAgICAgY29uc3QgeyBhc3NpZ25tZW50LCBpc0Nyb3NzUmVmIH0gPSB0aGlzLmdldEFzc2lnbm1lbnQoZmVhdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGlzS2V5d29yZChmZWF0dXJlKSA/IHRva2VuLmltYWdlIDogdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0b2tlbi5pbWFnZSwgbGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFzc2lnbm1lbnQub3BlcmF0b3IsIGFzc2lnbm1lbnQuZmVhdHVyZSwgY29udmVydGVkVmFsdWUsIGxlYWZOb2RlLCBpc0Nyb3NzUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YVR5cGVOb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB0b2tlbi5pbWFnZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzS2V5d29yZChmZWF0dXJlKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0ZXh0LCBsZWFmTm9kZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC52YWx1ZSArPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3QgY29uc3VtZWQgcGFyc2VyIHRva2VucyBhcmUgdmFsaWQuIEhvd2V2ZXIgdGhlcmUgYXJlIHR3byBjYXNlcyBpbiB3aGljaCB0aGV5IGFyZSBub3QgdmFsaWQ6XG4gICAgICpcbiAgICAgKiAxLiBUaGV5IHdlcmUgaW5zZXJ0ZWQgZHVyaW5nIGVycm9yIHJlY292ZXJ5IGJ5IHRoZSBwYXJzZXIuIFRoZXNlIHRva2VucyBkb24ndCByZWFsbHkgZXhpc3QgYW5kIHNob3VsZCBub3QgYmUgZnVydGhlciBwcm9jZXNzZWRcbiAgICAgKiAyLiBUaGV5IGNvbnRhaW4gaW52YWxpZCB0b2tlbiByYW5nZXMuIFRoaXMgbWlnaHQgaW5jbHVkZSB0aGUgc3BlY2lhbCBFT0YgdG9rZW4sIG9yIG90aGVyIHRva2VucyBwcm9kdWNlZCBieSBpbnZhbGlkIHRva2VuIGJ1aWxkZXJzLlxuICAgICAqL1xuICAgIGlzVmFsaWRUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gIXRva2VuLmlzSW5zZXJ0ZWRJblJlY292ZXJ5ICYmICFpc05hTih0b2tlbi5zdGFydE9mZnNldCkgJiYgdHlwZW9mIHRva2VuLmVuZE9mZnNldCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHRva2VuLmVuZE9mZnNldCk7XG4gICAgfVxuICAgIHN1YnJ1bGUoaWR4LCBydWxlLCBmZWF0dXJlLCBhcmdzKSB7XG4gICAgICAgIGxldCBjc3ROb2RlO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgY3N0Tm9kZSA9IHRoaXMubm9kZUJ1aWxkZXIuYnVpbGRDb21wb3NpdGVOb2RlKGZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YnJ1bGVSZXN1bHQgPSB0aGlzLndyYXBwZXIud3JhcFN1YnJ1bGUoaWR4LCBydWxlLCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgY3N0Tm9kZSAmJiBjc3ROb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVN1YnJ1bGVBc3NpZ25tZW50KHN1YnJ1bGVSZXN1bHQsIGZlYXR1cmUsIGNzdE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlcmZvcm1TdWJydWxlQXNzaWdubWVudChyZXN1bHQsIGZlYXR1cmUsIGNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgeyBhc3NpZ25tZW50LCBpc0Nyb3NzUmVmIH0gPSB0aGlzLmdldEFzc2lnbm1lbnQoZmVhdHVyZSk7XG4gICAgICAgIGlmIChhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbihhc3NpZ25tZW50Lm9wZXJhdG9yLCBhc3NpZ25tZW50LmZlYXR1cmUsIHJlc3VsdCwgY3N0Tm9kZSwgaXNDcm9zc1JlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbGwgYSBzdWJydWxlIHdpdGhvdXQgYW4gYXNzaWdubWVudCB3ZSBlaXRoZXI6XG4gICAgICAgICAgICAvLyAxLiBhcHBlbmQgdGhlIHJlc3VsdCBvZiB0aGUgc3VicnVsZSAoZGF0YSB0eXBlIHJ1bGUpXG4gICAgICAgICAgICAvLyAyLiBvdmVycmlkZSB0aGUgY3VycmVudCBvYmplY3Qgd2l0aCB0aGUgbmV3bHkgcGFyc2VkIG9iamVjdFxuICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhbiBBU1Qgbm9kZSBhbmQgdGhlIHJlc3VsdCBvZiB0aGUgc3VicnVsZVxuICAgICAgICAgICAgLy8gaXMgYSBkYXRhIHR5cGUgcnVsZSwgd2UgY2FuIHNhZmVseSBkaXNjYXJkIHRoZSByZXN1bHRzLlxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChpc0RhdGFUeXBlTm9kZShjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQudmFsdWUgKz0gcmVzdWx0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRLaW5kID0gcmVzdWx0LiR0eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuYXNzaWduV2l0aG91dE92ZXJyaWRlKHJlc3VsdCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEtpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LiR0eXBlID0gcmVzdWx0S2luZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IG9iamVjdDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChuZXdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhY3Rpb24oJHR5cGUsIGFjdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICAvLyBUaGlzIGJyYW5jaCBpcyB1c2VkIGZvciBsZWZ0IHJlY3Vyc2l2ZSBncmFtbWFyIHJ1bGVzLlxuICAgICAgICAgICAgLy8gVGhvc2UgZG9uJ3QgY2FsbCBgY29uc3RydWN0YCBiZWZvcmUgYW5vdGhlciBhY3Rpb24uXG4gICAgICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIG5lZWQgdG8gY2FsbCBpdCBoZXJlLlxuICAgICAgICAgICAgaWYgKCFsYXN0LiRjc3ROb2RlICYmIGFjdGlvbi5mZWF0dXJlICYmIGFjdGlvbi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0aGlzLmNvbnN0cnVjdChmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IGxhc3QuJGNzdE5vZGUuZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkQ29tcG9zaXRlTm9kZShmZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0l0ZW0gPSB7ICR0eXBlIH07XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5mZWF0dXJlICYmIGFjdGlvbi5vcGVyYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFjdGlvbi5vcGVyYXRvciwgYWN0aW9uLmZlYXR1cmUsIGxhc3QsIGxhc3QuJGNzdE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3QocG9wID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGlua0NvbnRlbnRUb0NvbnRhaW5lcihvYmopO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLmNvbnN0cnVjdChvYmopO1xuICAgICAgICBpZiAocG9wKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RhdGFUeXBlTm9kZShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0ZXIuY29udmVydChvYmoudmFsdWUsIG9iai4kY3N0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NpZ25NYW5kYXRvcnlQcm9wZXJ0aWVzKHRoaXMuYXN0UmVmbGVjdGlvbiwgb2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBnZXRBc3NpZ25tZW50KGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzc2lnbm1lbnRNYXAuaGFzKGZlYXR1cmUpKSB7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50ID0gZ2V0Q29udGFpbmVyT2ZUeXBlKGZlYXR1cmUsIGlzQXNzaWdubWVudCk7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbm1lbnRNYXAuc2V0KGZlYXR1cmUsIHtcbiAgICAgICAgICAgICAgICBhc3NpZ25tZW50OiBhc3NpZ25tZW50LFxuICAgICAgICAgICAgICAgIGlzQ3Jvc3NSZWY6IGFzc2lnbm1lbnQgPyBpc0Nyb3NzUmVmZXJlbmNlKGFzc2lnbm1lbnQudGVybWluYWwpIDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2lnbm1lbnRNYXAuZ2V0KGZlYXR1cmUpO1xuICAgIH1cbiAgICBhc3NpZ24ob3BlcmF0b3IsIGZlYXR1cmUsIHZhbHVlLCBjc3ROb2RlLCBpc0Nyb3NzUmVmKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIGlmIChpc0Nyb3NzUmVmICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmxpbmtlci5idWlsZFJlZmVyZW5jZShvYmosIGZlYXR1cmUsIGNzdE5vZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICc9Jzoge1xuICAgICAgICAgICAgICAgIG9ialtmZWF0dXJlXSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICc/PSc6IHtcbiAgICAgICAgICAgICAgICBvYmpbZmVhdHVyZV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnKz0nOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtmZWF0dXJlXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW2ZlYXR1cmVdID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9ialtmZWF0dXJlXS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2lnbldpdGhvdXRPdmVycmlkZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCBleGlzdGluZ1ZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRhcmdldFtuYW1lXTtcbiAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gZXhpc3RpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV3VmFsdWUpICYmIEFycmF5LmlzQXJyYXkoZXhpc3RpbmdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2goLi4ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGV4aXN0aW5nVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgZ2V0IGRlZmluaXRpb25FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZXIuZGVmaW5pdGlvbkVycm9ycztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RQYXJzZXJFcnJvck1lc3NhZ2VQcm92aWRlciB7XG4gICAgYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlci5idWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBidWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlci5idWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZShvcHRpb25zKTtcbiAgICB9XG4gICAgYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGROb1ZpYWJsZUFsdE1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgfVxuICAgIGJ1aWxkRWFybHlFeGl0TWVzc2FnZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlci5idWlsZEVhcmx5RXhpdE1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExhbmdpdW1QYXJzZXJFcnJvck1lc3NhZ2VQcm92aWRlciBleHRlbmRzIEFic3RyYWN0UGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIge1xuICAgIGJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2UoeyBleHBlY3RlZCwgYWN0dWFsIH0pIHtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRNc2cgPSBleHBlY3RlZC5MQUJFTFxuICAgICAgICAgICAgPyAnYCcgKyBleHBlY3RlZC5MQUJFTCArICdgJ1xuICAgICAgICAgICAgOiBleHBlY3RlZC5uYW1lLmVuZHNXaXRoKCc6S1cnKVxuICAgICAgICAgICAgICAgID8gYGtleXdvcmQgJyR7ZXhwZWN0ZWQubmFtZS5zdWJzdHJpbmcoMCwgZXhwZWN0ZWQubmFtZS5sZW5ndGggLSAzKX0nYFxuICAgICAgICAgICAgICAgIDogYHRva2VuIG9mIHR5cGUgJyR7ZXhwZWN0ZWQubmFtZX0nYDtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RpbmcgJHtleHBlY3RlZE1zZ30gYnV0IGZvdW5kIFxcYCR7YWN0dWFsLmltYWdlfVxcYC5gO1xuICAgIH1cbiAgICBidWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7IGZpcnN0UmVkdW5kYW50IH0pIHtcbiAgICAgICAgcmV0dXJuIGBFeHBlY3RpbmcgZW5kIG9mIGZpbGUgYnV0IGZvdW5kIFxcYCR7Zmlyc3RSZWR1bmRhbnQuaW1hZ2V9XFxgLmA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExhbmdpdW1Db21wbGV0aW9uUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RMYW5naXVtUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0RWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubmV4dFRva2VuSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IDA7XG4gICAgfVxuICAgIGFjdGlvbigpIHtcbiAgICAgICAgLy8gTk9PUFxuICAgIH1cbiAgICBjb25zdHJ1Y3QoKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMubGV4ZXIudG9rZW5pemUoaW5wdXQpO1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2Vucy50b2tlbnM7XG4gICAgICAgIHRoaXMud3JhcHBlci5pbnB1dCA9IFsuLi50aGlzLnRva2Vuc107XG4gICAgICAgIHRoaXMubWFpblJ1bGUuY2FsbCh0aGlzLndyYXBwZXIsIHt9KTtcbiAgICAgICAgdGhpcy51bm9yZGVyZWRHcm91cHMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuczogdGhpcy50b2tlbnMsXG4gICAgICAgICAgICBlbGVtZW50U3RhY2s6IFsuLi50aGlzLmxhc3RFbGVtZW50U3RhY2tdLFxuICAgICAgICAgICAgdG9rZW5JbmRleDogdGhpcy5uZXh0VG9rZW5JbmRleFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydWxlKHJ1bGUsIGltcGwpIHtcbiAgICAgICAgY29uc3QgcnVsZU1ldGhvZCA9IHRoaXMud3JhcHBlci5ERUZJTkVfUlVMRSh3aXRoUnVsZVN1ZmZpeChydWxlLm5hbWUpLCB0aGlzLnN0YXJ0SW1wbGVtZW50YXRpb24oaW1wbCkuYmluZCh0aGlzKSk7XG4gICAgICAgIGlmIChydWxlLmVudHJ5KSB7XG4gICAgICAgICAgICB0aGlzLm1haW5SdWxlID0gcnVsZU1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZU1ldGhvZDtcbiAgICB9XG4gICAgcmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5sYXN0RWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubmV4dFRva2VuSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IDA7XG4gICAgfVxuICAgIHN0YXJ0SW1wbGVtZW50YXRpb24oaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5rZWVwU3RhY2tTaXplKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YWNrU2l6ZShzaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVtb3ZlVW5leHBlY3RlZEVsZW1lbnRzKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRTdGFjay5zcGxpY2UodGhpcy5zdGFja1NpemUpO1xuICAgIH1cbiAgICBrZWVwU3RhY2tTaXplKCkge1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IHNpemU7XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICByZXNldFN0YWNrU2l6ZShzaXplKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVW5leHBlY3RlZEVsZW1lbnRzKCk7XG4gICAgICAgIHRoaXMuc3RhY2tTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgY29uc3VtZShpZHgsIHRva2VuVHlwZSwgZmVhdHVyZSkge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcENvbnN1bWUoaWR4LCB0b2tlblR5cGUpO1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RWxlbWVudFN0YWNrID0gWy4uLnRoaXMuZWxlbWVudFN0YWNrLCBmZWF0dXJlXTtcbiAgICAgICAgICAgIHRoaXMubmV4dFRva2VuSW5kZXggPSB0aGlzLmN1cnJJZHggKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnJ1bGUoaWR4LCBydWxlLCBmZWF0dXJlLCBhcmdzKSB7XG4gICAgICAgIHRoaXMuYmVmb3JlKGZlYXR1cmUpO1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcFN1YnJ1bGUoaWR4LCBydWxlLCBhcmdzKTtcbiAgICAgICAgdGhpcy5hZnRlcihmZWF0dXJlKTtcbiAgICB9XG4gICAgYmVmb3JlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWZ0ZXIoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmVsZW1lbnRTdGFjay5sYXN0SW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhY2suc3BsaWNlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY3VycklkeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlci5jdXJySWR4O1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRDb25maWcgPSB7XG4gICAgcmVjb3ZlcnlFbmFibGVkOiB0cnVlLFxuICAgIG5vZGVMb2NhdGlvblRyYWNraW5nOiAnZnVsbCcsXG4gICAgc2tpcFZhbGlkYXRpb25zOiB0cnVlLFxuICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiBuZXcgTGFuZ2l1bVBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyKClcbn07XG4vKipcbiAqIFRoaXMgY2xhc3Mgd3JhcHMgdGhlIGVtYmVkZGVkIGFjdGlvbnMgcGFyc2VyIG9mIGNoZXZyb3RhaW4gYW5kIGV4cG9zZXMgcHJvdGVjdGVkIG1ldGhvZHMuXG4gKiBUaGlzIHdheSwgd2UgY2FuIGJ1aWxkIHRoZSBgTGFuZ2l1bVBhcnNlcmAgYXMgYSBjb21wb3NpdGlvbi5cbiAqL1xuY2xhc3MgQ2hldnJvdGFpbldyYXBwZXIgZXh0ZW5kcyBFbWJlZGRlZEFjdGlvbnNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VucywgY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHVzZURlZmF1bHRMb29rYWhlYWQgPSBjb25maWcgJiYgJ21heExvb2thaGVhZCcgaW4gY29uZmlnO1xuICAgICAgICBzdXBlcih0b2tlbnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnKSwgeyBsb29rYWhlYWRTdHJhdGVneTogdXNlRGVmYXVsdExvb2thaGVhZFxuICAgICAgICAgICAgICAgID8gbmV3IExMa0xvb2thaGVhZFN0cmF0ZWd5KHsgbWF4TG9va2FoZWFkOiBjb25maWcubWF4TG9va2FoZWFkIH0pXG4gICAgICAgICAgICAgICAgOiBuZXcgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3koKSB9KSwgY29uZmlnKSk7XG4gICAgfVxuICAgIGdldCBJU19SRUNPUkRJTkcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLlJFQ09SRElOR19QSEFTRTtcbiAgICB9XG4gICAgREVGSU5FX1JVTEUobmFtZSwgaW1wbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5SVUxFKG5hbWUsIGltcGwpO1xuICAgIH1cbiAgICB3cmFwU2VsZkFuYWx5c2lzKCkge1xuICAgICAgICB0aGlzLnBlcmZvcm1TZWxmQW5hbHlzaXMoKTtcbiAgICB9XG4gICAgd3JhcENvbnN1bWUoaWR4LCB0b2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZShpZHgsIHRva2VuVHlwZSk7XG4gICAgfVxuICAgIHdyYXBTdWJydWxlKGlkeCwgcnVsZSwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlKGlkeCwgcnVsZSwge1xuICAgICAgICAgICAgQVJHUzogW2FyZ3NdXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3cmFwT3IoaWR4LCBjaG9pY2VzKSB7XG4gICAgICAgIHRoaXMub3IoaWR4LCBjaG9pY2VzKTtcbiAgICB9XG4gICAgd3JhcE9wdGlvbihpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub3B0aW9uKGlkeCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICB3cmFwTWFueShpZHgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubWFueShpZHgsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JhcEF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ2l1bS1wYXJzZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgRU1QVFlfQUxULCBFT0YgfSBmcm9tICdjaGV2cm90YWluJztcbmltcG9ydCB7IGlzQWN0aW9uLCBpc0FsdGVybmF0aXZlcywgaXNFbmRPZkZpbGUsIGlzQXNzaWdubWVudCwgaXNDb25qdW5jdGlvbiwgaXNDcm9zc1JlZmVyZW5jZSwgaXNEaXNqdW5jdGlvbiwgaXNHcm91cCwgaXNLZXl3b3JkLCBpc05lZ2F0aW9uLCBpc1BhcmFtZXRlclJlZmVyZW5jZSwgaXNQYXJzZXJSdWxlLCBpc1J1bGVDYWxsLCBpc1Rlcm1pbmFsUnVsZSwgaXNVbm9yZGVyZWRHcm91cCwgaXNCb29sZWFuTGl0ZXJhbCB9IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGFzc2VydFVucmVhY2hhYmxlLCBFcnJvcldpdGhMb2NhdGlvbiB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuaW1wb3J0IHsgZmluZE5hbWVBc3NpZ25tZW50LCBnZXRBbGxSZWFjaGFibGVSdWxlcywgZ2V0VHlwZU5hbWUgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQYXJzZXIoZ3JhbW1hciwgcGFyc2VyLCB0b2tlbnMpIHtcbiAgICBjb25zdCBydWxlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBwYXJzZXJDb250ZXh0ID0ge1xuICAgICAgICBwYXJzZXIsXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgcnVsZXMsXG4gICAgICAgIHJ1bGVOYW1lczogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpO1xuICAgIHJldHVybiBwYXJzZXI7XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByZWFjaGFibGUgPSBnZXRBbGxSZWFjaGFibGVSdWxlcyhncmFtbWFyLCBmYWxzZSk7XG4gICAgY29uc3QgcGFyc2VyUnVsZXMgPSBzdHJlYW0oZ3JhbW1hci5ydWxlcykuZmlsdGVyKGlzUGFyc2VyUnVsZSkuZmlsdGVyKHJ1bGUgPT4gcmVhY2hhYmxlLmhhcyhydWxlKSk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHBhcnNlclJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VyQ29udGV4dCksIHsgY29uc3VtZTogMSwgb3B0aW9uYWw6IDEsIHN1YnJ1bGU6IDEsIG1hbnk6IDEsIG9yOiAxIH0pO1xuICAgICAgICBjdHgucnVsZXMuc2V0KHJ1bGUubmFtZSwgcGFyc2VyQ29udGV4dC5wYXJzZXIucnVsZShydWxlLCBidWlsZEVsZW1lbnQoY3R4LCBydWxlLmRlZmluaXRpb24pKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRFbGVtZW50KGN0eCwgZWxlbWVudCwgaWdub3JlR3VhcmQgPSBmYWxzZSkge1xuICAgIGxldCBtZXRob2Q7XG4gICAgaWYgKGlzS2V5d29yZChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEtleXdvcmQoY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBY3Rpb24oZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRBY3Rpb24oY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBc3NpZ25tZW50KGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQudGVybWluYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Nyb3NzUmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkQ3Jvc3NSZWZlcmVuY2UoY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSdWxlQ2FsbChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZFJ1bGVDYWxsKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWx0ZXJuYXRpdmVzKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkQWx0ZXJuYXRpdmVzKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzVW5vcmRlcmVkR3JvdXAoZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRVbm9yZGVyZWRHcm91cChjdHgsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0dyb3VwKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkR3JvdXAoY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNFbmRPZkZpbGUoZWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgbWV0aG9kID0gKCkgPT4gY3R4LnBhcnNlci5jb25zdW1lKGlkeCwgRU9GLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhMb2NhdGlvbihlbGVtZW50LiRjc3ROb2RlLCBgVW5leHBlY3RlZCBlbGVtZW50IHR5cGU6ICR7ZWxlbWVudC4kdHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyYXAoY3R4LCBpZ25vcmVHdWFyZCA/IHVuZGVmaW5lZCA6IGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpLCBtZXRob2QsIGVsZW1lbnQuY2FyZGluYWxpdHkpO1xufVxuZnVuY3Rpb24gYnVpbGRBY3Rpb24oY3R4LCBhY3Rpb24pIHtcbiAgICBjb25zdCBhY3Rpb25UeXBlID0gZ2V0VHlwZU5hbWUoYWN0aW9uKTtcbiAgICByZXR1cm4gKCkgPT4gY3R4LnBhcnNlci5hY3Rpb24oYWN0aW9uVHlwZSwgYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUnVsZUNhbGwoY3R4LCBydWxlQ2FsbCkge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlQ2FsbC5ydWxlLnJlZjtcbiAgICBpZiAoaXNQYXJzZXJSdWxlKHJ1bGUpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5zdWJydWxlKys7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHJ1bGVDYWxsLmFyZ3VtZW50cy5sZW5ndGggPiAwID8gYnVpbGRSdWxlQ2FsbFByZWRpY2F0ZShydWxlLCBydWxlQ2FsbC5hcmd1bWVudHMpIDogKCkgPT4gKHt9KTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLnN1YnJ1bGUoaWR4LCBnZXRSdWxlKGN0eCwgcnVsZSksIHJ1bGVDYWxsLCBwcmVkaWNhdGUoYXJncykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1Rlcm1pbmFsUnVsZShydWxlKSkge1xuICAgICAgICBjb25zdCBpZHggPSBjdHguY29uc3VtZSsrO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBnZXRUb2tlbihjdHgsIHJ1bGUubmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjdHgucGFyc2VyLmNvbnN1bWUoaWR4LCBtZXRob2QsIHJ1bGVDYWxsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXJ1bGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yV2l0aExvY2F0aW9uKHJ1bGVDYWxsLiRjc3ROb2RlLCBgVW5kZWZpbmVkIHJ1bGUgdHlwZTogJHtydWxlQ2FsbC4kdHlwZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFVucmVhY2hhYmxlKHJ1bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUnVsZUNhbGxQcmVkaWNhdGUocnVsZSwgbmFtZWRBcmdzKSB7XG4gICAgY29uc3QgcHJlZGljYXRlcyA9IG5hbWVkQXJncy5tYXAoZSA9PiBidWlsZFByZWRpY2F0ZShlLnZhbHVlKSk7XG4gICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJ1bGVBcmdzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZGljYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcnVsZVRhcmdldCA9IHJ1bGUucGFyYW1ldGVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHByZWRpY2F0ZXNbaV07XG4gICAgICAgICAgICBydWxlQXJnc1tydWxlVGFyZ2V0Lm5hbWVdID0gcHJlZGljYXRlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydWxlQXJncztcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRQcmVkaWNhdGUoY29uZGl0aW9uKSB7XG4gICAgaWYgKGlzRGlzanVuY3Rpb24oY29uZGl0aW9uKSkge1xuICAgICAgICBjb25zdCBsZWZ0ID0gYnVpbGRQcmVkaWNhdGUoY29uZGl0aW9uLmxlZnQpO1xuICAgICAgICBjb25zdCByaWdodCA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi5yaWdodCk7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gKGxlZnQoYXJncykgfHwgcmlnaHQoYXJncykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Nvbmp1bmN0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi5sZWZ0KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZFByZWRpY2F0ZShjb25kaXRpb24ucmlnaHQpO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IChsZWZ0KGFyZ3MpICYmIHJpZ2h0KGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOZWdhdGlvbihjb25kaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYnVpbGRQcmVkaWNhdGUoY29uZGl0aW9uLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiAhdmFsdWUoYXJncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUGFyYW1ldGVyUmVmZXJlbmNlKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGNvbmRpdGlvbi5wYXJhbWV0ZXIucmVmLm5hbWU7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gYXJncyAhPT0gdW5kZWZpbmVkICYmIGFyZ3NbbmFtZV0gPT09IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQm9vbGVhbkxpdGVyYWwoY29uZGl0aW9uKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEJvb2xlYW4oY29uZGl0aW9uLnRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gdmFsdWU7XG4gICAgfVxuICAgIGFzc2VydFVucmVhY2hhYmxlKGNvbmRpdGlvbik7XG59XG5mdW5jdGlvbiBidWlsZEFsdGVybmF0aXZlcyhjdHgsIGFsdGVybmF0aXZlcykge1xuICAgIGlmIChhbHRlcm5hdGl2ZXMuZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWlsZEVsZW1lbnQoY3R4LCBhbHRlcm5hdGl2ZXMuZWxlbWVudHNbMF0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWV0aG9kcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgYWx0ZXJuYXRpdmVzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGVkTWV0aG9kID0ge1xuICAgICAgICAgICAgICAgIC8vIFNpbmNlIHdlIGhhbmRsZSB0aGUgZ3VhcmQgY29uZGl0aW9uIGluIHRoZSBhbHRlcm5hdGl2ZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGUgZ3JvdXAgZ3VhcmQgY29uZGl0aW9uIGluc2lkZVxuICAgICAgICAgICAgICAgIEFMVDogYnVpbGRFbGVtZW50KGN0eCwgZWxlbWVudCwgdHJ1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBndWFyZCA9IGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGd1YXJkKSB7XG4gICAgICAgICAgICAgICAgcHJlZGljYXRlZE1ldGhvZC5HQVRFID0gYnVpbGRQcmVkaWNhdGUoZ3VhcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0aG9kcy5wdXNoKHByZWRpY2F0ZWRNZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5vcisrO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IGN0eC5wYXJzZXIuYWx0ZXJuYXRpdmVzKGlkeCwgbWV0aG9kcy5tYXAobWV0aG9kID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsdCA9IHtcbiAgICAgICAgICAgICAgICBBTFQ6ICgpID0+IG1ldGhvZC5BTFQoYXJncylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBnYXRlID0gbWV0aG9kLkdBVEU7XG4gICAgICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGFsdC5HQVRFID0gKCkgPT4gZ2F0ZShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhbHQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFVub3JkZXJlZEdyb3VwKGN0eCwgZ3JvdXApIHtcbiAgICBpZiAoZ3JvdXAuZWxlbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBidWlsZEVsZW1lbnQoY3R4LCBncm91cC5lbGVtZW50c1swXSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZ3JvdXAuZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgcHJlZGljYXRlZE1ldGhvZCA9IHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHdlIGhhbmRsZSB0aGUgZ3VhcmQgY29uZGl0aW9uIGluIHRoZSBhbHRlcm5hdGl2ZSBhbHJlYWR5XG4gICAgICAgICAgICAvLyBXZSBjYW4gaWdub3JlIHRoZSBncm91cCBndWFyZCBjb25kaXRpb24gaW5zaWRlXG4gICAgICAgICAgICBBTFQ6IGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGd1YXJkID0gZ2V0R3VhcmRDb25kaXRpb24oZWxlbWVudCk7XG4gICAgICAgIGlmIChndWFyZCkge1xuICAgICAgICAgICAgcHJlZGljYXRlZE1ldGhvZC5HQVRFID0gYnVpbGRQcmVkaWNhdGUoZ3VhcmQpO1xuICAgICAgICB9XG4gICAgICAgIG1ldGhvZHMucHVzaChwcmVkaWNhdGVkTWV0aG9kKTtcbiAgICB9XG4gICAgY29uc3Qgb3JJZHggPSBjdHgub3IrKztcbiAgICBjb25zdCBpZEZ1bmMgPSAoZ3JvdXBJZHgsIGxQYXJzZXIpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhY2tJZCA9IGxQYXJzZXIuZ2V0UnVsZVN0YWNrKCkuam9pbignLScpO1xuICAgICAgICByZXR1cm4gYHVHcm91cF8ke2dyb3VwSWR4fV8ke3N0YWNrSWR9YDtcbiAgICB9O1xuICAgIGNvbnN0IGFsdGVybmF0aXZlcyA9IChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhvcklkeCwgbWV0aG9kcy5tYXAoKG1ldGhvZCwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IGFsdCA9IHsgQUxUOiAoKSA9PiB0cnVlIH07XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGN0eC5wYXJzZXI7XG4gICAgICAgIGFsdC5BTFQgPSAoKSA9PiB7XG4gICAgICAgICAgICBtZXRob2QuQUxUKGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCFwYXJzZXIuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGlkRnVuYyhvcklkeCwgcGFyc2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlci51bm9yZGVyZWRHcm91cHMuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdCBhZnRlciBjbGVhciBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIudW5vcmRlcmVkR3JvdXBzLnNldChrZXksIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBTdGF0ZSA9IHBhcnNlci51bm9yZGVyZWRHcm91cHMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZ3JvdXBTdGF0ZSA9PT0gbnVsbCB8fCBncm91cFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncm91cFN0YXRlW2lkeF0pID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWNjZXNzZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwU3RhdGVbaWR4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnYXRlID0gbWV0aG9kLkdBVEU7XG4gICAgICAgIGlmIChnYXRlKSB7XG4gICAgICAgICAgICBhbHQuR0FURSA9ICgpID0+IGdhdGUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbHQuR0FURSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQWx0ZXJuYXRpdmVzID0gcGFyc2VyLnVub3JkZXJlZEdyb3Vwcy5nZXQoaWRGdW5jKG9ySWR4LCBwYXJzZXIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvdyA9ICEodHJhY2tlZEFsdGVybmF0aXZlcyA9PT0gbnVsbCB8fCB0cmFja2VkQWx0ZXJuYXRpdmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFja2VkQWx0ZXJuYXRpdmVzW2lkeF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGxvdztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsdDtcbiAgICB9KSk7XG4gICAgY29uc3Qgd3JhcHBlZCA9IHdyYXAoY3R4LCBnZXRHdWFyZENvbmRpdGlvbihncm91cCksIGFsdGVybmF0aXZlcywgJyonKTtcbiAgICByZXR1cm4gKGFyZ3MpID0+IHtcbiAgICAgICAgd3JhcHBlZChhcmdzKTtcbiAgICAgICAgaWYgKCFjdHgucGFyc2VyLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgIGN0eC5wYXJzZXIudW5vcmRlcmVkR3JvdXBzLmRlbGV0ZShpZEZ1bmMob3JJZHgsIGN0eC5wYXJzZXIpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZEdyb3VwKGN0eCwgZ3JvdXApIHtcbiAgICBjb25zdCBtZXRob2RzID0gZ3JvdXAuZWxlbWVudHMubWFwKGUgPT4gYnVpbGRFbGVtZW50KGN0eCwgZSkpO1xuICAgIHJldHVybiAoYXJncykgPT4gbWV0aG9kcy5mb3JFYWNoKG1ldGhvZCA9PiBtZXRob2QoYXJncykpO1xufVxuZnVuY3Rpb24gZ2V0R3VhcmRDb25kaXRpb24oZWxlbWVudCkge1xuICAgIGlmIChpc0dyb3VwKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lmd1YXJkQ29uZGl0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gYnVpbGRDcm9zc1JlZmVyZW5jZShjdHgsIGNyb3NzUmVmLCB0ZXJtaW5hbCA9IGNyb3NzUmVmLnRlcm1pbmFsKSB7XG4gICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICBpZiAoIWNyb3NzUmVmLnR5cGUucmVmKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSB0byB0eXBlOiAnICsgY3Jvc3NSZWYudHlwZS4kcmVmVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IGZpbmROYW1lQXNzaWdubWVudChjcm9zc1JlZi50eXBlLnJlZik7XG4gICAgICAgIGNvbnN0IGFzc2lnblRlcm1pbmFsID0gYXNzaWdubWVudCA9PT0gbnVsbCB8fCBhc3NpZ25tZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhc3NpZ25tZW50LnRlcm1pbmFsO1xuICAgICAgICBpZiAoIWFzc2lnblRlcm1pbmFsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIG5hbWUgYXNzaWdubWVudCBmb3IgdHlwZTogJyArIGdldFR5cGVOYW1lKGNyb3NzUmVmLnR5cGUucmVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkQ3Jvc3NSZWZlcmVuY2UoY3R4LCBjcm9zc1JlZiwgYXNzaWduVGVybWluYWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bGVDYWxsKHRlcm1pbmFsKSAmJiBpc1BhcnNlclJ1bGUodGVybWluYWwucnVsZS5yZWYpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5zdWJydWxlKys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5zdWJydWxlKGlkeCwgZ2V0UnVsZShjdHgsIHRlcm1pbmFsLnJ1bGUucmVmKSwgY3Jvc3NSZWYsIGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bGVDYWxsKHRlcm1pbmFsKSAmJiBpc1Rlcm1pbmFsUnVsZSh0ZXJtaW5hbC5ydWxlLnJlZikpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgY29uc3QgdGVybWluYWxSdWxlID0gZ2V0VG9rZW4oY3R4LCB0ZXJtaW5hbC5ydWxlLnJlZi5uYW1lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIHRlcm1pbmFsUnVsZSwgY3Jvc3NSZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0tleXdvcmQodGVybWluYWwpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5jb25zdW1lKys7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSBnZXRUb2tlbihjdHgsIHRlcm1pbmFsLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIGtleXdvcmQsIGNyb3NzUmVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGJ1aWxkIGNyb3NzIHJlZmVyZW5jZSBwYXJzZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEtleXdvcmQoY3R4LCBrZXl3b3JkKSB7XG4gICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICBjb25zdCB0b2tlbiA9IGN0eC50b2tlbnNba2V5d29yZC52YWx1ZV07XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRva2VuIGZvciBrZXl3b3JkOiAnICsga2V5d29yZC52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjdHgucGFyc2VyLmNvbnN1bWUoaWR4LCB0b2tlbiwga2V5d29yZCk7XG59XG5mdW5jdGlvbiB3cmFwKGN0eCwgZ3VhcmQsIG1ldGhvZCwgY2FyZGluYWxpdHkpIHtcbiAgICBjb25zdCBnYXRlID0gZ3VhcmQgJiYgYnVpbGRQcmVkaWNhdGUoZ3VhcmQpO1xuICAgIGlmICghY2FyZGluYWxpdHkpIHtcbiAgICAgICAgaWYgKGdhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGN0eC5vcisrO1xuICAgICAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhpZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICBHQVRFOiAoKSA9PiBnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogRU1QVFlfQUxUKCksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+ICFnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJkaW5hbGl0eSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5tYW55Kys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5tYW55KGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICcrJykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgubWFueSsrO1xuICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgY29uc3Qgb3JJZHggPSBjdHgub3IrKztcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgZ3VhcmQgY29uZGl0aW9uIGZvciB0aGUgYCtgIGdyb3VwXG4gICAgICAgICAgICAvLyBXZSBjb21iaW5lIGl0IHdpdGggYW4gZW1wdHkgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25kaXRpb24gcmV0dXJucyB0cnVlLCBpdCBuZWVkcyB0byBwYXJzZSBhdCBsZWFzdCBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICAgIC8vIElmIGl0cyBmYWxzZSwgaXQgaXMgbm90IGFsbG93ZWQgdG8gcGFyc2UgYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hbHRlcm5hdGl2ZXMob3JJZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncylcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+IGdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgQUxUOiBFTVBUWV9BTFQoKSxcbiAgICAgICAgICAgICAgICAgICAgR0FURTogKCkgPT4gIWdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgIERFRjogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICc/Jykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgub3B0aW9uYWwrKztcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLm9wdGlvbmFsKGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFVucmVhY2hhYmxlKGNhcmRpbmFsaXR5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSdWxlKGN0eCwgZWxlbWVudCkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRSdWxlTmFtZShjdHgsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHJ1bGUgPSBjdHgucnVsZXMuZ2V0KG5hbWUpO1xuICAgIGlmICghcnVsZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSdWxlIFwiJHtuYW1lfVwiIG5vdCBmb3VuZC5cImApO1xuICAgIHJldHVybiBydWxlO1xufVxuZnVuY3Rpb24gZ2V0UnVsZU5hbWUoY3R4LCBlbGVtZW50KSB7XG4gICAgaWYgKGlzUGFyc2VyUnVsZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdHgucnVsZU5hbWVzLmhhcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gY3R4LnJ1bGVOYW1lcy5nZXQoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgaXRlbSA9IGVsZW1lbnQ7XG4gICAgICAgIGxldCBwYXJlbnQgPSBpdGVtLiRjb250YWluZXI7XG4gICAgICAgIGxldCBydWxlTmFtZSA9IGVsZW1lbnQuJHR5cGU7XG4gICAgICAgIHdoaWxlICghaXNQYXJzZXJSdWxlKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmIChpc0dyb3VwKHBhcmVudCkgfHwgaXNBbHRlcm5hdGl2ZXMocGFyZW50KSB8fCBpc1Vub3JkZXJlZEdyb3VwKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHBhcmVudC5lbGVtZW50cy5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHJ1bGVOYW1lID0gaW5kZXgudG9TdHJpbmcoKSArICc6JyArIHJ1bGVOYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IHBhcmVudDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC4kY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBwYXJlbnQ7XG4gICAgICAgIHJ1bGVOYW1lID0gcnVsZS5uYW1lICsgJzonICsgcnVsZU5hbWU7XG4gICAgICAgIGN0eC5ydWxlTmFtZXMuc2V0KGVsZW1lbnQsIHJ1bGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIHJ1bGVOYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRva2VuKGN0eCwgbmFtZSkge1xuICAgIGNvbnN0IHRva2VuID0gY3R4LnRva2Vuc1tuYW1lXTtcbiAgICBpZiAoIXRva2VuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuIFwiJHtuYW1lfVwiIG5vdCBmb3VuZC5cImApO1xuICAgIHJldHVybiB0b2tlbjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci1idWlsZGVyLWJhc2UuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgTGFuZ2l1bUNvbXBsZXRpb25QYXJzZXIgfSBmcm9tICcuL2xhbmdpdW0tcGFyc2VyLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhcnNlciB9IGZyb20gJy4vcGFyc2VyLWJ1aWxkZXItYmFzZS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29tcGxldGlvblBhcnNlcihzZXJ2aWNlcykge1xuICAgIGNvbnN0IGdyYW1tYXIgPSBzZXJ2aWNlcy5HcmFtbWFyO1xuICAgIGNvbnN0IGxleGVyID0gc2VydmljZXMucGFyc2VyLkxleGVyO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBMYW5naXVtQ29tcGxldGlvblBhcnNlcihzZXJ2aWNlcyk7XG4gICAgY3JlYXRlUGFyc2VyKGdyYW1tYXIsIHBhcnNlciwgbGV4ZXIuZGVmaW5pdGlvbik7XG4gICAgcGFyc2VyLmZpbmFsaXplKCk7XG4gICAgcmV0dXJuIHBhcnNlcjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgTGFuZ2l1bVBhcnNlciB9IGZyb20gJy4vbGFuZ2l1bS1wYXJzZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXItYnVpbGRlci1iYXNlLmpzJztcbi8qKlxuICogQ3JlYXRlIGFuZCBmaW5hbGl6ZSBhIExhbmdpdW0gcGFyc2VyLiBUaGUgcGFyc2VyIHJ1bGVzIGFyZSBkZXJpdmVkIGZyb20gdGhlIGdyYW1tYXIsIHdoaWNoIGlzXG4gKiBhdmFpbGFibGUgYXQgYHNlcnZpY2VzLkdyYW1tYXJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHByZXBhcmVMYW5naXVtUGFyc2VyKHNlcnZpY2VzKTtcbiAgICBwYXJzZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcGFyc2VyO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBMYW5naXVtIHBhcnNlciB3aXRob3V0IGZpbmFsaXppbmcgaXQuIFRoaXMgaXMgdXNlZCB0byBleHRyYWN0IG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAqIGluZm9ybWF0aW9uIHdoZW4gdGhlIHBhcnNlciBpcyBpbml0aWFsbHkgdmFsaWRhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxhbmdpdW1QYXJzZXIoc2VydmljZXMpIHtcbiAgICBjb25zdCBncmFtbWFyID0gc2VydmljZXMuR3JhbW1hcjtcbiAgICBjb25zdCBsZXhlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlcjtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcihncmFtbWFyLCBwYXJzZXIsIGxleGVyLmRlZmluaXRpb24pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ2l1bS1wYXJzZXItYnVpbGRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuaW1wb3J0IHsgaXNLZXl3b3JkLCBpc1BhcnNlclJ1bGUsIGlzVGVybWluYWxSdWxlIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMnO1xuaW1wb3J0IHsgc3RyZWFtQWxsQ29udGVudHMgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0QWxsUmVhY2hhYmxlUnVsZXMsIHRlcm1pbmFsUmVnZXggfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGdldENhc2VJbnNlbnNpdGl2ZVBhdHRlcm4sIGlzV2hpdGVzcGFjZSwgcGFydGlhbE1hdGNoZXMgfSBmcm9tICcuLi91dGlscy9yZWdleHAtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0VG9rZW5CdWlsZGVyIHtcbiAgICBidWlsZFRva2VucyhncmFtbWFyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlYWNoYWJsZVJ1bGVzID0gc3RyZWFtKGdldEFsbFJlYWNoYWJsZVJ1bGVzKGdyYW1tYXIsIGZhbHNlKSk7XG4gICAgICAgIGNvbnN0IHRlcm1pbmFsVG9rZW5zID0gdGhpcy5idWlsZFRlcm1pbmFsVG9rZW5zKHJlYWNoYWJsZVJ1bGVzKTtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5idWlsZEtleXdvcmRUb2tlbnMocmVhY2hhYmxlUnVsZXMsIHRlcm1pbmFsVG9rZW5zLCBvcHRpb25zKTtcbiAgICAgICAgdGVybWluYWxUb2tlbnMuZm9yRWFjaCh0ZXJtaW5hbFRva2VuID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0ZXJtaW5hbFRva2VuLlBBVFRFUk47XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdvYmplY3QnICYmIHBhdHRlcm4gJiYgJ3Rlc3QnIGluIHBhdHRlcm4gJiYgaXNXaGl0ZXNwYWNlKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnVuc2hpZnQodGVybWluYWxUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0ZXJtaW5hbFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gYWRkIHRoZSBFT0YgdG9rZW4gZXhwbGljaXRseS5cbiAgICAgICAgLy8gSXQgaXMgYXV0b21hdGljYWxseSBhdmFpbGFibGUgYXQgdGhlIGVuZCBvZiB0aGUgdG9rZW4gc3RyZWFtLlxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICBidWlsZFRlcm1pbmFsVG9rZW5zKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiBydWxlcy5maWx0ZXIoaXNUZXJtaW5hbFJ1bGUpLmZpbHRlcihlID0+ICFlLmZyYWdtZW50KVxuICAgICAgICAgICAgLm1hcCh0ZXJtaW5hbCA9PiB0aGlzLmJ1aWxkVGVybWluYWxUb2tlbih0ZXJtaW5hbCkpLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgYnVpbGRUZXJtaW5hbFRva2VuKHRlcm1pbmFsKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ID0gdGVybWluYWxSZWdleCh0ZXJtaW5hbCk7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0aGlzLnJlcXVpcmVzQ3VzdG9tUGF0dGVybihyZWdleCkgPyB0aGlzLnJlZ2V4UGF0dGVybkZ1bmN0aW9uKHJlZ2V4KSA6IHJlZ2V4O1xuICAgICAgICBjb25zdCB0b2tlblR5cGUgPSB7XG4gICAgICAgICAgICBuYW1lOiB0ZXJtaW5hbC5uYW1lLFxuICAgICAgICAgICAgUEFUVEVSTjogcGF0dGVybixcbiAgICAgICAgICAgIExJTkVfQlJFQUtTOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0ZXJtaW5hbC5oaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2tpcCB0b2tlbnMgdGhhdCBhcmUgYWJsZSB0byBhY2NlcHQgd2hpdGVzcGFjZVxuICAgICAgICAgICAgdG9rZW5UeXBlLkdST1VQID0gaXNXaGl0ZXNwYWNlKHJlZ2V4KSA/IExleGVyLlNLSVBQRUQgOiAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5UeXBlO1xuICAgIH1cbiAgICByZXF1aXJlc0N1c3RvbVBhdHRlcm4ocmVnZXgpIHtcbiAgICAgICAgaWYgKHJlZ2V4LmZsYWdzLmluY2x1ZGVzKCd1JykpIHtcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgcmVnZXhlcyBhcmUgbm90IHN1cHBvcnRlZCBieSBDaGV2cm90YWluLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVnZXguc291cmNlLmluY2x1ZGVzKCc/PD0nKSB8fCByZWdleC5zb3VyY2UuaW5jbHVkZXMoJz88IScpKSB7XG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSBhbmQgcG9zaXRpdmUgbG9va2JlaGluZCBhcmUgbm90IHN1cHBvcnRlZCBieSBDaGV2cm90YWluIHlldC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZ2V4UGF0dGVybkZ1bmN0aW9uKHJlZ2V4KSB7XG4gICAgICAgIGNvbnN0IHN0aWNreVJlZ2V4ID0gbmV3IFJlZ0V4cChyZWdleCwgcmVnZXguZmxhZ3MgKyAneScpO1xuICAgICAgICByZXR1cm4gKHRleHQsIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgc3RpY2t5UmVnZXgubGFzdEluZGV4ID0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgZXhlY1Jlc3VsdCA9IHN0aWNreVJlZ2V4LmV4ZWModGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gZXhlY1Jlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRLZXl3b3JkVG9rZW5zKHJ1bGVzLCB0ZXJtaW5hbFRva2Vucywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gcnVsZXNcbiAgICAgICAgICAgIC8vIFdlIGZpbHRlciBieSBwYXJzZXIgcnVsZXMsIHNpbmNlIGtleXdvcmRzIGluIHRlcm1pbmFsIHJ1bGVzIGdldCB0cmFuc2Zvcm1lZCBpbnRvIHJlZ2V4IGFuZCBhcmUgbm90IGFjdHVhbCB0b2tlbnNcbiAgICAgICAgICAgIC5maWx0ZXIoaXNQYXJzZXJSdWxlKVxuICAgICAgICAgICAgLmZsYXRNYXAocnVsZSA9PiBzdHJlYW1BbGxDb250ZW50cyhydWxlKS5maWx0ZXIoaXNLZXl3b3JkKSlcbiAgICAgICAgICAgIC5kaXN0aW5jdChlID0+IGUudmFsdWUpLnRvQXJyYXkoKVxuICAgICAgICAgICAgLy8gU29ydCBrZXl3b3JkcyBieSBkZXNjZW5kaW5nIGxlbmd0aFxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIudmFsdWUubGVuZ3RoIC0gYS52YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICAubWFwKGtleXdvcmQgPT4gdGhpcy5idWlsZEtleXdvcmRUb2tlbihrZXl3b3JkLCB0ZXJtaW5hbFRva2VucywgQm9vbGVhbihvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FzZUluc2Vuc2l0aXZlKSkpO1xuICAgIH1cbiAgICBidWlsZEtleXdvcmRUb2tlbihrZXl3b3JkLCB0ZXJtaW5hbFRva2VucywgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBrZXl3b3JkLnZhbHVlLFxuICAgICAgICAgICAgUEFUVEVSTjogdGhpcy5idWlsZEtleXdvcmRQYXR0ZXJuKGtleXdvcmQsIGNhc2VJbnNlbnNpdGl2ZSksXG4gICAgICAgICAgICBMT05HRVJfQUxUOiB0aGlzLmZpbmRMb25nZXJBbHQoa2V5d29yZCwgdGVybWluYWxUb2tlbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGJ1aWxkS2V5d29yZFBhdHRlcm4oa2V5d29yZCwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBjYXNlSW5zZW5zaXRpdmUgP1xuICAgICAgICAgICAgbmV3IFJlZ0V4cChnZXRDYXNlSW5zZW5zaXRpdmVQYXR0ZXJuKGtleXdvcmQudmFsdWUpKSA6XG4gICAgICAgICAgICBrZXl3b3JkLnZhbHVlO1xuICAgIH1cbiAgICBmaW5kTG9uZ2VyQWx0KGtleXdvcmQsIHRlcm1pbmFsVG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0ZXJtaW5hbFRva2Vucy5yZWR1Y2UoKGxvbmdlckFsdHMsIHRva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLlBBVFRFUk47XG4gICAgICAgICAgICBpZiAoKHBhdHRlcm4gPT09IG51bGwgfHwgcGF0dGVybiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0dGVybi5zb3VyY2UpICYmIHBhcnRpYWxNYXRjaGVzKCdeJyArIHBhdHRlcm4uc291cmNlICsgJyQnLCBrZXl3b3JkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxvbmdlckFsdHMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9uZ2VyQWx0cztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuLWJ1aWxkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgaXNDcm9zc1JlZmVyZW5jZSwgaXNSdWxlQ2FsbCB9IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGdldENyb3NzUmVmZXJlbmNlVGVybWluYWwsIGdldFJ1bGVUeXBlIH0gZnJvbSAnLi4vdXRpbHMvZ3JhbW1hci11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFZhbHVlQ29udmVydGVyIHtcbiAgICBjb252ZXJ0KGlucHV0LCBjc3ROb2RlKSB7XG4gICAgICAgIGxldCBmZWF0dXJlID0gY3N0Tm9kZS5ncmFtbWFyU291cmNlO1xuICAgICAgICBpZiAoaXNDcm9zc1JlZmVyZW5jZShmZWF0dXJlKSkge1xuICAgICAgICAgICAgZmVhdHVyZSA9IGdldENyb3NzUmVmZXJlbmNlVGVybWluYWwoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnVsZUNhbGwoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBmZWF0dXJlLnJ1bGUucmVmO1xuICAgICAgICAgICAgaWYgKCFydWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNzdCBub2RlIHdhcyBub3QgcGFyc2VkIGJ5IGEgcnVsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkNvbnZlcnRlcihydWxlLCBpbnB1dCwgY3N0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcnVuQ29udmVydGVyKHJ1bGUsIGlucHV0LCBjc3ROb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChydWxlLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnSU5UJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRJbnQoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnU1RSSU5HJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnSUQnOiByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuY29udmVydElEKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKChfYSA9IGdldFJ1bGVUeXBlKHJ1bGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnROdW1iZXIoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0Qm9vbGVhbihpbnB1dCk7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOiByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuY29udmVydEJpZ2ludChpbnB1dCk7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnREYXRlKGlucHV0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB2YXIgVmFsdWVDb252ZXJ0ZXI7XG4oZnVuY3Rpb24gKFZhbHVlQ29udmVydGVyKSB7XG4gICAgZnVuY3Rpb24gY29udmVydFN0cmluZyhpbnB1dCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gaW5wdXQuY2hhckF0KCsraSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNvbnZlcnRFc2NhcGVDaGFyYWN0ZXIoYzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydFN0cmluZyA9IGNvbnZlcnRTdHJpbmc7XG4gICAgZnVuY3Rpb24gY29udmVydEVzY2FwZUNoYXJhY3RlcihjaGFyKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnYic6IHJldHVybiAnXFxiJztcbiAgICAgICAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ1xcZic7XG4gICAgICAgICAgICBjYXNlICduJzogcmV0dXJuICdcXG4nO1xuICAgICAgICAgICAgY2FzZSAncic6IHJldHVybiAnXFxyJztcbiAgICAgICAgICAgIGNhc2UgJ3QnOiByZXR1cm4gJ1xcdCc7XG4gICAgICAgICAgICBjYXNlICd2JzogcmV0dXJuICdcXHYnO1xuICAgICAgICAgICAgY2FzZSAnMCc6IHJldHVybiAnXFwwJztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBjaGFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRJRChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckF0KDApID09PSAnXicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydElEID0gY29udmVydElEO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRJbnQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydEludCA9IGNvbnZlcnRJbnQ7XG4gICAgZnVuY3Rpb24gY29udmVydEJpZ2ludChpbnB1dCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydEJpZ2ludCA9IGNvbnZlcnRCaWdpbnQ7XG4gICAgZnVuY3Rpb24gY29udmVydERhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydERhdGUgPSBjb252ZXJ0RGF0ZTtcbiAgICBmdW5jdGlvbiBjb252ZXJ0TnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoaW5wdXQpO1xuICAgIH1cbiAgICBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0TnVtYmVyID0gY29udmVydE51bWJlcjtcbiAgICBmdW5jdGlvbiBjb252ZXJ0Qm9vbGVhbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0Qm9vbGVhbiA9IGNvbnZlcnRCb29sZWFuO1xufSkoVmFsdWVDb252ZXJ0ZXIgfHwgKFZhbHVlQ29udmVydGVyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLWNvbnZlcnRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyNCBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5leHBvcnQgKiBmcm9tICd2c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5jZWxsYXRpb24uanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4sIENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbi8qKlxuICogRGVsYXlzIHRoZSBleGVjdXRpb24gb2YgdGhlIGN1cnJlbnQgY29kZSB0byB0aGUgbmV4dCB0aWNrIG9mIHRoZSBldmVudCBsb29wLlxuICogRG9uJ3QgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSBpbiBhIHRpZ2h0IGxvb3AgdG8gcHJldmVudCB0b28gbWFueSBwcm9taXNlcyBmcm9tIGJlaW5nIGNyZWF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxheU5leHRUaWNrKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgLy8gSW4gY2FzZSB3ZSBhcmUgcnVubmluZyBpbiBhIG5vbi1ub2RlIGVudmlyb25tZW50LCBgc2V0SW1tZWRpYXRlYCBpc24ndCBhdmFpbGFibGUuXG4gICAgICAgIC8vIFVzaW5nIGBzZXRUaW1lb3V0YCBvZiB0aGUgYnJvd3NlciBBUEkgYWNjb21wbGlzaGVzIHRoZSBzYW1lIHJlc3VsdC5cbiAgICAgICAgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5sZXQgbGFzdFRpY2sgPSAwO1xubGV0IGdsb2JhbEludGVycnVwdGlvblBlcmlvZCA9IDEwO1xuLyoqXG4gKiBSZXNldCB0aGUgZ2xvYmFsIGludGVycnVwdGlvbiBwZXJpb2QgYW5kIGNyZWF0ZSBhIGNhbmNlbGxhdGlvbiB0b2tlbiBzb3VyY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydENhbmNlbGFibGVPcGVyYXRpb24oKSB7XG4gICAgbGFzdFRpY2sgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbn1cbi8qKlxuICogQ2hhbmdlIHRoZSBwZXJpb2QgZHVyYXRpb24gZm9yIGBpbnRlcnJ1cHRBbmRDaGVja2AgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxMG1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SW50ZXJydXB0aW9uUGVyaW9kKHBlcmlvZCkge1xuICAgIGdsb2JhbEludGVycnVwdGlvblBlcmlvZCA9IHBlcmlvZDtcbn1cbi8qKlxuICogVGhpcyBzeW1ib2wgbWF5IGJlIHRocm93biBpbiBhbiBhc3luY2hyb25vdXMgY29udGV4dCBieSBhbnkgTGFuZ2l1bSBzZXJ2aWNlIHRoYXQgcmVjZWl2ZXNcbiAqIGEgYENhbmNlbGxhdGlvblRva2VuYC4gVGhpcyBtZWFucyB0aGF0IHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHN1Y2ggYSBzZXJ2aWNlIGlzIHJlamVjdGVkIHdpdGhcbiAqIHRoaXMgc3ltYm9sIGFzIHJlamVjdGlvbiByZWFzb24uXG4gKi9cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25DYW5jZWxsZWQgPSBTeW1ib2woJ09wZXJhdGlvbkNhbmNlbGxlZCcpO1xuLyoqXG4gKiBVc2UgdGhpcyBpbiBhIGBjYXRjaGAgYmxvY2sgdG8gY2hlY2sgd2hldGhlciB0aGUgdGhyb3duIG9iamVjdCBpbmRpY2F0ZXMgdGhhdCB0aGUgb3BlcmF0aW9uXG4gKiBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpIHtcbiAgICByZXR1cm4gZXJyID09PSBPcGVyYXRpb25DYW5jZWxsZWQ7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyB0d28gdGhpbmdzOlxuICogIDEuIENoZWNrIHRoZSBlbGFwc2VkIHRpbWUgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIG9yIHRvIGBzdGFydENhbmNlbGFibGVPcGVyYXRpb25gLiBJZiB0aGUgcHJlZGVmaW5lZFxuICogICAgIHBlcmlvZCAoY29uZmlndXJlZCB3aXRoIGBzZXRJbnRlcnJ1cHRpb25QZXJpb2RgKSBpcyBleGNlZWRlZCwgZXhlY3V0aW9uIGlzIGRlbGF5ZWQgd2l0aCBgZGVsYXlOZXh0VGlja2AuXG4gKiAgMi4gSWYgdGhlIHByZWRlZmluZWQgcGVyaW9kIGlzIG5vdCBtZXQgeWV0IG9yIGV4ZWN1dGlvbiBpcyByZXN1bWVkIGFmdGVyIGFuIGludGVycnVwdGlvbiwgdGhlIGdpdmVuIGNhbmNlbGxhdGlvblxuICogICAgIHRva2VuIGlzIGNoZWNrZWQsIGFuZCBpZiBjYW5jZWxsYXRpb24gaXMgcmVxdWVzdGVkLCBgT3BlcmF0aW9uQ2FuY2VsZWRgIGlzIHRocm93bi5cbiAqXG4gKiBBbGwgc2VydmljZXMgaW4gTGFuZ2l1bSB0aGF0IHJlY2VpdmUgYSBgQ2FuY2VsbGF0aW9uVG9rZW5gIG1heSBwb3RlbnRpYWxseSBjYWxsIHRoaXMgZnVuY3Rpb24sIHNvIHRoZVxuICogYENhbmNlbGxhdGlvblRva2VuYCBtdXN0IGJlIGNhdWdodCAod2l0aCBhbiBgYXN5bmNgIHRyeS1jYXRjaCBibG9jayBvciBhIGBjYXRjaGAgY2FsbGJhY2sgYXR0YWNoZWQgdG9cbiAqIHRoZSBwcm9taXNlKSB0byBhdm9pZCB0aGF0IGV2ZW50IGJlaW5nIGV4cG9zZWQgYXMgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRlcnJ1cHRBbmRDaGVjayh0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICAvLyBFYXJseSBleGl0IGluIGNhc2UgY2FuY2VsbGF0aW9uIHdhcyBkaXNhYmxlZCBieSB0aGUgY2FsbGVyXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IERhdGUubm93KCk7XG4gICAgaWYgKGN1cnJlbnQgLSBsYXN0VGljayA+PSBnbG9iYWxJbnRlcnJ1cHRpb25QZXJpb2QpIHtcbiAgICAgICAgbGFzdFRpY2sgPSBjdXJyZW50O1xuICAgICAgICBhd2FpdCBkZWxheU5leHRUaWNrKCk7XG4gICAgfVxuICAgIGlmICh0b2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xuICAgICAgICB0aHJvdyBPcGVyYXRpb25DYW5jZWxsZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBTaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGRlZmVycmVkIHBhdHRlcm4uXG4gKiBBbiBvYmplY3QgdGhhdCBleHBvc2VzIGEgcHJvbWlzZSBhbmQgZnVuY3Rpb25zIHRvIHJlc29sdmUgYW5kIHJlamVjdCBpdC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmVycmVkIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoYXJnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnJlamVjdCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2UtdXRpbHMuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuJ3VzZSBzdHJpY3QnO1xuY2xhc3MgRnVsbFRleHREb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IGxhbmd1YWdlSWQ7XG4gICAgICAgIHRoaXMuX3ZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCB1cmkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmk7XG4gICAgfVxuICAgIGdldCBsYW5ndWFnZUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGFuZ3VhZ2VJZDtcbiAgICB9XG4gICAgZ2V0IHZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJzaW9uO1xuICAgIH1cbiAgICBnZXRUZXh0KHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGNoYW5nZXMsIHZlcnNpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNJbmNyZW1lbnRhbChjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFrZXMgc3VyZSBzdGFydCBpcyBiZWZvcmUgZW5kXG4gICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRXZWxsZm9ybWVkUmFuZ2UoY2hhbmdlLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY29udGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSB0aGlzLl9jb250ZW50LnN1YnN0cmluZygwLCBzdGFydE9mZnNldCkgKyBjaGFuZ2UudGV4dCArIHRoaXMuX2NvbnRlbnQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgb2Zmc2V0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0LmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZExpbmUgPSBNYXRoLm1heChyYW5nZS5lbmQubGluZSwgMCk7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWRMaW5lT2Zmc2V0cyA9IGNvbXB1dGVMaW5lT2Zmc2V0cyhjaGFuZ2UudGV4dCwgZmFsc2UsIHN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kTGluZSAtIHN0YXJ0TGluZSA9PT0gYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzW2kgKyBzdGFydExpbmUgKyAxXSA9IGFkZGVkTGluZU9mZnNldHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCA8IDEwMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0cy5zcGxpY2Uoc3RhcnRMaW5lICsgMSwgZW5kTGluZSAtIHN0YXJ0TGluZSwgLi4uYWRkZWRMaW5lT2Zmc2V0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGF2b2lkIHRvbyBtYW55IGFyZ3VtZW50cyBmb3Igc3BsaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzID0gbGluZU9mZnNldHMuc2xpY2UoMCwgc3RhcnRMaW5lICsgMSkuY29uY2F0KGFkZGVkTGluZU9mZnNldHMsIGxpbmVPZmZzZXRzLnNsaWNlKGVuZExpbmUgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChlbmRPZmZzZXQgLSBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZSArIDEgKyBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aCwgbGVuID0gbGluZU9mZnNldHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzW2ldID0gbGluZU9mZnNldHNbaV0gKyBkaWZmO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoRnVsbFRleHREb2N1bWVudC5pc0Z1bGwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRlbnQgPSBjaGFuZ2UudGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFuZ2UgZXZlbnQgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0TGluZU9mZnNldHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lT2Zmc2V0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGNvbXB1dGVMaW5lT2Zmc2V0cyh0aGlzLl9jb250ZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU9mZnNldHM7XG4gICAgfVxuICAgIHBvc2l0aW9uQXQob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGgubWF4KE1hdGgubWluKG9mZnNldCwgdGhpcy5fY29udGVudC5sZW5ndGgpLCAwKTtcbiAgICAgICAgY29uc3QgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY2hhcmFjdGVyOiBvZmZzZXQgfTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgY29uc3QgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgY29uc3QgbGluZSA9IGxvdyAtIDE7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldHNbbGluZV0pO1xuICAgICAgICByZXR1cm4geyBsaW5lLCBjaGFyYWN0ZXI6IG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdIH07XG4gICAgfVxuICAgIG9mZnNldEF0KHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGluZU9mZnNldCA9IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmVdO1xuICAgICAgICBpZiAocG9zaXRpb24uY2hhcmFjdGVyIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBNYXRoLm1pbihsaW5lT2Zmc2V0ICsgcG9zaXRpb24uY2hhcmFjdGVyLCBuZXh0TGluZU9mZnNldCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXQpO1xuICAgIH1cbiAgICBlbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KSB7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPiBsaW5lT2Zmc2V0ICYmIGlzRU9MKHRoaXMuX2NvbnRlbnQuY2hhckNvZGVBdChvZmZzZXQgLSAxKSkpIHtcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGdldCBsaW5lQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpbmVPZmZzZXRzKCkubGVuZ3RoO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbmNyZW1lbnRhbChldmVudCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbmRpZGF0ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBjYW5kaWRhdGUucmFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5yYW5nZUxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09ICdudW1iZXInKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnVsbChldmVudCkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSBldmVudDtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIGNhbmRpZGF0ZS50ZXh0ID09PSAnc3RyaW5nJyAmJiBjYW5kaWRhdGUucmFuZ2UgPT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgdmFyIFRleHREb2N1bWVudDtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgIFRoZSBkb2N1bWVudCdzIGxhbmd1YWdlIElkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIFRoZSBkb2N1bWVudCdzIGluaXRpYWwgdmVyc2lvbiBudW1iZXIuXG4gICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGRvY3VtZW50J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFRleHREb2N1bWVudCh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgYSBUZXh0RG9jdW1lbnQgYnkgbW9kaWZ5aW5nIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50IHRoZSBkb2N1bWVudCB0byB1cGRhdGUuIE9ubHkgZG9jdW1lbnRzIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZSBhcmUgdmFsaWQgaW5wdXRzLlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIHRoZSBjaGFuZ2VzIHRvIGFwcGx5IHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiB0aGUgY2hhbmdlcyB2ZXJzaW9uIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dERvY3VtZW50LiBOb3RlOiBUaGF0J3MgdGhlIHNhbWUgZG9jdW1lbnQgaW5zdGFuY2UgcGFzc2VkIGluIGFzIGZpcnN0IHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZShkb2N1bWVudCwgY2hhbmdlcywgdmVyc2lvbikge1xuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBGdWxsVGV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC51cGRhdGUoY2hhbmdlcywgdmVyc2lvbik7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHREb2N1bWVudC51cGRhdGU6IGRvY3VtZW50IG11c3QgYmUgY3JlYXRlZCBieSBUZXh0RG9jdW1lbnQuY3JlYXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGV4dERvY3VtZW50LnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuZ2V0VGV4dCgpO1xuICAgICAgICBjb25zdCBzb3J0ZWRFZGl0cyA9IG1lcmdlU29ydChlZGl0cy5tYXAoZ2V0V2VsbGZvcm1lZEVkaXQpLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGEucmFuZ2Uuc3RhcnQubGluZSAtIGIucmFuZ2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyIC0gYi5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGlmZjtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0TW9kaWZpZWRPZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBzcGFucyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc29ydGVkRWRpdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gZG9jdW1lbnQub2Zmc2V0QXQoZS5yYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPCBsYXN0TW9kaWZpZWRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ092ZXJsYXBwaW5nIGVkaXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0T2Zmc2V0ID4gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cmluZyhsYXN0TW9kaWZpZWRPZmZzZXQsIHN0YXJ0T2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZS5uZXdUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2goZS5uZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RNb2RpZmllZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHRleHQuc3Vic3RyKGxhc3RNb2RpZmllZE9mZnNldCkpO1xuICAgICAgICByZXR1cm4gc3BhbnMuam9pbignJyk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5hcHBseUVkaXRzID0gYXBwbHlFZGl0cztcbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbmZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgLy8gc29ydGVkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwID0gKGRhdGEubGVuZ3RoIC8gMikgfCAwO1xuICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgIGNvbnN0IHJpZ2h0ID0gZGF0YS5zbGljZShwKTtcbiAgICBtZXJnZVNvcnQobGVmdCwgY29tcGFyZSk7XG4gICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICBsZXQgbGVmdElkeCA9IDA7XG4gICAgbGV0IHJpZ2h0SWR4ID0gMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCAmJiByaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgIGlmIChyZXQgPD0gMCkge1xuICAgICAgICAgICAgLy8gc21hbGxlcl9lcXVhbCAtPiB0YWtlIGxlZnQgdG8gcHJlc2VydmUgb3JkZXJcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGxlZnRJZHggPCBsZWZ0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgfVxuICAgIHdoaWxlIChyaWdodElkeCA8IHJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICBkYXRhW2krK10gPSByaWdodFtyaWdodElkeCsrXTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZU9mZnNldHModGV4dCwgaXNBdExpbmVTdGFydCwgdGV4dE9mZnNldCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBpc0F0TGluZVN0YXJ0ID8gW3RleHRPZmZzZXRdIDogW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoaXNFT0woY2gpKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovICYmIGkgKyAxIDwgdGV4dC5sZW5ndGggJiYgdGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0ZXh0T2Zmc2V0ICsgaSArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBpc0VPTChjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIgPT09IDEzIC8qIENoYXJDb2RlLkNhcnJpYWdlUmV0dXJuICovIHx8IGNoYXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZFJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICBjb25zdCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgaWYgKHN0YXJ0LmxpbmUgPiBlbmQubGluZSB8fCAoc3RhcnQubGluZSA9PT0gZW5kLmxpbmUgJiYgc3RhcnQuY2hhcmFjdGVyID4gZW5kLmNoYXJhY3RlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IGVuZCwgZW5kOiBzdGFydCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG59XG5mdW5jdGlvbiBnZXRXZWxsZm9ybWVkRWRpdCh0ZXh0RWRpdCkge1xuICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKHRleHRFZGl0LnJhbmdlKTtcbiAgICBpZiAocmFuZ2UgIT09IHRleHRFZGl0LnJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IG5ld1RleHQ6IHRleHRFZGl0Lm5ld1RleHQsIHJhbmdlIH07XG4gICAgfVxuICAgIHJldHVybiB0ZXh0RWRpdDtcbn1cbiIsInZhciBMSUI7KCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9ezQ3MDp0PT57ZnVuY3Rpb24gZSh0KXtpZihcInN0cmluZ1wiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIitKU09OLnN0cmluZ2lmeSh0KSl9ZnVuY3Rpb24gcih0LGUpe2Zvcih2YXIgcixuPVwiXCIsaT0wLG89LTEscz0wLGg9MDtoPD10Lmxlbmd0aDsrK2gpe2lmKGg8dC5sZW5ndGgpcj10LmNoYXJDb2RlQXQoaCk7ZWxzZXtpZig0Nz09PXIpYnJlYWs7cj00N31pZig0Nz09PXIpe2lmKG89PT1oLTF8fDE9PT1zKTtlbHNlIGlmKG8hPT1oLTEmJjI9PT1zKXtpZihuLmxlbmd0aDwyfHwyIT09aXx8NDYhPT1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTIpKWlmKG4ubGVuZ3RoPjIpe3ZhciBhPW4ubGFzdEluZGV4T2YoXCIvXCIpO2lmKGEhPT1uLmxlbmd0aC0xKXstMT09PWE/KG49XCJcIixpPTApOmk9KG49bi5zbGljZSgwLGEpKS5sZW5ndGgtMS1uLmxhc3RJbmRleE9mKFwiL1wiKSxvPWgscz0wO2NvbnRpbnVlfX1lbHNlIGlmKDI9PT1uLmxlbmd0aHx8MT09PW4ubGVuZ3RoKXtuPVwiXCIsaT0wLG89aCxzPTA7Y29udGludWV9ZSYmKG4ubGVuZ3RoPjA/bis9XCIvLi5cIjpuPVwiLi5cIixpPTIpfWVsc2Ugbi5sZW5ndGg+MD9uKz1cIi9cIit0LnNsaWNlKG8rMSxoKTpuPXQuc2xpY2UobysxLGgpLGk9aC1vLTE7bz1oLHM9MH1lbHNlIDQ2PT09ciYmLTEhPT1zPysrczpzPS0xfXJldHVybiBufXZhciBuPXtyZXNvbHZlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0LG49XCJcIixpPSExLG89YXJndW1lbnRzLmxlbmd0aC0xO28+PS0xJiYhaTtvLS0pe3ZhciBzO28+PTA/cz1hcmd1bWVudHNbb106KHZvaWQgMD09PXQmJih0PXByb2Nlc3MuY3dkKCkpLHM9dCksZShzKSwwIT09cy5sZW5ndGgmJihuPXMrXCIvXCIrbixpPTQ3PT09cy5jaGFyQ29kZUF0KDApKX1yZXR1cm4gbj1yKG4sIWkpLGk/bi5sZW5ndGg+MD9cIi9cIituOlwiL1wiOm4ubGVuZ3RoPjA/bjpcIi5cIn0sbm9ybWFsaXplOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO3ZhciBuPTQ3PT09dC5jaGFyQ29kZUF0KDApLGk9NDc9PT10LmNoYXJDb2RlQXQodC5sZW5ndGgtMSk7cmV0dXJuIDAhPT0odD1yKHQsIW4pKS5sZW5ndGh8fG58fCh0PVwiLlwiKSx0Lmxlbmd0aD4wJiZpJiYodCs9XCIvXCIpLG4/XCIvXCIrdDp0fSxpc0Fic29sdXRlOmZ1bmN0aW9uKHQpe3JldHVybiBlKHQpLHQubGVuZ3RoPjAmJjQ3PT09dC5jaGFyQ29kZUF0KDApfSxqb2luOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciB0LHI9MDtyPGFyZ3VtZW50cy5sZW5ndGg7KytyKXt2YXIgaT1hcmd1bWVudHNbcl07ZShpKSxpLmxlbmd0aD4wJiYodm9pZCAwPT09dD90PWk6dCs9XCIvXCIraSl9cmV0dXJuIHZvaWQgMD09PXQ/XCIuXCI6bi5ub3JtYWxpemUodCl9LHJlbGF0aXZlOmZ1bmN0aW9uKHQscil7aWYoZSh0KSxlKHIpLHQ9PT1yKXJldHVyblwiXCI7aWYoKHQ9bi5yZXNvbHZlKHQpKT09PShyPW4ucmVzb2x2ZShyKSkpcmV0dXJuXCJcIjtmb3IodmFyIGk9MTtpPHQubGVuZ3RoJiY0Nz09PXQuY2hhckNvZGVBdChpKTsrK2kpO2Zvcih2YXIgbz10Lmxlbmd0aCxzPW8taSxoPTE7aDxyLmxlbmd0aCYmNDc9PT1yLmNoYXJDb2RlQXQoaCk7KytoKTtmb3IodmFyIGE9ci5sZW5ndGgtaCxjPXM8YT9zOmEsZj0tMSx1PTA7dTw9YzsrK3Upe2lmKHU9PT1jKXtpZihhPmMpe2lmKDQ3PT09ci5jaGFyQ29kZUF0KGgrdSkpcmV0dXJuIHIuc2xpY2UoaCt1KzEpO2lmKDA9PT11KXJldHVybiByLnNsaWNlKGgrdSl9ZWxzZSBzPmMmJig0Nz09PXQuY2hhckNvZGVBdChpK3UpP2Y9dTowPT09dSYmKGY9MCkpO2JyZWFrfXZhciBsPXQuY2hhckNvZGVBdChpK3UpO2lmKGwhPT1yLmNoYXJDb2RlQXQoaCt1KSlicmVhazs0Nz09PWwmJihmPXUpfXZhciBnPVwiXCI7Zm9yKHU9aStmKzE7dTw9bzsrK3UpdSE9PW8mJjQ3IT09dC5jaGFyQ29kZUF0KHUpfHwoMD09PWcubGVuZ3RoP2crPVwiLi5cIjpnKz1cIi8uLlwiKTtyZXR1cm4gZy5sZW5ndGg+MD9nK3Iuc2xpY2UoaCtmKTooaCs9Ziw0Nz09PXIuY2hhckNvZGVBdChoKSYmKytoLHIuc2xpY2UoaCkpfSxfbWFrZUxvbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHR9LGRpcm5hbWU6ZnVuY3Rpb24odCl7aWYoZSh0KSwwPT09dC5sZW5ndGgpcmV0dXJuXCIuXCI7Zm9yKHZhciByPXQuY2hhckNvZGVBdCgwKSxuPTQ3PT09cixpPS0xLG89ITAscz10Lmxlbmd0aC0xO3M+PTE7LS1zKWlmKDQ3PT09KHI9dC5jaGFyQ29kZUF0KHMpKSl7aWYoIW8pe2k9czticmVha319ZWxzZSBvPSExO3JldHVybi0xPT09aT9uP1wiL1wiOlwiLlwiOm4mJjE9PT1pP1wiLy9cIjp0LnNsaWNlKDAsaSl9LGJhc2VuYW1lOmZ1bmN0aW9uKHQscil7aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJleHRcIiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7ZSh0KTt2YXIgbixpPTAsbz0tMSxzPSEwO2lmKHZvaWQgMCE9PXImJnIubGVuZ3RoPjAmJnIubGVuZ3RoPD10Lmxlbmd0aCl7aWYoci5sZW5ndGg9PT10Lmxlbmd0aCYmcj09PXQpcmV0dXJuXCJcIjt2YXIgaD1yLmxlbmd0aC0xLGE9LTE7Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGM9dC5jaGFyQ29kZUF0KG4pO2lmKDQ3PT09Yyl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1hJiYocz0hMSxhPW4rMSksaD49MCYmKGM9PT1yLmNoYXJDb2RlQXQoaCk/LTE9PS0taCYmKG89bik6KGg9LTEsbz1hKSl9cmV0dXJuIGk9PT1vP289YTotMT09PW8mJihvPXQubGVuZ3RoKSx0LnNsaWNlKGksbyl9Zm9yKG49dC5sZW5ndGgtMTtuPj0wOy0tbilpZig0Nz09PXQuY2hhckNvZGVBdChuKSl7aWYoIXMpe2k9bisxO2JyZWFrfX1lbHNlLTE9PT1vJiYocz0hMSxvPW4rMSk7cmV0dXJuLTE9PT1vP1wiXCI6dC5zbGljZShpLG8pfSxleHRuYW1lOmZ1bmN0aW9uKHQpe2UodCk7Zm9yKHZhciByPS0xLG49MCxpPS0xLG89ITAscz0wLGg9dC5sZW5ndGgtMTtoPj0wOy0taCl7dmFyIGE9dC5jaGFyQ29kZUF0KGgpO2lmKDQ3IT09YSktMT09PWkmJihvPSExLGk9aCsxKSw0Nj09PWE/LTE9PT1yP3I9aDoxIT09cyYmKHM9MSk6LTEhPT1yJiYocz0tMSk7ZWxzZSBpZighbyl7bj1oKzE7YnJlYWt9fXJldHVybi0xPT09cnx8LTE9PT1pfHwwPT09c3x8MT09PXMmJnI9PT1pLTEmJnI9PT1uKzE/XCJcIjp0LnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbih0KXtpZihudWxsPT09dHx8XCJvYmplY3RcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgdCk7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5kaXJ8fGUucm9vdCxuPWUuYmFzZXx8KGUubmFtZXx8XCJcIikrKGUuZXh0fHxcIlwiKTtyZXR1cm4gcj9yPT09ZS5yb290P3IrbjpyK1wiL1wiK246bn0oMCx0KX0scGFyc2U6ZnVuY3Rpb24odCl7ZSh0KTt2YXIgcj17cm9vdDpcIlwiLGRpcjpcIlwiLGJhc2U6XCJcIixleHQ6XCJcIixuYW1lOlwiXCJ9O2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gcjt2YXIgbixpPXQuY2hhckNvZGVBdCgwKSxvPTQ3PT09aTtvPyhyLnJvb3Q9XCIvXCIsbj0xKTpuPTA7Zm9yKHZhciBzPS0xLGg9MCxhPS0xLGM9ITAsZj10Lmxlbmd0aC0xLHU9MDtmPj1uOy0tZilpZig0NyE9PShpPXQuY2hhckNvZGVBdChmKSkpLTE9PT1hJiYoYz0hMSxhPWYrMSksNDY9PT1pPy0xPT09cz9zPWY6MSE9PXUmJih1PTEpOi0xIT09cyYmKHU9LTEpO2Vsc2UgaWYoIWMpe2g9ZisxO2JyZWFrfXJldHVybi0xPT09c3x8LTE9PT1hfHwwPT09dXx8MT09PXUmJnM9PT1hLTEmJnM9PT1oKzE/LTEhPT1hJiYoci5iYXNlPXIubmFtZT0wPT09aCYmbz90LnNsaWNlKDEsYSk6dC5zbGljZShoLGEpKTooMD09PWgmJm8/KHIubmFtZT10LnNsaWNlKDEscyksci5iYXNlPXQuc2xpY2UoMSxhKSk6KHIubmFtZT10LnNsaWNlKGgscyksci5iYXNlPXQuc2xpY2UoaCxhKSksci5leHQ9dC5zbGljZShzLGEpKSxoPjA/ci5kaXI9dC5zbGljZSgwLGgtMSk6byYmKHIuZGlyPVwiL1wiKSxyfSxzZXA6XCIvXCIsZGVsaW1pdGVyOlwiOlwiLHdpbjMyOm51bGwscG9zaXg6bnVsbH07bi5wb3NpeD1uLHQuZXhwb3J0cz1ufX0sZT17fTtmdW5jdGlvbiByKG4pe3ZhciBpPWVbbl07aWYodm9pZCAwIT09aSlyZXR1cm4gaS5leHBvcnRzO3ZhciBvPWVbbl09e2V4cG9ydHM6e319O3JldHVybiB0W25dKG8sby5leHBvcnRzLHIpLG8uZXhwb3J0c31yLmQ9KHQsZSk9Pntmb3IodmFyIG4gaW4gZSlyLm8oZSxuKSYmIXIubyh0LG4pJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDplW25dfSl9LHIubz0odCxlKT0+T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSksci5yPXQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfTt2YXIgbj17fTsoKCk9PntsZXQgdDtpZihyLnIobiksci5kKG4se1VSSTooKT0+ZixVdGlsczooKT0+UH0pLFwib2JqZWN0XCI9PXR5cGVvZiBwcm9jZXNzKXQ9XCJ3aW4zMlwiPT09cHJvY2Vzcy5wbGF0Zm9ybTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBuYXZpZ2F0b3Ipe2xldCBlPW5hdmlnYXRvci51c2VyQWdlbnQ7dD1lLmluZGV4T2YoXCJXaW5kb3dzXCIpPj0wfWNvbnN0IGU9L15cXHdbXFx3XFxkKy4tXSokLyxpPS9eXFwvLyxvPS9eXFwvXFwvLztmdW5jdGlvbiBzKHQscil7aWYoIXQuc2NoZW1lJiZyKXRocm93IG5ldyBFcnJvcihgW1VyaUVycm9yXTogU2NoZW1lIGlzIG1pc3Npbmc6IHtzY2hlbWU6IFwiXCIsIGF1dGhvcml0eTogXCIke3QuYXV0aG9yaXR5fVwiLCBwYXRoOiBcIiR7dC5wYXRofVwiLCBxdWVyeTogXCIke3QucXVlcnl9XCIsIGZyYWdtZW50OiBcIiR7dC5mcmFnbWVudH1cIn1gKTtpZih0LnNjaGVtZSYmIWUudGVzdCh0LnNjaGVtZSkpdGhyb3cgbmV3IEVycm9yKFwiW1VyaUVycm9yXTogU2NoZW1lIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycy5cIik7aWYodC5wYXRoKWlmKHQuYXV0aG9yaXR5KXtpZighaS50ZXN0KHQucGF0aCkpdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKX1lbHNlIGlmKG8udGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyl9Y29uc3QgaD1cIlwiLGE9XCIvXCIsYz0vXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/LztjbGFzcyBme3N0YXRpYyBpc1VyaSh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGZ8fCEhdCYmXCJzdHJpbmdcIj09dHlwZW9mIHQuYXV0aG9yaXR5JiZcInN0cmluZ1wiPT10eXBlb2YgdC5mcmFnbWVudCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucGF0aCYmXCJzdHJpbmdcIj09dHlwZW9mIHQucXVlcnkmJlwic3RyaW5nXCI9PXR5cGVvZiB0LnNjaGVtZSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuZnNQYXRoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndpdGgmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQudG9TdHJpbmd9c2NoZW1lO2F1dGhvcml0eTtwYXRoO3F1ZXJ5O2ZyYWdtZW50O2NvbnN0cnVjdG9yKHQsZSxyLG4saSxvPSExKXtcIm9iamVjdFwiPT10eXBlb2YgdD8odGhpcy5zY2hlbWU9dC5zY2hlbWV8fGgsdGhpcy5hdXRob3JpdHk9dC5hdXRob3JpdHl8fGgsdGhpcy5wYXRoPXQucGF0aHx8aCx0aGlzLnF1ZXJ5PXQucXVlcnl8fGgsdGhpcy5mcmFnbWVudD10LmZyYWdtZW50fHxoKToodGhpcy5zY2hlbWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdHx8ZT90OlwiZmlsZVwifSh0LG8pLHRoaXMuYXV0aG9yaXR5PWV8fGgsdGhpcy5wYXRoPWZ1bmN0aW9uKHQsZSl7c3dpdGNoKHQpe2Nhc2VcImh0dHBzXCI6Y2FzZVwiaHR0cFwiOmNhc2VcImZpbGVcIjplP2VbMF0hPT1hJiYoZT1hK2UpOmU9YX1yZXR1cm4gZX0odGhpcy5zY2hlbWUscnx8aCksdGhpcy5xdWVyeT1ufHxoLHRoaXMuZnJhZ21lbnQ9aXx8aCxzKHRoaXMsbykpfWdldCBmc1BhdGgoKXtyZXR1cm4gbSh0aGlzLCExKX13aXRoKHQpe2lmKCF0KXJldHVybiB0aGlzO2xldHtzY2hlbWU6ZSxhdXRob3JpdHk6cixwYXRoOm4scXVlcnk6aSxmcmFnbWVudDpvfT10O3JldHVybiB2b2lkIDA9PT1lP2U9dGhpcy5zY2hlbWU6bnVsbD09PWUmJihlPWgpLHZvaWQgMD09PXI/cj10aGlzLmF1dGhvcml0eTpudWxsPT09ciYmKHI9aCksdm9pZCAwPT09bj9uPXRoaXMucGF0aDpudWxsPT09biYmKG49aCksdm9pZCAwPT09aT9pPXRoaXMucXVlcnk6bnVsbD09PWkmJihpPWgpLHZvaWQgMD09PW8/bz10aGlzLmZyYWdtZW50Om51bGw9PT1vJiYobz1oKSxlPT09dGhpcy5zY2hlbWUmJnI9PT10aGlzLmF1dGhvcml0eSYmbj09PXRoaXMucGF0aCYmaT09PXRoaXMucXVlcnkmJm89PT10aGlzLmZyYWdtZW50P3RoaXM6bmV3IGwoZSxyLG4saSxvKX1zdGF0aWMgcGFyc2UodCxlPSExKXtjb25zdCByPWMuZXhlYyh0KTtyZXR1cm4gcj9uZXcgbChyWzJdfHxoLEMocls0XXx8aCksQyhyWzVdfHxoKSxDKHJbN118fGgpLEMocls5XXx8aCksZSk6bmV3IGwoaCxoLGgsaCxoKX1zdGF0aWMgZmlsZShlKXtsZXQgcj1oO2lmKHQmJihlPWUucmVwbGFjZSgvXFxcXC9nLGEpKSxlWzBdPT09YSYmZVsxXT09PWEpe2NvbnN0IHQ9ZS5pbmRleE9mKGEsMik7LTE9PT10PyhyPWUuc3Vic3RyaW5nKDIpLGU9YSk6KHI9ZS5zdWJzdHJpbmcoMix0KSxlPWUuc3Vic3RyaW5nKHQpfHxhKX1yZXR1cm4gbmV3IGwoXCJmaWxlXCIscixlLGgsaCl9c3RhdGljIGZyb20odCl7Y29uc3QgZT1uZXcgbCh0LnNjaGVtZSx0LmF1dGhvcml0eSx0LnBhdGgsdC5xdWVyeSx0LmZyYWdtZW50KTtyZXR1cm4gcyhlLCEwKSxlfXRvU3RyaW5nKHQ9ITEpe3JldHVybiB5KHRoaXMsdCl9dG9KU09OKCl7cmV0dXJuIHRoaXN9c3RhdGljIHJldml2ZSh0KXtpZih0KXtpZih0IGluc3RhbmNlb2YgZilyZXR1cm4gdDt7Y29uc3QgZT1uZXcgbCh0KTtyZXR1cm4gZS5fZm9ybWF0dGVkPXQuZXh0ZXJuYWwsZS5fZnNQYXRoPXQuX3NlcD09PXU/dC5mc1BhdGg6bnVsbCxlfX1yZXR1cm4gdH19Y29uc3QgdT10PzE6dm9pZCAwO2NsYXNzIGwgZXh0ZW5kcyBme19mb3JtYXR0ZWQ9bnVsbDtfZnNQYXRoPW51bGw7Z2V0IGZzUGF0aCgpe3JldHVybiB0aGlzLl9mc1BhdGh8fCh0aGlzLl9mc1BhdGg9bSh0aGlzLCExKSksdGhpcy5fZnNQYXRofXRvU3RyaW5nKHQ9ITEpe3JldHVybiB0P3kodGhpcywhMCk6KHRoaXMuX2Zvcm1hdHRlZHx8KHRoaXMuX2Zvcm1hdHRlZD15KHRoaXMsITEpKSx0aGlzLl9mb3JtYXR0ZWQpfXRvSlNPTigpe2NvbnN0IHQ9eyRtaWQ6MX07cmV0dXJuIHRoaXMuX2ZzUGF0aCYmKHQuZnNQYXRoPXRoaXMuX2ZzUGF0aCx0Ll9zZXA9dSksdGhpcy5fZm9ybWF0dGVkJiYodC5leHRlcm5hbD10aGlzLl9mb3JtYXR0ZWQpLHRoaXMucGF0aCYmKHQucGF0aD10aGlzLnBhdGgpLHRoaXMuc2NoZW1lJiYodC5zY2hlbWU9dGhpcy5zY2hlbWUpLHRoaXMuYXV0aG9yaXR5JiYodC5hdXRob3JpdHk9dGhpcy5hdXRob3JpdHkpLHRoaXMucXVlcnkmJih0LnF1ZXJ5PXRoaXMucXVlcnkpLHRoaXMuZnJhZ21lbnQmJih0LmZyYWdtZW50PXRoaXMuZnJhZ21lbnQpLHR9fWNvbnN0IGc9ezU4OlwiJTNBXCIsNDc6XCIlMkZcIiw2MzpcIiUzRlwiLDM1OlwiJTIzXCIsOTE6XCIlNUJcIiw5MzpcIiU1RFwiLDY0OlwiJTQwXCIsMzM6XCIlMjFcIiwzNjpcIiUyNFwiLDM4OlwiJTI2XCIsMzk6XCIlMjdcIiw0MDpcIiUyOFwiLDQxOlwiJTI5XCIsNDI6XCIlMkFcIiw0MzpcIiUyQlwiLDQ0OlwiJTJDXCIsNTk6XCIlM0JcIiw2MTpcIiUzRFwiLDMyOlwiJTIwXCJ9O2Z1bmN0aW9uIGQodCxlLHIpe2xldCBuLGk9LTE7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDtvKyspe2NvbnN0IHM9dC5jaGFyQ29kZUF0KG8pO2lmKHM+PTk3JiZzPD0xMjJ8fHM+PTY1JiZzPD05MHx8cz49NDgmJnM8PTU3fHw0NT09PXN8fDQ2PT09c3x8OTU9PT1zfHwxMjY9PT1zfHxlJiY0Nz09PXN8fHImJjkxPT09c3x8ciYmOTM9PT1zfHxyJiY1OD09PXMpLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLHZvaWQgMCE9PW4mJihuKz10LmNoYXJBdChvKSk7ZWxzZXt2b2lkIDA9PT1uJiYobj10LnN1YnN0cigwLG8pKTtjb25zdCBlPWdbc107dm9pZCAwIT09ZT8oLTEhPT1pJiYobis9ZW5jb2RlVVJJQ29tcG9uZW50KHQuc3Vic3RyaW5nKGksbykpLGk9LTEpLG4rPWUpOi0xPT09aSYmKGk9byl9fXJldHVybi0xIT09aSYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhpKSkpLHZvaWQgMCE9PW4/bjp0fWZ1bmN0aW9uIHAodCl7bGV0IGU7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe2NvbnN0IG49dC5jaGFyQ29kZUF0KHIpOzM1PT09bnx8NjM9PT1uPyh2b2lkIDA9PT1lJiYoZT10LnN1YnN0cigwLHIpKSxlKz1nW25dKTp2b2lkIDAhPT1lJiYoZSs9dFtyXSl9cmV0dXJuIHZvaWQgMCE9PWU/ZTp0fWZ1bmN0aW9uIG0oZSxyKXtsZXQgbjtyZXR1cm4gbj1lLmF1dGhvcml0eSYmZS5wYXRoLmxlbmd0aD4xJiZcImZpbGVcIj09PWUuc2NoZW1lP2AvLyR7ZS5hdXRob3JpdHl9JHtlLnBhdGh9YDo0Nz09PWUucGF0aC5jaGFyQ29kZUF0KDApJiYoZS5wYXRoLmNoYXJDb2RlQXQoMSk+PTY1JiZlLnBhdGguY2hhckNvZGVBdCgxKTw9OTB8fGUucGF0aC5jaGFyQ29kZUF0KDEpPj05NyYmZS5wYXRoLmNoYXJDb2RlQXQoMSk8PTEyMikmJjU4PT09ZS5wYXRoLmNoYXJDb2RlQXQoMik/cj9lLnBhdGguc3Vic3RyKDEpOmUucGF0aFsxXS50b0xvd2VyQ2FzZSgpK2UucGF0aC5zdWJzdHIoMik6ZS5wYXRoLHQmJihuPW4ucmVwbGFjZSgvXFwvL2csXCJcXFxcXCIpKSxufWZ1bmN0aW9uIHkodCxlKXtjb25zdCByPWU/cDpkO2xldCBuPVwiXCIse3NjaGVtZTppLGF1dGhvcml0eTpvLHBhdGg6cyxxdWVyeTpoLGZyYWdtZW50OmN9PXQ7aWYoaSYmKG4rPWksbis9XCI6XCIpLChvfHxcImZpbGVcIj09PWkpJiYobis9YSxuKz1hKSxvKXtsZXQgdD1vLmluZGV4T2YoXCJAXCIpO2lmKC0xIT09dCl7Y29uc3QgZT1vLnN1YnN0cigwLHQpO289by5zdWJzdHIodCsxKSx0PWUubGFzdEluZGV4T2YoXCI6XCIpLC0xPT09dD9uKz1yKGUsITEsITEpOihuKz1yKGUuc3Vic3RyKDAsdCksITEsITEpLG4rPVwiOlwiLG4rPXIoZS5zdWJzdHIodCsxKSwhMSwhMCkpLG4rPVwiQFwifW89by50b0xvd2VyQ2FzZSgpLHQ9by5sYXN0SW5kZXhPZihcIjpcIiksLTE9PT10P24rPXIobywhMSwhMCk6KG4rPXIoby5zdWJzdHIoMCx0KSwhMSwhMCksbis9by5zdWJzdHIodCkpfWlmKHMpe2lmKHMubGVuZ3RoPj0zJiY0Nz09PXMuY2hhckNvZGVBdCgwKSYmNTg9PT1zLmNoYXJDb2RlQXQoMikpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDEpO3Q+PTY1JiZ0PD05MCYmKHM9YC8ke1N0cmluZy5mcm9tQ2hhckNvZGUodCszMil9OiR7cy5zdWJzdHIoMyl9YCl9ZWxzZSBpZihzLmxlbmd0aD49MiYmNTg9PT1zLmNoYXJDb2RlQXQoMSkpe2NvbnN0IHQ9cy5jaGFyQ29kZUF0KDApO3Q+PTY1JiZ0PD05MCYmKHM9YCR7U3RyaW5nLmZyb21DaGFyQ29kZSh0KzMyKX06JHtzLnN1YnN0cigyKX1gKX1uKz1yKHMsITAsITEpfXJldHVybiBoJiYobis9XCI/XCIsbis9cihoLCExLCExKSksYyYmKG4rPVwiI1wiLG4rPWU/YzpkKGMsITEsITEpKSxufWZ1bmN0aW9uIHYodCl7dHJ5e3JldHVybiBkZWNvZGVVUklDb21wb25lbnQodCl9Y2F0Y2h7cmV0dXJuIHQubGVuZ3RoPjM/dC5zdWJzdHIoMCwzKSt2KHQuc3Vic3RyKDMpKTp0fX1jb25zdCBiPS8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO2Z1bmN0aW9uIEModCl7cmV0dXJuIHQubWF0Y2goYik/dC5yZXBsYWNlKGIsKHQ9PnYodCkpKTp0fXZhciBBPXIoNDcwKTtjb25zdCB3PUEucG9zaXh8fEEseD1cIi9cIjt2YXIgUDshZnVuY3Rpb24odCl7dC5qb2luUGF0aD1mdW5jdGlvbih0LC4uLmUpe3JldHVybiB0LndpdGgoe3BhdGg6dy5qb2luKHQucGF0aCwuLi5lKX0pfSx0LnJlc29sdmVQYXRoPWZ1bmN0aW9uKHQsLi4uZSl7bGV0IHI9dC5wYXRoLG49ITE7clswXSE9PXgmJihyPXgrcixuPSEwKTtsZXQgaT13LnJlc29sdmUociwuLi5lKTtyZXR1cm4gbiYmaVswXT09PXgmJiF0LmF1dGhvcml0eSYmKGk9aS5zdWJzdHJpbmcoMSkpLHQud2l0aCh7cGF0aDppfSl9LHQuZGlybmFtZT1mdW5jdGlvbih0KXtpZigwPT09dC5wYXRoLmxlbmd0aHx8dC5wYXRoPT09eClyZXR1cm4gdDtsZXQgZT13LmRpcm5hbWUodC5wYXRoKTtyZXR1cm4gMT09PWUubGVuZ3RoJiY0Nj09PWUuY2hhckNvZGVBdCgwKSYmKGU9XCJcIiksdC53aXRoKHtwYXRoOmV9KX0sdC5iYXNlbmFtZT1mdW5jdGlvbih0KXtyZXR1cm4gdy5iYXNlbmFtZSh0LnBhdGgpfSx0LmV4dG5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHcuZXh0bmFtZSh0LnBhdGgpfX0oUHx8KFA9e30pKX0pKCksTElCPW59KSgpO2V4cG9ydCBjb25zdHtVUkksVXRpbHN9PUxJQjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBVUkksIFV0aWxzIH0gZnJvbSAndnNjb2RlLXVyaSc7XG5leHBvcnQgeyBVUkkgfTtcbmV4cG9ydCB2YXIgVXJpVXRpbHM7XG4oZnVuY3Rpb24gKFVyaVV0aWxzKSB7XG4gICAgVXJpVXRpbHMuYmFzZW5hbWUgPSBVdGlscy5iYXNlbmFtZTtcbiAgICBVcmlVdGlscy5kaXJuYW1lID0gVXRpbHMuZGlybmFtZTtcbiAgICBVcmlVdGlscy5leHRuYW1lID0gVXRpbHMuZXh0bmFtZTtcbiAgICBVcmlVdGlscy5qb2luUGF0aCA9IFV0aWxzLmpvaW5QYXRoO1xuICAgIFVyaVV0aWxzLnJlc29sdmVQYXRoID0gVXRpbHMucmVzb2x2ZVBhdGg7XG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEudG9TdHJpbmcoKSkgPT09IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIFVyaVV0aWxzLmVxdWFscyA9IGVxdWFscztcbiAgICBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgICAgICBjb25zdCBmcm9tUGF0aCA9IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGZyb20gOiBmcm9tLnBhdGg7XG4gICAgICAgIGNvbnN0IHRvUGF0aCA9IHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IHRvLnBhdGg7XG4gICAgICAgIGNvbnN0IGZyb21QYXJ0cyA9IGZyb21QYXRoLnNwbGl0KCcvJykuZmlsdGVyKGUgPT4gZS5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3QgdG9QYXJ0cyA9IHRvUGF0aC5zcGxpdCgnLycpLmZpbHRlcihlID0+IGUubGVuZ3RoID4gMCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrUGFydCA9ICcuLi8nLnJlcGVhdChmcm9tUGFydHMubGVuZ3RoIC0gaSk7XG4gICAgICAgIGNvbnN0IHRvUGFydCA9IHRvUGFydHMuc2xpY2UoaSkuam9pbignLycpO1xuICAgICAgICByZXR1cm4gYmFja1BhcnQgKyB0b1BhcnQ7XG4gICAgfVxuICAgIFVyaVV0aWxzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG59KShVcmlVdGlscyB8fCAoVXJpVXRpbHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXV0aWxzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKlxuICogUmUtZXhwb3J0ICdUZXh0RG9jdW1lbnQnIGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQnIGZvciBjb252ZW5pZW5jZSxcbiAqICBpbmNsdWRpbmcgYm90aCB0eXBlIF9hbmRfIHN5bWJvbCAobmFtZXNwYWNlKSwgYXMgd2UgaGVyZSBhbmQgdGhlcmUgYWxzbyByZWZlciB0byB0aGUgc3ltYm9sLFxuICogIHRoZSBvdmVyaGVhZCBpcyB2ZXJ5IHNtYWxsLCBqdXN0IGEgZmV3IGtpbG9ieXRlcy5cbiAqIEV2ZXJ5dGhpbmcgZWxzZSBvZiB0aGF0IHBhY2thZ2UgKGF0IHRoZSB0aW1lIGNvbnRyaWJ1dGluZykgaXMgYWxzbyBkZWZpbmVkXG4gKiAgaW4gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci1wcm90b2NvbCcgb3IgJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcycuXG4gKi9cbmV4cG9ydCB7IFRleHREb2N1bWVudCB9IGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10ZXh0ZG9jdW1lbnQnO1xuaW1wb3J0IHsgVGV4dERvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudHMuanMnO1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG4vKipcbiAqIEEgZG9jdW1lbnQgaXMgc3ViamVjdCB0byBzZXZlcmFsIHBoYXNlcyB0aGF0IGFyZSBydW4gaW4gcHJlZGVmaW5lZCBvcmRlci4gQW55IHN0YXRlIHZhbHVlIGltcGxpZXMgdGhhdFxuICogc21hbGxlciBzdGF0ZSB2YWx1ZXMgYXJlIGZpbmlzaGVkIGFzIHdlbGwuXG4gKi9cbmV4cG9ydCB2YXIgRG9jdW1lbnRTdGF0ZTtcbihmdW5jdGlvbiAoRG9jdW1lbnRTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGNvbnRlbnQgaGFzIGNoYW5nZWQgYW5kIG5lZWRzIHRvIGJlIHBhcnNlZCBhZ2Fpbi4gVGhlIEFTVCBoZWxkIGJ5IHRoaXMgb3V0ZGF0ZWRcbiAgICAgKiBkb2N1bWVudCBpbnN0YW5jZSBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiQ2hhbmdlZFwiXSA9IDBdID0gXCJDaGFuZ2VkXCI7XG4gICAgLyoqXG4gICAgICogQW4gQVNUIGhhcyBiZWVuIGNyZWF0ZWQgZnJvbSB0aGUgdGV4dCBjb250ZW50LiBUaGUgZG9jdW1lbnQgc3RydWN0dXJlIGNhbiBiZSB0cmF2ZXJzZWQsXG4gICAgICogYnV0IGNyb3NzLXJlZmVyZW5jZXMgY2Fubm90IGJlIHJlc29sdmVkIHlldC4gSWYgbmVjZXNzYXJ5LCB0aGUgc3RydWN0dXJlIGNhbiBiZSBtYW5pcHVsYXRlZFxuICAgICAqIGF0IHRoaXMgc3RhZ2UgYXMgYSBwcmVwcm9jZXNzaW5nIHN0ZXAuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiUGFyc2VkXCJdID0gMV0gPSBcIlBhcnNlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgSW5kZXhNYW5hZ2VyYCBzZXJ2aWNlIGhhcyBwcm9jZXNzZWQgQVNUIG5vZGVzIG9mIHRoaXMgZG9jdW1lbnQuIFRoaXMgbWVhbnMgdGhlXG4gICAgICogZXhwb3J0ZWQgc3ltYm9scyBhcmUgYXZhaWxhYmxlIGluIHRoZSBnbG9iYWwgc2NvcGUgYW5kIGNhbiBiZSByZXNvbHZlZCBmcm9tIG90aGVyIGRvY3VtZW50cy5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJJbmRleGVkQ29udGVudFwiXSA9IDJdID0gXCJJbmRleGVkQ29udGVudFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgU2NvcGVDb21wdXRhdGlvbmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIHRoaXMgZG9jdW1lbnQuIFRoaXMgbWVhbnMgdGhlIGxvY2FsIHN5bWJvbHNcbiAgICAgKiBhcmUgc3RvcmVkIGluIGEgTXVsdGlNYXAgc28gdGhleSBjYW4gYmUgbG9va2VkIHVwIGJ5IHRoZSBgU2NvcGVQcm92aWRlcmAgc2VydmljZS5cbiAgICAgKiBPbmNlIGEgZG9jdW1lbnQgaGFzIHJlYWNoZWQgdGhpcyBzdGF0ZSwgeW91IG1heSBmb2xsb3cgZXZlcnkgcmVmZXJlbmNlIC0gaXQgd2lsbCBsYXppbHlcbiAgICAgKiByZXNvbHZlIGl0cyBgcmVmYCBwcm9wZXJ0eSBhbmQgeWllbGQgZWl0aGVyIHRoZSB0YXJnZXQgQVNUIG5vZGUgb3IgYHVuZGVmaW5lZGAgaW4gY2FzZVxuICAgICAqIHRoZSB0YXJnZXQgaXMgbm90IGluIHNjb3BlLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkNvbXB1dGVkU2NvcGVzXCJdID0gM10gPSBcIkNvbXB1dGVkU2NvcGVzXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBMaW5rZXJgIHNlcnZpY2UgaGFzIHByb2Nlc3NlZCB0aGlzIGRvY3VtZW50LiBBbGwgb3V0Z29pbmcgcmVmZXJlbmNlcyBoYXZlIGJlZW5cbiAgICAgKiByZXNvbHZlZCBvciBtYXJrZWQgYXMgZXJyb25lb3VzLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkxpbmtlZFwiXSA9IDRdID0gXCJMaW5rZWRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYEluZGV4TWFuYWdlcmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIEFTVCBub2RlIHJlZmVyZW5jZXMgb2YgdGhpcyBkb2N1bWVudC4gVGhpcyBpc1xuICAgICAqIG5lY2Vzc2FyeSB0byBkZXRlcm1pbmUgd2hpY2ggZG9jdW1lbnRzIGFyZSBhZmZlY3RlZCBieSBhIGNoYW5nZSBpbiBvbmUgb2YgdGhlIHdvcmtzcGFjZVxuICAgICAqIGRvY3VtZW50cy5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJJbmRleGVkUmVmZXJlbmNlc1wiXSA9IDVdID0gXCJJbmRleGVkUmVmZXJlbmNlc1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgRG9jdW1lbnRWYWxpZGF0b3JgIHNlcnZpY2UgaGFzIHByb2Nlc3NlZCB0aGlzIGRvY3VtZW50LiBUaGUgbGFuZ3VhZ2Ugc2VydmVyIGxpc3RlbnNcbiAgICAgKiB0byB0aGUgcmVzdWx0cyBvZiB0aGlzIHBoYXNlIGFuZCBzZW5kcyBkaWFnbm9zdGljcyB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIlZhbGlkYXRlZFwiXSA9IDZdID0gXCJWYWxpZGF0ZWRcIjtcbn0pKERvY3VtZW50U3RhdGUgfHwgKERvY3VtZW50U3RhdGUgPSB7fSkpO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMYW5naXVtRG9jdW1lbnRGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICAgICAgdGhpcy50ZXh0RG9jdW1lbnRzID0gc2VydmljZXMud29ya3NwYWNlLlRleHREb2N1bWVudHM7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbVByb3ZpZGVyID0gc2VydmljZXMud29ya3NwYWNlLkZpbGVTeXN0ZW1Qcm92aWRlcjtcbiAgICB9XG4gICAgYXN5bmMgZnJvbVVyaSh1cmksIGNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIucmVhZEZpbGUodXJpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQXN5bmModXJpLCBjb250ZW50LCBjYW5jZWxsYXRpb25Ub2tlbik7XG4gICAgfVxuICAgIGZyb21UZXh0RG9jdW1lbnQodGV4dERvY3VtZW50LCB1cmksIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHVyaSA9IHVyaSAhPT0gbnVsbCAmJiB1cmkgIT09IHZvaWQgMCA/IHVyaSA6IFVSSS5wYXJzZSh0ZXh0RG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIHRleHREb2N1bWVudCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVyaSwgdGV4dERvY3VtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmcm9tU3RyaW5nKHRleHQsIHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgaWYgKGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIHRleHQsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh1cmksIHRleHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21Nb2RlbChtb2RlbCwgdXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh1cmksIHsgJG1vZGVsOiBtb2RlbCB9KTtcbiAgICB9XG4gICAgY3JlYXRlKHVyaSwgY29udGVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2UodXJpLCBjb250ZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCB1bmRlZmluZWQsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCckbW9kZWwnIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0geyB2YWx1ZTogY29udGVudC4kbW9kZWwsIHBhcnNlckVycm9yczogW10sIGxleGVyRXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlKHVyaSwgY29udGVudC5nZXRUZXh0KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmksIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUFzeW5jKHVyaSwgY29udGVudCwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCB0aGlzLnBhcnNlQXN5bmModXJpLCBjb250ZW50LCBjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdW5kZWZpbmVkLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKHVyaSwgY29udGVudC5nZXRUZXh0KCksIGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMYW5naXVtRG9jdW1lbnQgZnJvbSBhIGdpdmVuIHBhcnNlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEEgVGV4dERvY3VtZW50IGlzIGNyZWF0ZWQgb24gZGVtYW5kIGlmIGl0IGlzIG5vdCBwcm92aWRlZCBhcyBhcmd1bWVudCBoZXJlLiBVc3VhbGx5IHRoaXNcbiAgICAgKiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBtYWluIHB1cnBvc2Ugb2YgdGhlIFRleHREb2N1bWVudCBpcyB0byBjb252ZXJ0IGJldHdlZW5cbiAgICAgKiB0ZXh0IHJhbmdlcyBhbmQgb2Zmc2V0cywgd2hpY2ggaXMgZG9uZSBzb2xlbHkgaW4gTFNQIHJlcXVlc3QgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBpbnRyb2R1Y3Rpb24gb2Yge0BsaW5rIHVwZGF0ZX0gYmVsb3cgdGhpcyBtZXRob2QgaXMgc3VwcG9zZWQgdG8gYmUgbWFpbmx5IGNhbGxlZFxuICAgICAqIGR1cmluZyB3b3Jrc3BhY2UgaW5pdGlhbGl6YXRpb24gYW5kIG9uIGFkZGl0aW9uL3JlY29nbml0aW9uIG9mIG5ldyBmaWxlcywgd2hpbGUgY2hhbmdlcyBpblxuICAgICAqIGV4aXN0aW5nIGRvY3VtZW50cyBhcmUgcHJvY2Vzc2VkIHZpYSB7QGxpbmsgdXBkYXRlfS5cbiAgICAgKi9cbiAgICBjcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdGV4dERvY3VtZW50LCB0ZXh0KSB7XG4gICAgICAgIGxldCBkb2N1bWVudDtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRHZXR0ZXIgPSB0aGlzLmNyZWF0ZVRleHREb2N1bWVudEdldHRlcih1cmksIHRleHQpO1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBnZXQgdGV4dERvY3VtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dERvY3VtZW50R2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZS4kZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUoZG9jdW1lbnQsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIFRoZSBDU1QgZnVsbCB0ZXh0IHByb3BlcnR5IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRoZSBBU1QuXG4gICAgICAgIGNvbnN0IG9sZFRleHQgPSAoX2EgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3QuZnVsbFRleHQ7XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudCA9IChfYiA9IHRoaXMudGV4dERvY3VtZW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQgPyB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpIDogYXdhaXQgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIucmVhZEZpbGUoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAndGV4dERvY3VtZW50Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50R2V0dGVyID0gdGhpcy5jcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIoZG9jdW1lbnQudXJpLCB0ZXh0KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ3RleHREb2N1bWVudCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IHRleHREb2N1bWVudEdldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBkb2N1bWVudHMgY2FuIGJlIHByZXR0eSBsYXJnZSwgc28gcGFyc2luZyB0aGVtIGFnYWluIGNhbiBiZSBxdWl0ZSBleHBlbnNpdmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugb25seSBwYXJzZSBpZiB0aGUgdGV4dCBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKGRvY3VtZW50LnVyaSwgdGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUuJGRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSBEb2N1bWVudFN0YXRlLlBhcnNlZDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBwYXJzZSh1cmksIHRleHQpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpO1xuICAgICAgICByZXR1cm4gc2VydmljZXMucGFyc2VyLkxhbmdpdW1QYXJzZXIucGFyc2UodGV4dCk7XG4gICAgfVxuICAgIHBhcnNlQXN5bmModXJpLCB0ZXh0LCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKHVyaSk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5wYXJzZXIuQXN5bmNQYXJzZXIucGFyc2UodGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIodXJpLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VSZWdpc3RyeSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICBsZXQgdGV4dERvYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RG9jICE9PSBudWxsICYmIHRleHREb2MgIT09IHZvaWQgMCA/IHRleHREb2MgOiAodGV4dERvYyA9IFRleHREb2N1bWVudC5jcmVhdGUodXJpLnRvU3RyaW5nKCksIHNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpLkxhbmd1YWdlTWV0YURhdGEubGFuZ3VhZ2VJZCwgMCwgdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdExhbmdpdW1Eb2N1bWVudHMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeSA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRGYWN0b3J5O1xuICAgIH1cbiAgICBnZXQgYWxsKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtKHRoaXMuZG9jdW1lbnRNYXAudmFsdWVzKCkpO1xuICAgIH1cbiAgICBhZGREb2N1bWVudChkb2N1bWVudCkge1xuICAgICAgICBjb25zdCB1cmlTdHJpbmcgPSBkb2N1bWVudC51cmkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuZG9jdW1lbnRNYXAuaGFzKHVyaVN0cmluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBkb2N1bWVudCB3aXRoIHRoZSBVUkkgJyR7dXJpU3RyaW5nfScgaXMgYWxyZWFkeSBwcmVzZW50LmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jdW1lbnRNYXAuc2V0KHVyaVN0cmluZywgZG9jdW1lbnQpO1xuICAgIH1cbiAgICBnZXREb2N1bWVudCh1cmkpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50TWFwLmdldCh1cmlTdHJpbmcpO1xuICAgIH1cbiAgICBhc3luYyBnZXRPckNyZWF0ZURvY3VtZW50KHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgbGV0IGRvY3VtZW50ID0gdGhpcy5nZXREb2N1bWVudCh1cmkpO1xuICAgICAgICBpZiAoZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudCA9IGF3YWl0IHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeS5mcm9tVXJpKHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICB0aGlzLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBjcmVhdGVEb2N1bWVudCh1cmksIHRleHQsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGlmIChjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeS5mcm9tU3RyaW5nKHRleHQsIHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4pLnRoZW4oZG9jdW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbVN0cmluZyh0ZXh0LCB1cmkpO1xuICAgICAgICAgICAgdGhpcy5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRG9jdW1lbnQodXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50TWFwLmhhcyh1cmkudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGludmFsaWRhdGVEb2N1bWVudCh1cmkpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxhbmdpdW1Eb2MgPSB0aGlzLmRvY3VtZW50TWFwLmdldCh1cmlTdHJpbmcpO1xuICAgICAgICBpZiAobGFuZ2l1bURvYykge1xuICAgICAgICAgICAgbGFuZ2l1bURvYy5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgIGxhbmdpdW1Eb2MucHJlY29tcHV0ZWRTY29wZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYW5naXVtRG9jLnJlZmVyZW5jZXMgPSBbXTtcbiAgICAgICAgICAgIGxhbmdpdW1Eb2MuZGlhZ25vc3RpY3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhbmdpdW1Eb2M7XG4gICAgfVxuICAgIGRlbGV0ZURvY3VtZW50KHVyaSkge1xuICAgICAgICBjb25zdCB1cmlTdHJpbmcgPSB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGFuZ2l1bURvYyA9IHRoaXMuZG9jdW1lbnRNYXAuZ2V0KHVyaVN0cmluZyk7XG4gICAgICAgIGlmIChsYW5naXVtRG9jKSB7XG4gICAgICAgICAgICBsYW5naXVtRG9jLnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5DaGFuZ2VkO1xuICAgICAgICAgICAgdGhpcy5kb2N1bWVudE1hcC5kZWxldGUodXJpU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFuZ2l1bURvYztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudHMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgaXNBc3ROb2RlLCBpc0FzdE5vZGVEZXNjcmlwdGlvbiwgaXNMaW5raW5nRXJyb3IgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudCwgc3RyZWFtQXN0LCBzdHJlYW1SZWZlcmVuY2VzIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IGludGVycnVwdEFuZENoZWNrIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudFN0YXRlIH0gZnJvbSAnLi4vd29ya3NwYWNlL2RvY3VtZW50cy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdExpbmtlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uID0gc2VydmljZXMuc2hhcmVkLkFzdFJlZmxlY3Rpb247XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9ICgpID0+IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50cztcbiAgICAgICAgdGhpcy5zY29wZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5TY29wZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmFzdE5vZGVMb2NhdG9yID0gc2VydmljZXMud29ya3NwYWNlLkFzdE5vZGVMb2NhdG9yO1xuICAgIH1cbiAgICBhc3luYyBsaW5rKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHN0cmVhbUFzdChkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHN0cmVhbVJlZmVyZW5jZXMobm9kZSkuZm9yRWFjaChyZWYgPT4gdGhpcy5kb0xpbmsocmVmLCBkb2N1bWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvTGluayhyZWZJbmZvLCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCByZWYgPSByZWZJbmZvLnJlZmVyZW5jZTtcbiAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBtYXkgYWxyZWFkeSBoYXZlIGJlZW4gcmVzb2x2ZWQgbGF6aWx5IGJ5IGFjY2Vzc2luZyBpdHMgYHJlZmAgcHJvcGVydHkuXG4gICAgICAgIGlmIChyZWYuX3JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5nZXRDYW5kaWRhdGUocmVmSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGlua2luZ0Vycm9yKGRlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYuX3JlZiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLl9ub2RlRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGFuZ2l1bURvY3VtZW50cygpLmhhc0RvY3VtZW50KGRlc2NyaXB0aW9uLmRvY3VtZW50VXJpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRhcmdldCBkb2N1bWVudCBpcyBhbHJlYWR5IGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua2VkTm9kZSA9IHRoaXMubG9hZEFzdE5vZGUoZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmLl9yZWYgPSBsaW5rZWROb2RlICE9PSBudWxsICYmIGxpbmtlZE5vZGUgIT09IHZvaWQgMCA/IGxpbmtlZE5vZGUgOiB0aGlzLmNyZWF0ZUxpbmtpbmdFcnJvcihyZWZJbmZvLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVmLl9yZWYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZkluZm8pLCB7IG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXNvbHZpbmcgcmVmZXJlbmNlIHRvICcke3JlZi4kcmVmVGV4dH0nOiAke2Vycn1gIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCdzIGFycmF5IG9mIHJlZmVyZW5jZXNcbiAgICAgICAgZG9jdW1lbnQucmVmZXJlbmNlcy5wdXNoKHJlZik7XG4gICAgfVxuICAgIHVubGluayhkb2N1bWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBkb2N1bWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVmLl9yZWY7XG4gICAgICAgICAgICBkZWxldGUgcmVmLl9ub2RlRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVmZXJlbmNlcyA9IFtdO1xuICAgIH1cbiAgICBnZXRDYW5kaWRhdGUocmVmSW5mbykge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVQcm92aWRlci5nZXRTY29wZShyZWZJbmZvKTtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBzY29wZS5nZXRFbGVtZW50KHJlZkluZm8ucmVmZXJlbmNlLiRyZWZUZXh0KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uICE9PSB2b2lkIDAgPyBkZXNjcmlwdGlvbiA6IHRoaXMuY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8pO1xuICAgIH1cbiAgICBidWlsZFJlZmVyZW5jZShub2RlLCBwcm9wZXJ0eSwgcmVmTm9kZSwgcmVmVGV4dCkge1xuICAgICAgICAvLyBTZWUgYmVoYXZpb3IgZGVzY3JpcHRpb24gaW4gZG9jIG9mIExpbmtlciwgdXBkYXRlIHRoYXQgb24gY2hhbmdlcyBpbiBoZXJlLlxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgY29uc3QgbGlua2VyID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0ge1xuICAgICAgICAgICAgJHJlZk5vZGU6IHJlZk5vZGUsXG4gICAgICAgICAgICAkcmVmVGV4dDogcmVmVGV4dCxcbiAgICAgICAgICAgIGdldCByZWYoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodGhpcy5fcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3N0IGZyZXF1ZW50IGNhc2U6IHRoZSB0YXJnZXQgaXMgYWxyZWFkeSByZXNvbHZlZC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3ROb2RlRGVzY3JpcHRpb24odGhpcy5fbm9kZURlc2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGNhbmRpZGF0ZSBoYXMgYmVlbiBmb3VuZCBiZWZvcmUsIGJ1dCBpdCBpcyBub3QgbG9hZGVkIHlldC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGlua2VkTm9kZSA9IGxpbmtlci5sb2FkQXN0Tm9kZSh0aGlzLl9ub2RlRGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZWYgPSBsaW5rZWROb2RlICE9PSBudWxsICYmIGxpbmtlZE5vZGUgIT09IHZvaWQgMCA/IGxpbmtlZE5vZGUgOiBsaW5rZXIuY3JlYXRlTGlua2luZ0Vycm9yKHsgcmVmZXJlbmNlLCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5IH0sIHRoaXMuX25vZGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX3JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWZlcmVuY2UgaGFzIG5vdCBiZWVuIGxpbmtlZCB5ZXQsIHNvIGRvIHRoYXQgbm93LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZEYXRhID0gbGlua2VyLmdldExpbmtlZE5vZGUoeyByZWZlcmVuY2UsIGNvbnRhaW5lcjogbm9kZSwgcHJvcGVydHkgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZEYXRhLmVycm9yICYmIGdldERvY3VtZW50KG5vZGUpLnN0YXRlIDwgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3Blcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgc2NvcGUgaXMgbm90IHJlYWR5LCBkb24ndCBzZXQgYHRoaXMuX3JlZmAgc28gbGlua2VyIGNhbiByZXRyeSBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVmID0gKF9hID0gcmVmRGF0YS5ub2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZWZEYXRhLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ub2RlRGVzY3JpcHRpb24gPSByZWZEYXRhLmRlc2NyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXNBc3ROb2RlKHRoaXMuX3JlZikgPyB0aGlzLl9yZWYgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0ICRub2RlRGVzY3JpcHRpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGVEZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTGlua2luZ0Vycm9yKHRoaXMuX3JlZikgPyB0aGlzLl9yZWYgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2U7XG4gICAgfVxuICAgIGdldExpbmtlZE5vZGUocmVmSW5mbykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmdldENhbmRpZGF0ZShyZWZJbmZvKTtcbiAgICAgICAgICAgIGlmIChpc0xpbmtpbmdFcnJvcihkZXNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogZGVzY3JpcHRpb24gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpbmtlZE5vZGUgPSB0aGlzLmxvYWRBc3ROb2RlKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChsaW5rZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbGlua2VkTm9kZSwgZGVzY3I6IGRlc2NyaXB0aW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLmNyZWF0ZUxpbmtpbmdFcnJvcihyZWZJbmZvLCBkZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVmSW5mbyksIHsgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlc29sdmluZyByZWZlcmVuY2UgdG8gJyR7cmVmSW5mby5yZWZlcmVuY2UuJHJlZlRleHR9JzogJHtlcnJ9YCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkQXN0Tm9kZShub2RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKG5vZGVEZXNjcmlwdGlvbi5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZURlc2NyaXB0aW9uLm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzKCkuZ2V0RG9jdW1lbnQobm9kZURlc2NyaXB0aW9uLmRvY3VtZW50VXJpKTtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZShkb2MucGFyc2VSZXN1bHQudmFsdWUsIG5vZGVEZXNjcmlwdGlvbi5wYXRoKTtcbiAgICB9XG4gICAgY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8sIHRhcmdldERlc2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIHN1ZmZpY2llbnRseSBwcm9jZXNzZWQgYnkgdGhlIERvY3VtZW50QnVpbGRlci4gSWYgbm90LCB0aGlzIGlzIGEgaGludCBmb3IgYSBidWdcbiAgICAgICAgLy8gaW4gdGhlIGxhbmd1YWdlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KHJlZkluZm8uY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnN0YXRlIDwgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3Blcykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBdHRlbXB0ZWQgcmVmZXJlbmNlIHJlc29sdXRpb24gYmVmb3JlIGRvY3VtZW50IHJlYWNoZWQgQ29tcHV0ZWRTY29wZXMgc3RhdGUgKCR7ZG9jdW1lbnQudXJpfSkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHRoaXMucmVmbGVjdGlvbi5nZXRSZWZlcmVuY2VUeXBlKHJlZkluZm8pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZWZJbmZvKSwgeyBtZXNzYWdlOiBgQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlIHRvICR7cmVmZXJlbmNlVHlwZX0gbmFtZWQgJyR7cmVmSW5mby5yZWZlcmVuY2UuJHJlZlRleHR9Jy5gLCB0YXJnZXREZXNjcmlwdGlvbiB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saW5rZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZmluZE5vZGVGb3JQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmFtZWQobm9kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygbm9kZS5uYW1lID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydCBjbGFzcyBEZWZhdWx0TmFtZVByb3ZpZGVyIHtcbiAgICBnZXROYW1lKG5vZGUpIHtcbiAgICAgICAgaWYgKGlzTmFtZWQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0TmFtZU5vZGUobm9kZSkge1xuICAgICAgICByZXR1cm4gZmluZE5vZGVGb3JQcm9wZXJ0eShub2RlLiRjc3ROb2RlLCAnbmFtZScpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hbWUtcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZmluZEFzc2lnbm1lbnQgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNDaGlsZE5vZGUsIHRvRG9jdW1lbnRTZWdtZW50IH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBVcmlVdGlscyB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFJlZmVyZW5jZXMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICB9XG4gICAgZmluZERlY2xhcmF0aW9uKHNvdXJjZUNzdE5vZGUpIHtcbiAgICAgICAgaWYgKHNvdXJjZUNzdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBmaW5kQXNzaWdubWVudChzb3VyY2VDc3ROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtID0gc291cmNlQ3N0Tm9kZS5hc3ROb2RlO1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQgJiYgbm9kZUVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2UgPSBub2RlRWxlbVthc3NpZ25tZW50LmZlYXR1cmVdO1xuICAgICAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZShyZWZlcmVuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2UucmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCByZWYgb2YgcmVmZXJlbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UocmVmKSAmJiByZWYuJHJlZk5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByZWYuJHJlZk5vZGUub2Zmc2V0IDw9IHNvdXJjZUNzdE5vZGUub2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcmVmLiRyZWZOb2RlLmVuZCA+PSBzb3VyY2VDc3ROb2RlLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWYucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGVFbGVtKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZU5vZGUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lTm9kZShub2RlRWxlbSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSByZXR1cm4gdGhlIHRhcmdldGVkIG5vZGUgaW4gY2FzZSB0aGUgdGFyZ2V0ZWQgY3N0IG5vZGUgaXMgdGhlIG5hbWUgbm9kZSBvciBwYXJ0IG9mIGl0XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVOb2RlICYmIChuYW1lTm9kZSA9PT0gc291cmNlQ3N0Tm9kZSB8fCBpc0NoaWxkTm9kZShzb3VyY2VDc3ROb2RlLCBuYW1lTm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlRWxlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZERlY2xhcmF0aW9uTm9kZShzb3VyY2VDc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGUgPSB0aGlzLmZpbmREZWNsYXJhdGlvbihzb3VyY2VDc3ROb2RlKTtcbiAgICAgICAgaWYgKGFzdE5vZGUgPT09IG51bGwgfHwgYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0Tm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKGFzdE5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldE5vZGUgIT09IG51bGwgJiYgdGFyZ2V0Tm9kZSAhPT0gdm9pZCAwID8gdGFyZ2V0Tm9kZSA6IGFzdE5vZGUuJGNzdE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZmluZFJlZmVyZW5jZXModGFyZ2V0Tm9kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZWZzID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRSZWZlcmVuY2VUb1NlbGYodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4UmVmZXJlbmNlcyA9IHRoaXMuaW5kZXguZmluZEFsbFJlZmVyZW5jZXModGFyZ2V0Tm9kZSwgdGhpcy5ub2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aCh0YXJnZXROb2RlKSk7XG4gICAgICAgIGlmIChvcHRpb25zLmRvY3VtZW50VXJpKSB7XG4gICAgICAgICAgICBpbmRleFJlZmVyZW5jZXMgPSBpbmRleFJlZmVyZW5jZXMuZmlsdGVyKHJlZiA9PiBVcmlVdGlscy5lcXVhbHMocmVmLnNvdXJjZVVyaSwgb3B0aW9ucy5kb2N1bWVudFVyaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJlZnMucHVzaCguLi5pbmRleFJlZmVyZW5jZXMpO1xuICAgICAgICByZXR1cm4gc3RyZWFtKHJlZnMpO1xuICAgIH1cbiAgICBnZXRSZWZlcmVuY2VUb1NlbGYodGFyZ2V0Tm9kZSkge1xuICAgICAgICBjb25zdCBuYW1lTm9kZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKHRhcmdldE5vZGUpO1xuICAgICAgICBpZiAobmFtZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KHRhcmdldE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMubm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNvdXJjZVVyaTogZG9jLnVyaSxcbiAgICAgICAgICAgICAgICBzb3VyY2VQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHRhcmdldFVyaTogZG9jLnVyaSxcbiAgICAgICAgICAgICAgICB0YXJnZXRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHNlZ21lbnQ6IHRvRG9jdW1lbnRTZWdtZW50KG5hbWVOb2RlKSxcbiAgICAgICAgICAgICAgICBsb2NhbDogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZmVyZW5jZXMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgUmVkdWN0aW9uLCBzdHJlYW0gfSBmcm9tICcuL3N0cmVhbS5qcyc7XG4vKipcbiAqIEEgbXVsdGltYXAgaXMgYSB2YXJpYXRpb24gb2YgYSBNYXAgdGhhdCBoYXMgcG90ZW50aWFsbHkgbXVsdGlwbGUgdmFsdWVzIGZvciBldmVyeSBrZXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aU1hcCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiBSZWR1Y3Rpb24uc3VtKHN0cmVhbSh0aGlzLm1hcC52YWx1ZXMoKSkubWFwKGEgPT4gYS5sZW5ndGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGVudHJpZXMgaW4gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVyYXRlcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gd2hldGhlciBhIGB2YWx1ZWAgaXMgZ2l2ZW46XG4gICAgICogICogV2l0aCBhIHZhbHVlLCB0aGlzIG1ldGhvZCBkZWxldGVzIHRoZSBzcGVjaWZpYyBrZXkgLyB2YWx1ZSBwYWlyIGZyb20gdGhlIG11bHRpbWFwLlxuICAgICAqICAqIFdpdGhvdXQgYSB2YWx1ZSwgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleSBhcmUgZGVsZXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIHZhbHVlIGV4aXN0ZWQgYW5kIGhhcyBiZWVuIHJlbW92ZWQsIG9yIGBmYWxzZWAgaWYgdGhlIHNwZWNpZmllZFxuICAgICAqICAgICBrZXkgLyB2YWx1ZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB2YWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS4gSWYgbm8gdmFsdWUgZXhpc3RzLFxuICAgICAqIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogX05vdGU6XyBUaGUgcmV0dXJuZWQgYXJyYXkgaXMgYXNzdW1lZCBub3QgdG8gYmUgbW9kaWZpZWQuIFVzZSB0aGUgYHNldGAgbWV0aG9kIHRvIGFkZCBhXG4gICAgICogdmFsdWUgYW5kIGBkZWxldGVgIHRvIHJlbW92ZSBhIHZhbHVlIGZyb20gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5tYXAuZ2V0KGtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVyYXRlcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gd2hldGhlciBhIGB2YWx1ZWAgaXMgZ2l2ZW46XG4gICAgICogICogV2l0aCBhIHZhbHVlLCB0aGlzIG1ldGhvZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgc3BlY2lmaWMga2V5IC8gdmFsdWUgcGFpciBpcyBwcmVzZW50IGluIHRoZSBtdWx0aW1hcC5cbiAgICAgKiAgKiBXaXRob3V0IGEgdmFsdWUsIHRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBrZXkgaXMgcHJlc2VudCBpbiB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgaGFzKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIGtleSAvIHZhbHVlIHBhaXIgdG8gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KGtleSkucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBnaXZlbiBzZXQgb2Yga2V5IC8gdmFsdWUgcGFpcnMgdG8gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGFkZEFsbChrZXksIHZhbHVlcykge1xuICAgICAgICBpZiAodGhpcy5tYXAuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLmdldChrZXkpLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIEFycmF5LmZyb20odmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBldmVyeSBrZXkgLyB2YWx1ZSBwYWlyIGluIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICAgICAgdGhpcy5tYXAuZm9yRWFjaCgoYXJyYXksIGtleSkgPT4gYXJyYXkuZm9yRWFjaCh2YWx1ZSA9PiBjYWxsYmFja2ZuKHZhbHVlLCBrZXksIHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaXRlcmF0b3Igb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpLml0ZXJhdG9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2Yga2V5LCB2YWx1ZSBwYWlycyBmb3IgZXZlcnkgZW50cnkgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtKHRoaXMubWFwLmVudHJpZXMoKSlcbiAgICAgICAgICAgIC5mbGF0TWFwKChba2V5LCBhcnJheV0pID0+IGFycmF5Lm1hcCh2YWx1ZSA9PiBba2V5LCB2YWx1ZV0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBrZXlzIGluIHRoZSBtYXAuXG4gICAgICovXG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLm1hcC5rZXlzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIHZhbHVlcyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLm1hcC52YWx1ZXMoKSkuZmxhdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIGtleSwgdmFsdWUgc2V0IHBhaXJzIGZvciBldmVyeSBrZXkgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBlbnRyaWVzR3JvdXBlZEJ5S2V5KCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtKHRoaXMubWFwLmVudHJpZXMoKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJpTWFwIHtcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLnNpemU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmludmVyc2UgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChlbGVtZW50cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlLmNsZWFyKCk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnZlcnNlLnNldCh2YWx1ZSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJzZS5nZXQodmFsdWUpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuaW52ZXJzZS5kZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxLTIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgc3RyZWFtQWxsQ29udGVudHMsIHN0cmVhbUNvbnRlbnRzIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnLi4vdXRpbHMvY29sbGVjdGlvbnMuanMnO1xuaW1wb3J0IHsgaW50ZXJydXB0QW5kQ2hlY2sgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbi8qKlxuICogVGhlIGRlZmF1bHQgc2NvcGUgY29tcHV0YXRpb24gY3JlYXRlcyBhbmQgY29sbGVjdGVzIGRlc2NyaXB0aW9ucyBvZiB0aGUgQVNUIG5vZGVzIHRvIGJlIGV4cG9ydGVkIGludG8gdGhlXG4gKiBfZ2xvYmFsXyBzY29wZSBmcm9tIHRoZSBnaXZlbiBkb2N1bWVudC4gQnkgZGVmYXVsdCB0aG9zZSBhcmUgdGhlIGRvY3VtZW50J3Mgcm9vdCBBU1Qgbm9kZSBhbmQgaXRzIGRpcmVjdGx5XG4gKiBjb250YWluZWQgY2hpbGQgbm9kZXMuXG4gKlxuICogQmVzaWRlcywgaXQgZ2F0aGVycyBhbGwgQVNUIG5vZGVzIHRoYXQgaGF2ZSBhIG5hbWUgKGFjY29yZGluZyB0byB0aGUgYE5hbWVQcm92aWRlcmAgc2VydmljZSkgYW5kIGluY2x1ZGVzIHRoZW1cbiAqIGluIHRoZSBsb2NhbCBzY29wZSBvZiB0aGVpciBwYXJ0aWN1bGFyIGNvbnRhaW5lciBub2Rlcy4gQXMgYSByZXN1bHQsIGZvciBldmVyeSBjcm9zcy1yZWZlcmVuY2UgaW4gdGhlIEFTVCxcbiAqIHRhcmdldCBlbGVtZW50cyBmcm9tIHRoZSBzYW1lIGxldmVsIChzaWJsaW5ncykgYW5kIGZ1cnRoZXIgdXAgdG93YXJkcyB0aGUgcm9vdCAocGFyZW50cyBhbmQgc2libGluZ3Mgb2YgcGFyZW50cylcbiAqIGFyZSB2aXNpYmxlLiBFbGVtZW50cyBiZWluZyBuZXN0ZWQgaW5zaWRlIGxvd2VyIGxldmVscyAoY2hpbGRyZW4sIGNoaWxkcmVuIG9mIHNpYmxpbmdzIGFuZCBwYXJlbnRzJyBzaWJsaW5ncylcbiAqIGFyZSBfaW52aXNpYmxlXyBieSBkZWZhdWx0LCBidXQgdGhhdCBjYW4gYmUgY2hhbmdlZCBieSBjdXN0b21pemluZyB0aGlzIHNlcnZpY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U2NvcGVDb21wdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5uYW1lUHJvdmlkZXIgPSBzZXJ2aWNlcy5yZWZlcmVuY2VzLk5hbWVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbnMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXI7XG4gICAgfVxuICAgIGFzeW5jIGNvbXB1dGVFeHBvcnRzKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUV4cG9ydHNGb3JOb2RlKGRvY3VtZW50LnBhcnNlUmVzdWx0LnZhbHVlLCBkb2N1bWVudCwgdW5kZWZpbmVkLCBjYW5jZWxUb2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMge0BsaW5rIEFzdE5vZGVEZXNjcmlwdGlvbiBBc3ROb2RlRGVzY3JpcHRpb25zfSBmb3IgdGhlIGdpdmVuIHtAbGluayBBc3ROb2RlIHBhcmVudE5vZGV9IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICogVGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gYmUgY29uc2lkZXJlZCBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmdW5jdGlvbiBwYXJhbWV0ZXIge0BsaW5rIGNoaWxkcmVufS5cbiAgICAgKiBCeSBkZWZhdWx0IG9ubHkgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB7QGxpbmsgcGFyZW50Tm9kZX0gYXJlIHZpc2l0ZWQsIG5lc3RlZCBub2RlcyBhcmUgbm90IGV4cG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudE5vZGUgQVNUIG5vZGUgdG8gYmUgZXhwb3J0ZWQsIGkuZS4sIG9mIHdoaWNoIGFuIHtAbGluayBBc3ROb2RlRGVzY3JpcHRpb259IHNoYWxsIGJlIGFkZGVkIHRvIHRoZSByZXR1cm5lZCBsaXN0LlxuICAgICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgQVNUIG5vZGUgdG8gYmUgZXhwb3J0ZWQuXG4gICAgICogQHBhcmFtIGNoaWxkcmVuIEEgZnVuY3Rpb24gY2FsbGVkIHdpdGgge0BsaW5rIHBhcmVudE5vZGV9IGFzIHNpbmdsZSBhcmd1bWVudCBhbmQgcmV0dXJuaW5nIGFuIHtAbGluayBJdGVyYWJsZX0gc3VwcGx5aW5nIHRoZSBjaGlsZHJlbiB0byBiZSB2aXNpdGVkLCB3aGljaCBtdXN0IGJlIGRpcmVjdGx5IG9yIHRyYW5zaXRpdmVseSBjb250YWluZWQgaW4ge0BsaW5rIHBhcmVudE5vZGV9LlxuICAgICAqIEBwYXJhbSBjYW5jZWxUb2tlbiBJbmRpY2F0ZXMgd2hlbiB0byBjYW5jZWwgdGhlIGN1cnJlbnQgb3BlcmF0aW9uLlxuICAgICAqIEB0aHJvd3MgYE9wZXJhdGlvbkNhbmNlbGVkYCBpZiBhIHVzZXIgYWN0aW9uIG9jY3VycyBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgbGlzdCBvZiB7QGxpbmsgQXN0Tm9kZURlc2NyaXB0aW9uIEFzdE5vZGVEZXNjcmlwdGlvbnN9IHRvIGJlIHB1Ymxpc2hlZCB0byBpbmRleC5cbiAgICAgKi9cbiAgICBhc3luYyBjb21wdXRlRXhwb3J0c0Zvck5vZGUocGFyZW50Tm9kZSwgZG9jdW1lbnQsIGNoaWxkcmVuID0gc3RyZWFtQ29udGVudHMsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBleHBvcnRzID0gW107XG4gICAgICAgIHRoaXMuZXhwb3J0Tm9kZShwYXJlbnROb2RlLCBleHBvcnRzLCBkb2N1bWVudCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjaGlsZHJlbihwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5leHBvcnROb2RlKG5vZGUsIGV4cG9ydHMsIGRvY3VtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2luZ2xlIG5vZGUgdG8gdGhlIGxpc3Qgb2YgZXhwb3J0cyBpZiBpdCBoYXMgYSBuYW1lLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgaG93XG4gICAgICogc3ltYm9scyBhcmUgZXhwb3J0ZWQsIGUuZy4gYnkgbW9kaWZ5aW5nIHRoZWlyIGV4cG9ydGVkIG5hbWUuXG4gICAgICovXG4gICAgZXhwb3J0Tm9kZShub2RlLCBleHBvcnRzLCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZShub2RlKTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMucHVzaCh0aGlzLmRlc2NyaXB0aW9ucy5jcmVhdGVEZXNjcmlwdGlvbihub2RlLCBuYW1lLCBkb2N1bWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNvbXB1dGVMb2NhbFNjb3Blcyhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IG5ldyBNdWx0aU1hcCgpO1xuICAgICAgICAvLyBIZXJlIHdlIG5hdmlnYXRlIHRoZSBmdWxsIEFTVCAtIGxvY2FsIHNjb3BlcyBzaGFsbCBiZSBhdmFpbGFibGUgaW4gdGhlIHdob2xlIGRvY3VtZW50XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdHJlYW1BbGxDb250ZW50cyhyb290Tm9kZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05vZGUobm9kZSwgZG9jdW1lbnQsIHNjb3Blcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIHNpbmdsZSBub2RlIGR1cmluZyBzY29wZXMgY29tcHV0YXRpb24uIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG1ha2VzIHRoZSBub2RlIHZpc2libGVcbiAgICAgKiBpbiB0aGUgc3VidHJlZSBvZiBpdHMgY29udGFpbmVyIChpZiB0aGUgbm9kZSBoYXMgYSBuYW1lKS4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoaXMsXG4gICAgICogZS5nLiBieSBpbmNyZWFzaW5nIHRoZSB2aXNpYmlsaXR5IHRvIGEgaGlnaGVyIGxldmVsIGluIHRoZSBBU1QuXG4gICAgICovXG4gICAgcHJvY2Vzc05vZGUobm9kZSwgZG9jdW1lbnQsIHNjb3Blcykge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBub2RlLiRjb250YWluZXI7XG4gICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKG5vZGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzY29wZXMuYWRkKGNvbnRhaW5lciwgdGhpcy5kZXNjcmlwdGlvbnMuY3JlYXRlRGVzY3JpcHRpb24obm9kZSwgbmFtZSwgZG9jdW1lbnQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjb3BlLWNvbXB1dGF0aW9uLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IEVNUFRZX1NUUkVBTSwgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbi8qKlxuICogVGhlIGRlZmF1bHQgc2NvcGUgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gYSBgU3RyZWFtYC4gSXQgaGFzIGFuIG9wdGlvbmFsIF9vdXRlciBzY29wZV8gZGVzY3JpYmluZ1xuICogdGhlIG5leHQgbGV2ZWwgb2YgZWxlbWVudHMsIHdoaWNoIGFyZSBxdWVyaWVkIHdoZW4gYSB0YXJnZXQgZWxlbWVudCBpcyBub3QgZm91bmQgaW4gdGhlIHN0cmVhbSBwcm92aWRlZFxuICogdG8gdGhpcyBzY29wZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbVNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cywgb3V0ZXJTY29wZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICAgICAgdGhpcy5vdXRlclNjb3BlID0gb3V0ZXJTY29wZTtcbiAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FzZUluc2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0QWxsRWxlbWVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm91dGVyU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmNvbmNhdCh0aGlzLm91dGVyU2NvcGUuZ2V0QWxsRWxlbWVudHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbGVtZW50KG5hbWUpIHtcbiAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZVxuICAgICAgICAgICAgPyB0aGlzLmVsZW1lbnRzLmZpbmQoZSA9PiBlLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgOiB0aGlzLmVsZW1lbnRzLmZpbmQoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRlclNjb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRlclNjb3BlLmdldEVsZW1lbnQobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTWFwU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCBvdXRlclNjb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FzZUluc2Vuc2l0aXZlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5jYXNlSW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICA/IGVsZW1lbnQubmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgOiBlbGVtZW50Lm5hbWU7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnNldChuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dGVyU2NvcGUgPSBvdXRlclNjb3BlO1xuICAgIH1cbiAgICBnZXRFbGVtZW50KG5hbWUpIHtcbiAgICAgICAgY29uc3QgbG9jYWxOYW1lID0gdGhpcy5jYXNlSW5zZW5zaXRpdmUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiBuYW1lO1xuICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXMuZWxlbWVudHMuZ2V0KGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dGVyU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGVyU2NvcGUuZ2V0RWxlbWVudChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRBbGxFbGVtZW50cygpIHtcbiAgICAgICAgbGV0IGVsZW1lbnRTdHJlYW0gPSBzdHJlYW0odGhpcy5lbGVtZW50cy52YWx1ZXMoKSk7XG4gICAgICAgIGlmICh0aGlzLm91dGVyU2NvcGUpIHtcbiAgICAgICAgICAgIGVsZW1lbnRTdHJlYW0gPSBlbGVtZW50U3RyZWFtLmNvbmNhdCh0aGlzLm91dGVyU2NvcGUuZ2V0QWxsRWxlbWVudHMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRTdHJlYW07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEVNUFRZX1NDT1BFID0ge1xuICAgIGdldEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBnZXRBbGxFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIEVNUFRZX1NUUkVBTTtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudG9EaXNwb3NlID0gW107XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvbkRpc3Bvc2UoZGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzLnRvRGlzcG9zZS5wdXNoKGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9EaXNwb3NlLmZvckVhY2goZGlzcG9zYWJsZSA9PiBkaXNwb3NhYmxlLmRpc3Bvc2UoKSk7XG4gICAgfVxuICAgIHRocm93SWZEaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNhY2hlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaW1wbGVDYWNoZSBleHRlbmRzIERpc3Bvc2FibGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQoa2V5LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZXh0Q2FjaGUgZXh0ZW5kcyBEaXNwb3NhYmxlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlciAhPT0gbnVsbCAmJiBjb252ZXJ0ZXIgIT09IHZvaWQgMCA/IGNvbnZlcnRlciA6ICh2YWx1ZSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGhhcyhjb250ZXh0S2V5LCBrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoY29udGV4dEtleSwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldChjb250ZXh0S2V5LCBrZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRDYWNoZSA9IHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpO1xuICAgICAgICBpZiAoY29udGV4dENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dENhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb250ZXh0Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoY29udGV4dEtleSwga2V5KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgY2xlYXIoY29udGV4dEtleSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAoY29udGV4dEtleSkge1xuICAgICAgICAgICAgY29uc3QgbWFwS2V5ID0gdGhpcy5jb252ZXJ0ZXIoY29udGV4dEtleSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShtYXBLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KSB7XG4gICAgICAgIGNvbnN0IG1hcEtleSA9IHRoaXMuY29udmVydGVyKGNvbnRleHRLZXkpO1xuICAgICAgICBsZXQgZG9jdW1lbnRDYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KG1hcEtleSk7XG4gICAgICAgIGlmICghZG9jdW1lbnRDYWNoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KG1hcEtleSwgZG9jdW1lbnRDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50Q2FjaGU7XG4gICAgfVxufVxuLyoqXG4gKiBFdmVyeSBrZXkvdmFsdWUgcGFpciBpbiB0aGlzIGNhY2hlIGlzIHNjb3BlZCB0byBhIGRvY3VtZW50LlxuICogSWYgdGhpcyBkb2N1bWVudCBpcyBjaGFuZ2VkIG9yIGRlbGV0ZWQsIGFsbCBhc3NvY2lhdGVkIGtleS92YWx1ZSBwYWlycyBhcmUgZGVsZXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERvY3VtZW50Q2FjaGUgZXh0ZW5kcyBDb250ZXh0Q2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHNoYXJlZFNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKHVyaSA9PiB1cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIHRoaXMub25EaXNwb3NlKHNoYXJlZFNlcnZpY2VzLndvcmtzcGFjZS5Eb2N1bWVudEJ1aWxkZXIub25VcGRhdGUoKGNoYW5nZWQsIGRlbGV0ZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFVyaXMgPSBjaGFuZ2VkLmNvbmNhdChkZWxldGVkKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXJpIG9mIGFsbFVyaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKHVyaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vKipcbiAqIEV2ZXJ5IGtleS92YWx1ZSBwYWlyIGluIHRoaXMgY2FjaGUgaXMgc2NvcGVkIHRvIHRoZSB3aG9sZSB3b3Jrc3BhY2UuXG4gKiBJZiBhbnkgZG9jdW1lbnQgaW4gdGhlIHdvcmtzcGFjZSBjaGFuZ2VzLCB0aGUgd2hvbGUgY2FjaGUgaXMgZXZpY3RlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmtzcGFjZUNhY2hlIGV4dGVuZHMgU2ltcGxlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKHNoYXJlZFNlcnZpY2VzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub25EaXNwb3NlKHNoYXJlZFNlcnZpY2VzLndvcmtzcGFjZS5Eb2N1bWVudEJ1aWxkZXIub25VcGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGluZy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IE1hcFNjb3BlLCBTdHJlYW1TY29wZSB9IGZyb20gJy4vc2NvcGUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFdvcmtzcGFjZUNhY2hlIH0gZnJvbSAnLi4vdXRpbHMvY2FjaGluZy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFNjb3BlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMucmVmbGVjdGlvbiA9IHNlcnZpY2VzLnNoYXJlZC5Bc3RSZWZsZWN0aW9uO1xuICAgICAgICB0aGlzLm5hbWVQcm92aWRlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTmFtZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9ucyA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5nbG9iYWxTY29wZUNhY2hlID0gbmV3IFdvcmtzcGFjZUNhY2hlKHNlcnZpY2VzLnNoYXJlZCk7XG4gICAgfVxuICAgIGdldFNjb3BlKGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gW107XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZVR5cGUgPSB0aGlzLnJlZmxlY3Rpb24uZ2V0UmVmZXJlbmNlVHlwZShjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcHJlY29tcHV0ZWQgPSBnZXREb2N1bWVudChjb250ZXh0LmNvbnRhaW5lcikucHJlY29tcHV0ZWRTY29wZXM7XG4gICAgICAgIGlmIChwcmVjb21wdXRlZCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gY29udGV4dC5jb250YWluZXI7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRGVzY3JpcHRpb25zID0gcHJlY29tcHV0ZWQuZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxsRGVzY3JpcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGVzLnB1c2goc3RyZWFtKGFsbERlc2NyaXB0aW9ucykuZmlsdGVyKGRlc2MgPT4gdGhpcy5yZWZsZWN0aW9uLmlzU3VidHlwZShkZXNjLnR5cGUsIHJlZmVyZW5jZVR5cGUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuJGNvbnRhaW5lcjtcbiAgICAgICAgICAgIH0gd2hpbGUgKGN1cnJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5nZXRHbG9iYWxTY29wZShyZWZlcmVuY2VUeXBlLCBjb250ZXh0KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNjb3Blcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5jcmVhdGVTY29wZShzY29wZXNbaV0sIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2NvcGUgZm9yIHRoZSBnaXZlbiBjb2xsZWN0aW9uIG9mIEFTVCBub2RlIGRlc2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICBjcmVhdGVTY29wZShlbGVtZW50cywgb3V0ZXJTY29wZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVNjb3BlKHN0cmVhbShlbGVtZW50cyksIG91dGVyU2NvcGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBzY29wZSBmb3IgdGhlIGdpdmVuIGNvbGxlY3Rpb24gb2YgQVNUIG5vZGVzLCB3aGljaCBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIGludG8gcmVzcGVjdGl2ZVxuICAgICAqIGRlc2NyaXB0aW9ucyBmaXJzdC4gVGhpcyBpcyBkb25lIHVzaW5nIHRoZSBgTmFtZVByb3ZpZGVyYCBhbmQgYEFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyYCBzZXJ2aWNlcy5cbiAgICAgKi9cbiAgICBjcmVhdGVTY29wZUZvck5vZGVzKGVsZW1lbnRzLCBvdXRlclNjb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHMgPSBzdHJlYW0oZWxlbWVudHMpLm1hcChlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXNjcmlwdGlvbnMuY3JlYXRlRGVzY3JpcHRpb24oZSwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KS5ub25OdWxsYWJsZSgpO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbVNjb3BlKHMsIG91dGVyU2NvcGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnbG9iYWwgc2NvcGUgZmlsdGVyZWQgZm9yIHRoZSBnaXZlbiByZWZlcmVuY2UgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRHbG9iYWxTY29wZShyZWZlcmVuY2VUeXBlLCBfY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbG9iYWxTY29wZUNhY2hlLmdldChyZWZlcmVuY2VUeXBlLCAoKSA9PiBuZXcgTWFwU2NvcGUodGhpcy5pbmRleE1hbmFnZXIuYWxsRWxlbWVudHMocmVmZXJlbmNlVHlwZSkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS1wcm92aWRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBVUkkgfSBmcm9tICd2c2NvZGUtdXJpJztcbmltcG9ydCB7IGlzQXN0Tm9kZSwgaXNSZWZlcmVuY2UgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBmaW5kTm9kZXNGb3JQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXN0Tm9kZVdpdGhDb21tZW50KG5vZGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5vZGUuJGNvbW1lbnQgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNJbnRlcm1lZGlhdGVSZWZlcmVuY2Uob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICEhb2JqICYmICgnJHJlZicgaW4gb2JqIHx8ICckZXJyb3InIGluIG9iaik7XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdEpzb25TZXJpYWxpemVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICAvKiogVGhlIHNldCBvZiBBc3ROb2RlIHByb3BlcnRpZXMgdG8gYmUgaWdub3JlZCBieSB0aGUgc2VyaWFsaXplci4gKi9cbiAgICAgICAgdGhpcy5pZ25vcmVQcm9wZXJ0aWVzID0gbmV3IFNldChbJyRjb250YWluZXInLCAnJGNvbnRhaW5lclByb3BlcnR5JywgJyRjb250YWluZXJJbmRleCcsICckZG9jdW1lbnQnLCAnJGNzdE5vZGUnXSk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50cztcbiAgICAgICAgdGhpcy5hc3ROb2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICAgICAgdGhpcy5uYW1lUHJvdmlkZXIgPSBzZXJ2aWNlcy5yZWZlcmVuY2VzLk5hbWVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5jb21tZW50UHJvdmlkZXIgPSBzZXJ2aWNlcy5kb2N1bWVudGF0aW9uLkNvbW1lbnRQcm92aWRlcjtcbiAgICB9XG4gICAgc2VyaWFsaXplKG5vZGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBzcGVjaWZpY1JlcGxhY2VyID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGxhY2VyO1xuICAgICAgICBjb25zdCBkZWZhdWx0UmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4gdGhpcy5yZXBsYWNlcihrZXksIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVwbGFjZXIgPSBzcGVjaWZpY1JlcGxhY2VyID8gKGtleSwgdmFsdWUpID0+IHNwZWNpZmljUmVwbGFjZXIoa2V5LCB2YWx1ZSwgZGVmYXVsdFJlcGxhY2VyKSA6IGRlZmF1bHRSZXBsYWNlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERvY3VtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9kZSwgcmVwbGFjZXIsIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREb2N1bWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXNlcmlhbGl6ZShjb250ZW50LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgIHRoaXMubGlua05vZGUocm9vdCwgcm9vdCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXBsYWNlcihrZXksIHZhbHVlLCB7IHJlZlRleHQsIHNvdXJjZVRleHQsIHRleHRSZWdpb25zLCBjb21tZW50cywgdXJpQ29udmVydGVyIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAodGhpcy5pZ25vcmVQcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVmVmFsdWUgPSB2YWx1ZS5yZWY7XG4gICAgICAgICAgICBjb25zdCAkcmVmVGV4dCA9IHJlZlRleHQgPyB2YWx1ZS4kcmVmVGV4dCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChyZWZWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRVcmkgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RG9jdW1lbnQgJiYgdGhpcy5jdXJyZW50RG9jdW1lbnQgIT09IHRhcmdldERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cmlDb252ZXJ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFVyaSA9IHVyaUNvbnZlcnRlcih0YXJnZXREb2N1bWVudC51cmksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFVyaSA9IHRhcmdldERvY3VtZW50LnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSB0aGlzLmFzdE5vZGVMb2NhdG9yLmdldEFzdE5vZGVQYXRoKHJlZlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAkcmVmOiBgJHt0YXJnZXRVcml9IyR7dGFyZ2V0UGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICAkcmVmVGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAkZXJyb3I6IChfYiA9IChfYSA9IHZhbHVlLmVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ0NvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZScsXG4gICAgICAgICAgICAgICAgICAgICRyZWZUZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgYXN0Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0ZXh0UmVnaW9ucykge1xuICAgICAgICAgICAgICAgIGFzdE5vZGUgPSB0aGlzLmFkZEFzdE5vZGVSZWdpb25XaXRoQXNzaWdubWVudHNUbyhPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGlmICgoIWtleSB8fCB2YWx1ZS4kZG9jdW1lbnQpICYmIChhc3ROb2RlID09PSBudWxsIHx8IGFzdE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFzdE5vZGUuJHRleHRSZWdpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkb2N1bWVudCBVUkkgaXMgYWRkZWQgdG8gdGhlIHJvb3Qgbm9kZSBvZiB0aGUgcmVzdWx0aW5nIEpTT04gdHJlZVxuICAgICAgICAgICAgICAgICAgICBhc3ROb2RlLiR0ZXh0UmVnaW9uLmRvY3VtZW50VVJJID0gKF9jID0gdGhpcy5jdXJyZW50RG9jdW1lbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlVGV4dCAmJiAha2V5KSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZSAhPT0gbnVsbCAmJiBhc3ROb2RlICE9PSB2b2lkIDAgPyBhc3ROb2RlIDogKGFzdE5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIGFzdE5vZGUuJHNvdXJjZVRleHQgPSAoX2QgPSB2YWx1ZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICBhc3ROb2RlICE9PSBudWxsICYmIGFzdE5vZGUgIT09IHZvaWQgMCA/IGFzdE5vZGUgOiAoYXN0Tm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuY29tbWVudFByb3ZpZGVyLmdldENvbW1lbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFzdE5vZGUuJGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoL1xcci9nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFzdE5vZGUgIT09IG51bGwgJiYgYXN0Tm9kZSAhPT0gdm9pZCAwID8gYXN0Tm9kZSA6IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEFzdE5vZGVSZWdpb25XaXRoQXNzaWdubWVudHNUbyhub2RlKSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZURvY3VtZW50U2VnbWVudCA9IGNzdE5vZGUgPT4gKHtcbiAgICAgICAgICAgIG9mZnNldDogY3N0Tm9kZS5vZmZzZXQsXG4gICAgICAgICAgICBlbmQ6IGNzdE5vZGUuZW5kLFxuICAgICAgICAgICAgbGVuZ3RoOiBjc3ROb2RlLmxlbmd0aCxcbiAgICAgICAgICAgIHJhbmdlOiBjc3ROb2RlLnJhbmdlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vZGUuJGNzdE5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHRSZWdpb24gPSBub2RlLiR0ZXh0UmVnaW9uID0gY3JlYXRlRG9jdW1lbnRTZWdtZW50KG5vZGUuJGNzdE5vZGUpO1xuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudHMgPSB0ZXh0UmVnaW9uLmFzc2lnbm1lbnRzID0ge307XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhub2RlKS5maWx0ZXIoa2V5ID0+ICFrZXkuc3RhcnRzV2l0aCgnJCcpKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHlBc3NpZ25tZW50cyA9IGZpbmROb2Rlc0ZvclByb3BlcnR5KG5vZGUuJGNzdE5vZGUsIGtleSkubWFwKGNyZWF0ZURvY3VtZW50U2VnbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5QXNzaWdubWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2lnbm1lbnRzW2tleV0gPSBwcm9wZXJ0eUFzc2lnbm1lbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGlua05vZGUobm9kZSwgcm9vdCwgb3B0aW9ucywgY29udGFpbmVyLCBjb250YWluZXJQcm9wZXJ0eSwgY29udGFpbmVySW5kZXgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHlOYW1lLCBpdGVtXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgaXRlbS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGl0ZW1baW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbnRlcm1lZGlhdGVSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1baW5kZXhdID0gdGhpcy5yZXZpdmVSZWZlcmVuY2Uobm9kZSwgcHJvcGVydHlOYW1lLCByb290LCBlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlua05vZGUoZWxlbWVudCwgcm9vdCwgb3B0aW9ucywgbm9kZSwgcHJvcGVydHlOYW1lLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ludGVybWVkaWF0ZVJlZmVyZW5jZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIG5vZGVbcHJvcGVydHlOYW1lXSA9IHRoaXMucmV2aXZlUmVmZXJlbmNlKG5vZGUsIHByb3BlcnR5TmFtZSwgcm9vdCwgaXRlbSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmtOb2RlKGl0ZW0sIHJvb3QsIG9wdGlvbnMsIG5vZGUsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXV0YWJsZSA9IG5vZGU7XG4gICAgICAgIG11dGFibGUuJGNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgbXV0YWJsZS4kY29udGFpbmVyUHJvcGVydHkgPSBjb250YWluZXJQcm9wZXJ0eTtcbiAgICAgICAgbXV0YWJsZS4kY29udGFpbmVySW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICB9XG4gICAgcmV2aXZlUmVmZXJlbmNlKGNvbnRhaW5lciwgcHJvcGVydHksIHJvb3QsIHJlZmVyZW5jZSwgb3B0aW9ucykge1xuICAgICAgICBsZXQgcmVmVGV4dCA9IHJlZmVyZW5jZS4kcmVmVGV4dDtcbiAgICAgICAgbGV0IGVycm9yID0gcmVmZXJlbmNlLiRlcnJvcjtcbiAgICAgICAgaWYgKHJlZmVyZW5jZS4kcmVmKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldFJlZk5vZGUocm9vdCwgcmVmZXJlbmNlLiRyZWYsIG9wdGlvbnMudXJpQ29udmVydGVyKTtcbiAgICAgICAgICAgIGlmIChpc0FzdE5vZGUocmVmKSkge1xuICAgICAgICAgICAgICAgIGlmICghcmVmVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZWZUZXh0ID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZShyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAkcmVmVGV4dDogcmVmVGV4dCAhPT0gbnVsbCAmJiByZWZUZXh0ICE9PSB2b2lkIDAgPyByZWZUZXh0IDogJycsXG4gICAgICAgICAgICAgICAgICAgIHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgICAgICAgICAkcmVmVGV4dDogcmVmVGV4dCAhPT0gbnVsbCAmJiByZWZUZXh0ICE9PSB2b2lkIDAgPyByZWZUZXh0IDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZWYuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVmTm9kZShyb290LCB1cmksIHVyaUNvbnZlcnRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRJbmRleCA9IHVyaS5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmFzdE5vZGVMb2NhdG9yLmdldEFzdE5vZGUocm9vdCwgdXJpLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ291bGQgbm90IHJlc29sdmUgcGF0aDogJyArIHVyaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRJbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudFVyaSA9IHVyaUNvbnZlcnRlciA/IHVyaUNvbnZlcnRlcih1cmkpIDogVVJJLnBhcnNlKHVyaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0RG9jdW1lbnQoZG9jdW1lbnRVcmkpO1xuICAgICAgICAgICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDb3VsZCBub3QgZmluZCBkb2N1bWVudCBmb3IgVVJJOiAnICsgdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudFVyaSA9IHVyaUNvbnZlcnRlciA/IHVyaUNvbnZlcnRlcih1cmkuc3Vic3RyaW5nKDAsIGZyYWdtZW50SW5kZXgpKSA6IFVSSS5wYXJzZSh1cmkuc3Vic3RyaW5nKDAsIGZyYWdtZW50SW5kZXgpKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmdldERvY3VtZW50KGRvY3VtZW50VXJpKTtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0NvdWxkIG5vdCBmaW5kIGRvY3VtZW50IGZvciBVUkk6ICcgKyB1cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnRJbmRleCA9PT0gdXJpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5hc3ROb2RlTG9jYXRvci5nZXRBc3ROb2RlKGRvY3VtZW50LnBhcnNlUmVzdWx0LnZhbHVlLCB1cmkuc3Vic3RyaW5nKGZyYWdtZW50SW5kZXggKyAxKSk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0NvdWxkIG5vdCByZXNvbHZlIFVSSTogJyArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tc2VyaWFsaXplci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBVcmlVdGlscyB9IGZyb20gJy4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbi8qKlxuICogR2VuZXJpYyByZWdpc3RyeSBmb3IgTGFuZ2l1bSBzZXJ2aWNlcywgYnV0IGNhcGFibGUgb2YgYmVpbmcgdXNlZCB3aXRoIGV4dGVuZGluZyBzZXJ2aWNlIHNldHMgYXMgd2VsbCAoc3VjaCBhcyB0aGUgbHNwLWNvbXBsZXRlIExhbmdpdW1Db3JlU2VydmljZXMgc2V0KVxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFNlcnZpY2VSZWdpc3RyeSB7XG4gICAgcmVnaXN0ZXIobGFuZ3VhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpbmdsZXRvbiAmJiAhdGhpcy5tYXApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGxhbmd1YWdlIHRvIGJlIHJlZ2lzdGVyZWQ7IHN0b3JlIGl0IGFzIHNpbmdsZXRvbi5cbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1hcCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNpbmdsZXRvbikge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHByZXZpb3VzIHNpbmdsZXRvbiBpbnN0YW5jZSB0byB0aGUgbmV3IG1hcC5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGV4dCBvZiB0aGlzLnNpbmdsZXRvbi5MYW5ndWFnZU1ldGFEYXRhLmZpbGVFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW2V4dF0gPSB0aGlzLnNpbmdsZXRvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaW5nbGV0b24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIGxhbmd1YWdlIHNlcnZpY2VzIGluIHRoZSBtYXAuXG4gICAgICAgIGZvciAoY29uc3QgZXh0IG9mIGxhbmd1YWdlLkxhbmd1YWdlTWV0YURhdGEuZmlsZUV4dGVuc2lvbnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcFtleHRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5tYXBbZXh0XSAhPT0gbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBmaWxlIGV4dGVuc2lvbiAke2V4dH0gaXMgdXNlZCBieSBtdWx0aXBsZSBsYW5ndWFnZXMuIEl0IGlzIG5vdyBhc3NpZ25lZCB0byAnJHtsYW5ndWFnZS5MYW5ndWFnZU1ldGFEYXRhLmxhbmd1YWdlSWR9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFwW2V4dF0gPSBsYW5ndWFnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTZXJ2aWNlcyh1cmkpIHtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xldG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmljZSByZWdpc3RyeSBpcyBlbXB0eS4gVXNlIGByZWdpc3RlcmAgdG8gcmVnaXN0ZXIgdGhlIHNlcnZpY2VzIG9mIGEgbGFuZ3VhZ2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXh0ID0gVXJpVXRpbHMuZXh0bmFtZSh1cmkpO1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMubWFwW2V4dF07XG4gICAgICAgIGlmICghc2VydmljZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgcmVnaXN0cnkgY29udGFpbnMgbm8gc2VydmljZXMgZm9yIHRoZSBleHRlbnNpb24gJyR7ZXh0fScuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgIH1cbiAgICBnZXQgYWxsKCkge1xuICAgICAgICBpZiAodGhpcy5zaW5nbGV0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnNpbmdsZXRvbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1yZWdpc3RyeS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJy4uL3V0aWxzL2NvbGxlY3Rpb25zLmpzJztcbmltcG9ydCB7IGlzT3BlcmF0aW9uQ2FuY2VsbGVkIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuLyoqXG4gKiBDcmVhdGUgRGlhZ25vc3RpY0RhdGEgZm9yIGEgZ2l2ZW4gZGlhZ25vc3RpYyBjb2RlLiBUaGUgcmVzdWx0IGNhbiBiZSBwdXQgaW50byB0aGUgYGRhdGFgIGZpZWxkIG9mIGEgRGlhZ25vc3RpY0luZm8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWFnbm9zdGljRGF0YShjb2RlKSB7XG4gICAgcmV0dXJuIHsgY29kZSB9O1xufVxuZXhwb3J0IHZhciBWYWxpZGF0aW9uQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKFZhbGlkYXRpb25DYXRlZ29yeSkge1xuICAgIFZhbGlkYXRpb25DYXRlZ29yeS5hbGwgPSBbJ2Zhc3QnLCAnc2xvdycsICdidWlsdC1pbiddO1xufSkoVmFsaWRhdGlvbkNhdGVnb3J5IHx8IChWYWxpZGF0aW9uQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqXG4gKiBNYW5hZ2VzIGEgc2V0IG9mIGBWYWxpZGF0aW9uQ2hlY2tgcyB0byBiZSBhcHBsaWVkIHdoZW4gZG9jdW1lbnRzIGFyZSB2YWxpZGF0ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IG5ldyBNdWx0aU1hcCgpO1xuICAgICAgICB0aGlzLnJlZmxlY3Rpb24gPSBzZXJ2aWNlcy5zaGFyZWQuQXN0UmVmbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzZXQgb2YgdmFsaWRhdGlvbiBjaGVja3MuIEVhY2ggdmFsdWUgaW4gdGhlIHJlY29yZCBjYW4gYmUgZWl0aGVyIGEgc2luZ2xlIHZhbGlkYXRpb24gY2hlY2sgKGkuZS4gYSBmdW5jdGlvbilcbiAgICAgKiBvciBhbiBhcnJheSBvZiB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGVja3NSZWNvcmQgU2V0IG9mIHZhbGlkYXRpb24gY2hlY2tzIHRvIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSBjYXRlZ29yeSBPcHRpb25hbCBjYXRlZ29yeSBmb3IgdGhlIHZhbGlkYXRpb24gY2hlY2tzIChkZWZhdWx0cyB0byBgJ2Zhc3QnYCkuXG4gICAgICogQHBhcmFtIHRoaXNPYmogT3B0aW9uYWwgb2JqZWN0IHRvIGJlIHVzZWQgYXMgYHRoaXNgIHdoZW4gY2FsbGluZyB0aGUgdmFsaWRhdGlvbiBjaGVjayBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY2hlY2tzUmVjb3JkLCB0aGlzT2JqID0gdGhpcywgY2F0ZWdvcnkgPSAnZmFzdCcpIHtcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnYnVpbHQtaW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2J1aWx0LWluJyBjYXRlZ29yeSBpcyByZXNlcnZlZCBmb3IgbGV4ZXIsIHBhcnNlciwgYW5kIGxpbmtlciBlcnJvcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3R5cGUsIGNoXSBvZiBPYmplY3QuZW50cmllcyhjaGVja3NSZWNvcmQpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjaDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiB0aGlzLndyYXBWYWxpZGF0aW9uRXhjZXB0aW9uKGNoZWNrLCB0aGlzT2JqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50cnkodHlwZSwgZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2s6IHRoaXMud3JhcFZhbGlkYXRpb25FeGNlcHRpb24oY2FsbGJhY2tzLCB0aGlzT2JqKSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50cnkodHlwZSwgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHdyYXBWYWxpZGF0aW9uRXhjZXB0aW9uKGNoZWNrLCB0aGlzT2JqKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAobm9kZSwgYWNjZXB0LCBjYW5jZWxUb2tlbikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGVjay5jYWxsKHRoaXNPYmosIG5vZGUsIGFjY2VwdCwgY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHZhbGlkYXRpb246JywgZXJyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFN0cmluZyhlcnIpO1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnIuc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhY2NlcHQoJ2Vycm9yJywgJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyB2YWxpZGF0aW9uOiAnICsgbWVzc2FnZSwgeyBub2RlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRFbnRyeSh0eXBlLCBlbnRyeSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0FzdE5vZGUnKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuYWRkKCdBc3ROb2RlJywgZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3VidHlwZSBvZiB0aGlzLnJlZmxlY3Rpb24uZ2V0QWxsU3ViVHlwZXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW50cmllcy5hZGQoc3VidHlwZSwgZW50cnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoZWNrcyh0eXBlLCBjYXRlZ29yaWVzKSB7XG4gICAgICAgIGxldCBjaGVja3MgPSBzdHJlYW0odGhpcy5lbnRyaWVzLmdldCh0eXBlKSlcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5lbnRyaWVzLmdldCgnQXN0Tm9kZScpKTtcbiAgICAgICAgaWYgKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIGNoZWNrcyA9IGNoZWNrcy5maWx0ZXIoZW50cnkgPT4gY2F0ZWdvcmllcy5pbmNsdWRlcyhlbnRyeS5jYXRlZ29yeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja3MubWFwKGVudHJ5ID0+IGVudHJ5LmNoZWNrKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD12YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IGZpbmROb2RlRm9yS2V5d29yZCwgZmluZE5vZGVGb3JQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtQXN0IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHRva2VuVG9SYW5nZSB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpbnRlcnJ1cHRBbmRDaGVjaywgaXNPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IGRpYWdub3N0aWNEYXRhIH0gZnJvbSAnLi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RG9jdW1lbnRWYWxpZGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvblJlZ2lzdHJ5ID0gc2VydmljZXMudmFsaWRhdGlvbi5WYWxpZGF0aW9uUmVnaXN0cnk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBzZXJ2aWNlcy5MYW5ndWFnZU1ldGFEYXRhO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZURvY3VtZW50KGRvY3VtZW50LCBvcHRpb25zID0ge30sIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGRvY3VtZW50LnBhcnNlUmVzdWx0O1xuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IFtdO1xuICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYXRlZ29yaWVzIHx8IG9wdGlvbnMuY2F0ZWdvcmllcy5pbmNsdWRlcygnYnVpbHQtaW4nKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJMZXhpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdFcnJvcjsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJQYXJzaW5nRXJyb3JzICYmIGRpYWdub3N0aWNzLnNvbWUoZCA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBkLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gRG9jdW1lbnRWYWxpZGF0b3IuUGFyc2luZ0Vycm9yOyB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0b3BBZnRlckxpbmtpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MaW5raW5nRXJyb3I7IH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgY3VzdG9tIHZhbGlkYXRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLmF3YWl0IHRoaXMudmFsaWRhdGVBc3QocGFyc2VSZXN1bHQudmFsdWUsIG9wdGlvbnMsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdmFsaWRhdGlvbjonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgIH1cbiAgICBwcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlckVycm9yIG9mIHBhcnNlUmVzdWx0LmxleGVyRXJyb3JzKSB7XG4gICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgIHNldmVyaXR5OiB0b0RpYWdub3N0aWNTZXZlcml0eSgnZXJyb3InKSxcbiAgICAgICAgICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXJFcnJvci5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbGV4ZXJFcnJvci5jb2x1bW4gLSAxXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXJFcnJvci5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbGV4ZXJFcnJvci5jb2x1bW4gKyBsZXhlckVycm9yLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbGV4ZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRpYWdub3N0aWNEYXRhKERvY3VtZW50VmFsaWRhdG9yLkxleGluZ0Vycm9yKSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKGRpYWdub3N0aWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJzZXJFcnJvciBvZiBwYXJzZVJlc3VsdC5wYXJzZXJFcnJvcnMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBydW4gaW50byB0aGUgY2hldnJvdGFpbiBlcnJvciByZWNvdmVyeSBoZXJlXG4gICAgICAgICAgICAvLyBUaGUgdG9rZW4gY29udGFpbmVkIGluIHRoZSBwYXJzZXIgZXJyb3IgbWlnaHQgYmUgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGV2ZXJ5IHBvc2l0aW9uIHZhbHVlIHdpbGwgYmUgYE5hTmBcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZXJFcnJvci50b2tlbi5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHNwZWNpYWwgcGFyc2VyIGVycm9yIHR5cGVzIGNvbnRhaW4gYSBgcHJldmlvdXNUb2tlbmBcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2ltcGx5IGFwcGVuZCBvdXIgZGlhZ25vc3RpYyB0byB0aGF0IHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKCdwcmV2aW91c1Rva2VuJyBpbiBwYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnNlckVycm9yLnByZXZpb3VzVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odG9rZW4uc3RhcnRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogdG9rZW4uZW5kTGluZSAtIDEsIGNoYXJhY3RlcjogdG9rZW4uZW5kQ29sdW1uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB2YWxpZCBwcmV2IHRva2VuLiBNaWdodCBiZSBlbXB0eSBkb2N1bWVudCBvciBjb250YWluaW5nIG9ubHkgaGlkZGVuIHRva2Vucy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvaW50IHRvIGRvY3VtZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRva2VuVG9SYW5nZShwYXJzZXJFcnJvci50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogdG9EaWFnbm9zdGljU2V2ZXJpdHkoJ2Vycm9yJyksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkaWFnbm9zdGljRGF0YShEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBfb3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiBkb2N1bWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5raW5nRXJyb3IgPSByZWZlcmVuY2UuZXJyb3I7XG4gICAgICAgICAgICBpZiAobGlua2luZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGxpbmtpbmdFcnJvci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmtpbmdFcnJvci5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyVHlwZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lci4kdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBsaW5raW5nRXJyb3IucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUZXh0OiBsaW5raW5nRXJyb3IucmVmZXJlbmNlLiRyZWZUZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2godGhpcy50b0RpYWdub3N0aWMoJ2Vycm9yJywgbGlua2luZ0Vycm9yLm1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZUFzdChyb290Tm9kZSwgb3B0aW9ucywgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25JdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRvciA9IChzZXZlcml0eSwgbWVzc2FnZSwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkl0ZW1zLnB1c2godGhpcy50b0RpYWdub3N0aWMoc2V2ZXJpdHksIG1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc3RyZWFtQXN0KHJvb3ROb2RlKS5tYXAoYXN5bmMgKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrcyA9IHRoaXMudmFsaWRhdGlvblJlZ2lzdHJ5LmdldENoZWNrcyhub2RlLiR0eXBlLCBvcHRpb25zLmNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiBjaGVja3MpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBjaGVjayhub2RlLCBhY2NlcHRvciwgY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uSXRlbXM7XG4gICAgfVxuICAgIHRvRGlhZ25vc3RpYyhzZXZlcml0eSwgbWVzc2FnZSwgaW5mbykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIHJhbmdlOiBnZXREaWFnbm9zdGljUmFuZ2UoaW5mbyksXG4gICAgICAgICAgICBzZXZlcml0eTogdG9EaWFnbm9zdGljU2V2ZXJpdHkoc2V2ZXJpdHkpLFxuICAgICAgICAgICAgY29kZTogaW5mby5jb2RlLFxuICAgICAgICAgICAgY29kZURlc2NyaXB0aW9uOiBpbmZvLmNvZGVEZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHRhZ3M6IGluZm8udGFncyxcbiAgICAgICAgICAgIHJlbGF0ZWRJbmZvcm1hdGlvbjogaW5mby5yZWxhdGVkSW5mb3JtYXRpb24sXG4gICAgICAgICAgICBkYXRhOiBpbmZvLmRhdGEsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0U291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YS5sYW5ndWFnZUlkO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXREaWFnbm9zdGljUmFuZ2UoaW5mbykge1xuICAgIGlmIChpbmZvLnJhbmdlKSB7XG4gICAgICAgIHJldHVybiBpbmZvLnJhbmdlO1xuICAgIH1cbiAgICBsZXQgY3N0Tm9kZTtcbiAgICBpZiAodHlwZW9mIGluZm8ucHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNzdE5vZGUgPSBmaW5kTm9kZUZvclByb3BlcnR5KGluZm8ubm9kZS4kY3N0Tm9kZSwgaW5mby5wcm9wZXJ0eSwgaW5mby5pbmRleCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbmZvLmtleXdvcmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNzdE5vZGUgPSBmaW5kTm9kZUZvcktleXdvcmQoaW5mby5ub2RlLiRjc3ROb2RlLCBpbmZvLmtleXdvcmQsIGluZm8uaW5kZXgpO1xuICAgIH1cbiAgICBjc3ROb2RlICE9PSBudWxsICYmIGNzdE5vZGUgIT09IHZvaWQgMCA/IGNzdE5vZGUgOiAoY3N0Tm9kZSA9IGluZm8ubm9kZS4kY3N0Tm9kZSk7XG4gICAgaWYgKCFjc3ROb2RlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogeyBsaW5lOiAwLCBjaGFyYWN0ZXI6IDAgfSxcbiAgICAgICAgICAgIGVuZDogeyBsaW5lOiAwLCBjaGFyYWN0ZXI6IDAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY3N0Tm9kZS5yYW5nZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eSkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIDE7IC8vIGFjY29yZGluZyB0byB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdHlwZXMvbGliL2VzbS9tYWluLmpzI0RpYWdub3N0aWNTZXZlcml0eS5FcnJvclxuICAgICAgICBjYXNlICd3YXJuaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAyOyAvLyBhY2NvcmRpbmcgdG8gdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyNEaWFnbm9zdGljU2V2ZXJpdHkuV2FybmluZ1xuICAgICAgICBjYXNlICdpbmZvJzpcbiAgICAgICAgICAgIHJldHVybiAzOyAvLyBhY2NvcmRpbmcgdG8gdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyNEaWFnbm9zdGljU2V2ZXJpdHkuSW5mb3JtYXRpb25cbiAgICAgICAgY2FzZSAnaGludCc6XG4gICAgICAgICAgICByZXR1cm4gNDsgLy8gYWNjb3JkaW5nIHRvIHZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcy9saWIvZXNtL21haW4uanMjRGlhZ25vc3RpY1NldmVyaXR5LkhpbnRcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWFnbm9zdGljIHNldmVyaXR5OiAnICsgc2V2ZXJpdHkpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgRG9jdW1lbnRWYWxpZGF0b3I7XG4oZnVuY3Rpb24gKERvY3VtZW50VmFsaWRhdG9yKSB7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGV4aW5nRXJyb3IgPSAnbGV4aW5nLWVycm9yJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IgPSAncGFyc2luZy1lcnJvcic7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yID0gJ2xpbmtpbmctZXJyb3InO1xufSkoRG9jdW1lbnRWYWxpZGF0b3IgfHwgKERvY3VtZW50VmFsaWRhdG9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50LXZhbGlkYXRvci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBpc0xpbmtpbmdFcnJvciB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IGdldERvY3VtZW50LCBzdHJlYW1Bc3QsIHN0cmVhbVJlZmVyZW5jZXMgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgdG9Eb2N1bWVudFNlZ21lbnQgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaW50ZXJydXB0QW5kQ2hlY2sgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuYXN0Tm9kZUxvY2F0b3IgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZUxvY2F0b3I7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgfVxuICAgIGNyZWF0ZURlc2NyaXB0aW9uKG5vZGUsIG5hbWUsIGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogKG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKG5vZGUpKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgobm9kZSk7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIGF0IHBhdGggJHtwYXRofSBoYXMgbm8gbmFtZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZU5vZGVTZWdtZW50O1xuICAgICAgICBjb25zdCBuYW1lU2VnbWVudEdldHRlciA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gbmFtZU5vZGVTZWdtZW50ICE9PSBudWxsICYmIG5hbWVOb2RlU2VnbWVudCAhPT0gdm9pZCAwID8gbmFtZU5vZGVTZWdtZW50IDogKG5hbWVOb2RlU2VnbWVudCA9IHRvRG9jdW1lbnRTZWdtZW50KChfYSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKG5vZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBub2RlLiRjc3ROb2RlKSk7IH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGdldCBuYW1lU2VnbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVNlZ21lbnRHZXR0ZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25TZWdtZW50OiB0b0RvY3VtZW50U2VnbWVudChub2RlLiRjc3ROb2RlKSxcbiAgICAgICAgICAgIHR5cGU6IG5vZGUuJHR5cGUsXG4gICAgICAgICAgICBkb2N1bWVudFVyaTogZG9jdW1lbnQudXJpLFxuICAgICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5ub2RlTG9jYXRvciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Bc3ROb2RlTG9jYXRvcjtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlRGVzY3JpcHRpb25zKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3QgZGVzY3IgPSBbXTtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBhc3ROb2RlIG9mIHN0cmVhbUFzdChyb290Tm9kZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHN0cmVhbVJlZmVyZW5jZXMoYXN0Tm9kZSkuZmlsdGVyKHJlZkluZm8gPT4gIWlzTGlua2luZ0Vycm9yKHJlZkluZm8pKS5mb3JFYWNoKHJlZkluZm8gPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIGxvZ2dpbmcgYSB3YXJuaW5nIG9yIHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIERvY3VtZW50U3RhdGUgaXMgPCB0aGFuIExpbmtlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5jcmVhdGVEZXNjcmlwdGlvbihyZWZJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3IucHVzaChkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyO1xuICAgIH1cbiAgICBjcmVhdGVEZXNjcmlwdGlvbihyZWZJbmZvKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldE5vZGVEZXNjciA9IHJlZkluZm8ucmVmZXJlbmNlLiRub2RlRGVzY3JpcHRpb247XG4gICAgICAgIGNvbnN0IHJlZkNzdE5vZGUgPSByZWZJbmZvLnJlZmVyZW5jZS4kcmVmTm9kZTtcbiAgICAgICAgaWYgKCF0YXJnZXROb2RlRGVzY3IgfHwgIXJlZkNzdE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jVXJpID0gZ2V0RG9jdW1lbnQocmVmSW5mby5jb250YWluZXIpLnVyaTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNvdXJjZVVyaTogZG9jVXJpLFxuICAgICAgICAgICAgc291cmNlUGF0aDogdGhpcy5ub2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aChyZWZJbmZvLmNvbnRhaW5lciksXG4gICAgICAgICAgICB0YXJnZXRVcmk6IHRhcmdldE5vZGVEZXNjci5kb2N1bWVudFVyaSxcbiAgICAgICAgICAgIHRhcmdldFBhdGg6IHRhcmdldE5vZGVEZXNjci5wYXRoLFxuICAgICAgICAgICAgc2VnbWVudDogdG9Eb2N1bWVudFNlZ21lbnQocmVmQ3N0Tm9kZSksXG4gICAgICAgICAgICBsb2NhbDogVXJpVXRpbHMuZXF1YWxzKHRhcmdldE5vZGVEZXNjci5kb2N1bWVudFVyaSwgZG9jVXJpKVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC1kZXNjcmlwdGlvbnMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRBc3ROb2RlTG9jYXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudFNlcGFyYXRvciA9ICcvJztcbiAgICAgICAgdGhpcy5pbmRleFNlcGFyYXRvciA9ICdAJztcbiAgICB9XG4gICAgZ2V0QXN0Tm9kZVBhdGgobm9kZSkge1xuICAgICAgICBpZiAobm9kZS4kY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJQYXRoID0gdGhpcy5nZXRBc3ROb2RlUGF0aChub2RlLiRjb250YWluZXIpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VnbWVudCA9IHRoaXMuZ2V0UGF0aFNlZ21lbnQobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBub2RlUGF0aCA9IGNvbnRhaW5lclBhdGggKyB0aGlzLnNlZ21lbnRTZXBhcmF0b3IgKyBuZXdTZWdtZW50O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgZ2V0UGF0aFNlZ21lbnQoeyAkY29udGFpbmVyUHJvcGVydHksICRjb250YWluZXJJbmRleCB9KSB7XG4gICAgICAgIGlmICghJGNvbnRhaW5lclByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nICckY29udGFpbmVyUHJvcGVydHknIGluIEFTVCBub2RlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGNvbnRhaW5lckluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAkY29udGFpbmVyUHJvcGVydHkgKyB0aGlzLmluZGV4U2VwYXJhdG9yICsgJGNvbnRhaW5lckluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkY29udGFpbmVyUHJvcGVydHk7XG4gICAgfVxuICAgIGdldEFzdE5vZGUobm9kZSwgcGF0aCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQodGhpcy5zZWdtZW50U2VwYXJhdG9yKTtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXByZXZpb3VzVmFsdWUgfHwgY3VycmVudFZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcGVydHlJbmRleCA9IGN1cnJlbnRWYWx1ZS5pbmRleE9mKHRoaXMuaW5kZXhTZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIHByb3BlcnR5SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5SW5kZXggPSBwYXJzZUludChjdXJyZW50VmFsdWUuc3Vic3RyaW5nKHByb3BlcnR5SW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXkgPSBwcmV2aW91c1ZhbHVlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkgPT09IG51bGwgfHwgYXJyYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycmF5W2FycmF5SW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWVbY3VycmVudFZhbHVlXTtcbiAgICAgICAgfSwgbm9kZSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN0LW5vZGUtbG9jYXRvci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBEZWZlcnJlZCB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuLyoqXG4gKiBCYXNlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZXIgZm9yIGJ1aWxkaW5nIHVwIG90aGVyIGNvbmZpZ3VyYXRpb24gcHJvdmlkZXJzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q29uZmlndXJhdGlvblByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLl9yZWFkeSA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnNldHRpbmdzID0ge307XG4gICAgICAgIHRoaXMud29ya3NwYWNlQ29uZmlnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgIH1cbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLndvcmtzcGFjZUNvbmZpZyA9IChfYiA9IChfYSA9IHBhcmFtcy5jYXBhYmlsaXRpZXMud29ya3NwYWNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlndXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy53b3Jrc3BhY2VDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMucmVnaXN0ZXIoLi4uKSBpcyBhIGZ1bmN0aW9uIHRvIGJlIHByb3ZpZGVkIGJ5IHRoZSBjYWxsaW5nIGxhbmd1YWdlIHNlcnZlciBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyAgZGVjb3VwbGluZyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gdGhlIGNvbmNyZXRlIExTUCBpbXBsZW1lbnRhdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgTFNQIENvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5hbGw7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyBmb3IgYWxsIGxhbmd1YWdlc1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uOiBsYW5ndWFnZXMubWFwKGxhbmcgPT4gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZmV0Y2hDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbiguLi4pIGlzIGEgZnVuY3Rpb24gdG8gYmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxpbmcgbGFuZ3VhZ2Ugc2VydmVyIGZvciB0aGUgc2FrZSBvZlxuICAgICAgICAgICAgICAgIC8vICBkZWNvdXBsaW5nIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSB0aGUgY29uY3JldGUgTFNQIGltcGxlbWVudGF0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBMU1AgQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1RvVXBkYXRlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuYWxsLm1hcChsYW5nID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjb25maWd1cmF0aW9uIGNoYW5nZXMgZm9yIGFsbCBsYW5ndWFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgd29ya3NwYWNlIGNvbmZpZ3VyYXRpb25zIChkZWZhdWx0IHNjb3BlIFVSSSlcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWdzID0gYXdhaXQgcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbihjb25maWdUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uZmlnVG9VcGRhdGUuZm9yRWFjaCgoY29uZiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbkNvbmZpZ3VyYXRpb24oY29uZi5zZWN0aW9uLCBjb25maWdzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVwZGF0ZXMgdGhlIGNhY2hlZCBjb25maWd1cmF0aW9ucyB1c2luZyB0aGUgYGNoYW5nZWAgbm90aWZpY2F0aW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlIFRoZSBwYXJhbWV0ZXJzIG9mIGEgY2hhbmdlIGNvbmZpZ3VyYXRpb24gbm90aWZpY2F0aW9uLlxuICAgICAqIGBzZXR0aW5nc2AgcHJvcGVydHkgb2YgdGhlIGNoYW5nZSBvYmplY3QgY291bGQgYmUgZXhwcmVzc2VkIGFzIGBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBhbnk+PmBcbiAgICAgKi9cbiAgICB1cGRhdGVDb25maWd1cmF0aW9uKGNoYW5nZSkge1xuICAgICAgICBpZiAoIWNoYW5nZS5zZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZS5zZXR0aW5ncykuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbkNvbmZpZ3VyYXRpb24oc2VjdGlvbiwgY2hhbmdlLnNldHRpbmdzW3NlY3Rpb25dKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlY3Rpb25Db25maWd1cmF0aW9uKHNlY3Rpb24sIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1tzZWN0aW9uXSA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UuXG4gICAgKlxuICAgICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZFxuICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gQ29uZmlndXJhdGlvbiBuYW1lXG4gICAgKi9cbiAgICBhc3luYyBnZXRDb25maWd1cmF0aW9uKGxhbmd1YWdlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZHk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25OYW1lID0gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Nbc2VjdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1tzZWN0aW9uTmFtZV1bY29uZmlndXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TZWN0aW9uTmFtZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiBgJHtsYW5ndWFnZUlkfWA7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZmlndXJhdGlvbi5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgdmFyIERpc3Bvc2FibGU7XG4oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGFzeW5jICgpID0+IGF3YWl0IGNhbGxiYWNrKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChEaXNwb3NhYmxlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3Bvc2FibGUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgRGlzcG9zYWJsZSB9IGZyb20gJy4uL3V0aWxzL2Rpc3Bvc2FibGUuanMnO1xuaW1wb3J0IHsgTXVsdGlNYXAgfSBmcm9tICcuLi91dGlscy9jb2xsZWN0aW9ucy5qcyc7XG5pbXBvcnQgeyBPcGVyYXRpb25DYW5jZWxsZWQsIGludGVycnVwdEFuZENoZWNrIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuaW1wb3J0IHsgVmFsaWRhdGlvbkNhdGVnb3J5IH0gZnJvbSAnLi4vdmFsaWRhdGlvbi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IERvY3VtZW50U3RhdGUgfSBmcm9tICcuL2RvY3VtZW50cy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdERvY3VtZW50QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVCdWlsZE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBEZWZhdWx0OiBydW4gb25seSB0aGUgYnVpbHQtaW4gdmFsaWRhdGlvbiBjaGVja3MgYW5kIHRob3NlIGluIHRoZSBfZmFzdF8gY2F0ZWdvcnkgKGluY2x1ZGVzIHRob3NlIHdpdGhvdXQgY2F0ZWdvcnkpXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgY2F0ZWdvcmllczogWydidWlsdC1pbicsICdmYXN0J11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5idWlsZFBoYXNlTGlzdGVuZXJzID0gbmV3IE11bHRpTWFwKCk7XG4gICAgICAgIHRoaXMuYnVpbGRTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEJ1aWxkV2FpdGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBEb2N1bWVudFN0YXRlLkNoYW5nZWQ7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuSW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICB9XG4gICAgYXN5bmMgYnVpbGQoZG9jdW1lbnRzLCBvcHRpb25zID0ge30sIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBmb3IgKGNvbnN0IGRvY3VtZW50IG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuc3RhdGUgPT09IERvY3VtZW50U3RhdGUuVmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZhbGlkYXRpb24gPT09ICdib29sZWFuJyAmJiBvcHRpb25zLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgcmUtcnVubmluZyBhbGwgdmFsaWRhdGlvbiBjaGVja3NcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSBEb2N1bWVudFN0YXRlLkluZGV4ZWRSZWZlcmVuY2VzO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaWFnbm9zdGljcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3B0aW9ucy52YWxpZGF0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWlsZFN0YXRlID0gdGhpcy5idWlsZFN0YXRlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0NhdGVnb3JpZXMgPSAoX2EgPSBidWlsZFN0YXRlID09PSBudWxsIHx8IGJ1aWxkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJ1aWxkU3RhdGUucmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsaWRhdGlvbkNoZWNrcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzQ2F0ZWdvcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGlvbiB3aXRoIGV4cGxpY2l0IG9wdGlvbnMgd2FzIHJlcXVlc3RlZCBmb3IgYSBkb2N1bWVudCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gcGFydGx5IHZhbGlkYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBtZXJnZSB0aGUgcHJldmlvdXMgdmFsaWRhdGlvbiBjYXRlZ29yaWVzIHdpdGggdGhlIG5ldyBvbmVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcmllcyA9IChfYiA9IG9wdGlvbnMudmFsaWRhdGlvbi5jYXRlZ29yaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBWYWxpZGF0aW9uQ2F0ZWdvcnkuYWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IG5ld0NhdGVnb3JpZXMuZmlsdGVyKGMgPT4gIXByZXZpb3VzQ2F0ZWdvcmllcy5pbmNsdWRlcyhjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnZhbGlkYXRpb24pLCB7IGNhdGVnb3JpZXMgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBidWlsZFN0YXRlLnJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5JbmRleGVkUmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQ6IGZvcmdldCBhbnkgcHJldmlvdXMgYnVpbGQgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0VXBkYXRlKGRvY3VtZW50cy5tYXAoZSA9PiBlLnVyaSksIFtdKTtcbiAgICAgICAgYXdhaXQgdGhpcy5idWlsZERvY3VtZW50cyhkb2N1bWVudHMsIG9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlKGNoYW5nZWQsIGRlbGV0ZWQsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgLy8gUmVtb3ZlIGFsbCBtZXRhZGF0YSBvZiBkb2N1bWVudHMgdGhhdCBhcmUgcmVwb3J0ZWQgYXMgZGVsZXRlZFxuICAgICAgICBmb3IgKGNvbnN0IGRlbGV0ZWRVcmkgb2YgZGVsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmRlbGV0ZURvY3VtZW50KGRlbGV0ZWRVcmkpO1xuICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLmRlbGV0ZShkZWxldGVkVXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdGhpcy5pbmRleE1hbmFnZXIucmVtb3ZlKGRlbGV0ZWRVcmkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc3RhdGUgb2YgYWxsIGNoYW5nZWQgZG9jdW1lbnRzIHRvIGBDaGFuZ2VkYCBzbyB0aGV5IGFyZSBjb21wbGV0ZWx5IHJlYnVpbHRcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2VkVXJpIG9mIGNoYW5nZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGludmFsaWRhdGVkID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmludmFsaWRhdGVEb2N1bWVudChjaGFuZ2VkVXJpKTtcbiAgICAgICAgICAgIGlmICghaW52YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjcmVhdGUgYW4gdW5wYXJzZWQsIGludmFsaWQgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHBhcnNlZCBhcyBzb29uIGFzIHdlIHJlYWNoIHRoZSBmaXJzdCBkb2N1bWVudCBidWlsZGVyIHBoYXNlLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRvIGNhbmNlbCB0aGUgcGFyc2luZyBwcm9jZXNzIGxhdGVyIGluIGNhc2Ugd2UgbmVlZCBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEb2N1bWVudCA9IHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeS5mcm9tTW9kZWwoeyAkdHlwZTogJ0lOVkFMSUQnIH0sIGNoYW5nZWRVcmkpO1xuICAgICAgICAgICAgICAgIG5ld0RvY3VtZW50LnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5DaGFuZ2VkO1xuICAgICAgICAgICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cy5hZGREb2N1bWVudChuZXdEb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ1aWxkU3RhdGUuZGVsZXRlKGNoYW5nZWRVcmkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBzdGF0ZSBvZiBhbGwgZG9jdW1lbnRzIHRoYXQgc2hvdWxkIGJlIHJlbGlua2VkIHRvIGBDb21wdXRlZFNjb3Blc2AgKGlmIG5vdCBhbHJlYWR5IGxvd2VyKVxuICAgICAgICBjb25zdCBhbGxDaGFuZ2VkVXJpcyA9IHN0cmVhbShjaGFuZ2VkKS5jb25jYXQoZGVsZXRlZCkubWFwKHVyaSA9PiB1cmkudG9TdHJpbmcoKSkudG9TZXQoKTtcbiAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmFsbFxuICAgICAgICAgICAgLmZpbHRlcihkb2MgPT4gIWFsbENoYW5nZWRVcmlzLmhhcyhkb2MudXJpLnRvU3RyaW5nKCkpICYmIHRoaXMuc2hvdWxkUmVsaW5rKGRvYywgYWxsQ2hhbmdlZFVyaXMpKVxuICAgICAgICAgICAgLmZvckVhY2goZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvYy51cmkpLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICAgICAgbGlua2VyLnVubGluayhkb2MpO1xuICAgICAgICAgICAgZG9jLnN0YXRlID0gTWF0aC5taW4oZG9jLnN0YXRlLCBEb2N1bWVudFN0YXRlLkNvbXB1dGVkU2NvcGVzKTtcbiAgICAgICAgICAgIGRvYy5kaWFnbm9zdGljcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgb2YgdGhlIHVwZGF0ZVxuICAgICAgICBhd2FpdCB0aGlzLmVtaXRVcGRhdGUoY2hhbmdlZCwgZGVsZXRlZCk7XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgaW50ZXJydXB0aW5nIHRoZSBleGVjdXRpb24gYWZ0ZXIgYWxsIHN0YXRlIGNoYW5nZXMgYXJlIGRvbmVcbiAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAvLyBDb2xsZWN0IGFsbCBkb2N1bWVudHMgdGhhdCB3ZSBzaG91bGQgcmVidWlsZFxuICAgICAgICBjb25zdCByZWJ1aWxkRG9jdW1lbnRzID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmFsbFxuICAgICAgICAgICAgLmZpbHRlcihkb2MgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gVGhpcyBpbmNsdWRlcyB0aG9zZSB0aGF0IHdlcmUgcmVwb3J0ZWQgYXMgY2hhbmdlZCBhbmQgdGhvc2UgdGhhdCB3ZSBzZWxlY3RlZCBmb3IgcmVsaW5raW5nXG4gICAgICAgICAgICByZXR1cm4gZG9jLnN0YXRlIDwgRG9jdW1lbnRTdGF0ZS5MaW5rZWRcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIHRob3NlIGZvciB3aGljaCBhIHByZXZpb3VzIGJ1aWxkIGhhcyBiZWVuIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgIHx8ICEoKF9hID0gdGhpcy5idWlsZFN0YXRlLmdldChkb2MudXJpLnRvU3RyaW5nKCkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tcGxldGVkKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGREb2N1bWVudHMocmVidWlsZERvY3VtZW50cywgdGhpcy51cGRhdGVCdWlsZE9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgZW1pdFVwZGF0ZShjaGFuZ2VkLCBkZWxldGVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMudXBkYXRlTGlzdGVuZXJzLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lcihjaGFuZ2VkLCBkZWxldGVkKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBkb2N1bWVudCBzaG91bGQgYmUgcmVsaW5rZWQgYWZ0ZXIgY2hhbmdlcyB3ZXJlIGZvdW5kIGluIHRoZSBnaXZlbiBVUklzLlxuICAgICAqL1xuICAgIHNob3VsZFJlbGluayhkb2N1bWVudCwgY2hhbmdlZFVyaXMpIHtcbiAgICAgICAgLy8gUmVsaW5rIGRvY3VtZW50cyB3aXRoIGxpbmtpbmcgZXJyb3JzIC0tIG1heWJlIHRob3NlIHJlZmVyZW5jZXMgY2FuIGJlIHJlc29sdmVkIG5vd1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVmZXJlbmNlcy5zb21lKHJlZiA9PiByZWYuZXJyb3IgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIGFmZmVjdGVkIGJ5IGFueSBvZiB0aGUgY2hhbmdlZCBVUklzXG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4TWFuYWdlci5pc0FmZmVjdGVkKGRvY3VtZW50LCBjaGFuZ2VkVXJpcyk7XG4gICAgfVxuICAgIG9uVXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gRGlzcG9zYWJsZS5jcmVhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnVwZGF0ZUxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSBnaXZlbiBkb2N1bWVudHMgYnkgc3RlcHBpbmcgdGhyb3VnaCBhbGwgYnVpbGQgcGhhc2VzLiBJZiBhIGRvY3VtZW50J3Mgc3RhdGUgaW5kaWNhdGVzXG4gICAgICogdGhhdCBhIGNlcnRhaW4gYnVpbGQgcGhhc2UgaXMgYWxyZWFkeSBkb25lLCB0aGUgcGhhc2UgaXMgc2tpcHBlZCBmb3IgdGhhdCBkb2N1bWVudC5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZERvY3VtZW50cyhkb2N1bWVudHMsIG9wdGlvbnMsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZUJ1aWxkKGRvY3VtZW50cywgb3B0aW9ucyk7XG4gICAgICAgIC8vIDAuIFBhcnNlIGNvbnRlbnRcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5QYXJzZWQsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy5sYW5naXVtRG9jdW1lbnRGYWN0b3J5LnVwZGF0ZShkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIDEuIEluZGV4IGNvbnRlbnRcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5JbmRleGVkQ29udGVudCwgY2FuY2VsVG9rZW4sIGRvYyA9PiB0aGlzLmluZGV4TWFuYWdlci51cGRhdGVDb250ZW50KGRvYywgY2FuY2VsVG9rZW4pKTtcbiAgICAgICAgLy8gMi4gQ29tcHV0ZSBzY29wZXNcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3BlcywgY2FuY2VsVG9rZW4sIGFzeW5jIChkb2MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlQ29tcHV0YXRpb24gPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2MudXJpKS5yZWZlcmVuY2VzLlNjb3BlQ29tcHV0YXRpb247XG4gICAgICAgICAgICBkb2MucHJlY29tcHV0ZWRTY29wZXMgPSBhd2FpdCBzY29wZUNvbXB1dGF0aW9uLmNvbXB1dGVMb2NhbFNjb3Blcyhkb2MsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDMuIExpbmtpbmdcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5DYW5jZWxhYmxlKGRvY3VtZW50cywgRG9jdW1lbnRTdGF0ZS5MaW5rZWQsIGNhbmNlbFRva2VuLCBkb2MgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlua2VyID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jLnVyaSkucmVmZXJlbmNlcy5MaW5rZXI7XG4gICAgICAgICAgICByZXR1cm4gbGlua2VyLmxpbmsoZG9jLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyA0LiBJbmRleCByZWZlcmVuY2VzXG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuSW5kZXhlZFJlZmVyZW5jZXMsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy5pbmRleE1hbmFnZXIudXBkYXRlUmVmZXJlbmNlcyhkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIDUuIFZhbGlkYXRpb25cbiAgICAgICAgY29uc3QgdG9CZVZhbGlkYXRlZCA9IGRvY3VtZW50cy5maWx0ZXIoZG9jID0+IHRoaXMuc2hvdWxkVmFsaWRhdGUoZG9jKSk7XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZSh0b0JlVmFsaWRhdGVkLCBEb2N1bWVudFN0YXRlLlZhbGlkYXRlZCwgY2FuY2VsVG9rZW4sIGRvYyA9PiB0aGlzLnZhbGlkYXRlKGRvYywgY2FuY2VsVG9rZW4pKTtcbiAgICAgICAgLy8gSWYgd2UndmUgbWFkZSBpdCB0byB0aGlzIHBvaW50IHdpdGhvdXQgYmVpbmcgY2FuY2VsbGVkLCB3ZSBjYW4gbWFyayB0aGUgYnVpbGQgc3RhdGUgYXMgY29tcGxldGVkLlxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5idWlsZFN0YXRlLmdldChkb2MudXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmVwYXJlQnVpbGQoZG9jdW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jLnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmJ1aWxkU3RhdGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgaGFzIG5vIHByZXZpb3VzIGJ1aWxkIHN0YXRlLCB3ZSBzZXQgaXQuIElmIGl0IGhhcyBvbmUsIGJ1dCBpdCdzIGFscmVhZHkgbWFya2VkXG4gICAgICAgICAgICAvLyBhcyBjb21wbGV0ZWQsIHdlIG92ZXJ3cml0ZSBpdC4gSWYgdGhlIHByZXZpb3VzIGJ1aWxkIHdhcyBub3QgY29tcGxldGVkLCB3ZSBrZWVwIGl0cyBzdGF0ZVxuICAgICAgICAgICAgLy8gYW5kIGNvbnRpbnVlIHdoZXJlIGl0IHdhcyBjYW5jZWxsZWQuXG4gICAgICAgICAgICBpZiAoIXN0YXRlIHx8IHN0YXRlLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogc3RhdGUgPT09IG51bGwgfHwgc3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRlLnJlc3VsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJ1bkNhbmNlbGFibGUoZG9jdW1lbnRzLCB0YXJnZXRTdGF0ZSwgY2FuY2VsVG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gZG9jdW1lbnRzLmZpbHRlcihlID0+IGUuc3RhdGUgPCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5ub3RpZnlCdWlsZFBoYXNlKGZpbHRlcmVkLCB0YXJnZXRTdGF0ZSwgY2FuY2VsVG9rZW4pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgIH1cbiAgICBvbkJ1aWxkUGhhc2UodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycy5hZGQodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycy5kZWxldGUodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRVbnRpbChzdGF0ZSwgdXJpT3JUb2tlbiwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgbGV0IHVyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVyaU9yVG9rZW4gJiYgJ3BhdGgnIGluIHVyaU9yVG9rZW4pIHtcbiAgICAgICAgICAgIHVyaSA9IHVyaU9yVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5jZWxUb2tlbiA9IHVyaU9yVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsVG9rZW4gIT09IG51bGwgJiYgY2FuY2VsVG9rZW4gIT09IHZvaWQgMCA/IGNhbmNlbFRva2VuIDogKGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmdldERvY3VtZW50KHVyaSk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuc3RhdGUgPiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPj0gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW5jZWxUb2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkRGlzcG9zYWJsZSA9IHRoaXMub25CdWlsZFBoYXNlKHN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmdldERvY3VtZW50KHVyaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZG9jdW1lbnQgPT09IG51bGwgfHwgZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxEaXNwb3NhYmxlID0gY2FuY2VsVG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIG5vdGlmeUJ1aWxkUGhhc2UoZG9jdW1lbnRzLCBzdGF0ZSwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IG5vdGlmeSB3aGVuIG5vIGRvY3VtZW50IGhhcyBiZWVuIHByb2Nlc3NlZFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuYnVpbGRQaGFzZUxpc3RlbmVycy5nZXQoc3RhdGUpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgbGlzdGVuZXIoZG9jdW1lbnRzLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIGRvY3VtZW50IHNob3VsZCBiZSB2YWxpZGF0ZWQgZHVyaW5nIGEgYnVpbGQuIFRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gY2hlY2tzIHRoZSBgdmFsaWRhdGlvbmAgcHJvcGVydHkgb2YgdGhlIGJ1aWxkIG9wdGlvbnMuIElmIGl0J3Mgc2V0IHRvIGB0cnVlYFxuICAgICAqIG9yIGEgYFZhbGlkYXRpb25PcHRpb25zYCBvYmplY3QsIHRoZSBkb2N1bWVudCBpcyBpbmNsdWRlZCBpbiB0aGUgdmFsaWRhdGlvbiBwaGFzZS5cbiAgICAgKi9cbiAgICBzaG91bGRWYWxpZGF0ZShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldEJ1aWxkT3B0aW9ucyhkb2N1bWVudCkudmFsaWRhdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biB2YWxpZGF0aW9uIGNoZWNrcyBvbiB0aGUgZ2l2ZW4gZG9jdW1lbnQgYW5kIHN0b3JlIHRoZSByZXN1bHRpbmcgZGlhZ25vc3RpY3MgaW4gdGhlIGRvY3VtZW50LlxuICAgICAqIElmIHRoZSBkb2N1bWVudCBhbHJlYWR5IGNvbnRhaW5zIGRpYWdub3N0aWNzLCB0aGUgbmV3IG9uZXMgYXJlIGFkZGVkIHRvIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlKGRvY3VtZW50LCBjYW5jZWxUb2tlbikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB2YWxpZGF0b3IgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2N1bWVudC51cmkpLnZhbGlkYXRpb24uRG9jdW1lbnRWYWxpZGF0b3I7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25TZXR0aW5nID0gdGhpcy5nZXRCdWlsZE9wdGlvbnMoZG9jdW1lbnQpLnZhbGlkYXRpb247XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgdmFsaWRhdGlvblNldHRpbmcgPT09ICdvYmplY3QnID8gdmFsaWRhdGlvblNldHRpbmcgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gYXdhaXQgdmFsaWRhdG9yLnZhbGlkYXRlRG9jdW1lbnQoZG9jdW1lbnQsIG9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmRpYWdub3N0aWNzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5kaWFnbm9zdGljcy5wdXNoKC4uLmRpYWdub3N0aWNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmRpYWdub3N0aWNzID0gZGlhZ25vc3RpY3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4ZWN1dGVkIHZhbGlkYXRpb24gaW4gdGhlIGJ1aWxkIHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5idWlsZFN0YXRlLmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgKF9hID0gc3RhdGUucmVzdWx0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoc3RhdGUucmVzdWx0ID0ge30pO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2F0ZWdvcmllcyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXRlZ29yaWVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBWYWxpZGF0aW9uQ2F0ZWdvcnkuYWxsO1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc3VsdC52YWxpZGF0aW9uQ2hlY2tzKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVzdWx0LnZhbGlkYXRpb25DaGVja3MucHVzaCguLi5uZXdDYXRlZ29yaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJlc3VsdC52YWxpZGF0aW9uQ2hlY2tzID0gWy4uLm5ld0NhdGVnb3JpZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldEJ1aWxkT3B0aW9ucyhkb2N1bWVudCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5idWlsZFN0YXRlLmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcHRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb2N1bWVudC1idWlsZGVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IENvbnRleHRDYWNoZSB9IGZyb20gJy4uL3V0aWxzL2NhY2hpbmcuanMnO1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SW5kZXhNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN5bWJvbCBpbmRleCBzdG9yZXMgYWxsIGBBc3ROb2RlRGVzY3JpcHRpb25gIGl0ZW1zIGV4cG9ydGVkIGJ5IGEgZG9jdW1lbnQuXG4gICAgICAgICAqIFRoZSBrZXkgdXNlZCBpbiB0aGlzIG1hcCBpcyB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVjaWZpYyBkb2N1bWVudCBVUkkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN5bWJvbEluZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyBhIGNhY2hlIGZvciB0aGUgYGFsbEVsZW1lbnRzKClgIG1ldGhvZC5cbiAgICAgICAgICogSXQgY2FjaGVzIHRoZSBkZXNjcmlwdGlvbnMgZnJvbSBgc3ltYm9sSW5kZXhgIGdyb3VwZWQgYnkgdHlwZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN5bWJvbEJ5VHlwZUluZGV4ID0gbmV3IENvbnRleHRDYWNoZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpbmRleCBrZWVwcyB0cmFjayBvZiBhbGwgYFJlZmVyZW5jZURlc2NyaXB0aW9uYCBpdGVtcyBleHBvcnRlZCBieSBhIGRvY3VtZW50LlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gY29tcHV0ZSB3aGljaCBlbGVtZW50cyBhcmUgYWZmZWN0ZWQgYnkgYSBkb2N1bWVudCBjaGFuZ2VcbiAgICAgICAgICogYW5kIGZvciBmaW5kaW5nIHJlZmVyZW5jZXMgdG8gYW4gQVNUIG5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUluZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50cyA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICAgICAgdGhpcy5hc3RSZWZsZWN0aW9uID0gc2VydmljZXMuQXN0UmVmbGVjdGlvbjtcbiAgICB9XG4gICAgZmluZEFsbFJlZmVyZW5jZXModGFyZ2V0Tm9kZSwgYXN0Tm9kZVBhdGgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RG9jVXJpID0gZ2V0RG9jdW1lbnQodGFyZ2V0Tm9kZSkudXJpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VJbmRleC5mb3JFYWNoKGRvY1JlZnMgPT4ge1xuICAgICAgICAgICAgZG9jUmVmcy5mb3JFYWNoKHJlZkRlc2NyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoVXJpVXRpbHMuZXF1YWxzKHJlZkRlc2NyLnRhcmdldFVyaSwgdGFyZ2V0RG9jVXJpKSAmJiByZWZEZXNjci50YXJnZXRQYXRoID09PSBhc3ROb2RlUGF0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChyZWZEZXNjcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtKHJlc3VsdCk7XG4gICAgfVxuICAgIGFsbEVsZW1lbnRzKG5vZGVUeXBlLCB1cmlzKSB7XG4gICAgICAgIGxldCBkb2N1bWVudFVyaXMgPSBzdHJlYW0odGhpcy5zeW1ib2xJbmRleC5rZXlzKCkpO1xuICAgICAgICBpZiAodXJpcykge1xuICAgICAgICAgICAgZG9jdW1lbnRVcmlzID0gZG9jdW1lbnRVcmlzLmZpbHRlcih1cmkgPT4gIXVyaXMgfHwgdXJpcy5oYXModXJpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50VXJpc1xuICAgICAgICAgICAgLm1hcCh1cmkgPT4gdGhpcy5nZXRGaWxlRGVzY3JpcHRpb25zKHVyaSwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICB9XG4gICAgZ2V0RmlsZURlc2NyaXB0aW9ucyh1cmksIG5vZGVUeXBlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFub2RlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3ltYm9sSW5kZXguZ2V0KHVyaSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHRoaXMuc3ltYm9sQnlUeXBlSW5kZXguZ2V0KHVyaSwgbm9kZVR5cGUsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEZpbGVEZXNjcmlwdGlvbnMgPSAoX2EgPSB0aGlzLnN5bWJvbEluZGV4LmdldCh1cmkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIHJldHVybiBhbGxGaWxlRGVzY3JpcHRpb25zLmZpbHRlcihlID0+IHRoaXMuYXN0UmVmbGVjdGlvbi5pc1N1YnR5cGUoZS50eXBlLCBub2RlVHlwZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9ucztcbiAgICB9XG4gICAgcmVtb3ZlKHVyaSkge1xuICAgICAgICBjb25zdCB1cmlTdHJpbmcgPSB1cmkudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zeW1ib2xJbmRleC5kZWxldGUodXJpU3RyaW5nKTtcbiAgICAgICAgdGhpcy5zeW1ib2xCeVR5cGVJbmRleC5jbGVhcih1cmlTdHJpbmcpO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUluZGV4LmRlbGV0ZSh1cmlTdHJpbmcpO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVDb250ZW50KGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2N1bWVudC51cmkpO1xuICAgICAgICBjb25zdCBleHBvcnRzID0gYXdhaXQgc2VydmljZXMucmVmZXJlbmNlcy5TY29wZUNvbXB1dGF0aW9uLmNvbXB1dGVFeHBvcnRzKGRvY3VtZW50LCBjYW5jZWxUb2tlbik7XG4gICAgICAgIGNvbnN0IHVyaSA9IGRvY3VtZW50LnVyaS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnN5bWJvbEluZGV4LnNldCh1cmksIGV4cG9ydHMpO1xuICAgICAgICB0aGlzLnN5bWJvbEJ5VHlwZUluZGV4LmNsZWFyKHVyaSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVJlZmVyZW5jZXMoZG9jdW1lbnQsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGNvbnN0IGluZGV4RGF0YSA9IGF3YWl0IHNlcnZpY2VzLndvcmtzcGFjZS5SZWZlcmVuY2VEZXNjcmlwdGlvblByb3ZpZGVyLmNyZWF0ZURlc2NyaXB0aW9ucyhkb2N1bWVudCwgY2FuY2VsVG9rZW4pO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUluZGV4LnNldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSwgaW5kZXhEYXRhKTtcbiAgICB9XG4gICAgaXNBZmZlY3RlZChkb2N1bWVudCwgY2hhbmdlZFVyaXMpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlcyA9IHRoaXMucmVmZXJlbmNlSW5kZXguZ2V0KGRvY3VtZW50LnVyaS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKCFyZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZXMuc29tZShyZWYgPT4gIXJlZi5sb2NhbCAmJiBjaGFuZ2VkVXJpcy5oYXMocmVmLnRhcmdldFVyaS50b1N0cmluZygpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgtbWFuYWdlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCwgaW50ZXJydXB0QW5kQ2hlY2sgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IFVSSSwgVXJpVXRpbHMgfSBmcm9tICcuLi91dGlscy91cmktdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRXb3Jrc3BhY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmluaXRpYWxCdWlsZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUmVnaXN0cnkgPSBzZXJ2aWNlcy5TZXJ2aWNlUmVnaXN0cnk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLmRvY3VtZW50QnVpbGRlciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Eb2N1bWVudEJ1aWxkZXI7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbVByb3ZpZGVyID0gc2VydmljZXMud29ya3NwYWNlLkZpbGVTeXN0ZW1Qcm92aWRlcjtcbiAgICAgICAgdGhpcy5tdXRleCA9IHNlcnZpY2VzLndvcmtzcGFjZS5Xb3Jrc3BhY2VMb2NrO1xuICAgIH1cbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZm9sZGVycyA9IChfYSA9IHBhcmFtcy53b3Jrc3BhY2VGb2xkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGluaXRpYWxpemVkKF9wYXJhbXMpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgd29ya3NwYWNlIGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHdvcmtzcGFjZSBmb2xkZXJzXG4gICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gbG9hZCBhZGRpdGlvbmFsIGRvY3VtZW50cyAobGFuZ3VhZ2UgbGlicmFyeSBvciBzaW1pbGFyKSBkdXJpbmcgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMubXV0ZXgud3JpdGUodG9rZW4gPT4geyB2YXIgX2E7IHJldHVybiB0aGlzLmluaXRpYWxpemVXb3Jrc3BhY2UoKF9hID0gdGhpcy5mb2xkZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgdG9rZW4pOyB9KTtcbiAgICB9XG4gICAgYXN5bmMgaW5pdGlhbGl6ZVdvcmtzcGFjZShmb2xkZXJzLCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gYXdhaXQgdGhpcy5wZXJmb3JtU3RhcnR1cChmb2xkZXJzKTtcbiAgICAgICAgLy8gT25seSBhZnRlciBjcmVhdGluZyBhbGwgZG9jdW1lbnRzIGRvIHdlIGNoZWNrIHdoZXRoZXIgd2UgbmVlZCB0byBjYW5jZWwgdGhlIGluaXRpYWxpemF0aW9uXG4gICAgICAgIC8vIFRoZSBkb2N1bWVudCBidWlsZGVyIHdpbGwgbGF0ZXIgcGljayB1cCBvbiBhbGwgdW5wcm9jZXNzZWQgZG9jdW1lbnRzXG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgYXdhaXQgdGhpcy5kb2N1bWVudEJ1aWxkZXIuYnVpbGQoZG9jdW1lbnRzLCB0aGlzLmluaXRpYWxCdWlsZE9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHVuaW50ZXJydXB0YWJsZSBzdGFydHVwIHNlcXVlbmNlIG9mIHRoZSB3b3Jrc3BhY2UgbWFuYWdlci5cbiAgICAgKiBUaGlzIG1ldGhvZHMgbG9hZHMgYWxsIGRvY3VtZW50cyBpbiB0aGUgd29ya3NwYWNlIGFuZCBvdGhlciBkb2N1bWVudHMgYW5kIHJldHVybnMgdGhlbS5cbiAgICAgKi9cbiAgICBhc3luYyBwZXJmb3JtU3RhcnR1cChmb2xkZXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb25zID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuYWxsLmZsYXRNYXAoZSA9PiBlLkxhbmd1YWdlTWV0YURhdGEuZmlsZUV4dGVuc2lvbnMpO1xuICAgICAgICBjb25zdCBkb2N1bWVudHMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sbGVjdG9yID0gKGRvY3VtZW50KSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudHMucHVzaChkb2N1bWVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGFuZ2l1bURvY3VtZW50cy5oYXNEb2N1bWVudChkb2N1bWVudC51cmkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW5naXVtRG9jdW1lbnRzLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UgZG9uJ3QgYXdhaXQgdGhlIGluaXRpYWxpemF0aW9uIG9mIHRoZSB3b3Jrc3BhY2UgbWFuYWdlcixcbiAgICAgICAgLy8gd2UgY2FuIHN0aWxsIGFzc3VtZSB0aGF0IGFsbCBsaWJyYXJ5IGRvY3VtZW50cyBhbmQgZmlsZSBkb2N1bWVudHMgYXJlIGxvYWRlZCBieSB0aGUgdGltZSB3ZSBzdGFydCBidWlsZGluZyBkb2N1bWVudHMuXG4gICAgICAgIC8vIFRoZSBtdXRleCBwcmV2ZW50cyBhbnl0aGluZyBmcm9tIHBlcmZvcm1pbmcgYSB3b3Jrc3BhY2UgYnVpbGQgdW50aWwgd2UgY2hlY2sgdGhlIGNhbmNlbGxhdGlvbiB0b2tlblxuICAgICAgICBhd2FpdCB0aGlzLmxvYWRBZGRpdGlvbmFsRG9jdW1lbnRzKGZvbGRlcnMsIGNvbGxlY3Rvcik7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGZvbGRlcnMubWFwKHdmID0+IFt3ZiwgdGhpcy5nZXRSb290Rm9sZGVyKHdmKV0pXG4gICAgICAgICAgICAubWFwKGFzeW5jIChlbnRyeSkgPT4gdGhpcy50cmF2ZXJzZUZvbGRlciguLi5lbnRyeSwgZmlsZUV4dGVuc2lvbnMsIGNvbGxlY3RvcikpKTtcbiAgICAgICAgdGhpcy5fcmVhZHkucmVzb2x2ZSgpO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkIGFsbCBhZGRpdGlvbmFsIGRvY3VtZW50cyB0aGF0IHNoYWxsIGJlIHZpc2libGUgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGdpdmVuIHdvcmtzcGFjZVxuICAgICAqIGZvbGRlcnMgYW5kIGFkZCB0aGVtIHRvIHRoZSBjb2xsZWN0b3IuIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW5jbHVkZSBidWlsdC1pbiBsaWJyYXJpZXMgb2ZcbiAgICAgKiB5b3VyIGxhbmd1YWdlLCB3aGljaCBjYW4gYmUgZWl0aGVyIGxvYWRlZCBmcm9tIHByb3ZpZGVkIGZpbGVzIG9yIGNvbnN0cnVjdGVkIGluIG1lbW9yeS5cbiAgICAgKi9cbiAgICBsb2FkQWRkaXRpb25hbERvY3VtZW50cyhfZm9sZGVycywgX2NvbGxlY3Rvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgcm9vdCBmb2xkZXIgb2YgdGhlIHNvdXJjZSBkb2N1bWVudHMgaW4gdGhlIGdpdmVuIHdvcmtzcGFjZSBmb2xkZXIuXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0aGUgVVJJIG9mIHRoZSB3b3Jrc3BhY2UgZm9sZGVyLCBidXQgeW91IGNhbiBvdmVycmlkZVxuICAgICAqIHRoaXMgdG8gcmV0dXJuIGEgc3ViZm9sZGVyIGxpa2UgYHNyY2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXRSb290Rm9sZGVyKHdvcmtzcGFjZUZvbGRlcikge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHdvcmtzcGFjZUZvbGRlci51cmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSB0aGUgZmlsZSBzeXN0ZW0gZm9sZGVyIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIFVSSSBhbmQgaXRzIHN1YmZvbGRlcnMuIEFsbFxuICAgICAqIGNvbnRhaW5lZCBmaWxlcyB0aGF0IG1hdGNoIHRoZSBmaWxlIGV4dGVuc2lvbnMgYXJlIGFkZGVkIHRvIHRoZSBjb2xsZWN0b3IuXG4gICAgICovXG4gICAgYXN5bmMgdHJhdmVyc2VGb2xkZXIod29ya3NwYWNlRm9sZGVyLCBmb2xkZXJQYXRoLCBmaWxlRXh0ZW5zaW9ucywgY29sbGVjdG9yKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpbGVTeXN0ZW1Qcm92aWRlci5yZWFkRGlyZWN0b3J5KGZvbGRlclBhdGgpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjb250ZW50Lm1hcChhc3luYyAoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluY2x1ZGVFbnRyeSh3b3Jrc3BhY2VGb2xkZXIsIGVudHJ5LCBmaWxlRXh0ZW5zaW9ucykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy50cmF2ZXJzZUZvbGRlcih3b3Jrc3BhY2VGb2xkZXIsIGVudHJ5LnVyaSwgZmlsZUV4dGVuc2lvbnMsIGNvbGxlY3Rvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVudHJ5LmlzRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGF3YWl0IHRoaXMubGFuZ2l1bURvY3VtZW50cy5nZXRPckNyZWF0ZURvY3VtZW50KGVudHJ5LnVyaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvcihkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGV0aGVyIHRoZSBnaXZlbiBmb2xkZXIgZW50cnkgc2hhbGwgYmUgaW5jbHVkZWQgd2hpbGUgaW5kZXhpbmcgdGhlIHdvcmtzcGFjZS5cbiAgICAgKi9cbiAgICBpbmNsdWRlRW50cnkoX3dvcmtzcGFjZUZvbGRlciwgZW50cnksIGZpbGVFeHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBVcmlVdGlscy5iYXNlbmFtZShlbnRyeS51cmkpO1xuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCcuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lICE9PSAnbm9kZV9tb2R1bGVzJyAmJiBuYW1lICE9PSAnb3V0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dG5hbWUgPSBVcmlVdGlscy5leHRuYW1lKGVudHJ5LnVyaSk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZUV4dGVuc2lvbnMuaW5jbHVkZXMoZXh0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtzcGFjZS1tYW5hZ2VyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IExleGVyIGFzIENoZXZyb3RhaW5MZXhlciB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMZXhlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gc2VydmljZXMucGFyc2VyLlRva2VuQnVpbGRlci5idWlsZFRva2VucyhzZXJ2aWNlcy5HcmFtbWFyLCB7XG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IHNlcnZpY2VzLkxhbmd1YWdlTWV0YURhdGEuY2FzZUluc2Vuc2l0aXZlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRva2VuVHlwZXMgPSB0aGlzLnRvVG9rZW5UeXBlRGljdGlvbmFyeSh0b2tlbnMpO1xuICAgICAgICBjb25zdCBsZXhlclRva2VucyA9IGlzVG9rZW5UeXBlRGljdGlvbmFyeSh0b2tlbnMpID8gT2JqZWN0LnZhbHVlcyh0b2tlbnMpIDogdG9rZW5zO1xuICAgICAgICB0aGlzLmNoZXZyb3RhaW5MZXhlciA9IG5ldyBDaGV2cm90YWluTGV4ZXIobGV4ZXJUb2tlbnMsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVHJhY2tpbmc6ICdmdWxsJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuVHlwZXM7XG4gICAgfVxuICAgIHRva2VuaXplKHRleHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjaGV2cm90YWluUmVzdWx0ID0gdGhpcy5jaGV2cm90YWluTGV4ZXIudG9rZW5pemUodGV4dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IGNoZXZyb3RhaW5SZXN1bHQudG9rZW5zLFxuICAgICAgICAgICAgZXJyb3JzOiBjaGV2cm90YWluUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIGhpZGRlbjogKF9hID0gY2hldnJvdGFpblJlc3VsdC5ncm91cHMuaGlkZGVuKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1Rva2VuVHlwZURpY3Rpb25hcnkoYnVpbGRUb2tlbnMpIHtcbiAgICAgICAgaWYgKGlzVG9rZW5UeXBlRGljdGlvbmFyeShidWlsZFRva2VucykpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRUb2tlbnM7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGlzSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvbihidWlsZFRva2VucykgPyBPYmplY3QudmFsdWVzKGJ1aWxkVG9rZW5zLm1vZGVzKS5mbGF0KCkgOiBidWlsZFRva2VucztcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHJlc1t0b2tlbi5uYW1lXSA9IHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgVG9rZW5UeXBlIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuVHlwZUFycmF5KHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRva2VuVm9jYWJ1bGFyeSkgJiYgKHRva2VuVm9jYWJ1bGFyeS5sZW5ndGggPT09IDAgfHwgJ25hbWUnIGluIHRva2VuVm9jYWJ1bGFyeVswXSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uKHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiB0b2tlblZvY2FidWxhcnkgJiYgJ21vZGVzJyBpbiB0b2tlblZvY2FidWxhcnkgJiYgJ2RlZmF1bHRNb2RlJyBpbiB0b2tlblZvY2FidWxhcnk7XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgVG9rZW5UeXBlRGljdGlvbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGVEaWN0aW9uYXJ5KHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiAhaXNUb2tlblR5cGVBcnJheSh0b2tlblZvY2FidWxhcnkpICYmICFpc0lNdWx0aU1vZGVMZXhlckRlZmluaXRpb24odG9rZW5Wb2NhYnVsYXJ5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFBvc2l0aW9uLCBSYW5nZSB9IGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcyc7XG5pbXBvcnQgeyBORVdMSU5FX1JFR0VYUCwgZXNjYXBlUmVnRXhwIH0gZnJvbSAnLi4vdXRpbHMvcmVnZXhwLXV0aWxzLmpzJztcbmltcG9ydCB7IFVSSSB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VKU0RvYyhub2RlLCBzdGFydCwgb3B0aW9ucykge1xuICAgIGxldCBvcHRzO1xuICAgIGxldCBwb3NpdGlvbjtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBvc2l0aW9uID0gc3RhcnQ7XG4gICAgICAgIG9wdHMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9zaXRpb24gPSBub2RlLnJhbmdlLnN0YXJ0O1xuICAgICAgICBvcHRzID0gc3RhcnQ7XG4gICAgfVxuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBQb3NpdGlvbi5jcmVhdGUoMCwgMCk7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gZ2V0TGluZXMobm9kZSk7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdHMpO1xuICAgIGNvbnN0IHRva2VucyA9IHRva2VuaXplKHtcbiAgICAgICAgbGluZXMsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBvcHRpb25zOiBub3JtYWxpemVkT3B0aW9uc1xuICAgIH0pO1xuICAgIHJldHVybiBwYXJzZUpTRG9jQ29tbWVudCh7XG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNKU0RvYyhub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZE9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpbmVzID0gZ2V0TGluZXMobm9kZSk7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gbGluZXNbMF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGZpcnN0UmVnZXggPSBub3JtYWxpemVkT3B0aW9ucy5zdGFydDtcbiAgICBjb25zdCBsYXN0UmVnZXggPSBub3JtYWxpemVkT3B0aW9ucy5lbmQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oZmlyc3RSZWdleCA9PT0gbnVsbCB8fCBmaXJzdFJlZ2V4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXJzdFJlZ2V4LmV4ZWMoZmlyc3QpKSAmJiBCb29sZWFuKGxhc3RSZWdleCA9PT0gbnVsbCB8fCBsYXN0UmVnZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3RSZWdleC5leGVjKGxhc3QpKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVzKG5vZGUpIHtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGVudCA9IG5vZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb250ZW50ID0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoTkVXTElORV9SRUdFWFApO1xuICAgIHJldHVybiBsaW5lcztcbn1cbmNvbnN0IHRhZ1JlZ2V4ID0gL1xccyooQChbXFxwe0x9XVtcXHB7TH1cXHB7Tn1dKik/KS91eTtcbmNvbnN0IGlubGluZVRhZ1JlZ2V4ID0gL1xceyhAW1xccHtMfV1bXFxwe0x9XFxwe059XSopKFxccyopKFteXFxyXFxufV0rKT9cXH0vZ3U7XG5mdW5jdGlvbiB0b2tlbml6ZShjb250ZXh0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgbGV0IGN1cnJlbnRMaW5lID0gY29udGV4dC5wb3NpdGlvbi5saW5lO1xuICAgIGxldCBjdXJyZW50Q2hhcmFjdGVyID0gY29udGV4dC5wb3NpdGlvbi5jaGFyYWN0ZXI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250ZXh0LmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gaSA9PT0gMDtcbiAgICAgICAgY29uc3QgbGFzdCA9IGkgPT09IGNvbnRleHQubGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgbGV0IGxpbmUgPSBjb250ZXh0LmxpbmVzW2ldO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBpZiAoZmlyc3QgJiYgY29udGV4dC5vcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IChfYSA9IGNvbnRleHQub3B0aW9ucy5zdGFydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSAoX2IgPSBjb250ZXh0Lm9wdGlvbnMubGluZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IChfYyA9IGNvbnRleHQub3B0aW9ucy5lbmQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5leGVjKGxpbmUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc3Vic3RyaW5nKDAsIG1hdGNoLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGFzdENoYXJhY3RlcihsaW5lKSk7XG4gICAgICAgIGNvbnN0IHdoaXRlc3BhY2VFbmQgPSBza2lwV2hpdGVzcGFjZShsaW5lLCBpbmRleCk7XG4gICAgICAgIGlmICh3aGl0ZXNwYWNlRW5kID49IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIGJyZWFrIHRva2VuIHdoZW4gd2UgYWxyZWFkeSBoYXZlIHByZXZpb3VzIHRva2Vuc1xuICAgICAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBQb3NpdGlvbi5jcmVhdGUoY3VycmVudExpbmUsIGN1cnJlbnRDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2JyZWFrJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUocG9zaXRpb24sIHBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnUmVnZXgubGFzdEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCB0YWdNYXRjaCA9IHRhZ1JlZ2V4LmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAodGFnTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSB0YWdNYXRjaFswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRhZ01hdGNoWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gUG9zaXRpb24uY3JlYXRlKGN1cnJlbnRMaW5lLCBjdXJyZW50Q2hhcmFjdGVyICsgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IFBvc2l0aW9uLmNyZWF0ZShjdXJyZW50TGluZSwgY3VycmVudENoYXJhY3RlciArIGluZGV4ICsgZnVsbE1hdGNoLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGFnJyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoc3RhcnQsIGVuZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSBmdWxsTWF0Y2gubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2tpcFdoaXRlc3BhY2UobGluZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4IDwgbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gbGluZS5zdWJzdHJpbmcoaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubGluZVRhZ01hdGNoZXMgPSBBcnJheS5mcm9tKHJlc3QubWF0Y2hBbGwoaW5saW5lVGFnUmVnZXgpKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCguLi5idWlsZElubGluZVRva2VucyhpbmxpbmVUYWdNYXRjaGVzLCByZXN0LCBjdXJyZW50TGluZSwgY3VycmVudENoYXJhY3RlciArIGluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudExpbmUrKztcbiAgICAgICAgY3VycmVudENoYXJhY3RlciA9IDA7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBsYXN0IGJyZWFrIHRva2VuIGlmIHRoZXJlIGlzIG9uZVxuICAgIGlmICh0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdLnR5cGUgPT09ICdicmVhaycpIHtcbiAgICAgICAgcmV0dXJuIHRva2Vucy5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbnM7XG59XG5mdW5jdGlvbiBidWlsZElubGluZVRva2Vucyh0YWdzLCBsaW5lLCBsaW5lSW5kZXgsIGNoYXJhY3RlckluZGV4KSB7XG4gICAgY29uc3QgdG9rZW5zID0gW107XG4gICAgaWYgKHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgY2hhcmFjdGVySW5kZXgpO1xuICAgICAgICBjb25zdCBlbmQgPSBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBjaGFyYWN0ZXJJbmRleCArIGxpbmUubGVuZ3RoKTtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgY29udGVudDogbGluZSxcbiAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoc3RhcnQsIGVuZClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiB0YWdzKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaEluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBzdGFydENvbnRlbnQgPSBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoSW5kZXgpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hJbmRleCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBtYXRjaEluZGV4ICsgY2hhcmFjdGVySW5kZXgpKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0Q29udGVudC5sZW5ndGggKyAxO1xuICAgICAgICAgICAgY29uc3QgdGFnTmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdpbmxpbmUtdGFnJyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyB0YWdOYW1lLmxlbmd0aCArIGNoYXJhY3RlckluZGV4KSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRhZ05hbWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBtYXRjaFsyXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaFszXTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyB2YWx1ZS5sZW5ndGggKyBjaGFyYWN0ZXJJbmRleCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBSYW5nZS5jcmVhdGUoUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgb2Zmc2V0ICsgY2hhcmFjdGVySW5kZXgpLCBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyBjaGFyYWN0ZXJJbmRleCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaEluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuZENvbnRlbnQgPSBsaW5lLnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICBpZiAoZW5kQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGVuZENvbnRlbnQsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIGNoYXJhY3RlckluZGV4ICsgZW5kQ29udGVudC5sZW5ndGgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbmNvbnN0IG5vbldoaXRlc3BhY2VSZWdleCA9IC9cXFMvO1xuY29uc3Qgd2hpdGVzcGFjZUVuZFJlZ2V4ID0gL1xccyokLztcbmZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKGxpbmUsIGluZGV4KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLnN1YnN0cmluZyhpbmRleCkubWF0Y2gobm9uV2hpdGVzcGFjZVJlZ2V4KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ICsgbWF0Y2guaW5kZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbGluZS5sZW5ndGg7XG4gICAgfVxufVxuZnVuY3Rpb24gbGFzdENoYXJhY3RlcihsaW5lKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKHdoaXRlc3BhY2VFbmRSZWdleCk7XG4gICAgaWYgKG1hdGNoICYmIHR5cGVvZiBtYXRjaC5pbmRleCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmluZGV4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gUGFyc2luZ1xuZnVuY3Rpb24gcGFyc2VKU0RvY0NvbW1lbnQoY29udGV4dCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gUG9zaXRpb24uY3JlYXRlKGNvbnRleHQucG9zaXRpb24ubGluZSwgY29udGV4dC5wb3NpdGlvbi5jaGFyYWN0ZXIpO1xuICAgIGlmIChjb250ZXh0LnRva2Vucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKU0RvY0NvbW1lbnRJbXBsKFtdLCBSYW5nZS5jcmVhdGUoc3RhcnRQb3NpdGlvbiwgc3RhcnRQb3NpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgIHdoaWxlIChjb250ZXh0LmluZGV4IDwgY29udGV4dC50b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBwYXJzZUpTRG9jRWxlbWVudChjb250ZXh0LCBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gKF9iID0gKF9hID0gZWxlbWVudHNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yYW5nZS5zdGFydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogc3RhcnRQb3NpdGlvbjtcbiAgICBjb25zdCBlbmQgPSAoX2QgPSAoX2MgPSBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJhbmdlLmVuZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogc3RhcnRQb3NpdGlvbjtcbiAgICByZXR1cm4gbmV3IEpTRG9jQ29tbWVudEltcGwoZWxlbWVudHMsIFJhbmdlLmNyZWF0ZShzdGFydCwgZW5kKSk7XG59XG5mdW5jdGlvbiBwYXJzZUpTRG9jRWxlbWVudChjb250ZXh0LCBsYXN0KSB7XG4gICAgY29uc3QgbmV4dCA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGlmIChuZXh0LnR5cGUgPT09ICd0YWcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUpTRG9jVGFnKGNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV4dC50eXBlID09PSAndGV4dCcgfHwgbmV4dC50eXBlID09PSAnaW5saW5lLXRhZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NUZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXBwZW5kRW1wdHlMaW5lKG5leHQsIGxhc3QpO1xuICAgICAgICBjb250ZXh0LmluZGV4Kys7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kRW1wdHlMaW5lKHRva2VuLCBlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgbGluZSA9IG5ldyBKU0RvY0xpbmVJbXBsKCcnLCB0b2tlbi5yYW5nZSk7XG4gICAgICAgIGlmICgnaW5saW5lcycgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudC5pbmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LmNvbnRlbnQuaW5saW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VKU0RvY1RleHQoY29udGV4dCkge1xuICAgIGxldCB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGNvbnN0IGZpcnN0VG9rZW4gPSB0b2tlbjtcbiAgICBsZXQgbGFzdFRva2VuID0gdG9rZW47XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICB3aGlsZSAodG9rZW4gJiYgdG9rZW4udHlwZSAhPT0gJ2JyZWFrJyAmJiB0b2tlbi50eXBlICE9PSAndGFnJykge1xuICAgICAgICBsaW5lcy5wdXNoKHBhcnNlSlNEb2NJbmxpbmUoY29udGV4dCkpO1xuICAgICAgICBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBKU0RvY1RleHRJbXBsKGxpbmVzLCBSYW5nZS5jcmVhdGUoZmlyc3RUb2tlbi5yYW5nZS5zdGFydCwgbGFzdFRva2VuLnJhbmdlLmVuZCkpO1xufVxuZnVuY3Rpb24gcGFyc2VKU0RvY0lubGluZShjb250ZXh0KSB7XG4gICAgY29uc3QgdG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2lubGluZS10YWcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUpTRG9jVGFnKGNvbnRleHQsIHRydWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NMaW5lKGNvbnRleHQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSlNEb2NUYWcoY29udGV4dCwgaW5saW5lKSB7XG4gICAgY29uc3QgdGFnVG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4KytdO1xuICAgIGNvbnN0IG5hbWUgPSB0YWdUb2tlbi5jb250ZW50LnN1YnN0cmluZygxKTtcbiAgICBjb25zdCBuZXh0VG9rZW4gPSBjb250ZXh0LnRva2Vuc1tjb250ZXh0LmluZGV4XTtcbiAgICBpZiAoKG5leHRUb2tlbiA9PT0gbnVsbCB8fCBuZXh0VG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5leHRUb2tlbi50eXBlKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY0xpbmUgPSBwYXJzZUpTRG9jTGluZShjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSlNEb2NUYWdJbXBsKG5hbWUsIG5ldyBKU0RvY1RleHRJbXBsKFtkb2NMaW5lXSwgZG9jTGluZS5yYW5nZSksIGlubGluZSwgUmFuZ2UuY3JlYXRlKHRhZ1Rva2VuLnJhbmdlLnN0YXJ0LCBkb2NMaW5lLnJhbmdlLmVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dERvYyA9IHBhcnNlSlNEb2NUZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU0RvY1RhZ0ltcGwobmFtZSwgdGV4dERvYywgaW5saW5lLCBSYW5nZS5jcmVhdGUodGFnVG9rZW4ucmFuZ2Uuc3RhcnQsIHRleHREb2MucmFuZ2UuZW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gdGFnVG9rZW4ucmFuZ2U7XG4gICAgICAgIHJldHVybiBuZXcgSlNEb2NUYWdJbXBsKG5hbWUsIG5ldyBKU0RvY1RleHRJbXBsKFtdLCByYW5nZSksIGlubGluZSwgcmFuZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlSlNEb2NMaW5lKGNvbnRleHQpIHtcbiAgICBjb25zdCB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXgrK107XG4gICAgcmV0dXJuIG5ldyBKU0RvY0xpbmVJbXBsKHRva2VuLmNvbnRlbnQsIHRva2VuLnJhbmdlKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplT3B0aW9ucyh7XG4gICAgICAgICAgICBzdGFydDogJy8qKicsXG4gICAgICAgICAgICBlbmQ6ICcqLycsXG4gICAgICAgICAgICBsaW5lOiAnKidcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCwgbGluZSB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogbm9ybWFsaXplT3B0aW9uKHN0YXJ0LCB0cnVlKSxcbiAgICAgICAgZW5kOiBub3JtYWxpemVPcHRpb24oZW5kLCBmYWxzZSksXG4gICAgICAgIGxpbmU6IG5vcm1hbGl6ZU9wdGlvbihsaW5lLCB0cnVlKVxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb24ob3B0aW9uLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygb3B0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBlc2NhcGVkID0gdHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgPyBlc2NhcGVSZWdFeHAob3B0aW9uKSA6IG9wdGlvbi5zb3VyY2U7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5cXFxccyoke2VzY2FwZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXFxcXHMqJHtlc2NhcGVkfVxcXFxzKiRgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG59XG5jbGFzcyBKU0RvY0NvbW1lbnRJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cywgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIGdldFRhZyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRhZ3MoKS5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICB9XG4gICAgZ2V0VGFncyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbFRhZ3MoKS5maWx0ZXIoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgIH1cbiAgICBnZXRBbGxUYWdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5maWx0ZXIoKGUpID0+ICduYW1lJyBpbiBlKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5lbGVtZW50cykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZWxlbWVudC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGVsZW1lbnQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSBmaWxsTmV3bGluZXModmFsdWUpICsgdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICAgIH1cbiAgICB0b01hcmtkb3duKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50LnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWxlbWVudC50b01hcmtkb3duKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGZpbGxOZXdsaW5lcyh2YWx1ZSkgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NUYWdJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBjb250ZW50LCBpbmxpbmUsIHJhbmdlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuaW5saW5lID0gaW5saW5lO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgdGV4dCA9IGBAJHt0aGlzLm5hbWV9YDtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYCR7dGV4dH0gJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9XFxuJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgdGFncyBhcmUgc3Vycm91bmRlZCBieSBjdXJseSBicmFjZXNcbiAgICAgICAgICAgIHJldHVybiBgeyR7dGV4dH19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvTWFya2Rvd24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlbmRlclRhZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgdGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMudG9NYXJrZG93bkRlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHRvTWFya2Rvd25EZWZhdWx0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXMuY29udGVudC50b01hcmtkb3duKG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkID0gcmVuZGVySW5saW5lVGFnKHRoaXMubmFtZSwgY29udGVudCwgb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZW5kZXJlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hcmtlciA9ICcnO1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50YWcpID09PSAnaXRhbGljJyB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRhZykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbWFya2VyID0gJyonO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGFnKSA9PT0gJ2JvbGQnKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSAnKionO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGFnKSA9PT0gJ2JvbGQtaXRhbGljJykge1xuICAgICAgICAgICAgbWFya2VyID0gJyoqKic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSBgJHttYXJrZXJ9QCR7dGhpcy5uYW1lfSR7bWFya2VyfWA7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaW5saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRleHQgPSBgJHt0ZXh0fSDigJQgJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50LmlubGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9XFxuJHtjb250ZW50fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICAvLyBJbmxpbmUgdGFncyBhcmUgc3Vycm91bmRlZCBieSBjdXJseSBicmFjZXNcbiAgICAgICAgICAgIHJldHVybiBgeyR7dGV4dH19YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcmVuZGVySW5saW5lVGFnKHRhZywgY29udGVudCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKHRhZyA9PT0gJ2xpbmtwbGFpbicgfHwgdGFnID09PSAnbGlua2NvZGUnIHx8IHRhZyA9PT0gJ2xpbmsnKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29udGVudC5pbmRleE9mKCcgJyk7XG4gICAgICAgIGxldCBkaXNwbGF5ID0gY29udGVudDtcbiAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGlzcGxheVN0YXJ0ID0gc2tpcFdoaXRlc3BhY2UoY29udGVudCwgaW5kZXgpO1xuICAgICAgICAgICAgZGlzcGxheSA9IGNvbnRlbnQuc3Vic3RyaW5nKGRpc3BsYXlTdGFydCk7XG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09ICdsaW5rY29kZScgfHwgKHRhZyA9PT0gJ2xpbmsnICYmIG9wdGlvbnMubGluayA9PT0gJ2NvZGUnKSkge1xuICAgICAgICAgICAgLy8gU3Vycm91bmQgdGhlIGRpc3BsYXkgdmFsdWUgaW4gYSBtYXJrZG93biBpbmxpbmUgY29kZSBibG9ja1xuICAgICAgICAgICAgZGlzcGxheSA9IGBcXGAke2Rpc3BsYXl9XFxgYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJlZExpbmsgPSAoX2IgPSAoX2EgPSBvcHRpb25zLnJlbmRlckxpbmspID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGNvbnRlbnQsIGRpc3BsYXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiByZW5kZXJMaW5rRGVmYXVsdChjb250ZW50LCBkaXNwbGF5KTtcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkTGluaztcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlbmRlckxpbmtEZWZhdWx0KGNvbnRlbnQsIGRpc3BsYXkpIHtcbiAgICB0cnkge1xuICAgICAgICBVUkkucGFyc2UoY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBgWyR7ZGlzcGxheX1dKCR7Y29udGVudH0pYDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbn1cbmNsYXNzIEpTRG9jVGV4dEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVzLCByYW5nZSkge1xuICAgICAgICB0aGlzLmlubGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IHRoaXMuaW5saW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlubGluZXNbaSArIDFdO1xuICAgICAgICAgICAgdGV4dCArPSBpbmxpbmUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQucmFuZ2Uuc3RhcnQubGluZSA+IGlubGluZS5yYW5nZS5zdGFydC5saW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgdG9NYXJrZG93bihvcHRpb25zKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmxpbmUgPSB0aGlzLmlubGluZXNbaV07XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5pbmxpbmVzW2kgKyAxXTtcbiAgICAgICAgICAgIHRleHQgKz0gaW5saW5lLnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0LnJhbmdlLnN0YXJ0LmxpbmUgPiBpbmxpbmUucmFuZ2Uuc3RhcnQubGluZSkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NMaW5lSW1wbCB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG4gICAgdG9NYXJrZG93bigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaWxsTmV3bGluZXModGV4dCkge1xuICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXG4nKSkge1xuICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gJ1xcblxcbic7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNkb2MuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNKU0RvYywgcGFyc2VKU0RvYyB9IGZyb20gJy4vanNkb2MuanMnO1xuZXhwb3J0IGNsYXNzIEpTRG9jRG9jdW1lbnRhdGlvblByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuSW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLmNvbW1lbnRQcm92aWRlciA9IHNlcnZpY2VzLmRvY3VtZW50YXRpb24uQ29tbWVudFByb3ZpZGVyO1xuICAgIH1cbiAgICBnZXREb2N1bWVudGF0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuY29tbWVudFByb3ZpZGVyLmdldENvbW1lbnQobm9kZSk7XG4gICAgICAgIGlmIChjb21tZW50ICYmIGlzSlNEb2MoY29tbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEpTRG9jID0gcGFyc2VKU0RvYyhjb21tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKU0RvYy50b01hcmtkb3duKHtcbiAgICAgICAgICAgICAgICByZW5kZXJMaW5rOiAobGluaywgZGlzcGxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudGF0aW9uTGlua1JlbmRlcmVyKG5vZGUsIGxpbmssIGRpc3BsYXkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFnOiAodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50YXRpb25UYWdSZW5kZXJlcihub2RlLCB0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRvY3VtZW50YXRpb25MaW5rUmVuZGVyZXIobm9kZSwgbmFtZSwgZGlzcGxheSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKF9hID0gdGhpcy5maW5kTmFtZUluUHJlY29tcHV0ZWRTY29wZXMobm9kZSwgbmFtZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZmluZE5hbWVJbkdsb2JhbFNjb3BlKG5vZGUsIG5hbWUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gJiYgZGVzY3JpcHRpb24ubmFtZVNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkZXNjcmlwdGlvbi5uYW1lU2VnbWVudC5yYW5nZS5zdGFydC5saW5lICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGRlc2NyaXB0aW9uLm5hbWVTZWdtZW50LnJhbmdlLnN0YXJ0LmNoYXJhY3RlciArIDE7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBkZXNjcmlwdGlvbi5kb2N1bWVudFVyaS53aXRoKHsgZnJhZ21lbnQ6IGBMJHtsaW5lfSwke2NoYXJhY3Rlcn1gIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBbJHtkaXNwbGF5fV0oJHt1cmkudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnRhdGlvblRhZ1JlbmRlcmVyKF9ub2RlLCBfdGFnKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB0YWcgcmVuZGVyaW5nXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmROYW1lSW5QcmVjb21wdXRlZFNjb3Blcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgICAgIGNvbnN0IHByZWNvbXB1dGVkID0gZG9jdW1lbnQucHJlY29tcHV0ZWRTY29wZXM7XG4gICAgICAgIGlmICghcHJlY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYWxsRGVzY3JpcHRpb25zID0gcHJlY29tcHV0ZWQuZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYWxsRGVzY3JpcHRpb25zLmZpbmQoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS4kY29udGFpbmVyO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmROYW1lSW5HbG9iYWxTY29wZShub2RlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5pbmRleE1hbmFnZXIuYWxsRWxlbWVudHMoKS5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50YXRpb24tcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgaXNBc3ROb2RlV2l0aENvbW1lbnQgfSBmcm9tICcuLi9zZXJpYWxpemVyL2pzb24tc2VyaWFsaXplci5qcyc7XG5pbXBvcnQgeyBmaW5kQ29tbWVudE5vZGUgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRDb21tZW50UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZ3JhbW1hckNvbmZpZyA9ICgpID0+IHNlcnZpY2VzLnBhcnNlci5HcmFtbWFyQ29uZmlnO1xuICAgIH1cbiAgICBnZXRDb21tZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoaXNBc3ROb2RlV2l0aENvbW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLiRjb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2EgPSBmaW5kQ29tbWVudE5vZGUobm9kZS4kY3N0Tm9kZSwgdGhpcy5ncmFtbWFyQ29uZmlnKCkubXVsdGlsaW5lQ29tbWVudFJ1bGVzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRleHQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWVudC1wcm92aWRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyNCBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1pbXBvcnRzXG5leHBvcnQgKiBmcm9tICd2c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL2V2ZW50cy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBEZWZlcnJlZCwgT3BlcmF0aW9uQ2FuY2VsbGVkIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbHMvZXZlbnQuanMnO1xuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBhc3luYyBwYXJzZXIuIFRoaXMgaW1wbGVtZW50YXRpb24gb25seSB3cmFwcyB0aGUgc3luYyBwYXJzZXIgaW4gYSBwcm9taXNlLlxuICpcbiAqIEEgcmVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBjcmVhdGUgd29ya2VyIHRocmVhZHMgb3Igd2ViIHdvcmtlcnMgdG8gb2ZmbG9hZCB0aGUgcGFyc2luZyB3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdEFzeW5jUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLnN5bmNQYXJzZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGFuZ2l1bVBhcnNlcjtcbiAgICB9XG4gICAgcGFyc2UodGV4dCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc3luY1BhcnNlci5wYXJzZSh0ZXh0KSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0VGhyZWFkZWRBc3luY1BhcnNlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aHJlYWQgY291bnQgZGV0ZXJtaW5lcyBob3cgbWFueSB0aHJlYWRzIGFyZSB1c2VkIHRvIHBhcnNlIGZpbGVzIGluIHBhcmFsbGVsLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA4LiBEZWNyZWFzaW5nIHRoaXMgdmFsdWUgaW5jcmVhc2VzIHN0YXJ0dXAgcGVyZm9ybWFuY2UsIGJ1dCBkZWNyZWFzZXMgcGFyYWxsZWwgcGFyc2luZyBwZXJmb3JtYW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhyZWFkQ291bnQgPSA4O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRlcm1pbmF0aW9uIGRlbGF5IGRldGVybWluZXMgaG93IGxvbmcgdGhlIHBhcnNlciB3YWl0cyBmb3IgYSB0aHJlYWQgdG8gZmluaXNoIGFmdGVyIGEgY2FuY2VsbGF0aW9uIHJlcXVlc3QuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDIwMChtcykuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRlcm1pbmF0aW9uRGVsYXkgPSAyMDA7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbCA9IFtdO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuaHlkcmF0b3IgPSBzZXJ2aWNlcy5zZXJpYWxpemVyLkh5ZHJhdG9yO1xuICAgIH1cbiAgICBpbml0aWFsaXplV29ya2VycygpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMud29ya2VyUG9vbC5sZW5ndGggPCB0aGlzLnRocmVhZENvdW50KSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXIgPSB0aGlzLmNyZWF0ZVdvcmtlcigpO1xuICAgICAgICAgICAgd29ya2VyLm9uUmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUod29ya2VyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53b3JrZXJQb29sLnB1c2god29ya2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwYXJzZSh0ZXh0LCBjYW5jZWxUb2tlbikge1xuICAgICAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCB0aGlzLmFjcXVpcmVQYXJzZXJXb3JrZXIoY2FuY2VsVG9rZW4pO1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBsZXQgdGltZW91dDtcbiAgICAgICAgLy8gSWYgdGhlIGNhbmNlbGxhdGlvbiB0b2tlbiBpcyByZXF1ZXN0ZWQsIHdlIHdhaXQgZm9yIGEgY2VydGFpbiB0aW1lIGJlZm9yZSB0ZXJtaW5hdGluZyB0aGUgd29ya2VyLlxuICAgICAgICAvLyBTaW5jZSB0aGUgY2FuY2VsbGF0aW9uIHRva2VuIGxpdmVzIGxvbmdlciB0aGFuIHRoZSBwYXJzaW5nIHByb2Nlc3MsIHdlIG5lZWQgdG8gZGlzcG9zZSB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgd2UgbWlnaHQgYWNjaWRlbnRhbGx5IHRlcm1pbmF0ZSB0aGUgd29ya2VyIGFmdGVyIHRoZSBwYXJzaW5nIHByb2Nlc3MgaGFzIGZpbmlzaGVkLlxuICAgICAgICBjb25zdCBjYW5jZWxsYXRpb24gPSBjYW5jZWxUb2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVXb3JrZXIod29ya2VyKTtcbiAgICAgICAgICAgIH0sIHRoaXMudGVybWluYXRpb25EZWxheSk7XG4gICAgICAgIH0pO1xuICAgICAgICB3b3JrZXIucGFyc2UodGV4dCkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaHlkcmF0ZWQgPSB0aGlzLmh5ZHJhdG9yLmh5ZHJhdGUocmVzdWx0KTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoaHlkcmF0ZWQpO1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgY2FuY2VsbGF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbiAgICB0ZXJtaW5hdGVXb3JrZXIod29ya2VyKSB7XG4gICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLndvcmtlclBvb2wuaW5kZXhPZih3b3JrZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy53b3JrZXJQb29sLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgYWNxdWlyZVBhcnNlcldvcmtlcihjYW5jZWxUb2tlbikge1xuICAgICAgICB0aGlzLmluaXRpYWxpemVXb3JrZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qgd29ya2VyIG9mIHRoaXMud29ya2VyUG9vbCkge1xuICAgICAgICAgICAgaWYgKHdvcmtlci5yZWFkeSkge1xuICAgICAgICAgICAgICAgIHdvcmtlci5sb2NrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBjYW5jZWxUb2tlbi5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuaW5kZXhPZihkZWZlcnJlZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdChPcGVyYXRpb25DYW5jZWxsZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBhcnNlcldvcmtlciB7XG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG4gICAgfVxuICAgIGdldCBvblJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblJlYWR5RW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VuZE1lc3NhZ2UsIG9uTWVzc2FnZSwgb25FcnJvciwgdGVybWluYXRlKSB7XG4gICAgICAgIHRoaXMub25SZWFkeUVtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGFyc2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZSA9IHRlcm1pbmF0ZTtcbiAgICAgICAgb25NZXNzYWdlKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShwYXJzZVJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLnVubG9jaygpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25FcnJvcihlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnVubG9jaygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGVybWluYXRlKCkge1xuICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChPcGVyYXRpb25DYW5jZWxsZWQpO1xuICAgICAgICB0aGlzLl90ZXJtaW5hdGUoKTtcbiAgICB9XG4gICAgbG9jaygpIHtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgdW5sb2NrKCkge1xuICAgICAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vblJlYWR5RW1pdHRlci5maXJlKCk7XG4gICAgfVxuICAgIHBhcnNlKHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2VyIHdvcmtlciBpcyBidXN5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy1wYXJzZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4sIENhbmNlbGxhdGlvblRva2VuU291cmNlIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IERlZmVycmVkLCBpc09wZXJhdGlvbkNhbmNlbGxlZCB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRXb3Jrc3BhY2VMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Rva2VuU291cmNlID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH1cbiAgICB3cml0ZShhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYW5jZWxXcml0ZSgpO1xuICAgICAgICBjb25zdCB0b2tlblNvdXJjZSA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgICAgICB0aGlzLnByZXZpb3VzVG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZSh0aGlzLndyaXRlUXVldWUsIGFjdGlvbiwgdG9rZW5Tb3VyY2UudG9rZW4pO1xuICAgIH1cbiAgICByZWFkKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlKHRoaXMucmVhZFF1ZXVlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBlbnF1ZXVlKHF1ZXVlLCBhY3Rpb24sIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgZGVmZXJyZWQsXG4gICAgICAgICAgICBjYW5jZWxsYXRpb25Ub2tlbjogY2FuY2VsbGF0aW9uVG9rZW4gIT09IG51bGwgJiYgY2FuY2VsbGF0aW9uVG9rZW4gIT09IHZvaWQgMCA/IGNhbmNlbGxhdGlvblRva2VuIDogQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZVxuICAgICAgICB9O1xuICAgICAgICBxdWV1ZS5wdXNoKGVudHJ5KTtcbiAgICAgICAgdGhpcy5wZXJmb3JtTmV4dE9wZXJhdGlvbigpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgcGVyZm9ybU5leHRPcGVyYXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy53cml0ZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEp1c3QgcGVyZm9ybSB0aGUgbmV4dCB3cml0ZSBhY3Rpb25cbiAgICAgICAgICAgIGVudHJpZXMucHVzaCh0aGlzLndyaXRlUXVldWUuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yZWFkUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gRW1wdHkgdGhlIHJlYWQgcXVldWUgYW5kIHBlcmZvcm0gYWxsIGFjdGlvbnMgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIGVudHJpZXMucHVzaCguLi50aGlzLnJlYWRRdWV1ZS5zcGxpY2UoMCwgdGhpcy5yZWFkUXVldWUubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGVudHJpZXMubWFwKGFzeW5jICh7IGFjdGlvbiwgZGVmZXJyZWQsIGNhbmNlbGxhdGlvblRva2VuIH0pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0aGUgZXhlY3V0aW9uIG9mIHRoZSBhY3Rpb24gdG8gdGhlIG5leHQgZXZlbnQgbG9vcCB0aWNrIHZpYSBgUHJvbWlzZS5yZXNvbHZlKClgXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBhY3Rpb24oY2FuY2VsbGF0aW9uVG9rZW4pKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9wZXJhdGlvbiB3YXMgY2FuY2VsbGVkLCB3ZSBkb24ndCB3YW50IHRvIHJlamVjdCB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wZXJmb3JtTmV4dE9wZXJhdGlvbigpO1xuICAgIH1cbiAgICBjYW5jZWxXcml0ZSgpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Rva2VuU291cmNlLmNhbmNlbCgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtzcGFjZS1sb2NrLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDI0IFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENvbXBvc2l0ZUNzdE5vZGVJbXBsLCBMZWFmQ3N0Tm9kZUltcGwsIFJvb3RDc3ROb2RlSW1wbCB9IGZyb20gJy4uL3BhcnNlci9jc3Qtbm9kZS1idWlsZGVyLmpzJztcbmltcG9ydCB7IGlzQWJzdHJhY3RFbGVtZW50IH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMnO1xuaW1wb3J0IHsgaXNSb290Q3N0Tm9kZSwgaXNDb21wb3NpdGVDc3ROb2RlLCBpc0xlYWZDc3ROb2RlLCBpc0FzdE5vZGUsIGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgc3RyZWFtQXN0IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IEJpTWFwIH0gZnJvbSAnLi4vdXRpbHMvY29sbGVjdGlvbnMuanMnO1xuaW1wb3J0IHsgc3RyZWFtQ3N0IH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0SHlkcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZ3JhbW1hckVsZW1lbnRJZE1hcCA9IG5ldyBCaU1hcCgpO1xuICAgICAgICB0aGlzLnRva2VuVHlwZUlkTWFwID0gbmV3IEJpTWFwKCk7XG4gICAgICAgIHRoaXMuZ3JhbW1hciA9IHNlcnZpY2VzLkdyYW1tYXI7XG4gICAgICAgIHRoaXMubGV4ZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGV4ZXI7XG4gICAgICAgIHRoaXMubGlua2VyID0gc2VydmljZXMucmVmZXJlbmNlcy5MaW5rZXI7XG4gICAgfVxuICAgIGRlaHlkcmF0ZShyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIHNoYWxsb3cgY29waWVzIG9mIHRoZSBlcnJvcnNcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBlcnJvcnMgaW5oZXJpdCBmcm9tIHRoZSBgRXJyb3JgIGNsYXNzLCB3aGljaCBpcyBub3QgdHJhbnNmZXJhYmxlIGFjcm9zcyB3b3JrZXIgdGhyZWFkc1xuICAgICAgICAgICAgbGV4ZXJFcnJvcnM6IHJlc3VsdC5sZXhlckVycm9ycy5tYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZSkpKSxcbiAgICAgICAgICAgIHBhcnNlckVycm9yczogcmVzdWx0LnBhcnNlckVycm9ycy5tYXAoZSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZSkpKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmRlaHlkcmF0ZUFzdE5vZGUocmVzdWx0LnZhbHVlLCB0aGlzLmNyZWF0ZURlaHlyYXRpb25Db250ZXh0KHJlc3VsdC52YWx1ZSkpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZURlaHlyYXRpb25Db250ZXh0KG5vZGUpIHtcbiAgICAgICAgY29uc3QgYXN0Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGNzdE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGFzdE5vZGUgb2Ygc3RyZWFtQXN0KG5vZGUpKSB7XG4gICAgICAgICAgICBhc3ROb2Rlcy5zZXQoYXN0Tm9kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLiRjc3ROb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNzdE5vZGUgb2Ygc3RyZWFtQ3N0KG5vZGUuJGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY3N0Tm9kZXMuc2V0KGNzdE5vZGUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN0Tm9kZXMsXG4gICAgICAgICAgICBjc3ROb2Rlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBkZWh5ZHJhdGVBc3ROb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIG9iai4kdHlwZSA9IG5vZGUuJHR5cGU7XG4gICAgICAgIG9iai4kY29udGFpbmVySW5kZXggPSBub2RlLiRjb250YWluZXJJbmRleDtcbiAgICAgICAgb2JqLiRjb250YWluZXJQcm9wZXJ0eSA9IG5vZGUuJGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvYmouJGNzdE5vZGUgPSB0aGlzLmRlaHlkcmF0ZUNzdE5vZGUobm9kZS4kY3N0Tm9kZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IGFycjtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5kZWh5ZHJhdGVBc3ROb2RlKGl0ZW0sIGNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc1JlZmVyZW5jZShpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2godGhpcy5kZWh5ZHJhdGVSZWZlcmVuY2UoaXRlbSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqW25hbWVdID0gdGhpcy5kZWh5ZHJhdGVBc3ROb2RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IHRoaXMuZGVoeWRyYXRlUmVmZXJlbmNlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBkZWh5ZHJhdGVSZWZlcmVuY2UocmVmZXJlbmNlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBvYmouJHJlZlRleHQgPSByZWZlcmVuY2UuJHJlZlRleHQ7XG4gICAgICAgIGlmIChyZWZlcmVuY2UuJHJlZk5vZGUpIHtcbiAgICAgICAgICAgIG9iai4kcmVmTm9kZSA9IGNvbnRleHQuY3N0Tm9kZXMuZ2V0KHJlZmVyZW5jZS4kcmVmTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgZGVoeWRyYXRlQ3N0Tm9kZShub2RlLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNzdE5vZGUgPSBjb250ZXh0LmNzdE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgaWYgKGlzUm9vdENzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGNzdE5vZGUuZnVsbFRleHQgPSBub2RlLmZ1bGxUZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90ZTogVGhpcyByZXR1cm5zIHVuZGVmaW5lZCBmb3IgaGlkZGVuIG5vZGVzIChpLmUuIGNvbW1lbnRzKVxuICAgICAgICAgICAgY3N0Tm9kZS5ncmFtbWFyU291cmNlID0gdGhpcy5nZXRHcmFtbWFyRWxlbWVudElkKG5vZGUuZ3JhbW1hclNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3N0Tm9kZS5oaWRkZW4gPSBub2RlLmhpZGRlbjtcbiAgICAgICAgY3N0Tm9kZS5hc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZS5hc3ROb2RlKTtcbiAgICAgICAgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgY3N0Tm9kZS5jb250ZW50ID0gbm9kZS5jb250ZW50Lm1hcChjaGlsZCA9PiB0aGlzLmRlaHlkcmF0ZUNzdE5vZGUoY2hpbGQsIGNvbnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0xlYWZDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjc3ROb2RlLnRva2VuVHlwZSA9IG5vZGUudG9rZW5UeXBlLm5hbWU7XG4gICAgICAgICAgICBjc3ROb2RlLm9mZnNldCA9IG5vZGUub2Zmc2V0O1xuICAgICAgICAgICAgY3N0Tm9kZS5sZW5ndGggPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIGNzdE5vZGUuc3RhcnRMaW5lID0gbm9kZS5yYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgY3N0Tm9kZS5zdGFydENvbHVtbiA9IG5vZGUucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgY3N0Tm9kZS5lbmRMaW5lID0gbm9kZS5yYW5nZS5lbmQubGluZTtcbiAgICAgICAgICAgIGNzdE5vZGUuZW5kQ29sdW1uID0gbm9kZS5yYW5nZS5lbmQuY2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjc3ROb2RlO1xuICAgIH1cbiAgICBoeWRyYXRlKHJlc3VsdCkge1xuICAgICAgICBjb25zdCBub2RlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5jcmVhdGVIeWRyYXRpb25Db250ZXh0KG5vZGUpO1xuICAgICAgICBpZiAoJyRjc3ROb2RlJyBpbiBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmh5ZHJhdGVDc3ROb2RlKG5vZGUuJGNzdE5vZGUsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZXhlckVycm9yczogcmVzdWx0LmxleGVyRXJyb3JzLFxuICAgICAgICAgICAgcGFyc2VyRXJyb3JzOiByZXN1bHQucGFyc2VyRXJyb3JzLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuaHlkcmF0ZUFzdE5vZGUobm9kZSwgY29udGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlSHlkcmF0aW9uQ29udGV4dChub2RlKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjc3ROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBhc3ROb2RlIG9mIHN0cmVhbUFzdChub2RlKSkge1xuICAgICAgICAgICAgYXN0Tm9kZXMuc2V0KGFzdE5vZGUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdDtcbiAgICAgICAgaWYgKG5vZGUuJGNzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3N0Tm9kZSBvZiBzdHJlYW1Dc3Qobm9kZS4kY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3N0O1xuICAgICAgICAgICAgICAgIGlmICgnZnVsbFRleHQnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gbmV3IFJvb3RDc3ROb2RlSW1wbChjc3ROb2RlLmZ1bGxUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGNzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ2NvbnRlbnQnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gbmV3IENvbXBvc2l0ZUNzdE5vZGVJbXBsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCd0b2tlblR5cGUnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gdGhpcy5oeWRyYXRlQ3N0TGVhZk5vZGUoY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0Tm9kZXMuc2V0KGNzdE5vZGUsIGNzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNzdC5yb290ID0gcm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzdE5vZGVzLFxuICAgICAgICAgICAgY3N0Tm9kZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaHlkcmF0ZUFzdE5vZGUobm9kZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGFzdE5vZGUuJHR5cGUgPSBub2RlLiR0eXBlO1xuICAgICAgICBhc3ROb2RlLiRjb250YWluZXJJbmRleCA9IG5vZGUuJGNvbnRhaW5lckluZGV4O1xuICAgICAgICBhc3ROb2RlLiRjb250YWluZXJQcm9wZXJ0eSA9IG5vZGUuJGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgYXN0Tm9kZS4kY3N0Tm9kZSA9IGNvbnRleHQuY3N0Tm9kZXMuZ2V0KG5vZGUuJGNzdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBhc3ROb2RlW25hbWVdID0gYXJyO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNldFBhcmVudCh0aGlzLmh5ZHJhdGVBc3ROb2RlKGl0ZW0sIGNvbnRleHQpLCBhc3ROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuaHlkcmF0ZVJlZmVyZW5jZShpdGVtLCBhc3ROb2RlLCBuYW1lLCBjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBhc3ROb2RlW25hbWVdID0gdGhpcy5zZXRQYXJlbnQodGhpcy5oeWRyYXRlQXN0Tm9kZSh2YWx1ZSwgY29udGV4dCksIGFzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IHRoaXMuaHlkcmF0ZVJlZmVyZW5jZSh2YWx1ZSwgYXN0Tm9kZSwgbmFtZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3ROb2RlO1xuICAgIH1cbiAgICBzZXRQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIG5vZGUuJGNvbnRhaW5lciA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGh5ZHJhdGVSZWZlcmVuY2UocmVmZXJlbmNlLCBub2RlLCBuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtlci5idWlsZFJlZmVyZW5jZShub2RlLCBuYW1lLCBjb250ZXh0LmNzdE5vZGVzLmdldChyZWZlcmVuY2UuJHJlZk5vZGUpLCByZWZlcmVuY2UuJHJlZlRleHQpO1xuICAgIH1cbiAgICBoeWRyYXRlQ3N0Tm9kZShjc3ROb2RlLCBjb250ZXh0LCBudW0gPSAwKSB7XG4gICAgICAgIGNvbnN0IGNzdE5vZGVPYmogPSBjb250ZXh0LmNzdE5vZGVzLmdldChjc3ROb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjc3ROb2RlLmdyYW1tYXJTb3VyY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjc3ROb2RlT2JqLmdyYW1tYXJTb3VyY2UgPSB0aGlzLmdldEdyYW1tYXJFbGVtZW50KGNzdE5vZGUuZ3JhbW1hclNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3N0Tm9kZU9iai5hc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQoY3N0Tm9kZS5hc3ROb2RlKTtcbiAgICAgICAgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShjc3ROb2RlT2JqKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjc3ROb2RlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlZCA9IHRoaXMuaHlkcmF0ZUNzdE5vZGUoY2hpbGQsIGNvbnRleHQsIG51bSsrKTtcbiAgICAgICAgICAgICAgICBjc3ROb2RlT2JqLmNvbnRlbnQucHVzaChoeWRyYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzdE5vZGVPYmo7XG4gICAgfVxuICAgIGh5ZHJhdGVDc3RMZWFmTm9kZShjc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlKGNzdE5vZGUudG9rZW5UeXBlKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY3N0Tm9kZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNzdE5vZGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGFydExpbmUgPSBjc3ROb2RlLnN0YXJ0TGluZTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBjc3ROb2RlLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjb25zdCBlbmRMaW5lID0gY3N0Tm9kZS5lbmRMaW5lO1xuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSBjc3ROb2RlLmVuZENvbHVtbjtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gY3N0Tm9kZS5oaWRkZW47XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTGVhZkNzdE5vZGVJbXBsKG9mZnNldCwgbGVuZ3RoLCB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IHN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZSxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGVuZENvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0b2tlblR5cGUsIGhpZGRlbik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXhlci5kZWZpbml0aW9uW25hbWVdO1xuICAgIH1cbiAgICBnZXRHcmFtbWFyRWxlbWVudElkKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhbW1hckVsZW1lbnRJZE1hcC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdyYW1tYXJFbGVtZW50SWRNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ncmFtbWFyRWxlbWVudElkTWFwLmdldChub2RlKTtcbiAgICB9XG4gICAgZ2V0R3JhbW1hckVsZW1lbnQoaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhbW1hckVsZW1lbnRJZE1hcC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdyYW1tYXJFbGVtZW50SWRNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5ncmFtbWFyRWxlbWVudElkTWFwLmdldEtleShpZCk7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBncmFtbWFyIGVsZW1lbnQgaWQ6ICcgKyBpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlR3JhbW1hckVsZW1lbnRJZE1hcCgpIHtcbiAgICAgICAgbGV0IGlkID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHN0cmVhbUFzdCh0aGlzLmdyYW1tYXIpKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnN0cmFjdEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuc2V0KGVsZW1lbnQsIGlkKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHlkcmF0b3IuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBjcmVhdGVHcmFtbWFyQ29uZmlnIH0gZnJvbSAnLi9sYW5ndWFnZXMvZ3JhbW1hci1jb25maWcuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ29tcGxldGlvblBhcnNlciB9IGZyb20gJy4vcGFyc2VyL2NvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlTGFuZ2l1bVBhcnNlciB9IGZyb20gJy4vcGFyc2VyL2xhbmdpdW0tcGFyc2VyLWJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFRva2VuQnVpbGRlciB9IGZyb20gJy4vcGFyc2VyL3Rva2VuLWJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFZhbHVlQ29udmVydGVyIH0gZnJvbSAnLi9wYXJzZXIvdmFsdWUtY29udmVydGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMaW5rZXIgfSBmcm9tICcuL3JlZmVyZW5jZXMvbGlua2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHROYW1lUHJvdmlkZXIgfSBmcm9tICcuL3JlZmVyZW5jZXMvbmFtZS1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0UmVmZXJlbmNlcyB9IGZyb20gJy4vcmVmZXJlbmNlcy9yZWZlcmVuY2VzLmpzJztcbmltcG9ydCB7IERlZmF1bHRTY29wZUNvbXB1dGF0aW9uIH0gZnJvbSAnLi9yZWZlcmVuY2VzL3Njb3BlLWNvbXB1dGF0aW9uLmpzJztcbmltcG9ydCB7IERlZmF1bHRTY29wZVByb3ZpZGVyIH0gZnJvbSAnLi9yZWZlcmVuY2VzL3Njb3BlLXByb3ZpZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRKc29uU2VyaWFsaXplciB9IGZyb20gJy4vc2VyaWFsaXplci9qc29uLXNlcmlhbGl6ZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFNlcnZpY2VSZWdpc3RyeSB9IGZyb20gJy4vc2VydmljZS1yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0RG9jdW1lbnRWYWxpZGF0b3IgfSBmcm9tICcuL3ZhbGlkYXRpb24vZG9jdW1lbnQtdmFsaWRhdG9yLmpzJztcbmltcG9ydCB7IFZhbGlkYXRpb25SZWdpc3RyeSB9IGZyb20gJy4vdmFsaWRhdGlvbi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzJztcbmltcG9ydCB7IERlZmF1bHRBc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlciwgRGVmYXVsdFJlZmVyZW5jZURlc2NyaXB0aW9uUHJvdmlkZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9hc3QtZGVzY3JpcHRpb25zLmpzJztcbmltcG9ydCB7IERlZmF1bHRBc3ROb2RlTG9jYXRvciB9IGZyb20gJy4vd29ya3NwYWNlL2FzdC1ub2RlLWxvY2F0b3IuanMnO1xuaW1wb3J0IHsgRGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlciB9IGZyb20gJy4vd29ya3NwYWNlL2NvbmZpZ3VyYXRpb24uanMnO1xuaW1wb3J0IHsgRGVmYXVsdERvY3VtZW50QnVpbGRlciB9IGZyb20gJy4vd29ya3NwYWNlL2RvY3VtZW50LWJ1aWxkZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdExhbmdpdW1Eb2N1bWVudEZhY3RvcnksIERlZmF1bHRMYW5naXVtRG9jdW1lbnRzIH0gZnJvbSAnLi93b3Jrc3BhY2UvZG9jdW1lbnRzLmpzJztcbmltcG9ydCB7IERlZmF1bHRJbmRleE1hbmFnZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9pbmRleC1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHRXb3Jrc3BhY2VNYW5hZ2VyIH0gZnJvbSAnLi93b3Jrc3BhY2Uvd29ya3NwYWNlLW1hbmFnZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdExleGVyIH0gZnJvbSAnLi9wYXJzZXIvbGV4ZXIuanMnO1xuaW1wb3J0IHsgSlNEb2NEb2N1bWVudGF0aW9uUHJvdmlkZXIgfSBmcm9tICcuL2RvY3VtZW50YXRpb24vZG9jdW1lbnRhdGlvbi1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0Q29tbWVudFByb3ZpZGVyIH0gZnJvbSAnLi9kb2N1bWVudGF0aW9uL2NvbW1lbnQtcHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgTGFuZ2l1bVBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIH0gZnJvbSAnLi9wYXJzZXIvbGFuZ2l1bS1wYXJzZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdEFzeW5jUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXIvYXN5bmMtcGFyc2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHRXb3Jrc3BhY2VMb2NrIH0gZnJvbSAnLi93b3Jrc3BhY2Uvd29ya3NwYWNlLWxvY2suanMnO1xuaW1wb3J0IHsgRGVmYXVsdEh5ZHJhdG9yIH0gZnJvbSAnLi9zZXJpYWxpemVyL2h5ZHJhdG9yLmpzJztcbi8qKlxuICogQ3JlYXRlcyBhIGRlcGVuZGVuY3kgaW5qZWN0aW9uIG1vZHVsZSBjb25maWd1cmluZyB0aGUgZGVmYXVsdCBjb3JlIHNlcnZpY2VzLlxuICogVGhpcyBpcyBhIHNldCBvZiBzZXJ2aWNlcyB0aGF0IGFyZSBkZWRpY2F0ZWQgdG8gYSBzcGVjaWZpYyBsYW5ndWFnZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb2N1bWVudGF0aW9uOiB7XG4gICAgICAgICAgICBDb21tZW50UHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRDb21tZW50UHJvdmlkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgRG9jdW1lbnRhdGlvblByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBKU0RvY0RvY3VtZW50YXRpb25Qcm92aWRlcihzZXJ2aWNlcylcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VyOiB7XG4gICAgICAgICAgICBBc3luY1BhcnNlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdEFzeW5jUGFyc2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIEdyYW1tYXJDb25maWc6IChzZXJ2aWNlcykgPT4gY3JlYXRlR3JhbW1hckNvbmZpZyhzZXJ2aWNlcyksXG4gICAgICAgICAgICBMYW5naXVtUGFyc2VyOiAoc2VydmljZXMpID0+IGNyZWF0ZUxhbmdpdW1QYXJzZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgQ29tcGxldGlvblBhcnNlcjogKHNlcnZpY2VzKSA9PiBjcmVhdGVDb21wbGV0aW9uUGFyc2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFZhbHVlQ29udmVydGVyOiAoKSA9PiBuZXcgRGVmYXVsdFZhbHVlQ29udmVydGVyKCksXG4gICAgICAgICAgICBUb2tlbkJ1aWxkZXI6ICgpID0+IG5ldyBEZWZhdWx0VG9rZW5CdWlsZGVyKCksXG4gICAgICAgICAgICBMZXhlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdExleGVyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyOiAoKSA9PiBuZXcgTGFuZ2l1bVBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyKClcbiAgICAgICAgfSxcbiAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICBBc3ROb2RlTG9jYXRvcjogKCkgPT4gbmV3IERlZmF1bHRBc3ROb2RlTG9jYXRvcigpLFxuICAgICAgICAgICAgQXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRBc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBSZWZlcmVuY2VEZXNjcmlwdGlvblByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0UmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlcihzZXJ2aWNlcylcbiAgICAgICAgfSxcbiAgICAgICAgcmVmZXJlbmNlczoge1xuICAgICAgICAgICAgTGlua2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGlua2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIE5hbWVQcm92aWRlcjogKCkgPT4gbmV3IERlZmF1bHROYW1lUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIFNjb3BlUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRTY29wZVByb3ZpZGVyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFNjb3BlQ29tcHV0YXRpb246IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRTY29wZUNvbXB1dGF0aW9uKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFJlZmVyZW5jZXM6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRSZWZlcmVuY2VzKHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICBzZXJpYWxpemVyOiB7XG4gICAgICAgICAgICBIeWRyYXRvcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdEh5ZHJhdG9yKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIEpzb25TZXJpYWxpemVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0SnNvblNlcmlhbGl6ZXIoc2VydmljZXMpXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgICAgICAgIERvY3VtZW50VmFsaWRhdG9yOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0RG9jdW1lbnRWYWxpZGF0b3Ioc2VydmljZXMpLFxuICAgICAgICAgICAgVmFsaWRhdGlvblJlZ2lzdHJ5OiAoc2VydmljZXMpID0+IG5ldyBWYWxpZGF0aW9uUmVnaXN0cnkoc2VydmljZXMpXG4gICAgICAgIH0sXG4gICAgICAgIHNoYXJlZDogKCkgPT4gY29udGV4dC5zaGFyZWRcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgZGVwZW5kZW5jeSBpbmplY3Rpb24gbW9kdWxlIGNvbmZpZ3VyaW5nIHRoZSBkZWZhdWx0IHNoYXJlZCBjb3JlIHNlcnZpY2VzLlxuICogVGhpcyBpcyB0aGUgc2V0IG9mIHNlcnZpY2VzIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGxhbmd1YWdlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBTZXJ2aWNlUmVnaXN0cnk6ICgpID0+IG5ldyBEZWZhdWx0U2VydmljZVJlZ2lzdHJ5KCksXG4gICAgICAgIHdvcmtzcGFjZToge1xuICAgICAgICAgICAgTGFuZ2l1bURvY3VtZW50czogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdExhbmdpdW1Eb2N1bWVudHMoc2VydmljZXMpLFxuICAgICAgICAgICAgTGFuZ2l1bURvY3VtZW50RmFjdG9yeTogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdExhbmdpdW1Eb2N1bWVudEZhY3Rvcnkoc2VydmljZXMpLFxuICAgICAgICAgICAgRG9jdW1lbnRCdWlsZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0RG9jdW1lbnRCdWlsZGVyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIEluZGV4TWFuYWdlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdEluZGV4TWFuYWdlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBXb3Jrc3BhY2VNYW5hZ2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0V29ya3NwYWNlTWFuYWdlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBGaWxlU3lzdGVtUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gY29udGV4dC5maWxlU3lzdGVtUHJvdmlkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgV29ya3NwYWNlTG9jazogKCkgPT4gbmV3IERlZmF1bHRXb3Jrc3BhY2VMb2NrKCksXG4gICAgICAgICAgICBDb25maWd1cmF0aW9uUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIoc2VydmljZXMpXG4gICAgICAgIH1cbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmYXVsdC1tb2R1bGUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IHZhciBNb2R1bGU7XG4oZnVuY3Rpb24gKE1vZHVsZSkge1xuICAgIE1vZHVsZS5tZXJnZSA9IChtMSwgbTIpID0+IF9tZXJnZShfbWVyZ2Uoe30sIG0xKSwgbTIpO1xufSkoTW9kdWxlIHx8IChNb2R1bGUgPSB7fSkpO1xuLyoqXG4gKiBHaXZlbiBhIHNldCBvZiBtb2R1bGVzLCB0aGUgaW5qZWN0IGZ1bmN0aW9uIHJldHVybnMgYSBsYXppbHkgZXZhbHVhdGVkIGluamVjdG9yXG4gKiB0aGF0IGluamVjdHMgZGVwZW5kZW5jaWVzIGludG8gdGhlIHJlcXVlc3RlZCBzZXJ2aWNlIHdoZW4gaXQgaXMgcmVxdWVzdGVkIHRoZVxuICogZmlyc3QgdGltZS4gU3Vic2VxdWVudCByZXF1ZXN0cyB3aWxsIHJldHVybiB0aGUgc2FtZSBzZXJ2aWNlLlxuICpcbiAqIEluIHRoZSBjYXNlIG9mIGN5Y2xpYyBkZXBlbmRlbmNpZXMsIGFuIEVycm9yIHdpbGwgYmUgdGhyb3duLiBUaGlzIGNhbiBiZSBmaXhlZFxuICogYnkgaW5qZWN0aW5nIGEgcHJvdmlkZXIgYCgpID0+IFRgIGluc3RlYWQgb2YgYSBgVGAuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCB0aGUgYXJndW1lbnRzIG1heSBiZSBvYmplY3RzIG9yIGFycmF5cy4gSG93ZXZlciwgdGhlIHJlc3VsdCB3aWxsXG4gKiBiZSBhbiBvYmplY3QuIFVzaW5nIGl0IHdpdGggZm9yLi5vZiB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICpcbiAqIEBwYXJhbSBtb2R1bGUxIGZpcnN0IE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTIgKG9wdGlvbmFsKSBzZWNvbmQgTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlMyAob3B0aW9uYWwpIHRoaXJkIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTQgKG9wdGlvbmFsKSBmb3VydGggTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlNSAob3B0aW9uYWwpIGZpZnRoIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTYgKG9wdGlvbmFsKSBzaXh0aCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU3IChvcHRpb25hbCkgc2V2ZW50aCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU4IChvcHRpb25hbCkgZWlnaHRoIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTkgKG9wdGlvbmFsKSBuaW50aCBNb2R1bGVcbiAqIEByZXR1cm5zIGEgbmV3IG9iamVjdCBvZiB0eXBlIElcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluamVjdChtb2R1bGUxLCBtb2R1bGUyLCBtb2R1bGUzLCBtb2R1bGU0LCBtb2R1bGU1LCBtb2R1bGU2LCBtb2R1bGU3LCBtb2R1bGU4LCBtb2R1bGU5KSB7XG4gICAgY29uc3QgbW9kdWxlID0gW21vZHVsZTEsIG1vZHVsZTIsIG1vZHVsZTMsIG1vZHVsZTQsIG1vZHVsZTUsIG1vZHVsZTYsIG1vZHVsZTcsIG1vZHVsZTgsIG1vZHVsZTldLnJlZHVjZShfbWVyZ2UsIHt9KTtcbiAgICByZXR1cm4gX2luamVjdChtb2R1bGUpO1xufVxuY29uc3QgaXNQcm94eSA9IFN5bWJvbCgnaXNQcm94eScpO1xuLyoqXG4gKiBFYWdlcmx5IGxvYWQgYWxsIHNlcnZpY2VzIGluIHRoZSBnaXZlbiBkZXBlbmRlbmN5IGluamVjdGlvbiBjb250YWluZXIuIFRoaXMgaXMgc29tZXRpbWVzXG4gKiBuZWNlc3NhcnkgYmVjYXVzZSBzZXJ2aWNlcyBjYW4gcmVnaXN0ZXIgZXZlbnQgbGlzdGVuZXJzIGluIHRoZWlyIGNvbnN0cnVjdG9ycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVhZ2VyTG9hZChpdGVtKSB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbVtpc1Byb3h5XSkge1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIE9iamVjdC52YWx1ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgIGVhZ2VyTG9hZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gaW5qZWN0b3IgYnkgY3JlYXRpbmcgYSBwcm94eS5cbiAqIEludmFyaWFudDogaW5qZWN0b3IgaXMgb2YgdHlwZSBJLiBJZiBpbmplY3RvciBpcyB1bmRlZmluZWQsIHRoZW4gVCA9IEkuXG4gKi9cbmZ1bmN0aW9uIF9pbmplY3QobW9kdWxlLCBpbmplY3Rvcikge1xuICAgIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiBmYWxzZSxcbiAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiBfcmVzb2x2ZShvYmosIHByb3AsIG1vZHVsZSwgaW5qZWN0b3IgfHwgcHJveHkpLFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IChvYmosIHByb3ApID0+IChfcmVzb2x2ZShvYmosIHByb3AsIG1vZHVsZSwgaW5qZWN0b3IgfHwgcHJveHkpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwgcHJvcCkpLFxuICAgICAgICBoYXM6IChfLCBwcm9wKSA9PiBwcm9wIGluIG1vZHVsZSxcbiAgICAgICAgb3duS2V5czogKCkgPT4gWy4uLlJlZmxlY3Qub3duS2V5cyhtb2R1bGUpLCBpc1Byb3h5XSAvLyB1c2VkIGJ5IGZvci4uaW5cbiAgICB9KTtcbiAgICBwcm94eVtpc1Byb3h5XSA9IHRydWU7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gdGFnIGEgcmVxdWVzdGVkIGRlcGVuZGVuY3ksIGRpcmVjdGx5IGJlZm9yZSBjYWxsaW5nIHRoZSBmYWN0b3J5LlxuICogVGhpcyBhbGxvd3MgdXMgdG8gZmluZCBjeWNsZXMgZHVyaW5nIGluc3RhbmNlIGNyZWF0aW9uLlxuICovXG5jb25zdCBfX3JlcXVlc3RlZF9fID0gU3ltYm9sKCk7XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIGBvYmpbcHJvcF1gLiBJZiB0aGUgdmFsdWUgZG9lcyBub3QgZXhpc3QsIHlldCwgaXQgaXMgcmVzb2x2ZWQgZnJvbVxuICogdGhlIG1vZHVsZSBkZXNjcmlwdGlvbi4gVGhlIHJlc3VsdCBvZiBzZXJ2aWNlIGZhY3RvcmllcyBpcyBjYWNoZWQuIEdyb3VwcyBhcmVcbiAqIHJlY3Vyc2l2ZWx5IHByb3hpZWQuXG4gKlxuICogQHBhcmFtIG9iaiBhbiBvYmplY3QgaG9sZGluZyBhbGwgZ3JvdXAgcHJveGllcyBhbmQgc2VydmljZXNcbiAqIEBwYXJhbSBwcm9wIHRoZSBrZXkgb2YgYSB2YWx1ZSB3aXRoaW4gb2JqXG4gKiBAcGFyYW0gbW9kdWxlIGFuIG9iamVjdCBjb250YWluaW5nIGdyb3VwcyBhbmQgc2VydmljZSBmYWN0b3JpZXNcbiAqIEBwYXJhbSBpbmplY3RvciB0aGUgZmlyc3QgbGV2ZWwgcHJveHkgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gYWxsIHZhbHVlc1xuICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCB2YWx1ZSBgb2JqW3Byb3BdYFxuICogQHRocm93cyBFcnJvciBpZiBhIGRlcGVuZGVuY3kgY3ljbGUgaXMgZGV0ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmUob2JqLCBwcm9wLCBtb2R1bGUsIGluamVjdG9yKSB7XG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3Rpb24gZmFpbHVyZS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdXIgZGVwZW5kZW5jaWVzIGFyZSBjb25zdHJ1Y3RhYmxlLicsIHsgY2F1c2U6IG9ialtwcm9wXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqW3Byb3BdID09PSBfX3JlcXVlc3RlZF9fKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N5Y2xlIGRldGVjdGVkLiBQbGVhc2UgbWFrZSBcIicgKyBTdHJpbmcocHJvcCkgKyAnXCIgbGF6eS4gU2VlIGh0dHBzOi8vbGFuZ2l1bS5vcmcvZG9jcy9jb25maWd1cmF0aW9uLXNlcnZpY2VzLyNyZXNvbHZpbmctY3ljbGljLWRlcGVuZGVuY2llcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpbcHJvcF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3AgaW4gbW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbW9kdWxlW3Byb3BdO1xuICAgICAgICBvYmpbcHJvcF0gPSBfX3JlcXVlc3RlZF9fO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgPyB2YWx1ZShpbmplY3RvcikgOiBfaW5qZWN0KHZhbHVlLCBpbmplY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcC1tZXJnZSBvZiB0d28gbW9kdWxlcyBieSB3cml0aW5nIHNvdXJjZSBlbnRyaWVzIGludG8gdGhlIHRhcmdldCBtb2R1bGUuXG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgbW9kdWxlIHdoaWNoIGlzIHdyaXR0ZW5cbiAqIEBwYXJhbSBzb3VyY2UgdGhlIG1vZHVsZSB3aGljaCBpcyByZWFkXG4gKiBAcmV0dXJucyB0aGUgdGFyZ2V0IG1vZHVsZVxuICovXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZTEgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUxID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IF9tZXJnZSh2YWx1ZTEsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY3ktaW5qZWN0aW9uLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCAqIGZyb20gJy4vY29tbWVudC1wcm92aWRlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2RvY3VtZW50YXRpb24tcHJvdmlkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9qc2RvYy5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgKiBmcm9tICcuL2dyYW1tYXItY29uZmlnLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGFuZ3VhZ2UtbWV0YS1kYXRhLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCAqIGZyb20gJy4vYXN5bmMtcGFyc2VyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29tcGxldGlvbi1wYXJzZXItYnVpbGRlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NzdC1ub2RlLWJ1aWxkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9sYW5naXVtLXBhcnNlci1idWlsZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGFuZ2l1bS1wYXJzZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9sZXhlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3BhcnNlci1jb25maWcuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90b2tlbi1idWlsZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdmFsdWUtY29udmVydGVyLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCAqIGZyb20gJy4vbGlua2VyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbmFtZS1wcm92aWRlci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3JlZmVyZW5jZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zY29wZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3Njb3BlLWNvbXB1dGF0aW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2NvcGUtcHJvdmlkZXIuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0ICogZnJvbSAnLi9oeWRyYXRvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2pzb24tc2VyaWFsaXplci5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgY2xhc3MgRW1wdHlGaWxlU3lzdGVtUHJvdmlkZXIge1xuICAgIHJlYWRGaWxlKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZpbGUgc3lzdGVtIGlzIGF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZERpcmVjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBFbXB0eUZpbGVTeXN0ZW0gPSB7XG4gICAgZmlsZVN5c3RlbVByb3ZpZGVyOiAoKSA9PiBuZXcgRW1wdHlGaWxlU3lzdGVtUHJvdmlkZXIoKVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbGUtc3lzdGVtLXByb3ZpZGVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlLCBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZSB9IGZyb20gJy4uL2RlZmF1bHQtbW9kdWxlLmpzJztcbmltcG9ydCB7IGluamVjdCB9IGZyb20gJy4uL2RlcGVuZGVuY3ktaW5qZWN0aW9uLmpzJztcbmltcG9ydCAqIGFzIGFzdCBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBFbXB0eUZpbGVTeXN0ZW0gfSBmcm9tICcuLi93b3Jrc3BhY2UvZmlsZS1zeXN0ZW0tcHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi91cmktdXRpbHMuanMnO1xuY29uc3QgbWluaW1hbEdyYW1tYXJNb2R1bGUgPSB7XG4gICAgR3JhbW1hcjogKCkgPT4gdW5kZWZpbmVkLFxuICAgIExhbmd1YWdlTWV0YURhdGE6ICgpID0+ICh7XG4gICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gICAgICAgIGZpbGVFeHRlbnNpb25zOiBbJy5sYW5naXVtJ10sXG4gICAgICAgIGxhbmd1YWdlSWQ6ICdsYW5naXVtJ1xuICAgIH0pXG59O1xuY29uc3QgbWluaW1hbFNoYXJlZEdyYW1tYXJNb2R1bGUgPSB7XG4gICAgQXN0UmVmbGVjdGlvbjogKCkgPT4gbmV3IGFzdC5MYW5naXVtR3JhbW1hckFzdFJlZmxlY3Rpb24oKVxufTtcbmZ1bmN0aW9uIGNyZWF0ZU1pbmltYWxHcmFtbWFyU2VydmljZXMoKSB7XG4gICAgY29uc3Qgc2hhcmVkID0gaW5qZWN0KGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKEVtcHR5RmlsZVN5c3RlbSksIG1pbmltYWxTaGFyZWRHcmFtbWFyTW9kdWxlKTtcbiAgICBjb25zdCBncmFtbWFyID0gaW5qZWN0KGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKHsgc2hhcmVkIH0pLCBtaW5pbWFsR3JhbW1hck1vZHVsZSk7XG4gICAgc2hhcmVkLlNlcnZpY2VSZWdpc3RyeS5yZWdpc3RlcihncmFtbWFyKTtcbiAgICByZXR1cm4gZ3JhbW1hcjtcbn1cbi8qKlxuICogTG9hZCBhIExhbmdpdW0gZ3JhbW1hciBmb3IgeW91ciBsYW5ndWFnZSBmcm9tIGEgSlNPTiBzdHJpbmcuIFRoaXMgaXMgdXNlZCBieSBzZXZlcmFsIHNlcnZpY2VzLFxuICogbW9zdCBub3RhYmx5IHRoZSBwYXJzZXIgYnVpbGRlciB3aGljaCBpbnRlcnByZXRzIHRoZSBncmFtbWFyIHRvIGNyZWF0ZSBhIHBhcnNlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWRHcmFtbWFyRnJvbUpzb24oanNvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZXJ2aWNlcyA9IGNyZWF0ZU1pbmltYWxHcmFtbWFyU2VydmljZXMoKTtcbiAgICBjb25zdCBhc3ROb2RlID0gc2VydmljZXMuc2VyaWFsaXplci5Kc29uU2VyaWFsaXplci5kZXNlcmlhbGl6ZShqc29uKTtcbiAgICBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbU1vZGVsKGFzdE5vZGUsIFVSSS5wYXJzZShgbWVtb3J5Oi8vJHsoX2EgPSBhc3ROb2RlLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdncmFtbWFyJ30ubGFuZ2l1bWApKTtcbiAgICByZXR1cm4gYXN0Tm9kZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYW1tYXItbG9hZGVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCAqIGZyb20gJy4vY2FjaGluZy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2V2ZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vY29sbGVjdGlvbnMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kaXNwb3NhYmxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZ3JhbW1hci1sb2FkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wcm9taXNlLXV0aWxzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc3RyZWFtLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXJpLXV0aWxzLmpzJztcbmltcG9ydCAqIGFzIEFzdFV0aWxzIGZyb20gJy4vYXN0LXV0aWxzLmpzJztcbmltcG9ydCAqIGFzIENhbmNlbGxhdGlvbiBmcm9tICcuL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBDc3RVdGlscyBmcm9tICcuL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgKiBhcyBHcmFtbWFyVXRpbHMgZnJvbSAnLi9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCAqIGFzIFJlZ0V4cFV0aWxzIGZyb20gJy4vcmVnZXhwLXV0aWxzLmpzJztcbmV4cG9ydCB7IEFzdFV0aWxzLCBDYW5jZWxsYXRpb24sIENzdFV0aWxzLCBHcmFtbWFyVXRpbHMsIFJlZ0V4cFV0aWxzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgKiBmcm9tICcuL2RvY3VtZW50LXZhbGlkYXRvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3ZhbGlkYXRpb24tcmVnaXN0cnkuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0ICogZnJvbSAnLi9hc3QtZGVzY3JpcHRpb25zLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vYXN0LW5vZGUtbG9jYXRvci5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NvbmZpZ3VyYXRpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9kb2N1bWVudC1idWlsZGVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZG9jdW1lbnRzLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZmlsZS1zeXN0ZW0tcHJvdmlkZXIuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9pbmRleC1tYW5hZ2VyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vd29ya3NwYWNlLWxvY2suanMnO1xuZXhwb3J0ICogZnJvbSAnLi93b3Jrc3BhY2UtbWFuYWdlci5qcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgKiBmcm9tICcuL2RlZmF1bHQtbW9kdWxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vZGVwZW5kZW5jeS1pbmplY3Rpb24uanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zZXJ2aWNlLXJlZ2lzdHJ5LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2VydmljZXMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9zeW50YXgtdHJlZS5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2RvY3VtZW50YXRpb24vaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9sYW5ndWFnZXMvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9wYXJzZXIvaW5kZXguanMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWZlcmVuY2VzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vc2VyaWFsaXplci9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWxzL2luZGV4LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdmFsaWRhdGlvbi9pbmRleC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3dvcmtzcGFjZS9pbmRleC5qcyc7XG4vLyBFeHBvcnQgdGhlIExhbmdpdW0gR3JhbW1hciBBU1QgZGVmaW5pdGlvbnMgaW4gdGhlIGBHcmFtbWFyQVNUYCBuYW1lc3BhY2VcbmltcG9ydCAqIGFzIEdyYW1tYXJBU1QgZnJvbSAnLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5leHBvcnQgeyBHcmFtbWFyQVNUIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33394\n')},72559:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61882);\n\n\n/**\n * The base implementation of methods like `_.max` and `_.min` which accepts a\n * `comparator` to determine the extremum value.\n *\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The iteratee invoked per iteration.\n * @param {Function} comparator The comparator used to compare values.\n * @returns {*} Returns the extremum value.\n */\nfunction baseExtremum(array, iteratee, comparator) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    var value = array[index],\n        current = iteratee(value);\n\n    if (current != null && (computed === undefined\n          ? (current === current && !(0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(current))\n          : comparator(current, computed)\n        )) {\n      var computed = current,\n          result = value;\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseExtremum);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzI1NTkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsaUVBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUV4dHJlbXVtLmpzPzBiMTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5tYXhgIGFuZCBgXy5taW5gIHdoaWNoIGFjY2VwdHMgYVxuICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciB1c2VkIHRvIGNvbXBhcmUgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlRXh0cmVtdW0oYXJyYXksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBjdXJyZW50ID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgaWYgKGN1cnJlbnQgIT0gbnVsbCAmJiAoY29tcHV0ZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgIDogY29tcGFyYXRvcihjdXJyZW50LCBjb21wdXRlZClcbiAgICAgICAgKSkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUV4dHJlbXVtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///72559\n')},36224:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * The base implementation of `_.lt` which doesn't coerce arguments.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if `value` is less than `other`,\n *  else `false`.\n */\nfunction baseLt(value, other) {\n  return value < other;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseLt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYyMjQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUx0LmpzPzQyMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUx0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///36224\n")},52568:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6240);\n/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38446);\n\n\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(collection) ? Array(collection.length) : [];\n\n  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A)(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTI1NjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7QUFDSzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9FQUFXOztBQUUxQixFQUFFLGlFQUFRO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxpRUFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZU1hcC5qcz8wN2JmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWFwYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5KGNvbGxlY3Rpb24ubGVuZ3RoKSA6IFtdO1xuXG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52568\n')},99354:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ _basePickBy)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseGet.js\nvar _baseGet = __webpack_require__(66318);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_assignValue.js\nvar _assignValue = __webpack_require__(52851);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_castPath.js + 2 modules\nvar _castPath = __webpack_require__(7819);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_isIndex.js\nvar _isIndex = __webpack_require__(25353);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js\nvar isObject = __webpack_require__(23149);\n// EXTERNAL MODULE: ./node_modules/lodash-es/_toKey.js\nvar _toKey = __webpack_require__(30901);\n;// ./node_modules/lodash-es/_baseSet.js\n\n\n\n\n\n\n/**\n * The base implementation of `_.set`.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {Array|string} path The path of the property to set.\n * @param {*} value The value to set.\n * @param {Function} [customizer] The function to customize path creation.\n * @returns {Object} Returns `object`.\n */\nfunction baseSet(object, path, value, customizer) {\n  if (!(0,isObject/* default */.A)(object)) {\n    return object;\n  }\n  path = (0,_castPath/* default */.A)(path, object);\n\n  var index = -1,\n      length = path.length,\n      lastIndex = length - 1,\n      nested = object;\n\n  while (nested != null && ++index < length) {\n    var key = (0,_toKey/* default */.A)(path[index]),\n        newValue = value;\n\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\n      return object;\n    }\n\n    if (index != lastIndex) {\n      var objValue = nested[key];\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\n      if (newValue === undefined) {\n        newValue = (0,isObject/* default */.A)(objValue)\n          ? objValue\n          : ((0,_isIndex/* default */.A)(path[index + 1]) ? [] : {});\n      }\n    }\n    (0,_assignValue/* default */.A)(nested, key, newValue);\n    nested = nested[key];\n  }\n  return object;\n}\n\n/* harmony default export */ const _baseSet = (baseSet);\n\n;// ./node_modules/lodash-es/_basePickBy.js\n\n\n\n\n/**\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The source object.\n * @param {string[]} paths The property paths to pick.\n * @param {Function} predicate The function invoked per property.\n * @returns {Object} Returns the new object.\n */\nfunction basePickBy(object, paths, predicate) {\n  var index = -1,\n      length = paths.length,\n      result = {};\n\n  while (++index < length) {\n    var path = paths[index],\n        value = (0,_baseGet/* default */.A)(object, path);\n\n    if (predicate(value, path)) {\n      _baseSet(result, (0,_castPath/* default */.A)(path, object), value);\n    }\n  }\n  return result;\n}\n\n/* harmony default export */ const _basePickBy = (basePickBy);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkzNTQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0QztBQUNOO0FBQ0Y7QUFDQztBQUNMOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsT0FBTywyQkFBUTtBQUNmO0FBQ0E7QUFDQSxTQUFTLDRCQUFROztBQUVqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMseUJBQUs7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUFRO0FBQzNCO0FBQ0EsYUFBYSwyQkFBTywyQkFBMkI7QUFDL0M7QUFDQTtBQUNBLElBQUksK0JBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBZSxPQUFPLEVBQUM7OztBQ2xEYTtBQUNBO0FBQ0U7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwyQkFBTzs7QUFFdkI7QUFDQSxNQUFNLFFBQU8sU0FBUyw0QkFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNldC5qcz9mNWI2Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUGlja0J5LmpzP2FkNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2lnblZhbHVlIGZyb20gJy4vX2Fzc2lnblZhbHVlLmpzJztcbmltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDEsXG4gICAgICBuZXN0ZWQgPSBvYmplY3Q7XG5cbiAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pLFxuICAgICAgICBuZXdWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgdmFyIG9ialZhbHVlID0gbmVzdGVkW2tleV07XG4gICAgICBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9ialZhbHVlLCBrZXksIG5lc3RlZCkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGlzT2JqZWN0KG9ialZhbHVlKVxuICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2V0O1xuIiwiaW1wb3J0IGJhc2VHZXQgZnJvbSAnLi9fYmFzZUdldC5qcyc7XG5pbXBvcnQgYmFzZVNldCBmcm9tICcuL19iYXNlU2V0LmpzJztcbmltcG9ydCBjYXN0UGF0aCBmcm9tICcuL19jYXN0UGF0aC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUGlja0J5O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///99354\n")},50053:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68675);\n\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_SYMBOLS_FLAG = 4;\n\n/**\n * Creates a shallow clone of `value`.\n *\n * **Note:** This method is loosely based on the\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n * arrays. The own enumerable properties of `arguments` objects are cloned\n * as plain objects. An empty object is returned for uncloneable values such\n * as error objects, functions, DOM nodes, and WeakMaps.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to clone.\n * @returns {*} Returns the cloned value.\n * @see _.cloneDeep\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var shallow = _.clone(objects);\n * console.log(shallow[0] === objects[0]);\n * // => true\n */\nfunction clone(value) {\n  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(value, CLONE_SYMBOLS_FLAG);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAwNTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUF3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsSUFBSSxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQVM7QUFDbEI7O0FBRUEsaUVBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY2xvbmUuanM/YjMwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZUNsb25lIGZyb20gJy4vX2Jhc2VDbG9uZS5qcyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsb25lO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50053\n")},23068:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24326);\n/* harmony import */ var _eq_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(66984);\n/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6832);\n/* harmony import */ var _keysIn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55615);\n\n\n\n\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(function(object, sources) {\n  object = Object(object);\n\n  var index = -1;\n  var length = sources.length;\n  var guard = length > 2 ? sources[2] : undefined;\n\n  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(sources[0], sources[1], guard)) {\n    length = 1;\n  }\n\n  while (++index < length) {\n    var source = sources[index];\n    var props = (0,_keysIn_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)(source);\n    var propsIndex = -1;\n    var propsLength = props.length;\n\n    while (++propsIndex < propsLength) {\n      var key = props[propsIndex];\n      var value = object[key];\n\n      if (value === undefined ||\n          ((0,_eq_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A)(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        object[key] = source[key];\n      }\n    }\n  }\n\n  return object;\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMwNjguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUNiO0FBQ3lCO0FBQ2pCOztBQUVqQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUTtBQUNoRCxXQUFXO0FBQ1g7QUFDQSxlQUFlLGlFQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVFQUFjO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQiwrREFBTTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMkRBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVmYXVsdHMuanM/NTQwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGVxIGZyb20gJy4vZXEuanMnO1xuaW1wb3J0IGlzSXRlcmF0ZWVDYWxsIGZyb20gJy4vX2lzSXRlcmF0ZWVDYWxsLmpzJztcbmltcG9ydCBrZXlzSW4gZnJvbSAnLi9rZXlzSW4uanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAqIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdFxuICogcmVzb2x2ZSB0byBgdW5kZWZpbmVkYC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmRlZmF1bHRzRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBkZWZhdWx0cyA9IGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMTtcbiAgdmFyIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoO1xuICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgbGVuZ3RoID0gMTtcbiAgfVxuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgIHZhciBwcm9wc0luZGV4ID0gLTE7XG4gICAgdmFyIHByb3BzTGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAoZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqZWN0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23068\n")},16145:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lodash_es_find)\n});\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseIteratee.js + 15 modules\nvar _baseIteratee = __webpack_require__(23958);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isArrayLike.js\nvar isArrayLike = __webpack_require__(38446);\n// EXTERNAL MODULE: ./node_modules/lodash-es/keys.js\nvar keys = __webpack_require__(27422);\n;// ./node_modules/lodash-es/_createFind.js\n\n\n\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!(0,isArrayLike/* default */.A)(collection)) {\n      var iteratee = (0,_baseIteratee/* default */.A)(predicate, 3);\n      collection = (0,keys/* default */.A)(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\n/* harmony default export */ const _createFind = (createFind);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_baseFindIndex.js\nvar _baseFindIndex = __webpack_require__(25707);\n// EXTERNAL MODULE: ./node_modules/lodash-es/toInteger.js\nvar toInteger = __webpack_require__(18593);\n;// ./node_modules/lodash-es/findIndex.js\n\n\n\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : (0,toInteger/* default */.A)(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return (0,_baseFindIndex/* default */.A)(array, (0,_baseIteratee/* default */.A)(predicate, 3), index);\n}\n\n/* harmony default export */ const lodash_es_findIndex = (findIndex);\n\n;// ./node_modules/lodash-es/find.js\n\n\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = _createFind(lodash_es_findIndex);\n\n/* harmony default export */ const lodash_es_find = (find);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxNDUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNIO0FBQ2Q7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOEJBQVc7QUFDcEIscUJBQXFCLGdDQUFZO0FBQ2pDLG1CQUFtQix1QkFBSTtBQUN2QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBZSxVQUFVLEVBQUM7Ozs7Ozs7QUN4QnNCO0FBQ0Y7QUFDUDs7QUFFdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLE9BQU8sb0NBQW9DO0FBQzNDLE9BQU8sb0NBQW9DO0FBQzNDLE9BQU87QUFDUDtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxTQUFTLGlDQUFhLFFBQVEsZ0NBQVk7QUFDMUM7O0FBRUEsMERBQWUsU0FBUyxFQUFDOzs7QUN0RGlCO0FBQ0g7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxPQUFPLDhDQUE4QztBQUNyRCxPQUFPLCtDQUErQztBQUN0RCxPQUFPO0FBQ1A7QUFDQTtBQUNBLCtCQUErQixvQkFBb0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVSxDQUFDLG1CQUFTOztBQUUvQixxREFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlRmluZC5qcz9mZDNmIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbmRJbmRleC5qcz9kOGI3Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZpbmQuanM/NmE5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUZpbmQ7XG4iLCJpbXBvcnQgYmFzZUZpbmRJbmRleCBmcm9tICcuL19iYXNlRmluZEluZGV4LmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmaW5kSW5kZXg7XG4iLCJpbXBvcnQgY3JlYXRlRmluZCBmcm9tICcuL19jcmVhdGVGaW5kLmpzJztcbmltcG9ydCBmaW5kSW5kZXggZnJvbSAnLi9maW5kSW5kZXguanMnO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16145\n")},34098:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13588);\n\n\n/**\n * Flattens `array` a single level deep.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to flatten.\n * @returns {Array} Returns the new flattened array.\n * @example\n *\n * _.flatten([1, [2, [3, [4]], 5]]);\n * // => [1, 2, [3, [4]], 5]\n */\nfunction flatten(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(array, 1) : [];\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatten);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQwOTguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9FQUFXO0FBQzdCOztBQUVBLGlFQUFlLE9BQU8sRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2ZsYXR0ZW4uanM/YzUxNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZUZsYXR0ZW4gZnJvbSAnLi9fYmFzZUZsYXR0ZW4uanMnO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmxhdHRlbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34098\n')},48585:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lodash_es_has)\n});\n\n;// ./node_modules/lodash-es/_baseHas.js\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar _baseHas_hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * The base implementation of `_.has` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHas(object, key) {\n  return object != null && _baseHas_hasOwnProperty.call(object, key);\n}\n\n/* harmony default export */ const _baseHas = (baseHas);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/_hasPath.js\nvar _hasPath = __webpack_require__(85054);\n;// ./node_modules/lodash-es/has.js\n\n\n\n/**\n * Checks if `path` is a direct property of `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = { 'a': { 'b': 2 } };\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.has(object, 'a');\n * // => true\n *\n * _.has(object, 'a.b');\n * // => true\n *\n * _.has(object, ['a', 'b']);\n * // => true\n *\n * _.has(other, 'a');\n * // => false\n */\nfunction has(object, path) {\n  return object != null && (0,_hasPath/* default */.A)(object, path, _baseHas);\n}\n\n/* harmony default export */ const lodash_es_has = (has);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg1ODUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLHVCQUFjOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQWM7QUFDekM7O0FBRUEsK0NBQWUsT0FBTyxFQUFDOzs7OztBQ2xCYTtBQUNBOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGNBQWM7QUFDekIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QiwwQkFBMEIsZ0JBQWdCLFFBQVEsR0FBRztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUFPLGVBQWUsUUFBTztBQUN4RDs7QUFFQSxvREFBZSxHQUFHLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUhhcy5qcz9mZWRjIiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hhcy5qcz9lMTJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUhhcztcbiIsImltcG9ydCBiYXNlSGFzIGZyb20gJy4vX2Jhc2VIYXMuanMnO1xuaW1wb3J0IGhhc1BhdGggZnJvbSAnLi9faGFzUGF0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoYXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48585\n")},9703:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88496);\n/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92049);\n/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53098);\n\n\n\n\n/** `Object#toString` result references. */\nvar stringTag = '[object String]';\n\n/**\n * Checks if `value` is classified as a `String` primitive or object.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n * @example\n *\n * _.isString('abc');\n * // => true\n *\n * _.isString(1);\n * // => false\n */\nfunction isString(value) {\n  return typeof value == 'string' ||\n    (!(0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(value) && (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A)(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A)(value) == stringTag);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isString);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcwMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7QUFDUDtBQUNVOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnRUFBTyxXQUFXLHFFQUFZLFdBQVcsbUVBQVU7QUFDekQ7O0FBRUEsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmVnYWwtdWktZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNTdHJpbmcuanM/MjU0NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTdHJpbmcoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgKCFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9703\n")},26666:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * Gets the last element of `array`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to query.\n * @returns {*} Returns the last element of `array`.\n * @example\n *\n * _.last([1, 2, 3]);\n * // => 3\n */\nfunction last(array) {\n  var length = array == null ? 0 : array.length;\n  return length ? array[length - 1] : undefined;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (last);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY2NjYuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9sYXN0LmpzP2VlMDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGxhc3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26666\n")},74722:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45572);\n/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23958);\n/* harmony import */ var _baseMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52568);\n/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92049);\n\n\n\n\n\n/**\n * Creates an array of values by running each element in `collection` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, index|key, collection).\n *\n * Many lodash methods are guarded to work as iteratees for methods like\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n *\n * The guarded methods are:\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n * @example\n *\n * function square(n) {\n *   return n * n;\n * }\n *\n * _.map([4, 8], square);\n * // => [16, 64]\n *\n * _.map({ 'a': 4, 'b': 8 }, square);\n * // => [16, 64] (iteration order is not guaranteed)\n *\n * var users = [\n *   { 'user': 'barney' },\n *   { 'user': 'fred' }\n * ];\n *\n * // The `_.property` iteratee shorthand.\n * _.map(users, 'user');\n * // => ['barney', 'fred']\n */\nfunction map(collection, iteratee) {\n  var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(collection) ? _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__/* [\"default\"] */ .A : _baseMap_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A;\n  return func(collection, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A)(iteratee, 3));\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (map);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQ3MjIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFzQztBQUNRO0FBQ1Y7QUFDRDs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsVUFBVTtBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTyxrQkFBa0I7QUFDekIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnRUFBTyxlQUFlLDZEQUFRLEdBQUcsNERBQU87QUFDckQsMEJBQTBCLHFFQUFZO0FBQ3RDOztBQUVBLGlFQUFlLEdBQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21hcC5qcz8zMjdiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZU1hcCBmcm9tICcuL19iYXNlTWFwLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIE1hbnkgbG9kYXNoIG1ldGhvZHMgYXJlIGd1YXJkZWQgdG8gd29yayBhcyBpdGVyYXRlZXMgZm9yIG1ldGhvZHMgbGlrZVxuICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICogYGZpbGxgLCBgaW52ZXJ0YCwgYHBhcnNlSW50YCwgYHJhbmRvbWAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlcGVhdGAsXG4gKiBgc2FtcGxlU2l6ZWAsIGBzbGljZWAsIGBzb21lYCwgYHNvcnRCeWAsIGBzcGxpdGAsIGB0YWtlYCwgYHRha2VSaWdodGAsXG4gKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICogICByZXR1cm4gbiAqIG47XG4gKiB9XG4gKlxuICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICogLy8gPT4gWzE2LCA2NF1cbiAqXG4gKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICogLy8gPT4gWydiYXJuZXknLCAnZnJlZCddXG4gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheU1hcCA6IGJhc2VNYXA7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74722\n")},86452:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(72559);\n/* harmony import */ var _baseLt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36224);\n/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29008);\n\n\n\n\n/**\n * Computes the minimum value of `array`. If `array` is empty or falsey,\n * `undefined` is returned.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Math\n * @param {Array} array The array to iterate over.\n * @returns {*} Returns the minimum value.\n * @example\n *\n * _.min([4, 2, 8, 6]);\n * // => 2\n *\n * _.min([]);\n * // => undefined\n */\nfunction min(array) {\n  return (array && array.length)\n    ? (0,_baseExtremum_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A)(array, _identity_js__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A, _baseLt_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)\n    : undefined;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (min);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODY0NTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQThDO0FBQ1o7QUFDRzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFFQUFZLFFBQVEsNkRBQVEsRUFBRSwyREFBTTtBQUMxQztBQUNBOztBQUVBLGlFQUFlLEdBQUcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL21pbi5qcz9lODMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiYXNlRXh0cmVtdW0gZnJvbSAnLi9fYmFzZUV4dHJlbXVtLmpzJztcbmltcG9ydCBiYXNlTHQgZnJvbSAnLi9fYmFzZUx0LmpzJztcbmltcG9ydCBpZGVudGl0eSBmcm9tICcuL2lkZW50aXR5LmpzJztcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWluKFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5taW4oW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1pbihhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWluO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86452\n')},74342:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ lodash_es_toFinite)\n});\n\n;// ./node_modules/lodash-es/_trimmedEndIndex.js\n/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\n/* harmony default export */ const _trimmedEndIndex = (trimmedEndIndex);\n\n;// ./node_modules/lodash-es/_baseTrim.js\n\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\n/* harmony default export */ const _baseTrim = (baseTrim);\n\n// EXTERNAL MODULE: ./node_modules/lodash-es/isObject.js\nvar isObject = __webpack_require__(23149);\n// EXTERNAL MODULE: ./node_modules/lodash-es/isSymbol.js\nvar isSymbol = __webpack_require__(61882);\n;// ./node_modules/lodash-es/toNumber.js\n\n\n\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if ((0,isSymbol/* default */.A)(value)) {\n    return NAN;\n  }\n  if ((0,isObject/* default */.A)(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = (0,isObject/* default */.A)(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = _baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/* harmony default export */ const lodash_es_toNumber = (toNumber);\n\n;// ./node_modules/lodash-es/toFinite.js\n\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = lodash_es_toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/* harmony default export */ const lodash_es_toFinite = (toFinite);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQzNDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1REFBZSxlQUFlLEVBQUM7OztBQ2xCcUI7O0FBRXBEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZTtBQUNyQztBQUNBOztBQUVBLGdEQUFlLFFBQVEsRUFBQzs7Ozs7OztBQ2xCYztBQUNEO0FBQ0E7O0FBRXJDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDJCQUFRO0FBQ2Q7QUFDQTtBQUNBLE1BQU0sMkJBQVE7QUFDZDtBQUNBLFlBQVksMkJBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBZSxRQUFRLEVBQUM7OztBQy9EYTs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0JBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanM/YzA2ZSIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRyaW0uanM/YTVhMyIsIndlYnBhY2s6Ly9yZWdhbC11aS1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcz8wZjM3Iiwid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvRmluaXRlLmpzP2VhOWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZGVmYXVsdCB0cmltbWVkRW5kSW5kZXg7XG4iLCJpbXBvcnQgdHJpbW1lZEVuZEluZGV4IGZyb20gJy4vX3RyaW1tZWRFbmRJbmRleC5qcyc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRyaW07XG4iLCJpbXBvcnQgYmFzZVRyaW0gZnJvbSAnLi9fYmFzZVRyaW0uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCJpbXBvcnQgdG9OdW1iZXIgZnJvbSAnLi90b051bWJlci5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwODtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b0Zpbml0ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74342\n")},18593:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _toFinite_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74342);\n\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = (0,_toFinite_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A)(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toInteger);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1OTMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRUFBUTtBQUN2Qjs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLFNBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3JlZ2FsLXVpLWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3RvSW50ZWdlci5qcz81MWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b0Zpbml0ZSBmcm9tICcuL3RvRmluaXRlLmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9JbnRlZ2VyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18593\n")}}]);